{"time":2581,"results":[{"type":"loop-calculation","before":"uint pendingTime;","after":"// move outside for loop\nuint pendingTime;","loc":{"start":{"line":571,"column":12},"end":{"line":571,"column":28}},"contract":"Claims","time":0},{"type":"struct-data-arrangement ","before":"\naddress voter\nuint tokens\nuint claimId\nint8 verdict\nbool rewardClaimed","after":"uint tokens\nuint claimId\naddress voter\nint8 verdict\nbool rewardClaimed\n","contract":"ClaimsData","time":0},{"type":"loop-duplication","before":"\nstart line 4090 column 8, end line 4125 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n\n            voteid = cd.getVoteAddressCA(msg.sender, i);\n\n            (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\n\n            if (lastClaimed == lengthVote && lastClaimedCheck == true)\n\n                lastClaimed = i;\n\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n\n            if (perc > 0 && !claimed) {\n\n                counter++;\n\n                cd.setRewardClaimed(voteid, true);\n\n            } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\n\n                (perc,,) = cd.getClaimRewardDetail(claimId);\n\n                if (perc == 0)\n\n                    counter++;\n\n                cd.setRewardClaimed(voteid, true);\n\n            }\n\n            if (tokenForVoteId > 0)\n\n                total = tokenForVoteId.add(total);\n\n        }\nstart line 4151 column 8, end line 4175 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n\n            voteid = cd.getVoteAddressMember(msg.sender, i);\n\n            (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\n\n            if (lastClaimed == lengthVote && lastClaimedCheck == true)\n\n                lastClaimed = i;\n\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n            if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\n\n                cd.setRewardClaimed(voteid, true);\n\n                counter++;\n\n            }\n\n            if (tokenForVoteId > 0)\n\n                total = tokenForVoteId.add(total);\n\n        }","after":"// merge loop\n\nstart line 4090 column 8, end line 4125 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n\n            voteid = cd.getVoteAddressCA(msg.sender, i);\n\n            (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\n\n            if (lastClaimed == lengthVote && lastClaimedCheck == true)\n\n                lastClaimed = i;\n\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n\n            if (perc > 0 && !claimed) {\n\n                counter++;\n\n                cd.setRewardClaimed(voteid, true);\n\n            } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\n\n                (perc,,) = cd.getClaimRewardDetail(claimId);\n\n                if (perc == 0)\n\n                    counter++;\n\n                cd.setRewardClaimed(voteid, true);\n\n            }\n\n            if (tokenForVoteId > 0)\n\n                total = tokenForVoteId.add(total);\n\n        }\nstart line 4151 column 8, end line 4175 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n\n            voteid = cd.getVoteAddressMember(msg.sender, i);\n\n            (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\n\n            if (lastClaimed == lengthVote && lastClaimedCheck == true)\n\n                lastClaimed = i;\n\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n            if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\n\n                cd.setRewardClaimed(voteid, true);\n\n                counter++;\n\n            }\n\n            if (tokenForVoteId > 0)\n\n                total = tokenForVoteId.add(total);\n\n        }","contract":"ClaimsReward","time":0},{"type":"constant-restrict-modification  ","before":"address public tokenAddress;","after":"address public constant tokenAddress;","contract":"INXMMaster","time":0},{"type":"constant-restrict-modification  ","before":"address public owner;","after":"address public constant owner;","contract":"INXMMaster","time":1},{"type":"constant-restrict-modification  ","before":"uint public pauseTime;","after":"uint public constant pauseTime;","contract":"INXMMaster","time":1},{"type":"state-data-arrangement ","before":"\nTokenController public dAppToken;\nTokenData internal td;\nQuotationData internal qd;\nClaimsReward internal cr;\nGovernance internal gv;\nTokenFunctions internal tf;\nNXMToken public tk;\nMemberRoleDetails[] internal memberRoleData;\nbool internal constructorCheck;\nuint public maxABCount;\nbool public launched;\nuint public launchedOn;","after":"TokenController public dAppToken;\nTokenData internal td;\nQuotationData internal qd;\nClaimsReward internal cr;\nGovernance internal gv;\nTokenFunctions internal tf;\nNXMToken public tk;\nMemberRoleDetails[] internal memberRoleData;\nuint public maxABCount;\nuint public launchedOn;\nbool internal constructorCheck;\nbool public launched;\n","contract":"MemberRoles","time":0},{"type":"external-function ","before":"function addRole(//solhint-disable-line\n\n        bytes32 _roleName,\n\n        string memory _roleDescription,\n\n        address _authorized\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern {\n\n        _addRole(_roleName, _roleDescription, _authorized);\n\n    }","after":"function addRole(//solhint-disable-line\n\n        bytes32 _roleName,\n\n        string calldata _roleDescription,\n\n        address _authorized\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern {\n\n        _addRole(_roleName, _roleDescription, _authorized);\n\n    }","contract":"MemberRoles","time":0},{"type":"external-function ","before":"function addMembersBeforeLaunch(address[] memory userArray, uint[] memory tokens) public onlyOwner {\n\n        require(!launched);\n\n\n        for (uint i = 0; i < userArray.length; i++) {\n\n            require(!ms.isMember(userArray[i]));\n\n            dAppToken.addToWhitelist(userArray[i]);\n\n            _updateRole(userArray[i], uint(Role.Member), true);\n\n            dAppToken.mint(userArray[i], tokens[i]);\n\n        }\n\n        launched = true;\n\n        launchedOn = now;\n\n\n    }","after":"function addMembersBeforeLaunch(address[] calldata userArray, uint[] calldata tokens) public onlyOwner {\n\n        require(!launched);\n\n\n        for (uint i = 0; i < userArray.length; i++) {\n\n            require(!ms.isMember(userArray[i]));\n\n            dAppToken.addToWhitelist(userArray[i]);\n\n            _updateRole(userArray[i], uint(Role.Member), true);\n\n            dAppToken.mint(userArray[i], tokens[i]);\n\n        }\n\n        launched = true;\n\n        launchedOn = now;\n\n\n    }","contract":"MemberRoles","time":0},{"type":"constant-restrict-modification  ","before":"string public name = \"NXM\";","after":"string public constant name = \"NXM\";","contract":"NXMToken","time":0},{"type":"constant-restrict-modification  ","before":"string public symbol = \"NXM\";","after":"string public constant symbol = \"NXM\";","contract":"NXMToken","time":0},{"type":"constant-restrict-modification  ","before":"uint8 public decimals = 18;","after":"uint8 public constant decimals = 18;","contract":"NXMToken","time":0},{"type":"external-function ","before":"function makeCoverBegin(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] memory coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    isMember\n\n    checkPause\n\n    payable\n\n    {\n\n        require(msg.value == coverDetails[1]);\n\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","after":"function makeCoverBegin(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] calldata coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    isMember\n\n    checkPause\n\n    payable\n\n    {\n\n        require(msg.value == coverDetails[1]);\n\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","contract":"Pool1","time":0},{"type":"external-function ","before":"function makeCoverUsingCA(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] memory coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    isMember\n\n    checkPause\n\n    {\n\n        IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n\n        require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]), \"Transfer failed\");\n\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","after":"function makeCoverUsingCA(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] calldata coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    isMember\n\n    checkPause\n\n    {\n\n        IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n\n        require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]), \"Transfer failed\");\n\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","contract":"Pool1","time":0},{"type":"state-data-arrangement ","before":"\nMCR internal m1;\nPool1 internal p1;\nPoolData internal pd;\nFactory internal factory;\naddress public uniswapFactoryAddress;\nuint internal constant DECIMAL1E18 = uint(10) ** 18;\nbool internal locked;","after":"MCR internal m1;\nPool1 internal p1;\nPoolData internal pd;\nFactory internal factory;\nuint internal constant DECIMAL1E18 = uint(10) ** 18;\naddress public uniswapFactoryAddress;\nbool internal locked;\n","contract":"Pool2","time":0},{"type":"state-data-arrangement ","before":"\nIARankDetails[] internal allIARankDetails;\nMcrData[] public allMCRData;\nbytes4[] internal allInvestmentCurrencies;\nbytes4[] internal allCurrencies;\nbytes32[] public allAPIcall;\nmapping(bytes32 => ApiId) public allAPIid;\nmapping(uint64 => uint) internal datewiseId;\nmapping(bytes16 => uint) internal currencyLastIndex;\nmapping(bytes4 => CurrencyAssets) internal allCurrencyAssets;\nmapping(bytes4 => InvestmentAssets) internal allInvestmentAssets;\nmapping(bytes4 => uint) internal caAvgRate;\nmapping(bytes4 => uint) internal iaAvgRate;\naddress public notariseMCR;\naddress public daiFeedAddress;\nuint private constant DECIMAL1E18 = uint(10) ** 18;\nuint public uniswapDeadline;\nuint public liquidityTradeCallbackTime;\nuint public lastLiquidityTradeTrigger;\nuint64 internal lastDate;\nuint public variationPercX100;\nuint public iaRatesTime;\nuint public minCap;\nuint public mcrTime;\nuint public a;\nuint public shockParameter;\nuint public c;\nuint public mcrFailTime;\nuint public ethVolumeLimit;\nuint public capReached;\nuint public capacityLimit;","after":"IARankDetails[] internal allIARankDetails;\nMcrData[] public allMCRData;\nbytes4[] internal allInvestmentCurrencies;\nbytes4[] internal allCurrencies;\nbytes32[] public allAPIcall;\nmapping(bytes32 => ApiId) public allAPIid;\nmapping(uint64 => uint) internal datewiseId;\nmapping(bytes16 => uint) internal currencyLastIndex;\nmapping(bytes4 => CurrencyAssets) internal allCurrencyAssets;\nmapping(bytes4 => InvestmentAssets) internal allInvestmentAssets;\nmapping(bytes4 => uint) internal caAvgRate;\nmapping(bytes4 => uint) internal iaAvgRate;\nuint private constant DECIMAL1E18 = uint(10) ** 18;\nuint public uniswapDeadline;\nuint public liquidityTradeCallbackTime;\nuint public lastLiquidityTradeTrigger;\nuint public variationPercX100;\nuint public iaRatesTime;\nuint public minCap;\nuint public mcrTime;\nuint public a;\nuint public shockParameter;\nuint public c;\nuint public mcrFailTime;\nuint public ethVolumeLimit;\nuint public capReached;\nuint public capacityLimit;\naddress public notariseMCR;\naddress public daiFeedAddress;\nuint64 internal lastDate;\n","contract":"PoolData","time":0},{"type":"struct-data-arrangement ","before":"\nbytes4 typeOf\nbytes4 currency\nuint id\nuint64 dateAdd\nuint64 dateUpd","after":"uint id\nuint64 dateAdd\nuint64 dateUpd\nbytes4 typeOf\nbytes4 currency\n","contract":"PoolData","time":0},{"type":"external-function ","before":"function updateCategory(\n\n        uint _categoryId,\n\n        string memory _name,\n\n        uint _memberRoleToVote,\n\n        uint _majorityVotePerc,\n\n        uint _quorumPerc,\n\n        uint[] memory _allowedToCreateProposal,\n\n        uint _closingTime,\n\n        string memory _actionHash,\n\n        address _contractAddress,\n\n        bytes2 _contractName,\n\n        uint[] memory _incentives\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern\n\n    {\n\n        require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 0, \"Invalid Role\");\n\n        allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\n\n        allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\n\n        allCategory[_categoryId].closingTime = _closingTime;\n\n        allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\n\n        allCategory[_categoryId].minStake = _incentives[0];\n\n        allCategory[_categoryId].quorumPerc = _quorumPerc;\n\n        categoryActionData[_categoryId].defaultIncentive = _incentives[1];\n\n        categoryActionData[_categoryId].contractName = _contractName;\n\n        categoryActionData[_categoryId].contractAddress = _contractAddress;\n\n        categoryABReq[_categoryId] = _incentives[2];\n\n        emit Category(_categoryId, _name, _actionHash);\n\n    }","after":"function updateCategory(\n\n        uint _categoryId,\n\n        string calldata _name,\n\n        uint _memberRoleToVote,\n\n        uint _majorityVotePerc,\n\n        uint _quorumPerc,\n\n        uint[] calldata _allowedToCreateProposal,\n\n        uint _closingTime,\n\n        string calldata _actionHash,\n\n        address _contractAddress,\n\n        bytes2 _contractName,\n\n        uint[] calldata _incentives\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern\n\n    {\n\n        require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 0, \"Invalid Role\");\n\n        allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\n\n        allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\n\n        allCategory[_categoryId].closingTime = _closingTime;\n\n        allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\n\n        allCategory[_categoryId].minStake = _incentives[0];\n\n        allCategory[_categoryId].quorumPerc = _quorumPerc;\n\n        categoryActionData[_categoryId].defaultIncentive = _incentives[1];\n\n        categoryActionData[_categoryId].contractName = _contractName;\n\n        categoryActionData[_categoryId].contractAddress = _contractAddress;\n\n        categoryABReq[_categoryId] = _incentives[2];\n\n        emit Category(_categoryId, _name, _actionHash);\n\n    }","contract":"ProposalCategory","time":0},{"type":"external-function ","before":"function makeCoverUsingNXMTokens(\n\n        uint[] memory coverDetails,\n\n        uint16 coverPeriod,\n\n        bytes4 coverCurr,\n\n        address smartCAdd,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    isMemberAndcheckPause\n\n    {\n\n\n        tc.burnFrom(msg.sender, coverDetails[2]);\n        //need burn allowance\n\n        _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","after":"function makeCoverUsingNXMTokens(\n\n        uint[] calldata coverDetails,\n\n        uint16 coverPeriod,\n\n        bytes4 coverCurr,\n\n        address smartCAdd,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    isMemberAndcheckPause\n\n    {\n\n\n        tc.burnFrom(msg.sender, coverDetails[2]);\n        //need burn allowance\n\n        _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","contract":"Quotation","time":0},{"type":"external-function ","before":"function verifyCoverDetails(\n\n        address payable from,\n\n        address scAddress,\n\n        bytes4 coverCurr,\n\n        uint[] memory coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    onlyInternal\n\n    {\n\n        _verifyCoverDetails(\n\n            from,\n\n            scAddress,\n\n            coverCurr,\n\n            coverDetails,\n\n            coverPeriod,\n\n            _v,\n\n            _r,\n\n            _s\n\n        );\n\n    }","after":"function verifyCoverDetails(\n\n        address payable from,\n\n        address scAddress,\n\n        bytes4 coverCurr,\n\n        uint[] calldata coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    onlyInternal\n\n    {\n\n        _verifyCoverDetails(\n\n            from,\n\n            scAddress,\n\n            coverCurr,\n\n            coverDetails,\n\n            coverPeriod,\n\n            _v,\n\n            _r,\n\n            _s\n\n        );\n\n    }","contract":"Quotation","time":0},{"type":"external-function ","before":"function initiateMembershipAndCover(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] memory coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    payable\n\n    checkPause\n\n    {\n\n        require(coverDetails[3] > now);\n\n        require(!qd.timestampRepeated(coverDetails[4]));\n\n        qd.setTimestampRepeated(coverDetails[4]);\n\n        require(!ms.isMember(msg.sender));\n\n        require(qd.refundEligible(msg.sender) == false);\n\n        uint joinFee = td.joiningFee();\n\n        uint totalFee = joinFee;\n\n        if (coverCurr == \"ETH\") {\n\n            totalFee = joinFee.add(coverDetails[1]);\n\n        } else {\n\n            IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n\n            require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]));\n\n        }\n\n        require(msg.value == totalFee);\n\n        require(verifySign(coverDetails, coverPeriod, coverCurr, smartCAdd, _v, _r, _s));\n\n        qd.addHoldCover(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod);\n\n        qd.setRefundEligible(msg.sender, true);\n\n    }","after":"function initiateMembershipAndCover(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] calldata coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    payable\n\n    checkPause\n\n    {\n\n        require(coverDetails[3] > now);\n\n        require(!qd.timestampRepeated(coverDetails[4]));\n\n        qd.setTimestampRepeated(coverDetails[4]);\n\n        require(!ms.isMember(msg.sender));\n\n        require(qd.refundEligible(msg.sender) == false);\n\n        uint joinFee = td.joiningFee();\n\n        uint totalFee = joinFee;\n\n        if (coverCurr == \"ETH\") {\n\n            totalFee = joinFee.add(coverDetails[1]);\n\n        } else {\n\n            IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n\n            require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]));\n\n        }\n\n        require(msg.value == totalFee);\n\n        require(verifySign(coverDetails, coverPeriod, coverCurr, smartCAdd, _v, _r, _s));\n\n        qd.addHoldCover(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod);\n\n        qd.setRefundEligible(msg.sender, true);\n\n    }","contract":"Quotation","time":0},{"type":"struct-data-arrangement ","before":"\naddress payable memberAddress\nbytes4 currencyCode\nuint sumAssured\nuint16 coverPeriod\nuint validUntil\naddress scAddress\nuint premiumNXM","after":"uint sumAssured\nuint validUntil\nuint premiumNXM\naddress payable memberAddress\naddress scAddress\nbytes4 currencyCode\nuint16 coverPeriod\n","contract":"QuotationData","time":0},{"type":"struct-data-arrangement ","before":"\nuint holdCoverId\naddress payable userAddress\naddress scAddress\nbytes4 coverCurr\nuint[] coverDetails\nuint16 coverPeriod","after":"uint holdCoverId\nuint[] coverDetails\naddress payable userAddress\naddress scAddress\nbytes4 coverCurr\nuint16 coverPeriod\n","contract":"QuotationData","time":0},{"type":"constant-restrict-modification  ","before":"address public cbAddress;","after":"address public constant cbAddress;","contract":"OraclizeI","time":0},{"type":"state-data-arrangement ","before":"\nOraclizeI oraclize;\nOraclizeAddrResolverI OAR;\nuint constant day = 60 * 60 * 24;\nuint constant week = 60 * 60 * 24 * 7;\nuint constant month = 60 * 60 * 24 * 30;\nbyte constant proofType_NONE = 0x00;\nbyte constant proofType_Ledger = 0x30;\nbyte constant proofType_Native = 0xF0;\nbyte constant proofStorage_IPFS = 0x01;\nbyte constant proofType_Android = 0x40;\nbyte constant proofType_TLSNotary = 0x10;\nstring oraclize_network_name;\nuint8 constant networkID_auto = 0;\nuint8 constant networkID_morden = 2;\nuint8 constant networkID_mainnet = 1;\nuint8 constant networkID_testnet = 2;\nuint8 constant networkID_consensys = 161;\nmapping(bytes32 => bytes32) oraclize_randomDS_args;\nmapping(bytes32 => bool) oraclize_randomDS_sessionKeysHashVerified;","after":"OraclizeI oraclize;\nOraclizeAddrResolverI OAR;\nuint constant day = 60 * 60 * 24;\nuint constant week = 60 * 60 * 24 * 7;\nuint constant month = 60 * 60 * 24 * 30;\nstring oraclize_network_name;\nmapping(bytes32 => bytes32) oraclize_randomDS_args;\nmapping(bytes32 => bool) oraclize_randomDS_sessionKeysHashVerified;\nbyte constant proofType_NONE = 0x00;\nbyte constant proofType_Ledger = 0x30;\nbyte constant proofType_Native = 0xF0;\nbyte constant proofStorage_IPFS = 0x01;\nbyte constant proofType_Android = 0x40;\nbyte constant proofType_TLSNotary = 0x10;\nuint8 constant networkID_auto = 0;\nuint8 constant networkID_morden = 2;\nuint8 constant networkID_mainnet = 1;\nuint8 constant networkID_testnet = 2;\nuint8 constant networkID_consensys = 161;\n","contract":"usingOraclize","time":0}]}