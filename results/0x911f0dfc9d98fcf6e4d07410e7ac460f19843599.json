{"time":567,"results":[{"type":"external-function ","before":"function payFinalFees(address payer, FixedPoint.Unsigned memory amount)\n    external\n    onlyThisContract\n    {\n        _payFinalFees(payer, amount);\n    }","after":"function payFinalFees(address payer, FixedPoint.Unsigned calldata amount)\n    external\n    onlyThisContract\n    {\n        _payFinalFees(payer, amount);\n    }","contract":"FeePayerParty","time":0},{"type":"immutable-restrict-modification ","before":"address public timerAddress;","after":"address public immutable timerAddress;","contract":"FeePayerParty","time":0},{"type":"external-function ","before":"function payRegularFees(\n        FeePayerParty.FeePayerData storage feePayerData,\n        StoreInterface store,\n        uint256 time,\n        FixedPoint.Unsigned memory collateralPool\n    ) external returns (FixedPoint.Unsigned memory totalPaid) {\n        // Exit early if there is no collateral from which to pay fees.\n        if (collateralPool.isEqual(0)) {\n            // Note: set the lastPaymentTime in this case so the contract is credited for paying during periods when it\n            // has no locked collateral.\n            feePayerData.lastPaymentTime = time;\n            return totalPaid;\n        }\n\n        // Exit early if fees were already paid during this block.\n        if (feePayerData.lastPaymentTime == time) {\n            return totalPaid;\n        }\n\n        FixedPoint.Unsigned memory regularFee;\n        FixedPoint.Unsigned memory latePenalty;\n\n        (regularFee, latePenalty) = store.computeRegularFee(\n            feePayerData.lastPaymentTime,\n            time,\n            collateralPool\n        );\n        feePayerData.lastPaymentTime = time;\n\n        totalPaid = regularFee.add(latePenalty);\n        if (totalPaid.isEqual(0)) {\n            return totalPaid;\n        }\n\n        // If the effective fees paid as a % of the pfc is > 100%, then we need to reduce it and make the contract pay\n        // as much of the fee that it can (up to 100% of its pfc). We'll reduce the late penalty first and then the\n        // regular fee, which has the effect of paying the store first, followed by the caller if there is any fee remaining.\n        if (totalPaid.isGreaterThan(collateralPool)) {\n            FixedPoint.Unsigned memory deficit = totalPaid.sub(collateralPool);\n            FixedPoint.Unsigned memory latePenaltyReduction =\n            FixedPoint.min(latePenalty, deficit);\n            latePenalty = latePenalty.sub(latePenaltyReduction);\n            deficit = deficit.sub(latePenaltyReduction);\n            regularFee = regularFee.sub(FixedPoint.min(regularFee, deficit));\n            totalPaid = collateralPool;\n        }\n\n        emit RegularFeesPaid(regularFee.rawValue, latePenalty.rawValue);\n\n        feePayerData.cumulativeFeeMultiplier._adjustCumulativeFeeMultiplier(\n            totalPaid,\n            collateralPool\n        );\n\n        if (regularFee.isGreaterThan(0)) {\n            feePayerData.collateralCurrency.safeIncreaseAllowance(\n                address(store),\n                regularFee.rawValue\n            );\n            store.payOracleFeesErc20(\n                address(feePayerData.collateralCurrency),\n                regularFee\n            );\n        }\n\n        if (latePenalty.isGreaterThan(0)) {\n            feePayerData.collateralCurrency.safeTransfer(\n                msg.sender,\n                latePenalty.rawValue\n            );\n        }\n        return totalPaid;\n    }","after":"function payRegularFees(\n        FeePayerParty.FeePayerData storage feePayerData,\n        StoreInterface store,\n        uint256 time,\n        FixedPoint.Unsigned calldata collateralPool\n    ) external returns (FixedPoint.Unsigned memory totalPaid) {\n        // Exit early if there is no collateral from which to pay fees.\n        if (collateralPool.isEqual(0)) {\n            // Note: set the lastPaymentTime in this case so the contract is credited for paying during periods when it\n            // has no locked collateral.\n            feePayerData.lastPaymentTime = time;\n            return totalPaid;\n        }\n\n        // Exit early if fees were already paid during this block.\n        if (feePayerData.lastPaymentTime == time) {\n            return totalPaid;\n        }\n\n        FixedPoint.Unsigned memory regularFee;\n        FixedPoint.Unsigned memory latePenalty;\n\n        (regularFee, latePenalty) = store.computeRegularFee(\n            feePayerData.lastPaymentTime,\n            time,\n            collateralPool\n        );\n        feePayerData.lastPaymentTime = time;\n\n        totalPaid = regularFee.add(latePenalty);\n        if (totalPaid.isEqual(0)) {\n            return totalPaid;\n        }\n\n        // If the effective fees paid as a % of the pfc is > 100%, then we need to reduce it and make the contract pay\n        // as much of the fee that it can (up to 100% of its pfc). We'll reduce the late penalty first and then the\n        // regular fee, which has the effect of paying the store first, followed by the caller if there is any fee remaining.\n        if (totalPaid.isGreaterThan(collateralPool)) {\n            FixedPoint.Unsigned memory deficit = totalPaid.sub(collateralPool);\n            FixedPoint.Unsigned memory latePenaltyReduction =\n            FixedPoint.min(latePenalty, deficit);\n            latePenalty = latePenalty.sub(latePenaltyReduction);\n            deficit = deficit.sub(latePenaltyReduction);\n            regularFee = regularFee.sub(FixedPoint.min(regularFee, deficit));\n            totalPaid = collateralPool;\n        }\n\n        emit RegularFeesPaid(regularFee.rawValue, latePenalty.rawValue);\n\n        feePayerData.cumulativeFeeMultiplier._adjustCumulativeFeeMultiplier(\n            totalPaid,\n            collateralPool\n        );\n\n        if (regularFee.isGreaterThan(0)) {\n            feePayerData.collateralCurrency.safeIncreaseAllowance(\n                address(store),\n                regularFee.rawValue\n            );\n            store.payOracleFeesErc20(\n                address(feePayerData.collateralCurrency),\n                regularFee\n            );\n        }\n\n        if (latePenalty.isGreaterThan(0)) {\n            feePayerData.collateralCurrency.safeTransfer(\n                msg.sender,\n                latePenalty.rawValue\n            );\n        }\n        return totalPaid;\n    }","contract":"FeePayerPartyLib","time":0},{"type":"external-function ","before":"function payFinalFees(\n        FeePayerParty.FeePayerData storage feePayerData,\n        StoreInterface store,\n        address payer,\n        FixedPoint.Unsigned memory amount\n    ) external {\n        if (amount.isEqual(0)) {\n            return;\n        }\n\n        // Pull the collateral from the payer.\n        feePayerData.collateralCurrency.safeTransferFrom(\n            payer,\n            address(this),\n            amount.rawValue\n        );\n\n        emit FinalFeesPaid(amount.rawValue);\n\n        feePayerData.collateralCurrency.safeIncreaseAllowance(\n            address(store),\n            amount.rawValue\n        );\n        store.payOracleFeesErc20(address(feePayerData.collateralCurrency), amount);\n    }","after":"function payFinalFees(\n        FeePayerParty.FeePayerData storage feePayerData,\n        StoreInterface store,\n        address payer,\n        FixedPoint.Unsigned calldata amount\n    ) external {\n        if (amount.isEqual(0)) {\n            return;\n        }\n\n        // Pull the collateral from the payer.\n        feePayerData.collateralCurrency.safeTransferFrom(\n            payer,\n            address(this),\n            amount.rawValue\n        );\n\n        emit FinalFeesPaid(amount.rawValue);\n\n        feePayerData.collateralCurrency.safeIncreaseAllowance(\n            address(store),\n            amount.rawValue\n        );\n        store.payOracleFeesErc20(address(feePayerData.collateralCurrency), amount);\n    }","contract":"FeePayerPartyLib","time":0},{"type":"external-function ","before":"function getFeeAdjustedCollateral(\n        FixedPoint.Unsigned memory rawCollateral,\n        FixedPoint.Unsigned memory cumulativeFeeMultiplier\n    ) external pure returns (FixedPoint.Unsigned memory collateral) {\n        return rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\n    }","after":"function getFeeAdjustedCollateral(\n        FixedPoint.Unsigned calldata rawCollateral,\n        FixedPoint.Unsigned calldata cumulativeFeeMultiplier\n    ) external pure returns (FixedPoint.Unsigned memory collateral) {\n        return rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\n    }","contract":"FeePayerPartyLib","time":0},{"type":"external-function ","before":"function removeCollateral(\n        FixedPoint.Unsigned storage rawCollateral,\n        FixedPoint.Unsigned memory collateralToRemove,\n        FixedPoint.Unsigned memory cumulativeFeeMultiplier\n    ) external returns (FixedPoint.Unsigned memory removedCollateral) {\n        FixedPoint.Unsigned memory initialBalance =\n        rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\n        FixedPoint.Unsigned memory adjustedCollateral =\n        collateralToRemove._convertToRawCollateral(cumulativeFeeMultiplier);\n        rawCollateral.rawValue = rawCollateral.sub(adjustedCollateral).rawValue;\n        removedCollateral = initialBalance.sub(\n            rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier)\n        );\n    }","after":"function removeCollateral(\n        FixedPoint.Unsigned storage rawCollateral,\n        FixedPoint.Unsigned calldata collateralToRemove,\n        FixedPoint.Unsigned calldata cumulativeFeeMultiplier\n    ) external returns (FixedPoint.Unsigned memory removedCollateral) {\n        FixedPoint.Unsigned memory initialBalance =\n        rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\n        FixedPoint.Unsigned memory adjustedCollateral =\n        collateralToRemove._convertToRawCollateral(cumulativeFeeMultiplier);\n        rawCollateral.rawValue = rawCollateral.sub(adjustedCollateral).rawValue;\n        removedCollateral = initialBalance.sub(\n            rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier)\n        );\n    }","contract":"FeePayerPartyLib","time":0},{"type":"external-function ","before":"function addCollateral(\n        FixedPoint.Unsigned storage rawCollateral,\n        FixedPoint.Unsigned memory collateralToAdd,\n        FixedPoint.Unsigned memory cumulativeFeeMultiplier\n    ) external returns (FixedPoint.Unsigned memory addedCollateral) {\n        FixedPoint.Unsigned memory initialBalance =\n        rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\n        FixedPoint.Unsigned memory adjustedCollateral =\n        collateralToAdd._convertToRawCollateral(cumulativeFeeMultiplier);\n        rawCollateral.rawValue = rawCollateral.add(adjustedCollateral).rawValue;\n        addedCollateral = rawCollateral\n        ._getFeeAdjustedCollateral(cumulativeFeeMultiplier)\n        .sub(initialBalance);\n    }","after":"function addCollateral(\n        FixedPoint.Unsigned storage rawCollateral,\n        FixedPoint.Unsigned calldata collateralToAdd,\n        FixedPoint.Unsigned calldata cumulativeFeeMultiplier\n    ) external returns (FixedPoint.Unsigned memory addedCollateral) {\n        FixedPoint.Unsigned memory initialBalance =\n        rawCollateral._getFeeAdjustedCollateral(cumulativeFeeMultiplier);\n        FixedPoint.Unsigned memory adjustedCollateral =\n        collateralToAdd._convertToRawCollateral(cumulativeFeeMultiplier);\n        rawCollateral.rawValue = rawCollateral.add(adjustedCollateral).rawValue;\n        addedCollateral = rawCollateral\n        ._getFeeAdjustedCollateral(cumulativeFeeMultiplier)\n        .sub(initialBalance);\n    }","contract":"FeePayerPartyLib","time":0},{"type":"external-function ","before":"function convertToRawCollateral(\n        FixedPoint.Unsigned memory collateral,\n        FixedPoint.Unsigned memory cumulativeFeeMultiplier\n    ) external pure returns (FixedPoint.Unsigned memory rawCollateral) {\n        return collateral._convertToRawCollateral(cumulativeFeeMultiplier);\n    }","after":"function convertToRawCollateral(\n        FixedPoint.Unsigned calldata collateral,\n        FixedPoint.Unsigned calldata cumulativeFeeMultiplier\n    ) external pure returns (FixedPoint.Unsigned memory rawCollateral) {\n        return collateral._convertToRawCollateral(cumulativeFeeMultiplier);\n    }","contract":"FeePayerPartyLib","time":0},{"type":"external-function ","before":"function mint(MintParams memory mintParams)\n    external\n    override\n    nonReentrant\n    returns (uint256 syntheticTokensMinted, uint256 feePaid)\n    {\n        (syntheticTokensMinted, feePaid) = poolStorage.mint(mintParams);\n    }","after":"function mint(MintParams calldata mintParams)\n    external\n    override\n    nonReentrant\n    returns (uint256 syntheticTokensMinted, uint256 feePaid)\n    {\n        (syntheticTokensMinted, feePaid) = poolStorage.mint(mintParams);\n    }","contract":"SynthereumPoolOnChainPriceFeed","time":0},{"type":"external-function ","before":"function redeem(RedeemParams memory redeemParams)\n    external\n    override\n    nonReentrant\n    returns (uint256 collateralRedeemed, uint256 feePaid)\n    {\n        (collateralRedeemed, feePaid) = poolStorage.redeem(redeemParams);\n    }","after":"function redeem(RedeemParams calldata redeemParams)\n    external\n    override\n    nonReentrant\n    returns (uint256 collateralRedeemed, uint256 feePaid)\n    {\n        (collateralRedeemed, feePaid) = poolStorage.redeem(redeemParams);\n    }","contract":"SynthereumPoolOnChainPriceFeed","time":0},{"type":"external-function ","before":"function exchange(ExchangeParams memory exchangeParams)\n    external\n    override\n    nonReentrant\n    returns (uint256 destNumTokensMinted, uint256 feePaid)\n    {\n        (destNumTokensMinted, feePaid) = poolStorage.exchange(exchangeParams);\n    }","after":"function exchange(ExchangeParams calldata exchangeParams)\n    external\n    override\n    nonReentrant\n    returns (uint256 destNumTokensMinted, uint256 feePaid)\n    {\n        (destNumTokensMinted, feePaid) = poolStorage.exchange(exchangeParams);\n    }","contract":"SynthereumPoolOnChainPriceFeed","time":0},{"type":"external-function ","before":"function setFee(Fee memory _fee) public override onlyMaintainer nonReentrant {\n        poolStorage.setFeePercentage(_fee.feePercentage);\n        poolStorage.setFeeRecipients(_fee.feeRecipients, _fee.feeProportions);\n    }","after":"function setFee(Fee calldata _fee) public override onlyMaintainer nonReentrant {\n        poolStorage.setFeePercentage(_fee.feePercentage);\n        poolStorage.setFeeRecipients(_fee.feeRecipients, _fee.feeProportions);\n    }","contract":"SynthereumPoolOnChainPriceFeed","time":0},{"type":"external-function ","before":"function createPool(\n        IDerivative derivative,\n        ISynthereumFinder finder,\n        uint8 version,\n        ISynthereumPoolOnChainPriceFeed.Roles memory roles,\n        uint256 startingCollateralization,\n        ISynthereumPoolOnChainPriceFeed.Fee memory fee\n    ) public override returns (SynthereumPoolOnChainPriceFeed poolDeployed) {\n        address deployer =\n        ISynthereumFinder(synthereumFinder).getImplementationAddress(\n            SynthereumInterfaces.Deployer\n        );\n        require(msg.sender == deployer, 'Sender must be Synthereum deployer');\n        poolDeployed = super.createPool(\n            derivative,\n            finder,\n            version,\n            roles,\n            startingCollateralization,\n            fee\n        );\n    }","after":"function createPool(\n        IDerivative derivative,\n        ISynthereumFinder finder,\n        uint8 version,\n        ISynthereumPoolOnChainPriceFeed.Roles calldata roles,\n        uint256 startingCollateralization,\n        ISynthereumPoolOnChainPriceFeed.Fee calldata fee\n    ) public override returns (SynthereumPoolOnChainPriceFeed poolDeployed) {\n        address deployer =\n        ISynthereumFinder(synthereumFinder).getImplementationAddress(\n            SynthereumInterfaces.Deployer\n        );\n        require(msg.sender == deployer, 'Sender must be Synthereum deployer');\n        poolDeployed = super.createPool(\n            derivative,\n            finder,\n            version,\n            roles,\n            startingCollateralization,\n            fee\n        );\n    }","contract":"SynthereumPoolOnChainPriceFeedFactory","time":0},{"type":"external-function ","before":"function createPool(\n        IDerivative derivative,\n        ISynthereumFinder finder,\n        uint8 version,\n        ISynthereumPoolOnChainPriceFeed.Roles memory roles,\n        uint256 startingCollateralization,\n        ISynthereumPoolOnChainPriceFeed.Fee memory fee\n    )\n    public\n    virtual\n    nonReentrant\n    returns (SynthereumPoolOnChainPriceFeed poolDeployed)\n    {\n        poolDeployed = new SynthereumPoolOnChainPriceFeed(\n            derivative,\n            finder,\n            version,\n            roles,\n            startingCollateralization,\n            fee\n        );\n    }","after":"function createPool(\n        IDerivative derivative,\n        ISynthereumFinder finder,\n        uint8 version,\n        ISynthereumPoolOnChainPriceFeed.Roles calldata roles,\n        uint256 startingCollateralization,\n        ISynthereumPoolOnChainPriceFeed.Fee calldata fee\n    )\n    public\n    virtual\n    nonReentrant\n    returns (SynthereumPoolOnChainPriceFeed poolDeployed)\n    {\n        poolDeployed = new SynthereumPoolOnChainPriceFeed(\n            derivative,\n            finder,\n            version,\n            roles,\n            startingCollateralization,\n            fee\n        );\n    }","contract":"SynthereumPoolOnChainPriceFeedFactory","time":0},{"type":"immutable-restrict-modification ","before":"address public synthereumFinder;","after":"address public immutable synthereumFinder;","contract":"SynthereumPoolOnChainPriceFeedFactory","time":1},{"type":"immutable-restrict-modification ","before":"bytes4 public override deploymentSignature;","after":"bytes4 public override immutable deploymentSignature;","contract":"SynthereumPoolOnChainPriceFeedFactory","time":1},{"type":"external-function ","before":"function initialize(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        uint8 _version,\n        ISynthereumFinder _finder,\n        IDerivative _derivative,\n        FixedPoint.Unsigned memory _startingCollateralization\n    ) external {\n        self.version = _version;\n        self.finder = _finder;\n        self.startingCollateralization = _startingCollateralization;\n        self.collateralToken = getDerivativeCollateral(_derivative);\n        self.syntheticToken = _derivative.tokenCurrency();\n        self.priceIdentifier = _derivative.priceIdentifier();\n        self.derivatives.add(address(_derivative));\n        emit AddDerivative(address(this), address(_derivative));\n    }","after":"function initialize(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        uint8 _version,\n        ISynthereumFinder _finder,\n        IDerivative _derivative,\n        FixedPoint.Unsigned calldata _startingCollateralization\n    ) external {\n        self.version = _version;\n        self.finder = _finder;\n        self.startingCollateralization = _startingCollateralization;\n        self.collateralToken = getDerivativeCollateral(_derivative);\n        self.syntheticToken = _derivative.tokenCurrency();\n        self.priceIdentifier = _derivative.priceIdentifier();\n        self.derivatives.add(address(_derivative));\n        emit AddDerivative(address(this), address(_derivative));\n    }","contract":"SynthereumPoolOnChainPriceFeedLib","time":0},{"type":"external-function ","before":"function mint(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        ISynthereumPoolOnChainPriceFeed.MintParams memory mintParams\n    ) external returns (uint256 syntheticTokensMinted, uint256 feePaid) {\n        FixedPoint.Unsigned memory totCollateralAmount =\n        FixedPoint.Unsigned(mintParams.collateralAmount);\n        FixedPoint.Unsigned memory feeAmount =\n        totCollateralAmount.mul(self.fee.feePercentage);\n        FixedPoint.Unsigned memory collateralAmount =\n        totCollateralAmount.sub(feeAmount);\n        FixedPoint.Unsigned memory numTokens =\n        calculateNumberOfTokens(\n            self.finder,\n            IStandardERC20(address(self.collateralToken)),\n            self.priceIdentifier,\n            collateralAmount\n        );\n        require(\n            numTokens.rawValue >= mintParams.minNumTokens,\n            'Number of tokens less than minimum limit'\n        );\n        checkParams(\n            self,\n            mintParams.derivative,\n            mintParams.feePercentage,\n            mintParams.expiration\n        );\n        self.executeMint(\n            mintParams.derivative,\n            ExecuteMintParams(\n                numTokens,\n                collateralAmount,\n                feeAmount,\n                totCollateralAmount\n            ),\n            mintParams.recipient\n        );\n        syntheticTokensMinted = numTokens.rawValue;\n        feePaid = feeAmount.rawValue;\n    }","after":"function mint(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        ISynthereumPoolOnChainPriceFeed.MintParams calldata mintParams\n    ) external returns (uint256 syntheticTokensMinted, uint256 feePaid) {\n        FixedPoint.Unsigned memory totCollateralAmount =\n        FixedPoint.Unsigned(mintParams.collateralAmount);\n        FixedPoint.Unsigned memory feeAmount =\n        totCollateralAmount.mul(self.fee.feePercentage);\n        FixedPoint.Unsigned memory collateralAmount =\n        totCollateralAmount.sub(feeAmount);\n        FixedPoint.Unsigned memory numTokens =\n        calculateNumberOfTokens(\n            self.finder,\n            IStandardERC20(address(self.collateralToken)),\n            self.priceIdentifier,\n            collateralAmount\n        );\n        require(\n            numTokens.rawValue >= mintParams.minNumTokens,\n            'Number of tokens less than minimum limit'\n        );\n        checkParams(\n            self,\n            mintParams.derivative,\n            mintParams.feePercentage,\n            mintParams.expiration\n        );\n        self.executeMint(\n            mintParams.derivative,\n            ExecuteMintParams(\n                numTokens,\n                collateralAmount,\n                feeAmount,\n                totCollateralAmount\n            ),\n            mintParams.recipient\n        );\n        syntheticTokensMinted = numTokens.rawValue;\n        feePaid = feeAmount.rawValue;\n    }","contract":"SynthereumPoolOnChainPriceFeedLib","time":0},{"type":"external-function ","before":"function redeem(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        ISynthereumPoolOnChainPriceFeed.RedeemParams memory redeemParams\n    ) external returns (uint256 collateralRedeemed, uint256 feePaid) {\n        FixedPoint.Unsigned memory numTokens =\n        FixedPoint.Unsigned(redeemParams.numTokens);\n        FixedPoint.Unsigned memory totCollateralAmount =\n        calculateCollateralAmount(\n            self.finder,\n            IStandardERC20(address(self.collateralToken)),\n            self.priceIdentifier,\n            numTokens\n        );\n        FixedPoint.Unsigned memory feeAmount =\n        totCollateralAmount.mul(self.fee.feePercentage);\n        FixedPoint.Unsigned memory collateralAmount =\n        totCollateralAmount.sub(feeAmount);\n        require(\n            collateralAmount.rawValue >= redeemParams.minCollateral,\n            'Collateral amount less than minimum limit'\n        );\n        checkParams(\n            self,\n            redeemParams.derivative,\n            redeemParams.feePercentage,\n            redeemParams.expiration\n        );\n        self.executeRedeem(\n            redeemParams.derivative,\n            ExecuteRedeemParams(\n                numTokens,\n                collateralAmount,\n                feeAmount,\n                totCollateralAmount\n            ),\n            redeemParams.recipient\n        );\n        feePaid = feeAmount.rawValue;\n        collateralRedeemed = collateralAmount.rawValue;\n    }","after":"function redeem(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        ISynthereumPoolOnChainPriceFeed.RedeemParams calldata redeemParams\n    ) external returns (uint256 collateralRedeemed, uint256 feePaid) {\n        FixedPoint.Unsigned memory numTokens =\n        FixedPoint.Unsigned(redeemParams.numTokens);\n        FixedPoint.Unsigned memory totCollateralAmount =\n        calculateCollateralAmount(\n            self.finder,\n            IStandardERC20(address(self.collateralToken)),\n            self.priceIdentifier,\n            numTokens\n        );\n        FixedPoint.Unsigned memory feeAmount =\n        totCollateralAmount.mul(self.fee.feePercentage);\n        FixedPoint.Unsigned memory collateralAmount =\n        totCollateralAmount.sub(feeAmount);\n        require(\n            collateralAmount.rawValue >= redeemParams.minCollateral,\n            'Collateral amount less than minimum limit'\n        );\n        checkParams(\n            self,\n            redeemParams.derivative,\n            redeemParams.feePercentage,\n            redeemParams.expiration\n        );\n        self.executeRedeem(\n            redeemParams.derivative,\n            ExecuteRedeemParams(\n                numTokens,\n                collateralAmount,\n                feeAmount,\n                totCollateralAmount\n            ),\n            redeemParams.recipient\n        );\n        feePaid = feeAmount.rawValue;\n        collateralRedeemed = collateralAmount.rawValue;\n    }","contract":"SynthereumPoolOnChainPriceFeedLib","time":0},{"type":"external-function ","before":"function exchange(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        ISynthereumPoolOnChainPriceFeed.ExchangeParams memory exchangeParams\n    ) external returns (uint256 destNumTokensMinted, uint256 feePaid) {\n        FixedPoint.Unsigned memory numTokens =\n        FixedPoint.Unsigned(exchangeParams.numTokens);\n\n        FixedPoint.Unsigned memory totCollateralAmount =\n        calculateCollateralAmount(\n            self.finder,\n            IStandardERC20(address(self.collateralToken)),\n            self.priceIdentifier,\n            numTokens\n        );\n\n        FixedPoint.Unsigned memory feeAmount =\n        totCollateralAmount.mul(self.fee.feePercentage);\n\n        FixedPoint.Unsigned memory collateralAmount =\n        totCollateralAmount.sub(feeAmount);\n\n        FixedPoint.Unsigned memory destNumTokens =\n        calculateNumberOfTokens(\n            self.finder,\n            IStandardERC20(address(self.collateralToken)),\n            exchangeParams.destPool.getPriceFeedIdentifier(),\n            collateralAmount\n        );\n\n        require(\n            destNumTokens.rawValue >= exchangeParams.minDestNumTokens,\n            'Number of destination tokens less than minimum limit'\n        );\n        checkParams(\n            self,\n            exchangeParams.derivative,\n            exchangeParams.feePercentage,\n            exchangeParams.expiration\n        );\n\n        self.executeExchange(\n            exchangeParams.derivative,\n            exchangeParams.destPool,\n            exchangeParams.destDerivative,\n            ExecuteExchangeParams(\n                numTokens,\n                collateralAmount,\n                feeAmount,\n                totCollateralAmount,\n                destNumTokens\n            ),\n            exchangeParams.recipient\n        );\n\n        destNumTokensMinted = destNumTokens.rawValue;\n        feePaid = feeAmount.rawValue;\n    }","after":"function exchange(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        ISynthereumPoolOnChainPriceFeed.ExchangeParams calldata exchangeParams\n    ) external returns (uint256 destNumTokensMinted, uint256 feePaid) {\n        FixedPoint.Unsigned memory numTokens =\n        FixedPoint.Unsigned(exchangeParams.numTokens);\n\n        FixedPoint.Unsigned memory totCollateralAmount =\n        calculateCollateralAmount(\n            self.finder,\n            IStandardERC20(address(self.collateralToken)),\n            self.priceIdentifier,\n            numTokens\n        );\n\n        FixedPoint.Unsigned memory feeAmount =\n        totCollateralAmount.mul(self.fee.feePercentage);\n\n        FixedPoint.Unsigned memory collateralAmount =\n        totCollateralAmount.sub(feeAmount);\n\n        FixedPoint.Unsigned memory destNumTokens =\n        calculateNumberOfTokens(\n            self.finder,\n            IStandardERC20(address(self.collateralToken)),\n            exchangeParams.destPool.getPriceFeedIdentifier(),\n            collateralAmount\n        );\n\n        require(\n            destNumTokens.rawValue >= exchangeParams.minDestNumTokens,\n            'Number of destination tokens less than minimum limit'\n        );\n        checkParams(\n            self,\n            exchangeParams.derivative,\n            exchangeParams.feePercentage,\n            exchangeParams.expiration\n        );\n\n        self.executeExchange(\n            exchangeParams.derivative,\n            exchangeParams.destPool,\n            exchangeParams.destDerivative,\n            ExecuteExchangeParams(\n                numTokens,\n                collateralAmount,\n                feeAmount,\n                totCollateralAmount,\n                destNumTokens\n            ),\n            exchangeParams.recipient\n        );\n\n        destNumTokensMinted = destNumTokens.rawValue;\n        feePaid = feeAmount.rawValue;\n    }","contract":"SynthereumPoolOnChainPriceFeedLib","time":0},{"type":"external-function ","before":"function exchangeMint(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        IDerivative srcDerivative,\n        IDerivative derivative,\n        FixedPoint.Unsigned memory collateralAmount,\n        FixedPoint.Unsigned memory numTokens\n    ) external {\n        self.checkPool(ISynthereumPoolGeneral(msg.sender), srcDerivative);\n        FixedPoint.Unsigned memory globalCollateralization =\n        derivative.getGlobalCollateralizationRatio();\n\n        // Target the starting collateralization ratio if there is no global ratio\n        FixedPoint.Unsigned memory targetCollateralization =\n        globalCollateralization.isGreaterThan(0)\n        ? globalCollateralization\n        : self.startingCollateralization;\n\n        // Check that LP collateral can support the tokens to be minted\n        require(\n            self.checkCollateralizationRatio(\n                targetCollateralization,\n                collateralAmount,\n                numTokens\n            ),\n            'Insufficient collateral available from Liquidity Provider'\n        );\n\n        // Pull Collateral Tokens from calling Pool contract\n        self.pullCollateral(msg.sender, collateralAmount);\n\n        // Mint new tokens with the collateral\n        self.mintSynTokens(\n            derivative,\n            numTokens.mulCeil(targetCollateralization),\n            numTokens\n        );\n\n        // Transfer new tokens back to the calling Pool where they will be sent to the user\n        self.transferSynTokens(msg.sender, numTokens);\n    }","after":"function exchangeMint(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        IDerivative srcDerivative,\n        IDerivative derivative,\n        FixedPoint.Unsigned calldata collateralAmount,\n        FixedPoint.Unsigned calldata numTokens\n    ) external {\n        self.checkPool(ISynthereumPoolGeneral(msg.sender), srcDerivative);\n        FixedPoint.Unsigned memory globalCollateralization =\n        derivative.getGlobalCollateralizationRatio();\n\n        // Target the starting collateralization ratio if there is no global ratio\n        FixedPoint.Unsigned memory targetCollateralization =\n        globalCollateralization.isGreaterThan(0)\n        ? globalCollateralization\n        : self.startingCollateralization;\n\n        // Check that LP collateral can support the tokens to be minted\n        require(\n            self.checkCollateralizationRatio(\n                targetCollateralization,\n                collateralAmount,\n                numTokens\n            ),\n            'Insufficient collateral available from Liquidity Provider'\n        );\n\n        // Pull Collateral Tokens from calling Pool contract\n        self.pullCollateral(msg.sender, collateralAmount);\n\n        // Mint new tokens with the collateral\n        self.mintSynTokens(\n            derivative,\n            numTokens.mulCeil(targetCollateralization),\n            numTokens\n        );\n\n        // Transfer new tokens back to the calling Pool where they will be sent to the user\n        self.transferSynTokens(msg.sender, numTokens);\n    }","contract":"SynthereumPoolOnChainPriceFeedLib","time":0},{"type":"external-function ","before":"function withdrawFromPool(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        FixedPoint.Unsigned memory collateralAmount\n    ) external {\n        // Transfer the collateral from this pool to the LP sender\n        self.collateralToken.safeTransfer(msg.sender, collateralAmount.rawValue);\n    }","after":"function withdrawFromPool(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        FixedPoint.Unsigned calldata collateralAmount\n    ) external {\n        // Transfer the collateral from this pool to the LP sender\n        self.collateralToken.safeTransfer(msg.sender, collateralAmount.rawValue);\n    }","contract":"SynthereumPoolOnChainPriceFeedLib","time":0},{"type":"external-function ","before":"function depositIntoDerivative(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        IDerivative derivative,\n        FixedPoint.Unsigned memory collateralAmount\n    ) external checkDerivative(self, derivative) {\n        self.collateralToken.safeApprove(\n            address(derivative),\n            collateralAmount.rawValue\n        );\n        derivative.deposit(collateralAmount);\n    }","after":"function depositIntoDerivative(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        IDerivative derivative,\n        FixedPoint.Unsigned calldata collateralAmount\n    ) external checkDerivative(self, derivative) {\n        self.collateralToken.safeApprove(\n            address(derivative),\n            collateralAmount.rawValue\n        );\n        derivative.deposit(collateralAmount);\n    }","contract":"SynthereumPoolOnChainPriceFeedLib","time":0},{"type":"external-function ","before":"function slowWithdrawRequest(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        IDerivative derivative,\n        FixedPoint.Unsigned memory collateralAmount\n    ) external checkDerivative(self, derivative) {\n        derivative.requestWithdrawal(collateralAmount);\n    }","after":"function slowWithdrawRequest(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        IDerivative derivative,\n        FixedPoint.Unsigned calldata collateralAmount\n    ) external checkDerivative(self, derivative) {\n        derivative.requestWithdrawal(collateralAmount);\n    }","contract":"SynthereumPoolOnChainPriceFeedLib","time":0},{"type":"external-function ","before":"function fastWithdraw(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        IDerivative derivative,\n        FixedPoint.Unsigned memory collateralAmount\n    )\n    external\n    checkDerivative(self, derivative)\n    returns (uint256 amountWithdrawn)\n    {\n        FixedPoint.Unsigned memory totalAmountWithdrawn =\n        derivative.withdraw(collateralAmount);\n        amountWithdrawn = liquidateWithdrawal(\n            self,\n            totalAmountWithdrawn,\n            msg.sender\n        );\n    }","after":"function fastWithdraw(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        IDerivative derivative,\n        FixedPoint.Unsigned calldata collateralAmount\n    )\n    external\n    checkDerivative(self, derivative)\n    returns (uint256 amountWithdrawn)\n    {\n        FixedPoint.Unsigned memory totalAmountWithdrawn =\n        derivative.withdraw(collateralAmount);\n        amountWithdrawn = liquidateWithdrawal(\n            self,\n            totalAmountWithdrawn,\n            msg.sender\n        );\n    }","contract":"SynthereumPoolOnChainPriceFeedLib","time":0},{"type":"external-function ","before":"function setFeePercentage(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        FixedPoint.Unsigned memory _feePercentage\n    ) external {\n        require(\n            _feePercentage.rawValue < 10 ** (18),\n            'Fee Percentage must be less than 100%'\n        );\n        self.fee.feePercentage = _feePercentage;\n        emit SetFeePercentage(_feePercentage.rawValue);\n    }","after":"function setFeePercentage(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        FixedPoint.Unsigned calldata _feePercentage\n    ) external {\n        require(\n            _feePercentage.rawValue < 10 ** (18),\n            'Fee Percentage must be less than 100%'\n        );\n        self.fee.feePercentage = _feePercentage;\n        emit SetFeePercentage(_feePercentage.rawValue);\n    }","contract":"SynthereumPoolOnChainPriceFeedLib","time":0},{"type":"external-function ","before":"function setStartingCollateralization(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        FixedPoint.Unsigned memory startingCollateralRatio\n    ) external {\n        self.startingCollateralization = startingCollateralRatio;\n    }","after":"function setStartingCollateralization(\n        ISynthereumPoolOnChainPriceFeedStorage.Storage storage self,\n        FixedPoint.Unsigned calldata startingCollateralRatio\n    ) external {\n        self.startingCollateralization = startingCollateralRatio;\n    }","contract":"SynthereumPoolOnChainPriceFeedLib","time":0}]}