{"time":661,"results":[{"type":"external-function ","before":"function initialize(address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        // CToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }","after":"function initialize(address underlying_,\n        ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string calldata name_,\n        string calldata symbol_,\n        uint8 decimals_) public {\n        // CToken initialize does the bulk of the work\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n        // Set underlying and sanity check it\n        underlying = underlying_;\n        EIP20Interface(underlying).totalSupply();\n    }","contract":"CErc20","time":0},{"type":"external-function ","before":"function initialize(ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(msg.sender == admin, \"only admin may initialize the market\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint err = _setComptroller(comptroller_);\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }","after":"function initialize(ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string calldata name_,\n        string calldata symbol_,\n        uint8 decimals_) public {\n        require(msg.sender == admin, \"only admin may initialize the market\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint err = _setComptroller(comptroller_);\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }","contract":"CErc20","time":0},{"type":"state-data-arrangement ","before":"\n/\n    bool internal _notEn\n/\n    string public\n/\n    string public s\n/\n    uint8 public dec\n\n\n    uint internal constant borrowRateMaxMantissa = 0.00\n/\n    uint internal constant reserveFactorMaxMantissa =\n/\n    address payable public \n/\n    address payable public pending\n/\n    ComptrollerInterface public comptr\n/\n    InterestRateModel public interestRate\n/\n    uint internal initialExchangeRateMan\n/\n    uint public reserveFactorMan\n/\n    uint public accrualBlockN\n/\n    uint public borrow\n/\n    uint public totalBo\n/\n    uint public totalRes\n/\n    uint public totalS\n/\n    mapping(address => uint) internal accountT\n/\n    mapping(address => mapping(address => uint)) internal transferAllow\n/\n    mapping(address => BorrowSnapshot) internal accountBo","after":"/\n    string public\n/\n    string public s\n\n\n    uint internal constant borrowRateMaxMantissa = 0.00\n/\n    uint internal constant reserveFactorMaxMantissa =\n/\n    ComptrollerInterface public comptr\n/\n    InterestRateModel public interestRate\n/\n    uint internal initialExchangeRateMan\n/\n    uint public reserveFactorMan\n/\n    uint public accrualBlockN\n/\n    uint public borrow\n/\n    uint public totalBo\n/\n    uint public totalRes\n/\n    uint public totalS\n/\n    mapping(address => uint) internal accountT\n/\n    mapping(address => mapping(address => uint)) internal transferAllow\n/\n    mapping(address => BorrowSnapshot) internal accountBo\n/\n    address payable public \n/\n    address payable public pending\n/\n    bool internal _notEn\n/\n    uint8 public dec\n","contract":"CTokenStorage","time":0},{"type":"constant-restrict-modification  ","before":"/\n    address public implement","after":"/\n    address public implement","contract":"CDelegatorInterface","time":0},{"type":"constant-restrict-modification  ","before":"/\n    address public implement","after":"/\n    address public implement","contract":"CDelegateInterface","time":0},{"type":"struct-data-arrangement ","before":"\n      address \n      uint exchangeRateC\n      uint supplyRatePe\n      uint borrowRatePe\n      uint reserveFactorMa\n      uint totalB\n      uint totalRe\n      uint total\n      uint tot\n      bool is\n      uint collateralFactorMa\n      address underlyingAssetA\n      uint cTokenDe\n      uint underlyingDe","after":"      uint exchangeRateC\n      uint supplyRatePe\n      uint borrowRatePe\n      uint reserveFactorMa\n      uint totalB\n      uint totalRe\n      uint total\n      uint tot\n      uint collateralFactorMa\n      uint cTokenDe\n      uint underlyingDe\n      address \n      address underlyingAssetA\n      bool is\n","contract":"CompoundLens","time":0},{"type":"struct-data-arrangement ","before":"\n      uint prop\n      address pr\n      ui\n      address[] t\n      uint[] \n      string[] sign\n      bytes[] cal\n      uint star\n      uint en\n      uint fo\n      uint agains\n      bool ca\n      bool ex","after":"      uint prop\n      ui\n      address[] t\n      uint[] \n      string[] sign\n      bytes[] cal\n      uint star\n      uint en\n      uint fo\n      uint agains\n      address pr\n      bool ca\n      bool ex\n","contract":"CompoundLens","time":0},{"type":"external-function ","before":"\n\n    function getGovReceipts(GovernorAlpha governor, address voter, uint[] memory proposalIds) public view returns (GovReceipt[] memory) {\n        uint proposalCount = proposalIds.length;\n        GovReceipt[] memory res = new GovReceipt[](proposalCount);\n        for (uint i = 0; i < proposalCount; i++) {\n            GovernorAlpha.Receipt memory receipt = governor.getReceipt(proposalIds[i], voter);\n            res[i] = GovReceipt({\n            proposalId : proposalIds[i],\n            hasVoted : receipt.hasVoted,\n            support : receipt.support,\n            votes : receipt.votes\n            });\n        }\n        return res;","after":"\n\n    function getGovReceipts(GovernorAlpha governor, address voter, uint[] calldata proposalIds) public view returns (GovReceipt[] memory) {\n        uint proposalCount = proposalIds.length;\n        GovReceipt[] memory res = new GovReceipt[](proposalCount);\n        for (uint i = 0; i < proposalCount; i++) {\n            GovernorAlpha.Receipt memory receipt = governor.getReceipt(proposalIds[i], voter);\n            res[i] = GovReceipt({\n            proposalId : proposalIds[i],\n            hasVoted : receipt.hasVoted,\n            support : receipt.support,\n            votes : receipt.votes\n            });\n        }\n        return res;","contract":"CompoundLens","time":0},{"type":"struct-data-arrangement ","before":"\n      u\n      address pr\n      ui\n      address[] t\n      uint[] \n      string[] sign\n      bytes[] cal\n      uint star\n      uint en\n      uint fo\n      uint agains\n      bool ca\n      bool ex\n      mapping(address => Receipt) re","after":"      u\n      ui\n      address[] t\n      uint[] \n      string[] sign\n      bytes[] cal\n      uint star\n      uint en\n      uint fo\n      uint agains\n      mapping(address => Receipt) re\n      address pr\n      bool ca\n      bool ex\n","contract":"GovernorAlpha","time":0},{"type":"external-function ","before":"\n\n    function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n        require(comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        }\n\n        uint startBlock = add256(block.number, votingDelay());\n        uint endBlock = add256(startBlock, votingPeriod());\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n        id : proposalCount,\n        proposer : msg.sender,\n        eta : 0,\n        targets : targets,\n        values : values,\n        signatures : signatures,\n        calldatas : calldatas,\n        startBlock : startBlock,\n        endBlock : endBlock,\n        forVotes : 0,\n        againstVotes : 0,\n        canceled : false,\n        executed : false\n        });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;","after":"\n\n    function propose(address[] calldata targets, uint[] calldata values, string[] calldata signatures, bytes[] calldata calldatas, string calldata description) public returns (uint) {\n        require(comp.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        }\n\n        uint startBlock = add256(block.number, votingDelay());\n        uint endBlock = add256(startBlock, votingPeriod());\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n        id : proposalCount,\n        proposer : msg.sender,\n        eta : 0,\n        targets : targets,\n        values : values,\n        signatures : signatures,\n        calldatas : calldatas,\n        startBlock : startBlock,\n        endBlock : endBlock,\n        forVotes : 0,\n        againstVotes : 0,\n        canceled : false,\n        executed : false\n        });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;","contract":"GovernorAlpha","time":0}]}