{"time":1607,"results":[{"type":"external-function ","before":"function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }","after":"function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function hashPaymentAsWallet(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 amountCurrencyHash = hashPaymentAmountCurrency(payment);\n        bytes32 senderHash = hashPaymentSenderPartyAsWallet(payment.sender);\n        bytes32 recipientHash = hashAddress(payment.recipient.wallet);\n\n        return keccak256(abi.encodePacked(amountCurrencyHash, senderHash, recipientHash));\n    }","after":"function hashPaymentAsWallet(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 amountCurrencyHash = hashPaymentAmountCurrency(payment);\n        bytes32 senderHash = hashPaymentSenderPartyAsWallet(payment.sender);\n        bytes32 recipientHash = hashAddress(payment.recipient.wallet);\n\n        return keccak256(abi.encodePacked(amountCurrencyHash, senderHash, recipientHash));\n    }","contract":"PaymentHasher","time":0},{"type":"external-function ","before":"function hashPaymentAsOperator(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 walletSignatureHash = hashSignature(payment.seals.wallet.signature);\n        bytes32 senderHash = hashPaymentSenderPartyAsOperator(payment.sender);\n        bytes32 recipientHash = hashPaymentRecipientPartyAsOperator(payment.recipient);\n        bytes32 transfersHash = hashSingleTotalInt256(payment.transfers);\n        bytes32 operatorHash = hashString(payment.operator.data);\n\n        return keccak256(abi.encodePacked(\n                walletSignatureHash, senderHash, recipientHash, transfersHash, operatorHash\n            ));\n    }","after":"function hashPaymentAsOperator(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 walletSignatureHash = hashSignature(payment.seals.wallet.signature);\n        bytes32 senderHash = hashPaymentSenderPartyAsOperator(payment.sender);\n        bytes32 recipientHash = hashPaymentRecipientPartyAsOperator(payment.recipient);\n        bytes32 transfersHash = hashSingleTotalInt256(payment.transfers);\n        bytes32 operatorHash = hashString(payment.operator.data);\n\n        return keccak256(abi.encodePacked(\n                walletSignatureHash, senderHash, recipientHash, transfersHash, operatorHash\n            ));\n    }","contract":"PaymentHasher","time":0},{"type":"external-function ","before":"function isGenuinePaymentSeals(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentWalletSeal(payment) && isGenuinePaymentOperatorSeal(payment);\n    }","after":"function isGenuinePaymentSeals(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentWalletSeal(payment) && isGenuinePaymentOperatorSeal(payment);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentFeeOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        int256 feePartsPer = int256(ConstantsLib.PARTS_PER());\n\n        int256 feeAmount = payment.amount\n        .mul(\n            configuration.currencyPaymentFee(\n                payment.blockNumber, payment.currency.ct, payment.currency.id, payment.amount\n            )\n        ).div(feePartsPer);\n\n        if (1 > feeAmount)\n            feeAmount = 1;\n\n        return (payment.sender.fees.single.amount == feeAmount);\n    }","after":"function isGenuinePaymentFeeOfFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        int256 feePartsPer = int256(ConstantsLib.PARTS_PER());\n\n        int256 feeAmount = payment.amount\n        .mul(\n            configuration.currencyPaymentFee(\n                payment.blockNumber, payment.currency.ct, payment.currency.id, payment.amount\n            )\n        ).div(feePartsPer);\n\n        if (1 > feeAmount)\n            feeAmount = 1;\n\n        return (payment.sender.fees.single.amount == feeAmount);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentFeeOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        (address feeCurrencyCt, uint256 feeCurrencyId) = configuration.feeCurrency(\n            payment.blockNumber, payment.currency.ct, payment.currency.id\n        );\n\n        return feeCurrencyCt == payment.sender.fees.single.currency.ct\n        && feeCurrencyId == payment.sender.fees.single.currency.id;\n    }","after":"function isGenuinePaymentFeeOfNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        (address feeCurrencyCt, uint256 feeCurrencyId) = configuration.feeCurrency(\n            payment.blockNumber, payment.currency.ct, payment.currency.id\n        );\n\n        return feeCurrencyCt == payment.sender.fees.single.currency.ct\n        && feeCurrencyId == payment.sender.fees.single.currency.id;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentSenderOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet))\n        && (payment.sender.balances.current == payment.sender.balances.previous.sub(payment.transfers.single).sub(payment.sender.fees.single.amount));\n    }","after":"function isGenuinePaymentSenderOfFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet))\n        && (payment.sender.balances.current == payment.sender.balances.previous.sub(payment.transfers.single).sub(payment.sender.fees.single.amount));\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentRecipientOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (payment.recipient.balances.current == payment.recipient.balances.previous.add(payment.transfers.single));\n    }","after":"function isGenuinePaymentRecipientOfFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (payment.recipient.balances.current == payment.recipient.balances.previous.add(payment.transfers.single));\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentSenderOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet));\n    }","after":"function isGenuinePaymentSenderOfNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet));\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentRecipientOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet);\n    }","after":"function isGenuinePaymentRecipientOfNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isSuccessivePaymentsPartyNonces(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment memory lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole\n    )\n    public\n    pure\n    returns (bool)\n    {\n        uint256 firstNonce = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.nonce : firstPayment.recipient.nonce);\n        uint256 lastNonce = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.nonce : lastPayment.recipient.nonce);\n        return lastNonce == firstNonce.add(1);\n    }","after":"function isSuccessivePaymentsPartyNonces(\n        PaymentTypesLib.Payment calldata firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment calldata lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole\n    )\n    public\n    pure\n    returns (bool)\n    {\n        uint256 firstNonce = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.nonce : firstPayment.recipient.nonce);\n        uint256 lastNonce = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.nonce : lastPayment.recipient.nonce);\n        return lastNonce == firstNonce.add(1);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuineSuccessivePaymentsBalances(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment memory lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole,\n        int256 delta\n    )\n    public\n    pure\n    returns (bool)\n    {\n        NahmiiTypesLib.CurrentPreviousInt256 memory firstCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.balances : firstPayment.recipient.balances);\n        NahmiiTypesLib.CurrentPreviousInt256 memory lastCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.balances : lastPayment.recipient.balances);\n\n        return lastCurrentPreviousBalances.previous == firstCurrentPreviousBalances.current.add(delta);\n    }","after":"function isGenuineSuccessivePaymentsBalances(\n        PaymentTypesLib.Payment calldata firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment calldata lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole,\n        int256 delta\n    )\n    public\n    pure\n    returns (bool)\n    {\n        NahmiiTypesLib.CurrentPreviousInt256 memory firstCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.balances : firstPayment.recipient.balances);\n        NahmiiTypesLib.CurrentPreviousInt256 memory lastCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.balances : lastPayment.recipient.balances);\n\n        return lastCurrentPreviousBalances.previous == firstCurrentPreviousBalances.current.add(delta);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuineSuccessivePaymentsTotalFees(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.Payment memory lastPayment\n    )\n    public\n    pure\n    returns (bool)\n    {\n        MonetaryTypesLib.Figure memory firstTotalFee = getProtocolFigureByCurrency(firstPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        MonetaryTypesLib.Figure memory lastTotalFee = getProtocolFigureByCurrency(lastPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        return lastTotalFee.amount == firstTotalFee.amount.add(lastPayment.sender.fees.single.amount);\n    }","after":"function isGenuineSuccessivePaymentsTotalFees(\n        PaymentTypesLib.Payment calldata firstPayment,\n        PaymentTypesLib.Payment calldata lastPayment\n    )\n    public\n    pure\n    returns (bool)\n    {\n        MonetaryTypesLib.Figure memory firstTotalFee = getProtocolFigureByCurrency(firstPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        MonetaryTypesLib.Figure memory lastTotalFee = getProtocolFigureByCurrency(lastPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        return lastTotalFee.amount == firstTotalFee.amount.add(lastPayment.sender.fees.single.amount);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentParty(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet || wallet == payment.recipient.wallet;\n    }","after":"function isPaymentParty(PaymentTypesLib.Payment calldata payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet || wallet == payment.recipient.wallet;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentSender(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet;\n    }","after":"function isPaymentSender(PaymentTypesLib.Payment calldata payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentRecipient(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.recipient.wallet;\n    }","after":"function isPaymentRecipient(PaymentTypesLib.Payment calldata payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.recipient.wallet;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentCurrency(PaymentTypesLib.Payment memory payment, MonetaryTypesLib.Currency memory currency)\n    public\n    pure\n    returns (bool)\n    {\n        return currency.ct == payment.currency.ct && currency.id == payment.currency.id;\n    }","after":"function isPaymentCurrency(PaymentTypesLib.Payment calldata payment, MonetaryTypesLib.Currency calldata currency)\n    public\n    pure\n    returns (bool)\n    {\n        return currency.ct == payment.currency.ct && currency.id == payment.currency.id;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentCurrencyNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return payment.currency.ct != payment.sender.fees.single.currency.ct\n        || payment.currency.id != payment.sender.fees.single.currency.id;\n    }","after":"function isPaymentCurrencyNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bool)\n    {\n        return payment.currency.ct != payment.sender.fees.single.currency.ct\n        || payment.currency.id != payment.sender.fees.single.currency.id;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function transferController(address currencyCt, string memory standard)\npublic\nview\nreturns (TransferController)\n{\nif (bytes(standard).length > 0) {\nbytes32 standardHash = keccak256(abi.encodePacked(standard));\n\nrequire(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\nreturn TransferController(registeredTransferControllers[standardHash]);\n}\n\nrequire(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\nrequire(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\naddress controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\nrequire(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\nreturn TransferController(controllerAddress);\n}","after":"function transferController(address currencyCt, string calldata standard)\npublic\nview\nreturns (TransferController)\n{\nif (bytes(standard).length > 0) {\nbytes32 standardHash = keccak256(abi.encodePacked(standard));\n\nrequire(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\nreturn TransferController(registeredTransferControllers[standardHash]);\n}\n\nrequire(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\nrequire(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\naddress controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\nrequire(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\nreturn TransferController(controllerAddress);\n}","contract":"TransferControllerManager","time":0},{"type":"loop-duplication","before":"\nstart line 3671 column 0, end line 3672 column 91\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\nself.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\nstart line 3676 column 0, end line 3677 column 95\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\nself.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = i + 1;","after":"// merge loop\n\nstart line 3671 column 0, end line 3672 column 91\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\nself.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\nstart line 3676 column 0, end line 3677 column 95\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\nself.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = i + 1;","contract":"NonFungibleBalanceLib","time":0},{"type":"external-function ","before":"function setIds(address wallet, bytes32 _type, int256[] memory ids, address currencyCt, uint256 currencyId)\npublic\nonlyActiveService\n{\n\nwalletMap[wallet].nonFungibleBalanceByType[_type].set(\nids, currencyCt, currencyId\n);\n\n\n_updateTrackedBalanceTypes(_type);\n\n\n_updateTrackedWallets(wallet);\n}","after":"function setIds(address wallet, bytes32 _type, int256[] calldata ids, address currencyCt, uint256 currencyId)\npublic\nonlyActiveService\n{\n\nwalletMap[wallet].nonFungibleBalanceByType[_type].set(\nids, currencyCt, currencyId\n);\n\n\n_updateTrackedBalanceTypes(_type);\n\n\n_updateTrackedWallets(wallet);\n}","contract":"BalanceTracker","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"BalanceTracker","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"BalanceTracker","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"BalanceTracker","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public depositedBalanceType;","after":"bytes32 public immutable depositedBalanceType;","contract":"BalanceTracker","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 public settledBalanceType;","after":"bytes32 public immutable settledBalanceType;","contract":"BalanceTracker","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 public stagedBalanceType;","after":"bytes32 public immutable stagedBalanceType;","contract":"BalanceTracker","time":1},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"TransactionTracker","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"TransactionTracker","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"TransactionTracker","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public depositTransactionType;","after":"bytes32 public immutable depositTransactionType;","contract":"TransactionTracker","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public withdrawalTransactionType;","after":"bytes32 public immutable withdrawalTransactionType;","contract":"TransactionTracker","time":0},{"type":"external-function ","before":"function lockNonFungibleByProxy(address lockedWallet, address lockerWallet, int256[] memory ids,\naddress currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\npublic\nonlyAuthorizedService(lockedWallet)\n{\n\nrequire(lockedWallet != lockerWallet);\n\n\nuint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n\nrequire(\n(0 == lockIndex) ||\n(block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n);\n\n\nif (0 == lockIndex) {\nlockIndex = ++(walletNonFungibleLocks[lockedWallet].length);\nlockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\nwalletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n}\n\n\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].ids = ids;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\nblock.timestamp.add(visibleTimeoutInSeconds);\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\nblock.timestamp.add(configuration.walletLockTimeout());\n\n\nemit LockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId, visibleTimeoutInSeconds);\n}","after":"function lockNonFungibleByProxy(address lockedWallet, address lockerWallet, int256[] calldata ids,\naddress currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\npublic\nonlyAuthorizedService(lockedWallet)\n{\n\nrequire(lockedWallet != lockerWallet);\n\n\nuint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n\nrequire(\n(0 == lockIndex) ||\n(block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n);\n\n\nif (0 == lockIndex) {\nlockIndex = ++(walletNonFungibleLocks[lockedWallet].length);\nlockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\nwalletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n}\n\n\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].ids = ids;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\nblock.timestamp.add(visibleTimeoutInSeconds);\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\nblock.timestamp.add(configuration.walletLockTimeout());\n\n\nemit LockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId, visibleTimeoutInSeconds);\n}","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function authorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        require(!initialServiceAuthorizedMap[service]);\n\n\n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n\n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","after":"function authorizeRegisteredServiceAction(address service, string calldata action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        require(!initialServiceAuthorizedMap[service]);\n\n\n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n\n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function unauthorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        require(!initialServiceAuthorizedMap[service]);\n\n\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n\n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","after":"function unauthorizeRegisteredServiceAction(address service, string calldata action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        require(!initialServiceAuthorizedMap[service]);\n\n\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n\n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function isAuthorizedRegisteredServiceAction(address service, string memory action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }","after":"function isAuthorizedRegisteredServiceAction(address service, string calldata action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function defineReleases(uint256[] memory earliestReleaseTimes, uint256[] memory amounts, uint256[] memory releaseBlockNumbers)\nonlyOperator\npublic\n{\nrequire(\nearliestReleaseTimes.length == amounts.length,\n\"Earliest release times and amounts lengths mismatch [TokenMultiTimelock.sol:105]\"\n);\nrequire(\nearliestReleaseTimes.length >= releaseBlockNumbers.length,\n\"Earliest release times and release block numbers lengths mismatch [TokenMultiTimelock.sol:109]\"\n);\n\n\nrequire(address(token) != address(0), \"Token not initialized [TokenMultiTimelock.sol:115]\");\n\nfor (uint256 i = 0; i < earliestReleaseTimes.length; i++) {\n\ntotalLockedAmount += amounts[i];\n\n\n\nrequire(token.balanceOf(address(this)) >= totalLockedAmount, \"Total locked amount overrun [TokenMultiTimelock.sol:123]\");\n\n\nuint256 blockNumber = i < releaseBlockNumbers.length ? releaseBlockNumbers[i] : 0;\n\n\nreleases.push(Release(earliestReleaseTimes[i], amounts[i], blockNumber, false));\n\n\nemit DefineReleaseEvent(earliestReleaseTimes[i], amounts[i], blockNumber);\n}\n}","after":"function defineReleases(uint256[] calldata earliestReleaseTimes, uint256[] calldata amounts, uint256[] calldata releaseBlockNumbers)\nonlyOperator\npublic\n{\nrequire(\nearliestReleaseTimes.length == amounts.length,\n\"Earliest release times and amounts lengths mismatch [TokenMultiTimelock.sol:105]\"\n);\nrequire(\nearliestReleaseTimes.length >= releaseBlockNumbers.length,\n\"Earliest release times and release block numbers lengths mismatch [TokenMultiTimelock.sol:109]\"\n);\n\n\nrequire(address(token) != address(0), \"Token not initialized [TokenMultiTimelock.sol:115]\");\n\nfor (uint256 i = 0; i < earliestReleaseTimes.length; i++) {\n\ntotalLockedAmount += amounts[i];\n\n\n\nrequire(token.balanceOf(address(this)) >= totalLockedAmount, \"Total locked amount overrun [TokenMultiTimelock.sol:123]\");\n\n\nuint256 blockNumber = i < releaseBlockNumbers.length ? releaseBlockNumbers[i] : 0;\n\n\nreleases.push(Release(earliestReleaseTimes[i], amounts[i], blockNumber, false));\n\n\nemit DefineReleaseEvent(earliestReleaseTimes[i], amounts[i], blockNumber);\n}\n}","contract":"RevenueTokenManager","time":0},{"type":"external-function ","before":"function receiveTokens(string memory, int256 amount, address currencyCt, uint256 currencyId,\nstring memory standard)\npublic\n{\nreceiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n}","after":"function receiveTokens(string calldata, int256 amount, address currencyCt, uint256 currencyId,\nstring calldata standard)\npublic\n{\nreceiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n}","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\npublic\nonlyEnabledServiceAction(CLOSE_ACCRUAL_PERIOD_ACTION)\n{\n\nfor (uint256 i = 0; i < currencies.length; i++) {\nMonetaryTypesLib.Currency memory currency = currencies[i];\n\n\nint256 periodAmount = periodAccrual.get(currency.ct, currency.id);\n\n\naccrualBlockNumbersByCurrency[currency.ct][currency.id].push(block.number);\n\n\naggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number] = aggregateAccrualBalance(\ncurrency.ct, currency.id\n);\n\nif (periodAmount > 0) {\n\nperiodAccrual.set(0, currency.ct, currency.id);\n\n\nperiodCurrencies.removeByCurrency(currency.ct, currency.id);\n}\n\n\nemit CloseAccrualPeriodEvent(\nperiodAmount,\naggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number],\ncurrency.ct, currency.id\n);\n}\n}","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata currencies)\npublic\nonlyEnabledServiceAction(CLOSE_ACCRUAL_PERIOD_ACTION)\n{\n\nfor (uint256 i = 0; i < currencies.length; i++) {\nMonetaryTypesLib.Currency memory currency = currencies[i];\n\n\nint256 periodAmount = periodAccrual.get(currency.ct, currency.id);\n\n\naccrualBlockNumbersByCurrency[currency.ct][currency.id].push(block.number);\n\n\naggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number] = aggregateAccrualBalance(\ncurrency.ct, currency.id\n);\n\nif (periodAmount > 0) {\n\nperiodAccrual.set(0, currency.ct, currency.id);\n\n\nperiodCurrencies.removeByCurrency(currency.ct, currency.id);\n}\n\n\nemit CloseAccrualPeriodEvent(\nperiodAmount,\naggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number],\ncurrency.ct, currency.id\n);\n}\n}","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function claimAndTransferToBeneficiary(Beneficiary beneficiary, address destWallet, string memory balanceType,\naddress currencyCt, uint256 currencyId, string memory standard)\npublic\n{\n\nint256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n\nif (address(0) == currencyCt && 0 == currencyId)\nbeneficiary.receiveEthersTo.value(uint256(claimedAmount))(destWallet, balanceType);\n\nelse {\n\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\n)\n);\nrequire(success, \"Approval by controller failed [TokenHolderRevenueFund.sol:349]\");\n\n\nbeneficiary.receiveTokensTo(destWallet, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}\n\n\nemit ClaimAndTransferToBeneficiaryEvent(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}","after":"function claimAndTransferToBeneficiary(Beneficiary beneficiary, address destWallet, string calldata balanceType,\naddress currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\n\nint256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n\nif (address(0) == currencyCt && 0 == currencyId)\nbeneficiary.receiveEthersTo.value(uint256(claimedAmount))(destWallet, balanceType);\n\nelse {\n\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\n)\n);\nrequire(success, \"Approval by controller failed [TokenHolderRevenueFund.sol:349]\");\n\n\nbeneficiary.receiveTokensTo(destWallet, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}\n\n\nemit ClaimAndTransferToBeneficiaryEvent(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\n\nrequire(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [TokenHolderRevenueFund.sol:384]\");\n\n\namount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n\nstagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Dispatch by controller failed [TokenHolderRevenueFund.sol:403]\");\n}\n\n\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n}","after":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\n\nrequire(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [TokenHolderRevenueFund.sol:384]\");\n\n\namount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n\nstagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Dispatch by controller failed [TokenHolderRevenueFund.sol:403]\");\n}\n\n\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n}","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\npublic\n{\nemit CloseAccrualPeriodEvent();\n}","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata)\npublic\n{\nemit CloseAccrualPeriodEvent();\n}","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"TokenHolderRevenueFund","time":0},{"type":"loop-duplication","before":"\nstart line 6906 column 0, end line 6911 column 1\nfor (i = 0; i < balanceTypes.length; i++)\ntotalBalanceAmount = totalBalanceAmount.add(\nbalanceTracker.get(\nwallet, balanceTypes[i], currencyCt, currencyId\n)\n);\nstart line 6917 column 0, end line 6934 column 0\nfor (i = 0; i < balanceTypes.length; i++) {\nint256 typeAmount = balanceTracker.get(\nwallet, balanceTypes[i], currencyCt, currencyId\n);\n\nif (typeAmount >= _amount) {\nbalanceTracker.sub(\nwallet, balanceTypes[i], _amount, currencyCt, currencyId, true\n);\nbreak;\n\n} else {\nbalanceTracker.set(\nwallet, balanceTypes[i], 0, currencyCt, currencyId, true\n);\n_amount = _amount.sub(typeAmount);\n}\n}","after":"// merge loop\n\nstart line 6906 column 0, end line 6911 column 1\nfor (i = 0; i < balanceTypes.length; i++)\ntotalBalanceAmount = totalBalanceAmount.add(\nbalanceTracker.get(\nwallet, balanceTypes[i], currencyCt, currencyId\n)\n);\nstart line 6917 column 0, end line 6934 column 0\nfor (i = 0; i < balanceTypes.length; i++) {\nint256 typeAmount = balanceTracker.get(\nwallet, balanceTypes[i], currencyCt, currencyId\n);\n\nif (typeAmount >= _amount) {\nbalanceTracker.sub(\nwallet, balanceTypes[i], _amount, currencyCt, currencyId, true\n);\nbreak;\n\n} else {\nbalanceTracker.set(\nwallet, balanceTypes[i], 0, currencyCt, currencyId, true\n);\n_amount = _amount.sub(typeAmount);\n}\n}","contract":"ClientFund","time":0},{"type":"external-function ","before":"function receiveTokens(string memory balanceType, int256 value, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\nreceiveTokensTo(msg.sender, balanceType, value, currencyCt, currencyId, standard);\n}","after":"function receiveTokens(string calldata balanceType, int256 value, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\nreceiveTokensTo(msg.sender, balanceType, value, currencyCt, currencyId, standard);\n}","contract":"ClientFund","time":0},{"type":"external-function ","before":"function updateSettledBalance(address wallet, int256 value, address currencyCt, uint256 currencyId,\nstring memory standard, uint256 blockNumber)\npublic\nonlyAuthorizedService(wallet)\nnotNullAddress(wallet)\n{\nrequire(value.isPositiveInt256());\n\nif (_isFungible(currencyCt, currencyId, standard)) {\n(int256 depositedValue,) = balanceTracker.fungibleRecordByBlockNumber(\nwallet, balanceTracker.depositedBalanceType(), currencyCt, currencyId, blockNumber\n);\nbalanceTracker.set(\nwallet, balanceTracker.settledBalanceType(), value.sub(depositedValue),\ncurrencyCt, currencyId, true\n);\n\n} else {\nbalanceTracker.sub(\nwallet, balanceTracker.depositedBalanceType(), value, currencyCt, currencyId, false\n);\nbalanceTracker.add(\nwallet, balanceTracker.settledBalanceType(), value, currencyCt, currencyId, false\n);\n}\n\n\nemit UpdateSettledBalanceEvent(wallet, value, currencyCt, currencyId);\n}","after":"function updateSettledBalance(address wallet, int256 value, address currencyCt, uint256 currencyId,\nstring calldata standard, uint256 blockNumber)\npublic\nonlyAuthorizedService(wallet)\nnotNullAddress(wallet)\n{\nrequire(value.isPositiveInt256());\n\nif (_isFungible(currencyCt, currencyId, standard)) {\n(int256 depositedValue,) = balanceTracker.fungibleRecordByBlockNumber(\nwallet, balanceTracker.depositedBalanceType(), currencyCt, currencyId, blockNumber\n);\nbalanceTracker.set(\nwallet, balanceTracker.settledBalanceType(), value.sub(depositedValue),\ncurrencyCt, currencyId, true\n);\n\n} else {\nbalanceTracker.sub(\nwallet, balanceTracker.depositedBalanceType(), value, currencyCt, currencyId, false\n);\nbalanceTracker.add(\nwallet, balanceTracker.settledBalanceType(), value, currencyCt, currencyId, false\n);\n}\n\n\nemit UpdateSettledBalanceEvent(wallet, value, currencyCt, currencyId);\n}","contract":"ClientFund","time":0},{"type":"external-function ","before":"function stage(address wallet, int256 value, address currencyCt, uint256 currencyId,\nstring memory standard)\npublic\nonlyAuthorizedService(wallet)\n{\nrequire(value.isNonZeroPositiveInt256());\n\n\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n\nvalue = _subtractSequentially(wallet, balanceTracker.activeBalanceTypes(), value, currencyCt, currencyId, fungible);\n\n\nbalanceTracker.add(\nwallet, balanceTracker.stagedBalanceType(), value, currencyCt, currencyId, fungible\n);\n\n\nemit StageEvent(wallet, value, currencyCt, currencyId, standard);\n}","after":"function stage(address wallet, int256 value, address currencyCt, uint256 currencyId,\nstring calldata standard)\npublic\nonlyAuthorizedService(wallet)\n{\nrequire(value.isNonZeroPositiveInt256());\n\n\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n\nvalue = _subtractSequentially(wallet, balanceTracker.activeBalanceTypes(), value, currencyCt, currencyId, fungible);\n\n\nbalanceTracker.add(\nwallet, balanceTracker.stagedBalanceType(), value, currencyCt, currencyId, fungible\n);\n\n\nemit StageEvent(wallet, value, currencyCt, currencyId, standard);\n}","contract":"ClientFund","time":0},{"type":"external-function ","before":"function unstage(int256 value, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\nrequire(value.isNonZeroPositiveInt256());\n\n\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n\nvalue = _subtractFromStaged(msg.sender, value, currencyCt, currencyId, fungible);\n\n\nbalanceTracker.add(\nmsg.sender, balanceTracker.depositedBalanceType(), value, currencyCt, currencyId, fungible\n);\n\n\nemit UnstageEvent(msg.sender, value, currencyCt, currencyId, standard);\n}","after":"function unstage(int256 value, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\nrequire(value.isNonZeroPositiveInt256());\n\n\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n\nvalue = _subtractFromStaged(msg.sender, value, currencyCt, currencyId, fungible);\n\n\nbalanceTracker.add(\nmsg.sender, balanceTracker.depositedBalanceType(), value, currencyCt, currencyId, fungible\n);\n\n\nemit UnstageEvent(msg.sender, value, currencyCt, currencyId, standard);\n}","contract":"ClientFund","time":0},{"type":"external-function ","before":"function stageToBeneficiary(address wallet, Beneficiary beneficiary, int256 value,\naddress currencyCt, uint256 currencyId, string memory standard)\npublic\nonlyAuthorizedService(wallet)\n{\n\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n\nvalue = _subtractSequentially(wallet, balanceTracker.activeBalanceTypes(), value, currencyCt, currencyId, fungible);\n\n\n_transferToBeneficiary(wallet, beneficiary, value, currencyCt, currencyId, standard);\n\n\nemit StageToBeneficiaryEvent(wallet, beneficiary, value, currencyCt, currencyId, standard);\n}","after":"function stageToBeneficiary(address wallet, Beneficiary beneficiary, int256 value,\naddress currencyCt, uint256 currencyId, string calldata standard)\npublic\nonlyAuthorizedService(wallet)\n{\n\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n\nvalue = _subtractSequentially(wallet, balanceTracker.activeBalanceTypes(), value, currencyCt, currencyId, fungible);\n\n\n_transferToBeneficiary(wallet, beneficiary, value, currencyCt, currencyId, standard);\n\n\nemit StageToBeneficiaryEvent(wallet, beneficiary, value, currencyCt, currencyId, standard);\n}","contract":"ClientFund","time":0},{"type":"external-function ","before":"function transferToBeneficiary(address wallet, Beneficiary beneficiary, int256 value,\naddress currencyCt, uint256 currencyId, string memory standard)\npublic\nonlyAuthorizedService(wallet)\n{\n\n_transferToBeneficiary(wallet, beneficiary, value, currencyCt, currencyId, standard);\n\n\nemit TransferToBeneficiaryEvent(wallet, beneficiary, value, currencyCt, currencyId, standard);\n}","after":"function transferToBeneficiary(address wallet, Beneficiary beneficiary, int256 value,\naddress currencyCt, uint256 currencyId, string calldata standard)\npublic\nonlyAuthorizedService(wallet)\n{\n\n_transferToBeneficiary(wallet, beneficiary, value, currencyCt, currencyId, standard);\n\n\nemit TransferToBeneficiaryEvent(wallet, beneficiary, value, currencyCt, currencyId, standard);\n}","contract":"ClientFund","time":0},{"type":"external-function ","before":"function seizeBalances(address wallet, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\nif (_isFungible(currencyCt, currencyId, standard))\n_seizeFungibleBalances(wallet, msg.sender, currencyCt, currencyId);\n\nelse\n_seizeNonFungibleBalances(wallet, msg.sender, currencyCt, currencyId);\n\n\nif (!seizedByWallet[wallet]) {\nseizedByWallet[wallet] = true;\nseizedWallets.push(wallet);\n}\n}","after":"function seizeBalances(address wallet, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\nif (_isFungible(currencyCt, currencyId, standard))\n_seizeFungibleBalances(wallet, msg.sender, currencyCt, currencyId);\n\nelse\n_seizeNonFungibleBalances(wallet, msg.sender, currencyCt, currencyId);\n\n\nif (!seizedByWallet[wallet]) {\nseizedByWallet[wallet] = true;\nseizedWallets.push(wallet);\n}\n}","contract":"ClientFund","time":0},{"type":"external-function ","before":"function withdraw(int256 value, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\nrequire(value.isNonZeroPositiveInt256());\n\n\nrequire(!walletLocker.isLocked(msg.sender, currencyCt, currencyId));\n\n\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n\nvalue = _subtractFromStaged(msg.sender, value, currencyCt, currencyId, fungible);\n\n\ntransactionTracker.add(\nmsg.sender, transactionTracker.withdrawalTransactionType(), value, currencyCt, currencyId\n);\n\n\n_transferToWallet(msg.sender, value, currencyCt, currencyId, standard);\n\n\nemit WithdrawEvent(msg.sender, value, currencyCt, currencyId, standard);\n}","after":"function withdraw(int256 value, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\nrequire(value.isNonZeroPositiveInt256());\n\n\nrequire(!walletLocker.isLocked(msg.sender, currencyCt, currencyId));\n\n\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n\nvalue = _subtractFromStaged(msg.sender, value, currencyCt, currencyId, fungible);\n\n\ntransactionTracker.add(\nmsg.sender, transactionTracker.withdrawalTransactionType(), value, currencyCt, currencyId\n);\n\n\n_transferToWallet(msg.sender, value, currencyCt, currencyId, standard);\n\n\nemit WithdrawEvent(msg.sender, value, currencyCt, currencyId, standard);\n}","contract":"ClientFund","time":0},{"type":"external-function ","before":"function claimRevenue(address claimer, string memory balanceType, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\nonlyOperator\n{\ntokenHolderRevenueFund.claimAndTransferToBeneficiary(\nthis, claimer, balanceType,\ncurrencyCt, currencyId, standard\n);\n\nemit ClaimRevenueEvent(claimer, balanceType, currencyCt, currencyId, standard);\n}","after":"function claimRevenue(address claimer, string calldata balanceType, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\nonlyOperator\n{\ntokenHolderRevenueFund.claimAndTransferToBeneficiary(\nthis, claimer, balanceType,\ncurrencyCt, currencyId, standard\n);\n\nemit ClaimRevenueEvent(claimer, balanceType, currencyCt, currencyId, standard);\n}","contract":"ClientFund","time":0},{"type":"external-function ","before":"function authorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        require(!initialServiceAuthorizedMap[service]);\n\n\n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n\n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","after":"function authorizeRegisteredServiceAction(address service, string calldata action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        require(!initialServiceAuthorizedMap[service]);\n\n\n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n\n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","contract":"ClientFund","time":0},{"type":"external-function ","before":"function unauthorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        require(!initialServiceAuthorizedMap[service]);\n\n\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n\n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","after":"function unauthorizeRegisteredServiceAction(address service, string calldata action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        require(!initialServiceAuthorizedMap[service]);\n\n\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n\n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","contract":"ClientFund","time":0},{"type":"external-function ","before":"function isAuthorizedRegisteredServiceAction(address service, string memory action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }","after":"function isAuthorizedRegisteredServiceAction(address service, string calldata action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }","contract":"ClientFund","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"ClientFund","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"ClientFund","time":0},{"type":"constant-restrict-modification  ","before":"uint256 maxDriipNonce;","after":"uint256 constant maxDriipNonce;","contract":"CommunityVote","time":0},{"type":"constant-restrict-modification  ","before":"uint256 maxNullNonce;","after":"uint256 constant maxNullNonce;","contract":"CommunityVote","time":0},{"type":"immutable-restrict-modification ","before":"bool dataAvailable;","after":"bool immutable dataAvailable;","contract":"CommunityVote","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"FraudChallenge","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"FraudChallenge","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"FraudChallenge","time":0},{"type":"external-function ","before":"function receiveTokens(string memory balanceType, int256 amount, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\nreceiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);\n}","after":"function receiveTokens(string calldata balanceType, int256 amount, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\nreceiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);\n}","contract":"RevenueFund","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\npublic\nonlyOperator\n{\nrequire(\nConstantsLib.PARTS_PER() == totalBeneficiaryFraction,\n\"Total beneficiary fraction out of bounds [RevenueFund.sol:236]\"\n);\n\n\nfor (uint256 i = 0; i < currencies.length; i++) {\nMonetaryTypesLib.Currency memory currency = currencies[i];\n\nint256 remaining = periodAccrual.get(currency.ct, currency.id);\n\nif (0 >= remaining)\ncontinue;\n\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\nif (beneficiaryFraction(beneficiary) > 0) {\nint256 transferable = periodAccrual.get(currency.ct, currency.id)\n.mul(beneficiaryFraction(beneficiary))\n.div(ConstantsLib.PARTS_PER());\n\nif (transferable > remaining)\ntransferable = remaining;\n\nif (transferable > 0) {\n\nif (currency.ct == address(0))\nbeneficiary.receiveEthersTo.value(uint256(transferable))(address(0), \"\");\n\n\nelse {\nTransferController controller = transferController(currency.ct, \"\");\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(transferable), currency.ct, currency.id\n)\n);\nrequire(success, \"Approval by controller failed [RevenueFund.sol:274]\");\n\nbeneficiary.receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\n}\n\nremaining = remaining.sub(transferable);\n}\n}\n}\n\n\nperiodAccrual.set(remaining, currency.ct, currency.id);\n}\n\n\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n\nif (0 >= beneficiaryFraction(beneficiary))\ncontinue;\n\n\nbeneficiary.closeAccrualPeriod(currencies);\n}\n\n\nemit CloseAccrualPeriodEvent();\n}","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata currencies)\npublic\nonlyOperator\n{\nrequire(\nConstantsLib.PARTS_PER() == totalBeneficiaryFraction,\n\"Total beneficiary fraction out of bounds [RevenueFund.sol:236]\"\n);\n\n\nfor (uint256 i = 0; i < currencies.length; i++) {\nMonetaryTypesLib.Currency memory currency = currencies[i];\n\nint256 remaining = periodAccrual.get(currency.ct, currency.id);\n\nif (0 >= remaining)\ncontinue;\n\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\nif (beneficiaryFraction(beneficiary) > 0) {\nint256 transferable = periodAccrual.get(currency.ct, currency.id)\n.mul(beneficiaryFraction(beneficiary))\n.div(ConstantsLib.PARTS_PER());\n\nif (transferable > remaining)\ntransferable = remaining;\n\nif (transferable > 0) {\n\nif (currency.ct == address(0))\nbeneficiary.receiveEthersTo.value(uint256(transferable))(address(0), \"\");\n\n\nelse {\nTransferController controller = transferController(currency.ct, \"\");\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(transferable), currency.ct, currency.id\n)\n);\nrequire(success, \"Approval by controller failed [RevenueFund.sol:274]\");\n\nbeneficiary.receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\n}\n\nremaining = remaining.sub(transferable);\n}\n}\n}\n\n\nperiodAccrual.set(remaining, currency.ct, currency.id);\n}\n\n\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n\nif (0 >= beneficiaryFraction(beneficiary))\ncontinue;\n\n\nbeneficiary.closeAccrualPeriod(currencies);\n}\n\n\nemit CloseAccrualPeriodEvent();\n}","contract":"RevenueFund","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\npublic\n{\nemit CloseAccrualPeriodEvent();\n}","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata)\npublic\n{\nemit CloseAccrualPeriodEvent();\n}","contract":"RevenueFund","time":0},{"type":"struct-data-arrangement ","before":"\naddress wallet\nuint256 nonce\nuint256 referenceBlockNumber\nuint256 definitionBlockNumber\nuint256 expirationTime\nStatus status\nAmounts amounts\nMonetaryTypesLib.Currency currency\nDriip challenged\nbool walletInitiated\nbool terminated\nDisqualification disqualification","after":"uint256 nonce\nuint256 referenceBlockNumber\nuint256 definitionBlockNumber\nuint256 expirationTime\nStatus status\nAmounts amounts\nMonetaryTypesLib.Currency currency\nDriip challenged\nDisqualification disqualification\naddress wallet\nbool walletInitiated\nbool terminated\n","contract":"SettlementChallengeTypesLib","time":0},{"type":"external-function ","before":"function initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\nint256 targetBalanceAmount, MonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated,\nbytes32 challengedHash, string memory challengedKind)\npublic\nonlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n{\n\n_initiateProposal(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\ncurrency, blockNumber, walletInitiated, challengedHash, challengedKind\n);\n\n\nemit InitiateProposalEvent(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\nblockNumber, walletInitiated, challengedHash, challengedKind\n);\n}","after":"function initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\nint256 targetBalanceAmount, MonetaryTypesLib.Currency calldata currency, uint256 blockNumber, bool walletInitiated,\nbytes32 challengedHash, string calldata challengedKind)\npublic\nonlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n{\n\n_initiateProposal(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\ncurrency, blockNumber, walletInitiated, challengedHash, challengedKind\n);\n\n\nemit InitiateProposalEvent(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\nblockNumber, walletInitiated, challengedHash, challengedKind\n);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n\nproposals[index - 1].terminated = true;\n\n\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n}","after":"function terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool clearNonce)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n\nproposals[index - 1].terminated = true;\n\n\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce,\nbool walletTerminated)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:165]\");\n\n\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n\nproposals[index - 1].terminated = true;\n\n\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n}","after":"function terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool clearNonce,\nbool walletTerminated)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:165]\");\n\n\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n\nproposals[index - 1].terminated = true;\n\n\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n\n_removeProposal(index);\n}","after":"function removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n\n_removeProposal(index);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:225]\");\n\n\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n\n_removeProposal(index);\n}","after":"function removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:225]\");\n\n\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n\n_removeProposal(index);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\nuint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\npublic\nonlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:255]\");\n\n\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\nproposals[index - 1].disqualification.challenger = challengerWallet;\nproposals[index - 1].disqualification.nonce = candidateNonce;\nproposals[index - 1].disqualification.blockNumber = blockNumber;\nproposals[index - 1].disqualification.candidate.hash = candidateHash;\nproposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n\nemit DisqualifyProposalEvent(\nchallengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\ncurrency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nchallengerWallet, candidateNonce, candidateHash, candidateKind\n);\n}","after":"function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency calldata currency, address challengerWallet,\nuint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string calldata candidateKind)\npublic\nonlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:255]\");\n\n\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\nproposals[index - 1].disqualification.challenger = challengerWallet;\nproposals[index - 1].disqualification.nonce = candidateNonce;\nproposals[index - 1].disqualification.blockNumber = blockNumber;\nproposals[index - 1].disqualification.candidate.hash = candidateHash;\nproposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n\nemit DisqualifyProposalEvent(\nchallengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\ncurrency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nchallengerWallet, candidateNonce, candidateHash, candidateKind\n);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function qualifyProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nonlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:284]\");\n\n\nemit QualifyProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].disqualification.challenger,\nproposals[index - 1].disqualification.nonce,\nproposals[index - 1].disqualification.candidate.hash,\nproposals[index - 1].disqualification.candidate.kind\n);\n\n\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\ndelete proposals[index - 1].disqualification;\n}","after":"function qualifyProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nonlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:284]\");\n\n\nemit QualifyProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].disqualification.challenger,\nproposals[index - 1].disqualification.nonce,\nproposals[index - 1].disqualification.candidate.hash,\nproposals[index - 1].disqualification.candidate.kind\n);\n\n\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\ndelete proposals[index - 1].disqualification;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n\nreturn 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];\n}","after":"function hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n\nreturn 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n\nreturn 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n}","after":"function hasProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n\nreturn 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:342]\");\nreturn proposals[index - 1].terminated;\n}","after":"function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:342]\");\nreturn proposals[index - 1].terminated;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:357]\");\nreturn block.timestamp >= proposals[index - 1].expirationTime;\n}","after":"function hasProposalExpired(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:357]\");\nreturn block.timestamp >= proposals[index - 1].expirationTime;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:371]\");\nreturn proposals[index - 1].nonce;\n}","after":"function proposalNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:371]\");\nreturn proposals[index - 1].nonce;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:385]\");\nreturn proposals[index - 1].referenceBlockNumber;\n}","after":"function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:385]\");\nreturn proposals[index - 1].referenceBlockNumber;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:399]\");\nreturn proposals[index - 1].definitionBlockNumber;\n}","after":"function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:399]\");\nreturn proposals[index - 1].definitionBlockNumber;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:413]\");\nreturn proposals[index - 1].expirationTime;\n}","after":"function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:413]\");\nreturn proposals[index - 1].expirationTime;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (SettlementChallengeTypesLib.Status)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:427]\");\nreturn proposals[index - 1].status;\n}","after":"function proposalStatus(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (SettlementChallengeTypesLib.Status)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:427]\");\nreturn proposals[index - 1].status;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:441]\");\nreturn proposals[index - 1].amounts.cumulativeTransfer;\n}","after":"function proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:441]\");\nreturn proposals[index - 1].amounts.cumulativeTransfer;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:455]\");\nreturn proposals[index - 1].amounts.stage;\n}","after":"function proposalStageAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:455]\");\nreturn proposals[index - 1].amounts.stage;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:469]\");\nreturn proposals[index - 1].amounts.targetBalance;\n}","after":"function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:469]\");\nreturn proposals[index - 1].amounts.targetBalance;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalChallengedHash(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:483]\");\nreturn proposals[index - 1].challenged.hash;\n}","after":"function proposalChallengedHash(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:483]\");\nreturn proposals[index - 1].challenged.hash;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalChallengedKind(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:497]\");\nreturn proposals[index - 1].challenged.kind;\n}","after":"function proposalChallengedKind(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:497]\");\nreturn proposals[index - 1].challenged.kind;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:511]\");\nreturn proposals[index - 1].walletInitiated;\n}","after":"function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:511]\");\nreturn proposals[index - 1].walletInitiated;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (address)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:525]\");\nreturn proposals[index - 1].disqualification.challenger;\n}","after":"function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (address)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:525]\");\nreturn proposals[index - 1].disqualification.challenger;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:539]\");\nreturn proposals[index - 1].disqualification.nonce;\n}","after":"function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:539]\");\nreturn proposals[index - 1].disqualification.nonce;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:553]\");\nreturn proposals[index - 1].disqualification.blockNumber;\n}","after":"function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:553]\");\nreturn proposals[index - 1].disqualification.blockNumber;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:567]\");\nreturn proposals[index - 1].disqualification.candidate.hash;\n}","after":"function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:567]\");\nreturn proposals[index - 1].disqualification.candidate.hash;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:581]\");\nreturn proposals[index - 1].disqualification.candidate.kind;\n}","after":"function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:581]\");\nreturn proposals[index - 1].disqualification.candidate.kind;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function upgradeProposal(SettlementChallengeTypesLib.Proposal memory proposal)\npublic\nonlyWhenUpgrading\n{\n\nrequire(\n0 == proposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id],\n\"Proposal exists for wallet, nonce and currency [DriipSettlementChallengeState.sol:592]\"\n);\n\n\nproposals.push(proposal);\n\n\nuint256 index = proposals.length;\n\n\nproposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id] = index;\nproposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id] = index;\n\n\nemit UpgradeProposalEvent(proposal);\n}","after":"function upgradeProposal(SettlementChallengeTypesLib.Proposal calldata proposal)\npublic\nonlyWhenUpgrading\n{\n\nrequire(\n0 == proposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id],\n\"Proposal exists for wallet, nonce and currency [DriipSettlementChallengeState.sol:592]\"\n);\n\n\nproposals.push(proposal);\n\n\nuint256 index = proposals.length;\n\n\nproposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id] = index;\nproposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id] = index;\n\n\nemit UpgradeProposalEvent(proposal);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"struct-data-arrangement ","before":"\nbytes32 nameHash\nuint256 fee\naddress wallet\nuint256 index\nbool operatorCanUpdate\nbool partnerCanUpdate\nFungibleBalanceLib.Balance active\nFungibleBalanceLib.Balance staged\nTxHistoryLib.TxHistory txHistory\nFullBalanceHistory[] fullBalanceHistory","after":"bytes32 nameHash\nuint256 fee\nuint256 index\nFungibleBalanceLib.Balance active\nFungibleBalanceLib.Balance staged\nTxHistoryLib.TxHistory txHistory\nFullBalanceHistory[] fullBalanceHistory\naddress wallet\nbool operatorCanUpdate\nbool partnerCanUpdate\n","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function receiveEthersTo(address tag, string memory)\npublic\npayable\n{\n_receiveEthersTo(\nuint256(tag) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\n);\n}","after":"function receiveEthersTo(address tag, string calldata)\npublic\npayable\n{\n_receiveEthersTo(\nuint256(tag) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\n);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function receiveTokens(string memory, int256 amount, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\n_receiveTokensTo(\nindexByWallet(msg.sender) - 1, amount, currencyCt, currencyId, standard\n);\n}","after":"function receiveTokens(string calldata, int256 amount, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\n_receiveTokensTo(\nindexByWallet(msg.sender) - 1, amount, currencyCt, currencyId, standard\n);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function receiveTokensTo(address tag, string memory, int256 amount, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\n_receiveTokensTo(\nuint256(tag) - 1, amount, currencyCt, currencyId, standard\n);\n}","after":"function receiveTokensTo(address tag, string calldata, int256 amount, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\n_receiveTokensTo(\nuint256(tag) - 1, amount, currencyCt, currencyId, standard\n);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function depositByName(string memory name, uint depositIndex)\npublic\nview\nreturns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n{\n\nreturn _depositByIndices(indexByName(name) - 1, depositIndex);\n}","after":"function depositByName(string calldata name, uint depositIndex)\npublic\nview\nreturns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n{\n\nreturn _depositByIndices(indexByName(name) - 1, depositIndex);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function depositsCountByName(string memory name)\npublic\nview\nreturns (uint256)\n{\n\nreturn _depositsCountByIndex(indexByName(name) - 1);\n}","after":"function depositsCountByName(string calldata name)\npublic\nview\nreturns (uint256)\n{\n\nreturn _depositsCountByIndex(indexByName(name) - 1);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function activeBalanceByName(string memory name, address currencyCt, uint256 currencyId)\npublic\nview\nreturns (int256)\n{\n\nreturn _activeBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n}","after":"function activeBalanceByName(string calldata name, address currencyCt, uint256 currencyId)\npublic\nview\nreturns (int256)\n{\n\nreturn _activeBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function stagedBalanceByName(string memory name, address currencyCt, uint256 currencyId)\npublic\nview\nreturns (int256)\n{\n\nreturn _stagedBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n}","after":"function stagedBalanceByName(string calldata name, address currencyCt, uint256 currencyId)\npublic\nview\nreturns (int256)\n{\n\nreturn _stagedBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function registerByName(string memory name, uint256 fee, address wallet,\nbool partnerCanUpdate, bool operatorCanUpdate)\npublic\nonlyOperator\n{\n\nrequire(bytes(name).length > 0, \"Some error message when require fails [PartnerFund.sol:392]\");\n\n\nbytes32 nameHash = hashName(name);\n\n\n_registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\n\n\nemit RegisterPartnerByNameEvent(name, fee, wallet);\n}","after":"function registerByName(string calldata name, uint256 fee, address wallet,\nbool partnerCanUpdate, bool operatorCanUpdate)\npublic\nonlyOperator\n{\n\nrequire(bytes(name).length > 0, \"Some error message when require fails [PartnerFund.sol:392]\");\n\n\nbytes32 nameHash = hashName(name);\n\n\n_registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\n\n\nemit RegisterPartnerByNameEvent(name, fee, wallet);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function isRegisteredByName(string memory name)\npublic\nview\nreturns (bool)\n{\nreturn (0 < _indexByNameHash[hashName(name)]);\n}","after":"function isRegisteredByName(string calldata name)\npublic\nview\nreturns (bool)\n{\nreturn (0 < _indexByNameHash[hashName(name)]);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function feeByName(string memory name)\npublic\nview\nreturns (uint256)\n{\n\nreturn _partnerFeeByIndex(indexByName(name) - 1);\n}","after":"function feeByName(string calldata name)\npublic\nview\nreturns (uint256)\n{\n\nreturn _partnerFeeByIndex(indexByName(name) - 1);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function setFeeByName(string memory name, uint256 newFee)\npublic\n{\n\nuint256 oldFee = _setPartnerFeeByIndex(indexByName(name) - 1, newFee);\n\n\nemit SetFeeByNameEvent(name, oldFee, newFee);\n}","after":"function setFeeByName(string calldata name, uint256 newFee)\npublic\n{\n\nuint256 oldFee = _setPartnerFeeByIndex(indexByName(name) - 1, newFee);\n\n\nemit SetFeeByNameEvent(name, oldFee, newFee);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function walletByName(string memory name)\npublic\nview\nreturns (address)\n{\n\nreturn partners[indexByName(name) - 1].wallet;\n}","after":"function walletByName(string calldata name)\npublic\nview\nreturns (address)\n{\n\nreturn partners[indexByName(name) - 1].wallet;\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function setWalletByName(string memory name, address newWallet)\npublic\n{\n\naddress oldWallet = _setPartnerWalletByIndex(indexByName(name) - 1, newWallet);\n\n\nemit SetPartnerWalletByNameEvent(name, oldWallet, newWallet);\n}","after":"function setWalletByName(string calldata name, address newWallet)\npublic\n{\n\naddress oldWallet = _setPartnerWalletByIndex(indexByName(name) - 1, newWallet);\n\n\nemit SetPartnerWalletByNameEvent(name, oldWallet, newWallet);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\n\nuint256 index = indexByWallet(msg.sender);\n\n\nrequire(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:736]\");\n\n\namount = amount.clampMax(partners[index - 1].staged.get(currencyCt, currencyId));\n\npartners[index - 1].staged.sub(amount, currencyCt, currencyId);\n\n\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Some error message when require fails [PartnerFund.sol:754]\");\n}\n\n\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId);\n}","after":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\n\nuint256 index = indexByWallet(msg.sender);\n\n\nrequire(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:736]\");\n\n\namount = amount.clampMax(partners[index - 1].staged.get(currencyCt, currencyId));\n\npartners[index - 1].staged.sub(amount, currencyCt, currencyId);\n\n\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Some error message when require fails [PartnerFund.sol:754]\");\n}\n\n\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function initSettlement(string memory settledKind, bytes32 settledHash, address originWallet,\nuint256 originNonce, address targetWallet, uint256 targetNonce)\npublic\nonlyEnabledServiceAction(INIT_SETTLEMENT_ACTION)\n{\nif (\n0 == walletNonceSettlementIndex[originWallet][originNonce] &&\n0 == walletNonceSettlementIndex[targetWallet][targetNonce]\n) {\n\nsettlements.length++;\n\n\nuint256 index = settlements.length - 1;\n\n\nsettlements[index].settledKind = settledKind;\nsettlements[index].settledHash = settledHash;\nsettlements[index].origin.nonce = originNonce;\nsettlements[index].origin.wallet = originWallet;\nsettlements[index].target.nonce = targetNonce;\nsettlements[index].target.wallet = targetWallet;\n\n\nemit InitSettlementEvent(settlements[index]);\n\n\nindex++;\nwalletSettlementIndices[originWallet].push(index);\nwalletSettlementIndices[targetWallet].push(index);\nwalletNonceSettlementIndex[originWallet][originNonce] = index;\nwalletNonceSettlementIndex[targetWallet][targetNonce] = index;\n}\n}","after":"function initSettlement(string calldata settledKind, bytes32 settledHash, address originWallet,\nuint256 originNonce, address targetWallet, uint256 targetNonce)\npublic\nonlyEnabledServiceAction(INIT_SETTLEMENT_ACTION)\n{\nif (\n0 == walletNonceSettlementIndex[originWallet][originNonce] &&\n0 == walletNonceSettlementIndex[targetWallet][targetNonce]\n) {\n\nsettlements.length++;\n\n\nuint256 index = settlements.length - 1;\n\n\nsettlements[index].settledKind = settledKind;\nsettlements[index].settledHash = settledHash;\nsettlements[index].origin.nonce = originNonce;\nsettlements[index].origin.wallet = originWallet;\nsettlements[index].target.nonce = targetNonce;\nsettlements[index].target.wallet = targetWallet;\n\n\nemit InitSettlementEvent(settlements[index]);\n\n\nindex++;\nwalletSettlementIndices[originWallet].push(index);\nwalletSettlementIndices[targetWallet].push(index);\nwalletNonceSettlementIndex[originWallet][originNonce] = index;\nwalletNonceSettlementIndex[targetWallet][targetNonce] = index;\n}\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function maxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nreturn walletCurrencyMaxNonce[wallet][currency.ct][currency.id];\n}","after":"function maxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nreturn walletCurrencyMaxNonce[wallet][currency.ct][currency.id];\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function setMaxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency,\nuint256 maxNonce)\npublic\nonlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n{\n\nwalletCurrencyMaxNonce[wallet][currency.ct][currency.id] = maxNonce;\n\n\nemit SetMaxNonceByWalletAndCurrencyEvent(wallet, currency, maxNonce);\n}","after":"function setMaxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency calldata currency,\nuint256 maxNonce)\npublic\nonlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n{\n\nwalletCurrencyMaxNonce[wallet][currency.ct][currency.id] = maxNonce;\n\n\nemit SetMaxNonceByWalletAndCurrencyEvent(wallet, currency, maxNonce);\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function settledAmountByBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency,\nuint256 blockNumber)\npublic\nview\nreturns (int256)\n{\nuint256 settledBlockNumber = _walletSettledBlockNumber(wallet, currency, blockNumber);\nreturn walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber];\n}","after":"function settledAmountByBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency,\nuint256 blockNumber)\npublic\nview\nreturns (int256)\n{\nuint256 settledBlockNumber = _walletSettledBlockNumber(wallet, currency, blockNumber);\nreturn walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber];\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function addSettledAmountByBlockNumber(address wallet, int256 amount, MonetaryTypesLib.Currency memory currency,\nuint256 blockNumber)\npublic\nonlyEnabledServiceAction(ADD_SETTLED_AMOUNT_ACTION)\n{\n\nuint256 settledBlockNumber = _walletSettledBlockNumber(wallet, currency, blockNumber);\n\n\nwalletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber] =\nwalletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber].add(amount);\n\n\nwalletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].push(block.number);\n\n\nemit AddSettledAmountEvent(wallet, amount, currency, blockNumber);\n}","after":"function addSettledAmountByBlockNumber(address wallet, int256 amount, MonetaryTypesLib.Currency calldata currency,\nuint256 blockNumber)\npublic\nonlyEnabledServiceAction(ADD_SETTLED_AMOUNT_ACTION)\n{\n\nuint256 settledBlockNumber = _walletSettledBlockNumber(wallet, currency, blockNumber);\n\n\nwalletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber] =\nwalletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber].add(amount);\n\n\nwalletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].push(block.number);\n\n\nemit AddSettledAmountEvent(wallet, amount, currency, blockNumber);\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function totalFee(address wallet, Beneficiary beneficiary, address destination,\nMonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (MonetaryTypesLib.NoncedAmount memory)\n{\nreturn totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id];\n}","after":"function totalFee(address wallet, Beneficiary beneficiary, address destination,\nMonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (MonetaryTypesLib.NoncedAmount memory)\n{\nreturn totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id];\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function setTotalFee(address wallet, Beneficiary beneficiary, address destination,\nMonetaryTypesLib.Currency memory currency, MonetaryTypesLib.NoncedAmount memory _totalFee)\npublic\nonlyEnabledServiceAction(SET_TOTAL_FEE_ACTION)\n{\n\ntotalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id] = _totalFee;\n\n\nemit SetTotalFeeEvent(wallet, beneficiary, destination, currency, _totalFee);\n}","after":"function setTotalFee(address wallet, Beneficiary beneficiary, address destination,\nMonetaryTypesLib.Currency calldata currency, MonetaryTypesLib.NoncedAmount calldata _totalFee)\npublic\nonlyEnabledServiceAction(SET_TOTAL_FEE_ACTION)\n{\n\ntotalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id] = _totalFee;\n\n\nemit SetTotalFeeEvent(wallet, beneficiary, destination, currency, _totalFee);\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function upgradeSettlement(DriipSettlementTypesLib.Settlement memory settlement)\npublic\nonlyWhenUpgrading\n{\n\nrequire(\n0 == walletNonceSettlementIndex[settlement.origin.wallet][settlement.origin.nonce],\n\"Settlement exists for origin wallet and nonce [DriipSettlementState.sol:443]\"\n);\nrequire(\n0 == walletNonceSettlementIndex[settlement.target.wallet][settlement.target.nonce],\n\"Settlement exists for target wallet and nonce [DriipSettlementState.sol:447]\"\n);\n\n\nsettlements.push(settlement);\n\n\nuint256 index = settlements.length;\n\n\nwalletSettlementIndices[settlement.origin.wallet].push(index);\nwalletSettlementIndices[settlement.target.wallet].push(index);\nwalletNonceSettlementIndex[settlement.origin.wallet][settlement.origin.nonce] = index;\nwalletNonceSettlementIndex[settlement.target.wallet][settlement.target.nonce] = index;\n\n\nemit UpgradeSettlementEvent(settlement);\n}","after":"function upgradeSettlement(DriipSettlementTypesLib.Settlement calldata settlement)\npublic\nonlyWhenUpgrading\n{\n\nrequire(\n0 == walletNonceSettlementIndex[settlement.origin.wallet][settlement.origin.nonce],\n\"Settlement exists for origin wallet and nonce [DriipSettlementState.sol:443]\"\n);\nrequire(\n0 == walletNonceSettlementIndex[settlement.target.wallet][settlement.target.nonce],\n\"Settlement exists for target wallet and nonce [DriipSettlementState.sol:447]\"\n);\n\n\nsettlements.push(settlement);\n\n\nuint256 index = settlements.length;\n\n\nwalletSettlementIndices[settlement.origin.wallet].push(index);\nwalletSettlementIndices[settlement.target.wallet].push(index);\nwalletNonceSettlementIndex[settlement.origin.wallet][settlement.origin.nonce] = index;\nwalletNonceSettlementIndex[settlement.target.wallet][settlement.target.nonce] = index;\n\n\nemit UpgradeSettlementEvent(settlement);\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function upgradeSettledAmount(address wallet, int256 amount, MonetaryTypesLib.Currency memory currency,\nuint256 blockNumber)\npublic\nonlyWhenUpgrading\n{\n\nrequire(0 == walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][blockNumber], \"[DriipSettlementState.sol:479]\");\n\n\nwalletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][blockNumber] = amount;\n\n\nwalletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].push(blockNumber);\n\n\nemit UpgradeSettledAmountEvent(wallet, amount, currency, blockNumber);\n}","after":"function upgradeSettledAmount(address wallet, int256 amount, MonetaryTypesLib.Currency calldata currency,\nuint256 blockNumber)\npublic\nonlyWhenUpgrading\n{\n\nrequire(0 == walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][blockNumber], \"[DriipSettlementState.sol:479]\");\n\n\nwalletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][blockNumber] = amount;\n\n\nwalletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].push(blockNumber);\n\n\nemit UpgradeSettledAmountEvent(wallet, amount, currency, blockNumber);\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementState","time":1},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function settlePayment(PaymentTypesLib.Payment memory payment, string memory standard)\npublic\n{\n\n_settlePayment(msg.sender, payment, standard);\n\n\nemit SettlePaymentEvent(msg.sender, payment, standard);\n}","after":"function settlePayment(PaymentTypesLib.Payment calldata payment, string calldata standard)\npublic\n{\n\n_settlePayment(msg.sender, payment, standard);\n\n\nemit SettlePaymentEvent(msg.sender, payment, standard);\n}","contract":"DriipSettlementByPayment","time":0},{"type":"external-function ","before":"function settlePaymentByProxy(address wallet, PaymentTypesLib.Payment memory payment, string memory standard)\npublic\nonlyOperator\n{\n\n_settlePayment(wallet, payment, standard);\n\n\nemit SettlePaymentByProxyEvent(msg.sender, wallet, payment, standard);\n}","after":"function settlePaymentByProxy(address wallet, PaymentTypesLib.Payment calldata payment, string calldata standard)\npublic\nonlyOperator\n{\n\n_settlePayment(wallet, payment, standard);\n\n\nemit SettlePaymentByProxyEvent(msg.sender, wallet, payment, standard);\n}","contract":"DriipSettlementByPayment","time":0}]}