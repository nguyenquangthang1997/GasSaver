{"time":331,"results":[{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"Eraswap","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"Eraswap","time":0},{"type":"immutable-restrict-modification ","before":"uint8 private _decimals;","after":"uint8 private immutable _decimals;","contract":"Eraswap","time":0},{"type":"immutable-restrict-modification ","before":"uint256 private _cap;","after":"uint256 private immutable _cap;","contract":"Eraswap","time":0},{"type":"immutable-restrict-modification ","before":"address Owner;","after":"address immutable Owner;","contract":"NRTManager","time":0},{"type":"external-function ","before":"function giveLaunchReward(address[] memory _addresses, uint256[] memory _exaEsAmountArray) public onlyOwner {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","after":"function giveLaunchReward(address[] calldata _addresses, uint256[] calldata _exaEsAmountArray) public onlyOwner {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function seeBenefitOfAStakingByMonths(\n        address _userAddress,\n        uint256 _stakingId,\n        uint256[] memory _months\n    ) public view returns (uint256) {\n        uint256 benefitOfAllMonths;\n        for (uint256 i = 0; i < _months.length; i++) {\n            /// @dev this require statement is converted into if statement for easier UI fetching. If there is no benefit for a month or already claimed, it will consider benefit of that month as 0 ES. But same is not done for withdraw function.\n            // require(\n            //   isStakingActive(_userAddress, _stakingId, _months[i])\n            //   && !stakings[_userAddress][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if (isStakingActive(_userAddress, _stakingId, _months[i])\n                && !stakings[_userAddress][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 benefit = stakings[_userAddress][_stakingId].exaEsAmount\n                .mul(timeAllyMonthlyNRT[_months[i]])\n                .div(totalActiveStakings[_months[i]]);\n                benefitOfAllMonths = benefitOfAllMonths.add(benefit);\n            }\n        }\n        return benefitOfAllMonths.mul(\n            stakingPlans[stakings[_userAddress][_stakingId].stakingPlanId].fractionFrom15\n        ).div(15);\n    }","after":"function seeBenefitOfAStakingByMonths(\n        address _userAddress,\n        uint256 _stakingId,\n        uint256[] calldata _months\n    ) public view returns (uint256) {\n        uint256 benefitOfAllMonths;\n        for (uint256 i = 0; i < _months.length; i++) {\n            /// @dev this require statement is converted into if statement for easier UI fetching. If there is no benefit for a month or already claimed, it will consider benefit of that month as 0 ES. But same is not done for withdraw function.\n            // require(\n            //   isStakingActive(_userAddress, _stakingId, _months[i])\n            //   && !stakings[_userAddress][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if (isStakingActive(_userAddress, _stakingId, _months[i])\n                && !stakings[_userAddress][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 benefit = stakings[_userAddress][_stakingId].exaEsAmount\n                .mul(timeAllyMonthlyNRT[_months[i]])\n                .div(totalActiveStakings[_months[i]]);\n                benefitOfAllMonths = benefitOfAllMonths.add(benefit);\n            }\n        }\n        return benefitOfAllMonths.mul(\n            stakingPlans[stakings[_userAddress][_stakingId].stakingPlanId].fractionFrom15\n        ).div(15);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] memory _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for (uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if (isStakingActive(msg.sender, _stakingId, _months[i])\n                && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                .mul(timeAllyMonthlyNRT[_months[i]])\n                .div(totalActiveStakings[_months[i]]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n        .mul(uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15))\n        .div(15);\n\n        require(token.transfer(address(nrtManager), _luckPool));\n        require(nrtManager.UpdateLuckpool(_luckPool));\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require(token.transfer(msg.sender, _halfBenefit));\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","after":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] calldata _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for (uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if (isStakingActive(msg.sender, _stakingId, _months[i])\n                && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                .mul(timeAllyMonthlyNRT[_months[i]])\n                .div(totalActiveStakings[_months[i]]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n        .mul(uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15))\n        .div(15);\n\n        require(token.transfer(address(nrtManager), _luckPool));\n        require(nrtManager.UpdateLuckpool(_luckPool));\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require(token.transfer(msg.sender, _halfBenefit));\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawExpiredStakings(uint256[] memory _stakingIds) public {\n        for (uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n            .add(stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months.mul(earthSecondsInMonth))\n            // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","after":"function withdrawExpiredStakings(uint256[] calldata _stakingIds) public {\n        for (uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n            .add(stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months.mul(earthSecondsInMonth))\n            // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function seeMaxLoaningAmountOnUserStakings(address _userAddress, uint256[] memory _stakingIds, uint256 _loanPlanId) public view returns (uint256) {\n        uint256 _currentMonth = getCurrentMonth();\n        //require(_currentMonth >= _atMonth, 'cannot see future stakings');\n\n        uint256 userStakingsExaEsAmount;\n\n        for (uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if (isStakingActive(_userAddress, _stakingIds[i], _currentMonth)\n                && (\n                // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                stakingPlans[stakings[_userAddress][_stakingIds[i]].stakingPlanId].isUrgentLoanAllowed\n                || now > stakings[_userAddress][_stakingIds[i]].timestamp + stakingPlans[stakings[_userAddress][_stakingIds[i]].stakingPlanId].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n                userStakingsExaEsAmount = userStakingsExaEsAmount\n                .add(stakings[_userAddress][_stakingIds[i]].exaEsAmount\n                .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                .div(100)\n                // .mul(stakingPlans[ stakings[_userAddress][_stakingIds[i]].stakingPlanId ].fractionFrom15)\n                // .div(15)\n                );\n            }\n        }\n\n        return userStakingsExaEsAmount;\n        //.mul( uint256(100).sub(loanPlans[_loanPlanId].loanRate) ).div(100);\n    }","after":"function seeMaxLoaningAmountOnUserStakings(address _userAddress, uint256[] calldata _stakingIds, uint256 _loanPlanId) public view returns (uint256) {\n        uint256 _currentMonth = getCurrentMonth();\n        //require(_currentMonth >= _atMonth, 'cannot see future stakings');\n\n        uint256 userStakingsExaEsAmount;\n\n        for (uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if (isStakingActive(_userAddress, _stakingIds[i], _currentMonth)\n                && (\n                // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                stakingPlans[stakings[_userAddress][_stakingIds[i]].stakingPlanId].isUrgentLoanAllowed\n                || now > stakings[_userAddress][_stakingIds[i]].timestamp + stakingPlans[stakings[_userAddress][_stakingIds[i]].stakingPlanId].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n                userStakingsExaEsAmount = userStakingsExaEsAmount\n                .add(stakings[_userAddress][_stakingIds[i]].exaEsAmount\n                .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                .div(100)\n                // .mul(stakingPlans[ stakings[_userAddress][_stakingIds[i]].stakingPlanId ].fractionFrom15)\n                // .div(15)\n                );\n            }\n        }\n\n        return userStakingsExaEsAmount;\n        //.mul( uint256(100).sub(loanPlans[_loanPlanId].loanRate) ).div(100);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] memory _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for (uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if (isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].isUrgentLoanAllowed\n                || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                .add(\n                    stakings[msg.sender][_stakingIds[i]].exaEsAmount\n                    .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                    .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for (uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for (uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][_stakingIds[i]].isMonthClaimed[_currentMonth + j] = true;\n                    stakings[msg.sender][_stakingIds[i]].status = 2;\n                    // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if (_exaEsAmount > _maxLoaningAmount) {\n            require(false\n            // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require(token.transfer(address(nrtManager), _loanInterest));\n        require(nrtManager.UpdateLuckpool(_loanInterest));\n\n        loans[msg.sender].push(Loan({\n        exaEsAmount : _exaEsAmount,\n        timestamp : now,\n        loanPlanId : _loanPlanId,\n        status : 1,\n        stakingIds : _stakingIds\n        }));\n\n        // @dev send user amount\n        require(token.transfer(msg.sender, _loanAmountToTransfer));\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","after":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] calldata _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for (uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if (isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].isUrgentLoanAllowed\n                || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                .add(\n                    stakings[msg.sender][_stakingIds[i]].exaEsAmount\n                    .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                    .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for (uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for (uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][_stakingIds[i]].isMonthClaimed[_currentMonth + j] = true;\n                    stakings[msg.sender][_stakingIds[i]].status = 2;\n                    // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if (_exaEsAmount > _maxLoaningAmount) {\n            require(false\n            // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require(token.transfer(address(nrtManager), _loanInterest));\n        require(nrtManager.UpdateLuckpool(_loanInterest));\n\n        loans[msg.sender].push(Loan({\n        exaEsAmount : _exaEsAmount,\n        timestamp : now,\n        loanPlanId : _loanPlanId,\n        status : 1,\n        stakingIds : _stakingIds\n        }));\n\n        // @dev send user amount\n        require(token.transfer(msg.sender, _loanAmountToTransfer));\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function burnDefaultedLoans(address[] memory _addressArray, uint256[] memory _loanIdArray) public {\n        uint256 _amountToBurn;\n        for (uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[_addressArray[i]][_loanIdArray[i]].status == 1\n            // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[_addressArray[i]][_loanIdArray[i]].timestamp\n                + loanPlans[loans[_addressArray[i]][_loanIdArray[i]].loanPlanId].loanMonths.mul(earthSecondsInMonth)\n            // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[_addressArray[i]][_loanIdArray[i]].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for (uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[_addressArray[i]][_stakingIdsOfLoan[j]].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[_addressArray[i]][_loanIdArray[i]].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","after":"function burnDefaultedLoans(address[] calldata _addressArray, uint256[] calldata _loanIdArray) public {\n        uint256 _amountToBurn;\n        for (uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[_addressArray[i]][_loanIdArray[i]].status == 1\n            // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[_addressArray[i]][_loanIdArray[i]].timestamp\n                + loanPlans[loans[_addressArray[i]][_loanIdArray[i]].loanPlanId].loanMonths.mul(earthSecondsInMonth)\n            // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[_addressArray[i]][_loanIdArray[i]].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for (uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[_addressArray[i]][_stakingIdsOfLoan[j]].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[_addressArray[i]][_loanIdArray[i]].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","contract":"TimeAlly","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public deployedTimestamp;","after":"uint256 public immutable deployedTimestamp;","contract":"TimeAlly","time":1},{"type":"immutable-restrict-modification ","before":"address public owner;","after":"address public immutable owner;","contract":"TimeAlly","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public earthSecondsInMonth = 2629744;","after":"uint256 public constant earthSecondsInMonth = 2629744;","contract":"TimeAlly","time":1}]}