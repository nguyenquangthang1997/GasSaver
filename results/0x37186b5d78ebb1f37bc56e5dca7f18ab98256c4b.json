{"time":375,"results":[{"type":"external-function ","before":"function balanceOfBatch(\n\n        address[] memory owners,\n\n        uint256[] memory ids\n\n    )\n\n    public\n\n    view\n\n    returns (uint256[] memory)\n\n    {\n\n        require(owners.length == ids.length, \"ERC1155: owners and IDs must have same lengths\");\n\n\n        uint256[] memory batchBalances = new uint256[](owners.length);\n\n\n        for (uint256 i = 0; i < owners.length; ++i) {\n\n            require(owners[i] != address(0), \"ERC1155: some address in batch balance query is zero\");\n\n            batchBalances[i] = _balances[ids[i]][owners[i]];\n\n        }\n\n\n        return batchBalances;\n\n    }","after":"function balanceOfBatch(\n\n        address[] calldata owners,\n\n        uint256[] calldata ids\n\n    )\n\n    public\n\n    view\n\n    returns (uint256[] memory)\n\n    {\n\n        require(owners.length == ids.length, \"ERC1155: owners and IDs must have same lengths\");\n\n\n        uint256[] memory batchBalances = new uint256[](owners.length);\n\n\n        for (uint256 i = 0; i < owners.length; ++i) {\n\n            require(owners[i] != address(0), \"ERC1155: some address in batch balance query is zero\");\n\n            batchBalances[i] = _balances[ids[i]][owners[i]];\n\n        }\n\n\n        return batchBalances;\n\n    }","contract":"ConditionalTokens","time":0},{"type":"external-function ","before":"n Maximum number\n\n    function max(int[] memory nums)\n\n    public\n\n    pure\n\n    returns (int maxNum)\n\n    {\n\n        require(nums.length > 0);\n\n        maxNum = - 2 ** 255;\n\n        for (uint i = 0; i < nums.length; i++)\n\n            if (nums[i] > maxNum)\n\n                ma","after":"n Maximum number\n\n    function max(int[] memory nums)\n\n    public\n\n    pure\n\n    returns (int maxNum)\n\n    {\n\n        require(nums.length > 0);\n\n        maxNum = - 2 ** 255;\n\n        for (uint i = 0; i < nums.length; i++)\n\n            if (nums[i] > maxNum)\n\n                ma","contract":"Fixed192x64Math","time":0},{"type":"state-data-arrangement ","before":"\nnstants\n\n     */\n\n    uint64 public constant\nStorage\n\n     */\n\n    ConditionalT\npublic pmSystem;\n\n    IERC20 p\ncollateralToken;\n\n    bytes32[\nic conditionIds;\n\n    uint public a\nutcomeSlotCount;\n\n\nnt64 public fee;\n\n  \n public funding;\n\n \nge public stage;\n\n    White\nblic whitelist;\n\n\n    uin\ntcomeSlotCounts;\n\n    byte\n] collectionIds;\n\n ","after":"Storage\n\n     */\n\n    ConditionalT\npublic pmSystem;\n\n    IERC20 p\ncollateralToken;\n\n    bytes32[\nic conditionIds;\n\n    uint public a\nnt64 public fee;\n\n  \n public funding;\n\n \nge public stage;\n\n    White\nblic whitelist;\n\n\n    uin\ntcomeSlotCounts;\n\n    byte\n] collectionIds;\n\n \nnstants\n\n     */\n\n    uint64 public constant\nutcomeSlotCount;\n\n\n","contract":"MarketMaker","time":0},{"type":"loop-calculation","before":"; i++) {\n\n            int negBalance = - int(pmSystem.balanceOf(address(this), generate","after":"// move outside for loop\n; i++) {\n\n            int negBalance = - int(pmSystem.balanceOf(address(this), generate","loc":{"start":{"line":4323,"column":12},"end":{"line":4323,"column":98}},"contract":"LMSRMarketMaker","time":0},{"type":"external-function ","before":"ent or received.\n\n    function trade(int[] memory outcomeTokenAmounts, int collateralLimit)\n\n    public\n\n    atStage(Stage.Running)\n\n    onlyWhitelisted\n\n    returns (int netCost)\n\n    {\n\n        require(outcomeTokenAmounts.length == atomicOutcomeSlotCount);\n\n\n        // Calculate net cost for executing trade\n\n        int outcomeTokenNetCost = calcNetCost(outcomeTokenAmounts);\n\n        int fees;\n\n        if (outcomeTokenNetCost < 0)\n\n            fees = int(calcMarketFee(uint(- outcomeTokenNetCost)));\n\n        else\n\n            fees = int(calcMarketFee(uint(outcomeTokenNetCost)));\n\n\n        require(fees >= 0);\n\n        netCost = outcomeTokenNetCost.add(fees);\n\n\n        require(\n\n            (collateralLimit != 0 && netCost <= collateralLimit) ||\n\n            collateralLimit == 0\n\n        );\n\n\n        if (outcomeTokenNetCost > 0) {\n\n            require(\n\n                collateralToken.transferFrom(msg.sender, address(this), uint(netCost)) &&\n\n                collateralToken.approve(address(pmSystem), uint(outcomeTokenNetCost))\n\n            );\n\n\n            splitPositionThroughAllConditions(uint(outcomeTokenNetCost));\n\n        }\n\n\n        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {\n\n            if (outcomeTokenAmounts[i] != 0) {\n\n                uint positionId = generateAtomicPositionId(i);\n\n                if (outcomeTokenAmounts[i] < 0) {\n\n                    pmSystem.safeTransferFrom(msg.sender, address(this), positionId, uint(- outcomeTokenAmounts[i]), \"\");\n\n                } else {\n\n                    pmSystem.safeTransferFrom(address(this), msg.sender, positionId, uint(outcomeTokenAmounts[i]), \"\");\n\n                }\n\n\n            }\n\n        }\n\n\n        if (outcomeTokenNetCost < 0) {\n\n            // This is safe since\n\n            // 0x8000000000000000000000000000000000000000000000000000000000000000 ==\n\n            // uint(-int(-0x8000000000000000000000000000000000000000000000000000000000000000))\n\n            mergePositionsThroughAllConditions(uint(- outcomeTokenNetCost));\n\n            if (netCost < 0) {\n\n                require(collateralToken.transfer(msg.sender, uint(- netCost)));\n\n            }\n\n        }\n\n\n        emit AMMOutcomeTokenTrade(msg.sender, outcomeTokenAmounts, outcomeTokenNetCos","after":"ent or received.\n\n    function trade(int[] calldata outcomeTokenAmounts, int collateralLimit)\n\n    public\n\n    atStage(Stage.Running)\n\n    onlyWhitelisted\n\n    returns (int netCost)\n\n    {\n\n        require(outcomeTokenAmounts.length == atomicOutcomeSlotCount);\n\n\n        // Calculate net cost for executing trade\n\n        int outcomeTokenNetCost = calcNetCost(outcomeTokenAmounts);\n\n        int fees;\n\n        if (outcomeTokenNetCost < 0)\n\n            fees = int(calcMarketFee(uint(- outcomeTokenNetCost)));\n\n        else\n\n            fees = int(calcMarketFee(uint(outcomeTokenNetCost)));\n\n\n        require(fees >= 0);\n\n        netCost = outcomeTokenNetCost.add(fees);\n\n\n        require(\n\n            (collateralLimit != 0 && netCost <= collateralLimit) ||\n\n            collateralLimit == 0\n\n        );\n\n\n        if (outcomeTokenNetCost > 0) {\n\n            require(\n\n                collateralToken.transferFrom(msg.sender, address(this), uint(netCost)) &&\n\n                collateralToken.approve(address(pmSystem), uint(outcomeTokenNetCost))\n\n            );\n\n\n            splitPositionThroughAllConditions(uint(outcomeTokenNetCost));\n\n        }\n\n\n        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {\n\n            if (outcomeTokenAmounts[i] != 0) {\n\n                uint positionId = generateAtomicPositionId(i);\n\n                if (outcomeTokenAmounts[i] < 0) {\n\n                    pmSystem.safeTransferFrom(msg.sender, address(this), positionId, uint(- outcomeTokenAmounts[i]), \"\");\n\n                } else {\n\n                    pmSystem.safeTransferFrom(address(this), msg.sender, positionId, uint(outcomeTokenAmounts[i]), \"\");\n\n                }\n\n\n            }\n\n        }\n\n\n        if (outcomeTokenNetCost < 0) {\n\n            // This is safe since\n\n            // 0x8000000000000000000000000000000000000000000000000000000000000000 ==\n\n            // uint(-int(-0x8000000000000000000000000000000000000000000000000000000000000000))\n\n            mergePositionsThroughAllConditions(uint(- outcomeTokenNetCost));\n\n            if (netCost < 0) {\n\n                require(collateralToken.transfer(msg.sender, uint(- netCost)));\n\n            }\n\n        }\n\n\n        emit AMMOutcomeTokenTrade(msg.sender, outcomeTokenAmounts, outcomeTokenNetCos","contract":"LMSRMarketMaker","time":0},{"type":"constant-restrict-modification  ","before":"ic conditionIds;\n\n    uint public a","after":"ic conditionIds;\n\n    uint public a","contract":"LMSRMarketMaker","time":1},{"type":"state-data-arrangement ","before":"\narketMakerData {\n\n    ad\nexed newOwner);\n\n\n    bytes4 internal constant _INTERFACE_I\n65 = 0x01ffc9a7;\n\n    mapping(bytes4 => bool) internal\nrtedInterfaces;\n\n\n    uint64 constant\ninitialFunding);\n\n    ConditionalTok\nternal pmSystem;\n\n    IERC20 int\ncollateralToken;\n\n    bytes32[] \nal conditionIds;\n\n    uint internal a\nutcomeSlotCount;\n\n  \n64 internal fee;\n\n    \nnternal funding;\n\n   \n internal stage;\n\n    Whiteli\nrnal whitelist;\n\n\n    uint[] inter\ntcomeSlotCounts;\n\n    bytes32[][] i\nl collectionIds;\n\n    uint[]","after":"65 = 0x01ffc9a7;\n\n    mapping(bytes4 => bool) internal\ninitialFunding);\n\n    ConditionalTok\nternal pmSystem;\n\n    IERC20 int\ncollateralToken;\n\n    bytes32[] \nal conditionIds;\n\n    uint internal a\n64 internal fee;\n\n    \nnternal funding;\n\n   \n internal stage;\n\n    Whiteli\nrnal whitelist;\n\n\n    uint[] inter\ntcomeSlotCounts;\n\n    bytes32[][] i\nl collectionIds;\n\n    uint[]\narketMakerData {\n\n    ad\nrtedInterfaces;\n\n\n    uint64 constant\nutcomeSlotCount;\n\n  \nexed newOwner);\n\n\n    bytes4 internal constant _INTERFACE_I\n","contract":"LMSRMarketMakerData","time":0},{"type":"constant-restrict-modification  ","before":"64 internal fee;\n\n    ","after":"64 internal fee;\n\n    ","contract":"LMSRMarketMakerFactory","time":0}]}