{"time":283,"results":[{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"zBTC","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"zBTC","time":0},{"type":"immutable-restrict-modification ","before":"   uint8 private _decima","after":"   uint8 private _decima","contract":"zBTC","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"zZEC","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"zZEC","time":0},{"type":"immutable-restrict-modification ","before":"   uint8 private _decima","after":"   uint8 private _decima","contract":"zZEC","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"zBCH","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"zBCH","time":0},{"type":"immutable-restrict-modification ","before":"   uint8 private _decima","after":"   uint8 private _decima","contract":"zBCH","time":0},{"type":"state-data-arrangement ","before":"\n   uint8 public version =\n   uint256 constant BIPS_DENOMINATOR = 100\n   uint256 public minShiftAmou\n   ERC20Shifted public tok\n   address public mintAuthori\n   address public feeRecipie\n   uint16 public shiftInF\n   uint16 public shiftOutF\n   mapping(bytes32 => bool) public stat\n   uint256 public nextShiftID =","after":"   uint256 constant BIPS_DENOMINATOR = 100\n   uint256 public minShiftAmou\n   ERC20Shifted public tok\n   mapping(bytes32 => bool) public stat\n   uint256 public nextShiftID =\n   address public mintAuthori\n   address public feeRecipie\n   uint16 public shiftInF\n   uint16 public shiftOutF\n   uint8 public version =\n","contract":"Shifter","time":0},{"type":"external-function ","before":"   function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes memory _sig) public returns (uint256) {\n\n        // Verify signature\n\n        bytes32 signedMessageHash = hashForSignature(_pHash, _amount, msg.sender, _nHash);\n\n        require(status[signedMessageHash] == false, \"Shifter: nonce hash already spent\");\n\n        if (!verifySignature(signedMessageHash, _sig)) {\n\n            // Return a detailed string containing the hash and recovered\n\n            // signer. This is a costly operation but is only run in the revert\n\n            // branch.\n\n            revert(\n\n            String.add4(\n\n                \"Shifter: invalid signature - hash: \",\n\n                String.fromBytes32(signedMessageHash),\n\n                \", signer: \",\n\n                String.fromAddress(ECDSA.recover(signedMessageHash, _sig))\n\n            )\n\n            );\n\n        }\n\n        status[signedMessageHash] = true;\n\n\n        // Mint `amount - fee` for the recipient and mint `fee` for the minter\n\n        uint256 absoluteFee = (_amount.mul(shiftInFee)).div(BIPS_DENOMINATOR);\n\n        uint256 receivedAmount = _amount.sub(absoluteFee);\n\n        token.mint(msg.sender, receivedAmount);\n\n        token.mint(feeRecipient, absoluteFee);\n\n\n        // Emit a log with a unique shift ID\n\n        emit LogShiftIn(msg.sender, receivedAmount, nextShiftID, signedMessageHash);\n\n        nextShiftID += 1;\n\n\n        return receivedAmount;\n\n  ","after":"   function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes calldata _sig) public returns (uint256) {\n\n        // Verify signature\n\n        bytes32 signedMessageHash = hashForSignature(_pHash, _amount, msg.sender, _nHash);\n\n        require(status[signedMessageHash] == false, \"Shifter: nonce hash already spent\");\n\n        if (!verifySignature(signedMessageHash, _sig)) {\n\n            // Return a detailed string containing the hash and recovered\n\n            // signer. This is a costly operation but is only run in the revert\n\n            // branch.\n\n            revert(\n\n            String.add4(\n\n                \"Shifter: invalid signature - hash: \",\n\n                String.fromBytes32(signedMessageHash),\n\n                \", signer: \",\n\n                String.fromAddress(ECDSA.recover(signedMessageHash, _sig))\n\n            )\n\n            );\n\n        }\n\n        status[signedMessageHash] = true;\n\n\n        // Mint `amount - fee` for the recipient and mint `fee` for the minter\n\n        uint256 absoluteFee = (_amount.mul(shiftInFee)).div(BIPS_DENOMINATOR);\n\n        uint256 receivedAmount = _amount.sub(absoluteFee);\n\n        token.mint(msg.sender, receivedAmount);\n\n        token.mint(feeRecipient, absoluteFee);\n\n\n        // Emit a log with a unique shift ID\n\n        emit LogShiftIn(msg.sender, receivedAmount, nextShiftID, signedMessageHash);\n\n        nextShiftID += 1;\n\n\n        return receivedAmount;\n\n  ","contract":"BTCShifter","time":0},{"type":"external-function ","before":"   function shiftOut(bytes memory _to, uint256 _amount) public returns (uint256) {\n\n        // The recipient must not be empty. Better validation is possible,\n\n        // but would need to be customized for each destination ledger.\n\n        require(_to.length != 0, \"Shifter: to address is empty\");\n\n        require(_amount >= minShiftAmount, \"Shifter: amount is less than the minimum shiftOut amount\");\n\n\n        // Burn full amount and mint fee\n\n        uint256 absoluteFee = (_amount.mul(shiftOutFee)).div(BIPS_DENOMINATOR);\n\n        token.burn(msg.sender, _amount);\n\n        token.mint(feeRecipient, absoluteFee);\n\n\n        // Emit a log with a unique shift ID\n\n        uint256 receivedValue = _amount.sub(absoluteFee);\n\n        emit LogShiftOut(_to, receivedValue, nextShiftID, _to);\n\n        nextShiftID += 1;\n\n\n        return receivedValue;\n\n  ","after":"   function shiftOut(bytes calldata _to, uint256 _amount) public returns (uint256) {\n\n        // The recipient must not be empty. Better validation is possible,\n\n        // but would need to be customized for each destination ledger.\n\n        require(_to.length != 0, \"Shifter: to address is empty\");\n\n        require(_amount >= minShiftAmount, \"Shifter: amount is less than the minimum shiftOut amount\");\n\n\n        // Burn full amount and mint fee\n\n        uint256 absoluteFee = (_amount.mul(shiftOutFee)).div(BIPS_DENOMINATOR);\n\n        token.burn(msg.sender, _amount);\n\n        token.mint(feeRecipient, absoluteFee);\n\n\n        // Emit a log with a unique shift ID\n\n        uint256 receivedValue = _amount.sub(absoluteFee);\n\n        emit LogShiftOut(_to, receivedValue, nextShiftID, _to);\n\n        nextShiftID += 1;\n\n\n        return receivedValue;\n\n  ","contract":"BTCShifter","time":0},{"type":"constant-restrict-modification  ","before":"   uint8 public version =","after":"   uint8 public constant version =","contract":"BTCShifter","time":1},{"type":"external-function ","before":"   function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes memory _sig) public returns (uint256) {\n\n        // Verify signature\n\n        bytes32 signedMessageHash = hashForSignature(_pHash, _amount, msg.sender, _nHash);\n\n        require(status[signedMessageHash] == false, \"Shifter: nonce hash already spent\");\n\n        if (!verifySignature(signedMessageHash, _sig)) {\n\n            // Return a detailed string containing the hash and recovered\n\n            // signer. This is a costly operation but is only run in the revert\n\n            // branch.\n\n            revert(\n\n            String.add4(\n\n                \"Shifter: invalid signature - hash: \",\n\n                String.fromBytes32(signedMessageHash),\n\n                \", signer: \",\n\n                String.fromAddress(ECDSA.recover(signedMessageHash, _sig))\n\n            )\n\n            );\n\n        }\n\n        status[signedMessageHash] = true;\n\n\n        // Mint `amount - fee` for the recipient and mint `fee` for the minter\n\n        uint256 absoluteFee = (_amount.mul(shiftInFee)).div(BIPS_DENOMINATOR);\n\n        uint256 receivedAmount = _amount.sub(absoluteFee);\n\n        token.mint(msg.sender, receivedAmount);\n\n        token.mint(feeRecipient, absoluteFee);\n\n\n        // Emit a log with a unique shift ID\n\n        emit LogShiftIn(msg.sender, receivedAmount, nextShiftID, signedMessageHash);\n\n        nextShiftID += 1;\n\n\n        return receivedAmount;\n\n  ","after":"   function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes calldata _sig) public returns (uint256) {\n\n        // Verify signature\n\n        bytes32 signedMessageHash = hashForSignature(_pHash, _amount, msg.sender, _nHash);\n\n        require(status[signedMessageHash] == false, \"Shifter: nonce hash already spent\");\n\n        if (!verifySignature(signedMessageHash, _sig)) {\n\n            // Return a detailed string containing the hash and recovered\n\n            // signer. This is a costly operation but is only run in the revert\n\n            // branch.\n\n            revert(\n\n            String.add4(\n\n                \"Shifter: invalid signature - hash: \",\n\n                String.fromBytes32(signedMessageHash),\n\n                \", signer: \",\n\n                String.fromAddress(ECDSA.recover(signedMessageHash, _sig))\n\n            )\n\n            );\n\n        }\n\n        status[signedMessageHash] = true;\n\n\n        // Mint `amount - fee` for the recipient and mint `fee` for the minter\n\n        uint256 absoluteFee = (_amount.mul(shiftInFee)).div(BIPS_DENOMINATOR);\n\n        uint256 receivedAmount = _amount.sub(absoluteFee);\n\n        token.mint(msg.sender, receivedAmount);\n\n        token.mint(feeRecipient, absoluteFee);\n\n\n        // Emit a log with a unique shift ID\n\n        emit LogShiftIn(msg.sender, receivedAmount, nextShiftID, signedMessageHash);\n\n        nextShiftID += 1;\n\n\n        return receivedAmount;\n\n  ","contract":"ZECShifter","time":0},{"type":"external-function ","before":"   function shiftOut(bytes memory _to, uint256 _amount) public returns (uint256) {\n\n        // The recipient must not be empty. Better validation is possible,\n\n        // but would need to be customized for each destination ledger.\n\n        require(_to.length != 0, \"Shifter: to address is empty\");\n\n        require(_amount >= minShiftAmount, \"Shifter: amount is less than the minimum shiftOut amount\");\n\n\n        // Burn full amount and mint fee\n\n        uint256 absoluteFee = (_amount.mul(shiftOutFee)).div(BIPS_DENOMINATOR);\n\n        token.burn(msg.sender, _amount);\n\n        token.mint(feeRecipient, absoluteFee);\n\n\n        // Emit a log with a unique shift ID\n\n        uint256 receivedValue = _amount.sub(absoluteFee);\n\n        emit LogShiftOut(_to, receivedValue, nextShiftID, _to);\n\n        nextShiftID += 1;\n\n\n        return receivedValue;\n\n  ","after":"   function shiftOut(bytes calldata _to, uint256 _amount) public returns (uint256) {\n\n        // The recipient must not be empty. Better validation is possible,\n\n        // but would need to be customized for each destination ledger.\n\n        require(_to.length != 0, \"Shifter: to address is empty\");\n\n        require(_amount >= minShiftAmount, \"Shifter: amount is less than the minimum shiftOut amount\");\n\n\n        // Burn full amount and mint fee\n\n        uint256 absoluteFee = (_amount.mul(shiftOutFee)).div(BIPS_DENOMINATOR);\n\n        token.burn(msg.sender, _amount);\n\n        token.mint(feeRecipient, absoluteFee);\n\n\n        // Emit a log with a unique shift ID\n\n        uint256 receivedValue = _amount.sub(absoluteFee);\n\n        emit LogShiftOut(_to, receivedValue, nextShiftID, _to);\n\n        nextShiftID += 1;\n\n\n        return receivedValue;\n\n  ","contract":"ZECShifter","time":0},{"type":"constant-restrict-modification  ","before":"   uint8 public version =","after":"   uint8 public constant version =","contract":"ZECShifter","time":0},{"type":"external-function ","before":"   function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes memory _sig) public returns (uint256) {\n\n        // Verify signature\n\n        bytes32 signedMessageHash = hashForSignature(_pHash, _amount, msg.sender, _nHash);\n\n        require(status[signedMessageHash] == false, \"Shifter: nonce hash already spent\");\n\n        if (!verifySignature(signedMessageHash, _sig)) {\n\n            // Return a detailed string containing the hash and recovered\n\n            // signer. This is a costly operation but is only run in the revert\n\n            // branch.\n\n            revert(\n\n            String.add4(\n\n                \"Shifter: invalid signature - hash: \",\n\n                String.fromBytes32(signedMessageHash),\n\n                \", signer: \",\n\n                String.fromAddress(ECDSA.recover(signedMessageHash, _sig))\n\n            )\n\n            );\n\n        }\n\n        status[signedMessageHash] = true;\n\n\n        // Mint `amount - fee` for the recipient and mint `fee` for the minter\n\n        uint256 absoluteFee = (_amount.mul(shiftInFee)).div(BIPS_DENOMINATOR);\n\n        uint256 receivedAmount = _amount.sub(absoluteFee);\n\n        token.mint(msg.sender, receivedAmount);\n\n        token.mint(feeRecipient, absoluteFee);\n\n\n        // Emit a log with a unique shift ID\n\n        emit LogShiftIn(msg.sender, receivedAmount, nextShiftID, signedMessageHash);\n\n        nextShiftID += 1;\n\n\n        return receivedAmount;\n\n  ","after":"   function shiftIn(bytes32 _pHash, uint256 _amount, bytes32 _nHash, bytes calldata _sig) public returns (uint256) {\n\n        // Verify signature\n\n        bytes32 signedMessageHash = hashForSignature(_pHash, _amount, msg.sender, _nHash);\n\n        require(status[signedMessageHash] == false, \"Shifter: nonce hash already spent\");\n\n        if (!verifySignature(signedMessageHash, _sig)) {\n\n            // Return a detailed string containing the hash and recovered\n\n            // signer. This is a costly operation but is only run in the revert\n\n            // branch.\n\n            revert(\n\n            String.add4(\n\n                \"Shifter: invalid signature - hash: \",\n\n                String.fromBytes32(signedMessageHash),\n\n                \", signer: \",\n\n                String.fromAddress(ECDSA.recover(signedMessageHash, _sig))\n\n            )\n\n            );\n\n        }\n\n        status[signedMessageHash] = true;\n\n\n        // Mint `amount - fee` for the recipient and mint `fee` for the minter\n\n        uint256 absoluteFee = (_amount.mul(shiftInFee)).div(BIPS_DENOMINATOR);\n\n        uint256 receivedAmount = _amount.sub(absoluteFee);\n\n        token.mint(msg.sender, receivedAmount);\n\n        token.mint(feeRecipient, absoluteFee);\n\n\n        // Emit a log with a unique shift ID\n\n        emit LogShiftIn(msg.sender, receivedAmount, nextShiftID, signedMessageHash);\n\n        nextShiftID += 1;\n\n\n        return receivedAmount;\n\n  ","contract":"BCHShifter","time":0},{"type":"external-function ","before":"   function shiftOut(bytes memory _to, uint256 _amount) public returns (uint256) {\n\n        // The recipient must not be empty. Better validation is possible,\n\n        // but would need to be customized for each destination ledger.\n\n        require(_to.length != 0, \"Shifter: to address is empty\");\n\n        require(_amount >= minShiftAmount, \"Shifter: amount is less than the minimum shiftOut amount\");\n\n\n        // Burn full amount and mint fee\n\n        uint256 absoluteFee = (_amount.mul(shiftOutFee)).div(BIPS_DENOMINATOR);\n\n        token.burn(msg.sender, _amount);\n\n        token.mint(feeRecipient, absoluteFee);\n\n\n        // Emit a log with a unique shift ID\n\n        uint256 receivedValue = _amount.sub(absoluteFee);\n\n        emit LogShiftOut(_to, receivedValue, nextShiftID, _to);\n\n        nextShiftID += 1;\n\n\n        return receivedValue;\n\n  ","after":"   function shiftOut(bytes calldata _to, uint256 _amount) public returns (uint256) {\n\n        // The recipient must not be empty. Better validation is possible,\n\n        // but would need to be customized for each destination ledger.\n\n        require(_to.length != 0, \"Shifter: to address is empty\");\n\n        require(_amount >= minShiftAmount, \"Shifter: amount is less than the minimum shiftOut amount\");\n\n\n        // Burn full amount and mint fee\n\n        uint256 absoluteFee = (_amount.mul(shiftOutFee)).div(BIPS_DENOMINATOR);\n\n        token.burn(msg.sender, _amount);\n\n        token.mint(feeRecipient, absoluteFee);\n\n\n        // Emit a log with a unique shift ID\n\n        uint256 receivedValue = _amount.sub(absoluteFee);\n\n        emit LogShiftOut(_to, receivedValue, nextShiftID, _to);\n\n        nextShiftID += 1;\n\n\n        return receivedValue;\n\n  ","contract":"BCHShifter","time":0},{"type":"constant-restrict-modification  ","before":"   uint8 public version =","after":"   uint8 public constant version =","contract":"BCHShifter","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"BTC_DAI_Reserve","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"BTC_DAI_Reserve","time":0},{"type":"immutable-restrict-modification ","before":"   uint8 private _decima","after":"   uint8 private _decima","contract":"BTC_DAI_Reserve","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"ZEC_DAI_Reserve","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"ZEC_DAI_Reserve","time":0},{"type":"immutable-restrict-modification ","before":"   uint8 private _decima","after":"   uint8 private _decima","contract":"ZEC_DAI_Reserve","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"BCH_DAI_Reserve","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"BCH_DAI_Reserve","time":0},{"type":"immutable-restrict-modification ","before":"   uint8 private _decima","after":"   uint8 private _decima","contract":"BCH_DAI_Reserve","time":0},{"type":"immutable-restrict-modification ","before":"   address public baseTok","after":"   address public baseTok","contract":"DEX","time":1}]}