{"time":412,"results":[{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"LPToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"LPToken","time":0},{"type":"external-function ","before":"function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee\n    ) public virtual override initializer {\n        Swap.initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            _withdrawFee\n        );\n        flashLoanFeeBPS = 100;\n        // 100bps\n        protocolFeeShareBPS = 5000;\n        // 5000bps\n    }","after":"function initialize(\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee\n    ) public virtual override initializer {\n        Swap.initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            _withdrawFee\n        );\n        flashLoanFeeBPS = 100;\n        // 100bps\n        protocolFeeShareBPS = 5000;\n        // 5000bps\n    }","contract":"SwapFlashLoan","time":0},{"type":"external-function ","before":"function flashLoan(\n        address receiver,\n        IERC20 token,\n        uint256 amount,\n        bytes memory params\n    ) external nonReentrant {\n        uint8 tokenIndex = getTokenIndex(address(token));\n        uint256 availableLiquidityBefore = token.balanceOf(address(this));\n        uint256 protocolBalanceBefore =\n        availableLiquidityBefore.sub(swapStorage.balances[tokenIndex]);\n        require(\n            amount > 0 && availableLiquidityBefore >= amount,\n            \"invalid amount\"\n        );\n\n        // Calculate the additional amount of tokens the pool should end up with\n        uint256 amountFee = amount.mul(flashLoanFeeBPS).div(10000);\n        // Calculate the portion of the fee that will go to the protocol\n        uint256 protocolFee = amountFee.mul(protocolFeeShareBPS).div(10000);\n        require(amountFee > 0, \"amount is small for a flashLoan\");\n\n        // Transfer the requested amount of tokens\n        token.safeTransfer(receiver, amount);\n\n        // Execute callback function on receiver\n        IFlashLoanReceiver(receiver).executeOperation(\n            address(this),\n            address(token),\n            amount,\n            amountFee,\n            params\n        );\n\n        uint256 availableLiquidityAfter =\n        token.balanceOf(address(this)).sub(protocolBalanceBefore);\n        require(\n            availableLiquidityAfter >= availableLiquidityBefore.add(amountFee),\n            \"flashLoan fee is not met\"\n        );\n\n        swapStorage.balances[tokenIndex] = availableLiquidityAfter.sub(\n            protocolFee\n        );\n        emit FlashLoan(receiver, tokenIndex, amount, amountFee, protocolFee);\n    }","after":"function flashLoan(\n        address receiver,\n        IERC20 token,\n        uint256 amount,\n        bytes calldata params\n    ) external nonReentrant {\n        uint8 tokenIndex = getTokenIndex(address(token));\n        uint256 availableLiquidityBefore = token.balanceOf(address(this));\n        uint256 protocolBalanceBefore =\n        availableLiquidityBefore.sub(swapStorage.balances[tokenIndex]);\n        require(\n            amount > 0 && availableLiquidityBefore >= amount,\n            \"invalid amount\"\n        );\n\n        // Calculate the additional amount of tokens the pool should end up with\n        uint256 amountFee = amount.mul(flashLoanFeeBPS).div(10000);\n        // Calculate the portion of the fee that will go to the protocol\n        uint256 protocolFee = amountFee.mul(protocolFeeShareBPS).div(10000);\n        require(amountFee > 0, \"amount is small for a flashLoan\");\n\n        // Transfer the requested amount of tokens\n        token.safeTransfer(receiver, amount);\n\n        // Execute callback function on receiver\n        IFlashLoanReceiver(receiver).executeOperation(\n            address(this),\n            address(token),\n            amount,\n            amountFee,\n            params\n        );\n\n        uint256 availableLiquidityAfter =\n        token.balanceOf(address(this)).sub(protocolBalanceBefore);\n        require(\n            availableLiquidityAfter >= availableLiquidityBefore.add(amountFee),\n            \"flashLoan fee is not met\"\n        );\n\n        swapStorage.balances[tokenIndex] = availableLiquidityAfter.sub(\n            protocolFee\n        );\n        emit FlashLoan(receiver, tokenIndex, amount, amountFee, protocolFee);\n    }","contract":"SwapFlashLoan","time":0},{"type":"external-function ","before":"function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee\n    ) public virtual initializer {\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                    _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            precisionMultipliers[i] =\n            10 **\n            uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(\n                uint256(decimals[i])\n            );\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < SwapUtils.MAX_A, \"_a exceeds maximum\");\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < SwapUtils.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n        require(\n            _withdrawFee < SwapUtils.MAX_WITHDRAW_FEE,\n            \"_withdrawFee exceeds maximum\"\n        );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = new LPToken(\n            lpTokenName,\n            lpTokenSymbol,\n            SwapUtils.POOL_PRECISION_DECIMALS\n        );\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a.mul(SwapUtils.A_PRECISION);\n        swapStorage.futureA = _a.mul(SwapUtils.A_PRECISION);\n        swapStorage.initialATime = 0;\n        swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n        swapStorage.defaultWithdrawFee = _withdrawFee;\n    }","after":"function initialize(\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee\n    ) public virtual initializer {\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                    _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            precisionMultipliers[i] =\n            10 **\n            uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(\n                uint256(decimals[i])\n            );\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < SwapUtils.MAX_A, \"_a exceeds maximum\");\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < SwapUtils.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n        require(\n            _withdrawFee < SwapUtils.MAX_WITHDRAW_FEE,\n            \"_withdrawFee exceeds maximum\"\n        );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = new LPToken(\n            lpTokenName,\n            lpTokenSymbol,\n            SwapUtils.POOL_PRECISION_DECIMALS\n        );\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a.mul(SwapUtils.A_PRECISION);\n        swapStorage.futureA = _a.mul(SwapUtils.A_PRECISION);\n        swapStorage.initialATime = 0;\n        swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n        swapStorage.defaultWithdrawFee = _withdrawFee;\n    }","contract":"SwapFlashLoan","time":0},{"type":"constant-restrict-modification  ","before":"bool private initialized = false;","after":"bool private constant initialized = false;","contract":"SwapFlashLoan","time":1},{"type":"loop-duplication","before":"\nstart line 3542 column 8, end line 3547 column 8\nfor (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            balances1[i] = balances1[i].sub(\n                amounts[i],\n                \"Cannot withdraw more than available\"\n            );\n        }\nstart line 3551 column 8, end line 3559 column 8\nfor (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\n            uint256 difference = idealBalance.difference(balances1[i]);\n            fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n            self.balances[i] = balances1[i].sub(\n                fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n            );\n            balances1[i] = balances1[i].sub(fees[i]);\n        }\nstart line 3573 column 8, end line 3575 column 8\nfor (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }","after":"// merge loop\n\nstart line 3542 column 8, end line 3547 column 8\nfor (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            balances1[i] = balances1[i].sub(\n                amounts[i],\n                \"Cannot withdraw more than available\"\n            );\n        }\nstart line 3551 column 8, end line 3559 column 8\nfor (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\n            uint256 difference = idealBalance.difference(balances1[i]);\n            fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n            self.balances[i] = balances1[i].sub(\n                fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n            );\n            balances1[i] = balances1[i].sub(fees[i]);\n        }\nstart line 3573 column 8, end line 3575 column 8\nfor (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }","contract":"SwapUtils","time":0},{"type":"external-function ","before":"function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] memory amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        require(\n            amounts.length == self.pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n        require(\n            maxBurnAmount <= self.lpToken.balanceOf(msg.sender) &&\n            maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        RemoveLiquidityImbalanceInfo memory v =\n        RemoveLiquidityImbalanceInfo(0, 0, 0, 0);\n\n        uint256 tokenSupply = self.lpToken.totalSupply();\n        uint256 feePerToken = _feePerToken(self);\n\n        uint256[] memory balances1 = self.balances;\n\n        v.preciseA = _getAPrecise(self);\n        v.d0 = getD(_xp(self), v.preciseA);\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            balances1[i] = balances1[i].sub(\n                amounts[i],\n                \"Cannot withdraw more than available\"\n            );\n        }\n        v.d1 = getD(_xp(self, balances1), v.preciseA);\n        uint256[] memory fees = new uint256[](self.pooledTokens.length);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\n            uint256 difference = idealBalance.difference(balances1[i]);\n            fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n            self.balances[i] = balances1[i].sub(\n                fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n            );\n            balances1[i] = balances1[i].sub(fees[i]);\n        }\n\n        v.d2 = getD(_xp(self, balances1), v.preciseA);\n\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(tokenSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1).mul(FEE_DENOMINATOR).div(\n            FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, msg.sender))\n        );\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        self.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            tokenSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }","after":"function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        require(\n            amounts.length == self.pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n        require(\n            maxBurnAmount <= self.lpToken.balanceOf(msg.sender) &&\n            maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        RemoveLiquidityImbalanceInfo memory v =\n        RemoveLiquidityImbalanceInfo(0, 0, 0, 0);\n\n        uint256 tokenSupply = self.lpToken.totalSupply();\n        uint256 feePerToken = _feePerToken(self);\n\n        uint256[] memory balances1 = self.balances;\n\n        v.preciseA = _getAPrecise(self);\n        v.d0 = getD(_xp(self), v.preciseA);\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            balances1[i] = balances1[i].sub(\n                amounts[i],\n                \"Cannot withdraw more than available\"\n            );\n        }\n        v.d1 = getD(_xp(self, balances1), v.preciseA);\n        uint256[] memory fees = new uint256[](self.pooledTokens.length);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\n            uint256 difference = idealBalance.difference(balances1[i]);\n            fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n            self.balances[i] = balances1[i].sub(\n                fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n            );\n            balances1[i] = balances1[i].sub(fees[i]);\n        }\n\n        v.d2 = getD(_xp(self, balances1), v.preciseA);\n\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(tokenSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1).mul(FEE_DENOMINATOR).div(\n            FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, msg.sender))\n        );\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        self.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            tokenSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }","contract":"SwapUtils","time":0}]}