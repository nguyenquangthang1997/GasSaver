{"time":1002,"results":[{"type":"external-function ","before":"function updateWeightsGradually(\n        uint256 startTime,\n        uint256 endTime,\n        uint256[] memory endWeights\n    ) external authenticate whenNotPaused nonReentrant {\n        InputHelpers.ensureInputLengthMatch(_getTotalTokens(), endWeights.length);\n\n        // If the start time is in the past, \"fast forward\" to start now\n        // This avoids discontinuities in the weight curve. Otherwise, if you set the start/end times with\n        // only 10% of the period in the future, the weights would immediately jump 90%\n        uint256 currentTime = block.timestamp;\n        startTime = Math.max(currentTime, startTime);\n\n        _require(startTime <= endTime, Errors.GRADUAL_UPDATE_TIME_TRAVEL);\n\n        _startGradualWeightChange(startTime, endTime, _getNormalizedWeights(), endWeights);\n    }","after":"function updateWeightsGradually(\n        uint256 startTime,\n        uint256 endTime,\n        uint256[] calldata endWeights\n    ) external authenticate whenNotPaused nonReentrant {\n        InputHelpers.ensureInputLengthMatch(_getTotalTokens(), endWeights.length);\n\n        // If the start time is in the past, \"fast forward\" to start now\n        // This avoids discontinuities in the weight curve. Otherwise, if you set the start/end times with\n        // only 10% of the period in the future, the weights would immediately jump 90%\n        uint256 currentTime = block.timestamp;\n        startTime = Math.max(currentTime, startTime);\n\n        _require(startTime <= endTime, Errors.GRADUAL_UPDATE_TIME_TRAVEL);\n\n        _startGradualWeightChange(startTime, endTime, _getNormalizedWeights(), endWeights);\n    }","contract":"LiquidityBootstrappingPool","time":0},{"type":"external-function ","before":"function setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig)\n    public\n    virtual\n    authenticate\n    whenNotPaused\n    {\n        _setAssetManagerPoolConfig(token, poolConfig);\n    }","after":"function setAssetManagerPoolConfig(IERC20 token, bytes calldata poolConfig)\n    public\n    virtual\n    authenticate\n    whenNotPaused\n    {\n        _setAssetManagerPoolConfig(token, poolConfig);\n    }","contract":"LiquidityBootstrappingPool","time":0},{"type":"external-function ","before":"function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        if (totalSupply() == 0) {\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(\n                poolId,\n                sender,\n                recipient,\n                scalingFactors,\n                userData\n            );\n\n            // On initialization, we lock _MINIMUM_BPT by minting it for the zero address. This BPT acts as a minimum\n            // as it will never be burned, which reduces potential issues with rounding, and also prevents the Pool from\n            // ever being fully drained.\n            _require(bptAmountOut >= _MINIMUM_BPT, Errors.MINIMUM_BPT);\n            _mintPoolTokens(address(0), _MINIMUM_BPT);\n            _mintPoolTokens(recipient, bptAmountOut - _MINIMUM_BPT);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n            return (amountsIn, new uint256[](_getTotalTokens()));\n        } else {\n            _upscaleArray(balances, scalingFactors);\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n            return (amountsIn, dueProtocolFeeAmounts);\n        }\n    }","after":"function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        if (totalSupply() == 0) {\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(\n                poolId,\n                sender,\n                recipient,\n                scalingFactors,\n                userData\n            );\n\n            // On initialization, we lock _MINIMUM_BPT by minting it for the zero address. This BPT acts as a minimum\n            // as it will never be burned, which reduces potential issues with rounding, and also prevents the Pool from\n            // ever being fully drained.\n            _require(bptAmountOut >= _MINIMUM_BPT, Errors.MINIMUM_BPT);\n            _mintPoolTokens(address(0), _MINIMUM_BPT);\n            _mintPoolTokens(recipient, bptAmountOut - _MINIMUM_BPT);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n            return (amountsIn, new uint256[](_getTotalTokens()));\n        } else {\n            _upscaleArray(balances, scalingFactors);\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n            return (amountsIn, dueProtocolFeeAmounts);\n        }\n    }","contract":"LiquidityBootstrappingPool","time":0},{"type":"external-function ","before":"function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            scalingFactors,\n            userData\n        );\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n        _downscaleDownArray(amountsOut, scalingFactors);\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n        return (amountsOut, dueProtocolFeeAmounts);\n    }","after":"function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            scalingFactors,\n            userData\n        );\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n        _downscaleDownArray(amountsOut, scalingFactors);\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n        return (amountsOut, dueProtocolFeeAmounts);\n    }","contract":"LiquidityBootstrappingPool","time":0},{"type":"external-function ","before":"function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptOut, amountsIn);\n    }","after":"function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptOut, amountsIn);\n    }","contract":"LiquidityBootstrappingPool","time":0},{"type":"external-function ","before":"function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptIn, amountsOut);\n    }","after":"function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptIn, amountsOut);\n    }","contract":"LiquidityBootstrappingPool","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"LiquidityBootstrappingPool","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"LiquidityBootstrappingPool","time":1},{"type":"constant-restrict-modification  ","before":"bytes32 private immutable _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");","after":"bytes32 private immutable constant _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");","contract":"LiquidityBootstrappingPool","time":1},{"type":"external-function ","before":"function create(\n        string memory name,\n        string memory symbol,\n        IERC20[] memory tokens,\n        uint256[] memory weights,\n        uint256 swapFeePercentage,\n        address owner,\n        bool swapEnabledOnStart\n    ) external returns (address) {\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        return\n        _create(\n            abi.encode(\n                getVault(),\n                name,\n                symbol,\n                tokens,\n                weights,\n                swapFeePercentage,\n                pauseWindowDuration,\n                bufferPeriodDuration,\n                owner,\n                swapEnabledOnStart\n            )\n        );\n    }","after":"function create(\n        string calldata name,\n        string calldata symbol,\n        IERC20[] calldata tokens,\n        uint256[] calldata weights,\n        uint256 swapFeePercentage,\n        address owner,\n        bool swapEnabledOnStart\n    ) external returns (address) {\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        return\n        _create(\n            abi.encode(\n                getVault(),\n                name,\n                symbol,\n                tokens,\n                weights,\n                swapFeePercentage,\n                pauseWindowDuration,\n                bufferPeriodDuration,\n                owner,\n                swapEnabledOnStart\n            )\n        );\n    }","contract":"LiquidityBootstrappingPoolFactory","time":0},{"type":"external-function ","before":"ghtedMath is WeightedMath {\n    function invariant(uint256[] memory normalizedWeights, uint256[] memory balances) external pure returns (uint256) {\n        return _calculateInvariant(nor","after":"ghtedMath is WeightedMath {\n    function invariant(uint256[] calldata normalizedWeights, uint256[] memory balances) external pure returns (uint256) {\n        return _calculateInvariant(nor","contract":"MockWeightedMath","time":0},{"type":"external-function ","before":"ut, tokenAmountOut);\n    }\n\n    function exactTokensInForBPTOut(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory amountsIn,\n        uint256 bptTotalSupply,\n        uint256 swapFee\n    ) external pure returns (uint256) {\n        return _calcBptOutGivenExactTokensIn(balances, normalizedWeights, amountsIn,","after":"ut, tokenAmountOut);\n    }\n\n    function exactTokensInForBPTOut(\n        uint256[] calldata balances,\n        uint256[] calldata normalizedWeights,\n        uint256[] calldata amountsIn,\n        uint256 bptTotalSupply,\n        uint256 swapFee\n    ) external pure returns (uint256) {\n        return _calcBptOutGivenExactTokensIn(balances, normalizedWeights, amountsIn,","contract":"MockWeightedMath","time":0},{"type":"external-function ","before":"talSupply, swapFee);\n    }\n\n    function exactBPTInForTokensOut(\n        uint256[] memory currentBalances,\n        uint256 bptAmountIn,\n        uint256 totalBPT\n    ) external pure returns (uint256[] memory) {\n        return _calcTokensOutGivenExactBptIn(currentBalance","after":"talSupply, swapFee);\n    }\n\n    function exactBPTInForTokensOut(\n        uint256[] calldata currentBalances,\n        uint256 bptAmountIn,\n        uint256 totalBPT\n    ) external pure returns (uint256[] memory) {\n        return _calcTokensOutGivenExactBptIn(currentBalance","contract":"MockWeightedMath","time":0},{"type":"external-function ","before":"AmountIn, totalBPT);\n    }\n\n    function bptInForExactTokensOut(\n        uint256[] memory balances,\n        uint256[] memory normalizedWeights,\n        uint256[] memory amountsOut,\n        uint256 bptTotalSupply,\n        uint256 swapFee\n    ) external pure returns (uint256) {\n        return _calcBptInGivenExactTokensOut(balances, normalizedWeights, amountsOut,","after":"AmountIn, totalBPT);\n    }\n\n    function bptInForExactTokensOut(\n        uint256[] calldata balances,\n        uint256[] calldata normalizedWeights,\n        uint256[] calldata amountsOut,\n        uint256 bptTotalSupply,\n        uint256 swapFee\n    ) external pure returns (uint256) {\n        return _calcBptInGivenExactTokensOut(balances, normalizedWeights, amountsOut,","contract":"MockWeightedMath","time":0},{"type":"external-function ","before":"tOracleIndex(index);\n    }\n\n    function mockMiscData(MiscData memory miscData) external {\n        _mi","after":"tOracleIndex(index);\n    }\n\n    function mockMiscData(MiscData memory miscData) external {\n        _mi","contract":"MockWeightedPool2Tokens","time":0},{"type":"external-function ","before":");\n    }\n\n    // Join Hook\n\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    )\n    public\n    virtual\n    override\n    onlyVault(poolId)\n    whenNotPaused\n    returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts)\n    {\n        // All joins, including initializations, are disabled while the contract is paused.\n\n        uint256 bptAmountOut;\n        if (totalSupply() == 0) {\n            (bptAmountOut, amountsIn) = _onInitializePool(poolId, sender, recipient, userData);\n\n            // On initialization, we lock _MINIMUM_BPT by minting it for the zero address. This BPT acts as a minimum\n            // as it will never be burned, which reduces potential issues with rounding, and also prevents the Pool from\n            // ever being fully drained.\n            _require(bptAmountOut >= _MINIMUM_BPT, Errors.MINIMUM_BPT);\n            _mintPoolTokens(address(0), _MINIMUM_BPT);\n            _mintPoolTokens(recipient, bptAmountOut - _MINIMUM_BPT);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn);\n\n            // There are no due protocol fee amounts during initialization\n            dueProtocolFeeAmounts = new uint256[](2);\n        } else {\n            _upscaleArray(balances);\n\n            // Update price oracle with the pre-join balances\n            _updateOracle(lastChangeBlock, balances[0], balances[1]);\n\n            (bptAmountOut, amountsIn, dueProtocolFeeAmounts) = _onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                userData\n            );\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn);\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n            _downscaleDownArray(dueProtocolFeeAmounts);\n        }\n\n        // Update cached total supply and invariant using the results after the join that will be used for future\n        // oracle updates.\n        _","after":");\n    }\n\n    // Join Hook\n\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    )\n    public\n    virtual\n    override\n    onlyVault(poolId)\n    whenNotPaused\n    returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts)\n    {\n        // All joins, including initializations, are disabled while the contract is paused.\n\n        uint256 bptAmountOut;\n        if (totalSupply() == 0) {\n            (bptAmountOut, amountsIn) = _onInitializePool(poolId, sender, recipient, userData);\n\n            // On initialization, we lock _MINIMUM_BPT by minting it for the zero address. This BPT acts as a minimum\n            // as it will never be burned, which reduces potential issues with rounding, and also prevents the Pool from\n            // ever being fully drained.\n            _require(bptAmountOut >= _MINIMUM_BPT, Errors.MINIMUM_BPT);\n            _mintPoolTokens(address(0), _MINIMUM_BPT);\n            _mintPoolTokens(recipient, bptAmountOut - _MINIMUM_BPT);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn);\n\n            // There are no due protocol fee amounts during initialization\n            dueProtocolFeeAmounts = new uint256[](2);\n        } else {\n            _upscaleArray(balances);\n\n            // Update price oracle with the pre-join balances\n            _updateOracle(lastChangeBlock, balances[0], balances[1]);\n\n            (bptAmountOut, amountsIn, dueProtocolFeeAmounts) = _onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                userData\n            );\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn);\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n            _downscaleDownArray(dueProtocolFeeAmounts);\n        }\n\n        // Update cached total supply and invariant using the results after the join that will be used for future\n        // oracle updates.\n        _","contract":"MockWeightedPool2Tokens","time":0},{"type":"external-function ","before":");\n    }\n\n    // Exit Hook\n\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        _upscaleArray(balances);\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData\n        );\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n        _downscaleDownArray(amountsOut);\n        _downscaleDownArray(dueProtocolFeeAmounts);\n\n        // Update cached total supply and invariant using the results after the exit that will be used for future\n        // oracle updates, only if the pool was not paused (to minimize code paths taken while paused).\n        if (_isNotPaused()) {\n            _cacheInvariantAndSupply();\n        }\n\n        return (amountsOu","after":");\n    }\n\n    // Exit Hook\n\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        _upscaleArray(balances);\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData\n        );\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n        _downscaleDownArray(amountsOut);\n        _downscaleDownArray(dueProtocolFeeAmounts);\n\n        // Update cached total supply and invariant using the results after the exit that will be used for future\n        // oracle updates, only if the pool was not paused (to minimize code paths taken while paused).\n        if (_isNotPaused()) {\n            _cacheInvariantAndSupply();\n        }\n\n        return (amountsOu","contract":"MockWeightedPool2Tokens","time":0},{"type":"external-function ","before":"esLog(instantValue);\n    }\n\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n    external\n    view\n    override\n    returns (uint256[] memory results)\n    {\n        results = new uint256[](queries.length);\n\n        uint256 oracleIndex = _miscData.oracleIndex();\n\n        OracleAverageQuery memory query;\n        for (uint256 i = 0; i < queries.length; ++i) {\n            query = queries[i];\n            _require(query.secs != 0, Errors.ORACLE_BAD_SECS);\n\n            int256 beginAccumulator = _getPastAccumulator(query.variable, oracleIndex, query.ago + query.secs);\n            int256 endAccumulator = _getPastAccumulator(query.variable, oracleIndex, query.ago);\n            results[i] = LogCompression.fromLowResLog((endAccumulator - beginAccumulator) / int2","after":"esLog(instantValue);\n    }\n\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n    external\n    view\n    override\n    returns (uint256[] memory results)\n    {\n        results = new uint256[](queries.length);\n\n        uint256 oracleIndex = _miscData.oracleIndex();\n\n        OracleAverageQuery memory query;\n        for (uint256 i = 0; i < queries.length; ++i) {\n            query = queries[i];\n            _require(query.secs != 0, Errors.ORACLE_BAD_SECS);\n\n            int256 beginAccumulator = _getPastAccumulator(query.variable, oracleIndex, query.ago + query.secs);\n            int256 endAccumulator = _getPastAccumulator(query.variable, oracleIndex, query.ago);\n            results[i] = LogCompression.fromLowResLog((endAccumulator - beginAccumulator) / int2","contract":"MockWeightedPool2Tokens","time":0},{"type":"external-function ","before":"ry.secs));\n        }\n    }\n\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\n    external\n    view\n    override\n    returns (int256[] memory results)\n    {\n        results = new int256[](queries.length);\n\n        uint256 oracleIndex = _miscData.oracleIndex();\n\n        OracleAccumulatorQuery memory query;\n        for (uint256 i = 0; i < queries.length; ++i) {\n            query = queries[i];\n            results[i] = _getPastAccumulator(query.variable, oracleIn","after":"ry.secs));\n        }\n    }\n\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\n    external\n    view\n    override\n    returns (int256[] memory results)\n    {\n        results = new int256[](queries.length);\n\n        uint256 oracleIndex = _miscData.oracleIndex();\n\n        OracleAccumulatorQuery memory query;\n        for (uint256 i = 0; i < queries.length; ++i) {\n            query = queries[i];\n            results[i] = _getPastAccumulator(query.variable, oracleIn","contract":"MockWeightedPool2Tokens","time":0},{"type":"external-function ","before":"th_sendTransaction.\n     */\n    function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, 2);\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        r","after":"th_sendTransaction.\n     */\n    function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, 2);\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        r","contract":"MockWeightedPool2Tokens","time":0},{"type":"external-function ","before":"th_sendTransaction.\n     */\n    function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, 2);\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        r","after":"th_sendTransaction.\n     */\n    function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, 2);\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        r","contract":"MockWeightedPool2Tokens","time":0},{"type":"external-function ","before":"x] = encode(sample);\n    }\n\n    function mockSamples(uint256[] memory indexes, Sample[] memory samples) public {\n        for (uint256 i = 0; i < indexes.length; i++) {\n            mockSample(indexes[","after":"x] = encode(sample);\n    }\n\n    function mockSamples(uint256[] calldata indexes, Sample[] memory samples) public {\n        for (uint256 i = 0; i < indexes.length; i++) {\n            mockSample(indexes[","contract":"MockWeightedPool2Tokens","time":0},{"type":"external-function ","before":"Index, sampleIndex);\n    }\n\n    function findNearestSamplesTimestamp(uint256[] memory dates, uint256 offset)\n    external\n    view\n    returns (BinarySearchResult[] memory results)\n    {\n        results = new BinarySearchResult[](dates.length);\n        for (uint256 i = 0; i < dates.length; i++) {\n            (bytes32 prev, bytes32 next) = _findNearestSample(dates[i], offset);\n            results[i] = BinarySearchResult({prev : prev.timestamp(), next : nex","after":"Index, sampleIndex);\n    }\n\n    function findNearestSamplesTimestamp(uint256[] memory dates, uint256 offset)\n    external\n    view\n    returns (BinarySearchResult[] memory results)\n    {\n        results = new BinarySearchResult[](dates.length);\n        for (uint256 i = 0; i < dates.length; i++) {\n            (bytes32 prev, bytes32 next) = _findNearestSample(dates[i], offset);\n            results[i] = BinarySearchResult({prev : prev.timestamp(), next : nex","contract":"MockWeightedPool2Tokens","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"MockWeightedPool2Tokens","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"MockWeightedPool2Tokens","time":1},{"type":"constant-restrict-modification  ","before":"bytes32 private immutable _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");","after":"bytes32 private immutable constant _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");","contract":"MockWeightedPool2Tokens","time":1},{"type":"external-function ","before":"function setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig)\n    public\n    virtual\n    authenticate\n    whenNotPaused\n    {\n        _setAssetManagerPoolConfig(token, poolConfig);\n    }","after":"function setAssetManagerPoolConfig(IERC20 token, bytes calldata poolConfig)\n    public\n    virtual\n    authenticate\n    whenNotPaused\n    {\n        _setAssetManagerPoolConfig(token, poolConfig);\n    }","contract":"WeightedPool","time":0},{"type":"external-function ","before":"function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        if (totalSupply() == 0) {\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(\n                poolId,\n                sender,\n                recipient,\n                scalingFactors,\n                userData\n            );\n\n            // On initialization, we lock _MINIMUM_BPT by minting it for the zero address. This BPT acts as a minimum\n            // as it will never be burned, which reduces potential issues with rounding, and also prevents the Pool from\n            // ever being fully drained.\n            _require(bptAmountOut >= _MINIMUM_BPT, Errors.MINIMUM_BPT);\n            _mintPoolTokens(address(0), _MINIMUM_BPT);\n            _mintPoolTokens(recipient, bptAmountOut - _MINIMUM_BPT);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n            return (amountsIn, new uint256[](_getTotalTokens()));\n        } else {\n            _upscaleArray(balances, scalingFactors);\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n            return (amountsIn, dueProtocolFeeAmounts);\n        }\n    }","after":"function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        if (totalSupply() == 0) {\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(\n                poolId,\n                sender,\n                recipient,\n                scalingFactors,\n                userData\n            );\n\n            // On initialization, we lock _MINIMUM_BPT by minting it for the zero address. This BPT acts as a minimum\n            // as it will never be burned, which reduces potential issues with rounding, and also prevents the Pool from\n            // ever being fully drained.\n            _require(bptAmountOut >= _MINIMUM_BPT, Errors.MINIMUM_BPT);\n            _mintPoolTokens(address(0), _MINIMUM_BPT);\n            _mintPoolTokens(recipient, bptAmountOut - _MINIMUM_BPT);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n            return (amountsIn, new uint256[](_getTotalTokens()));\n        } else {\n            _upscaleArray(balances, scalingFactors);\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n            return (amountsIn, dueProtocolFeeAmounts);\n        }\n    }","contract":"WeightedPool","time":0},{"type":"external-function ","before":"function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            scalingFactors,\n            userData\n        );\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n        _downscaleDownArray(amountsOut, scalingFactors);\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n        return (amountsOut, dueProtocolFeeAmounts);\n    }","after":"function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            scalingFactors,\n            userData\n        );\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n        _downscaleDownArray(amountsOut, scalingFactors);\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n        return (amountsOut, dueProtocolFeeAmounts);\n    }","contract":"WeightedPool","time":0},{"type":"external-function ","before":"function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptOut, amountsIn);\n    }","after":"function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptOut, amountsIn);\n    }","contract":"WeightedPool","time":0},{"type":"external-function ","before":"function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptIn, amountsOut);\n    }","after":"function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptIn, amountsOut);\n    }","contract":"WeightedPool","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"WeightedPool","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"WeightedPool","time":1},{"type":"constant-restrict-modification  ","before":"bytes32 private immutable _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");","after":"bytes32 private immutable constant _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");","contract":"WeightedPool","time":1},{"type":"external-function ","before":"new `WeightedPool`.\n     */\n    function create(\n        string memory name,\n        string memory symbol,\n        IERC20[] memory tokens,\n        uint256[] memory weights,\n        address[] memory assetManagers,\n        uint256 swapFeePercentage,\n        address owner\n    ) external returns (address) {\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        return\n        _create(\n            abi.encode(\n                getVault(),\n                name,\n                symbol,\n                tokens,\n                weights,\n                assetManagers,\n                swapFeePercentage,\n                pauseWindowDuration,\n                bufferPeriodDuration,\n                owne","after":"new `WeightedPool`.\n     */\n    function create(\n        string calldata name,\n        string calldata symbol,\n        IERC20[] calldata tokens,\n        uint256[] calldata weights,\n        address[] calldata assetManagers,\n        uint256 swapFeePercentage,\n        address owner\n    ) external returns (address) {\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        return\n        _create(\n            abi.encode(\n                getVault(),\n                name,\n                symbol,\n                tokens,\n                weights,\n                assetManagers,\n                swapFeePercentage,\n                pauseWindowDuration,\n                bufferPeriodDuration,\n                owne","contract":"WeightedPoolFactory","time":0},{"type":"external-function ","before":"out asset managers.\n     */\n    function create(\n        string memory name,\n        string memory symbol,\n        IERC20[] memory tokens,\n        uint256[] memory weights,\n        uint256 swapFeePercentage,\n        address owner\n    ) external returns (address) {\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        return\n        _create(\n            abi.encode(\n                getVault(),\n                name,\n                symbol,\n                tokens,\n                weights,\n                new address[](tokens.length), // Don't allow asset managers\n                swapFeePercentage,\n                pauseWindowDuration,\n                bufferPeriodDuration,\n                owne","after":"out asset managers.\n     */\n    function create(\n        string calldata name,\n        string calldata symbol,\n        IERC20[] calldata tokens,\n        uint256[] calldata weights,\n        uint256 swapFeePercentage,\n        address owner\n    ) external returns (address) {\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        return\n        _create(\n            abi.encode(\n                getVault(),\n                name,\n                symbol,\n                tokens,\n                weights,\n                new address[](tokens.length), // Don't allow asset managers\n                swapFeePercentage,\n                pauseWindowDuration,\n                bufferPeriodDuration,\n                owne","contract":"WeightedPoolNoAMFactory","time":0}]}