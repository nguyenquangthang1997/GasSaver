{"time":180,"results":[{"type":"state-data-arrangement ","before":"\n bytes4 private constant _ERC721_RECEIVED = 0x150b7a02\n mapping(uint256 => address) private _tokenOwner\n mapping(uint256 => address) private _tokenApprovals\n mapping(address => uint256) private _ownedTokensCount\n mapping(address => mapping(address => bool)) private _operatorApprovals\n bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd","after":" mapping(uint256 => address) private _tokenOwner\n mapping(uint256 => address) private _tokenApprovals\n mapping(address => uint256) private _ownedTokensCount\n mapping(address => mapping(address => bool)) private _operatorApprovals\n bytes4 private constant _ERC721_RECEIVED = 0x150b7a02\n bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd\n","contract":"ERC721","time":0},{"type":"struct-data-arrangement ","before":"\n uint256 loanI\n uint256 loanPrincipalAmoun\n uint256 maximumRepaymentAmoun\n uint256 nftCollateralI\n uint64 loanStartTim\n uint32 loanDuratio\n uint32 loanInterestRateForDurationInBasisPoint\n uint32 loanAdminFeeInBasisPoint\n address nftCollateralContrac\n address loanERC20Denominatio\n address borrowe\n bool interestIsProRate","after":" uint256 loanI\n uint256 loanPrincipalAmoun\n uint256 maximumRepaymentAmoun\n uint256 nftCollateralI\n address nftCollateralContrac\n address loanERC20Denominatio\n address borrowe\n uint64 loanStartTim\n uint32 loanDuratio\n uint32 loanInterestRateForDurationInBasisPoint\n uint32 loanAdminFeeInBasisPoint\n bool interestIsProRate\n","contract":"NFTfi","time":8},{"type":"external-function ","before":" function beginLoan(\n\n        uint256 _loanPrincipalAmount,\n\n        uint256 _maximumRepaymentAmount,\n\n        uint256 _nftCollateralId,\n\n        uint256 _loanDuration,\n\n        uint256 _loanInterestRateForDurationInBasisPoints,\n\n        uint256 _adminFeeInBasisPoints,\n\n        uint256[2] memory _borrowerAndLenderNonces,\n\n        address _nftCollateralContract,\n\n        address _loanERC20Denomination,\n\n        address _lender,\n\n        bytes memory _borrowerSignature,\n\n        bytes memory _lenderSignature\n\n    ) public whenNotPaused nonReentrant {\n\n\n        // Save loan details to a struct in memory first, to save on gas if any\n\n        // of the below checks fail, and to avoid the \"Stack Too Deep\" error by\n\n        // clumping the parameters together into one struct held in memory.\n\n        Loan memory loan = Loan({\n\n        loanId : totalNumLoans, //currentLoanId,\n\n        loanPrincipalAmount : _loanPrincipalAmount,\n\n        maximumRepaymentAmount : _maximumRepaymentAmount,\n\n        nftCollateralId : _nftCollateralId,\n\n        loanStartTime : uint64(now), //_loanStartTime\n\n        loanDuration : uint32(_loanDuration),\n\n        loanInterestRateForDurationInBasisPoints : uint32(_loanInterestRateForDurationInBasisPoints),\n\n        loanAdminFeeInBasisPoints : uint32(_adminFeeInBasisPoints),\n\n        nftCollateralContract : _nftCollateralContract,\n\n        loanERC20Denomination : _loanERC20Denomination,\n\n        borrower : msg.sender, //borrower\n\n        interestIsProRated : (_loanInterestRateForDurationInBasisPoints != ~(uint32(0)))\n\n        });\n\n\n        // Sanity check loan values.\n\n        require(loan.maximumRepaymentAmount >= loan.loanPrincipalAmount, 'Negative interest rate loans are not allowed.');\n\n        require(uint256(loan.loanDuration) <= maximumLoanDuration, 'Loan duration exceeds maximum loan duration');\n\n        require(uint256(loan.loanDuration) != 0, 'Loan duration cannot be zero');\n\n        require(uint256(loan.loanAdminFeeInBasisPoints) == adminFeeInBasisPoints, 'The admin fee has changed since this order was signed.');\n\n\n        // Check that both the collateral and the principal come from supported\n\n        // contracts.\n\n        require(erc20CurrencyIsWhitelisted[loan.loanERC20Denomination], 'Currency denomination is not whitelisted to be used by this contract');\n\n        require(nftContractIsWhitelisted[loan.nftCollateralContract], 'NFT collateral contract is not whitelisted to be used by this contract');\n\n\n        // Check loan nonces. These are different from Ethereum account nonces.\n\n        // Here, these are uint256 numbers that should uniquely identify\n\n        // each signature for each user (i.e. each user should only create one\n\n        // off-chain signature for each nonce, with a nonce being any arbitrary\n\n        // uint256 value that they have not used yet for an off-chain NFTfi\n\n        // signature).\n\n        require(!_nonceHasBeenUsedForUser[msg.sender][_borrowerAndLenderNonces[0]], 'Borrower nonce invalid, borrower has either cancelled/begun this loan, or reused this nonce when signing');\n\n        _nonceHasBeenUsedForUser[msg.sender][_borrowerAndLenderNonces[0]] = true;\n\n        require(!_nonceHasBeenUsedForUser[_lender][_borrowerAndLenderNonces[1]], 'Lender nonce invalid, lender has either cancelled/begun this loan, or reused this nonce when signing');\n\n        _nonceHasBeenUsedForUser[_lender][_borrowerAndLenderNonces[1]] = true;\n\n\n        // Check that both signatures are valid.\n\n        require(isValidBorrowerSignature(\n\n                loan.nftCollateralId,\n\n                _borrowerAndLenderNonces[0], //_borrowerNonce,\n\n                loan.nftCollateralContract,\n\n                msg.sender, //borrower,\n\n                _borrowerSignature\n\n            ), 'Borrower signature is invalid');\n\n        require(isValidLenderSignature(\n\n                loan.loanPrincipalAmount,\n\n                loan.maximumRepaymentAmount,\n\n                loan.nftCollateralId,\n\n                loan.loanDuration,\n\n                loan.loanInterestRateForDurationInBasisPoints,\n\n                loan.loanAdminFeeInBasisPoints,\n\n                _borrowerAndLenderNonces[1], //_lenderNonce,\n\n                loan.nftCollateralContract,\n\n                loan.loanERC20Denomination,\n\n                _lender,\n\n                loan.interestIsProRated,\n\n                _lenderSignature\n\n            ), 'Lender signature is invalid');\n\n\n        // Add the loan to storage before moving collateral/principal to follow\n\n        // the Checks-Effects-Interactions pattern.\n\n        loanIdToLoan[totalNumLoans] = loan;\n\n        totalNumLoans = totalNumLoans.add(1);\n\n\n        // Update number of active loans.\n\n        totalActiveLoans = totalActiveLoans.add(1);\n\n        require(totalActiveLoans <= maximumNumberOfActiveLoans, 'Contract has reached the maximum number of active loans allowed by admins');\n\n\n        // Transfer collateral from borrower to this contract to be held until\n\n        // loan completion.\n\n        IERC721(loan.nftCollateralContract).transferFrom(msg.sender, address(this), loan.nftCollateralId);\n\n\n        // Transfer principal from lender to borrower.\n\n        IERC20(loan.loanERC20Denomination).transferFrom(_lender, msg.sender, loan.loanPrincipalAmount);\n\n\n        // Issue an ERC721 promissory note to the lender that gives them the\n\n        // right to either the principal-plus-interest or the collateral.\n\n        _mint(_lender, loan.loanId);\n\n\n        // Emit an event with all relevant details from this transaction.\n\n        emit LoanStarted(\n\n            loan.loanId,\n\n            msg.sender, //borrower,\n\n            _lender,\n\n            loan.loanPrincipalAmount,\n\n            loan.maximumRepaymentAmount,\n\n            loan.nftCollateralId,\n\n            now, //_loanStartTime\n\n            loan.loanDuration,\n\n            loan.loanInterestRateForDurationInBasisPoints,\n\n            loan.nftCollateralContract,\n\n            loan.loanERC20Denomination,\n\n            loan.interestIsProRated\n\n        );\n\n    ","after":" function beginLoan(\n\n        uint256 _loanPrincipalAmount,\n\n        uint256 _maximumRepaymentAmount,\n\n        uint256 _nftCollateralId,\n\n        uint256 _loanDuration,\n\n        uint256 _loanInterestRateForDurationInBasisPoints,\n\n        uint256 _adminFeeInBasisPoints,\n\n        uint256[2] calldata _borrowerAndLenderNonces,\n\n        address _nftCollateralContract,\n\n        address _loanERC20Denomination,\n\n        address _lender,\n\n        bytes calldata _borrowerSignature,\n\n        bytes calldata _lenderSignature\n\n    ) public whenNotPaused nonReentrant {\n\n\n        // Save loan details to a struct in memory first, to save on gas if any\n\n        // of the below checks fail, and to avoid the \"Stack Too Deep\" error by\n\n        // clumping the parameters together into one struct held in memory.\n\n        Loan memory loan = Loan({\n\n        loanId : totalNumLoans, //currentLoanId,\n\n        loanPrincipalAmount : _loanPrincipalAmount,\n\n        maximumRepaymentAmount : _maximumRepaymentAmount,\n\n        nftCollateralId : _nftCollateralId,\n\n        loanStartTime : uint64(now), //_loanStartTime\n\n        loanDuration : uint32(_loanDuration),\n\n        loanInterestRateForDurationInBasisPoints : uint32(_loanInterestRateForDurationInBasisPoints),\n\n        loanAdminFeeInBasisPoints : uint32(_adminFeeInBasisPoints),\n\n        nftCollateralContract : _nftCollateralContract,\n\n        loanERC20Denomination : _loanERC20Denomination,\n\n        borrower : msg.sender, //borrower\n\n        interestIsProRated : (_loanInterestRateForDurationInBasisPoints != ~(uint32(0)))\n\n        });\n\n\n        // Sanity check loan values.\n\n        require(loan.maximumRepaymentAmount >= loan.loanPrincipalAmount, 'Negative interest rate loans are not allowed.');\n\n        require(uint256(loan.loanDuration) <= maximumLoanDuration, 'Loan duration exceeds maximum loan duration');\n\n        require(uint256(loan.loanDuration) != 0, 'Loan duration cannot be zero');\n\n        require(uint256(loan.loanAdminFeeInBasisPoints) == adminFeeInBasisPoints, 'The admin fee has changed since this order was signed.');\n\n\n        // Check that both the collateral and the principal come from supported\n\n        // contracts.\n\n        require(erc20CurrencyIsWhitelisted[loan.loanERC20Denomination], 'Currency denomination is not whitelisted to be used by this contract');\n\n        require(nftContractIsWhitelisted[loan.nftCollateralContract], 'NFT collateral contract is not whitelisted to be used by this contract');\n\n\n        // Check loan nonces. These are different from Ethereum account nonces.\n\n        // Here, these are uint256 numbers that should uniquely identify\n\n        // each signature for each user (i.e. each user should only create one\n\n        // off-chain signature for each nonce, with a nonce being any arbitrary\n\n        // uint256 value that they have not used yet for an off-chain NFTfi\n\n        // signature).\n\n        require(!_nonceHasBeenUsedForUser[msg.sender][_borrowerAndLenderNonces[0]], 'Borrower nonce invalid, borrower has either cancelled/begun this loan, or reused this nonce when signing');\n\n        _nonceHasBeenUsedForUser[msg.sender][_borrowerAndLenderNonces[0]] = true;\n\n        require(!_nonceHasBeenUsedForUser[_lender][_borrowerAndLenderNonces[1]], 'Lender nonce invalid, lender has either cancelled/begun this loan, or reused this nonce when signing');\n\n        _nonceHasBeenUsedForUser[_lender][_borrowerAndLenderNonces[1]] = true;\n\n\n        // Check that both signatures are valid.\n\n        require(isValidBorrowerSignature(\n\n                loan.nftCollateralId,\n\n                _borrowerAndLenderNonces[0], //_borrowerNonce,\n\n                loan.nftCollateralContract,\n\n                msg.sender, //borrower,\n\n                _borrowerSignature\n\n            ), 'Borrower signature is invalid');\n\n        require(isValidLenderSignature(\n\n                loan.loanPrincipalAmount,\n\n                loan.maximumRepaymentAmount,\n\n                loan.nftCollateralId,\n\n                loan.loanDuration,\n\n                loan.loanInterestRateForDurationInBasisPoints,\n\n                loan.loanAdminFeeInBasisPoints,\n\n                _borrowerAndLenderNonces[1], //_lenderNonce,\n\n                loan.nftCollateralContract,\n\n                loan.loanERC20Denomination,\n\n                _lender,\n\n                loan.interestIsProRated,\n\n                _lenderSignature\n\n            ), 'Lender signature is invalid');\n\n\n        // Add the loan to storage before moving collateral/principal to follow\n\n        // the Checks-Effects-Interactions pattern.\n\n        loanIdToLoan[totalNumLoans] = loan;\n\n        totalNumLoans = totalNumLoans.add(1);\n\n\n        // Update number of active loans.\n\n        totalActiveLoans = totalActiveLoans.add(1);\n\n        require(totalActiveLoans <= maximumNumberOfActiveLoans, 'Contract has reached the maximum number of active loans allowed by admins');\n\n\n        // Transfer collateral from borrower to this contract to be held until\n\n        // loan completion.\n\n        IERC721(loan.nftCollateralContract).transferFrom(msg.sender, address(this), loan.nftCollateralId);\n\n\n        // Transfer principal from lender to borrower.\n\n        IERC20(loan.loanERC20Denomination).transferFrom(_lender, msg.sender, loan.loanPrincipalAmount);\n\n\n        // Issue an ERC721 promissory note to the lender that gives them the\n\n        // right to either the principal-plus-interest or the collateral.\n\n        _mint(_lender, loan.loanId);\n\n\n        // Emit an event with all relevant details from this transaction.\n\n        emit LoanStarted(\n\n            loan.loanId,\n\n            msg.sender, //borrower,\n\n            _lender,\n\n            loan.loanPrincipalAmount,\n\n            loan.maximumRepaymentAmount,\n\n            loan.nftCollateralId,\n\n            now, //_loanStartTime\n\n            loan.loanDuration,\n\n            loan.loanInterestRateForDurationInBasisPoints,\n\n            loan.nftCollateralContract,\n\n            loan.loanERC20Denomination,\n\n            loan.interestIsProRated\n\n        );\n\n    ","contract":"NFTfi","time":0}]}