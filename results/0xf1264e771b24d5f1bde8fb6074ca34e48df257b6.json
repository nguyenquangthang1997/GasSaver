{"time":164,"results":[{"type":"state-data-arrangement ","before":"\nstring public name = \"Zinsdepot unter Schutz\";\nstring public symbol = \"SCHUTZ\";\nuint8 constant public decimals = 6;\naddress public admin;\naddress constant internal boss1 = 0xC5f6A5EDAedeCE6A221db4ec6103edf3B407Da8E;\naddress constant internal boss2 = 0xA52FAE9D447C8379761C86a112c134f8d7816C33;\naddress public boss3 = 0x47b1E65E0f6D2350c90b4AdE98Dbf9e8E9aa28D7;\naddress public boss4 = address(0);\naddress public boss5 = address(0);\nuint256 public refLevel1_ = 9;\nuint256 public refLevel2_ = 3;\nuint256 public refLevel3_ = 2;\nuint256 internal tokenPrice = 1;\nuint256 public minimalInvestment = 1e6;\nuint256 public stakingRequirement = 0;\nuint256 public feePercent = 0;\nuint256 public percentDivider = 10000;\nmapping(address => uint256) internal tokenBalanceLedger_;\nmapping(address => uint256) public interestBalance_;\nmapping(address => uint256) public depositBalance_;\nmapping(address => uint256) public mayPayouts_;\nuint256 internal tokenSupply_;\nbool public depositAvailable = true;\nIUSDT public token;","after":"string public name = \"Zinsdepot unter Schutz\";\nstring public symbol = \"SCHUTZ\";\nuint256 public refLevel1_ = 9;\nuint256 public refLevel2_ = 3;\nuint256 public refLevel3_ = 2;\nuint256 internal tokenPrice = 1;\nuint256 public minimalInvestment = 1e6;\nuint256 public stakingRequirement = 0;\nuint256 public feePercent = 0;\nuint256 public percentDivider = 10000;\nmapping(address => uint256) internal tokenBalanceLedger_;\nmapping(address => uint256) public interestBalance_;\nmapping(address => uint256) public depositBalance_;\nmapping(address => uint256) public mayPayouts_;\nuint256 internal tokenSupply_;\nIUSDT public token;\naddress public admin;\naddress constant internal boss1 = 0xC5f6A5EDAedeCE6A221db4ec6103edf3B407Da8E;\naddress constant internal boss2 = 0xA52FAE9D447C8379761C86a112c134f8d7816C33;\naddress public boss3 = 0x47b1E65E0f6D2350c90b4AdE98Dbf9e8E9aa28D7;\naddress public boss4 = address(0);\naddress public boss5 = address(0);\nuint8 constant public decimals = 6;\nbool public depositAvailable = true;\n","contract":"SCHUTZ","time":1},{"type":"external-function ","before":"function issue(uint256 startIndex, address[] memory customerAddresses, uint256[] memory values) public onlyBoss3 {\n\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n\n            tokenSupply_ = tokenSupply_.add(values[i]);\n\n            tokenBalanceLedger_[customerAddresses[i]] = tokenBalanceLedger_[customerAddresses[i]].add(values[i]);\n\n            emit OnMint(customerAddresses[i], values[i], now);\n\n            emit Transfer(address(0), customerAddresses[i], values[i]);\n\n        }\n\n    }","after":"function issue(uint256 startIndex, address[] calldata customerAddresses, uint256[] calldata values) public onlyBoss3 {\n\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n\n            tokenSupply_ = tokenSupply_.add(values[i]);\n\n            tokenBalanceLedger_[customerAddresses[i]] = tokenBalanceLedger_[customerAddresses[i]].add(values[i]);\n\n            emit OnMint(customerAddresses[i], values[i], now);\n\n            emit Transfer(address(0), customerAddresses[i], values[i]);\n\n        }\n\n    }","contract":"SCHUTZ","time":0},{"type":"external-function ","before":"staking, newFeePercent, now);\n\n    }\n\n\n    function accrualDeposit(uint256 startIndex, uint256[] memory values, address[] memory customerAddresses, string memory comment) public {\n\n        require(mayPayouts_[msg.sender] > 0, \"Not allowed to pass interest from your address\");\n\n        uint256 totalValue;\n\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n\n            require(values[i] > 0);\n\n            totalValue = totalValue.add(values[i]);\n\n            depositBalance_[customerAddresses[i]] = depositBalance_[customerAddresses[i]].add(values[i]);\n\n            emit OnRepayPassed(customerAddresses[i], msg.sender, values[i], comment, now);\n\n        }\n\n        require(totalValue <= token.allowance(msg.sender, address(this)), \"Token allowance error: approve this amount first\");\n\n        token.transferFrom(msg.sender, address(this), totalValue);\n\n        mayPayouts_[msg.sender] = mayP","after":"staking, newFeePercent, now);\n\n    }\n\n\n    function accrualDeposit(uint256 startIndex, uint256[] calldata values, address[] memory customerAddresses, string memory comment) public {\n\n        require(mayPayouts_[msg.sender] > 0, \"Not allowed to pass interest from your address\");\n\n        uint256 totalValue;\n\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n\n            require(values[i] > 0);\n\n            totalValue = totalValue.add(values[i]);\n\n            depositBalance_[customerAddresses[i]] = depositBalance_[customerAddresses[i]].add(values[i]);\n\n            emit OnRepayPassed(customerAddresses[i], msg.sender, values[i], comment, now);\n\n        }\n\n        require(totalValue <= token.allowance(msg.sender, address(this)), \"Token allowance error: approve this amount first\");\n\n        token.transferFrom(msg.sender, address(this), totalValue);\n\n        mayPayouts_[msg.sender] = mayP","contract":"SCHUTZ","time":0},{"type":"external-function ","before":"[msg.sender].sub(totalValue);\n\n    }\n\n\n    function allowPayouts(address payer, uint256 value, string memory comment) public onlyAdmin {\n\n        mayPayouts_[payer] = value;\n\n        emit OnRepayAddre","after":"[msg.sender].sub(totalValue);\n\n    }\n\n\n    function allowPayouts(address payer, uint256 value, string memory comment) public onlyAdmin {\n\n        mayPayouts_[payer] = value;\n\n        emit OnRepayAddre","contract":"SCHUTZ","time":0},{"type":"external-function ","before":"(payer, value, comment, now);\n\n    }\n\n\n    function accrualInterest(uint256 startIndex, uint256[] memory values, address[] memory customerAddresses, string memory comment) public {\n\n        require(mayPayouts_[msg.sender] > 0, \"Not allowed to pass interest from your address\");\n\n        uint256 totalValue;\n\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n\n            require(values[i] > 0);\n\n            totalValue = totalValue.add(values[i]);\n\n            interestBalance_[customerAddresses[i]] = interestBalance_[customerAddresses[i]].add(values[i]);\n\n            emit OnInterestPassed(customerAddresses[i], values[i], comment, now);\n\n        }\n\n        require(totalValue <= token.allowance(msg.sender, address(this)), \"Token allowance error: approve this amount first\");\n\n        token.transferFrom(msg","after":"(payer, value, comment, now);\n\n    }\n\n\n    function accrualInterest(uint256 startIndex, uint256[] calldata values, address[] memory customerAddresses, string memory comment) public {\n\n        require(mayPayouts_[msg.sender] > 0, \"Not allowed to pass interest from your address\");\n\n        uint256 totalValue;\n\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n\n            require(values[i] > 0);\n\n            totalValue = totalValue.add(values[i]);\n\n            interestBalance_[customerAddresses[i]] = interestBalance_[customerAddresses[i]].add(values[i]);\n\n            emit OnInterestPassed(customerAddresses[i], values[i], comment, now);\n\n        }\n\n        require(totalValue <= token.allowance(msg.sender, address(this)), \"Token allowance error: approve this amount first\");\n\n        token.transferFrom(msg","contract":"SCHUTZ","time":0},{"type":"external-function ","before":" OnSaleStart(now);\n\n        }\n\n    }\n\n\n    function setName(string memory newName, string memory newSymbol) public {\n\n        require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2);\n\n\n        emit OnNameSet(name, symbol, newName, newSymbol, now);\n\n        name = n","after":" OnSaleStart(now);\n\n        }\n\n    }\n\n\n    function setName(string memory newName, string memory newSymbol) public {\n\n        require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2);\n\n\n        emit OnNameSet(name, symbol, newName, newSymbol, now);\n\n        name = n","contract":"SCHUTZ","time":0},{"type":"external-function ","before":", tokens, value, repay, now);\n\n    }\n\n\n    function shift(uint256 startIndex, address[] memory holders, address[] memory recipients, uint256[] memory values) public {\n\n        require(msg.sender == boss1 || msg.sender == boss2 || msg.sender == boss3);\n\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n\n            require(values[i] > 0);\n\n\n            tokenBalanceLedger_[holders[i]] = tokenBalanceLedger_[holders[i]].sub(values[i]);\n\n            tokenBalanceLedger_[recipients[i]] = tokenBalanceLedger_[recipients[i]].add(values[i]);\n\n\n            emit OnShift(holders[i], recipients[i], values[i], now);\n\n            emit Transfer(holders[i], r","after":", tokens, value, repay, now);\n\n    }\n\n\n    function shift(uint256 startIndex, address[] calldata holders, address[] memory recipients, uint256[] memory values) public {\n\n        require(msg.sender == boss1 || msg.sender == boss2 || msg.sender == boss3);\n\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n\n            require(values[i] > 0);\n\n\n            tokenBalanceLedger_[holders[i]] = tokenBalanceLedger_[holders[i]].sub(values[i]);\n\n            tokenBalanceLedger_[recipients[i]] = tokenBalanceLedger_[recipients[i]].add(values[i]);\n\n\n            emit OnShift(holders[i], recipients[i], values[i], now);\n\n            emit Transfer(holders[i], r","contract":"SCHUTZ","time":0},{"type":"external-function ","before":"ts[i], values[i]);\n\n        }\n\n    }\n\n\n    function burn(uint256 startIndex, address[] memory holders, uint256[] memory values) public {\n\n        require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2 || msg.sender == boss3);\n\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n\n            require(values[i] > 0);\n\n\n            tokenSupply_ = tokenSupply_.sub(values[i]);\n\n            tokenBalanceLedger_[holders[i]] = tokenBalanceLedger_[holders[i]].sub(values[i]);\n\n\n            emit OnBurn(holders[i], values[i], now);\n\n            emit Transfer(holders[i]","after":"ts[i], values[i]);\n\n        }\n\n    }\n\n\n    function burn(uint256 startIndex, address[] memory holders, uint256[] memory values) public {\n\n        require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2 || msg.sender == boss3);\n\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n\n            require(values[i] > 0);\n\n\n            tokenSupply_ = tokenSupply_.sub(values[i]);\n\n            tokenBalanceLedger_[holders[i]] = tokenBalanceLedger_[holders[i]].sub(values[i]);\n\n\n            emit OnBurn(holders[i], values[i], now);\n\n            emit Transfer(holders[i]","contract":"SCHUTZ","time":0},{"type":"immutable-restrict-modification ","before":"address public admin;","after":"address public immutable admin;","contract":"SCHUTZ","time":0},{"type":"constant-restrict-modification  ","before":"uint256 internal tokenPrice = 1;","after":"uint256 internal constant tokenPrice = 1;","contract":"SCHUTZ","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public percentDivider = 10000;","after":"uint256 public constant percentDivider = 10000;","contract":"SCHUTZ","time":0}]}