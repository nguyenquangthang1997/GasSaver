{"time":223,"results":[{"type":"immutable-restrict-modification ","before":" string public name","after":" string public immutable name","contract":"PositionToken","time":0},{"type":"immutable-restrict-modification ","before":" string public symbol","after":" string public immutable symbol","contract":"PositionToken","time":0},{"type":"immutable-restrict-modification ","before":" uint8 public decimals","after":" uint8 public immutable decimals","contract":"PositionToken","time":0},{"type":"state-data-arrangement ","before":"\n string public CONTRACT_NAME\n address public COLLATERAL_TOKEN_ADDRESS\n address public COLLATERAL_POOL_ADDRESS\n uint256 public PRICE_CAP\n uint256 public PRICE_FLOOR\n uint256 public PRICE_DECIMAL_PLACES\n uint256 public QTY_MULTIPLIER\n uint256 public COLLATERAL_PER_UNIT\n uint256 public COLLATERAL_TOKEN_FEE_PER_UNIT\n uint256 public MKT_TOKEN_FEE_PER_UNIT\n uint256 public EXPIRATION\n uint256 public SETTLEMENT_DELAY = 1 days\n address public LONG_POSITION_TOKEN\n address public SHORT_POSITION_TOKEN\n uint256 public lastPrice\n uint256 public settlementPrice\n uint256 public settlementTimeStamp\n bool public isSettled = false","after":" string public CONTRACT_NAME\n uint256 public PRICE_CAP\n uint256 public PRICE_FLOOR\n uint256 public PRICE_DECIMAL_PLACES\n uint256 public QTY_MULTIPLIER\n uint256 public COLLATERAL_PER_UNIT\n uint256 public COLLATERAL_TOKEN_FEE_PER_UNIT\n uint256 public MKT_TOKEN_FEE_PER_UNIT\n uint256 public EXPIRATION\n uint256 public SETTLEMENT_DELAY = 1 days\n uint256 public lastPrice\n uint256 public settlementPrice\n uint256 public settlementTimeStamp\n address public COLLATERAL_TOKEN_ADDRESS\n address public COLLATERAL_POOL_ADDRESS\n address public LONG_POSITION_TOKEN\n address public SHORT_POSITION_TOKEN\n bool public isSettled = false\n","contract":"MarketContract","time":0},{"type":"immutable-restrict-modification ","before":" string public ORACLE_URL","after":" string public immutable ORACLE_URL","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" string public ORACLE_STATISTIC","after":" string public immutable ORACLE_STATISTIC","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" string public CONTRACT_NAME","after":" string public immutable CONTRACT_NAME","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" address public COLLATERAL_TOKEN_ADDRESS","after":" address public immutable COLLATERAL_TOKEN_ADDRESS","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" address public COLLATERAL_POOL_ADDRESS","after":" address public immutable COLLATERAL_POOL_ADDRESS","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" uint256 public PRICE_CAP","after":" uint256 public immutable PRICE_CAP","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" uint256 public PRICE_FLOOR","after":" uint256 public immutable PRICE_FLOOR","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" uint256 public PRICE_DECIMAL_PLACES","after":" uint256 public immutable PRICE_DECIMAL_PLACES","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" uint256 public QTY_MULTIPLIER","after":" uint256 public immutable QTY_MULTIPLIER","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" uint256 public COLLATERAL_PER_UNIT","after":" uint256 public immutable COLLATERAL_PER_UNIT","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" uint256 public COLLATERAL_TOKEN_FEE_PER_UNIT","after":" uint256 public immutable COLLATERAL_TOKEN_FEE_PER_UNIT","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" uint256 public MKT_TOKEN_FEE_PER_UNIT","after":" uint256 public immutable MKT_TOKEN_FEE_PER_UNIT","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" uint256 public EXPIRATION","after":" uint256 public immutable EXPIRATION","contract":"MarketContractMPX","time":0},{"type":"constant-restrict-modification  ","before":" uint256 public SETTLEMENT_DELAY = 1 days","after":" uint256 public constant SETTLEMENT_DELAY = 1 days","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" address public LONG_POSITION_TOKEN","after":" address public immutable LONG_POSITION_TOKEN","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" address public SHORT_POSITION_TOKEN","after":" address public immutable SHORT_POSITION_TOKEN","contract":"MarketContractMPX","time":0},{"type":"immutable-restrict-modification ","before":" address public MARKET_COLLATERAL_POOL","after":" address public immutable MARKET_COLLATERAL_POOL","contract":"MarketContractFactoryMPX","time":0},{"type":"external-function ","before":" function execute(address _target, bytes memory _data)\n    public\n    payable\n    auth\n    note\n    returns (bytes memory response)\n    {\n        require(_target != address(0), \"ds-proxy-target-address-required\");\n\n        // call contract in current context\n        assembly {\n            let succeeded := delegatecall(\n            sub(gas, 5000),\n            _target,\n            add(_data, 0x20),\n            mload(_data),\n            0,\n            0\n            )\n            let size := returndatasize\n\n            response := mload(0x40)\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response, size)\n            returndatacopy(add(response, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n            // throw if delegatecall failed\n                revert(add(response, 0x20), size)\n            }\n        }\n    ","after":" function execute(address _target, bytes calldata _data)\n    public\n    payable\n    auth\n    note\n    returns (bytes memory response)\n    {\n        require(_target != address(0), \"ds-proxy-target-address-required\");\n\n        // call contract in current context\n        assembly {\n            let succeeded := delegatecall(\n            sub(gas, 5000),\n            _target,\n            add(_data, 0x20),\n            mload(_data),\n            0,\n            0\n            )\n            let size := returndatasize\n\n            response := mload(0x40)\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            mstore(response, size)\n            returndatacopy(add(response, 0x20), 0, size)\n\n            switch iszero(succeeded)\n            case 1 {\n            // throw if delegatecall failed\n                revert(add(response, 0x20), size)\n            }\n        }\n    ","contract":"DSProxy","time":1},{"type":"immutable-restrict-modification ","before":" address marketContractProxy","after":" address immutable marketContractProxy","contract":"DSProxyFactory","time":0},{"type":"external-function ","before":"   function batchRedeem(\n        address[] memory tokenAddresses, // Address of the long or short token to redeem\n        uint256[] memory tokensToRedeem // the number of tokens to redeem\n    ) public nonReentrant {\n        require(tokenAddresses.length == tokensToRedeem.length, \"Invalid input params\");\n        require(this.owner() == msg.sender, \"You don't own this DSProxy GTFO\");\n\n        MarketContractMPX marketInstance;\n        MarketCollateralPool marketCollateralPool;\n        PositionToken tokenInstance;\n\n        // Loop through all tokens and preform redemption\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            tokenInstance = PositionToken(tokenAddresses[i]);\n\n            require(\n                tokenInstance.balanceOf(address(this)) >= tokensToRedeem[i],\n                \"Insufficient position token balance\"\n            );\n\n            marketInstance = MarketContractMPX(tokenInstance.owner());\n            marketCollateralPool = getCollateralPool(marketInstance);\n\n            tokenInstance.approve(address(marketInstance), tokensToRedeem[i]);\n\n            if (uint8(tokenInstance.MARKET_SIDE()) == 0) {\n                // redeem n long tokens and 0 short tokens\n                marketCollateralPool.settleAndClose(\n                    address(marketInstance),\n                    tokensToRedeem[i],\n                    0\n                );\n            } else {\n                // redeem 0 long tokens and n short tokens\n                marketCollateralPool.settleAndClose(\n                    address(marketInstance),\n                    0,\n                    tokensToRedeem[i]\n                );\n            }\n        }\n        // Finally redeem collateral back to user.\n        ERC20 collateralToken = ERC20(marketInstance.COLLATERAL_TOKEN_ADDRESS());\n\n        // DSProxy balance. address(this) is the DSProxy contract address that will redeem the tokens.\n        uint256 dSProxyBalance = collateralToken.balanceOf(address(this));\n\n        // Move all redeemed tokens from DSProxy back to users wallet. msg.sender is the owner of the DSProxy.\n        collateralToken.transfer(msg.sender, dSProxyBalance);\n  ","after":"   function batchRedeem(\n        address[] calldata tokenAddresses, // Address of the long or short token to redeem\n        uint256[] calldata tokensToRedeem // the number of tokens to redeem\n    ) public nonReentrant {\n        require(tokenAddresses.length == tokensToRedeem.length, \"Invalid input params\");\n        require(this.owner() == msg.sender, \"You don't own this DSProxy GTFO\");\n\n        MarketContractMPX marketInstance;\n        MarketCollateralPool marketCollateralPool;\n        PositionToken tokenInstance;\n\n        // Loop through all tokens and preform redemption\n        for (uint256 i = 0; i < tokenAddresses.length; i++) {\n            tokenInstance = PositionToken(tokenAddresses[i]);\n\n            require(\n                tokenInstance.balanceOf(address(this)) >= tokensToRedeem[i],\n                \"Insufficient position token balance\"\n            );\n\n            marketInstance = MarketContractMPX(tokenInstance.owner());\n            marketCollateralPool = getCollateralPool(marketInstance);\n\n            tokenInstance.approve(address(marketInstance), tokensToRedeem[i]);\n\n            if (uint8(tokenInstance.MARKET_SIDE()) == 0) {\n                // redeem n long tokens and 0 short tokens\n                marketCollateralPool.settleAndClose(\n                    address(marketInstance),\n                    tokensToRedeem[i],\n                    0\n                );\n            } else {\n                // redeem 0 long tokens and n short tokens\n                marketCollateralPool.settleAndClose(\n                    address(marketInstance),\n                    0,\n                    tokensToRedeem[i]\n                );\n            }\n        }\n        // Finally redeem collateral back to user.\n        ERC20 collateralToken = ERC20(marketInstance.COLLATERAL_TOKEN_ADDRESS());\n\n        // DSProxy balance. address(this) is the DSProxy contract address that will redeem the tokens.\n        uint256 dSProxyBalance = collateralToken.balanceOf(address(this));\n\n        // Move all redeemed tokens from DSProxy back to users wallet. msg.sender is the owner of the DSProxy.\n        collateralToken.transfer(msg.sender, dSProxyBalance);\n  ","contract":"MarketContractProxy","time":0},{"type":"external-function ","before":"   function dailySettlement(\n        uint256 lookbackIndexValue,\n        uint256 currentIndexValue,\n        bytes32[3] memory marketAndsTokenNames,\n        uint256 newMarketExpiration\n    ) public onlyHoneyLemonOracle {\n        require(currentIndexValue != 0, \"Current MRI value cant be zero\");\n\n        // 1. Settle the past contract, if there is a price and contract exists.\n        MarketContractMPX expiringMarketContract = getExpiringMarketContract();\n        if (address(expiringMarketContract) != address(0x0)) {\n            settleMarketContract(lookbackIndexValue, address(expiringMarketContract));\n        }\n\n        // 2. Deploy daily contract for the next 28 days.\n        deployContract(currentIndexValue, marketAndsTokenNames, newMarketExpiration);\n\n        // 3. Store the latest MRI value\n        latestMri = currentIndexValue;\n  ","after":"   function dailySettlement(\n        uint256 lookbackIndexValue,\n        uint256 currentIndexValue,\n        bytes32[3] calldata marketAndsTokenNames,\n        uint256 newMarketExpiration\n    ) public onlyHoneyLemonOracle {\n        require(currentIndexValue != 0, \"Current MRI value cant be zero\");\n\n        // 1. Settle the past contract, if there is a price and contract exists.\n        MarketContractMPX expiringMarketContract = getExpiringMarketContract();\n        if (address(expiringMarketContract) != address(0x0)) {\n            settleMarketContract(lookbackIndexValue, address(expiringMarketContract));\n        }\n\n        // 2. Deploy daily contract for the next 28 days.\n        deployContract(currentIndexValue, marketAndsTokenNames, newMarketExpiration);\n\n        // 3. Store the latest MRI value\n        latestMri = currentIndexValue;\n  ","contract":"MarketContractProxy","time":0},{"type":"immutable-restrict-modification ","before":" address public COLLATERAL_TOKEN_ADDRESS","after":" address public immutable COLLATERAL_TOKEN_ADDRESS","contract":"MarketContractProxy","time":0},{"type":"constant-restrict-modification  ","before":" uint256 public CONTRACT_DURATION_DAYS = 28","after":" uint256 public constant CONTRACT_DURATION_DAYS = 28","contract":"MarketContractProxy","time":0},{"type":"constant-restrict-modification  ","before":" uint256 public CONTRACT_DURATION = CONTRACT_DURATION_DAYS * 24 * 60 * 60","after":" uint256 public constant CONTRACT_DURATION = CONTRACT_DURATION_DAYS * 24 * 60 * 60","contract":"MarketContractProxy","time":0},{"type":"constant-restrict-modification  ","before":" uint256 public CONTRACT_COLLATERAL_RATIO = 125000000","after":" uint256 public constant CONTRACT_COLLATERAL_RATIO = 125000000","contract":"MarketContractProxy","time":0}]}