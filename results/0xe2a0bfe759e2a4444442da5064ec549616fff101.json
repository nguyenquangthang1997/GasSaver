{"time":163,"results":[{"type":"external-function ","before":"indexed orderHash);\n\n\n\n    /**\n\n     * When orders are being matched, they will always contain the exact same base token,\n\n     * quote token, and relayer. Since excessive call data is very expensive, we choose\n\n     * to create a stripped down OrderParam struct containing only data that may vary between\n\n     * Order objects, and separate out the common elements into a set of addresses that will\n\n     * be shared among all of the OrderParam items. This is meant to eliminate redundancy in\n\n     * the call data, reducing it's size, and hence saving gas.\n\n     */\n\n    struct OrderParam {\n\n        address trader;\n\n        uint256 baseTokenAmount;\n\n        uint256 quoteTokenAmount;\n\n        uint256 gasTokenAmount;\n\n        bytes32 data;\n\n        OrderSignature signature;\n\n    }\n\n\n\n    /**\n\n     * Calculated data about an order object.\n\n     * Generally the filledAmount is specified in base token units, however in the case of a market\n\n     * buy order the filledAmount is specified in quote token units.\n\n     */\n\n    struct OrderInfo {\n\n        bytes32 orderHash;\n\n        uint256 filledAmount;\n\n    }\n\n\n    struct OrderAddressSet {\n\n        address baseToken;\n\n        address quoteToken;\n\n        address relayer;\n\n    }\n\n\n    struct MatchResult {\n\n        address maker;\n\n        address taker;\n\n        address buyer;\n\n        uint256 makerFee;\n\n        uint256 makerRebate;\n\n        uint256 takerFee;\n\n        uint256 makerGasFee;\n\n        uint256 takerGasFee;\n\n        uint256 baseTokenFilledAmount;\n\n        uint256 quoteTokenFilledAmount;\n\n    }\n\n\n    event Match(\n\n        OrderAddressSet addressSet,\n\n        MatchResult result\n\n    );\n\n\n\n    constructor(address _proxyAddress, address hotTokenAddress)\n\n    LibDiscount(hotTokenAddress)\n\n    public\n\n    {\n\n        proxyAddress = _proxyAddress;\n\n    }\n\n\n\n    /**\n\n     * Match taker order to a list of maker orders. Co","after":"indexed orderHash);\n\n\n\n    /**\n\n     * When orders are being matched, they will always contain the exact same base token,\n\n     * quote token, and relayer. Since excessive call data is very expensive, we choose\n\n     * to create a stripped down OrderParam struct containing only data that may vary between\n\n     * Order objects, and separate out the common elements into a set of addresses that will\n\n     * be shared among all of the OrderParam items. This is meant to eliminate redundancy in\n\n     * the call data, reducing it's size, and hence saving gas.\n\n     */\n\n    struct OrderParam {\n\n        address trader;\n\n        uint256 baseTokenAmount;\n\n        uint256 quoteTokenAmount;\n\n        uint256 gasTokenAmount;\n\n        bytes32 data;\n\n        OrderSignature signature;\n\n    }\n\n\n\n    /**\n\n     * Calculated data about an order object.\n\n     * Generally the filledAmount is specified in base token units, however in the case of a market\n\n     * buy order the filledAmount is specified in quote token units.\n\n     */\n\n    struct OrderInfo {\n\n        bytes32 orderHash;\n\n        uint256 filledAmount;\n\n    }\n\n\n    struct OrderAddressSet {\n\n        address baseToken;\n\n        address quoteToken;\n\n        address relayer;\n\n    }\n\n\n    struct MatchResult {\n\n        address maker;\n\n        address taker;\n\n        address buyer;\n\n        uint256 makerFee;\n\n        uint256 makerRebate;\n\n        uint256 takerFee;\n\n        uint256 makerGasFee;\n\n        uint256 takerGasFee;\n\n        uint256 baseTokenFilledAmount;\n\n        uint256 quoteTokenFilledAmount;\n\n    }\n\n\n    event Match(\n\n        OrderAddressSet addressSet,\n\n        MatchResult result\n\n    );\n\n\n\n    constructor(address _proxyAddress, address hotTokenAddress)\n\n    LibDiscount(hotTokenAddress)\n\n    public\n\n    {\n\n        proxyAddress = _proxyAddress;\n\n    }\n\n\n\n    /**\n\n     * Match taker order to a list of maker orders. Co","contract":"HybridExchange","time":0},{"type":"external-function ","before":"ms,\n\n        uint256[] memory baseTokenFilledAmounts,\n\n        OrderAddressSet memory orderAddressSet\n\n    ) public {\n\n        require(canMatchOrdersFrom(orderAddressSet.relayer), INVALID_SENDER);\n\n        require(!isMakerOnly(takerOrderPara","after":"ms,\n\n        uint256[] calldata baseTokenFilledAmounts,\n\n        OrderAddressSet memory orderAddressSet\n\n    ) public {\n\n        require(canMatchOrdersFrom(orderAddressSet.relayer), INVALID_SENDER);\n\n        require(!isMakerOnly(takerOrderPara","contract":"HybridExchange","time":0},{"type":"immutable-restrict-modification ","before":"for (uint256 i = 0; i < coun","after":"for (uint256 i = 0; i < coun","contract":"HybridExchange","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public DOMAIN_SEPARATOR;","after":"bytes32 public immutable DOMAIN_SEPARATOR;","contract":"HybridExchange","time":0},{"type":"immutable-restrict-modification ","before":"r;\n\n    }\n\n\n\n    /// @dev Allow","after":"r;\n\n    }\n\n\n\n    /// @dev Allow","contract":"HybridExchange","time":0}]}