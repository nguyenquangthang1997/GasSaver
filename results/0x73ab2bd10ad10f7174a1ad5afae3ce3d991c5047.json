{"time":102,"results":[{"type":"external-function ","before":"function executeMetaTransaction(address userAddress,\n\n        bytes memory functionSignature, string memory message, string memory length,\n\n        bytes32 sigR, bytes32 sigS, uint8 sigV) public payable returns (bytes memory) {\n\n\n        require(verify(userAddress, message, length, nonces[userAddress], getChainID(), sigR, sigS, sigV), \"Signer and signature do not match\");\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n\n        (bool success, bytes memory returnData) = address(this).call(abi.encodePacked(functionSignature, userAddress));\n\n\n        require(success, \"Function call not successfull\");\n\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(userAddress, msg.sender, functionSignature);\n\n        return returnData;\n\n    }","after":"function executeMetaTransaction(address userAddress,\n\n        bytes calldata functionSignature, string calldata message, string calldata length,\n\n        bytes32 sigR, bytes32 sigS, uint8 sigV) public payable returns (bytes memory) {\n\n\n        require(verify(userAddress, message, length, nonces[userAddress], getChainID(), sigR, sigS, sigV), \"Signer and signature do not match\");\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n\n        (bool success, bytes memory returnData) = address(this).call(abi.encodePacked(functionSignature, userAddress));\n\n\n        require(success, \"Function call not successfull\");\n\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(userAddress, msg.sender, functionSignature);\n\n        return returnData;\n\n    }","contract":"CurveExchangeAdapter","time":0}]}