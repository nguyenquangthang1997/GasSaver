{"time":161,"results":[{"type":"loop-calculation","before":"uint tokenId = uint(reservations[reservist].tokens[reservations[reservist].tokens.length - 1]);","after":"// move outside for loop\nuint tokenId = uint(reservations[reservist].tokens[reservations[reservist].tokens.length - 1]);","loc":{"start":{"line":1552,"column":12},"end":{"line":1552,"column":106}},"contract":"Ronin","time":0},{"type":"state-data-arrangement ","before":"\nbool paused = true;\nbool unpausable;\nuint startTime;\nuint pauseTime;\naddress whitelist;\nbool forceCeremony;\nuint16 public tokenCount;\nuint16 constant TOKEN_MAX = 8888;\nuint16 tokensGiven;\nuint16 constant TOKENS_GIVEAWAY = 300;\nuint constant PRICE_MINT = 0.0888 ether;\nstring __uriBase;\nstring __uriSuffix;\nuint constant COOLDOWN = 10;\nuint16 constant TRANSACTION_LIMIT = 10;\nmapping(address => Reservation) reservations;\nmapping(address => bool) public catMinted;","after":"uint startTime;\nuint pauseTime;\nuint constant PRICE_MINT = 0.0888 ether;\nstring __uriBase;\nstring __uriSuffix;\nuint constant COOLDOWN = 10;\nmapping(address => Reservation) reservations;\nmapping(address => bool) public catMinted;\naddress whitelist;\nuint16 public tokenCount;\nuint16 constant TOKEN_MAX = 8888;\nuint16 tokensGiven;\nuint16 constant TOKENS_GIVEAWAY = 300;\nuint16 constant TRANSACTION_LIMIT = 10;\nbool paused = true;\nbool unpausable;\nbool forceCeremony;\n","contract":"Ronin","time":3},{"type":"external-function ","before":"function catMint(bytes32[] memory merkleProof) external payable {\n\n        require(!paused, \"paused\");\n\n        require(phase() != Phase.Init, \"phase\");\n\n        require(tokenCount < TOKEN_MAX, \"TOKEN_MAX\");\n\n\n        require(msg.value >= PRICE_MINT, \"PRICE_MINT\");\n\n        require(!catMinted[msg.sender], \"catMinted\");\n\n        require(RoninWhitelist(whitelist).isWhitelisted(merkleProof, msg.sender), \"whitelist\");\n\n        catMinted[msg.sender] = true;\n\n\n        _mint(msg.sender, uint(++tokenCount));\n\n    }","after":"function catMint(bytes32[] calldata merkleProof) external payable {\n\n        require(!paused, \"paused\");\n\n        require(phase() != Phase.Init, \"phase\");\n\n        require(tokenCount < TOKEN_MAX, \"TOKEN_MAX\");\n\n\n        require(msg.value >= PRICE_MINT, \"PRICE_MINT\");\n\n        require(!catMinted[msg.sender], \"catMinted\");\n\n        require(RoninWhitelist(whitelist).isWhitelisted(merkleProof, msg.sender), \"whitelist\");\n\n        catMinted[msg.sender] = true;\n\n\n        _mint(msg.sender, uint(++tokenCount));\n\n    }","contract":"Ronin","time":0},{"type":"external-function ","before":"function updateURI(string memory _uriBase, string memory _uriSuffix) public onlyOwner {\n\n        __uriBase = _uriBase;\n\n        __uriSuffix = _uriSuffix;\n\n    }","after":"function updateURI(string calldata _uriBase, string calldata _uriSuffix) public onlyOwner {\n\n        __uriBase = _uriBase;\n\n        __uriSuffix = _uriSuffix;\n\n    }","contract":"Ronin","time":0},{"type":"immutable-restrict-modification ","before":"address whitelist;","after":"address immutable whitelist;","contract":"Ronin","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"Ronin","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"Ronin","time":1},{"type":"external-function ","before":"function isWhitelisted(bytes32[] memory proof, address claimer) public view returns (bool){\n\n        bytes32 leaf = keccak256(abi.encodePacked(claimer));\n\n        return MerkleProof.verify(proof, merkleRoot, leaf);\n\n    }","after":"function isWhitelisted(bytes32[] calldata proof, address claimer) public view returns (bool){\n\n        bytes32 leaf = keccak256(abi.encodePacked(claimer));\n\n        return MerkleProof.verify(proof, merkleRoot, leaf);\n\n    }","contract":"RoninWhitelist","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 merkleRoot;","after":"bytes32 immutable merkleRoot;","contract":"RoninWhitelist","time":0}]}