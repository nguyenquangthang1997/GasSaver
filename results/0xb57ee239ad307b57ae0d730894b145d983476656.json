{"time":423,"results":[{"type":"external-function ","before":"function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n    external\n    nonReentrant\n    onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from \n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantityUnits,\n            _minReceiveQuantityUnits,\n            _tradeAdapterName,\n            true\n        );\n\n        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }","after":"function lever(\n        ISetToken _setToken,\n        IERC20 _borrowAsset,\n        IERC20 _collateralAsset,\n        uint256 _borrowQuantityUnits,\n        uint256 _minReceiveQuantityUnits,\n        string calldata _tradeAdapterName,\n        bytes calldata _tradeData\n    )\n    external\n    nonReentrant\n    onlyManagerAndValidSet(_setToken)\n    {\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from \n        // collateral asset\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            _borrowQuantityUnits,\n            _minReceiveQuantityUnits,\n            _tradeAdapterName,\n            true\n        );\n\n        _borrow(leverInfo.setToken, leverInfo.lendingPool, leverInfo.borrowAsset, leverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _deposit(leverInfo.setToken, leverInfo.lendingPool, _collateralAsset, postTradeCollateralQuantity);\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n        emit LeverageIncreased(\n            _setToken,\n            _borrowAsset,\n            _collateralAsset,\n            leverInfo.exchangeAdapter,\n            leverInfo.notionalSendQuantity,\n            postTradeCollateralQuantity,\n            protocolFee\n        );\n    }","contract":"AaveLeverageModule","time":0},{"type":"external-function ","before":"function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        uint256 _minRepayQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n    external\n    nonReentrant\n    onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from \n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantityUnits,\n            _minRepayQuantityUnits,\n            _tradeAdapterName,\n            false\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }","after":"function delever(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        uint256 _minRepayQuantityUnits,\n        string calldata _tradeAdapterName,\n        bytes calldata _tradeData\n    )\n    external\n    nonReentrant\n    onlyManagerAndValidSet(_setToken)\n    {\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from \n        // repay asset\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            _redeemQuantityUnits,\n            _minRepayQuantityUnits,\n            _tradeAdapterName,\n            false\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, repayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            repayQuantity,\n            protocolFee\n        );\n    }","contract":"AaveLeverageModule","time":0},{"type":"external-function ","before":"function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        string memory _tradeAdapterName,\n        bytes memory _tradeData\n    )\n    external\n    nonReentrant\n    onlyManagerAndValidSet(_setToken)\n    returns (uint256)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);\n\n        require(borrowAssetEnabled[_setToken][_repayAsset], \"Borrow not enabled\");\n        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));\n        require(notionalRepayQuantity > 0, \"Borrow balance is zero\");\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false,\n            setTotalSupply\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0   // No protocol fee\n        );\n\n        return notionalRepayQuantity;\n    }","after":"function deleverToZeroBorrowBalance(\n        ISetToken _setToken,\n        IERC20 _collateralAsset,\n        IERC20 _repayAsset,\n        uint256 _redeemQuantityUnits,\n        string calldata _tradeAdapterName,\n        bytes calldata _tradeData\n    )\n    external\n    nonReentrant\n    onlyManagerAndValidSet(_setToken)\n    returns (uint256)\n    {\n        uint256 setTotalSupply = _setToken.totalSupply();\n        uint256 notionalRedeemQuantity = _redeemQuantityUnits.preciseMul(setTotalSupply);\n\n        require(borrowAssetEnabled[_setToken][_repayAsset], \"Borrow not enabled\");\n        uint256 notionalRepayQuantity = underlyingToReserveTokens[_repayAsset].variableDebtToken.balanceOf(address(_setToken));\n        require(notionalRepayQuantity > 0, \"Borrow balance is zero\");\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            notionalRedeemQuantity,\n            notionalRepayQuantity,\n            _tradeAdapterName,\n            false,\n            setTotalSupply\n        );\n\n        _withdraw(deleverInfo.setToken, deleverInfo.lendingPool, _collateralAsset, deleverInfo.notionalSendQuantity);\n\n        _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.lendingPool, _repayAsset, notionalRepayQuantity);\n\n        _updateDeleverPositions(deleverInfo, _repayAsset);\n\n        emit LeverageDecreased(\n            _setToken,\n            _collateralAsset,\n            _repayAsset,\n            deleverInfo.exchangeAdapter,\n            deleverInfo.notionalSendQuantity,\n            notionalRepayQuantity,\n            0   // No protocol fee\n        );\n\n        return notionalRepayQuantity;\n    }","contract":"AaveLeverageModule","time":0},{"type":"external-function ","before":"function initialize(\n        ISetToken _setToken,\n        IERC20[] memory _collateralAssets,\n        IERC20[] memory _borrowAssets\n    )\n    external\n    onlySetManager(_setToken, msg.sender)\n    onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], \"Not allowed SetToken\");\n        }\n\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), \"Issuance not initialized\");\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for (uint256 i = 0; i < modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n\n        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions\n        _addCollateralAssets(_setToken, _collateralAssets);\n        _addBorrowAssets(_setToken, _borrowAssets);\n    }","after":"function initialize(\n        ISetToken _setToken,\n        IERC20[] calldata _collateralAssets,\n        IERC20[] calldata _borrowAssets\n    )\n    external\n    onlySetManager(_setToken, msg.sender)\n    onlyValidAndPendingSet(_setToken)\n    {\n        if (!anySetAllowed) {\n            require(allowedSetTokens[_setToken], \"Not allowed SetToken\");\n        }\n\n        // Initialize module before trying register\n        _setToken.initializeModule();\n\n        // Get debt issuance module registered to this module and require that it is initialized\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), \"Issuance not initialized\");\n\n        // Try if register exists on any of the modules including the debt issuance module\n        address[] memory modules = _setToken.getModules();\n        for (uint256 i = 0; i < modules.length; i++) {\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n        }\n\n        // _collateralAssets and _borrowAssets arrays are validated in their respective internal functions\n        _addCollateralAssets(_setToken, _collateralAssets);\n        _addBorrowAssets(_setToken, _borrowAssets);\n    }","contract":"AaveLeverageModule","time":0},{"type":"external-function ","before":"function addCollateralAssets(ISetToken _setToken, IERC20[] memory _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {\n        _addCollateralAssets(_setToken, _newCollateralAssets);\n    }","after":"function addCollateralAssets(ISetToken _setToken, IERC20[] calldata _newCollateralAssets) external onlyManagerAndValidSet(_setToken) {\n        _addCollateralAssets(_setToken, _newCollateralAssets);\n    }","contract":"AaveLeverageModule","time":0},{"type":"external-function ","before":"function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for (uint256 i = 0; i < _collateralAssets.length; i++) {\n            IERC20 collateralAsset = _collateralAssets[i];\n            require(collateralAssetEnabled[_setToken][collateralAsset], \"Collateral not enabled\");\n\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);\n\n            delete collateralAssetEnabled[_setToken][collateralAsset];\n            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }","after":"function removeCollateralAssets(ISetToken _setToken, IERC20[] calldata _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for (uint256 i = 0; i < _collateralAssets.length; i++) {\n            IERC20 collateralAsset = _collateralAssets[i];\n            require(collateralAssetEnabled[_setToken][collateralAsset], \"Collateral not enabled\");\n\n            _updateUseReserveAsCollateral(_setToken, collateralAsset, false);\n\n            delete collateralAssetEnabled[_setToken][collateralAsset];\n            enabledAssets[_setToken].collateralAssets.removeStorage(address(collateralAsset));\n        }\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n    }","contract":"AaveLeverageModule","time":0},{"type":"external-function ","before":"function addBorrowAssets(ISetToken _setToken, IERC20[] memory _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {\n        _addBorrowAssets(_setToken, _newBorrowAssets);\n    }","after":"function addBorrowAssets(ISetToken _setToken, IERC20[] calldata _newBorrowAssets) external onlyManagerAndValidSet(_setToken) {\n        _addBorrowAssets(_setToken, _newBorrowAssets);\n    }","contract":"AaveLeverageModule","time":0},{"type":"external-function ","before":"function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for (uint256 i = 0; i < _borrowAssets.length; i++) {\n            IERC20 borrowAsset = _borrowAssets[i];\n\n            require(borrowAssetEnabled[_setToken][borrowAsset], \"Borrow not enabled\");\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, \"Variable debt remaining\");\n\n            delete borrowAssetEnabled[_setToken][borrowAsset];\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }","after":"function removeBorrowAssets(ISetToken _setToken, IERC20[] calldata _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n\n        for (uint256 i = 0; i < _borrowAssets.length; i++) {\n            IERC20 borrowAsset = _borrowAssets[i];\n\n            require(borrowAssetEnabled[_setToken][borrowAsset], \"Borrow not enabled\");\n            require(underlyingToReserveTokens[borrowAsset].variableDebtToken.balanceOf(address(_setToken)) == 0, \"Variable debt remaining\");\n\n            delete borrowAssetEnabled[_setToken][borrowAsset];\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(borrowAsset));\n        }\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n    }","contract":"AaveLeverageModule","time":0},{"type":"struct-data-arrangement ","before":"\naddress component\naddress module\nint256 unit\nuint8 positionState\nbytes data","after":"int256 unit\nbytes data\naddress component\naddress module\nuint8 positionState\n","contract":"ISetToken","time":0}]}