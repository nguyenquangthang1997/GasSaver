{"time":1554,"results":[{"type":"external-function ","before":"function evaluateCFrag(\n        bytes memory _capsuleBytes,\n        bytes memory _cFragBytes,\n        bytes memory _cFragSignature,\n        bytes memory _taskSignature,\n        bytes memory _requesterPublicKey,\n        bytes memory _workerPublicKey,\n        bytes memory _workerIdentityEvidence,\n        bytes memory _preComputedData\n    )\n    public\n    {\n        // 1. Check that CFrag is not evaluated yet\n        bytes32 evaluationHash = SignatureVerifier.hash(\n            abi.encodePacked(_capsuleBytes, _cFragBytes), hashAlgorithm);\n        require(!evaluatedCFrags[evaluationHash], \"This CFrag has already been evaluated.\");\n        evaluatedCFrags[evaluationHash] = true;\n\n        // 2. Verify correctness of re-encryption\n        bool cFragIsCorrect = ReEncryptionValidator.validateCFrag(_capsuleBytes, _cFragBytes, _preComputedData);\n        emit CFragEvaluated(evaluationHash, msg.sender, cFragIsCorrect);\n\n        // 3. Verify associated public keys and signatures\n        require(ReEncryptionValidator.checkSerializedCoordinates(_workerPublicKey),\n            \"Staker's public key is invalid\");\n        require(ReEncryptionValidator.checkSerializedCoordinates(_requesterPublicKey),\n            \"Requester's public key is invalid\");\n\n        UmbralDeserializer.PreComputedData memory precomp = _preComputedData.toPreComputedData();\n\n        // Verify worker's signature of CFrag\n        require(SignatureVerifier.verify(\n                _cFragBytes,\n                abi.encodePacked(_cFragSignature, precomp.lostBytes[1]),\n                _workerPublicKey,\n                hashAlgorithm),\n            \"CFrag signature is invalid\"\n        );\n\n        // Verify worker's signature of taskSignature and that it corresponds to cfrag.proof.metadata\n        UmbralDeserializer.CapsuleFrag memory cFrag = _cFragBytes.toCapsuleFrag();\n        require(SignatureVerifier.verify(\n                _taskSignature,\n                abi.encodePacked(cFrag.proof.metadata, precomp.lostBytes[2]),\n                _workerPublicKey,\n                hashAlgorithm),\n            \"Task signature is invalid\"\n        );\n\n        // Verify that _taskSignature is bob's signature of the task specification.\n        // A task specification is: capsule + ursula pubkey + alice address + blockhash\n        bytes32 stampXCoord;\n        assembly {\n            stampXCoord := mload(add(_workerPublicKey, 32))\n        }\n        bytes memory stamp = abi.encodePacked(precomp.lostBytes[4], stampXCoord);\n\n        require(SignatureVerifier.verify(\n                abi.encodePacked(_capsuleBytes,\n                stamp,\n                _workerIdentityEvidence,\n                precomp.alicesKeyAsAddress,\n                bytes32(0)),\n                abi.encodePacked(_taskSignature, precomp.lostBytes[3]),\n                _requesterPublicKey,\n                hashAlgorithm),\n            \"Specification signature is invalid\"\n        );\n\n        // 4. Extract worker address from stamp signature.\n        address worker = SignatureVerifier.recover(\n            SignatureVerifier.hashEIP191(stamp, byte(0x45)), // Currently, we use version E (0x45) of EIP191 signatures\n            _workerIdentityEvidence);\n        address staker = escrow.stakerFromWorker(worker);\n        require(staker != address(0), \"Worker must be related to a staker\");\n\n        // 5. Check that staker can be slashed\n        uint256 stakerValue = escrow.getAllTokens(staker);\n        require(stakerValue > 0, \"Staker has no tokens\");\n\n        // 6. If CFrag was incorrect, slash staker\n        if (!cFragIsCorrect) {\n            (uint256 penalty, uint256 reward) = calculatePenaltyAndReward(staker, stakerValue);\n            escrow.slashStaker(staker, penalty, msg.sender, reward);\n            emit IncorrectCFragVerdict(evaluationHash, worker, staker);\n        }\n    }","after":"function evaluateCFrag(\n        bytes calldata _capsuleBytes,\n        bytes calldata _cFragBytes,\n        bytes calldata _cFragSignature,\n        bytes calldata _taskSignature,\n        bytes calldata _requesterPublicKey,\n        bytes calldata _workerPublicKey,\n        bytes calldata _workerIdentityEvidence,\n        bytes calldata _preComputedData\n    )\n    public\n    {\n        // 1. Check that CFrag is not evaluated yet\n        bytes32 evaluationHash = SignatureVerifier.hash(\n            abi.encodePacked(_capsuleBytes, _cFragBytes), hashAlgorithm);\n        require(!evaluatedCFrags[evaluationHash], \"This CFrag has already been evaluated.\");\n        evaluatedCFrags[evaluationHash] = true;\n\n        // 2. Verify correctness of re-encryption\n        bool cFragIsCorrect = ReEncryptionValidator.validateCFrag(_capsuleBytes, _cFragBytes, _preComputedData);\n        emit CFragEvaluated(evaluationHash, msg.sender, cFragIsCorrect);\n\n        // 3. Verify associated public keys and signatures\n        require(ReEncryptionValidator.checkSerializedCoordinates(_workerPublicKey),\n            \"Staker's public key is invalid\");\n        require(ReEncryptionValidator.checkSerializedCoordinates(_requesterPublicKey),\n            \"Requester's public key is invalid\");\n\n        UmbralDeserializer.PreComputedData memory precomp = _preComputedData.toPreComputedData();\n\n        // Verify worker's signature of CFrag\n        require(SignatureVerifier.verify(\n                _cFragBytes,\n                abi.encodePacked(_cFragSignature, precomp.lostBytes[1]),\n                _workerPublicKey,\n                hashAlgorithm),\n            \"CFrag signature is invalid\"\n        );\n\n        // Verify worker's signature of taskSignature and that it corresponds to cfrag.proof.metadata\n        UmbralDeserializer.CapsuleFrag memory cFrag = _cFragBytes.toCapsuleFrag();\n        require(SignatureVerifier.verify(\n                _taskSignature,\n                abi.encodePacked(cFrag.proof.metadata, precomp.lostBytes[2]),\n                _workerPublicKey,\n                hashAlgorithm),\n            \"Task signature is invalid\"\n        );\n\n        // Verify that _taskSignature is bob's signature of the task specification.\n        // A task specification is: capsule + ursula pubkey + alice address + blockhash\n        bytes32 stampXCoord;\n        assembly {\n            stampXCoord := mload(add(_workerPublicKey, 32))\n        }\n        bytes memory stamp = abi.encodePacked(precomp.lostBytes[4], stampXCoord);\n\n        require(SignatureVerifier.verify(\n                abi.encodePacked(_capsuleBytes,\n                stamp,\n                _workerIdentityEvidence,\n                precomp.alicesKeyAsAddress,\n                bytes32(0)),\n                abi.encodePacked(_taskSignature, precomp.lostBytes[3]),\n                _requesterPublicKey,\n                hashAlgorithm),\n            \"Specification signature is invalid\"\n        );\n\n        // 4. Extract worker address from stamp signature.\n        address worker = SignatureVerifier.recover(\n            SignatureVerifier.hashEIP191(stamp, byte(0x45)), // Currently, we use version E (0x45) of EIP191 signatures\n            _workerIdentityEvidence);\n        address staker = escrow.stakerFromWorker(worker);\n        require(staker != address(0), \"Worker must be related to a staker\");\n\n        // 5. Check that staker can be slashed\n        uint256 stakerValue = escrow.getAllTokens(staker);\n        require(stakerValue > 0, \"Staker has no tokens\");\n\n        // 6. If CFrag was incorrect, slash staker\n        if (!cFragIsCorrect) {\n            (uint256 penalty, uint256 reward) = calculatePenaltyAndReward(staker, stakerValue);\n            escrow.slashStaker(staker, penalty, msg.sender, reward);\n            emit IncorrectCFragVerdict(evaluationHash, worker, staker);\n        }\n    }","contract":"Adjudicator","time":0},{"type":"constant-restrict-modification  ","before":"address public target;","after":"address public constant target;","contract":"Adjudicator","time":1},{"type":"constant-restrict-modification  ","before":"address public previousTarget;","after":"address public constant previousTarget;","contract":"Adjudicator","time":1},{"type":"constant-restrict-modification  ","before":"uint8 public isUpgrade;","after":"uint8 public constant isUpgrade;","contract":"Adjudicator","time":1},{"type":"constant-restrict-modification  ","before":"uint256 stubSlot;","after":"uint256 constant stubSlot;","contract":"Adjudicator","time":1},{"type":"constant-restrict-modification  ","before":"uint256 stubSlot;","after":"uint256 constant stubSlot;","contract":"Dispatcher","time":1},{"type":"state-data-arrangement ","before":"\nuint128 constant MAX_UINT128 = uint128(0) - 1;\nNuCypherToken public immutable token;\nuint128 public immutable totalSupply;\nuint256 public immutable mintingCoefficient;\nuint256 public immutable lockDurationCoefficient1;\nuint256 public immutable lockDurationCoefficient2;\nuint32 public immutable secondsPerPeriod;\nuint16 public immutable maximumRewardedPeriods;\nuint256 public immutable firstPhaseMaxIssuance;\nuint256 public immutable firstPhaseTotalSupply;\nuint128 public previousPeriodSupply;\nuint128 public currentPeriodSupply;\nuint16 public currentMintingPeriod;","after":"NuCypherToken public immutable token;\nuint256 public immutable mintingCoefficient;\nuint256 public immutable lockDurationCoefficient1;\nuint256 public immutable lockDurationCoefficient2;\nuint256 public immutable firstPhaseMaxIssuance;\nuint256 public immutable firstPhaseTotalSupply;\nuint128 constant MAX_UINT128 = uint128(0) - 1;\nuint128 public immutable totalSupply;\nuint128 public previousPeriodSupply;\nuint128 public currentPeriodSupply;\nuint32 public immutable secondsPerPeriod;\nuint16 public immutable maximumRewardedPeriods;\nuint16 public currentMintingPeriod;\n","contract":"Issuer","time":2},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"NuCypherToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"NuCypherToken","time":0},{"type":"immutable-restrict-modification ","before":"uint8 private _decimals;","after":"uint8 private immutable _decimals;","contract":"NuCypherToken","time":0},{"type":"state-data-arrangement ","before":"\nbytes16 internal constant RESERVED_POLICY_ID = bytes16(0);\naddress internal constant RESERVED_NODE = address(0);\nuint256 internal constant MAX_BALANCE = uint256(uint128(0) - 1);\nint256 public constant DEFAULT_FEE_DELTA = int256((uint256(0) - 1) >> 1);\nStakingEscrow public immutable escrow;\nuint32 public immutable secondsPerPeriod;\nmapping(bytes16 => Policy) public policies;\nmapping(address => NodeInfo) public nodes;\nRange public feeRateRange;","after":"uint256 internal constant MAX_BALANCE = uint256(uint128(0) - 1);\nint256 public constant DEFAULT_FEE_DELTA = int256((uint256(0) - 1) >> 1);\nStakingEscrow public immutable escrow;\nmapping(bytes16 => Policy) public policies;\nmapping(address => NodeInfo) public nodes;\nRange public feeRateRange;\naddress internal constant RESERVED_NODE = address(0);\nbytes16 internal constant RESERVED_POLICY_ID = bytes16(0);\nuint32 public immutable secondsPerPeriod;\n","contract":"PolicyManager","time":0},{"type":"struct-data-arrangement ","before":"\naddress node\nuint256 indexOfDowntimePeriods\nuint16 lastRefundedPeriod","after":"uint256 indexOfDowntimePeriods\naddress node\nuint16 lastRefundedPeriod\n","contract":"PolicyManager","time":0},{"type":"constant-restrict-modification  ","before":"address public target;","after":"address public constant target;","contract":"PolicyManager","time":0},{"type":"constant-restrict-modification  ","before":"address public previousTarget;","after":"address public constant previousTarget;","contract":"PolicyManager","time":0},{"type":"constant-restrict-modification  ","before":"uint8 public isUpgrade;","after":"uint8 public constant isUpgrade;","contract":"PolicyManager","time":0},{"type":"constant-restrict-modification  ","before":"uint256 stubSlot;","after":"uint256 constant stubSlot;","contract":"PolicyManager","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public ownerFraction;","after":"uint256 public immutable ownerFraction;","contract":"PoolingStakingContract","time":0},{"type":"loop-calculation","before":"StakerInfo storage info = stakerInfo[staker];","after":"// move outside for loop\nStakerInfo storage info = stakerInfo[staker];","loc":{"start":{"line":4106,"column":12},"end":{"line":4106,"column":56}},"contract":"StakingEscrow","time":0},{"type":"de-morgan-condition ","before":"!crosscurrentCommittedPeriod && !crossnextCommittedPeriod","after":"!(crosscurrentCommittedPeriod && crossnextCommittedPeriod)","loc":{"start":{"line":5181,"column":12},"end":{"line":5181,"column":45}},"contract":"StakingEscrow","time":0},{"type":"state-data-arrangement ","before":"\nuint16 internal constant RESERVED_PERIOD = 0;\nuint16 internal constant MAX_CHECKED_VALUES = 5;\nuint16 public constant MAX_SUB_STAKES = 30;\nuint16 internal constant MAX_UINT16 = 65535;\nuint8 internal constant RE_STAKE_DISABLED_INDEX = 0;\nuint8 internal constant WIND_DOWN_INDEX = 1;\nuint8 internal constant MEASURE_WORK_INDEX = 2;\nuint8 internal constant SNAPSHOTS_DISABLED_INDEX = 3;\nuint16 public immutable minLockedPeriods;\nuint16 public immutable minWorkerPeriods;\nuint256 public immutable minAllowableLockedTokens;\nuint256 public immutable maxAllowableLockedTokens;\nbool public immutable isTestContract;\nmapping(address => StakerInfo) public stakerInfo;\naddress[] public stakers;\nmapping(address => address) public stakerFromWorker;\nmapping(uint16 => uint256) public lockedPerPeriod;\nuint128[] public balanceHistory;\nPolicyManagerInterface public policyManager;\nAdjudicatorInterface public adjudicator;\nWorkLockInterface public workLock;","after":"uint256 public immutable minAllowableLockedTokens;\nuint256 public immutable maxAllowableLockedTokens;\nmapping(address => StakerInfo) public stakerInfo;\naddress[] public stakers;\nmapping(address => address) public stakerFromWorker;\nmapping(uint16 => uint256) public lockedPerPeriod;\nuint128[] public balanceHistory;\nPolicyManagerInterface public policyManager;\nAdjudicatorInterface public adjudicator;\nWorkLockInterface public workLock;\nuint16 internal constant RESERVED_PERIOD = 0;\nuint16 internal constant MAX_CHECKED_VALUES = 5;\nuint16 public constant MAX_SUB_STAKES = 30;\nuint16 internal constant MAX_UINT16 = 65535;\nuint16 public immutable minLockedPeriods;\nuint16 public immutable minWorkerPeriods;\nuint8 internal constant RE_STAKE_DISABLED_INDEX = 0;\nuint8 internal constant WIND_DOWN_INDEX = 1;\nuint8 internal constant MEASURE_WORK_INDEX = 2;\nuint8 internal constant SNAPSHOTS_DISABLED_INDEX = 3;\nbool public immutable isTestContract;\n","contract":"StakingEscrow","time":10},{"type":"struct-data-arrangement ","before":"\nuint256 value\nuint16 currentCommittedPeriod\nuint16 nextCommittedPeriod\nuint16 lastCommittedPeriod\nuint16 lockReStakeUntilPeriod\nuint256 completedWork\nuint16 workerStartPeriod\naddress worker\nuint256 flags\nuint256 reservedSlot1\nuint256 reservedSlot2\nuint256 reservedSlot3\nuint256 reservedSlot4\nuint256 reservedSlot5\nDowntime[] pastDowntime\nSubStakeInfo[] subStakes\nuint128[] history","after":"uint256 value\nuint256 completedWork\nuint256 flags\nuint256 reservedSlot1\nuint256 reservedSlot2\nuint256 reservedSlot3\nuint256 reservedSlot4\nuint256 reservedSlot5\nDowntime[] pastDowntime\nSubStakeInfo[] subStakes\nuint128[] history\naddress worker\nuint16 currentCommittedPeriod\nuint16 nextCommittedPeriod\nuint16 lastCommittedPeriod\nuint16 lockReStakeUntilPeriod\nuint16 workerStartPeriod\n","contract":"StakingEscrow","time":0},{"type":"constant-restrict-modification  ","before":"address public target;","after":"address public constant target;","contract":"StakingEscrow","time":3},{"type":"constant-restrict-modification  ","before":"address public previousTarget;","after":"address public constant previousTarget;","contract":"StakingEscrow","time":3},{"type":"constant-restrict-modification  ","before":"uint8 public isUpgrade;","after":"uint8 public constant isUpgrade;","contract":"StakingEscrow","time":3},{"type":"constant-restrict-modification  ","before":"uint256 stubSlot;","after":"uint256 constant stubSlot;","contract":"StakingEscrow","time":3},{"type":"loop-calculation","before":"StakerInfo storage info = stakerInfo[staker];","after":"// move outside for loop\nStakerInfo storage info = stakerInfo[staker];","loc":{"start":{"line":5781,"column":12},"end":{"line":5781,"column":56}},"contract":"StakingEscrow","time":0},{"type":"de-morgan-condition ","before":"!crosscurrentCommittedPeriod && !crossnextCommittedPeriod","after":"!(crosscurrentCommittedPeriod && crossnextCommittedPeriod)","loc":{"start":{"line":6849,"column":12},"end":{"line":6849,"column":45}},"contract":"StakingEscrow","time":0},{"type":"state-data-arrangement ","before":"\nuint16 internal constant RESERVED_PERIOD = 0;\nuint16 internal constant MAX_CHECKED_VALUES = 5;\nuint16 public constant MAX_SUB_STAKES = 30;\nuint16 internal constant MAX_UINT16 = 65535;\nuint8 internal constant RE_STAKE_DISABLED_INDEX = 0;\nuint8 internal constant WIND_DOWN_INDEX = 1;\nuint8 internal constant MEASURE_WORK_INDEX = 2;\nuint8 internal constant SNAPSHOTS_DISABLED_INDEX = 3;\nuint16 public immutable minLockedPeriods;\nuint16 public immutable minWorkerPeriods;\nuint256 public immutable minAllowableLockedTokens;\nuint256 public immutable maxAllowableLockedTokens;\nbool public immutable isTestContract;\nmapping(address => StakerInfo) public stakerInfo;\naddress[] public stakers;\nmapping(address => address) public stakerFromWorker;\nmapping(uint16 => uint256) public lockedPerPeriod;\nuint128[] public balanceHistory;\nPolicyManagerInterface public policyManager;\nAdjudicatorInterface public adjudicator;\nWorkLockInterface public workLock;","after":"uint256 public immutable minAllowableLockedTokens;\nuint256 public immutable maxAllowableLockedTokens;\nmapping(address => StakerInfo) public stakerInfo;\naddress[] public stakers;\nmapping(address => address) public stakerFromWorker;\nmapping(uint16 => uint256) public lockedPerPeriod;\nuint128[] public balanceHistory;\nPolicyManagerInterface public policyManager;\nAdjudicatorInterface public adjudicator;\nWorkLockInterface public workLock;\nuint16 internal constant RESERVED_PERIOD = 0;\nuint16 internal constant MAX_CHECKED_VALUES = 5;\nuint16 public constant MAX_SUB_STAKES = 30;\nuint16 internal constant MAX_UINT16 = 65535;\nuint16 public immutable minLockedPeriods;\nuint16 public immutable minWorkerPeriods;\nuint8 internal constant RE_STAKE_DISABLED_INDEX = 0;\nuint8 internal constant WIND_DOWN_INDEX = 1;\nuint8 internal constant MEASURE_WORK_INDEX = 2;\nuint8 internal constant SNAPSHOTS_DISABLED_INDEX = 3;\nbool public immutable isTestContract;\n","contract":"StakingEscrow","time":4},{"type":"struct-data-arrangement ","before":"\nuint256 value\nuint16 currentCommittedPeriod\nuint16 nextCommittedPeriod\nuint16 lastCommittedPeriod\nuint16 lockReStakeUntilPeriod\nuint256 completedWork\nuint16 workerStartPeriod\naddress worker\nuint256 flags\nuint256 reservedSlot1\nuint256 reservedSlot2\nuint256 reservedSlot3\nuint256 reservedSlot4\nuint256 reservedSlot5\nDowntime[] pastDowntime\nSubStakeInfo[] subStakes\nuint128[] history","after":"uint256 value\nuint256 completedWork\nuint256 flags\nuint256 reservedSlot1\nuint256 reservedSlot2\nuint256 reservedSlot3\nuint256 reservedSlot4\nuint256 reservedSlot5\nDowntime[] pastDowntime\nSubStakeInfo[] subStakes\nuint128[] history\naddress worker\nuint16 currentCommittedPeriod\nuint16 nextCommittedPeriod\nuint16 lastCommittedPeriod\nuint16 lockReStakeUntilPeriod\nuint16 workerStartPeriod\n","contract":"StakingEscrow","time":0},{"type":"constant-restrict-modification  ","before":"address public target;","after":"address public constant target;","contract":"StakingEscrow","time":1},{"type":"constant-restrict-modification  ","before":"address public previousTarget;","after":"address public constant previousTarget;","contract":"StakingEscrow","time":1},{"type":"constant-restrict-modification  ","before":"uint8 public isUpgrade;","after":"uint8 public constant isUpgrade;","contract":"StakingEscrow","time":1},{"type":"constant-restrict-modification  ","before":"uint256 stubSlot;","after":"uint256 constant stubSlot;","contract":"StakingEscrow","time":1},{"type":"state-data-arrangement ","before":"\naddress public target;\naddress public previousTarget;\nuint8 public isUpgrade;\nuint256 stubSlot;\nuint8 constant UPGRADE_FALSE = 1;\nuint8 constant UPGRADE_TRUE = 2;","after":"uint256 stubSlot;\naddress public target;\naddress public previousTarget;\nuint8 public isUpgrade;\nuint8 constant UPGRADE_FALSE = 1;\nuint8 constant UPGRADE_TRUE = 2;\n","contract":"Upgradeable","time":0},{"type":"loop-calculation","before":"uint256 depositedETH = workInfo[bidder].depositedETH;","after":"// move outside for loop\nuint256 depositedETH = workInfo[bidder].depositedETH;","loc":{"start":{"line":8273,"column":12},"end":{"line":8273,"column":64}},"contract":"WorkLock","time":0},{"type":"loop-duplication","before":"\nstart line 8310 column 8, end line 8315 column 8\nfor (uint256 i = 0; i < length; i++) {\n            address bidder = _biddersForRefund[i];\n            WorkInfo storage info = workInfo[bidder];\n            refunds[i] += refundETH;\n            info.depositedETH = resultBid;\n        }\nstart line 8321 column 8, end line 8325 column 8\nfor (uint256 i = 0; i < length; i++) {\n            address bidder = _biddersForRefund[i];\n            compensation[bidder] += refunds[i];\n            emit ForceRefund(msg.sender, bidder, refunds[i]);\n        }","after":"// merge loop\n\nstart line 8310 column 8, end line 8315 column 8\nfor (uint256 i = 0; i < length; i++) {\n            address bidder = _biddersForRefund[i];\n            WorkInfo storage info = workInfo[bidder];\n            refunds[i] += refundETH;\n            info.depositedETH = resultBid;\n        }\nstart line 8321 column 8, end line 8325 column 8\nfor (uint256 i = 0; i < length; i++) {\n            address bidder = _biddersForRefund[i];\n            compensation[bidder] += refunds[i];\n            emit ForceRefund(msg.sender, bidder, refunds[i]);\n        }","contract":"WorkLock","time":0},{"type":"state-data-arrangement ","before":"\nuint16 public constant SLOWING_REFUND = 100;\nuint256 private constant MAX_ETH_SUPPLY = 2e10 ether;\nNuCypherToken public immutable token;\nStakingEscrow public immutable escrow;\nuint256 public immutable boostingRefund;\nuint256 public immutable minAllowedBid;\nuint16 public immutable stakingPeriods;\nuint256 public immutable maxAllowableLockedTokens;\nuint256 public immutable minAllowableLockedTokens;\nuint256 public tokenSupply;\nuint256 public startBidDate;\nuint256 public endBidDate;\nuint256 public endCancellationDate;\nuint256 public bonusETHSupply;\nmapping(address => WorkInfo) public workInfo;\nmapping(address => uint256) public compensation;\naddress[] public bidders;\nuint256 public nextBidderToCheck;","after":"uint256 private constant MAX_ETH_SUPPLY = 2e10 ether;\nNuCypherToken public immutable token;\nStakingEscrow public immutable escrow;\nuint256 public immutable boostingRefund;\nuint256 public immutable minAllowedBid;\nuint256 public immutable maxAllowableLockedTokens;\nuint256 public immutable minAllowableLockedTokens;\nuint256 public tokenSupply;\nuint256 public startBidDate;\nuint256 public endBidDate;\nuint256 public endCancellationDate;\nuint256 public bonusETHSupply;\nmapping(address => WorkInfo) public workInfo;\nmapping(address => uint256) public compensation;\naddress[] public bidders;\nuint256 public nextBidderToCheck;\nuint16 public constant SLOWING_REFUND = 100;\nuint16 public immutable stakingPeriods;\n","contract":"WorkLock","time":0},{"type":"state-data-arrangement ","before":"\nuint256 public constant BASIS_FRACTION = 100;\nStakingEscrow public escrow;\nWorkLock public workLock;\naddress public workerOwner;\nuint256 public totalDepositedTokens;\nuint256 public workLockClaimedTokens;\nuint256 public totalWithdrawnReward;\nuint256 public totalWithdrawnETH;\nuint256 public totalWorkLockETHReceived;\nuint256 public totalWorkLockETHRefunded;\nuint256 public totalWorkLockETHWithdrawn;\nuint256 workerFraction;\nuint256 public workerWithdrawnReward;\nmapping(address => Delegator) public delegators;\nbool depositIsEnabled = true;","after":"uint256 public constant BASIS_FRACTION = 100;\nStakingEscrow public escrow;\nWorkLock public workLock;\nuint256 public totalDepositedTokens;\nuint256 public workLockClaimedTokens;\nuint256 public totalWithdrawnReward;\nuint256 public totalWithdrawnETH;\nuint256 public totalWorkLockETHReceived;\nuint256 public totalWorkLockETHRefunded;\nuint256 public totalWorkLockETHWithdrawn;\nuint256 workerFraction;\nuint256 public workerWithdrawnReward;\nmapping(address => Delegator) public delegators;\naddress public workerOwner;\nbool depositIsEnabled = true;\n","contract":"WorkLockPoolingContract","time":0}]}