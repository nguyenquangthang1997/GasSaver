{"time":310,"results":[{"type":"state-data-arrangement ","before":"\nCounters.Counter private _tokenIdCounter;\nCounters.Counter private _reservedTokenIdCounter;\n  address public superTigerContrac\n  uint256 public constant NFT_PRICE = 8000000000000000\n  uint public constant MAX_NFT_PURCHASE = 10\n  uint256 public constant NFT_PRICE_PRE_SALE = 5800000000000000\n  uint public constant MAX_NFT_PURCHASE_PRE_SALE = 1\n  uint256 public constant NFT_PRICE_LOVE = 6900000000000000\n  uint public constant MAX_NFT_PURCHASE_LOVE = 10\n  uint256 public MAX_SUPPLY = 1000\n  uint public constant RESERVED_TOTAL = 32\n  bool public isSaleActive = fals\n  bool public isPreSaleActive = fals\n  bool public isRevealed = fals\n  string public provenanceHas\n  string private _baseURIExtende\n  string private _placeholderURIExtende","after":"Counters.Counter private _tokenIdCounter;\nCounters.Counter private _reservedTokenIdCounter;\n  uint256 public constant NFT_PRICE = 8000000000000000\n  uint public constant MAX_NFT_PURCHASE = 10\n  uint256 public constant NFT_PRICE_PRE_SALE = 5800000000000000\n  uint public constant MAX_NFT_PURCHASE_PRE_SALE = 1\n  uint256 public constant NFT_PRICE_LOVE = 6900000000000000\n  uint public constant MAX_NFT_PURCHASE_LOVE = 10\n  uint256 public MAX_SUPPLY = 1000\n  uint public constant RESERVED_TOTAL = 32\n  string public provenanceHas\n  string private _baseURIExtende\n  string private _placeholderURIExtende\n  address public superTigerContrac\n  bool public isSaleActive = fals\n  bool public isPreSaleActive = fals\n  bool public isRevealed = fals\n","contract":"SuperBunnies","time":0},{"type":"external-function ","before":"  function setBaseURI(string memory baseURI_) external onlyOwner {\n        _baseURIExtended = baseURI_;\n   ","after":"  function setBaseURI(string calldata baseURI_) external onlyOwner {\n        _baseURIExtended = baseURI_;\n   ","contract":"SuperBunnies","time":0},{"type":"external-function ","before":"  function setPlaceholderURI(string memory placeholderURI_) external onlyOwner {\n        _placeholderURIExtended = placeholderURI_;\n   ","after":"  function setPlaceholderURI(string calldata placeholderURI_) external onlyOwner {\n        _placeholderURIExtended = placeholderURI_;\n   ","contract":"SuperBunnies","time":0},{"type":"external-function ","before":"  function setProvenanceHash(string memory provenanceHash_) external onlyOwner {\n        provenanceHash = provenanceHash_;\n   ","after":"  function setProvenanceHash(string calldata provenanceHash_) external onlyOwner {\n        provenanceHash = provenanceHash_;\n   ","contract":"SuperBunnies","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n        nonce : nonces[userAddress],\n        from : userAddress,\n        functionSignature : functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n        nonce : nonces[userAddress],\n        from : userAddress,\n        functionSignature : functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"SuperBunnies","time":0},{"type":"constant-restrict-modification  ","before":"  uint256 public MAX_SUPPLY = 1000","after":"  uint256 public constant MAX_SUPPLY = 1000","contract":"SuperBunnies","time":1},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"SuperBunnies","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"SuperBunnies","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"SuperBunnies","time":1}]}