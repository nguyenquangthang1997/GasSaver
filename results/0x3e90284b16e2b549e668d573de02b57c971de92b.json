{"time":1242,"results":[{"type":"external-function ","before":"  function requestRedemption(\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript\n    ) public returns (bool) {\n        self.requestRedemption(_outputValueBytes, _redeemerOutputScript);\n        return true;\n   ","after":"  function requestRedemption(\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript\n    ) public returns (bool) {\n        self.requestRedemption(_outputValueBytes, _redeemerOutputScript);\n        return true;\n   ","contract":"Deposit","time":0},{"type":"external-function ","before":"  function transferAndRequestRedemption(\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public returns (bool) {\n        self.transferAndRequestRedemption(\n            _outputValueBytes,\n            _redeemerOutputScript,\n            _finalRecipient\n        );\n        return true;\n   ","after":"  function transferAndRequestRedemption(\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public returns (bool) {\n        self.transferAndRequestRedemption(\n            _outputValueBytes,\n            _redeemerOutputScript,\n            _finalRecipient\n        );\n        return true;\n   ","contract":"Deposit","time":0},{"type":"external-function ","before":"  function provideRedemptionProof(\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public returns (bool) {\n        self.provideRedemptionProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n        return true;\n   ","after":"  function provideRedemptionProof(\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public returns (bool) {\n        self.provideRedemptionProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n        return true;\n   ","contract":"Deposit","time":0},{"type":"external-function ","before":"  function requestFunderAbort(bytes memory _abortOutputScript) public {\n        require(\n            self.depositOwner() == msg.sender,\n            \"Only TDT holder can request funder abort\"\n        );\n\n        self.requestFunderAbort(_abortOutputScript);\n   ","after":"  function requestFunderAbort(bytes calldata _abortOutputScript) public {\n        require(\n            self.depositOwner() == msg.sender,\n            \"Only TDT holder can request funder abort\"\n        );\n\n        self.requestFunderAbort(_abortOutputScript);\n   ","contract":"Deposit","time":0},{"type":"external-function ","before":"  function provideFundingECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public returns (bool) {\n        self.provideFundingECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n        return true;\n   ","after":"  function provideFundingECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public returns (bool) {\n        self.provideFundingECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n        return true;\n   ","contract":"Deposit","time":0},{"type":"external-function ","before":"  function provideBTCFundingProof(\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public returns (bool) {\n        self.provideBTCFundingProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n        return true;\n   ","after":"  function provideBTCFundingProof(\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public returns (bool) {\n        self.provideBTCFundingProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n        return true;\n   ","contract":"Deposit","time":0},{"type":"external-function ","before":"  function provideECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public returns (bool) {\n        self.provideECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n        return true;\n   ","after":"  function provideECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public returns (bool) {\n        self.provideECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n        return true;\n   ","contract":"Deposit","time":0},{"type":"immutable-restrict-modification ","before":"c pure returns (uint256) {\n        ","after":"c pure returns (uint256) {\n        ","contract":"DepositFactory","time":0},{"type":"external-function ","before":"  function requestFunderAbort(\n        DepositUtils.Deposit storage _d,\n        bytes memory _abortOutputScript\n    ) public {\n        require(\n            _d.inFailedSetup(),\n            \"The deposit has not failed funding\"\n        );\n\n        _d.logFunderRequestedAbort(_abortOutputScript);\n   ","after":"  function requestFunderAbort(\n        DepositUtils.Deposit storage _d,\n        bytes calldata _abortOutputScript\n    ) public {\n        require(\n            _d.inFailedSetup(),\n            \"The deposit has not failed funding\"\n        );\n\n        _d.logFunderRequestedAbort(_abortOutputScript);\n   ","contract":"DepositFunding","time":0},{"type":"external-function ","before":"  function provideFundingECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public {\n        require(\n            _d.inAwaitingBTCFundingProof(),\n            \"Signer fraud during funding flow only available while awaiting funding\"\n        );\n\n        _d.submitSignatureFraud(_v, _r, _s, _signedDigest, _preimage);\n        _d.logFraudDuringSetup();\n\n        // Allow deposit owner to withdraw seized bonds after contract termination.\n        uint256 _seized = _d.seizeSignerBonds();\n        _d.enableWithdrawal(_d.depositOwner(), _seized);\n\n        fundingFraudTeardown(_d);\n        _d.setFailedSetup();\n        _d.logSetupFailed();\n   ","after":"  function provideFundingECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public {\n        require(\n            _d.inAwaitingBTCFundingProof(),\n            \"Signer fraud during funding flow only available while awaiting funding\"\n        );\n\n        _d.submitSignatureFraud(_v, _r, _s, _signedDigest, _preimage);\n        _d.logFraudDuringSetup();\n\n        // Allow deposit owner to withdraw seized bonds after contract termination.\n        uint256 _seized = _d.seizeSignerBonds();\n        _d.enableWithdrawal(_d.depositOwner(), _seized);\n\n        fundingFraudTeardown(_d);\n        _d.setFailedSetup();\n        _d.logSetupFailed();\n   ","contract":"DepositFunding","time":0},{"type":"external-function ","before":"  function provideBTCFundingProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public returns (bool) {\n\n        require(_d.inAwaitingBTCFundingProof(), \"Not awaiting funding\");\n\n        bytes8 _valueBytes;\n        bytes memory _utxoOutpoint;\n\n        (_valueBytes, _utxoOutpoint) = _d.validateAndParseFundingSPVProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n\n        // Write down the UTXO info and set to active. Congratulations :)\n        _d.utxoSizeBytes = _valueBytes;\n        _d.utxoOutpoint = _utxoOutpoint;\n        _d.fundedAt = block.timestamp;\n\n        fundingTeardown(_d);\n        _d.setActive();\n        _d.logFunded();\n\n        return true;\n   ","after":"  function provideBTCFundingProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public returns (bool) {\n\n        require(_d.inAwaitingBTCFundingProof(), \"Not awaiting funding\");\n\n        bytes8 _valueBytes;\n        bytes memory _utxoOutpoint;\n\n        (_valueBytes, _utxoOutpoint) = _d.validateAndParseFundingSPVProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n\n        // Write down the UTXO info and set to active. Congratulations :)\n        _d.utxoSizeBytes = _valueBytes;\n        _d.utxoOutpoint = _utxoOutpoint;\n        _d.fundedAt = block.timestamp;\n\n        fundingTeardown(_d);\n        _d.setActive();\n        _d.logFunded();\n\n        return true;\n   ","contract":"DepositFunding","time":0},{"type":"external-function ","before":"    function provideECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public {\n        require(\n            !_d.inFunding(),\n            \"Use provideFundingECDSAFraudProof instead\"\n        );\n        require(\n            !_d.inSignerLiquidation(),\n            \"Signer liquidation already in progress\"\n        );\n        require(!_d.inEndState(), \"Contract has halted\");\n        submitSignatureFraud(_d, _v, _r, _s, _signedDigest, _preimage);\n\n        startLiquidation(_d, true);\n ","after":"    function provideECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public {\n        require(\n            !_d.inFunding(),\n            \"Use provideFundingECDSAFraudProof instead\"\n        );\n        require(\n            !_d.inSignerLiquidation(),\n            \"Signer liquidation already in progress\"\n        );\n        require(!_d.inEndState(), \"Contract has halted\");\n        submitSignatureFraud(_d, _v, _r, _s, _signedDigest, _preimage);\n\n        startLiquidation(_d, true);\n ","contract":"DepositLiquidation","time":0},{"type":"external-function ","before":"er.\n    function transferAndRequestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public {\n        _d.tbtcDepositToken.transferFrom(msg.sender, _finalRecipient, uint256(address(this)));\n\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, _finalRecipient","after":"er.\n    function transferAndRequestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public {\n        _d.tbtcDepositToken.transferFrom(msg.sender, _finalRecipient, uint256(address(this)));\n\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, _finalRecipient","contract":"DepositRedemption","time":0},{"type":"external-function ","before":"pt.\n    function requestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript\n    ) public {\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, msg.sender","after":"pt.\n    function requestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript\n    ) public {\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, msg.sender","contract":"DepositRedemption","time":0},{"type":"external-function ","before":"rs.\n    function provideRedemptionProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public {\n        bytes32 _txid;\n        uint256 _fundingOutputValue;\n\n        require(_d.inRedemption(), \"Redemption proof only allowed from redemption flow\");\n\n        _fundingOutputValue = redemptionTransactionChecks(_d, _txInputVector, _txOutputVector);\n\n        _txid = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n        _d.checkProofFromTxId(_txid, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        require((_d.utxoSize().sub(_fundingOutputValue)) <= _d.latestRedemptionFee, \"Incorrect fee amount\");\n\n        // Transfer TBTC to signers and close the keep.\n        distributeSignerFee(_d);\n        _d.closeKeep();\n\n        _d.distributeFeeRebate();\n\n        // We're done yey!\n        _d.setRedeemed();\n        _d.redemptionTeardown();\n        _d.logRedeemed(_txid","after":"rs.\n    function provideRedemptionProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public {\n        bytes32 _txid;\n        uint256 _fundingOutputValue;\n\n        require(_d.inRedemption(), \"Redemption proof only allowed from redemption flow\");\n\n        _fundingOutputValue = redemptionTransactionChecks(_d, _txInputVector, _txOutputVector);\n\n        _txid = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n        _d.checkProofFromTxId(_txid, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        require((_d.utxoSize().sub(_fundingOutputValue)) <= _d.latestRedemptionFee, \"Incorrect fee amount\");\n\n        // Transfer TBTC to signers and close the keep.\n        distributeSignerFee(_d);\n        _d.closeKeep();\n\n        _d.distributeFeeRebate();\n\n        // We're done yey!\n        _d.setRedeemed();\n        _d.redemptionTeardown();\n        _d.logRedeemed(_txid","contract":"DepositRedemption","time":0},{"type":"struct-data-arrangement ","before":"\nION\n        ITBTCSyste\nem;\n        TBTCTok\nen;\n        IERC721 tbtc\nen;\n        FeeRebateToken fe\nen;\n        address vendingMa\nss;\n        uint64 lot\nis;\n        uint8 \nte;\n        uint16 sign\nor;\n        uint16 initialCollatera\nnt;\n        uint16 undercollateralizedThre\nnt;\n        uint16 severelyUndercollateralizedThre\nnt;\n        uint256 \nAUD\n        uint256 liquidat\nrts\n        uint256 courtesyC\nued\n        address payable liquidat\neep\n        address\nact\n        uint256 signingGrou\nult\n        uint256 fundingPro\niod\n        bytes32 signing\nkey\n        bytes32 signing\nLOW\n        address payable red\nion\n        bytes redeemer\nipt\n        uint256 initialR\nted\n        uint256 latestR\nion\n        uint256 withdrawa\namp\n        bytes32 lastReq\nded\n        bytes8 u\nhis\n        uint\nved\n        bytes \nte.\n        mapping(address => uint256) withdraw\ning\n        mapping(bytes32 => uint256) app","after":"ION\n        ITBTCSyste\nem;\n        TBTCTok\nen;\n        IERC721 tbtc\nen;\n        FeeRebateToken fe\nnt;\n        uint256 \nAUD\n        uint256 liquidat\nrts\n        uint256 courtesyC\nact\n        uint256 signingGrou\nult\n        uint256 fundingPro\niod\n        bytes32 signing\nkey\n        bytes32 signing\nion\n        bytes redeemer\nipt\n        uint256 initialR\nted\n        uint256 latestR\nion\n        uint256 withdrawa\namp\n        bytes32 lastReq\nhis\n        uint\nved\n        bytes \nte.\n        mapping(address => uint256) withdraw\ning\n        mapping(bytes32 => uint256) app\nen;\n        address vendingMa\nued\n        address payable liquidat\neep\n        address\nLOW\n        address payable red\nss;\n        uint64 lot\nded\n        bytes8 u\nte;\n        uint16 sign\nor;\n        uint16 initialCollatera\nnt;\n        uint16 undercollateralizedThre\nnt;\n        uint16 severelyUndercollateralizedThre\nis;\n        uint8 \n","contract":"DepositUtils","time":280},{"type":"external-function ","before":"tpoint.\n    function validateAndParseFundingSPVProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public view returns (bytes8 _valueBytes, bytes memory _utxoOutpoint){\n        require(_txInputVector.validateVin(), \"invalid input vector provided\");\n        require(_txOutputVector.validateVout(), \"invalid output vector provided\");\n\n        bytes32 txID = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n\n        _valueBytes = findAndParseFundingOutput(_d, _txOutputVector, _fundingOutputIndex);\n\n        require(bytes8LEToUint(_valueBytes) >= _d.lotSizeSatoshis, \"Deposit too small\");\n\n        checkProofFromTxId(_d, txID, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        // The utxoOutpoint is the LE txID plus the index of the output as a 4-byte LE int\n        // _fundingOutputIndex is a uint8, so we know it is only 1 byte\n        // Therefore, pad with 3 more bytes\n        _utxoOutpoint = abi.encodePacked(txID, _fundingOutputIndex, hex\"000","after":"tpoint.\n    function validateAndParseFundingSPVProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public view returns (bytes8 _valueBytes, bytes memory _utxoOutpoint){\n        require(_txInputVector.validateVin(), \"invalid input vector provided\");\n        require(_txOutputVector.validateVout(), \"invalid output vector provided\");\n\n        bytes32 txID = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n\n        _valueBytes = findAndParseFundingOutput(_d, _txOutputVector, _fundingOutputIndex);\n\n        require(bytes8LEToUint(_valueBytes) >= _d.lotSizeSatoshis, \"Deposit too small\");\n\n        checkProofFromTxId(_d, txID, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        // The utxoOutpoint is the LE txID plus the index of the output as a 4-byte LE int\n        // _fundingOutputIndex is a uint8, so we know it is only 1 byte\n        // Therefore, pad with 3 more bytes\n        _utxoOutpoint = abi.encodePacked(txID, _fundingOutputIndex, hex\"000","contract":"DepositUtils","time":0},{"type":"state-data-arrangement ","before":"\nlector`\n    bytes4 private constant _ERC721_RECEIVED =\no owner\n    mapping(uint256 => address) private \naddress\n    mapping(uint256 => address) private _tok\nd token\n    mapping(address => Counters.Counter) private _owned\nprovals\n    mapping(address => mapping(address => bool)) private _operat\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 =","after":"o owner\n    mapping(uint256 => address) private \naddress\n    mapping(uint256 => address) private _tok\nd token\n    mapping(address => Counters.Counter) private _owned\nprovals\n    mapping(address => mapping(address => bool)) private _operat\nlector`\n    bytes4 private constant _ERC721_RECEIVED =\n     */\n    bytes4 private constant _INTERFACE_ID_ERC721 =\n","contract":"ERC721","time":0},{"type":"immutable-restrict-modification ","before":"en name\n    string pr","after":"en name\n    string pr","contract":"FeeRebateToken","time":1},{"type":"immutable-restrict-modification ","before":" symbol\n    string priv","after":" symbol\n    string priv","contract":"FeeRebateToken","time":1},{"type":"immutable-restrict-modification ","before":"       _txInputVector,\n         ","after":"       _txInputVector,\n         ","contract":"FeeRebateToken","time":1},{"type":"external-function ","before":"ke-based factory.\n    /// Once both fully-backed keep factory and factory selection strategy are\n    /// set, KEEP-stake-based factory is no longer the default choice and it is\n    /// up to the selection strategy to decide which factory should be chosen.\n    /// @dev Can be called only one time!\n    /// @param _factorySelector Address of the keep factory selection strategy.\n    function setKeepFactorySelector(\n        Storage storage _self,\n        address _factorySelector\n    ) internal {\n        require(\n            address(_self.factorySelector) == address(0),\n            \"Factory select","after":"ke-based factory.\n    /// Once both fully-backed keep factory and factory selection strategy are\n    /// set, KEEP-stake-based factory is no longer the default choice and it is\n    /// up to the selection strategy to decide which factory should be chosen.\n    /// @dev Can be called only one time!\n    /// @param _factorySelector Address of the keep factory selection strategy.\n    function setKeepFactorySelector(\n        Storage storage _self,\n        address _factorySelector\n    ) internal {\n        require(\n            address(_self.factorySelector) == address(0),\n            \"Factory select","contract":"OutsourceDepositLogging","time":0},{"type":"external-function ","before":"  uint256 _utxoSize,\n        bytes memory _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes memory _outpoint\n    ) public {// not external to allow bytes memory output scripts\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n  ","after":"  uint256 _utxoSize,\n        bytes calldata _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes memory _outpoint\n    ) public {// not external to allow bytes memory output scripts\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n  ","contract":"OutsourceDepositLogging","time":0},{"type":"immutable-restrict-modification ","before":"import {BytesLib} from \"@summa","after":"import {BytesLib} from \"@summa","contract":"Relay","time":0},{"type":"external-function ","before":" be transferred freely. tBTC's VendingMachine\n///         contract takes ownership of TDTs and in exchange returns fungible\n///         TBTC tokens whose value is backed 1-to-1 by the corresponding\n///         deposit's BTC.\n/// @dev Currently, TDTs are minted using","after":" be transferred freely. tBTC's VendingMachine\n///         contract takes ownership of TDTs and in exchange returns fungible\n///         TBTC tokens whose value is backed 1-to-1 by the corresponding\n///         deposit's BTC.\n/// @dev Currently, TDTs are minted using","contract":"TBTCDepositToken","time":0},{"type":"immutable-restrict-modification ","before":"en name\n    string pr","after":"en name\n    string pr","contract":"TBTCDepositToken","time":0},{"type":"immutable-restrict-modification ","before":" symbol\n    string priv","after":" symbol\n    string priv","contract":"TBTCDepositToken","time":0},{"type":"state-data-arrangement ","before":"\npositFactory} from \"../pro\npositFactory.sol\";\n\nimpo\nRelay} from \"@summa-tx/relay-sol/contracts\n.sol\";\nimport \"../external/IMedian\nsol\";\n\nimport {ITBTC\n} from \"../interfaces/ITBTCSystem.sol\";\nimport {IS\n;\nimport {DepositLog} from \"../Deposit\nol\";\n\nimport {TBTCDepositToken} from \".\nn.sol\";\nimport \"./FeeRebateToken.sol\";\nimport \"ope\nty/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin\nts/math/SafeMath.sol\";\nimport \"./KeepFactorySelection.sol\";\n\n/// \ntem.\n/// @notice This contract acts as a central point for access control,\n///         valu\nnable values should only affect new deposit crea\ncontract TBTCSystem is Ownable, ITBTCSystem, Dep\nog {\n\n    using SafeMath for uint256;\n  \nng KeepFactorySelection for KeepFactorySelection.Storage;\n\n\nvent EthBtcPriceFeedAdditionStarted(address _priceFee\nt256 _timestamp);\n    event LotSize\nteStarted(uint64[] _lotSizes,\n256 _timestamp);\n    event SignerFeeDivisorUpda\nrted(uint16 _signerFeeDivisor, uint256 _timestamp);\n  \nnt CollateralizationThresholdsUpdateStarted(\n        uint16 _i\nlCollateralizedPercent,\n        uin\nundercollateralizedThresholdPercent,\nyUndercollateralizedThresholdPercent,\n        u\n6 _timestamp\n    );\n    event KeepFactory\neShotUpdateStarted(\n        addr","after":"positFactory.sol\";\n\nimpo\nRelay} from \"@summa-tx/relay-sol/contracts\n.sol\";\nimport \"../external/IMedian\nsol\";\n\nimport {ITBTC\n} from \"../interfaces/ITBTCSystem.sol\";\nimport {IS\ntem.\n/// @notice This contract acts as a central point for access control,\n///         valu\nnable values should only affect new deposit crea\ncontract TBTCSystem is Ownable, ITBTCSystem, Dep\nog {\n\n    using SafeMath for uint256;\n  \nng KeepFactorySelection for KeepFactorySelection.Storage;\n\n\nvent EthBtcPriceFeedAdditionStarted(address _priceFee\nteStarted(uint64[] _lotSizes,\nyUndercollateralizedThresholdPercent,\n        u\n6 _timestamp\n    );\n    event KeepFactory\neShotUpdateStarted(\n        addr\nlCollateralizedPercent,\n        uin\nundercollateralizedThresholdPercent,\nol\";\n\nimport {TBTCDepositToken} from \".\nn.sol\";\nimport \"./FeeRebateToken.sol\";\nimport \"ope\nty/contracts/ownership/Ownable.sol\";\nimport \"openzeppelin\nts/math/SafeMath.sol\";\nimport \"./KeepFactorySelection.sol\";\n\n/// \nt256 _timestamp);\n    event LotSize\n256 _timestamp);\n    event SignerFeeDivisorUpda\nrted(uint16 _signerFeeDivisor, uint256 _timestamp);\n  \nnt CollateralizationThresholdsUpdateStarted(\n        uint16 _i\npositFactory} from \"../pro\n;\nimport {DepositLog} from \"../Deposit\n","contract":"TBTCSystem","time":34},{"type":"external-function ","before":"    function logRedemptionRequested(\n        address _requester,\n        bytes32 _digest,\n        uint256 _utxoSize,\n        bytes memory _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes memory _outpoint\n    ) public {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit RedemptionRequested(\n            msg.sender,\n            _requester,\n            _digest,\n            _utxoSize,\n            _redeemerOutputScript,\n            _requestedFee,\n            _outpoint\n        );\n ","after":"    function logRedemptionRequested(\n        address _requester,\n        bytes32 _digest,\n        uint256 _utxoSize,\n        bytes calldata _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes calldata _outpoint\n    ) public {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit RedemptionRequested(\n            msg.sender,\n            _requester,\n            _digest,\n            _utxoSize,\n            _redeemerOutputScript,\n            _requestedFee,\n            _outpoint\n        );\n ","contract":"TBTCSystem","time":0},{"type":"external-function ","before":"    function logFunderRequestedAbort(bytes memory _abortOutputScript) public {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit FunderAbortRequested(msg.sender, _abortOutputScript);\n ","after":"    function logFunderRequestedAbort(bytes calldata _abortOutputScript) public {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit FunderAbortRequested(msg.sender, _abortOutputScript);\n ","contract":"TBTCSystem","time":0},{"type":"constant-restrict-modification  ","before":"yUndercollateralizedThresholdPercent,\n        u","after":"yUndercollateralizedThresholdPercent,\n        u","contract":"TBTCSystem","time":0},{"type":"external-function ","before":"tor(address _VendingMachine)\n    ERC20Detailed(\"tBTC\", \"TBTC\", 18)\n    VendingMachineAuthority(_VendingMachine)\n    public {\n        // solium-disable-previous-line no-empty-blocks\n    }\n\n    /// @dev             Mints an amount of the token and assigns it to an account.\n    ///                  Uses the intern","after":"tor(address _VendingMachine)\n    ERC20Detailed(\"tBTC\", \"TBTC\", 18)\n    VendingMachineAuthority(_VendingMachine)\n    public {\n        // solium-disable-previous-line no-empty-blocks\n    }\n\n    /// @dev             Mints an amount of the token and assigns it to an account.\n    ///                  Uses the intern","contract":"TBTCToken","time":0},{"type":"immutable-restrict-modification ","before":"ERC20 {\n    string pr","after":"ERC20 {\n    string pr","contract":"TBTCToken","time":0},{"type":"immutable-restrict-modification ","before":" _name;\n    string priv","after":" _name;\n    string priv","contract":"TBTCToken","time":0},{"type":"immutable-restrict-modification ","before":"symbol;\n    uint8 privat","after":"symbol;\n    uint8 privat","contract":"TBTCToken","time":0},{"type":"immutable-restrict-modification ","before":"       _txInputVector,\n         ","after":"       _txInputVector,\n         ","contract":"TBTCToken","time":0},{"type":"external-function ","before":"function tbtcToTdt(uint256 _tdtId) public {\n        require(tbtcDepositToken.exists(_tdtId), \"tBTC Deposit Token does not exist\");\n        require(isQualified(address(_tdtId)), \"Deposit must be qualified\");\n\n        uint256 depositValue = Deposit(address(uint160(_tdtId))).lotSizeTbtc();\n        require(tbtcToken.balanceOf(msg.sender) >= depositValue, \"Not enough TBTC for TDT exchange\");\n        tbtcToken.burnFrom(msg.sender, depositValue);\n\n        // TODO do we need the owner check below? transferFrom can be approved for a user, which might be an interesting use case.\n        require(tbtcDepositToken.ownerOf(_tdtId) == address(this), \"Deposit is locked\");\n        tbtcDepositToken.transferFrom(address(this), msg.sender, _tdtId);\n    }\n\n    /// @notice Transfer the tBTC Deposit Token and mint TBTC.\n    /// @dev    Transfe","after":"function tbtcToTdt(uint256 _tdtId) public {\n        require(tbtcDepositToken.exists(_tdtId), \"tBTC Deposit Token does not exist\");\n        require(isQualified(address(_tdtId)), \"Deposit must be qualified\");\n\n        uint256 depositValue = Deposit(address(uint160(_tdtId))).lotSizeTbtc();\n        require(tbtcToken.balanceOf(msg.sender) >= depositValue, \"Not enough TBTC for TDT exchange\");\n        tbtcToken.burnFrom(msg.sender, depositValue);\n\n        // TODO do we need the owner check below? transferFrom can be approved for a user, which might be an interesting use case.\n        require(tbtcDepositToken.ownerOf(_tdtId) == address(this), \"Deposit is locked\");\n        tbtcDepositToken.transferFrom(address(this), msg.sender, _tdtId);\n    }\n\n    /// @notice Transfer the tBTC Deposit Token and mint TBTC.\n    /// @dev    Transfe","contract":"VendingMachine","time":0},{"type":"external-function ","before":"Fee();\n        uint256 depositValue = deposit.lotSizeTbtc();\n\n        if (tbtcToken.balanceOf(address(_tdtId)) < signerFee) {\n            tbtcToken.mint(msg.sender, depositValue.sub(signerFee));\n            tbtcToken.mint(address(_tdtId), signerFee);\n        }\n        else {\n            tbtcToken.mint(msg.sender, depositValue);\n        }\n\n        // owner of the TDT during first TBTC mint receives the FRT\n        if (!feeRebateToken.exists(_tdtId)) {\n            feeRebateToken.mint(msg.sender, _tdtId);\n        }\n    }\n\n    // WRAPPERS\n\n    /// @notice Qualifies a deposit and mints TBTC.\n    /// @dev User must allow VendingManchine to transfer TDT.\n    function unqualifiedDepositToTbtc(\n        address payable _depositAddress,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,","after":"Fee();\n        uint256 depositValue = deposit.lotSizeTbtc();\n\n        if (tbtcToken.balanceOf(address(_tdtId)) < signerFee) {\n            tbtcToken.mint(msg.sender, depositValue.sub(signerFee));\n            tbtcToken.mint(address(_tdtId), signerFee);\n        }\n        else {\n            tbtcToken.mint(msg.sender, depositValue);\n        }\n\n        // owner of the TDT during first TBTC mint receives the FRT\n        if (!feeRebateToken.exists(_tdtId)) {\n            feeRebateToken.mint(msg.sender, _tdtId);\n        }\n    }\n\n    // WRAPPERS\n\n    /// @notice Qualifies a deposit and mints TBTC.\n    /// @dev User must allow VendingManchine to transfer TDT.\n    function unqualifiedDepositToTbtc(\n        address payable _depositAddress,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,","contract":"VendingMachine","time":0},{"type":"immutable-restrict-modification ","before":"c pure returns (uint256) {\n        ","after":"c pure returns (uint256) {\n        ","contract":"VendingMachine","time":0}]}