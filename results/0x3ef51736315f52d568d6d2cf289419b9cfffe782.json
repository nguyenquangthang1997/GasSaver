{"time":228,"results":[{"type":"constant-restrict-modification  ","before":"   bytes32 private immutable _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)","after":"   bytes32 private immutable constant _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)","contract":"ERC20Permit","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC20Permit","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC20Permit","time":0},{"type":"external-function ","before":"\n\n    function remainingsRaw(bytes32[] memory orderHashes) external view returns (uint256[] memory results) {\n\n        results = new uint256[](orderHashes.length);\n\n        for (uint i = 0; i < orderHashes.length; i++) {\n\n            results[i] = _remaining[orderHashes[i]];\n\n        }\n","after":"\n\n    function remainingsRaw(bytes32[] calldata orderHashes) external view returns (uint256[] memory results) {\n\n        results = new uint256[](orderHashes.length);\n\n        for (uint i = 0; i < orderHashes.length; i++) {\n\n            results[i] = _remaining[orderHashes[i]];\n\n        }\n","contract":"LimitOrderProtocol","time":0},{"type":"external-function ","before":"\n\n    function cancelOrder(Order memory order) external {\n\n        require(order.makerAssetData.decodeAddress(_FROM_INDEX) == msg.sender, \"LOP: Access denied\");\n\n\n        bytes32 orderHash = _hash(order);\n\n        _remaining[orderHash] = 1;\n\n        emit OrderFilled(msg.sender, orderHash, 0);\n","after":"\n\n    function cancelOrder(Order calldata order) external {\n\n        require(order.makerAssetData.decodeAddress(_FROM_INDEX) == msg.sender, \"LOP: Access denied\");\n\n\n        bytes32 orderHash = _hash(order);\n\n        _remaining[orderHash] = 1;\n\n        emit OrderFilled(msg.sender, orderHash, 0);\n","contract":"LimitOrderProtocol","time":0},{"type":"external-function ","before":"\n\n    function fillOrderRFQ(OrderRFQ memory order, bytes memory signature, uint256 makingAmount, uint256 takingAmount) external {\n\n        // Check time expiration\n\n        uint256 expiration = uint128(order.info) >> 64;\n\n        require(expiration == 0 || block.timestamp <= expiration, \"LOP: order expired\");\n        // solhint-disable-line not-rely-on-time\n\n\n\n        // Validate double spend\n\n        address maker = order.makerAssetData.decodeAddress(_FROM_INDEX);\n\n        uint256 invalidatorSlot = uint64(order.info) >> 8;\n\n        uint256 invalidatorBit = 1 << uint8(order.info);\n\n        uint256 invalidator = _invalidator[maker][invalidatorSlot];\n\n        require(invalidator & invalidatorBit == 0, \"LOP: already filled\");\n\n        _invalidator[maker][invalidatorSlot] = invalidator | invalidatorBit;\n\n\n        // Compute partial fill if needed\n\n        uint256 orderMakerAmount = order.makerAssetData.decodeUint256(_AMOUNT_INDEX);\n\n        uint256 orderTakerAmount = order.takerAssetData.decodeUint256(_AMOUNT_INDEX);\n\n        if (takingAmount == 0 && makingAmount == 0) {\n\n            // Two zeros means whole order\n\n            makingAmount = orderMakerAmount;\n\n            takingAmount = orderTakerAmount;\n\n        }\n\n        else if (takingAmount == 0) {\n\n            takingAmount = (makingAmount * orderTakerAmount + orderMakerAmount - 1) / orderMakerAmount;\n\n        }\n\n        else if (makingAmount == 0) {\n\n            makingAmount = takingAmount * orderMakerAmount / orderTakerAmount;\n\n        }\n\n        else {\n\n            revert(\"LOP: one of amounts should be 0\");\n\n        }\n\n\n        require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n\n        require(makingAmount <= orderMakerAmount, \"LOP: making amount exceeded\");\n\n        require(takingAmount <= orderTakerAmount, \"LOP: taking amount exceeded\");\n\n\n        // Validate order\n\n        bytes32 orderHash = _hash(order);\n\n        _validate(order.makerAssetData, order.takerAssetData, signature, orderHash);\n\n\n        // Maker => Taker, Taker => Maker\n\n        _callMakerAssetTransferFrom(order.makerAsset, order.makerAssetData, msg.sender, makingAmount);\n\n        _callTakerAssetTransferFrom(order.takerAsset, order.takerAssetData, msg.sender, takingAmount);\n\n\n        emit OrderFilledRFQ(orderHash, makingAmount);\n","after":"\n\n    function fillOrderRFQ(OrderRFQ calldata order, bytes calldata signature, uint256 makingAmount, uint256 takingAmount) external {\n\n        // Check time expiration\n\n        uint256 expiration = uint128(order.info) >> 64;\n\n        require(expiration == 0 || block.timestamp <= expiration, \"LOP: order expired\");\n        // solhint-disable-line not-rely-on-time\n\n\n\n        // Validate double spend\n\n        address maker = order.makerAssetData.decodeAddress(_FROM_INDEX);\n\n        uint256 invalidatorSlot = uint64(order.info) >> 8;\n\n        uint256 invalidatorBit = 1 << uint8(order.info);\n\n        uint256 invalidator = _invalidator[maker][invalidatorSlot];\n\n        require(invalidator & invalidatorBit == 0, \"LOP: already filled\");\n\n        _invalidator[maker][invalidatorSlot] = invalidator | invalidatorBit;\n\n\n        // Compute partial fill if needed\n\n        uint256 orderMakerAmount = order.makerAssetData.decodeUint256(_AMOUNT_INDEX);\n\n        uint256 orderTakerAmount = order.takerAssetData.decodeUint256(_AMOUNT_INDEX);\n\n        if (takingAmount == 0 && makingAmount == 0) {\n\n            // Two zeros means whole order\n\n            makingAmount = orderMakerAmount;\n\n            takingAmount = orderTakerAmount;\n\n        }\n\n        else if (takingAmount == 0) {\n\n            takingAmount = (makingAmount * orderTakerAmount + orderMakerAmount - 1) / orderMakerAmount;\n\n        }\n\n        else if (makingAmount == 0) {\n\n            makingAmount = takingAmount * orderMakerAmount / orderTakerAmount;\n\n        }\n\n        else {\n\n            revert(\"LOP: one of amounts should be 0\");\n\n        }\n\n\n        require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n\n        require(makingAmount <= orderMakerAmount, \"LOP: making amount exceeded\");\n\n        require(takingAmount <= orderTakerAmount, \"LOP: taking amount exceeded\");\n\n\n        // Validate order\n\n        bytes32 orderHash = _hash(order);\n\n        _validate(order.makerAssetData, order.takerAssetData, signature, orderHash);\n\n\n        // Maker => Taker, Taker => Maker\n\n        _callMakerAssetTransferFrom(order.makerAsset, order.makerAssetData, msg.sender, makingAmount);\n\n        _callTakerAssetTransferFrom(order.takerAsset, order.takerAssetData, msg.sender, takingAmount);\n\n\n        emit OrderFilledRFQ(orderHash, makingAmount);\n","contract":"LimitOrderProtocol","time":0},{"type":"external-function ","before":"\n\n    function fillOrder(Order memory order, bytes calldata signature, uint256 makingAmount, uint256 takingAmount, uint256 thresholdAmount) external returns (uint256, uint256) {\n\n        bytes32 orderHash = _hash(order);\n\n\n        uint256 remainingMakerAmount;\n\n        {// Stack too deep\n\n            bool orderExists;\n\n            (orderExists, remainingMakerAmount) = _remaining[orderHash].trySub(1);\n\n            if (!orderExists) {\n\n                // First fill: validate order and permit maker asset\n\n                _validate(order.makerAssetData, order.takerAssetData, signature, orderHash);\n\n                remainingMakerAmount = order.makerAssetData.decodeUint256(_AMOUNT_INDEX);\n\n                if (order.permit.length > 0) {\n\n                    (address token, bytes memory permit) = abi.decode(order.permit, (address, bytes));\n\n                    token.uncheckedFunctionCall(abi.encodePacked(IERC20Permit.permit.selector, permit), \"LOP: permit failed\");\n\n                    require(_remaining[orderHash] == 0, \"LOP: reentrancy detected\");\n\n                }\n\n            }\n\n        }\n\n\n        // Check if order is valid\n\n        if (order.predicate.length > 0) {\n\n            require(checkPredicate(order), \"LOP: predicate returned false\");\n\n        }\n\n\n        // Compute maker and taker assets amount\n\n        if ((takingAmount == 0) == (makingAmount == 0)) {\n\n            revert(\"LOP: only one amount should be 0\");\n\n        }\n\n        else if (takingAmount == 0) {\n\n            takingAmount = _callGetTakerAmount(order, makingAmount);\n\n            require(takingAmount <= thresholdAmount, \"LOP: taking amount too high\");\n\n        }\n\n        else {\n\n            makingAmount = _callGetMakerAmount(order, takingAmount);\n\n            require(makingAmount >= thresholdAmount, \"LOP: making amount too low\");\n\n        }\n\n\n        require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n\n\n        // Update remaining amount in storage\n\n        remainingMakerAmount = remainingMakerAmount.sub(makingAmount, \"LOP: taking > remaining\");\n\n        _remaining[orderHash] = remainingMakerAmount + 1;\n\n        emit OrderFilled(msg.sender, orderHash, remainingMakerAmount);\n\n\n        // Taker => Maker\n\n        _callTakerAssetTransferFrom(order.takerAsset, order.takerAssetData, msg.sender, takingAmount);\n\n\n        // Maker can handle funds interactively\n\n        if (order.interaction.length > 0) {\n\n            InteractiveMaker(order.makerAssetData.decodeAddress(_FROM_INDEX))\n\n            .notifyFillOrder(order.makerAsset, order.takerAsset, makingAmount, takingAmount, order.interaction);\n\n        }\n\n\n        // Maker => Taker\n\n        _callMakerAssetTransferFrom(order.makerAsset, order.makerAssetData, msg.sender, makingAmount);\n\n\n        return (makingAmount, takingAmount);\n","after":"\n\n    function fillOrder(Order calldata order, bytes calldata signature, uint256 makingAmount, uint256 takingAmount, uint256 thresholdAmount) external returns (uint256, uint256) {\n\n        bytes32 orderHash = _hash(order);\n\n\n        uint256 remainingMakerAmount;\n\n        {// Stack too deep\n\n            bool orderExists;\n\n            (orderExists, remainingMakerAmount) = _remaining[orderHash].trySub(1);\n\n            if (!orderExists) {\n\n                // First fill: validate order and permit maker asset\n\n                _validate(order.makerAssetData, order.takerAssetData, signature, orderHash);\n\n                remainingMakerAmount = order.makerAssetData.decodeUint256(_AMOUNT_INDEX);\n\n                if (order.permit.length > 0) {\n\n                    (address token, bytes memory permit) = abi.decode(order.permit, (address, bytes));\n\n                    token.uncheckedFunctionCall(abi.encodePacked(IERC20Permit.permit.selector, permit), \"LOP: permit failed\");\n\n                    require(_remaining[orderHash] == 0, \"LOP: reentrancy detected\");\n\n                }\n\n            }\n\n        }\n\n\n        // Check if order is valid\n\n        if (order.predicate.length > 0) {\n\n            require(checkPredicate(order), \"LOP: predicate returned false\");\n\n        }\n\n\n        // Compute maker and taker assets amount\n\n        if ((takingAmount == 0) == (makingAmount == 0)) {\n\n            revert(\"LOP: only one amount should be 0\");\n\n        }\n\n        else if (takingAmount == 0) {\n\n            takingAmount = _callGetTakerAmount(order, makingAmount);\n\n            require(takingAmount <= thresholdAmount, \"LOP: taking amount too high\");\n\n        }\n\n        else {\n\n            makingAmount = _callGetMakerAmount(order, takingAmount);\n\n            require(makingAmount >= thresholdAmount, \"LOP: making amount too low\");\n\n        }\n\n\n        require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n\n\n        // Update remaining amount in storage\n\n        remainingMakerAmount = remainingMakerAmount.sub(makingAmount, \"LOP: taking > remaining\");\n\n        _remaining[orderHash] = remainingMakerAmount + 1;\n\n        emit OrderFilled(msg.sender, orderHash, remainingMakerAmount);\n\n\n        // Taker => Maker\n\n        _callTakerAssetTransferFrom(order.takerAsset, order.takerAssetData, msg.sender, takingAmount);\n\n\n        // Maker can handle funds interactively\n\n        if (order.interaction.length > 0) {\n\n            InteractiveMaker(order.makerAssetData.decodeAddress(_FROM_INDEX))\n\n            .notifyFillOrder(order.makerAsset, order.takerAsset, makingAmount, takingAmount, order.interaction);\n\n        }\n\n\n        // Maker => Taker\n\n        _callMakerAssetTransferFrom(order.makerAsset, order.makerAssetData, msg.sender, makingAmount);\n\n\n        return (makingAmount, takingAmount);\n","contract":"LimitOrderProtocol","time":0},{"type":"external-function ","before":"   function arbitraryStaticCall(address target, bytes memory data) external view returns (uint256) {\n\n        (bytes memory result) = target.uncheckedFunctionStaticCall(data, \"AC: arbitraryStaticCall\");\n\n        return abi.decode(result, (uint256));\n\n  ","after":"   function arbitraryStaticCall(address target, bytes calldata data) external view returns (uint256) {\n\n        (bytes memory result) = target.uncheckedFunctionStaticCall(data, \"AC: arbitraryStaticCall\");\n\n        return abi.decode(result, (uint256));\n\n  ","contract":"LimitOrderProtocol","time":0},{"type":"external-function ","before":"   function eq(uint256 value, address target, bytes memory data) external view returns (bool) {\n\n        bytes memory result = target.uncheckedFunctionStaticCall(data, \"PH: eq\");\n\n        require(result.length == 32, \"PH: invalid call result\");\n\n        return abi.decode(result, (uint256)) == value;\n\n  ","after":"   function eq(uint256 value, address target, bytes calldata data) external view returns (bool) {\n\n        bytes memory result = target.uncheckedFunctionStaticCall(data, \"PH: eq\");\n\n        require(result.length == 32, \"PH: invalid call result\");\n\n        return abi.decode(result, (uint256)) == value;\n\n  ","contract":"LimitOrderProtocol","time":0},{"type":"external-function ","before":"   function lt(uint256 value, address target, bytes memory data) external view returns (bool) {\n\n        bytes memory result = target.uncheckedFunctionStaticCall(data, \"PH: lt\");\n\n        require(result.length == 32, \"PH: invalid call result\");\n\n        return abi.decode(result, (uint256)) < value;\n\n  ","after":"   function lt(uint256 value, address target, bytes calldata data) external view returns (bool) {\n\n        bytes memory result = target.uncheckedFunctionStaticCall(data, \"PH: lt\");\n\n        require(result.length == 32, \"PH: invalid call result\");\n\n        return abi.decode(result, (uint256)) < value;\n\n  ","contract":"LimitOrderProtocol","time":0},{"type":"external-function ","before":"   function gt(uint256 value, address target, bytes memory data) external view returns (bool) {\n\n        bytes memory result = target.uncheckedFunctionStaticCall(data, \"PH: gt\");\n\n        require(result.length == 32, \"PH: invalid call result\");\n\n        return abi.decode(result, (uint256)) > value;\n\n  ","after":"   function gt(uint256 value, address target, bytes calldata data) external view returns (bool) {\n\n        bytes memory result = target.uncheckedFunctionStaticCall(data, \"PH: gt\");\n\n        require(result.length == 32, \"PH: invalid call result\");\n\n        return abi.decode(result, (uint256)) > value;\n\n  ","contract":"LimitOrderProtocol","time":0},{"type":"constant-restrict-modification  ","before":"\n\n    bytes4 immutable private _MAX_SELECTOR = bytes4(uint32(IERC20.transferFrom.selector) ","after":"\n\n    bytes4 immutable private constant _MAX_SELECTOR = bytes4(uint32(IERC20.transferFrom.selector) ","contract":"LimitOrderProtocol","time":0}]}