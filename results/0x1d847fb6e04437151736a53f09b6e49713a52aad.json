{"time":1020,"results":[{"type":"loop-duplication","before":"\nstart line 128 column 8, end line 132 column 8\nfor (uint256 i = 0; i < whitelistIndices.length; i++) {\n            if (whitelist[whitelistIndices[i]] == Status.In) {\n                activeCount++;\n            }\n        }\nstart line 137 column 8, end line 143 column 8\nfor (uint256 i = 0; i < whitelistIndices.length; i++) {\n            address addr = whitelistIndices[i];\n            if (whitelist[addr] == Status.In) {\n                activeWhitelist[activeCount] = addr;\n                activeCount++;\n            }\n        }","after":"// merge loop\n\nstart line 128 column 8, end line 132 column 8\nfor (uint256 i = 0; i < whitelistIndices.length; i++) {\n            if (whitelist[whitelistIndices[i]] == Status.In) {\n                activeCount++;\n            }\n        }\nstart line 137 column 8, end line 143 column 8\nfor (uint256 i = 0; i < whitelistIndices.length; i++) {\n            address addr = whitelistIndices[i];\n            if (whitelist[addr] == Status.In) {\n                activeWhitelist[activeCount] = addr;\n                activeCount++;\n            }\n        }","contract":"AddressWhitelist","time":0},{"type":"external-function ","before":"function deposit(FixedPoint.Unsigned memory collateralAmount) public isInitialized() fees() nonReentrant() {\n        require(collateralAmount.isGreaterThan(0), \"Invalid collateral amount\");\n        DepositBoxData storage depositBoxData = depositBoxes[msg.sender];\n        if (_getFeeAdjustedCollateral(depositBoxData.rawCollateral).isEqual(0)) {\n            emit NewDepositBox(msg.sender);\n        }\n\n        // Increase the individual deposit box and global collateral balance by collateral amount.\n        _incrementCollateralBalances(depositBoxData, collateralAmount);\n\n        emit Deposit(msg.sender, collateralAmount.rawValue);\n\n        // Move collateral currency from sender to contract.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n    }","after":"function deposit(FixedPoint.Unsigned calldata collateralAmount) public isInitialized() fees() nonReentrant() {\n        require(collateralAmount.isGreaterThan(0), \"Invalid collateral amount\");\n        DepositBoxData storage depositBoxData = depositBoxes[msg.sender];\n        if (_getFeeAdjustedCollateral(depositBoxData.rawCollateral).isEqual(0)) {\n            emit NewDepositBox(msg.sender);\n        }\n\n        // Increase the individual deposit box and global collateral balance by collateral amount.\n        _incrementCollateralBalances(depositBoxData, collateralAmount);\n\n        emit Deposit(msg.sender, collateralAmount.rawValue);\n\n        // Move collateral currency from sender to contract.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n    }","contract":"DepositBox","time":0},{"type":"external-function ","before":"function requestWithdrawal(FixedPoint.Unsigned memory denominatedCollateralAmount)\n    public\n    isInitialized()\n    noPendingWithdrawal(msg.sender)\n    nonReentrant()\n    {\n        DepositBoxData storage depositBoxData = depositBoxes[msg.sender];\n        require(denominatedCollateralAmount.isGreaterThan(0), \"Invalid collateral amount\");\n\n        // Update the position object for the user.\n        depositBoxData.withdrawalRequestAmount = denominatedCollateralAmount;\n        depositBoxData.requestPassTimestamp = getCurrentTime();\n\n        emit RequestWithdrawal(msg.sender, denominatedCollateralAmount.rawValue, depositBoxData.requestPassTimestamp);\n\n        // Every price request costs a fixed fee. Check that this user has enough deposited to cover the final fee.\n        FixedPoint.Unsigned memory finalFee = _computeFinalFees();\n        require(\n            _getFeeAdjustedCollateral(depositBoxData.rawCollateral).isGreaterThanOrEqual(finalFee),\n            \"Cannot pay final fee\"\n        );\n        _payFinalFees(address(this), finalFee);\n        // A price request is sent for the current timestamp.\n        _requestOraclePrice(depositBoxData.requestPassTimestamp);\n    }","after":"function requestWithdrawal(FixedPoint.Unsigned calldata denominatedCollateralAmount)\n    public\n    isInitialized()\n    noPendingWithdrawal(msg.sender)\n    nonReentrant()\n    {\n        DepositBoxData storage depositBoxData = depositBoxes[msg.sender];\n        require(denominatedCollateralAmount.isGreaterThan(0), \"Invalid collateral amount\");\n\n        // Update the position object for the user.\n        depositBoxData.withdrawalRequestAmount = denominatedCollateralAmount;\n        depositBoxData.requestPassTimestamp = getCurrentTime();\n\n        emit RequestWithdrawal(msg.sender, denominatedCollateralAmount.rawValue, depositBoxData.requestPassTimestamp);\n\n        // Every price request costs a fixed fee. Check that this user has enough deposited to cover the final fee.\n        FixedPoint.Unsigned memory finalFee = _computeFinalFees();\n        require(\n            _getFeeAdjustedCollateral(depositBoxData.rawCollateral).isGreaterThanOrEqual(finalFee),\n            \"Cannot pay final fee\"\n        );\n        _payFinalFees(address(this), finalFee);\n        // A price request is sent for the current timestamp.\n        _requestOraclePrice(depositBoxData.requestPassTimestamp);\n    }","contract":"DepositBox","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 private priceIdentifier;","after":"bytes32 private immutable priceIdentifier;","contract":"DepositBox","time":1},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"DepositBox","time":1},{"type":"immutable-restrict-modification ","before":"address internal finderAddress;","after":"address internal immutable finderAddress;","contract":"DepositBox","time":1},{"type":"external-function ","before":"function retrieveRewards(uint256 roundId, VotingInterface.PendingRequest[] memory toRetrieve)\n    public\n    onlyRoleHolder(uint256(Roles.Voter))\n    returns (FixedPoint.Unsigned memory)\n    {\n        return _getVotingAddress().retrieveRewards(address(this), roundId, toRetrieve);\n    }","after":"function retrieveRewards(uint256 roundId, VotingInterface.PendingRequest[] calldata toRetrieve)\n    public\n    onlyRoleHolder(uint256(Roles.Voter))\n    returns (FixedPoint.Unsigned memory)\n    {\n        return _getVotingAddress().retrieveRewards(address(this), roundId, toRetrieve);\n    }","contract":"DesignatedVoting","time":0},{"type":"immutable-restrict-modification ","before":"address private finder;","after":"address private immutable finder;","contract":"DesignatedVotingFactory","time":0},{"type":"external-function ","before":"   function deposit(FixedPoint.Unsigned memory collateralAmount) public {\n        // This is just a thin wrapper over depositTo that specified the sender as the sponsor.\n        depositTo(msg.sender, collateralAmount);\n  ","after":"   function deposit(FixedPoint.Unsigned calldata collateralAmount) public {\n        // This is just a thin wrapper over depositTo that specified the sender as the sponsor.\n        depositTo(msg.sender, collateralAmount);\n  ","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"   function withdraw(FixedPoint.Unsigned memory collateralAmount)\n    public\n    onlyPreExpiration()\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(collateralAmount.isGreaterThan(0), \"Invalid collateral amount\");\n\n        // Decrement the sponsor's collateral and global collateral amounts. Check the GCR between decrement to ensure\n        // position remains above the GCR within the witdrawl. If this is not the case the caller must submit a request.\n        amountWithdrawn = _decrementCollateralBalancesCheckGCR(positionData, collateralAmount);\n\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n\n        // Move collateral currency from contract to sender.\n        // Note: that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n        // instead of the user requested amount. This eliminates precision loss that could occur\n        // where the user withdraws more collateral than rawCollateral is decremented by.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n  ","after":"   function withdraw(FixedPoint.Unsigned calldata collateralAmount)\n    public\n    onlyPreExpiration()\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(collateralAmount.isGreaterThan(0), \"Invalid collateral amount\");\n\n        // Decrement the sponsor's collateral and global collateral amounts. Check the GCR between decrement to ensure\n        // position remains above the GCR within the witdrawl. If this is not the case the caller must submit a request.\n        amountWithdrawn = _decrementCollateralBalancesCheckGCR(positionData, collateralAmount);\n\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n\n        // Move collateral currency from contract to sender.\n        // Note: that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n        // instead of the user requested amount. This eliminates precision loss that could occur\n        // where the user withdraws more collateral than rawCollateral is decremented by.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n  ","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"   function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\n    public\n    onlyPreExpiration()\n    noPendingWithdrawal(msg.sender)\n    nonReentrant()\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(\n            collateralAmount.isGreaterThan(0) &&\n            collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral)),\n            \"Invalid collateral amount\"\n        );\n\n        // Make sure the proposed expiration of this request is not post-expiry.\n        uint256 requestPassTime = getCurrentTime().add(withdrawalLiveness);\n        require(requestPassTime < expirationTimestamp, \"Request expires post-expiry\");\n\n        // Update the position object for the user.\n        positionData.withdrawalRequestPassTimestamp = requestPassTime;\n        positionData.withdrawalRequestAmount = collateralAmount;\n\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n  ","after":"   function requestWithdrawal(FixedPoint.Unsigned calldata collateralAmount)\n    public\n    onlyPreExpiration()\n    noPendingWithdrawal(msg.sender)\n    nonReentrant()\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(\n            collateralAmount.isGreaterThan(0) &&\n            collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral)),\n            \"Invalid collateral amount\"\n        );\n\n        // Make sure the proposed expiration of this request is not post-expiry.\n        uint256 requestPassTime = getCurrentTime().add(withdrawalLiveness);\n        require(requestPassTime < expirationTimestamp, \"Request expires post-expiry\");\n\n        // Update the position object for the user.\n        positionData.withdrawalRequestPassTimestamp = requestPassTime;\n        positionData.withdrawalRequestAmount = collateralAmount;\n\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n  ","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"   function create(FixedPoint.Unsigned memory collateralAmount, FixedPoint.Unsigned memory numTokens)\n    public\n    onlyPreExpiration()\n    fees()\n    nonReentrant()\n    {\n        PositionData storage positionData = positions[msg.sender];\n\n        // Either the new create ratio or the resultant position CR must be above the current GCR.\n        require(\n            (_checkCollateralization(\n            _getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),\n            positionData.tokensOutstanding.add(numTokens)\n        ) || _checkCollateralization(collateralAmount, numTokens)),\n            \"Insufficient collateral\"\n        );\n\n        require(positionData.withdrawalRequestPassTimestamp == 0, \"Pending withdrawal\");\n        if (positionData.tokensOutstanding.isEqual(0)) {\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\n            emit NewSponsor(msg.sender);\n        }\n\n        // Increase the position and global collateral balance by collateral amount.\n        _incrementCollateralBalances(positionData, collateralAmount);\n\n        // Add the number of tokens created to the position's outstanding tokens.\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n\n        // Transfer tokens into the contract from caller and mint corresponding synthetic tokens to the caller's address.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue), \"Minting synthetic tokens failed\");\n  ","after":"   function create(FixedPoint.Unsigned calldata collateralAmount, FixedPoint.Unsigned calldata numTokens)\n    public\n    onlyPreExpiration()\n    fees()\n    nonReentrant()\n    {\n        PositionData storage positionData = positions[msg.sender];\n\n        // Either the new create ratio or the resultant position CR must be above the current GCR.\n        require(\n            (_checkCollateralization(\n            _getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),\n            positionData.tokensOutstanding.add(numTokens)\n        ) || _checkCollateralization(collateralAmount, numTokens)),\n            \"Insufficient collateral\"\n        );\n\n        require(positionData.withdrawalRequestPassTimestamp == 0, \"Pending withdrawal\");\n        if (positionData.tokensOutstanding.isEqual(0)) {\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\n            emit NewSponsor(msg.sender);\n        }\n\n        // Increase the position and global collateral balance by collateral amount.\n        _incrementCollateralBalances(positionData, collateralAmount);\n\n        // Add the number of tokens created to the position's outstanding tokens.\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n\n        // Transfer tokens into the contract from caller and mint corresponding synthetic tokens to the caller's address.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue), \"Minting synthetic tokens failed\");\n  ","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"   function redeem(FixedPoint.Unsigned memory numTokens)\n    public\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(!numTokens.isGreaterThan(positionData.tokensOutstanding), \"Invalid token amount\");\n\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n        FixedPoint.Unsigned memory collateralRedeemed = fractionRedeemed.mul(\n            _getFeeAdjustedCollateral(positionData.rawCollateral)\n        );\n\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n        } else {\n            // Decrement the sponsor's collateral and global collateral amounts.\n            amountWithdrawn = _decrementCollateralBalances(positionData, collateralRedeemed);\n\n            // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\n            positionData.tokensOutstanding = newTokenCount;\n\n            // Update the totalTokensOutstanding after redemption.\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n        }\n\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n  ","after":"   function redeem(FixedPoint.Unsigned calldata numTokens)\n    public\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(!numTokens.isGreaterThan(positionData.tokensOutstanding), \"Invalid token amount\");\n\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n        FixedPoint.Unsigned memory collateralRedeemed = fractionRedeemed.mul(\n            _getFeeAdjustedCollateral(positionData.rawCollateral)\n        );\n\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n        } else {\n            // Decrement the sponsor's collateral and global collateral amounts.\n            amountWithdrawn = _decrementCollateralBalances(positionData, collateralRedeemed);\n\n            // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\n            positionData.tokensOutstanding = newTokenCount;\n\n            // Update the totalTokensOutstanding after redemption.\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n        }\n\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n  ","contract":"ExpiringMultiParty","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public liquidationLivene","after":"   uint256 public liquidationLivene","contract":"ExpiringMultiParty","time":1},{"type":"immutable-restrict-modification ","before":"   bytes32 public priceIdentifi","after":"   bytes32 public priceIdentifi","contract":"ExpiringMultiParty","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 public withdrawalLivene","after":"   uint256 public withdrawalLivene","contract":"ExpiringMultiParty","time":1},{"type":"immutable-restrict-modification ","before":"   address public excessTokenBeneficia","after":"   address public excessTokenBeneficia","contract":"ExpiringMultiParty","time":1},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"ExpiringMultiParty","time":1},{"type":"external-function ","before":"   function createExpiringMultiParty(Params memory params) public nonReentrant() returns (address) {\n        address derivative = ExpiringMultiPartyLib.deploy(_convertParams(params));\n\n        _registerContract(new address[](0), address(derivative));\n\n        emit CreatedExpiringMultiParty(address(derivative), msg.sender);\n\n        return address(derivative);\n  ","after":"   function createExpiringMultiParty(Params calldata params) public nonReentrant() returns (address) {\n        address derivative = ExpiringMultiPartyLib.deploy(_convertParams(params));\n\n        _registerContract(new address[](0), address(derivative));\n\n        emit CreatedExpiringMultiParty(address(derivative), msg.sender);\n\n        return address(derivative);\n  ","contract":"ExpiringMultiPartyCreator","time":0},{"type":"immutable-restrict-modification ","before":"   address public tokenFactoryAddre","after":"   address public tokenFactoryAddre","contract":"ExpiringMultiPartyCreator","time":0},{"type":"immutable-restrict-modification ","before":"address internal finderAddress;","after":"address internal immutable finderAddress;","contract":"ExpiringMultiPartyCreator","time":0},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"ExpiringMultiPartyCreator","time":0},{"type":"external-function ","before":"   function deploy(ExpiringMultiParty.ConstructorParams memory params) public returns (address) {\n        ExpiringMultiParty derivative = new ExpiringMultiParty(params);\n        return address(derivative);\n  ","after":"   function deploy(ExpiringMultiParty.ConstructorParams calldata params) public returns (address) {\n        ExpiringMultiParty derivative = new ExpiringMultiParty(params);\n        return address(derivative);\n  ","contract":"ExpiringMultiPartyLib","time":0},{"type":"external-function ","before":"   function propose(Transaction[] memory transactions) public onlyRoleHolder(uint256(Roles.Proposer)) {\n        uint256 id = proposals.length;\n        uint256 time = getCurrentTime();\n\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\n\n        // Add a zero-initialized element to the proposals array.\n        proposals.push();\n\n        // Initialize the new proposal.\n        Proposal storage proposal = proposals[id];\n        proposal.requestTime = time;\n\n        // Initialize the transaction array.\n        for (uint256 i = 0; i < transactions.length; i++) {\n            require(transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\n            if (transactions[i].data.length > 0) {\n                require(transactions[i].to.isContract(), \"EOA can't accept tx with data\");\n            }\n            proposal.transactions.push(transactions[i]);\n        }\n\n        bytes32 identifier = _constructIdentifier(id);\n\n        // Request a vote on this proposal in the DVM.\n        OracleInterface oracle = _getOracle();\n        IdentifierWhitelistInterface supportedIdentifiers = _getIdentifierWhitelist();\n        supportedIdentifiers.addSupportedIdentifier(identifier);\n\n        oracle.requestPrice(identifier, time);\n        supportedIdentifiers.removeSupportedIdentifier(identifier);\n\n        emit NewProposal(id, transactions);\n  ","after":"   function propose(Transaction[] calldata transactions) public onlyRoleHolder(uint256(Roles.Proposer)) {\n        uint256 id = proposals.length;\n        uint256 time = getCurrentTime();\n\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\n\n        // Add a zero-initialized element to the proposals array.\n        proposals.push();\n\n        // Initialize the new proposal.\n        Proposal storage proposal = proposals[id];\n        proposal.requestTime = time;\n\n        // Initialize the transaction array.\n        for (uint256 i = 0; i < transactions.length; i++) {\n            require(transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\n            if (transactions[i].data.length > 0) {\n                require(transactions[i].to.isContract(), \"EOA can't accept tx with data\");\n            }\n            proposal.transactions.push(transactions[i]);\n        }\n\n        bytes32 identifier = _constructIdentifier(id);\n\n        // Request a vote on this proposal in the DVM.\n        OracleInterface oracle = _getOracle();\n        IdentifierWhitelistInterface supportedIdentifiers = _getIdentifierWhitelist();\n        supportedIdentifiers.addSupportedIdentifier(identifier);\n\n        oracle.requestPrice(identifier, time);\n        supportedIdentifiers.removeSupportedIdentifier(identifier);\n\n        emit NewProposal(id, transactions);\n  ","contract":"GovernorTest","time":0},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"GovernorTest","time":0},{"type":"immutable-restrict-modification ","before":"   address public own","after":"   address public own","contract":"Migrations","time":0},{"type":"de-morgan-condition ","before":"f (!lookup.isAvailable && !queryIndices[identifier][time].isVa","after":"!(f (lookup.isAvailable && queryIndices[identifier][time].isVa)","loc":{"start":{"line":3872,"column":12},"end":{"line":3872,"column":67}},"contract":"MockOracle","time":0},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"MockOracle","time":0},{"type":"external-function ","before":"   function swap(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] memory distribution,\n        uint256 flags\n    ) public override payable returns (uint256 returnAmount) {\n        uint256 amountReturn = prices[keccak256(abi.encodePacked(fromToken, destToken))] * amount;\n\n        require(amountReturn >= minReturn, \"Min Amount not reached\");\n\n        if (destToken == ETH_ADDRESS) {\n            msg.sender.transfer(amountReturn);\n        } else {\n            require(IERC20(destToken).transfer(msg.sender, amountReturn), \"erc20-send-failed\");\n        }\n  ","after":"   function swap(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata distribution,\n        uint256 flags\n    ) public override payable returns (uint256 returnAmount) {\n        uint256 amountReturn = prices[keccak256(abi.encodePacked(fromToken, destToken))] * amount;\n\n        require(amountReturn >= minReturn, \"Min Amount not reached\");\n\n        if (destToken == ETH_ADDRESS) {\n            msg.sender.transfer(amountReturn);\n        } else {\n            require(IERC20(destToken).transfer(msg.sender, amountReturn), \"erc20-send-failed\");\n        }\n  ","contract":"OneSplitMock","time":0},{"type":"external-function ","before":"   function setTransactionData(bytes memory _txnData) public {\n        txnData = _txnData;\n  ","after":"   function setTransactionData(bytes calldata _txnData) public {\n        txnData = _txnData;\n  ","contract":"ReentrancyChecker","time":0},{"type":"external-function ","before":"   function setFinalFee(address currency, FixedPoint.Unsigned memory newFinalFee)\n    public\n    onlyRoleHolder(uint256(Roles.Owner))\n    {\n        finalFees[currency] = newFinalFee;\n        emit NewFinalFee(newFinalFee);\n  ","after":"   function setFinalFee(address currency, FixedPoint.Unsigned calldata newFinalFee)\n    public\n    onlyRoleHolder(uint256(Roles.Owner))\n    {\n        finalFees[currency] = newFinalFee;\n        emit NewFinalFee(newFinalFee);\n  ","contract":"Store","time":0},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"Store","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"SyntheticToken","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"SyntheticToken","time":1},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"TestableTest","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"TestnetERC20","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"TestnetERC20","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public snapshot","after":"   uint256 public snapshot","contract":"TokenMigrator","time":0},{"type":"immutable-restrict-modification ","before":"ade.\n    address public ","after":"ade.\n    address public ","contract":"Umip15Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"ade.\n    address public n","after":"ade.\n    address public n","contract":"Umip15Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"ade.\n    address public existing","after":"ade.\n    address public existing","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"der.\n    address public new","after":"der.\n    address public new","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"ade.\n    address publi","after":"ade.\n    address publi","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"ing;\n    address public identifierW","after":"ing;\n    address public identifierW","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"ist;\n    address publ","after":"ist;\n    address publ","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"ore;\n    address public financialContra","after":"ore;\n    address public financialContra","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"min;\n    address public ","after":"min;\n    address public ","contract":"Umip3Upgrader","time":0},{"type":"external-function ","before":"  */\n    function getPriceRequestStatuses(PendingRequest[] memory requests) public view returns (RequestState[] memory) {\n        RequestState[] memory requestStates = new RequestState[](requests.length);\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        for (uint256 i = 0; i < requests.length; i++) {\n            PriceRequest storage priceRequest = _getPriceRequest(requests[i].identifier, requests[i].time);\n\n            RequestStatus status = _getRequestStatus(priceRequest, currentRoundId);\n\n            // If it's an active request, its true lastVotingRound is the current one, even if it hasn't been updated.\n            if (status == RequestStatus.Active) {\n                requestStates[i].lastVotingRound = currentRoundId;\n            } else {\n                requestStates[i].lastVotingRound = priceRequest.lastVotingRound;\n            }\n            requestStates[i].status = status;\n        }\n        return requestStat","after":"  */\n    function getPriceRequestStatuses(PendingRequest[] calldata requests) public view returns (RequestState[] memory) {\n        RequestState[] memory requestStates = new RequestState[](requests.length);\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        for (uint256 i = 0; i < requests.length; i++) {\n            PriceRequest storage priceRequest = _getPriceRequest(requests[i].identifier, requests[i].time);\n\n            RequestStatus status = _getRequestStatus(priceRequest, currentRoundId);\n\n            // If it's an active request, its true lastVotingRound is the current one, even if it hasn't been updated.\n            if (status == RequestStatus.Active) {\n                requestStates[i].lastVotingRound = currentRoundId;\n            } else {\n                requestStates[i].lastVotingRound = priceRequest.lastVotingRound;\n            }\n            requestStates[i].status = status;\n        }\n        return requestStat","contract":"VotingTest","time":0},{"type":"external-function ","before":"    */\n    function retrieveRewards(\n        address voterAddress,\n        uint256 roundId,\n        PendingRequest[] memory toRetrieve\n    ) public override returns (FixedPoint.Unsigned memory totalRewardToIssue) {\n        if (migratedAddress != address(0)) {\n            require(msg.sender == migratedAddress, \"Can only call from migrated\");\n        }\n        uint256 blockTime = getCurrentTime();\n        require(roundId < voteTiming.computeCurrentRoundId(blockTime), \"Invalid roundId\");\n\n        Round storage round = rounds[roundId];\n        bool isExpired = blockTime > round.rewardsExpirationTime;\n        FixedPoint.Unsigned memory snapshotBalance = FixedPoint.Unsigned(\n            votingToken.balanceOfAt(voterAddress, round.snapshotId)\n        );\n\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\n        FixedPoint.Unsigned memory snapshotTotalSupply = FixedPoint.Unsigned(\n            votingToken.totalSupplyAt(round.snapshotId)\n        );\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\n\n        // Keep track of the voter's accumulated token reward.\n        totalRewardToIssue = FixedPoint.Unsigned(0);\n\n        for (uint256 i = 0; i < toRetrieve.length; i++) {\n            PriceRequest storage priceRequest = _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time);\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n            // Only retrieve rewards for votes resolved in same round\n            require(priceRequest.lastVotingRound == roundId, \"Retrieve for votes same round\");\n\n            _resolvePriceRequest(priceRequest, voteInstance);\n\n            if (voteInstance.voteSubmissions[voterAddress].revealHash == 0) {\n                continue;\n            } else if (isExpired) {\n                // Emit a 0 token retrieval on expired rewards.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n            } else if (\n                voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)\n            ) {\n                // The price was successfully resolved during the voter's last voting round, the voter revealed\n                // and was correct, so they are eligible for a reward.\n                // Compute the reward and add to the cumulative reward.\n                FixedPoint.Unsigned memory reward = snapshotBalance.mul(totalRewardPerVote).div(\n                    voteInstance.resultComputation.getTotalCorrectlyVotedTokens()\n                );\n                totalRewardToIssue = totalRewardToIssue.add(reward);\n\n                // Emit reward retrieval for this vote.\n                emit RewardsRetrieved(\n                    voterAddress,\n                    roundId,\n                    toRetrieve[i].identifier,\n                    toRetrieve[i].time,\n                    reward.rawValue\n                );\n            } else {\n                // Emit a 0 token retrieval on incorrect votes.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n            }\n\n            // Delete the submission to capture any refund and clean up storage.\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\n        }\n\n        // Issue any accumulated rewards.\n        if (totalRewardToIssue.isGreaterThan(0)) {\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue), \"Voting token issuance failed\");\n    ","after":"    */\n    function retrieveRewards(\n        address voterAddress,\n        uint256 roundId,\n        PendingRequest[] calldata toRetrieve\n    ) public override returns (FixedPoint.Unsigned memory totalRewardToIssue) {\n        if (migratedAddress != address(0)) {\n            require(msg.sender == migratedAddress, \"Can only call from migrated\");\n        }\n        uint256 blockTime = getCurrentTime();\n        require(roundId < voteTiming.computeCurrentRoundId(blockTime), \"Invalid roundId\");\n\n        Round storage round = rounds[roundId];\n        bool isExpired = blockTime > round.rewardsExpirationTime;\n        FixedPoint.Unsigned memory snapshotBalance = FixedPoint.Unsigned(\n            votingToken.balanceOfAt(voterAddress, round.snapshotId)\n        );\n\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\n        FixedPoint.Unsigned memory snapshotTotalSupply = FixedPoint.Unsigned(\n            votingToken.totalSupplyAt(round.snapshotId)\n        );\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\n\n        // Keep track of the voter's accumulated token reward.\n        totalRewardToIssue = FixedPoint.Unsigned(0);\n\n        for (uint256 i = 0; i < toRetrieve.length; i++) {\n            PriceRequest storage priceRequest = _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time);\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n            // Only retrieve rewards for votes resolved in same round\n            require(priceRequest.lastVotingRound == roundId, \"Retrieve for votes same round\");\n\n            _resolvePriceRequest(priceRequest, voteInstance);\n\n            if (voteInstance.voteSubmissions[voterAddress].revealHash == 0) {\n                continue;\n            } else if (isExpired) {\n                // Emit a 0 token retrieval on expired rewards.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n            } else if (\n                voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)\n            ) {\n                // The price was successfully resolved during the voter's last voting round, the voter revealed\n                // and was correct, so they are eligible for a reward.\n                // Compute the reward and add to the cumulative reward.\n                FixedPoint.Unsigned memory reward = snapshotBalance.mul(totalRewardPerVote).div(\n                    voteInstance.resultComputation.getTotalCorrectlyVotedTokens()\n                );\n                totalRewardToIssue = totalRewardToIssue.add(reward);\n\n                // Emit reward retrieval for this vote.\n                emit RewardsRetrieved(\n                    voterAddress,\n                    roundId,\n                    toRetrieve[i].identifier,\n                    toRetrieve[i].time,\n                    reward.rawValue\n                );\n            } else {\n                // Emit a 0 token retrieval on incorrect votes.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n            }\n\n            // Delete the submission to capture any refund and clean up storage.\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\n        }\n\n        // Issue any accumulated rewards.\n        if (totalRewardToIssue.isGreaterThan(0)) {\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue), \"Voting token issuance failed\");\n    ","contract":"VotingTest","time":0},{"type":"external-function ","before":"    */\n    function setInflationRate(FixedPoint.Unsigned memory newInflationRate) public onlyOwner {\n        inflationRate = newInflation","after":"    */\n    function setInflationRate(FixedPoint.Unsigned calldata newInflationRate) public onlyOwner {\n        inflationRate = newInflation","contract":"VotingTest","time":0},{"type":"external-function ","before":"    */\n    function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage) public onlyOwner {\n        require(newGatPercentage.isLessThan(1), \"GAT percentage must be < 100%\");\n        gatPercentage = newGatPercen","after":"    */\n    function setGatPercentage(FixedPoint.Unsigned calldata newGatPercentage) public onlyOwner {\n        require(newGatPercentage.isLessThan(1), \"GAT percentage must be < 100%\");\n        gatPercentage = newGatPercen","contract":"VotingTest","time":0},{"type":"constant-restrict-modification  ","before":"0);\n\n    bytes32 public snapshotMessageHash = ECDSA.toEthSignedMessageHash(keccak256(bytes(\"Sign For Snap","after":"0);\n\n    bytes32 public constant snapshotMessageHash = ECDSA.toEthSignedMessageHash(keccak256(bytes(\"Sign For Snap","contract":"VotingTest","time":0},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"VotingTest","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"VotingToken","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"VotingToken","time":0},{"type":"constant-restrict-modification  ","before":" WETH9 {\n    string public name = \"Wr","after":" WETH9 {\n    string public constant name = \"Wr","contract":"WETH9","time":0},{"type":"constant-restrict-modification  ","before":" Ether\";\n    string public sym","after":" Ether\";\n    string public sym","contract":"WETH9","time":0},{"type":"constant-restrict-modification  ","before":" \"WETH\";\n    uint8 public d","after":" \"WETH\";\n    uint8 public d","contract":"WETH9","time":0}]}