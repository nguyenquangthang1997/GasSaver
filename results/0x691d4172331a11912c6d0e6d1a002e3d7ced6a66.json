{"time":192,"results":[{"type":"loop-duplication","before":"\nstart line 1818 column 8, end line 1828 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            address _token = _tokens[i] == ethAddr ? wethAddr : _tokens[i];\n\n            _marketIds[i] = _getMarketIdFromTokenAddress(soloAddr, _token);\n\n            _tokenContracts[i] = IERC20(_token);\n\n            _tokenContracts[i].approve(soloAddr, _amounts[i] + 2);\n\n        }\nstart line 1836 column 8, end line 1840 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            operations[i] = _getWithdrawAction(_marketIds[i], _amounts[i]);\n\n        }\nstart line 1844 column 8, end line 1850 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            uint _opIndex = _length + 1 + i;\n\n            operations[_opIndex] = _getDepositAction(_marketIds[i], _amounts[i] + 2);\n\n        }\nstart line 1869 column 8, end line 1885 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            uint tokenBal = _tokenContracts[i].balanceOf(address(this));\n\n            if (_tokens[i] == ethAddr) {\n\n                flashloanData._iniBals[i] = add(tokenBal, address(this).balance);\n\n            } else {\n\n                flashloanData._iniBals[i] = tokenBal;\n\n            }\n\n            flashloanData._tokenDecimals[i] = TokenInterface(address(_tokenContracts[i])).decimals();\n\n        }\nstart line 1891 column 8, end line 1920 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            flashloanData._finBals[i] = _tokenContracts[i].balanceOf(address(this));\n\n            if (fee == 0) {\n\n                flashloanData._feeAmts[i] = 0;\n\n                uint _dif = wmul(convertTo18(_amounts[i], flashloanData._tokenDecimals[i]), 200000000000);\n                // Taking margin of 0.0000002%\n\n                require(convertTo18(sub(flashloanData._iniBals[i], flashloanData._finBals[i]), flashloanData._tokenDecimals[i]) <= _dif, \"amount-paid-less\");\n\n            } else {\n\n                uint _feeLowerLimit = wmul(_amounts[i], wmul(fee, 999500000000000000));\n                // removing 0.05% fee for decimal/dust error\n\n                uint _feeUpperLimit = wmul(_amounts[i], wmul(fee, 1000500000000000000));\n                // adding 0.05% fee for decimal/dust error\n\n                require(flashloanData._finBals[i] >= flashloanData._iniBals[i], \"final-balance-less-than-inital-balance\");\n\n                flashloanData._feeAmts[i] = sub(flashloanData._finBals[i], flashloanData._iniBals[i]);\n\n                require(_feeLowerLimit < flashloanData._feeAmts[i] && flashloanData._feeAmts[i] < _feeUpperLimit, \"amount-paid-less\");\n\n            }\n\n        }","after":"// merge loop\n\nstart line 1818 column 8, end line 1828 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            address _token = _tokens[i] == ethAddr ? wethAddr : _tokens[i];\n\n            _marketIds[i] = _getMarketIdFromTokenAddress(soloAddr, _token);\n\n            _tokenContracts[i] = IERC20(_token);\n\n            _tokenContracts[i].approve(soloAddr, _amounts[i] + 2);\n\n        }\nstart line 1836 column 8, end line 1840 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            operations[i] = _getWithdrawAction(_marketIds[i], _amounts[i]);\n\n        }\nstart line 1844 column 8, end line 1850 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            uint _opIndex = _length + 1 + i;\n\n            operations[_opIndex] = _getDepositAction(_marketIds[i], _amounts[i] + 2);\n\n        }\nstart line 1869 column 8, end line 1885 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            uint tokenBal = _tokenContracts[i].balanceOf(address(this));\n\n            if (_tokens[i] == ethAddr) {\n\n                flashloanData._iniBals[i] = add(tokenBal, address(this).balance);\n\n            } else {\n\n                flashloanData._iniBals[i] = tokenBal;\n\n            }\n\n            flashloanData._tokenDecimals[i] = TokenInterface(address(_tokenContracts[i])).decimals();\n\n        }\nstart line 1891 column 8, end line 1920 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            flashloanData._finBals[i] = _tokenContracts[i].balanceOf(address(this));\n\n            if (fee == 0) {\n\n                flashloanData._feeAmts[i] = 0;\n\n                uint _dif = wmul(convertTo18(_amounts[i], flashloanData._tokenDecimals[i]), 200000000000);\n                // Taking margin of 0.0000002%\n\n                require(convertTo18(sub(flashloanData._iniBals[i], flashloanData._finBals[i]), flashloanData._tokenDecimals[i]) <= _dif, \"amount-paid-less\");\n\n            } else {\n\n                uint _feeLowerLimit = wmul(_amounts[i], wmul(fee, 999500000000000000));\n                // removing 0.05% fee for decimal/dust error\n\n                uint _feeUpperLimit = wmul(_amounts[i], wmul(fee, 1000500000000000000));\n                // adding 0.05% fee for decimal/dust error\n\n                require(flashloanData._finBals[i] >= flashloanData._iniBals[i], \"final-balance-less-than-inital-balance\");\n\n                flashloanData._feeAmts[i] = sub(flashloanData._finBals[i], flashloanData._iniBals[i]);\n\n                require(_feeLowerLimit < flashloanData._feeAmts[i] && flashloanData._feeAmts[i] < _feeUpperLimit, \"amount-paid-less\");\n\n            }\n\n        }","contract":"DydxFlashloaner","time":0},{"type":"loop-duplication","before":"\nstart line 1983 column 8, end line 2003 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            address _token = _tokens[i] == ethAddr ? wethAddr : _tokens[i];\n\n            _tokenContracts[i] = IERC20(_token);\n\n            uint tokenBal = _tokenContracts[i].balanceOf(address(this));\n\n            if (_tokens[i] == ethAddr) {\n\n                flashloanData._iniBals[i] = add(tokenBal, address(this).balance);\n\n            } else {\n\n                flashloanData._iniBals[i] = tokenBal;\n\n            }\n\n            flashloanData._tokenDecimals[i] = TokenInterface(_token).decimals();\n\n        }\nstart line 2009 column 8, end line 2038 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            flashloanData._finBals[i] = _tokenContracts[i].balanceOf(address(this));\n\n            if (fee == 0) {\n\n                flashloanData._feeAmts[i] = 0;\n\n                uint _dif = wmul(convertTo18(_amounts[i], flashloanData._tokenDecimals[i]), 200000000000);\n                // Taking margin of 0.0000002%\n\n                require(convertTo18(sub(flashloanData._iniBals[i], flashloanData._finBals[i]), flashloanData._tokenDecimals[i]) <= _dif, \"amount-paid-less\");\n\n            } else {\n\n                uint _feeLowerLimit = wmul(_amounts[i], wmul(fee, 999500000000000000));\n                // removing 0.05% fee for decimal/dust error\n\n                uint _feeUpperLimit = wmul(_amounts[i], wmul(fee, 1000500000000000000));\n                // adding 0.05% fee for decimal/dust error\n\n                require(flashloanData._finBals[i] >= flashloanData._iniBals[i], \"final-balance-less-than-inital-balance\");\n\n                flashloanData._feeAmts[i] = sub(flashloanData._finBals[i], flashloanData._iniBals[i]);\n\n                require(_feeLowerLimit < flashloanData._feeAmts[i] && flashloanData._feeAmts[i] < _feeUpperLimit, \"amount-paid-less\");\n\n            }\n\n        }","after":"// merge loop\n\nstart line 1983 column 8, end line 2003 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            address _token = _tokens[i] == ethAddr ? wethAddr : _tokens[i];\n\n            _tokenContracts[i] = IERC20(_token);\n\n            uint tokenBal = _tokenContracts[i].balanceOf(address(this));\n\n            if (_tokens[i] == ethAddr) {\n\n                flashloanData._iniBals[i] = add(tokenBal, address(this).balance);\n\n            } else {\n\n                flashloanData._iniBals[i] = tokenBal;\n\n            }\n\n            flashloanData._tokenDecimals[i] = TokenInterface(_token).decimals();\n\n        }\nstart line 2009 column 8, end line 2038 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            flashloanData._finBals[i] = _tokenContracts[i].balanceOf(address(this));\n\n            if (fee == 0) {\n\n                flashloanData._feeAmts[i] = 0;\n\n                uint _dif = wmul(convertTo18(_amounts[i], flashloanData._tokenDecimals[i]), 200000000000);\n                // Taking margin of 0.0000002%\n\n                require(convertTo18(sub(flashloanData._iniBals[i], flashloanData._finBals[i]), flashloanData._tokenDecimals[i]) <= _dif, \"amount-paid-less\");\n\n            } else {\n\n                uint _feeLowerLimit = wmul(_amounts[i], wmul(fee, 999500000000000000));\n                // removing 0.05% fee for decimal/dust error\n\n                uint _feeUpperLimit = wmul(_amounts[i], wmul(fee, 1000500000000000000));\n                // adding 0.05% fee for decimal/dust error\n\n                require(flashloanData._finBals[i] >= flashloanData._iniBals[i], \"final-balance-less-than-inital-balance\");\n\n                flashloanData._feeAmts[i] = sub(flashloanData._finBals[i], flashloanData._iniBals[i]);\n\n                require(_feeLowerLimit < flashloanData._feeAmts[i] && flashloanData._feeAmts[i] < _feeUpperLimit, \"amount-paid-less\");\n\n            }\n\n        }","contract":"DydxFlashloaner","time":0},{"type":"external-function ","before":"function callFunction(\n\n        address sender,\n\n        Account.Info memory account,\n\n        bytes memory data\n\n    ) public override {\n\n        require(sender == address(this), \"not-same-sender\");\n\n        require(msg.sender == soloAddr, \"not-solo-dydx-sender\");\n\n        CastData memory cd;\n\n        (cd.dsa, cd.route, cd.tokens, cd.amounts, cd.dsaTargets, cd.dsaData) = abi.decode(\n\n            data,\n\n            (address, uint256, address[], uint256[], address[], bytes[])\n\n        );\n\n\n        bool isWeth = checkWeth(cd.tokens, cd.route);\n\n        if (isWeth) {\n\n            wethContract.withdraw(wethContract.balanceOf(address(this)));\n\n        }\n\n\n        selectBorrow(cd.tokens, cd.amounts, cd.route);\n\n\n        uint _length = cd.tokens.length;\n\n\n        for (uint i = 0; i < _length; i++) {\n\n            if (cd.tokens[i] == ethAddr) {\n\n                payable(cd.dsa).transfer(cd.amounts[i]);\n\n            } else {\n\n                IERC20(cd.tokens[i]).safeTransfer(cd.dsa, cd.amounts[i]);\n\n            }\n\n        }\n\n\n        DSAInterface(cd.dsa).cast(cd.dsaTargets, cd.dsaData, 0xB7fA44c2E964B6EB24893f7082Ecc08c8d0c0F87);\n\n\n        selectPayback(cd.tokens, cd.route);\n\n\n        if (isWeth) {\n\n            wethContract.deposit{value : address(this).balance}();\n\n        }\n\n    }","after":"function callFunction(\n\n        address sender,\n\n        Account.Info calldata account,\n\n        bytes calldata data\n\n    ) public override {\n\n        require(sender == address(this), \"not-same-sender\");\n\n        require(msg.sender == soloAddr, \"not-solo-dydx-sender\");\n\n        CastData memory cd;\n\n        (cd.dsa, cd.route, cd.tokens, cd.amounts, cd.dsaTargets, cd.dsaData) = abi.decode(\n\n            data,\n\n            (address, uint256, address[], uint256[], address[], bytes[])\n\n        );\n\n\n        bool isWeth = checkWeth(cd.tokens, cd.route);\n\n        if (isWeth) {\n\n            wethContract.withdraw(wethContract.balanceOf(address(this)));\n\n        }\n\n\n        selectBorrow(cd.tokens, cd.amounts, cd.route);\n\n\n        uint _length = cd.tokens.length;\n\n\n        for (uint i = 0; i < _length; i++) {\n\n            if (cd.tokens[i] == ethAddr) {\n\n                payable(cd.dsa).transfer(cd.amounts[i]);\n\n            } else {\n\n                IERC20(cd.tokens[i]).safeTransfer(cd.dsa, cd.amounts[i]);\n\n            }\n\n        }\n\n\n        DSAInterface(cd.dsa).cast(cd.dsaTargets, cd.dsaData, 0xB7fA44c2E964B6EB24893f7082Ecc08c8d0c0F87);\n\n\n        selectPayback(cd.tokens, cd.route);\n\n\n        if (isWeth) {\n\n            wethContract.deposit{value : address(this).balance}();\n\n        }\n\n    }","contract":"InstaPoolV2","time":0},{"type":"constant-restrict-modification  ","before":"address public makerConnect = address(0x33c4f6d6c0A123AF5F1655EA5Fd730098d0aBD50);","after":"address public constant makerConnect = address(0x33c4f6d6c0A123AF5F1655EA5Fd730098d0aBD50);","contract":"InstaPoolV2","time":1},{"type":"constant-restrict-modification  ","before":"address public compoundConnect = address(0x33d4876A16F712f1a305C5594A5AdeDc9b7A9f14);","after":"address public constant compoundConnect = address(0x33d4876A16F712f1a305C5594A5AdeDc9b7A9f14);","contract":"InstaPoolV2","time":1},{"type":"constant-restrict-modification  ","before":"address public aaveConnect = address(0x01d0734e34B0251f46aD34d1a82c4946a5B943D9);","after":"address public constant aaveConnect = address(0x01d0734e34B0251f46aD34d1a82c4946a5B943D9);","contract":"InstaPoolV2","time":1},{"type":"immutable-restrict-modification ","before":"uint public vaultId;","after":"uint public immutable vaultId;","contract":"InstaPoolV2","time":1}]}