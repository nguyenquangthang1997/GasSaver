{"time":49,"results":[{"type":"external-function ","before":"function read(\n\n        TimeSeriesStateLibrary.State memory _timeSeriesState\n\n    )\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        // Validate that nextEarliest update timestamp is less than current block timestamp\n\n        require(\n\n            block.timestamp >= _timeSeriesState.nextEarliestUpdate,\n\n            \"LinearizedPriceDataSource.read: current timestamp must be greater than nextAvailableUpdate.\"\n\n        );\n\n\n        // Calculate how much time has passed from last expected update\n\n        uint256 timeFromExpectedUpdate = block.timestamp.sub(_timeSeriesState.nextEarliestUpdate);\n\n\n        // Get current oracle value\n\n        uint256 oracleValue = oracleInstance.read();\n\n\n        // If block timeFromExpectedUpdate is greater than interpolationThreshold we linearize\n\n        // the current price to try to reduce error\n\n        if (timeFromExpectedUpdate < interpolationThreshold) {\n\n            return oracleValue;\n\n        } else {\n\n            uint256 mostRecentPrice = _timeSeriesState.timeSeriesData.getLatestValue();\n\n\n            return DataSourceLinearInterpolationLibrary.interpolateDelayedPriceUpdate(\n\n                oracleValue,\n\n                _timeSeriesState.updateInterval,\n\n                timeFromExpectedUpdate,\n\n                mostRecentPrice\n\n            );\n\n        }\n\n    }","after":"function read(\n\n        TimeSeriesStateLibrary.State calldata _timeSeriesState\n\n    )\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        // Validate that nextEarliest update timestamp is less than current block timestamp\n\n        require(\n\n            block.timestamp >= _timeSeriesState.nextEarliestUpdate,\n\n            \"LinearizedPriceDataSource.read: current timestamp must be greater than nextAvailableUpdate.\"\n\n        );\n\n\n        // Calculate how much time has passed from last expected update\n\n        uint256 timeFromExpectedUpdate = block.timestamp.sub(_timeSeriesState.nextEarliestUpdate);\n\n\n        // Get current oracle value\n\n        uint256 oracleValue = oracleInstance.read();\n\n\n        // If block timeFromExpectedUpdate is greater than interpolationThreshold we linearize\n\n        // the current price to try to reduce error\n\n        if (timeFromExpectedUpdate < interpolationThreshold) {\n\n            return oracleValue;\n\n        } else {\n\n            uint256 mostRecentPrice = _timeSeriesState.timeSeriesData.getLatestValue();\n\n\n            return DataSourceLinearInterpolationLibrary.interpolateDelayedPriceUpdate(\n\n                oracleValue,\n\n                _timeSeriesState.updateInterval,\n\n                timeFromExpectedUpdate,\n\n                mostRecentPrice\n\n            );\n\n        }\n\n    }","contract":"LinearizedPriceDataSource","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public interpolationThreshold;","after":"uint256 public immutable interpolationThreshold;","contract":"LinearizedPriceDataSource","time":0},{"type":"immutable-restrict-modification ","before":"string public dataDescription;","after":"string public immutable dataDescription;","contract":"LinearizedPriceDataSource","time":0}]}