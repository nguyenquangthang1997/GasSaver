{"time":116,"results":[{"type":"external-function ","before":"function fill(\n\n        uint256 userSalt,\n\n        bytes memory data,\n\n        bytes memory userSignature\n\n    )\n\n    override\n\n    public\n\n    payable\n\n    onlyUserProxy\n\n    nonReentrant\n\n    returns (uint256)\n\n    {\n\n        // decode & assert\n\n        (LibOrder.Order memory order,\n\n        TradeInfo memory tradeInfo) = _assertTransaction(userSalt, data, userSignature);\n\n\n        // Deposit to WETH if taker asset is ETH, else transfer from user\n\n        IWETH weth = IWETH(permStorage.wethAddr());\n\n        if (address(weth) == tradeInfo.takerAssetAddr) {\n\n            require(\n\n                msg.value == order.takerAssetAmount,\n\n                \"PMM: insufficient ETH\"\n\n            );\n\n            weth.deposit{value : msg.value}();\n\n        } else {\n\n            spender.spendFromUser(tradeInfo.user, tradeInfo.takerAssetAddr, order.takerAssetAmount);\n\n        }\n\n\n        IERC20(tradeInfo.takerAssetAddr).safeIncreaseAllowance(zxERC20Proxy, order.takerAssetAmount);\n\n\n        // send tx to 0x\n\n        zeroExchange.executeTransaction(\n\n            userSalt,\n\n            address(this),\n\n            data,\n\n            \"\"\n\n        );\n\n\n        // settle token/ETH to user\n\n        uint256 settleAmount = _settle(weth, tradeInfo.receiver, tradeInfo.makerAssetAddr, order.makerAssetAmount, tradeInfo.feeFactor);\n\n        IERC20(tradeInfo.takerAssetAddr).safeApprove(zxERC20Proxy, 0);\n\n\n        emit FillOrder(\n\n            SOURCE,\n\n            tradeInfo.transactionHash,\n\n            tradeInfo.orderHash,\n\n            tradeInfo.user,\n\n            tradeInfo.takerAssetAddr,\n\n            order.takerAssetAmount,\n\n            order.makerAddress,\n\n            tradeInfo.makerAssetAddr,\n\n            order.makerAssetAmount,\n\n            tradeInfo.receiver,\n\n            settleAmount,\n\n            tradeInfo.feeFactor\n\n        );\n\n        return settleAmount;\n\n    }","after":"function fill(\n\n        uint256 userSalt,\n\n        bytes calldata data,\n\n        bytes calldata userSignature\n\n    )\n\n    override\n\n    public\n\n    payable\n\n    onlyUserProxy\n\n    nonReentrant\n\n    returns (uint256)\n\n    {\n\n        // decode & assert\n\n        (LibOrder.Order memory order,\n\n        TradeInfo memory tradeInfo) = _assertTransaction(userSalt, data, userSignature);\n\n\n        // Deposit to WETH if taker asset is ETH, else transfer from user\n\n        IWETH weth = IWETH(permStorage.wethAddr());\n\n        if (address(weth) == tradeInfo.takerAssetAddr) {\n\n            require(\n\n                msg.value == order.takerAssetAmount,\n\n                \"PMM: insufficient ETH\"\n\n            );\n\n            weth.deposit{value : msg.value}();\n\n        } else {\n\n            spender.spendFromUser(tradeInfo.user, tradeInfo.takerAssetAddr, order.takerAssetAmount);\n\n        }\n\n\n        IERC20(tradeInfo.takerAssetAddr).safeIncreaseAllowance(zxERC20Proxy, order.takerAssetAmount);\n\n\n        // send tx to 0x\n\n        zeroExchange.executeTransaction(\n\n            userSalt,\n\n            address(this),\n\n            data,\n\n            \"\"\n\n        );\n\n\n        // settle token/ETH to user\n\n        uint256 settleAmount = _settle(weth, tradeInfo.receiver, tradeInfo.makerAssetAddr, order.makerAssetAmount, tradeInfo.feeFactor);\n\n        IERC20(tradeInfo.takerAssetAddr).safeApprove(zxERC20Proxy, 0);\n\n\n        emit FillOrder(\n\n            SOURCE,\n\n            tradeInfo.transactionHash,\n\n            tradeInfo.orderHash,\n\n            tradeInfo.user,\n\n            tradeInfo.takerAssetAddr,\n\n            order.takerAssetAmount,\n\n            order.makerAddress,\n\n            tradeInfo.makerAssetAddr,\n\n            order.makerAssetAmount,\n\n            tradeInfo.receiver,\n\n            settleAmount,\n\n            tradeInfo.feeFactor\n\n        );\n\n        return settleAmount;\n\n    }","contract":"PMM","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public EIP712_DOMAIN_HASH;","after":"bytes32 public immutable EIP712_DOMAIN_HASH;","contract":"PMM","time":0}]}