{"time":167,"results":[{"type":"external-function ","before":"  function tokenAllowAll(\n        address[] memory tokensToApprove,\n        address spender\n    ) external onlyApprover {\n        for (uint i = 0; i < tokensToApprove.length; i++) {\n            IERC20 token = IERC20(tokensToApprove[i]);\n            if (token.allowance(address(this), spender) != uint256(- 1)) {\n                token.safeApprove(spender, uint256(- 1));\n            }\n        }\n   ","after":"  function tokenAllowAll(\n        address[] calldata tokensToApprove,\n        address spender\n    ) external onlyApprover {\n        for (uint i = 0; i < tokensToApprove.length; i++) {\n            IERC20 token = IERC20(tokensToApprove[i]);\n            if (token.allowance(address(this), spender) != uint256(- 1)) {\n                token.safeApprove(spender, uint256(- 1));\n            }\n        }\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function tokenAllow(\n        address[] memory tokensToApprove,\n        uint256[] memory approvalAmounts,\n        address spender\n    ) external onlyApprover {\n        require(tokensToApprove.length == approvalAmounts.length, \"not same length\");\n        for (uint i = 0; i < tokensToApprove.length; i++) {\n            IERC20 token = IERC20(tokensToApprove[i]);\n            if (token.allowance(address(this), spender) != uint256(- 1)) {\n                token.safeApprove(spender, approvalAmounts[i]);\n            }\n        }\n   ","after":"  function tokenAllow(\n        address[] calldata tokensToApprove,\n        uint256[] calldata approvalAmounts,\n        address spender\n    ) external onlyApprover {\n        require(tokensToApprove.length == approvalAmounts.length, \"not same length\");\n        for (uint i = 0; i < tokensToApprove.length; i++) {\n            IERC20 token = IERC20(tokensToApprove[i]);\n            if (token.allowance(address(this), spender) != uint256(- 1)) {\n                token.safeApprove(spender, approvalAmounts[i]);\n            }\n        }\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function estimateQueryCost(bytes memory script, uint256[] memory inputLocations) public {\n        queryEngine.queryAllPrices(script, inputLocations);\n   ","after":"  function estimateQueryCost(bytes calldata script, uint256[] calldata inputLocations) public {\n        queryEngine.queryAllPrices(script, inputLocations);\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function makeTrade(\n        bytes memory executeScript,\n        uint256 ethValue\n    ) public onlyTrader nonReentrant mustBeProfitable(ethValue) {\n        execute(executeScript, ethValue);\n   ","after":"  function makeTrade(\n        bytes calldata executeScript,\n        uint256 ethValue\n    ) public onlyTrader nonReentrant mustBeProfitable(ethValue) {\n        execute(executeScript, ethValue);\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function makeTrade(\n        bytes memory executeScript,\n        uint256 ethValue,\n        uint256 blockDeadline\n    ) public onlyTrader nonReentrant notExpired(blockDeadline) mustBeProfitable(ethValue) {\n        execute(executeScript, ethValue);\n   ","after":"  function makeTrade(\n        bytes calldata executeScript,\n        uint256 ethValue,\n        uint256 blockDeadline\n    ) public onlyTrader nonReentrant notExpired(blockDeadline) mustBeProfitable(ethValue) {\n        execute(executeScript, ethValue);\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function makeTrade(\n        bytes memory executeScript,\n        uint256 ethValue,\n        uint256 minTimestamp,\n        uint256 maxTimestamp\n    ) public onlyTrader nonReentrant onTime(minTimestamp, maxTimestamp) mustBeProfitable(ethValue) {\n        execute(executeScript, ethValue);\n   ","after":"  function makeTrade(\n        bytes calldata executeScript,\n        uint256 ethValue,\n        uint256 minTimestamp,\n        uint256 maxTimestamp\n    ) public onlyTrader nonReentrant onTime(minTimestamp, maxTimestamp) mustBeProfitable(ethValue) {\n        execute(executeScript, ethValue);\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function makeTrade(\n        bytes memory queryScript,\n        uint256[] memory queryInputLocations,\n        bytes memory executeScript,\n        uint256[] memory executeInputLocations,\n        uint256 targetPrice,\n        uint256 ethValue\n    ) public onlyTrader nonReentrant mustBeProfitable(ethValue) {\n        bytes memory prices = queryEngine.queryAllPrices(queryScript, queryInputLocations);\n        require(prices.toUint256(prices.length - 32) >= targetPrice, \"Not profitable\");\n        for (uint i = 0; i < executeInputLocations.length; i++) {\n            replaceDataAt(executeScript, prices.slice(i * 32, 32), executeInputLocations[i]);\n        }\n        execute(executeScript, ethValue);\n   ","after":"  function makeTrade(\n        bytes calldata queryScript,\n        uint256[] calldata queryInputLocations,\n        bytes calldata executeScript,\n        uint256[] calldata executeInputLocations,\n        uint256 targetPrice,\n        uint256 ethValue\n    ) public onlyTrader nonReentrant mustBeProfitable(ethValue) {\n        bytes memory prices = queryEngine.queryAllPrices(queryScript, queryInputLocations);\n        require(prices.toUint256(prices.length - 32) >= targetPrice, \"Not profitable\");\n        for (uint i = 0; i < executeInputLocations.length; i++) {\n            replaceDataAt(executeScript, prices.slice(i * 32, 32), executeInputLocations[i]);\n        }\n        execute(executeScript, ethValue);\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function makeTrade(\n        bytes memory queryScript,\n        uint256[] memory queryInputLocations,\n        bytes memory executeScript,\n        uint256[] memory executeInputLocations,\n        uint256 targetPrice,\n        uint256 ethValue,\n        uint256 blockDeadline\n    ) public onlyTrader nonReentrant notExpired(blockDeadline) mustBeProfitable(ethValue) {\n        bytes memory prices = queryEngine.queryAllPrices(queryScript, queryInputLocations);\n        require(prices.toUint256(prices.length - 32) >= targetPrice, \"Not profitable\");\n        for (uint i = 0; i < executeInputLocations.length; i++) {\n            replaceDataAt(executeScript, prices.slice(i * 32, 32), executeInputLocations[i]);\n        }\n        execute(executeScript, ethValue);\n   ","after":"  function makeTrade(\n        bytes calldata queryScript,\n        uint256[] calldata queryInputLocations,\n        bytes calldata executeScript,\n        uint256[] calldata executeInputLocations,\n        uint256 targetPrice,\n        uint256 ethValue,\n        uint256 blockDeadline\n    ) public onlyTrader nonReentrant notExpired(blockDeadline) mustBeProfitable(ethValue) {\n        bytes memory prices = queryEngine.queryAllPrices(queryScript, queryInputLocations);\n        require(prices.toUint256(prices.length - 32) >= targetPrice, \"Not profitable\");\n        for (uint i = 0; i < executeInputLocations.length; i++) {\n            replaceDataAt(executeScript, prices.slice(i * 32, 32), executeInputLocations[i]);\n        }\n        execute(executeScript, ethValue);\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function makeTrade(\n        bytes memory queryScript,\n        uint256[] memory queryInputLocations,\n        bytes memory executeScript,\n        uint256[] memory executeInputLocations,\n        uint256 targetPrice,\n        uint256 ethValue,\n        uint256 minTimestamp,\n        uint256 maxTimestamp\n    ) public onlyTrader nonReentrant onTime(minTimestamp, maxTimestamp) mustBeProfitable(ethValue) {\n        bytes memory prices = queryEngine.queryAllPrices(queryScript, queryInputLocations);\n        require(prices.toUint256(prices.length - 32) >= targetPrice, \"Not profitable\");\n        for (uint i = 0; i < executeInputLocations.length; i++) {\n            replaceDataAt(executeScript, prices.slice(i * 32, 32), executeInputLocations[i]);\n        }\n        execute(executeScript, ethValue);\n   ","after":"  function makeTrade(\n        bytes calldata queryScript,\n        uint256[] calldata queryInputLocations,\n        bytes calldata executeScript,\n        uint256[] calldata executeInputLocations,\n        uint256 targetPrice,\n        uint256 ethValue,\n        uint256 minTimestamp,\n        uint256 maxTimestamp\n    ) public onlyTrader nonReentrant onTime(minTimestamp, maxTimestamp) mustBeProfitable(ethValue) {\n        bytes memory prices = queryEngine.queryAllPrices(queryScript, queryInputLocations);\n        require(prices.toUint256(prices.length - 32) >= targetPrice, \"Not profitable\");\n        for (uint i = 0; i < executeInputLocations.length; i++) {\n            replaceDataAt(executeScript, prices.slice(i * 32, 32), executeInputLocations[i]);\n        }\n        execute(executeScript, ethValue);\n   ","contract":"Dispatcher","time":0},{"type":"immutable-restrict-modification ","before":"  uint8 public versio","after":"  uint8 public versio","contract":"Dispatcher","time":1}]}