{"time":307,"results":[{"type":"external-function ","before":"function updateBaseURI(string memory __baseURI) public onlyOwner {\n\n        _baseTokenURI = __baseURI;\n\n    }","after":"function updateBaseURI(string calldata __baseURI) public onlyOwner {\n\n        _baseTokenURI = __baseURI;\n\n    }","contract":"BoonjiNft","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n\n        address userAddress,\n\n        bytes memory functionSignature,\n\n        bytes32 sigR,\n\n        bytes32 sigS,\n\n        uint8 sigV\n\n    ) public payable returns (bytes memory) {\n\n        MetaTransaction memory metaTx = MetaTransaction({\n\n        nonce : nonces[userAddress],\n\n        from : userAddress,\n\n        functionSignature : functionSignature\n\n        });\n\n\n        require(\n\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n\n            \"Signer and signature do not match\"\n\n        );\n\n\n        // increase nonce for user (to avoid re-use)\n\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n\n        emit MetaTransactionExecuted(\n\n            userAddress,\n\n            payable(msg.sender),\n\n            functionSignature\n\n        );\n\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n\n        (bool success, bytes memory returnData) = address(this).call(\n\n            abi.encodePacked(functionSignature, userAddress)\n\n        );\n\n        require(success, \"Function call not successful\");\n\n\n        return returnData;\n\n    }","after":"function executeMetaTransaction(\n\n        address userAddress,\n\n        bytes calldata functionSignature,\n\n        bytes32 sigR,\n\n        bytes32 sigS,\n\n        uint8 sigV\n\n    ) public payable returns (bytes memory) {\n\n        MetaTransaction memory metaTx = MetaTransaction({\n\n        nonce : nonces[userAddress],\n\n        from : userAddress,\n\n        functionSignature : functionSignature\n\n        });\n\n\n        require(\n\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n\n            \"Signer and signature do not match\"\n\n        );\n\n\n        // increase nonce for user (to avoid re-use)\n\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n\n        emit MetaTransactionExecuted(\n\n            userAddress,\n\n            payable(msg.sender),\n\n            functionSignature\n\n        );\n\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n\n        (bool success, bytes memory returnData) = address(this).call(\n\n            abi.encodePacked(functionSignature, userAddress)\n\n        );\n\n        require(success, \"Function call not successful\");\n\n\n        return returnData;\n\n    }","contract":"BoonjiNft","time":0},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"BoonjiNft","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"BoonjiNft","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"BoonjiNft","time":1}]}