{"time":177,"results":[{"type":"state-data-arrangement ","before":"\nbool public paused;\nuint256 public positionCount;\nmapping(uint256 => MozartTypes.Position) internal positions;\nmapping(uint256 => mapping(address => bool)) internal positionOperators;\nmapping(address => bool) internal globalOperators;\nIOracle internal oracle;\nuint256 internal precisionScalar;\naddress internal collateralAsset;\naddress internal syntheticAsset;\nuint256 internal totalSupplied;\nuint256 internal totalBorrowed;\nuint256 internal borrowIndex;\nuint256 internal indexLastUpdate;\nuint256 internal interestRate;\nDecimal.D256 internal collateralRatio;\nDecimal.D256 internal liquidationUserFee;\nDecimal.D256 internal liquidationArcRatio;\naddress internal interestSetter;\nuint256 internal collateralLimit;\nuint256 internal positionCollateralMinimum;","after":"uint256 public positionCount;\nmapping(uint256 => MozartTypes.Position) internal positions;\nmapping(uint256 => mapping(address => bool)) internal positionOperators;\nmapping(address => bool) internal globalOperators;\nIOracle internal oracle;\nuint256 internal precisionScalar;\nuint256 internal totalSupplied;\nuint256 internal totalBorrowed;\nuint256 internal borrowIndex;\nuint256 internal indexLastUpdate;\nuint256 internal interestRate;\nDecimal.D256 internal collateralRatio;\nDecimal.D256 internal liquidationUserFee;\nDecimal.D256 internal liquidationArcRatio;\nuint256 internal collateralLimit;\nuint256 internal positionCollateralMinimum;\naddress internal collateralAsset;\naddress internal syntheticAsset;\naddress internal interestSetter;\nbool public paused;\n","contract":"MozartCoreStorageV1","time":0},{"type":"external-function ","before":"function init(\n        uint8 _collateralDecimals,\n        address _collateralAddress,\n        address _syntheticAddress,\n        address _oracleAddress,\n        address _interestSetter,\n        Decimal.D256 memory _collateralRatio,\n        Decimal.D256 memory _liquidationUserFee,\n        Decimal.D256 memory _liquidationArcRatio\n    )\n    public\n    {\n        require(\n            collateralAsset == address(0),\n            \"MozartCore: cannot re-call init()\"\n        );\n\n        precisionScalar = 10 ** (18 - uint256(_collateralDecimals));\n        collateralAsset = _collateralAddress;\n        syntheticAsset = _syntheticAddress;\n\n        borrowIndex = uint256(10 ** 18);\n        indexLastUpdate = currentTimestamp();\n\n        setOracle(_oracleAddress);\n        setCollateralRatio(_collateralRatio);\n        setInterestSetter(_interestSetter);\n\n        setFees(\n            _liquidationUserFee,\n            _liquidationArcRatio\n        );\n    }","after":"function init(\n        uint8 _collateralDecimals,\n        address _collateralAddress,\n        address _syntheticAddress,\n        address _oracleAddress,\n        address _interestSetter,\n        Decimal.D256 calldata _collateralRatio,\n        Decimal.D256 calldata _liquidationUserFee,\n        Decimal.D256 calldata _liquidationArcRatio\n    )\n    public\n    {\n        require(\n            collateralAsset == address(0),\n            \"MozartCore: cannot re-call init()\"\n        );\n\n        precisionScalar = 10 ** (18 - uint256(_collateralDecimals));\n        collateralAsset = _collateralAddress;\n        syntheticAsset = _syntheticAddress;\n\n        borrowIndex = uint256(10 ** 18);\n        indexLastUpdate = currentTimestamp();\n\n        setOracle(_oracleAddress);\n        setCollateralRatio(_collateralRatio);\n        setInterestSetter(_interestSetter);\n\n        setFees(\n            _liquidationUserFee,\n            _liquidationArcRatio\n        );\n    }","contract":"MozartCoreV2","time":0},{"type":"external-function ","before":"function operateAction(\n        Operation operation,\n        OperationParams memory params\n    )\n    public\n    {\n        require(\n            paused == false,\n            \"operateAction(): contracts cannot be paused\"\n        );\n\n        MozartTypes.Position memory operatedPosition;\n\n        // Get the price now since certain contracts consume a lot.\n        Decimal.D256 memory currentPrice = oracle.fetchCurrentPrice();\n\n        // Update the index to calculate how much interest has accrued\n        // And then subsequently mint more of the synth to the printer\n        updateIndex();\n\n        if (operation == Operation.Open) {\n            (operatedPosition, params.id) = openPosition(\n                params.amountOne,\n                params.amountTwo,\n                currentPrice\n            );\n        } else if (operation == Operation.Borrow) {\n            operatedPosition = borrow(\n                params.id,\n                params.amountOne,\n                params.amountTwo,\n                currentPrice\n            );\n        } else if (operation == Operation.Repay) {\n            operatedPosition = repay(\n                params.id,\n                params.amountOne,\n                params.amountTwo,\n                currentPrice\n            );\n        } else if (operation == Operation.Liquidate) {\n            operatedPosition = liquidate(\n                params.id,\n                currentPrice\n            );\n        } else if (operation == Operation.TransferOwnership) {\n            operatedPosition = transferOwnership(\n                params.id,\n                params.addressOne\n            );\n        } else {\n            revert(\"operateAction(): invalid action\");\n        }\n\n        // Ensure that the operated action is collateralised again, unless a liquidation\n        // has occured in which case the position might be under-collataralised\n        require(\n            isCollateralized(operatedPosition, currentPrice) == true || operation == Operation.Liquidate,\n            \"operateAction(): the operated position is undercollateralised\"\n        );\n\n        // Ensure the amount supplied is less than the collateral limit of the system\n        require(\n            totalSupplied <= collateralLimit || collateralLimit == 0,\n            \"operateAction(): collateral locked cannot be greater than limit\"\n        );\n\n        // Collateral should never be expressed as negative since it means value has been drained\n        assert(operatedPosition.collateralAmount.sign == true);\n\n        // Debt should never be expressed as positive since it means the protocol is in debt to the user\n        assert(operatedPosition.borrowedAmount.sign == false);\n\n        emit ActionOperated(\n            uint8(operation),\n            params,\n            operatedPosition\n        );\n    }","after":"function operateAction(\n        Operation operation,\n        OperationParams calldata params\n    )\n    public\n    {\n        require(\n            paused == false,\n            \"operateAction(): contracts cannot be paused\"\n        );\n\n        MozartTypes.Position memory operatedPosition;\n\n        // Get the price now since certain contracts consume a lot.\n        Decimal.D256 memory currentPrice = oracle.fetchCurrentPrice();\n\n        // Update the index to calculate how much interest has accrued\n        // And then subsequently mint more of the synth to the printer\n        updateIndex();\n\n        if (operation == Operation.Open) {\n            (operatedPosition, params.id) = openPosition(\n                params.amountOne,\n                params.amountTwo,\n                currentPrice\n            );\n        } else if (operation == Operation.Borrow) {\n            operatedPosition = borrow(\n                params.id,\n                params.amountOne,\n                params.amountTwo,\n                currentPrice\n            );\n        } else if (operation == Operation.Repay) {\n            operatedPosition = repay(\n                params.id,\n                params.amountOne,\n                params.amountTwo,\n                currentPrice\n            );\n        } else if (operation == Operation.Liquidate) {\n            operatedPosition = liquidate(\n                params.id,\n                currentPrice\n            );\n        } else if (operation == Operation.TransferOwnership) {\n            operatedPosition = transferOwnership(\n                params.id,\n                params.addressOne\n            );\n        } else {\n            revert(\"operateAction(): invalid action\");\n        }\n\n        // Ensure that the operated action is collateralised again, unless a liquidation\n        // has occured in which case the position might be under-collataralised\n        require(\n            isCollateralized(operatedPosition, currentPrice) == true || operation == Operation.Liquidate,\n            \"operateAction(): the operated position is undercollateralised\"\n        );\n\n        // Ensure the amount supplied is less than the collateral limit of the system\n        require(\n            totalSupplied <= collateralLimit || collateralLimit == 0,\n            \"operateAction(): collateral locked cannot be greater than limit\"\n        );\n\n        // Collateral should never be expressed as negative since it means value has been drained\n        assert(operatedPosition.collateralAmount.sign == true);\n\n        // Debt should never be expressed as positive since it means the protocol is in debt to the user\n        assert(operatedPosition.borrowedAmount.sign == false);\n\n        emit ActionOperated(\n            uint8(operation),\n            params,\n            operatedPosition\n        );\n    }","contract":"MozartCoreV2","time":0}]}