{"time":789,"results":[{"type":"external-function ","before":"ure sender is vault\n     */\n    function onSwap(\n        SwapRequest memory request,\n        uint256[] memory balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) public virtual override onlyVault(request.poolId) returns (uint256) {\n        _cachePriceRatesIfNecessary();\n        return super.onSwap(request, bal","after":"ure sender is vault\n     */\n    function onSwap(\n        SwapRequest calldata request,\n        uint256[] calldata balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) public virtual override onlyVault(request.poolId) returns (uint256) {\n        _cachePriceRatesIfNecessary();\n        return super.onSwap(request, bal","contract":"MetaStablePool","time":0},{"type":"external-function ","before":"ure sender is vault\n     */\n    function onSwap(\n        SwapRequest memory request,\n        uint256 balanceTokenIn,\n        uint256 balanceTokenOut\n    ) public virtual override onlyVault(request.poolId) returns (uint256) {\n        _cachePriceRatesIfNecessary();\n        return super.onSwap(request, balance","after":"ure sender is vault\n     */\n    function onSwap(\n        SwapRequest calldata request,\n        uint256 balanceTokenIn,\n        uint256 balanceTokenOut\n    ) public virtual override onlyVault(request.poolId) returns (uint256) {\n        _cachePriceRatesIfNecessary();\n        return super.onSwap(request, balance","contract":"MetaStablePool","time":0},{"type":"external-function ","before":"entations for that.\n     */\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) {\n        _cachePriceRatesIfNecessary();\n\n        (amountsIn, dueProtocolFeeAmounts) = super.onJoinPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData\n        );\n\n        _","after":"entations for that.\n     */\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) {\n        _cachePriceRatesIfNecessary();\n\n        (amountsIn, dueProtocolFeeAmounts) = super.onJoinPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData\n        );\n\n        _","contract":"MetaStablePool","time":0},{"type":"external-function ","before":"entations for that.\n     */\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) {\n        _cachePriceRatesIfNecessary();\n\n        (amountsOut, dueProtocolFeeAmounts) = super.onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData\n        );\n\n        // If the contract is paused, the oracle is not updated to avoid extra calculations and reduce potential errors.\n        if (_isNotPaused()) {\n            _cacheInvar","after":"entations for that.\n     */\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override returns (uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) {\n        _cachePriceRatesIfNecessary();\n\n        (amountsOut, dueProtocolFeeAmounts) = super.onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData\n        );\n\n        // If the contract is paused, the oracle is not updated to avoid extra calculations and reduce potential errors.\n        if (_isNotPaused()) {\n            _cacheInvar","contract":"MetaStablePool","time":0},{"type":"external-function ","before":"function onSwap(\n        SwapRequest memory swapRequest,\n        uint256[] memory balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) public virtual override returns (uint256) {\n        _validateIndexes(indexIn, indexOut, _getTotalTokens());\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        return\n        swapRequest.kind == IVault.SwapKind.GIVEN_IN\n        ? _swapGivenIn(swapRequest, balances, indexIn, indexOut, scalingFactors)\n        : _swapGivenOut(swapRequest, balances, indexIn, indexOut, scalingFactors);\n    }","after":"function onSwap(\n        SwapRequest calldata swapRequest,\n        uint256[] calldata balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) public virtual override returns (uint256) {\n        _validateIndexes(indexIn, indexOut, _getTotalTokens());\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        return\n        swapRequest.kind == IVault.SwapKind.GIVEN_IN\n        ? _swapGivenIn(swapRequest, balances, indexIn, indexOut, scalingFactors)\n        : _swapGivenOut(swapRequest, balances, indexIn, indexOut, scalingFactors);\n    }","contract":"MetaStablePool","time":0},{"type":"external-function ","before":"function setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig)\n    public\n    virtual\n    authenticate\n    whenNotPaused\n    {\n        _setAssetManagerPoolConfig(token, poolConfig);\n    }","after":"function setAssetManagerPoolConfig(IERC20 token, bytes calldata poolConfig)\n    public\n    virtual\n    authenticate\n    whenNotPaused\n    {\n        _setAssetManagerPoolConfig(token, poolConfig);\n    }","contract":"MetaStablePool","time":0},{"type":"external-function ","before":"function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        if (totalSupply() == 0) {\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(\n                poolId,\n                sender,\n                recipient,\n                scalingFactors,\n                userData\n            );\n\n            // On initialization, we lock _MINIMUM_BPT by minting it for the zero address. This BPT acts as a minimum\n            // as it will never be burned, which reduces potential issues with rounding, and also prevents the Pool from\n            // ever being fully drained.\n            _require(bptAmountOut >= _MINIMUM_BPT, Errors.MINIMUM_BPT);\n            _mintPoolTokens(address(0), _MINIMUM_BPT);\n            _mintPoolTokens(recipient, bptAmountOut - _MINIMUM_BPT);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n            return (amountsIn, new uint256[](_getTotalTokens()));\n        } else {\n            _upscaleArray(balances, scalingFactors);\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n            return (amountsIn, dueProtocolFeeAmounts);\n        }\n    }","after":"function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        if (totalSupply() == 0) {\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(\n                poolId,\n                sender,\n                recipient,\n                scalingFactors,\n                userData\n            );\n\n            // On initialization, we lock _MINIMUM_BPT by minting it for the zero address. This BPT acts as a minimum\n            // as it will never be burned, which reduces potential issues with rounding, and also prevents the Pool from\n            // ever being fully drained.\n            _require(bptAmountOut >= _MINIMUM_BPT, Errors.MINIMUM_BPT);\n            _mintPoolTokens(address(0), _MINIMUM_BPT);\n            _mintPoolTokens(recipient, bptAmountOut - _MINIMUM_BPT);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n            return (amountsIn, new uint256[](_getTotalTokens()));\n        } else {\n            _upscaleArray(balances, scalingFactors);\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n            return (amountsIn, dueProtocolFeeAmounts);\n        }\n    }","contract":"MetaStablePool","time":0},{"type":"external-function ","before":"function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            scalingFactors,\n            userData\n        );\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n        _downscaleDownArray(amountsOut, scalingFactors);\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n        return (amountsOut, dueProtocolFeeAmounts);\n    }","after":"function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            scalingFactors,\n            userData\n        );\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n        _downscaleDownArray(amountsOut, scalingFactors);\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n        return (amountsOut, dueProtocolFeeAmounts);\n    }","contract":"MetaStablePool","time":0},{"type":"external-function ","before":"function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptOut, amountsIn);\n    }","after":"function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptOut, amountsIn);\n    }","contract":"MetaStablePool","time":0},{"type":"external-function ","before":"function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptIn, amountsOut);\n    }","after":"function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptIn, amountsOut);\n    }","contract":"MetaStablePool","time":0},{"type":"external-function ","before":" _getOracleIndex());\n    }\n\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n    external\n    view\n    override\n    returns (uint256[] memory results)\n    {\n        results = new uint256[](queries.length);\n        uint256 latestIndex = _getOracleIndex();\n\n        for (uint256 i = 0; i < queries.length; ++i) {\n            results[i] = QueryProcessor.getTimeWeightedAverage(_samples, queries[i","after":" _getOracleIndex());\n    }\n\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n    external\n    view\n    override\n    returns (uint256[] memory results)\n    {\n        results = new uint256[](queries.length);\n        uint256 latestIndex = _getOracleIndex();\n\n        for (uint256 i = 0; i < queries.length; ++i) {\n            results[i] = QueryProcessor.getTimeWeightedAverage(_samples, queries[i","contract":"MetaStablePool","time":0},{"type":"external-function ","before":"estIndex);\n        }\n    }\n\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\n    external\n    view\n    override\n    returns (int256[] memory results)\n    {\n        results = new int256[](queries.length);\n        uint256 latestIndex = _getOracleIndex();\n\n        OracleAccumulatorQuery memory query;\n        for (uint256 i = 0; i < queries.length; ++i) {\n            query = queries[i];\n            results[i] = _getPastAccumulator(query.variable, latestIn","after":"estIndex);\n        }\n    }\n\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\n    external\n    view\n    override\n    returns (int256[] memory results)\n    {\n        results = new int256[](queries.length);\n        uint256 latestIndex = _getOracleIndex();\n\n        OracleAccumulatorQuery memory query;\n        for (uint256 i = 0; i < queries.length; ++i) {\n            query = queries[i];\n            results[i] = _getPastAccumulator(query.variable, latestIn","contract":"MetaStablePool","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"MetaStablePool","time":3},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"MetaStablePool","time":3},{"type":"constant-restrict-modification  ","before":"bytes32 private immutable _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");","after":"bytes32 private immutable constant _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");","contract":"MetaStablePool","time":3},{"type":"external-function ","before":"w `MetaStablePool`.\n     */\n    function create(\n        string memory name,\n        string memory symbol,\n        IERC20[] memory tokens,\n        uint256 amplificationParameter,\n        IRateProvider[] memory rateProviders,\n        uint256[] memory priceRateCacheDuration,\n        uint256 swapFeePercentage,\n        bool oracleEnabled,\n        address owner\n    ) external returns (address) {\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        return\n        _create(\n            abi.encode(\n                MetaStablePool.NewPoolParams({\n            vault : getVault(),\n            name : name,\n            symbol : symbol,\n            tokens : tokens,\n            rateProviders : rateProviders,\n            priceRateCacheDuration : priceRateCacheDuration,\n            amplificationParameter : amplificationParameter,\n            swapFeePercentage : swapFeePercentage,\n            pauseWindowDuration : pauseWindowDuration,\n            bufferPeriodDuration : bufferPeriodDuration,\n            oracleEnabled : oracleEnabled,\n            owner : owner\n            }","after":"w `MetaStablePool`.\n     */\n    function create(\n        string calldata name,\n        string calldata symbol,\n        IERC20[] calldata tokens,\n        uint256 amplificationParameter,\n        IRateProvider[] calldata rateProviders,\n        uint256[] calldata priceRateCacheDuration,\n        uint256 swapFeePercentage,\n        bool oracleEnabled,\n        address owner\n    ) external returns (address) {\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        return\n        _create(\n            abi.encode(\n                MetaStablePool.NewPoolParams({\n            vault : getVault(),\n            name : name,\n            symbol : symbol,\n            tokens : tokens,\n            rateProviders : rateProviders,\n            priceRateCacheDuration : priceRateCacheDuration,\n            amplificationParameter : amplificationParameter,\n            swapFeePercentage : swapFeePercentage,\n            pauseWindowDuration : pauseWindowDuration,\n            bufferPeriodDuration : bufferPeriodDuration,\n            oracleEnabled : oracleEnabled,\n            owner : owner\n            }","contract":"MetaStablePoolFactory","time":0},{"type":"external-function ","before":"ponding to `query`.\n     */\n    function getTimeWeightedAverage(\n        mapping(uint256 => bytes32) storage samples,\n        IPriceOracle.OracleAverageQuery memory query,\n        uint256 latestIndex\n    ) external view returns (uint256) {\n        _require(query.secs != 0, Errors.ORACLE_BAD_SECS);\n\n        int256 beginAccumulator = getPastAccumulator(samples, query.variable, latestIndex, query.ago + query.secs);\n        int256 endAccumulator = getPastAccumulator(samples, query.variable, latestIndex, query.ago);\n        return LogCompression.fromLowResLog((endAccumulator - beginAccumulat","after":"ponding to `query`.\n     */\n    function getTimeWeightedAverage(\n        mapping(uint256 => bytes32) storage samples,\n        IPriceOracle.OracleAverageQuery calldata query,\n        uint256 latestIndex\n    ) external view returns (uint256) {\n        _require(query.secs != 0, Errors.ORACLE_BAD_SECS);\n\n        int256 beginAccumulator = getPastAccumulator(samples, query.variable, latestIndex, query.ago + query.secs);\n        int256 endAccumulator = getPastAccumulator(samples, query.variable, latestIndex, query.ago);\n        return LogCompression.fromLowResLog((endAccumulator - beginAccumulat","contract":"QueryProcessor","time":0}]}