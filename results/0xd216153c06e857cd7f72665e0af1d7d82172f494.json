{"time":191,"results":[{"type":"external-function ","before":"   function registerRelay(uint256 transactionFee, string memory url) public {\n\n        address relay = msg.sender;\n\n\n        require(relay == tx.origin, \"Contracts cannot register as relays\");\n\n        require(relays[relay].state == RelayState.Staked || relays[relay].state == RelayState.Registered, \"wrong state for stake\");\n\n        require(relay.balance >= minimumRelayBalance, \"balance lower than minimum\");\n\n\n        if (relays[relay].state != RelayState.Registered) {\n\n            relays[relay].state = RelayState.Registered;\n\n        }\n\n\n        emit RelayAdded(relay, relays[relay].owner, transactionFee, relays[relay].stake, relays[relay].unstakeDelay, url);\n\n  ","after":"   function registerRelay(uint256 transactionFee, string calldata url) public {\n\n        address relay = msg.sender;\n\n\n        require(relay == tx.origin, \"Contracts cannot register as relays\");\n\n        require(relays[relay].state == RelayState.Staked || relays[relay].state == RelayState.Registered, \"wrong state for stake\");\n\n        require(relay.balance >= minimumRelayBalance, \"balance lower than minimum\");\n\n\n        if (relays[relay].state != RelayState.Registered) {\n\n            relays[relay].state = RelayState.Registered;\n\n        }\n\n\n        emit RelayAdded(relay, relays[relay].owner, transactionFee, relays[relay].stake, relays[relay].unstakeDelay, url);\n\n  ","contract":"RelayHub","time":0},{"type":"external-function ","before":"   function relayCall(\n\n        address from,\n\n        address recipient,\n\n        bytes memory encodedFunction,\n\n        uint256 transactionFee,\n\n        uint256 gasPrice,\n\n        uint256 gasLimit,\n\n        uint256 nonce,\n\n        bytes memory signature,\n\n        bytes memory approvalData\n\n    )\n\n    public\n\n    {\n\n        uint256 initialGas = gasleft();\n\n\n        // Initial soundness checks - the relay must make sure these pass, or it will pay for a reverted transaction.\n\n\n\n        // The relay must be registered\n\n        require(relays[msg.sender].state == RelayState.Registered, \"Unknown relay\");\n\n\n        // A relay may use a higher gas price than the one requested by the signer (to e.g. get the transaction in a\n\n        // block faster), but it must not be lower. The recipient will be charged for the requested gas price, not the\n\n        // one used in the transaction.\n\n        require(gasPrice <= tx.gasprice, \"Invalid gas price\");\n\n\n        // This transaction must have enough gas to forward the call to the recipient with the requested amount, and not\n\n        // run out of gas later in this function.\n\n        require(initialGas >= SafeMath.sub(requiredGas(gasLimit), gasOverhead), \"Not enough gasleft()\");\n\n\n        // We don't yet know how much gas will be used by the recipient, so we make sure there are enough funds to pay\n\n        // for the maximum possible charge.\n\n        require(maxPossibleCharge(gasLimit, gasPrice, transactionFee) <= balances[recipient], \"Recipient balance too low\");\n\n\n        bytes4 functionSelector = LibBytes.readBytes4(encodedFunction, 0);\n\n\n        bytes memory recipientContext;\n\n        {\n\n            // We now verify the legitimacy of the transaction (it must be signed by the sender, and not be replayed),\n\n            // and that the recpient will accept to be charged by it.\n\n            uint256 preconditionCheck;\n\n            (preconditionCheck, recipientContext) = canRelay(msg.sender, from, recipient, encodedFunction, transactionFee, gasPrice, gasLimit, nonce, signature, approvalData);\n\n\n            if (preconditionCheck != uint256(PreconditionCheck.OK)) {\n\n                emit CanRelayFailed(msg.sender, from, recipient, functionSelector, preconditionCheck);\n\n                return;\n\n            }\n\n        }\n\n\n        // From this point on, this transaction will not revert nor run out of gas, and the recipient will be charged\n\n        // for the gas spent.\n\n\n\n        // The sender's nonce is advanced to prevent transaction replays.\n\n        nonces[from]++;\n\n\n        // Calls to the recipient are performed atomically inside an inner transaction which may revert in case of\n\n        // errors in the recipient. In either case (revert or regular execution) the return data encodes the\n\n        // RelayCallStatus value.\n\n        RelayCallStatus status;\n\n        {\n\n            uint256 preChecksGas = initialGas - gasleft();\n\n            bytes memory encodedFunctionWithFrom = abi.encodePacked(encodedFunction, from);\n\n            bytes memory data = abi.encodeWithSelector(this.recipientCallsAtomic.selector, recipient, encodedFunctionWithFrom, transactionFee, gasPrice, gasLimit, preChecksGas, recipientContext);\n\n            (, bytes memory relayCallStatus) = address(this).call(data);\n\n            status = abi.decode(relayCallStatus, (RelayCallStatus));\n\n        }\n\n\n        // We now perform the actual charge calculation, based on the measured gas used\n\n        uint256 charge = calculateCharge(\n\n            getChargeableGas(initialGas - gasleft(), false),\n\n            gasPrice,\n\n            transactionFee\n\n        );\n\n\n        // We've already checked that the recipient has enough balance to pay for the relayed transaction, this is only\n\n        // a sanity check to prevent overflows in case of bugs.\n\n        require(balances[recipient] >= charge, \"Should not get here\");\n\n        balances[recipient] -= charge;\n\n        balances[relays[msg.sender].owner] += charge;\n\n\n        emit TransactionRelayed(msg.sender, from, recipient, functionSelector, status, charge);\n\n  ","after":"   function relayCall(\n\n        address from,\n\n        address recipient,\n\n        bytes calldata encodedFunction,\n\n        uint256 transactionFee,\n\n        uint256 gasPrice,\n\n        uint256 gasLimit,\n\n        uint256 nonce,\n\n        bytes calldata signature,\n\n        bytes calldata approvalData\n\n    )\n\n    public\n\n    {\n\n        uint256 initialGas = gasleft();\n\n\n        // Initial soundness checks - the relay must make sure these pass, or it will pay for a reverted transaction.\n\n\n\n        // The relay must be registered\n\n        require(relays[msg.sender].state == RelayState.Registered, \"Unknown relay\");\n\n\n        // A relay may use a higher gas price than the one requested by the signer (to e.g. get the transaction in a\n\n        // block faster), but it must not be lower. The recipient will be charged for the requested gas price, not the\n\n        // one used in the transaction.\n\n        require(gasPrice <= tx.gasprice, \"Invalid gas price\");\n\n\n        // This transaction must have enough gas to forward the call to the recipient with the requested amount, and not\n\n        // run out of gas later in this function.\n\n        require(initialGas >= SafeMath.sub(requiredGas(gasLimit), gasOverhead), \"Not enough gasleft()\");\n\n\n        // We don't yet know how much gas will be used by the recipient, so we make sure there are enough funds to pay\n\n        // for the maximum possible charge.\n\n        require(maxPossibleCharge(gasLimit, gasPrice, transactionFee) <= balances[recipient], \"Recipient balance too low\");\n\n\n        bytes4 functionSelector = LibBytes.readBytes4(encodedFunction, 0);\n\n\n        bytes memory recipientContext;\n\n        {\n\n            // We now verify the legitimacy of the transaction (it must be signed by the sender, and not be replayed),\n\n            // and that the recpient will accept to be charged by it.\n\n            uint256 preconditionCheck;\n\n            (preconditionCheck, recipientContext) = canRelay(msg.sender, from, recipient, encodedFunction, transactionFee, gasPrice, gasLimit, nonce, signature, approvalData);\n\n\n            if (preconditionCheck != uint256(PreconditionCheck.OK)) {\n\n                emit CanRelayFailed(msg.sender, from, recipient, functionSelector, preconditionCheck);\n\n                return;\n\n            }\n\n        }\n\n\n        // From this point on, this transaction will not revert nor run out of gas, and the recipient will be charged\n\n        // for the gas spent.\n\n\n\n        // The sender's nonce is advanced to prevent transaction replays.\n\n        nonces[from]++;\n\n\n        // Calls to the recipient are performed atomically inside an inner transaction which may revert in case of\n\n        // errors in the recipient. In either case (revert or regular execution) the return data encodes the\n\n        // RelayCallStatus value.\n\n        RelayCallStatus status;\n\n        {\n\n            uint256 preChecksGas = initialGas - gasleft();\n\n            bytes memory encodedFunctionWithFrom = abi.encodePacked(encodedFunction, from);\n\n            bytes memory data = abi.encodeWithSelector(this.recipientCallsAtomic.selector, recipient, encodedFunctionWithFrom, transactionFee, gasPrice, gasLimit, preChecksGas, recipientContext);\n\n            (, bytes memory relayCallStatus) = address(this).call(data);\n\n            status = abi.decode(relayCallStatus, (RelayCallStatus));\n\n        }\n\n\n        // We now perform the actual charge calculation, based on the measured gas used\n\n        uint256 charge = calculateCharge(\n\n            getChargeableGas(initialGas - gasleft(), false),\n\n            gasPrice,\n\n            transactionFee\n\n        );\n\n\n        // We've already checked that the recipient has enough balance to pay for the relayed transaction, this is only\n\n        // a sanity check to prevent overflows in case of bugs.\n\n        require(balances[recipient] >= charge, \"Should not get here\");\n\n        balances[recipient] -= charge;\n\n        balances[relays[msg.sender].owner] += charge;\n\n\n        emit TransactionRelayed(msg.sender, from, recipient, functionSelector, status, charge);\n\n  ","contract":"RelayHub","time":0},{"type":"external-function ","before":"   function penalizeRepeatedNonce(bytes memory unsignedTx1, bytes memory signature1, bytes memory unsignedTx2, bytes memory signature2) public {\n\n        // Can be called by anyone.\n\n        // If a relay attacked the system by signing multiple transactions with the same nonce (so only one is accepted), anyone can grab both transactions from the blockchain and submit them here.\n\n        // Check whether unsignedTx1 != unsignedTx2, that both are signed by the same address, and that unsignedTx1.nonce == unsignedTx2.nonce.  If all conditions are met, relay is considered an \"offending relay\".\n\n        // The offending relay will be unregistered immediately, its stake will be forfeited and given to the address who reported it (msg.sender), thus incentivizing anyone to report offending relays.\n\n        // If reported via a relay, the forfeited stake is split between msg.sender (the relay used for reporting) and the address that reported it.\n\n\n\n        address addr1 = keccak256(abi.encodePacked(unsignedTx1)).recover(signature1);\n\n        address addr2 = keccak256(abi.encodePacked(unsignedTx2)).recover(signature2);\n\n\n        require(addr1 == addr2, \"Different signer\");\n\n\n        Transaction memory decodedTx1 = decodeTransaction(unsignedTx1);\n\n        Transaction memory decodedTx2 = decodeTransaction(unsignedTx2);\n\n\n        //checking that the same nonce is used in both transaction, with both signed by the same address and the actual data is different\n\n        // note: we compare the hash of the tx to save gas over iterating both byte arrays\n\n        require(decodedTx1.nonce == decodedTx2.nonce, \"Different nonce\");\n\n\n        bytes memory dataToCheck1 = abi.encodePacked(decodedTx1.data, decodedTx1.gasLimit, decodedTx1.to, decodedTx1.value);\n\n        bytes memory dataToCheck2 = abi.encodePacked(decodedTx2.data, decodedTx2.gasLimit, decodedTx2.to, decodedTx2.value);\n\n        require(keccak256(dataToCheck1) != keccak256(dataToCheck2), \"tx is equal\");\n\n\n        penalize(addr1);\n\n  ","after":"   function penalizeRepeatedNonce(bytes calldata unsignedTx1, bytes calldata signature1, bytes calldata unsignedTx2, bytes calldata signature2) public {\n\n        // Can be called by anyone.\n\n        // If a relay attacked the system by signing multiple transactions with the same nonce (so only one is accepted), anyone can grab both transactions from the blockchain and submit them here.\n\n        // Check whether unsignedTx1 != unsignedTx2, that both are signed by the same address, and that unsignedTx1.nonce == unsignedTx2.nonce.  If all conditions are met, relay is considered an \"offending relay\".\n\n        // The offending relay will be unregistered immediately, its stake will be forfeited and given to the address who reported it (msg.sender), thus incentivizing anyone to report offending relays.\n\n        // If reported via a relay, the forfeited stake is split between msg.sender (the relay used for reporting) and the address that reported it.\n\n\n\n        address addr1 = keccak256(abi.encodePacked(unsignedTx1)).recover(signature1);\n\n        address addr2 = keccak256(abi.encodePacked(unsignedTx2)).recover(signature2);\n\n\n        require(addr1 == addr2, \"Different signer\");\n\n\n        Transaction memory decodedTx1 = decodeTransaction(unsignedTx1);\n\n        Transaction memory decodedTx2 = decodeTransaction(unsignedTx2);\n\n\n        //checking that the same nonce is used in both transaction, with both signed by the same address and the actual data is different\n\n        // note: we compare the hash of the tx to save gas over iterating both byte arrays\n\n        require(decodedTx1.nonce == decodedTx2.nonce, \"Different nonce\");\n\n\n        bytes memory dataToCheck1 = abi.encodePacked(decodedTx1.data, decodedTx1.gasLimit, decodedTx1.to, decodedTx1.value);\n\n        bytes memory dataToCheck2 = abi.encodePacked(decodedTx2.data, decodedTx2.gasLimit, decodedTx2.to, decodedTx2.value);\n\n        require(keccak256(dataToCheck1) != keccak256(dataToCheck2), \"tx is equal\");\n\n\n        penalize(addr1);\n\n  ","contract":"RelayHub","time":0},{"type":"external-function ","before":"   function penalizeIllegalTransaction(bytes memory unsignedTx, bytes memory signature) public {\n\n        Transaction memory decodedTx = decodeTransaction(unsignedTx);\n\n        if (decodedTx.to == address(this)) {\n\n            bytes4 selector = GsnUtils.getMethodSig(decodedTx.data);\n\n            // Note: If RelayHub's relay API is extended, the selectors must be added to the ones listed here\n\n            require(selector != this.relayCall.selector && selector != this.registerRelay.selector, \"Legal relay transaction\");\n\n        }\n\n\n        address relay = keccak256(abi.encodePacked(unsignedTx)).recover(signature);\n\n\n        penalize(relay);\n\n  ","after":"   function penalizeIllegalTransaction(bytes calldata unsignedTx, bytes calldata signature) public {\n\n        Transaction memory decodedTx = decodeTransaction(unsignedTx);\n\n        if (decodedTx.to == address(this)) {\n\n            bytes4 selector = GsnUtils.getMethodSig(decodedTx.data);\n\n            // Note: If RelayHub's relay API is extended, the selectors must be added to the ones listed here\n\n            require(selector != this.relayCall.selector && selector != this.registerRelay.selector, \"Legal relay transaction\");\n\n        }\n\n\n        address relay = keccak256(abi.encodePacked(unsignedTx)).recover(signature);\n\n\n        penalize(relay);\n\n  ","contract":"RelayHub","time":0},{"type":"constant-restrict-modification  ","before":"   string public version = \"1.0.","after":"   string public constant version = \"1.0.","contract":"RelayHub","time":0}]}