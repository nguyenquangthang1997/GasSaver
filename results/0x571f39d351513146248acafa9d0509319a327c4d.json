{"time":385,"results":[{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC20","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC20","time":0},{"type":"state-data-arrangement ","before":"\nstring public constant name = \"hats.finance\";\nstring public constant symbol = \"HAT\";\nuint8 public constant decimals = 18;\nuint public override totalSupply;\naddress public governance;\naddress public governancePending;\nuint256 public setGovernancePendingAt;\nuint256 public immutable timeLockDelay;\nuint256 public constant CAP = 10000000e18;\nmapping(address => uint256) public minters;\nmapping(address => PendingMinter) public pendingMinters;\nmapping(address => mapping(address => uint96)) internal allowances;\nmapping(address => uint96) internal balances;\nmapping(address => address) public delegates;\nmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\nmapping(address => uint32) public numCheckpoints;\nmapping(address => uint) public nonces;\nbytes32 public constant DOMAIN_TYPEHASH =\n    keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\nbytes32 public constant DELEGATION_TYPEHASH =\n    keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\nbytes32 public constant PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");","after":"string public constant name = \"hats.finance\";\nstring public constant symbol = \"HAT\";\nuint public override totalSupply;\nuint256 public setGovernancePendingAt;\nuint256 public immutable timeLockDelay;\nuint256 public constant CAP = 10000000e18;\nmapping(address => uint256) public minters;\nmapping(address => PendingMinter) public pendingMinters;\nmapping(address => mapping(address => uint96)) internal allowances;\nmapping(address => uint96) internal balances;\nmapping(address => address) public delegates;\nmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\nmapping(address => uint32) public numCheckpoints;\nmapping(address => uint) public nonces;\nbytes32 public constant DOMAIN_TYPEHASH =\n    keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\nbytes32 public constant DELEGATION_TYPEHASH =\n    keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\nbytes32 public constant PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\naddress public governance;\naddress public governancePending;\nuint8 public constant decimals = 18;\n","contract":"HATToken","time":0},{"type":"external-function ","before":"function claim(string memory _descriptionHash) external payable {\n        if (generalParameters.claimFee > 0) {\n            require(msg.value >= generalParameters.claimFee, \"not enough fee payed\");\n            // solhint-disable-next-line indent\n            payable(governance()).transfer(msg.value);\n        }\n        emit Claim(msg.sender, _descriptionHash);\n    }","after":"function claim(string calldata _descriptionHash) external payable {\n        if (generalParameters.claimFee > 0) {\n            require(msg.value >= generalParameters.claimFee, \"not enough fee payed\");\n            // solhint-disable-next-line indent\n            payable(governance()).transfer(msg.value);\n        }\n        emit Claim(msg.sender, _descriptionHash);\n    }","contract":"HATVaults","time":0},{"type":"external-function ","before":"function setRewardsSplit(uint256 _pid, RewardsSplit memory _rewardsSplit)\n    external\n    onlyGovernance noPendingApproval(_pid) noSafetyPeriod {\n        validateSplit(_rewardsSplit);\n        poolsRewards[_pid].rewardsSplit = _rewardsSplit;\n        emit SetRewardsSplit(_pid, _rewardsSplit);\n    }","after":"function setRewardsSplit(uint256 _pid, RewardsSplit calldata _rewardsSplit)\n    external\n    onlyGovernance noPendingApproval(_pid) noSafetyPeriod {\n        validateSplit(_rewardsSplit);\n        poolsRewards[_pid].rewardsSplit = _rewardsSplit;\n        emit SetRewardsSplit(_pid, _rewardsSplit);\n    }","contract":"HATVaults","time":0},{"type":"external-function ","before":"function setPendingRewardsLevels(uint256 _pid, uint256[] memory _rewardsLevels)\n    external\n    onlyCommittee(_pid) noPendingApproval(_pid) {\n        pendingRewardsLevels[_pid].rewardsLevels = checkRewardsLevels(_rewardsLevels);\n        // solhint-disable-next-line not-rely-on-time\n        pendingRewardsLevels[_pid].timestamp = block.timestamp;\n        emit PendingRewardsLevelsLog(_pid, _rewardsLevels, pendingRewardsLevels[_pid].timestamp);\n    }","after":"function setPendingRewardsLevels(uint256 _pid, uint256[] calldata _rewardsLevels)\n    external\n    onlyCommittee(_pid) noPendingApproval(_pid) {\n        pendingRewardsLevels[_pid].rewardsLevels = checkRewardsLevels(_rewardsLevels);\n        // solhint-disable-next-line not-rely-on-time\n        pendingRewardsLevels[_pid].timestamp = block.timestamp;\n        emit PendingRewardsLevelsLog(_pid, _rewardsLevels, pendingRewardsLevels[_pid].timestamp);\n    }","contract":"HATVaults","time":0},{"type":"external-function ","before":"function addPool(uint256 _allocPoint,\n        address _lpToken,\n        address _committee,\n        uint256[] memory _rewardsLevels,\n        RewardsSplit memory _rewardsSplit,\n        string memory _descriptionHash,\n        uint256[2] memory _rewardVestingParams)\n    external\n    onlyGovernance {\n        require(_rewardVestingParams[0] < 120 days, \"vesting duration is too long\");\n        require(_rewardVestingParams[1] > 0, \"vesting periods cannot be zero\");\n        require(_rewardVestingParams[0] >= _rewardVestingParams[1], \"vesting duration smaller than periods\");\n        require(_committee != address(0), \"committee is zero\");\n        add(_allocPoint, IERC20(_lpToken));\n        uint256 poolId = poolInfo.length - 1;\n        committees[poolId] = _committee;\n        uint256[] memory rewardsLevels = checkRewardsLevels(_rewardsLevels);\n\n        RewardsSplit memory rewardsSplit = (_rewardsSplit.hackerVestedReward == 0 && _rewardsSplit.hackerReward == 0) ?\n        getDefaultRewardsSplit() : _rewardsSplit;\n\n        validateSplit(rewardsSplit);\n        poolsRewards[poolId] = PoolReward({\n        rewardsLevels : rewardsLevels,\n        rewardsSplit : rewardsSplit,\n        committeeCheckIn : false,\n        vestingDuration : _rewardVestingParams[0],\n        vestingPeriods : _rewardVestingParams[1]\n        });\n\n        emit AddPool(poolId,\n            _allocPoint,\n            address(_lpToken),\n            _committee,\n            _descriptionHash,\n            rewardsLevels,\n            rewardsSplit,\n            _rewardVestingParams[0],\n            _rewardVestingParams[1]);\n    }","after":"function addPool(uint256 _allocPoint,\n        address _lpToken,\n        address _committee,\n        uint256[] calldata _rewardsLevels,\n        RewardsSplit calldata _rewardsSplit,\n        string calldata _descriptionHash,\n        uint256[2] calldata _rewardVestingParams)\n    external\n    onlyGovernance {\n        require(_rewardVestingParams[0] < 120 days, \"vesting duration is too long\");\n        require(_rewardVestingParams[1] > 0, \"vesting periods cannot be zero\");\n        require(_rewardVestingParams[0] >= _rewardVestingParams[1], \"vesting duration smaller than periods\");\n        require(_committee != address(0), \"committee is zero\");\n        add(_allocPoint, IERC20(_lpToken));\n        uint256 poolId = poolInfo.length - 1;\n        committees[poolId] = _committee;\n        uint256[] memory rewardsLevels = checkRewardsLevels(_rewardsLevels);\n\n        RewardsSplit memory rewardsSplit = (_rewardsSplit.hackerVestedReward == 0 && _rewardsSplit.hackerReward == 0) ?\n        getDefaultRewardsSplit() : _rewardsSplit;\n\n        validateSplit(rewardsSplit);\n        poolsRewards[poolId] = PoolReward({\n        rewardsLevels : rewardsLevels,\n        rewardsSplit : rewardsSplit,\n        committeeCheckIn : false,\n        vestingDuration : _rewardVestingParams[0],\n        vestingPeriods : _rewardVestingParams[1]\n        });\n\n        emit AddPool(poolId,\n            _allocPoint,\n            address(_lpToken),\n            _committee,\n            _descriptionHash,\n            rewardsLevels,\n            rewardsSplit,\n            _rewardVestingParams[0],\n            _rewardVestingParams[1]);\n    }","contract":"HATVaults","time":0},{"type":"external-function ","before":"function setPool(uint256 _pid,\n        uint256 _allocPoint,\n        bool _registered,\n        bool _depositPause,\n        string memory _descriptionHash)\n    external onlyGovernance {\n        require(poolInfo[_pid].lpToken != IERC20(address(0)), \"pool does not exist\");\n        set(_pid, _allocPoint);\n        poolDepositPause[_pid] = _depositPause;\n        emit SetPool(_pid, _allocPoint, _registered, _descriptionHash);\n    }","after":"function setPool(uint256 _pid,\n        uint256 _allocPoint,\n        bool _registered,\n        bool _depositPause,\n        string calldata _descriptionHash)\n    external onlyGovernance {\n        require(poolInfo[_pid].lpToken != IERC20(address(0)), \"pool does not exist\");\n        set(_pid, _allocPoint);\n        poolDepositPause[_pid] = _depositPause;\n        emit SetPool(_pid, _allocPoint, _registered, _descriptionHash);\n    }","contract":"HATVaults","time":0},{"type":"external-function ","before":"function swapBurnSend(uint256 _pid,\n        address _beneficiary,\n        uint256 _amountOutMinimum,\n        uint24[2] memory _fees)\n    external\n    onlyGovernance {\n        IERC20 token = poolInfo[_pid].lpToken;\n        uint256 amountToSwapAndBurn = swapAndBurns[address(token)];\n        uint256 amountForHackersHatRewards = hackersHatRewards[_beneficiary][address(token)];\n        uint256 amount = amountToSwapAndBurn.add(amountForHackersHatRewards).add(governanceHatRewards[address(token)]);\n        require(amount > 0, \"amount is zero\");\n        swapAndBurns[address(token)] = 0;\n        governanceHatRewards[address(token)] = 0;\n        hackersHatRewards[_beneficiary][address(token)] = 0;\n        uint256 hatsReceived = swapTokenForHAT(amount, token, _fees, _amountOutMinimum);\n        uint256 burntHats = hatsReceived.mul(amountToSwapAndBurn).div(amount);\n        if (burntHats > 0) {\n            HAT.burn(burntHats);\n        }\n        emit SwapAndBurn(_pid, amount, burntHats);\n        address tokenLock;\n        uint256 hackerReward = hatsReceived.mul(amountForHackersHatRewards).div(amount);\n        if (hackerReward > 0) {\n            //hacker get its reward via vesting contract\n            tokenLock = tokenLockFactory.createTokenLock(\n                address(HAT),\n                0x000000000000000000000000000000000000dEaD, //this address as owner, so it can do nothing.\n                _beneficiary,\n                hackerReward,\n            // solhint-disable-next-line not-rely-on-time\n                block.timestamp, //start\n            // solhint-disable-next-line not-rely-on-time\n                block.timestamp + generalParameters.hatVestingDuration, //end\n                generalParameters.hatVestingPeriods,\n                0, //no release start\n                0, //no cliff\n                ITokenLock.Revocability.Disabled,\n                true\n            );\n            HAT.transfer(tokenLock, hackerReward);\n        }\n        emit SwapAndSend(_pid, _beneficiary, amount, hackerReward, tokenLock);\n        HAT.transfer(governance(), hatsReceived.sub(hackerReward).sub(burntHats));\n    }","after":"function swapBurnSend(uint256 _pid,\n        address _beneficiary,\n        uint256 _amountOutMinimum,\n        uint24[2] calldata _fees)\n    external\n    onlyGovernance {\n        IERC20 token = poolInfo[_pid].lpToken;\n        uint256 amountToSwapAndBurn = swapAndBurns[address(token)];\n        uint256 amountForHackersHatRewards = hackersHatRewards[_beneficiary][address(token)];\n        uint256 amount = amountToSwapAndBurn.add(amountForHackersHatRewards).add(governanceHatRewards[address(token)]);\n        require(amount > 0, \"amount is zero\");\n        swapAndBurns[address(token)] = 0;\n        governanceHatRewards[address(token)] = 0;\n        hackersHatRewards[_beneficiary][address(token)] = 0;\n        uint256 hatsReceived = swapTokenForHAT(amount, token, _fees, _amountOutMinimum);\n        uint256 burntHats = hatsReceived.mul(amountToSwapAndBurn).div(amount);\n        if (burntHats > 0) {\n            HAT.burn(burntHats);\n        }\n        emit SwapAndBurn(_pid, amount, burntHats);\n        address tokenLock;\n        uint256 hackerReward = hatsReceived.mul(amountForHackersHatRewards).div(amount);\n        if (hackerReward > 0) {\n            //hacker get its reward via vesting contract\n            tokenLock = tokenLockFactory.createTokenLock(\n                address(HAT),\n                0x000000000000000000000000000000000000dEaD, //this address as owner, so it can do nothing.\n                _beneficiary,\n                hackerReward,\n            // solhint-disable-next-line not-rely-on-time\n                block.timestamp, //start\n            // solhint-disable-next-line not-rely-on-time\n                block.timestamp + generalParameters.hatVestingDuration, //end\n                generalParameters.hatVestingPeriods,\n                0, //no release start\n                0, //no cliff\n                ITokenLock.Revocability.Disabled,\n                true\n            );\n            HAT.transfer(tokenLock, hackerReward);\n        }\n        emit SwapAndSend(_pid, _beneficiary, amount, hackerReward, tokenLock);\n        HAT.transfer(governance(), hatsReceived.sub(hackerReward).sub(burntHats));\n    }","contract":"HATVaults","time":0}]}