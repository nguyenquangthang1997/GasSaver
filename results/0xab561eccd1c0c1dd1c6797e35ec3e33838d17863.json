{"time":269,"results":[{"type":"loop-calculation","before":"HistoricVotes[] storage voteHistory = dials[dialId].voteHistory;","after":"// move outside for loop\nHistoricVotes[] storage voteHistory = dials[dialId].voteHistory;","loc":{"start":{"line":914,"column":12},"end":{"line":914,"column":75}},"contract":"EmissionsController","time":0},{"type":"state-data-arrangement ","before":"\nuint32 constant DISTRIBUTION_PERIOD = 1 weeks;\nuint256 constant SCALE = 200;\nint256 immutable A;\nint256 immutable B;\nint256 immutable C;\nint256 immutable D;\nuint128 immutable EPOCHS;\nIERC20 public immutable REWARD_TOKEN;\nEpochHistory public epochs;\nmapping(address => uint32) public stakingContractAddTime;\nIVotes[] public stakingContracts;\nDialData[] public dials;\nmapping(address => VoterPreferences) public voterPreferences;","after":"uint256 constant SCALE = 200;\nint256 immutable A;\nint256 immutable B;\nint256 immutable C;\nint256 immutable D;\nIERC20 public immutable REWARD_TOKEN;\nEpochHistory public epochs;\nmapping(address => uint32) public stakingContractAddTime;\nIVotes[] public stakingContracts;\nDialData[] public dials;\nmapping(address => VoterPreferences) public voterPreferences;\nuint128 immutable EPOCHS;\nuint32 constant DISTRIBUTION_PERIOD = 1 weeks;\n","contract":"EmissionsController","time":0},{"type":"external-function ","before":"function initialize(\n        address[] memory _recipients,\n        uint8[] memory _caps,\n        bool[] memory _notifies,\n        address[] memory _stakingContracts\n    ) external initializer {\n        uint256 len = _recipients.length;\n        require(_notifies.length == len && _caps.length == len, \"Initialize args mismatch\");\n\n        // 1.0 - Set the last epoch storage variable to the immutable start epoch\n        //       Set the weekly epoch this contract starts distributions which will be 1 - 2 week after deployment.\n        uint32 startEpoch = _epoch(block.timestamp) + 1;\n        epochs = EpochHistory({startEpoch : startEpoch, lastEpoch : startEpoch});\n\n        // 2.0 - Add each of the dials\n        for (uint256 i = 0; i < len; i++) {\n            _addDial(_recipients[i], _caps[i], _notifies[i]);\n        }\n\n        // 3.0 - Initialize the staking contracts\n        for (uint256 i = 0; i < _stakingContracts.length; i++) {\n            _addStakingContract(_stakingContracts[i]);\n        }\n    }","after":"function initialize(\n        address[] calldata _recipients,\n        uint8[] calldata _caps,\n        bool[] calldata _notifies,\n        address[] calldata _stakingContracts\n    ) external initializer {\n        uint256 len = _recipients.length;\n        require(_notifies.length == len && _caps.length == len, \"Initialize args mismatch\");\n\n        // 1.0 - Set the last epoch storage variable to the immutable start epoch\n        //       Set the weekly epoch this contract starts distributions which will be 1 - 2 week after deployment.\n        uint32 startEpoch = _epoch(block.timestamp) + 1;\n        epochs = EpochHistory({startEpoch : startEpoch, lastEpoch : startEpoch});\n\n        // 2.0 - Add each of the dials\n        for (uint256 i = 0; i < len; i++) {\n            _addDial(_recipients[i], _caps[i], _notifies[i]);\n        }\n\n        // 3.0 - Initialize the staking contracts\n        for (uint256 i = 0; i < _stakingContracts.length; i++) {\n            _addStakingContract(_stakingContracts[i]);\n        }\n    }","contract":"EmissionsController","time":0},{"type":"external-function ","before":"function donate(uint256[] memory _dialIds, uint256[] memory _amounts) external {\n        uint256 dialLen = _dialIds.length;\n        require(dialLen > 0 && _amounts.length == dialLen, \"Invalid inputs\");\n\n        uint256 totalAmount;\n\n        // For each specified dial\n        uint256 dialId;\n        for (uint256 i = 0; i < dialLen; i++) {\n            dialId = _dialIds[i];\n            require(dialId < dials.length, \"Invalid dial id\");\n\n            // Sum the rewards for each dial\n            totalAmount += _amounts[i];\n            // Add rewards to the dial's rewards balance\n            dials[dialId].balance += SafeCast.toUint96(_amounts[i]);\n\n            emit DonatedRewards(dialId, _amounts[i]);\n        }\n\n        // Transfer the total donated rewards to this Emissions Controller contract\n        REWARD_TOKEN.safeTransferFrom(msg.sender, address(this), totalAmount);\n    }","after":"function donate(uint256[] calldata _dialIds, uint256[] calldata _amounts) external {\n        uint256 dialLen = _dialIds.length;\n        require(dialLen > 0 && _amounts.length == dialLen, \"Invalid inputs\");\n\n        uint256 totalAmount;\n\n        // For each specified dial\n        uint256 dialId;\n        for (uint256 i = 0; i < dialLen; i++) {\n            dialId = _dialIds[i];\n            require(dialId < dials.length, \"Invalid dial id\");\n\n            // Sum the rewards for each dial\n            totalAmount += _amounts[i];\n            // Add rewards to the dial's rewards balance\n            dials[dialId].balance += SafeCast.toUint96(_amounts[i]);\n\n            emit DonatedRewards(dialId, _amounts[i]);\n        }\n\n        // Transfer the total donated rewards to this Emissions Controller contract\n        REWARD_TOKEN.safeTransferFrom(msg.sender, address(this), totalAmount);\n    }","contract":"EmissionsController","time":0},{"type":"external-function ","before":"function distributeRewards(uint256[] memory _dialIds) external {\n        // For each specified dial\n        uint256 len = _dialIds.length;\n        for (uint256 i = 0; i < len; i++) {\n            require(_dialIds[i] < dials.length, \"Invalid dial id\");\n            DialData memory dialData = dials[_dialIds[i]];\n\n            // 1.0 - Get the dial's reward balance\n            if (dialData.balance == 0) {\n                continue;\n            }\n            // 2.0 - Reset the balance in storage back to 0\n            dials[_dialIds[i]].balance = 0;\n\n            // 3.0 - Send the rewards the to the dial recipient\n            REWARD_TOKEN.safeTransfer(dialData.recipient, dialData.balance);\n\n            // 4.0 - Notify the dial of the new rewards if configured to\n            //       Only after successful transer tx\n            if (dialData.notify) {\n                IRewardsDistributionRecipient(dialData.recipient).notifyRewardAmount(\n                    dialData.balance\n                );\n            }\n\n            emit DistributedReward(_dialIds[i], dialData.balance);\n        }\n    }","after":"function distributeRewards(uint256[] calldata _dialIds) external {\n        // For each specified dial\n        uint256 len = _dialIds.length;\n        for (uint256 i = 0; i < len; i++) {\n            require(_dialIds[i] < dials.length, \"Invalid dial id\");\n            DialData memory dialData = dials[_dialIds[i]];\n\n            // 1.0 - Get the dial's reward balance\n            if (dialData.balance == 0) {\n                continue;\n            }\n            // 2.0 - Reset the balance in storage back to 0\n            dials[_dialIds[i]].balance = 0;\n\n            // 3.0 - Send the rewards the to the dial recipient\n            REWARD_TOKEN.safeTransfer(dialData.recipient, dialData.balance);\n\n            // 4.0 - Notify the dial of the new rewards if configured to\n            //       Only after successful transer tx\n            if (dialData.notify) {\n                IRewardsDistributionRecipient(dialData.recipient).notifyRewardAmount(\n                    dialData.balance\n                );\n            }\n\n            emit DistributedReward(_dialIds[i], dialData.balance);\n        }\n    }","contract":"EmissionsController","time":0},{"type":"external-function ","before":"function setVoterDialWeights(Preference[] memory _preferences) external {\n        require(_preferences.length <= 16, \"Max of 16 preferences\");\n\n        // 1.0 - Get staker's previous total votes cast\n        uint256 votesCast = voterPreferences[msg.sender].votesCast;\n        // 1.1 - Adjust dial votes from removed staker votes\n        _moveVotingPower(msg.sender, votesCast, _subtract);\n        //       Clear the old weights as they will be added back below\n        delete voterPreferences[msg.sender];\n\n        // 2.0 - Log new preferences\n        uint256 newTotalWeight;\n        uint256 newDialWeights;\n        for (uint256 i = 0; i < _preferences.length; i++) {\n            require(_preferences[i].dialId < dials.length, \"Invalid dial id\");\n            require(_preferences[i].weight > 0, \"Must give a dial some weight\");\n            newTotalWeight += _preferences[i].weight;\n\n            // Add staker's dial weight\n            newDialWeights |= uint256(_preferences[i].weight) << (i * 16);\n            // Add staker's dial id\n            newDialWeights |= uint256(_preferences[i].dialId) << ((i * 16) + 8);\n        }\n\n        // 2.1 - In the likely scenario less than 16 preferences are given, add a breaker with max uint\n        //       to signal that this is the end of array.\n        if (_preferences.length < 16) {\n            // Set dialId to 255\n            newDialWeights |= uint256(255) << ((_preferences.length * 16) + 8);\n        }\n        require(newTotalWeight <= SCALE, \"Imbalanced weights\");\n        // Update storage with the array of 16 Preferences stored as an uint256\n        voterPreferences[msg.sender].dialWeights = newDialWeights;\n\n        // Need to set before calling _moveVotingPower for the second time\n        voterPreferences[msg.sender].lastSourcePoke = SafeCast.toUint32(block.timestamp);\n\n        // 3.0 - Cast votes on these new preferences\n        _moveVotingPower(msg.sender, getVotes(msg.sender), _add);\n\n        emit PreferencesChanged(msg.sender, _preferences);\n    }","after":"function setVoterDialWeights(Preference[] calldata _preferences) external {\n        require(_preferences.length <= 16, \"Max of 16 preferences\");\n\n        // 1.0 - Get staker's previous total votes cast\n        uint256 votesCast = voterPreferences[msg.sender].votesCast;\n        // 1.1 - Adjust dial votes from removed staker votes\n        _moveVotingPower(msg.sender, votesCast, _subtract);\n        //       Clear the old weights as they will be added back below\n        delete voterPreferences[msg.sender];\n\n        // 2.0 - Log new preferences\n        uint256 newTotalWeight;\n        uint256 newDialWeights;\n        for (uint256 i = 0; i < _preferences.length; i++) {\n            require(_preferences[i].dialId < dials.length, \"Invalid dial id\");\n            require(_preferences[i].weight > 0, \"Must give a dial some weight\");\n            newTotalWeight += _preferences[i].weight;\n\n            // Add staker's dial weight\n            newDialWeights |= uint256(_preferences[i].weight) << (i * 16);\n            // Add staker's dial id\n            newDialWeights |= uint256(_preferences[i].dialId) << ((i * 16) + 8);\n        }\n\n        // 2.1 - In the likely scenario less than 16 preferences are given, add a breaker with max uint\n        //       to signal that this is the end of array.\n        if (_preferences.length < 16) {\n            // Set dialId to 255\n            newDialWeights |= uint256(255) << ((_preferences.length * 16) + 8);\n        }\n        require(newTotalWeight <= SCALE, \"Imbalanced weights\");\n        // Update storage with the array of 16 Preferences stored as an uint256\n        voterPreferences[msg.sender].dialWeights = newDialWeights;\n\n        // Need to set before calling _moveVotingPower for the second time\n        voterPreferences[msg.sender].lastSourcePoke = SafeCast.toUint32(block.timestamp);\n\n        // 3.0 - Cast votes on these new preferences\n        _moveVotingPower(msg.sender, getVotes(msg.sender), _add);\n\n        emit PreferencesChanged(msg.sender, _preferences);\n    }","contract":"EmissionsController","time":0},{"type":"loop-duplication","before":"\nstart line 1805 column 8, end line 1813 column 8\nfor (uint256 i = 0; i < numberStakingContracts; i++) {\n            address stakingContractAddress = EMISSIONS_CONTROLLER.getDialRecipient(\n                stakingDialIds[i]\n            );\n            require(stakingContractAddress != address(0), \"invalid dial id\");\n\n            votingPower[i] = IERC20(stakingContractAddress).totalSupply();\n            totalVotingPower += votingPower[i];\n        }\nstart line 1822 column 8, end line 1824 column 8\nfor (uint256 i = 0; i < numberStakingContracts; i++) {\n            rewardDonationAmounts[i] = (rewardsBal * votingPower[i]) / totalVotingPower;\n        }","after":"// merge loop\n\nstart line 1805 column 8, end line 1813 column 8\nfor (uint256 i = 0; i < numberStakingContracts; i++) {\n            address stakingContractAddress = EMISSIONS_CONTROLLER.getDialRecipient(\n                stakingDialIds[i]\n            );\n            require(stakingContractAddress != address(0), \"invalid dial id\");\n\n            votingPower[i] = IERC20(stakingContractAddress).totalSupply();\n            totalVotingPower += votingPower[i];\n        }\nstart line 1822 column 8, end line 1824 column 8\nfor (uint256 i = 0; i < numberStakingContracts; i++) {\n            rewardDonationAmounts[i] = (rewardsBal * votingPower[i]) / totalVotingPower;\n        }","contract":"RevenueBuyBack","time":0},{"type":"external-function ","before":"function initialize(uint16[] memory _stakingDialIds) external initializer {\n        for (uint256 i = 0; i < _stakingDialIds.length; i++) {\n            _addStakingContract(_stakingDialIds[i]);\n        }\n    }","after":"function initialize(uint16[] calldata _stakingDialIds) external initializer {\n        for (uint256 i = 0; i < _stakingDialIds.length; i++) {\n            _addStakingContract(_stakingDialIds[i]);\n        }\n    }","contract":"RevenueBuyBack","time":0}]}