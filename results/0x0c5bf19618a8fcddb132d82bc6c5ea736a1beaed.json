{"time":105,"results":[{"type":"external-function ","before":"function dispatchMultiple(address[] memory cTokens) external nonReentrant {\n        for (uint i = 0; i < cTokens.length; i++) {\n            dispatch(cTokens[i], true);\n        }\n        IBurner(usdcBurner).burn(usdcAddress);\n    }","after":"function dispatchMultiple(address[] calldata cTokens) external nonReentrant {\n        for (uint i = 0; i < cTokens.length; i++) {\n            dispatch(cTokens[i], true);\n        }\n        IBurner(usdcBurner).burn(usdcAddress);\n    }","contract":"ReserveManager","time":0},{"type":"external-function ","before":"function setBlocked(address[] memory cTokens, bool[] memory blocked) external onlyOwner {\n        require(cTokens.length == blocked.length, \"invalid data\");\n\n        for (uint i = 0; i < cTokens.length; i++) {\n            bool wasBlocked = isBlocked[cTokens[i]];\n            isBlocked[cTokens[i]] = blocked[i];\n\n            emit MarketBlocked(cTokens[i], wasBlocked, blocked[i]);\n        }\n    }","after":"function setBlocked(address[] calldata cTokens, bool[] calldata blocked) external onlyOwner {\n        require(cTokens.length == blocked.length, \"invalid data\");\n\n        for (uint i = 0; i < cTokens.length; i++) {\n            bool wasBlocked = isBlocked[cTokens[i]];\n            isBlocked[cTokens[i]] = blocked[i];\n\n            emit MarketBlocked(cTokens[i], wasBlocked, blocked[i]);\n        }\n    }","contract":"ReserveManager","time":0},{"type":"external-function ","before":"function setCTokenAdmins(address[] memory cTokens, address[] memory newCTokenAdmins) external onlyOwner {\n        require(cTokens.length == newCTokenAdmins.length, \"invalid data\");\n\n        for (uint i = 0; i < cTokens.length; i++) {\n            require(comptroller.isMarketListed(cTokens[i]), \"market not listed\");\n            require(ICToken(cTokens[i]).admin() == newCTokenAdmins[i], \"mismatch cToken admin\");\n\n            address oldAdmin = cTokenAdmins[cTokens[i]];\n            cTokenAdmins[cTokens[i]] = newCTokenAdmins[i];\n\n            emit CTokenAdminUpdated(cTokens[i], oldAdmin, newCTokenAdmins[i]);\n        }\n    }","after":"function setCTokenAdmins(address[] calldata cTokens, address[] calldata newCTokenAdmins) external onlyOwner {\n        require(cTokens.length == newCTokenAdmins.length, \"invalid data\");\n\n        for (uint i = 0; i < cTokens.length; i++) {\n            require(comptroller.isMarketListed(cTokens[i]), \"market not listed\");\n            require(ICToken(cTokens[i]).admin() == newCTokenAdmins[i], \"mismatch cToken admin\");\n\n            address oldAdmin = cTokenAdmins[cTokens[i]];\n            cTokenAdmins[cTokens[i]] = newCTokenAdmins[i];\n\n            emit CTokenAdminUpdated(cTokens[i], oldAdmin, newCTokenAdmins[i]);\n        }\n    }","contract":"ReserveManager","time":0},{"type":"external-function ","before":"function setBurners(address[] memory cTokens, address[] memory newBurners) external onlyOwner {\n        require(cTokens.length == newBurners.length, \"invalid data\");\n\n        for (uint i = 0; i < cTokens.length; i++) {\n            address oldBurner = burners[cTokens[i]];\n            burners[cTokens[i]] = newBurners[i];\n\n            emit BurnerUpdated(cTokens[i], oldBurner, newBurners[i]);\n        }\n    }","after":"function setBurners(address[] calldata cTokens, address[] calldata newBurners) external onlyOwner {\n        require(cTokens.length == newBurners.length, \"invalid data\");\n\n        for (uint i = 0; i < cTokens.length; i++) {\n            address oldBurner = burners[cTokens[i]];\n            burners[cTokens[i]] = newBurners[i];\n\n            emit BurnerUpdated(cTokens[i], oldBurner, newBurners[i]);\n        }\n    }","contract":"ReserveManager","time":0},{"type":"external-function ","before":"function setManualBurn(address[] memory cTokens, bool[] memory manual) external onlyOwner {\n        require(cTokens.length == manual.length, \"invalid data\");\n\n        for (uint i = 0; i < cTokens.length; i++) {\n            bool wasManual = manualBurn[cTokens[i]];\n            manualBurn[cTokens[i]] = manual[i];\n\n            emit MarketManualBurn(cTokens[i], wasManual, manual[i]);\n        }\n    }","after":"function setManualBurn(address[] calldata cTokens, bool[] calldata manual) external onlyOwner {\n        require(cTokens.length == manual.length, \"invalid data\");\n\n        for (uint i = 0; i < cTokens.length; i++) {\n            bool wasManual = manualBurn[cTokens[i]];\n            manualBurn[cTokens[i]] = manual[i];\n\n            emit MarketManualBurn(cTokens[i], wasManual, manual[i]);\n        }\n    }","contract":"ReserveManager","time":0}]}