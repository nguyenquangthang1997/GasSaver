{"time":220,"results":[{"type":"immutable-restrict-modification ","before":"address private caller;","after":"address private immutable caller;","contract":"HBTCLogic","time":0},{"type":"immutable-restrict-modification ","before":"address private caller;","after":"address private immutable caller;","contract":"HBTCStorage","time":0},{"type":"constant-restrict-modification  ","before":"uint256 MaxItemAdressNum = 255;","after":"uint256 constant MaxItemAdressNum = 255;","contract":"HBTCStorage","time":0},{"type":"external-function ","before":"function mint(address to, uint256 value, string memory proof, bytes32 taskHash) public whenNotPaused returns (bool){\n        require(itemAddressExists(OPERATORHASH, msg.sender), \"wrong operator\");\n        uint256 status = logic.mintLogic(value, to, proof, taskHash, msg.sender, operatorRequireNum);\n        if (status == 1) {\n            emit Minting(to, value, proof, msg.sender);\n        } else if (status == 3) {\n            emit Minting(to, value, proof, msg.sender);\n            emit Minted(to, value, proof);\n            emit Transfer(address(0x0), to, value);\n        }\n        return true;\n    }","after":"function mint(address to, uint256 value, string calldata proof, bytes32 taskHash) public whenNotPaused returns (bool){\n        require(itemAddressExists(OPERATORHASH, msg.sender), \"wrong operator\");\n        uint256 status = logic.mintLogic(value, to, proof, taskHash, msg.sender, operatorRequireNum);\n        if (status == 1) {\n            emit Minting(to, value, proof, msg.sender);\n        } else if (status == 3) {\n            emit Minting(to, value, proof, msg.sender);\n            emit Minted(to, value, proof);\n            emit Transfer(address(0x0), to, value);\n        }\n        return true;\n    }","contract":"HBTCToken","time":0},{"type":"external-function ","before":"function burn(address from, uint256 value, string memory btcAddress, string memory proof, bytes32 taskHash)\n    public whenNotPaused returns (bool){\n        require(itemAddressExists(OPERATORHASH, msg.sender), \"wrong operator\");\n        uint256 status = logic.burnLogic(from, value, btcAddress, proof, taskHash, msg.sender, operatorRequireNum);\n        if (status == 1) {\n            emit Burning(from, value, proof, btcAddress, msg.sender);\n        } else if (status == 3) {\n            emit Burning(from, value, proof, btcAddress, msg.sender);\n            emit Burned(from, value, proof, btcAddress);\n            emit Transfer(from, address(0x0), value);\n        }\n        return true;\n    }","after":"function burn(address from, uint256 value, string calldata btcAddress, string calldata proof, bytes32 taskHash)\n    public whenNotPaused returns (bool){\n        require(itemAddressExists(OPERATORHASH, msg.sender), \"wrong operator\");\n        uint256 status = logic.burnLogic(from, value, btcAddress, proof, taskHash, msg.sender, operatorRequireNum);\n        if (status == 1) {\n            emit Burning(from, value, proof, btcAddress, msg.sender);\n        } else if (status == 3) {\n            emit Burning(from, value, proof, btcAddress, msg.sender);\n            emit Burned(from, value, proof, btcAddress);\n            emit Transfer(from, address(0x0), value);\n        }\n        return true;\n    }","contract":"HBTCToken","time":0},{"type":"external-function ","before":"function modifyAdminAddress(string memory class, address oldAddress, address newAddress) public whenPaused {\n        require(newAddress != address(0x0), \"wrong address\");\n        bool flag = modifyAddress(class, oldAddress, newAddress);\n        if (flag) {\n            bytes32 classHash = keccak256(abi.encodePacked(class));\n            if (classHash == LOGICHASH) {\n                logic = HBTCLogic(newAddress);\n            } else if (classHash == STOREHASH) {\n                logic.resetStoreLogic(newAddress);\n            }\n        }\n    }","after":"function modifyAdminAddress(string calldata class, address oldAddress, address newAddress) public whenPaused {\n        require(newAddress != address(0x0), \"wrong address\");\n        bool flag = modifyAddress(class, oldAddress, newAddress);\n        if (flag) {\n            bytes32 classHash = keccak256(abi.encodePacked(class));\n            if (classHash == LOGICHASH) {\n                logic = HBTCLogic(newAddress);\n            } else if (classHash == STOREHASH) {\n                logic.resetStoreLogic(newAddress);\n            }\n        }\n    }","contract":"HBTCToken","time":0},{"type":"external-function ","before":"function getAdminAddresses(string memory class) public view returns (address[] memory) {\n        bytes32 classHash = getClassHash(class);\n        return getItemAddresses(classHash);\n    }","after":"function getAdminAddresses(string calldata class) public view returns (address[] memory) {\n        bytes32 classHash = getClassHash(class);\n        return getItemAddresses(classHash);\n    }","contract":"HBTCToken","time":0},{"type":"external-function ","before":"function resetRequiredNum(string memory class, uint256 requiredNum)\n    public onlyOwner returns (bool){\n        bytes32 classHash = getClassHash(class);\n        require((classHash == OPERATORHASH) || (classHash == OWNERHASH), \"wrong class\");\n        if (classHash == OWNERHASH)\n            require(requiredNum <= getItemAddressCount(OWNERHASH), \"num larger than existed owners\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"resetRequiredNum\", class, requiredNum));\n        addItemAddress(taskHash, msg.sender);\n\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            removeItem(taskHash);\n            uint256 previousNum = 0;\n            if (classHash == OWNERHASH) {\n                previousNum = ownerRequireNum;\n                ownerRequireNum = requiredNum;\n            }\n            else if (classHash == OPERATORHASH) {\n                previousNum = operatorRequireNum;\n                operatorRequireNum = requiredNum;\n            } else {\n                revert(\"wrong class\");\n            }\n            emit AdminRequiredNumChanged(\"resetRequiredNum\", class, previousNum, requiredNum);\n        }\n        return true;\n    }","after":"function resetRequiredNum(string calldata class, uint256 requiredNum)\n    public onlyOwner returns (bool){\n        bytes32 classHash = getClassHash(class);\n        require((classHash == OPERATORHASH) || (classHash == OWNERHASH), \"wrong class\");\n        if (classHash == OWNERHASH)\n            require(requiredNum <= getItemAddressCount(OWNERHASH), \"num larger than existed owners\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"resetRequiredNum\", class, requiredNum));\n        addItemAddress(taskHash, msg.sender);\n\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            removeItem(taskHash);\n            uint256 previousNum = 0;\n            if (classHash == OWNERHASH) {\n                previousNum = ownerRequireNum;\n                ownerRequireNum = requiredNum;\n            }\n            else if (classHash == OPERATORHASH) {\n                previousNum = operatorRequireNum;\n                operatorRequireNum = requiredNum;\n            } else {\n                revert(\"wrong class\");\n            }\n            emit AdminRequiredNumChanged(\"resetRequiredNum\", class, previousNum, requiredNum);\n        }\n        return true;\n    }","contract":"HBTCToken","time":0},{"type":"external-function ","before":"function dropAddress(string memory class, address oneAddress)\n    public onlyOwner returns (bool){\n        bytes32 classHash = getClassHash(class);\n        require(classHash != STOREHASH && classHash != LOGICHASH, \"wrong class\");\n        require(itemAddressExists(classHash, oneAddress), \"no such address exist\");\n\n        if (classHash == OWNERHASH)\n            require(getItemAddressCount(classHash) > ownerRequireNum, \"insuffience addresses\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"dropAddress\", class, oneAddress));\n        addItemAddress(taskHash, msg.sender);\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            removeOneItemAddress(classHash, oneAddress);\n            emit AdminChanged(\"dropAddress\", class, oneAddress, oneAddress);\n            removeItem(taskHash);\n            return true;\n        }\n        return false;\n\n    }","after":"function dropAddress(string calldata class, address oneAddress)\n    public onlyOwner returns (bool){\n        bytes32 classHash = getClassHash(class);\n        require(classHash != STOREHASH && classHash != LOGICHASH, \"wrong class\");\n        require(itemAddressExists(classHash, oneAddress), \"no such address exist\");\n\n        if (classHash == OWNERHASH)\n            require(getItemAddressCount(classHash) > ownerRequireNum, \"insuffience addresses\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"dropAddress\", class, oneAddress));\n        addItemAddress(taskHash, msg.sender);\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            removeOneItemAddress(classHash, oneAddress);\n            emit AdminChanged(\"dropAddress\", class, oneAddress, oneAddress);\n            removeItem(taskHash);\n            return true;\n        }\n        return false;\n\n    }","contract":"HBTCToken","time":0},{"type":"external-function ","before":"function addAddress(string memory class, address oneAddress)\n    public onlyOwner returns (bool){\n        bytes32 classHash = getClassHash(class);\n        require(classHash != STOREHASH && classHash != LOGICHASH, \"wrong class\");\n        require(!itemAddressExists(classHash, oneAddress), \"address existed already\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"addAddress\", class, oneAddress));\n        addItemAddress(taskHash, msg.sender);\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            addItemAddress(classHash, oneAddress);\n            emit AdminChanged(\"addAddress\", class, oneAddress, oneAddress);\n            removeItem(taskHash);\n            return true;\n        }\n        return false;\n    }","after":"function addAddress(string calldata class, address oneAddress)\n    public onlyOwner returns (bool){\n        bytes32 classHash = getClassHash(class);\n        require(classHash != STOREHASH && classHash != LOGICHASH, \"wrong class\");\n        require(!itemAddressExists(classHash, oneAddress), \"address existed already\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"addAddress\", class, oneAddress));\n        addItemAddress(taskHash, msg.sender);\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            addItemAddress(classHash, oneAddress);\n            emit AdminChanged(\"addAddress\", class, oneAddress, oneAddress);\n            removeItem(taskHash);\n            return true;\n        }\n        return false;\n    }","contract":"HBTCToken","time":0},{"type":"constant-restrict-modification  ","before":"uint256 MaxItemAdressNum = 255;","after":"uint256 constant MaxItemAdressNum = 255;","contract":"HBTCToken","time":0},{"type":"immutable-restrict-modification ","before":"address public owner;","after":"address public immutable owner;","contract":"Migrations","time":0}]}