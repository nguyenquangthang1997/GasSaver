{"time":403,"results":[{"type":"de-morgan-condition ","before":"!reserves[_token].isSet || !isActive()","after":"!(reserves[_token].isSet || isActive())","loc":{"start":{"line":2080,"column":16},"end":{"line":2080,"column":53}},"contract":"ConverterBase","time":0},{"type":"state-data-arrangement ","before":"\nuint32 internal constant WEIGHT_RESOLUTION = 1000000;\nuint64 internal constant CONVERSION_FEE_RESOLUTION = 1000000;\naddress internal constant ETH_RESERVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\nuint16 public constant version = 30;\nIConverterAnchor public anchor;\nIWhitelist public conversionWhitelist;\nIERC20Token[] public reserveTokens;\nmapping(address => Reserve) public reserves;\nuint32 public reserveRatio = 0;\nuint32 public maxConversionFee = 0;\nuint32 public conversionFee = 0;\nbool public constant conversionsEnabled = true;","after":"IConverterAnchor public anchor;\nIWhitelist public conversionWhitelist;\nIERC20Token[] public reserveTokens;\nmapping(address => Reserve) public reserves;\naddress internal constant ETH_RESERVE_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\nuint64 internal constant CONVERSION_FEE_RESOLUTION = 1000000;\nuint32 internal constant WEIGHT_RESOLUTION = 1000000;\nuint32 public reserveRatio = 0;\nuint32 public maxConversionFee = 0;\nuint32 public conversionFee = 0;\nuint16 public constant version = 30;\nbool public constant conversionsEnabled = true;\n","contract":"ConverterBase","time":18},{"type":"external-function ","before":"function addLiquidity(IERC20Token[] memory _reserveTokens, uint256[] memory _reserveAmounts, uint256 _minReturn)\n\n    public\n\n    payable\n\n    protected\n\n    active\n\n    {\n\n        // verify the user input\n\n        verifyLiquidityInput(_reserveTokens, _reserveAmounts, _minReturn);\n\n\n        // if one of the reserves is ETH, then verify that the input amount of ETH is equal to the input value of ETH\n\n        for (uint256 i = 0; i < _reserveTokens.length; i++)\n\n            if (_reserveTokens[i] == ETH_RESERVE_ADDRESS)\n\n                require(_reserveAmounts[i] == msg.value, \"ERR_ETH_AMOUNT_MISMATCH\");\n\n\n        // if the input value of ETH is larger than zero, then verify that one of the reserves is ETH\n\n        if (msg.value > 0)\n\n            require(reserves[ETH_RESERVE_ADDRESS].isSet, \"ERR_NO_ETH_RESERVE\");\n\n\n        // get the total supply\n\n        uint256 totalSupply = ISmartToken(anchor).totalSupply();\n\n\n        // transfer from the user an equally-worth amount of each one of the reserve tokens\n\n        uint256 amount = addLiquidityToPool(_reserveTokens, _reserveAmounts, totalSupply);\n\n\n        // verify that the equivalent amount of tokens is equal to or larger than the user's expectation\n\n        require(amount >= _minReturn, \"ERR_RETURN_TOO_LOW\");\n\n\n        // issue the tokens to the user\n\n        ISmartToken(anchor).issue(msg.sender, amount);\n\n    }","after":"function addLiquidity(IERC20Token[] calldata _reserveTokens, uint256[] calldata _reserveAmounts, uint256 _minReturn)\n\n    public\n\n    payable\n\n    protected\n\n    active\n\n    {\n\n        // verify the user input\n\n        verifyLiquidityInput(_reserveTokens, _reserveAmounts, _minReturn);\n\n\n        // if one of the reserves is ETH, then verify that the input amount of ETH is equal to the input value of ETH\n\n        for (uint256 i = 0; i < _reserveTokens.length; i++)\n\n            if (_reserveTokens[i] == ETH_RESERVE_ADDRESS)\n\n                require(_reserveAmounts[i] == msg.value, \"ERR_ETH_AMOUNT_MISMATCH\");\n\n\n        // if the input value of ETH is larger than zero, then verify that one of the reserves is ETH\n\n        if (msg.value > 0)\n\n            require(reserves[ETH_RESERVE_ADDRESS].isSet, \"ERR_NO_ETH_RESERVE\");\n\n\n        // get the total supply\n\n        uint256 totalSupply = ISmartToken(anchor).totalSupply();\n\n\n        // transfer from the user an equally-worth amount of each one of the reserve tokens\n\n        uint256 amount = addLiquidityToPool(_reserveTokens, _reserveAmounts, totalSupply);\n\n\n        // verify that the equivalent amount of tokens is equal to or larger than the user's expectation\n\n        require(amount >= _minReturn, \"ERR_RETURN_TOO_LOW\");\n\n\n        // issue the tokens to the user\n\n        ISmartToken(anchor).issue(msg.sender, amount);\n\n    }","contract":"LiquidityPoolV1Converter","time":0},{"type":"external-function ","before":"function removeLiquidity(uint256 _amount, IERC20Token[] memory _reserveTokens, uint256[] memory _reserveMinReturnAmounts)\n\n    public\n\n    protected\n\n    active\n\n    {\n\n        // verify the user input\n\n        verifyLiquidityInput(_reserveTokens, _reserveMinReturnAmounts, _amount);\n\n\n        // get the total supply BEFORE destroying the user tokens\n\n        uint256 totalSupply = ISmartToken(anchor).totalSupply();\n\n\n        // destroy the user tokens\n\n        ISmartToken(anchor).destroy(msg.sender, _amount);\n\n\n        // transfer to the user an equivalent amount of each one of the reserve tokens\n\n        removeLiquidityFromPool(_reserveTokens, _reserveMinReturnAmounts, totalSupply, _amount);\n\n    }","after":"function removeLiquidity(uint256 _amount, IERC20Token[] calldata _reserveTokens, uint256[] calldata _reserveMinReturnAmounts)\n\n    public\n\n    protected\n\n    active\n\n    {\n\n        // verify the user input\n\n        verifyLiquidityInput(_reserveTokens, _reserveMinReturnAmounts, _amount);\n\n\n        // get the total supply BEFORE destroying the user tokens\n\n        uint256 totalSupply = ISmartToken(anchor).totalSupply();\n\n\n        // destroy the user tokens\n\n        ISmartToken(anchor).destroy(msg.sender, _amount);\n\n\n        // transfer to the user an equivalent amount of each one of the reserve tokens\n\n        removeLiquidityFromPool(_reserveTokens, _reserveMinReturnAmounts, totalSupply, _amount);\n\n    }","contract":"LiquidityPoolV1Converter","time":0},{"type":"immutable-restrict-modification ","before":"uint32 public maxConversionFee = 0;","after":"uint32 public immutable maxConversionFee = 0;","contract":"LiquidityPoolV1Converter","time":2}]}