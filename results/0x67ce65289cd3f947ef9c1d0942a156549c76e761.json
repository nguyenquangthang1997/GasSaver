{"time":731,"results":[{"type":"state-data-arrangement ","before":"\nuint8 internal constant FALSE = 0;\nuint8 internal constant TRUE = 1;\nuint8 internal _locked;\nuint internal _tokenPerHour;\naddress internal _iTrustFactoryAddress;\nuint[] internal _totalSupplyKeys;\nmapping(uint => uint) internal _totalSupplyHistory;\nmapping(address => uint[]) internal _totalStakedKeys;\nmapping(address => mapping(uint => uint)) internal _totalStakedHistory;\nmapping(address => uint) internal _lastClaimedTimes;\nmapping(address => mapping(string => bool)) _UsedNonces;","after":"uint internal _tokenPerHour;\nuint[] internal _totalSupplyKeys;\nmapping(uint => uint) internal _totalSupplyHistory;\nmapping(address => uint[]) internal _totalStakedKeys;\nmapping(address => mapping(uint => uint)) internal _totalStakedHistory;\nmapping(address => uint) internal _lastClaimedTimes;\nmapping(address => mapping(string => bool)) _UsedNonces;\naddress internal _iTrustFactoryAddress;\nuint8 internal constant FALSE = 0;\nuint8 internal constant TRUE = 1;\nuint8 internal _locked;\n","contract":"GovernanceDistribution","time":0},{"type":"external-function ","before":"function withdrawTokens(uint amount, uint claimedUntil, string memory nonce, bytes memory sig) external {\n\n        _nonReentrant();\n\n        require(amount != 0);\n\n        require(claimedUntil != 0);\n\n        require(!_UsedNonces[_msgSender()][nonce]);\n\n        _locked = TRUE;\n\n        bytes32 abiBytes = keccak256(abi.encodePacked(_msgSender(), amount, claimedUntil, nonce, address(this)));\n\n        bytes32 message = _prefixed(abiBytes);\n\n\n        address signer = _recoverSigner(message, sig);\n\n        _isTrustedSigner(signer);\n\n\n        _lastClaimedTimes[_msgSender()] = claimedUntil;\n\n        _UsedNonces[_msgSender()][nonce] = true;\n\n\n        _getiTrustGovernanceToken().transfer(_msgSender(), amount);\n\n        _locked = FALSE;\n\n    }","after":"function withdrawTokens(uint amount, uint claimedUntil, string calldata nonce, bytes calldata sig) external {\n\n        _nonReentrant();\n\n        require(amount != 0);\n\n        require(claimedUntil != 0);\n\n        require(!_UsedNonces[_msgSender()][nonce]);\n\n        _locked = TRUE;\n\n        bytes32 abiBytes = keccak256(abi.encodePacked(_msgSender(), amount, claimedUntil, nonce, address(this)));\n\n        bytes32 message = _prefixed(abiBytes);\n\n\n        address signer = _recoverSigner(message, sig);\n\n        _isTrustedSigner(signer);\n\n\n        _lastClaimedTimes[_msgSender()] = claimedUntil;\n\n        _UsedNonces[_msgSender()][nonce] = true;\n\n\n        _getiTrustGovernanceToken().transfer(_msgSender(), amount);\n\n        _locked = FALSE;\n\n    }","contract":"GovernanceDistribution","time":0},{"type":"struct-data-arrangement ","before":"\naddress tokenAddress\nuint amount\nuint commissionAmount\nuint tokenPerBlock\nuint totalSupply\nbool ignoreUnstakes","after":"uint amount\nuint commissionAmount\nuint tokenPerBlock\nuint totalSupply\naddress tokenAddress\nbool ignoreUnstakes\n","contract":"ITrustVaultLib","time":0},{"type":"external-function ","before":"function endRound(\n\n        address vaultAddress,\n\n        address[] memory tokens,\n\n        uint[] memory tokenAmounts,\n\n        bool[] memory ignoreUnstakes,\n\n        uint totalSupplyForBlockRange,\n\n        uint totalUnstakings,\n\n        uint commissionValue)\n\n    external\n\n    {\n\n        require(_Rounds[vaultAddress][_CurrentRoundNumbers[vaultAddress]].startBlock < block.number);\n\n        uint32 roundNumber = _CurrentRoundNumbers[vaultAddress];\n\n        uint rewardAmount;\n\n        uint commissionAmount;\n\n        uint tokensPerBlock;\n        //Amoun\n\n\n\n        for (uint i = 0; i < tokens.length; i++) {\n\n\n            rewardAmount = tokenAmounts[i].sub(tokenAmounts[i].mul(commissionValue).div(10000));\n\n            commissionAmount = tokenAmounts[i].mul(commissionValue).div(10000);\n\n            tokensPerBlock = VaultLib.divider(rewardAmount, _getAdjustedTotalSupply(totalSupplyForBlockRange, totalUnstakings, ignoreUnstakes[i]), 18);\n\n            VaultLib.RewardTokenRoundData memory tokenData = VaultLib.RewardTokenRoundData(\n\n            {\n\n            tokenAddress : tokens[i],\n\n            amount : rewardAmount,\n\n            commissionAmount : commissionAmount,\n\n            tokenPerBlock : tokensPerBlock, //.div(1e18),\n\n            totalSupply : _getAdjustedTotalSupply(totalSupplyForBlockRange, totalUnstakings, ignoreUnstakes[i]),\n\n            ignoreUnstakes : ignoreUnstakes[i]\n\n            }\n\n            );\n\n\n            _Rounds[vaultAddress][roundNumber].roundData[tokens[i]] = tokenData;\n\n\n            if (_RewardTokens[vaultAddress][tokens[i]] != TRUE) {\n\n                _RewardStartingRounds[vaultAddress][tokens[i]] = roundNumber;\n\n                totalRewardTokenAddresses[vaultAddress].push(tokens[i]);\n\n                _RewardTokens[vaultAddress][tokens[i]] = TRUE;\n\n            }\n\n        }\n\n\n        //do this last\n\n        _Rounds[vaultAddress][_CurrentRoundNumbers[vaultAddress]].endBlock = block.number;\n\n        _CurrentRoundNumbers[vaultAddress]++;\n\n        _Rounds[vaultAddress][_CurrentRoundNumbers[vaultAddress]].startBlock = block.number;\n\n\n    }","after":"function endRound(\n\n        address vaultAddress,\n\n        address[] calldata tokens,\n\n        uint[] calldata tokenAmounts,\n\n        bool[] calldata ignoreUnstakes,\n\n        uint totalSupplyForBlockRange,\n\n        uint totalUnstakings,\n\n        uint commissionValue)\n\n    external\n\n    {\n\n        require(_Rounds[vaultAddress][_CurrentRoundNumbers[vaultAddress]].startBlock < block.number);\n\n        uint32 roundNumber = _CurrentRoundNumbers[vaultAddress];\n\n        uint rewardAmount;\n\n        uint commissionAmount;\n\n        uint tokensPerBlock;\n        //Amoun\n\n\n\n        for (uint i = 0; i < tokens.length; i++) {\n\n\n            rewardAmount = tokenAmounts[i].sub(tokenAmounts[i].mul(commissionValue).div(10000));\n\n            commissionAmount = tokenAmounts[i].mul(commissionValue).div(10000);\n\n            tokensPerBlock = VaultLib.divider(rewardAmount, _getAdjustedTotalSupply(totalSupplyForBlockRange, totalUnstakings, ignoreUnstakes[i]), 18);\n\n            VaultLib.RewardTokenRoundData memory tokenData = VaultLib.RewardTokenRoundData(\n\n            {\n\n            tokenAddress : tokens[i],\n\n            amount : rewardAmount,\n\n            commissionAmount : commissionAmount,\n\n            tokenPerBlock : tokensPerBlock, //.div(1e18),\n\n            totalSupply : _getAdjustedTotalSupply(totalSupplyForBlockRange, totalUnstakings, ignoreUnstakes[i]),\n\n            ignoreUnstakes : ignoreUnstakes[i]\n\n            }\n\n            );\n\n\n            _Rounds[vaultAddress][roundNumber].roundData[tokens[i]] = tokenData;\n\n\n            if (_RewardTokens[vaultAddress][tokens[i]] != TRUE) {\n\n                _RewardStartingRounds[vaultAddress][tokens[i]] = roundNumber;\n\n                totalRewardTokenAddresses[vaultAddress].push(tokens[i]);\n\n                _RewardTokens[vaultAddress][tokens[i]] = TRUE;\n\n            }\n\n        }\n\n\n        //do this last\n\n        _Rounds[vaultAddress][_CurrentRoundNumbers[vaultAddress]].endBlock = block.number;\n\n        _CurrentRoundNumbers[vaultAddress]++;\n\n        _Rounds[vaultAddress][_CurrentRoundNumbers[vaultAddress]].startBlock = block.number;\n\n\n    }","contract":"RoundData","time":0},{"type":"constant-restrict-modification  ","before":"uint8 internal _locked;","after":"uint8 internal constant _locked;","contract":"RoundData","time":0},{"type":"constant-restrict-modification  ","before":"address internal _iTrustFactoryAddress;","after":"address internal constant _iTrustFactoryAddress;","contract":"RoundData","time":0},{"type":"constant-restrict-modification  ","before":"uint8 internal _locked;","after":"uint8 internal constant _locked;","contract":"StakeData","time":2},{"type":"constant-restrict-modification  ","before":"address internal _iTrustFactoryAddress;","after":"address internal constant _iTrustFactoryAddress;","contract":"StakeData","time":2},{"type":"external-function ","before":"function getUnstakingsForBlockRange(\n\n        VaultLib.UnStaking[] memory unStakes,\n\n        uint startBlock,\n\n        uint endBlock) external pure returns (uint){\n\n        return VaultLib.getUnstakingsForBlockRange(\n\n            unStakes,\n\n            startBlock,\n\n            endBlock\n\n        );\n\n    }","after":"function getUnstakingsForBlockRange(\n\n        VaultLib.UnStaking[] calldata unStakes,\n\n        uint startBlock,\n\n        uint endBlock) external pure returns (uint){\n\n        return VaultLib.getUnstakingsForBlockRange(\n\n            unStakes,\n\n            startBlock,\n\n            endBlock\n\n        );\n\n    }","contract":"StakingCalculation","time":0},{"type":"external-function ","before":"function getHoldingsForBlockRange(\n\n        VaultLib.Staking[] memory stakes,\n\n        uint startBlock,\n\n        uint endBlock) external pure returns (uint){\n\n\n        return VaultLib.getHoldingsForBlockRange(\n\n            stakes,\n\n            startBlock,\n\n            endBlock);\n\n    }","after":"function getHoldingsForBlockRange(\n\n        VaultLib.Staking[] calldata stakes,\n\n        uint startBlock,\n\n        uint endBlock) external pure returns (uint){\n\n\n        return VaultLib.getHoldingsForBlockRange(\n\n            stakes,\n\n            startBlock,\n\n            endBlock);\n\n    }","contract":"StakingCalculation","time":0},{"type":"external-function ","before":"function authoriseUnstakes(address[] memory account, uint[] memory timestamp) external returns (bool) {\n\n        _validateVault();\n\n        require(account.length <= 10);\n\n        for (uint8 i = 0; i < account.length; i++) {\n\n            _authoriseUnstake(_vaultAddress(), account[i], timestamp[i]);\n\n        }\n\n        return true;\n\n    }","after":"function authoriseUnstakes(address[] calldata account, uint[] calldata timestamp) external returns (bool) {\n\n        _validateVault();\n\n        require(account.length <= 10);\n\n        for (uint8 i = 0; i < account.length; i++) {\n\n            _authoriseUnstake(_vaultAddress(), account[i], timestamp[i]);\n\n        }\n\n        return true;\n\n    }","contract":"StakingData","time":0},{"type":"external-function ","before":"function withdrawRewards(address account, address[] memory rewardTokens, uint[] memory rewards) external returns (bool) {\n\n        _validateVault();\n\n        _nonReentrant();\n\n        _locked = TRUE;\n\n        _withdrawRewards(_vaultAddress(), rewardTokens, rewards, account);\n\n        _locked = FALSE;\n\n        return true;\n\n    }","after":"function withdrawRewards(address account, address[] calldata rewardTokens, uint[] calldata rewards) external returns (bool) {\n\n        _validateVault();\n\n        _nonReentrant();\n\n        _locked = TRUE;\n\n        _withdrawRewards(_vaultAddress(), rewardTokens, rewards, account);\n\n        _locked = FALSE;\n\n        return true;\n\n    }","contract":"StakingData","time":0},{"type":"loop-duplication","before":"\nstart line 5192 column 8, end line 5200 column 8\nfor (uint x = 0; x < tokens.length; x++) {\n\n            if (rewards[x] != 0) {\n\n                toClaim = true;\n\n            }\n\n        }\nstart line 5219 column 8, end line 5231 column 8\nfor (uint x = 0; x < tokens.length; x++) {\n\n            if (rewards[x] != 0) {\n\n                IERC20Upgradeable token = IERC20Upgradeable(tokens[x]);\n\n                require(token.balanceOf(address(this)) >= rewards[x]);\n\n                require(token.transfer(_msgSender(), rewards[x]));\n\n            }\n\n        }","after":"// merge loop\n\nstart line 5192 column 8, end line 5200 column 8\nfor (uint x = 0; x < tokens.length; x++) {\n\n            if (rewards[x] != 0) {\n\n                toClaim = true;\n\n            }\n\n        }\nstart line 5219 column 8, end line 5231 column 8\nfor (uint x = 0; x < tokens.length; x++) {\n\n            if (rewards[x] != 0) {\n\n                IERC20Upgradeable token = IERC20Upgradeable(tokens[x]);\n\n                require(token.balanceOf(address(this)) >= rewards[x]);\n\n                require(token.transfer(_msgSender(), rewards[x]));\n\n            }\n\n        }","contract":"Vault","time":0},{"type":"state-data-arrangement ","before":"\nuint8 internal constant FALSE = 0;\nuint8 internal constant TRUE = 1;\nuint8 internal _Locked;\nuint internal _RewardCommission;\nuint internal _AdminFee;\naddress internal _NXMAddress;\naddress internal _WNXMAddress;\naddress payable internal _VaultWalletAddress;\naddress payable internal _TreasuryAddress;\naddress internal _StakingDataAddress;\naddress internal _BurnDataAddress;\naddress internal _iTrustFactoryAddress;\nmapping(address => uint256) internal _ReentrantCheck;\nmapping(address => mapping(string => bool)) internal _UsedNonces;","after":"uint internal _RewardCommission;\nuint internal _AdminFee;\nmapping(address => uint256) internal _ReentrantCheck;\nmapping(address => mapping(string => bool)) internal _UsedNonces;\naddress internal _NXMAddress;\naddress internal _WNXMAddress;\naddress payable internal _VaultWalletAddress;\naddress payable internal _TreasuryAddress;\naddress internal _StakingDataAddress;\naddress internal _BurnDataAddress;\naddress internal _iTrustFactoryAddress;\nuint8 internal constant FALSE = 0;\nuint8 internal constant TRUE = 1;\nuint8 internal _Locked;\n","contract":"Vault","time":1},{"type":"external-function ","before":"function initialize(\n\n        address nxmAddress,\n\n        address wnxmAddress,\n\n        address vaultWalletAddress,\n\n        address stakingDataAddress,\n\n        address burnDataAddress,\n\n        string memory tokenName,\n\n        string memory tokenSymbol,\n\n        uint adminFee,\n\n        uint commission,\n\n        address treasuryAddress\n\n    )\n\n    initializer\n\n    external\n\n    {\n\n        __ERC20_init(tokenName, tokenSymbol);\n\n        _Locked = FALSE;\n\n        _NXMAddress = nxmAddress;\n\n        _WNXMAddress = wnxmAddress;\n\n        _VaultWalletAddress = payable(vaultWalletAddress);\n\n        _StakingDataAddress = stakingDataAddress;\n\n        _BurnDataAddress = burnDataAddress;\n\n        _AdminFee = adminFee;\n\n        _iTrustFactoryAddress = _msgSender();\n\n        _RewardCommission = commission;\n\n        _TreasuryAddress = payable(treasuryAddress);\n\n    }","after":"function initialize(\n\n        address nxmAddress,\n\n        address wnxmAddress,\n\n        address vaultWalletAddress,\n\n        address stakingDataAddress,\n\n        address burnDataAddress,\n\n        string calldata tokenName,\n\n        string calldata tokenSymbol,\n\n        uint adminFee,\n\n        uint commission,\n\n        address treasuryAddress\n\n    )\n\n    initializer\n\n    external\n\n    {\n\n        __ERC20_init(tokenName, tokenSymbol);\n\n        _Locked = FALSE;\n\n        _NXMAddress = nxmAddress;\n\n        _WNXMAddress = wnxmAddress;\n\n        _VaultWalletAddress = payable(vaultWalletAddress);\n\n        _StakingDataAddress = stakingDataAddress;\n\n        _BurnDataAddress = burnDataAddress;\n\n        _AdminFee = adminFee;\n\n        _iTrustFactoryAddress = _msgSender();\n\n        _RewardCommission = commission;\n\n        _TreasuryAddress = payable(treasuryAddress);\n\n    }","contract":"Vault","time":0},{"type":"external-function ","before":"function authoriseUnstakes(address[] memory account, uint[] memory timestamp, uint[] memory amounts) external {\n\n        _onlyAdmin();\n\n        require(_getStakingDataContract().authoriseUnstakes(account, timestamp));\n\n        //for each unstake burn\n\n        for (uint i = 0; i < account.length; i++) {\n\n            _burn(account[i], amounts[i]);\n\n            emit UnstakedApproved(\n\n                account[i],\n\n                amounts[i],\n\n                balanceOf(account[i]),\n\n                _getStakingDataContract().getAccountStakingTotal(account[i]));\n\n        }\n\n    }","after":"function authoriseUnstakes(address[] calldata account, uint[] calldata timestamp, uint[] calldata amounts) external {\n\n        _onlyAdmin();\n\n        require(_getStakingDataContract().authoriseUnstakes(account, timestamp));\n\n        //for each unstake burn\n\n        for (uint i = 0; i < account.length; i++) {\n\n            _burn(account[i], amounts[i]);\n\n            emit UnstakedApproved(\n\n                account[i],\n\n                amounts[i],\n\n                balanceOf(account[i]),\n\n                _getStakingDataContract().getAccountStakingTotal(account[i]));\n\n        }\n\n    }","contract":"Vault","time":0},{"type":"external-function ","before":"function withdrawRewards(address[] memory tokens, uint[] memory rewards, string memory nonce, bytes memory sig) external returns (bool) {\n\n        require(!_UsedNonces[_msgSender()][nonce]);\n\n        _nonReentrant();\n\n        _Locked = TRUE;\n\n        bool toClaim = false;\n\n        for (uint x = 0; x < tokens.length; x++) {\n\n            if (rewards[x] != 0) {\n\n                toClaim = true;\n\n            }\n\n        }\n\n        require(toClaim == true);\n\n        bytes32 abiBytes = keccak256(abi.encodePacked(_msgSender(), tokens, rewards, nonce, address(this)));\n\n        bytes32 message = VaultLib.prefixed(abiBytes);\n\n\n        address signer = VaultLib.recoverSigner(message, sig);\n\n        _isTrustedSigner(signer);\n\n\n        require(_getStakingDataContract().withdrawRewards(_msgSender(), tokens, rewards));\n\n        _UsedNonces[_msgSender()][nonce] = true;\n\n\n        for (uint x = 0; x < tokens.length; x++) {\n\n            if (rewards[x] != 0) {\n\n                IERC20Upgradeable token = IERC20Upgradeable(tokens[x]);\n\n                require(token.balanceOf(address(this)) >= rewards[x]);\n\n                require(token.transfer(_msgSender(), rewards[x]));\n\n            }\n\n        }\n\n        _Locked = FALSE;\n\n        return true;\n\n    }","after":"function withdrawRewards(address[] calldata tokens, uint[] calldata rewards, string calldata nonce, bytes calldata sig) external returns (bool) {\n\n        require(!_UsedNonces[_msgSender()][nonce]);\n\n        _nonReentrant();\n\n        _Locked = TRUE;\n\n        bool toClaim = false;\n\n        for (uint x = 0; x < tokens.length; x++) {\n\n            if (rewards[x] != 0) {\n\n                toClaim = true;\n\n            }\n\n        }\n\n        require(toClaim == true);\n\n        bytes32 abiBytes = keccak256(abi.encodePacked(_msgSender(), tokens, rewards, nonce, address(this)));\n\n        bytes32 message = VaultLib.prefixed(abiBytes);\n\n\n        address signer = VaultLib.recoverSigner(message, sig);\n\n        _isTrustedSigner(signer);\n\n\n        require(_getStakingDataContract().withdrawRewards(_msgSender(), tokens, rewards));\n\n        _UsedNonces[_msgSender()][nonce] = true;\n\n\n        for (uint x = 0; x < tokens.length; x++) {\n\n            if (rewards[x] != 0) {\n\n                IERC20Upgradeable token = IERC20Upgradeable(tokens[x]);\n\n                require(token.balanceOf(address(this)) >= rewards[x]);\n\n                require(token.transfer(_msgSender(), rewards[x]));\n\n            }\n\n        }\n\n        _Locked = FALSE;\n\n        return true;\n\n    }","contract":"Vault","time":0},{"type":"external-function ","before":"function createVault(\n\n        address contractAddress,\n\n        bytes memory data\n\n    ) external onlyAdmin {\n\n        TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(contractAddress, msg.sender, data);\n\n        require(address(proxy) != address(0));\n\n        _VaultProxies.push(address(proxy));\n\n        _VaultStatus[address(proxy)] = true;\n\n        StakingData stakingDataContract = StakingData(_stakingDataAddress);\n\n        stakingDataContract.addVault(address(proxy));\n\n    }","after":"function createVault(\n\n        address contractAddress,\n\n        bytes calldata data\n\n    ) external onlyAdmin {\n\n        TransparentUpgradeableProxy proxy = new TransparentUpgradeableProxy(contractAddress, msg.sender, data);\n\n        require(address(proxy) != address(0));\n\n        _VaultProxies.push(address(proxy));\n\n        _VaultStatus[address(proxy)] = true;\n\n        StakingData stakingDataContract = StakingData(_stakingDataAddress);\n\n        stakingDataContract.addVault(address(proxy));\n\n    }","contract":"ITrustVaultFactory","time":0}]}