{"time":323,"results":[{"type":"external-function ","before":"function balanceOfBatch(\n\n        address[] memory owners,\n\n        uint256[] memory ids\n\n    )\n\n    public\n\n    view\n\n    returns (uint256[] memory)\n\n    {\n\n        require(owners.length == ids.length, \"ERC1155: owners and IDs must have same lengths\");\n\n\n        uint256[] memory batchBalances = new uint256[](owners.length);\n\n\n        for (uint256 i = 0; i < owners.length; ++i) {\n\n            require(owners[i] != address(0), \"ERC1155: some address in batch balance query is zero\");\n\n            batchBalances[i] = _balances[ids[i]][owners[i]];\n\n        }\n\n\n        return batchBalances;\n\n    }","after":"function balanceOfBatch(\n\n        address[] calldata owners,\n\n        uint256[] calldata ids\n\n    )\n\n    public\n\n    view\n\n    returns (uint256[] memory)\n\n    {\n\n        require(owners.length == ids.length, \"ERC1155: owners and IDs must have same lengths\");\n\n\n        uint256[] memory batchBalances = new uint256[](owners.length);\n\n\n        for (uint256 i = 0; i < owners.length; ++i) {\n\n            require(owners[i] != address(0), \"ERC1155: some address in batch balance query is zero\");\n\n            batchBalances[i] = _balances[ids[i]][owners[i]];\n\n        }\n\n\n        return batchBalances;\n\n    }","contract":"ConditionalTokens","time":0},{"type":"external-function ","before":"n Maximum number\n\n    function max(int[] memory nums)\n\n    public\n\n    pure\n\n    returns (int maxNum)\n\n    {\n\n        require(nums.length > 0);\n\n        maxNum = - 2 ** 255;\n\n        for (uint i = 0; i < nums.length; i++)\n\n            if (nums[i] > maxNum)\n\n                ma","after":"n Maximum number\n\n    function max(int[] memory nums)\n\n    public\n\n    pure\n\n    returns (int maxNum)\n\n    {\n\n        require(nums.length > 0);\n\n        maxNum = - 2 ** 255;\n\n        for (uint i = 0; i < nums.length; i++)\n\n            if (nums[i] > maxNum)\n\n                ma","contract":"Fixed192x64Math","time":0},{"type":"state-data-arrangement ","before":"\nnstants\n\n     */\n\n    uint64 public constant\nStorage\n\n     */\n\n    ConditionalT\npublic pmSystem;\n\n    IERC20 p\ncollateralToken;\n\n    bytes32[\nic conditionIds;\n\n    uint public a\nutcomeSlotCount;\n\n\nnt64 public fee;\n\n  \n public funding;\n\n \nge public stage;\n\n    White\nblic whitelist;\n\n\n    uin\ntcomeSlotCounts;\n\n    byte\n] collectionIds;\n\n ","after":"Storage\n\n     */\n\n    ConditionalT\npublic pmSystem;\n\n    IERC20 p\ncollateralToken;\n\n    bytes32[\nic conditionIds;\n\n    uint public a\nnt64 public fee;\n\n  \n public funding;\n\n \nge public stage;\n\n    White\nblic whitelist;\n\n\n    uin\ntcomeSlotCounts;\n\n    byte\n] collectionIds;\n\n \nnstants\n\n     */\n\n    uint64 public constant\nutcomeSlotCount;\n\n\n","contract":"MarketMaker","time":0},{"type":"loop-calculation","before":"; i++) {\n\n            int negBalance = - int(pmSystem.balanceOf(address(this), generate","after":"// move outside for loop\n; i++) {\n\n            int negBalance = - int(pmSystem.balanceOf(address(this), generate","loc":{"start":{"line":4262,"column":12},"end":{"line":4262,"column":98}},"contract":"LMSRMarketMaker","time":0},{"type":"external-function ","before":"ent or received.\n\n    function trade(int[] memory outcomeTokenAmounts, int collateralLimit)\n\n    public\n\n    atStage(Stage.Running)\n\n    onlyWhitelisted\n\n    returns (int netCost)\n\n    {\n\n        require(outcomeTokenAmounts.length == atomicOutcomeSlotCount);\n\n\n        // Calculate net cost for executing trade\n\n        int outcomeTokenNetCost = calcNetCost(outcomeTokenAmounts);\n\n        int fees;\n\n        if (outcomeTokenNetCost < 0)\n\n            fees = int(calcMarketFee(uint(- outcomeTokenNetCost)));\n\n        else\n\n            fees = int(calcMarketFee(uint(outcomeTokenNetCost)));\n\n\n        require(fees >= 0);\n\n        netCost = outcomeTokenNetCost.add(fees);\n\n\n        require(\n\n            (collateralLimit != 0 && netCost <= collateralLimit) ||\n\n            collateralLimit == 0\n\n        );\n\n\n        if (outcomeTokenNetCost > 0) {\n\n            require(\n\n                collateralToken.transferFrom(msg.sender, address(this), uint(netCost)) &&\n\n                collateralToken.approve(address(pmSystem), uint(outcomeTokenNetCost))\n\n            );\n\n\n            splitPositionThroughAllConditions(uint(outcomeTokenNetCost));\n\n        }\n\n\n        bool touched = false;\n\n        uint[] memory transferAmounts = new uint[](atomicOutcomeSlotCount);\n\n        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {\n\n            if (outcomeTokenAmounts[i] < 0) {\n\n                touched = true;\n\n                // This is safe since\n\n                // 0x8000000000000000000000000000000000000000000000000000000000000000 ==\n\n                // uint(-int(-0x8000000000000000000000000000000000000000000000000000000000000000))\n\n                transferAmounts[i] = uint(- outcomeTokenAmounts[i]);\n\n            }\n\n        }\n\n        if (touched) pmSystem.safeBatchTransferFrom(msg.sender, address(this), positionIds, transferAmounts, \"\");\n\n\n        if (outcomeTokenNetCost < 0) {\n\n            mergePositionsThroughAllConditions(uint(- outcomeTokenNetCost));\n\n        }\n\n\n        emit AMMOutcomeTokenTrade(msg.sender, outcomeTokenAmounts, outcomeTokenNetCost, uint(fees));\n\n\n        touched = false;\n\n        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {\n\n            if (outcomeTokenAmounts[i] > 0) {\n\n                touched = true;\n\n                transferAmounts[i] = uint(outcomeTokenAmounts[i]);\n\n            } else {\n\n                transferAmounts[i] = 0;\n\n            }\n\n        }\n\n        if (touched) pmSystem.safeBatchTransferFrom(address(this), msg.sender, positionIds, transferAmounts, \"\");\n\n\n        if (netCost < 0) {\n\n            require(collateralToken.transfer(msg.sender, uint(- netCost","after":"ent or received.\n\n    function trade(int[] calldata outcomeTokenAmounts, int collateralLimit)\n\n    public\n\n    atStage(Stage.Running)\n\n    onlyWhitelisted\n\n    returns (int netCost)\n\n    {\n\n        require(outcomeTokenAmounts.length == atomicOutcomeSlotCount);\n\n\n        // Calculate net cost for executing trade\n\n        int outcomeTokenNetCost = calcNetCost(outcomeTokenAmounts);\n\n        int fees;\n\n        if (outcomeTokenNetCost < 0)\n\n            fees = int(calcMarketFee(uint(- outcomeTokenNetCost)));\n\n        else\n\n            fees = int(calcMarketFee(uint(outcomeTokenNetCost)));\n\n\n        require(fees >= 0);\n\n        netCost = outcomeTokenNetCost.add(fees);\n\n\n        require(\n\n            (collateralLimit != 0 && netCost <= collateralLimit) ||\n\n            collateralLimit == 0\n\n        );\n\n\n        if (outcomeTokenNetCost > 0) {\n\n            require(\n\n                collateralToken.transferFrom(msg.sender, address(this), uint(netCost)) &&\n\n                collateralToken.approve(address(pmSystem), uint(outcomeTokenNetCost))\n\n            );\n\n\n            splitPositionThroughAllConditions(uint(outcomeTokenNetCost));\n\n        }\n\n\n        bool touched = false;\n\n        uint[] memory transferAmounts = new uint[](atomicOutcomeSlotCount);\n\n        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {\n\n            if (outcomeTokenAmounts[i] < 0) {\n\n                touched = true;\n\n                // This is safe since\n\n                // 0x8000000000000000000000000000000000000000000000000000000000000000 ==\n\n                // uint(-int(-0x8000000000000000000000000000000000000000000000000000000000000000))\n\n                transferAmounts[i] = uint(- outcomeTokenAmounts[i]);\n\n            }\n\n        }\n\n        if (touched) pmSystem.safeBatchTransferFrom(msg.sender, address(this), positionIds, transferAmounts, \"\");\n\n\n        if (outcomeTokenNetCost < 0) {\n\n            mergePositionsThroughAllConditions(uint(- outcomeTokenNetCost));\n\n        }\n\n\n        emit AMMOutcomeTokenTrade(msg.sender, outcomeTokenAmounts, outcomeTokenNetCost, uint(fees));\n\n\n        touched = false;\n\n        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {\n\n            if (outcomeTokenAmounts[i] > 0) {\n\n                touched = true;\n\n                transferAmounts[i] = uint(outcomeTokenAmounts[i]);\n\n            } else {\n\n                transferAmounts[i] = 0;\n\n            }\n\n        }\n\n        if (touched) pmSystem.safeBatchTransferFrom(address(this), msg.sender, positionIds, transferAmounts, \"\");\n\n\n        if (netCost < 0) {\n\n            require(collateralToken.transfer(msg.sender, uint(- netCost","contract":"LMSRMarketMaker","time":0},{"type":"constant-restrict-modification  ","before":"ic conditionIds;\n\n    uint public a","after":"ic conditionIds;\n\n    uint public a","contract":"LMSRMarketMaker","time":0}]}