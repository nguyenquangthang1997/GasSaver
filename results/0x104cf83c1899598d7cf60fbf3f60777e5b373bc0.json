{"time":613,"results":[{"type":"state-data-arrangement ","before":"\nbool private _paused;\nbool public override tokenMinting;\nuint256 public constant override denominator = 10000;\nIWETH public immutable override weth;\nEnumerableSet.AddressSet private deadTokens;\naddress payable public fallbackRecipient;\nmapping(address => string) public strategistNames;","after":"uint256 public constant override denominator = 10000;\nIWETH public immutable override weth;\nEnumerableSet.AddressSet private deadTokens;\nmapping(address => string) public strategistNames;\naddress payable public fallbackRecipient;\nbool private _paused;\nbool public override tokenMinting;\n","contract":"Registry","time":0},{"type":"external-function ","before":"function addPool(\n        address _pool,\n        uint256 _pid,\n        address[][2] memory _pathsFromRewards,\n        address _extraRewardHandler\n    ) external whenNotPaused isAuthorized(OLib.STRATEGIST_ROLE) {\n        require(!pools[_pool]._isSet, \"Pool already registered\");\n        require(_pool != address(0), \"Cannot be zero address\");\n\n        address lpToken = masterChef.lpToken(_pid);\n        require(lpToken == _pool, \"LP Token does not match\");\n        require(\n            _pathsFromRewards[0][0] == address(sushiToken) &&\n            _pathsFromRewards[1][0] != address(sushiToken),\n            \"First path must be from SUSHI\"\n        );\n        address token0 = IUniswapV2Pair(_pool).token0();\n        address token1 = IUniswapV2Pair(_pool).token1();\n        for (uint256 i = 0; i < 2; i++) {\n            address rewardToken = _pathsFromRewards[i][0];\n            if (rewardToken == token0 || rewardToken == token1) {\n                require(_pathsFromRewards[i].length == 1, \"Invalid path\");\n            } else {\n                address endToken =\n                _pathsFromRewards[i][_pathsFromRewards[i].length - 1];\n                require(endToken == token0 || endToken == token1, \"Invalid path\");\n            }\n        }\n        pools[_pool].pathsFromRewards = _pathsFromRewards;\n\n        pools[_pool].pid = _pid;\n        pools[_pool]._isSet = true;\n        pools[_pool].extraRewardHandler = IUserTriggeredReward(_extraRewardHandler);\n\n        emit NewPair(_pool, _pid);\n    }","after":"function addPool(\n        address _pool,\n        uint256 _pid,\n        address[][2] calldata _pathsFromRewards,\n        address _extraRewardHandler\n    ) external whenNotPaused isAuthorized(OLib.STRATEGIST_ROLE) {\n        require(!pools[_pool]._isSet, \"Pool already registered\");\n        require(_pool != address(0), \"Cannot be zero address\");\n\n        address lpToken = masterChef.lpToken(_pid);\n        require(lpToken == _pool, \"LP Token does not match\");\n        require(\n            _pathsFromRewards[0][0] == address(sushiToken) &&\n            _pathsFromRewards[1][0] != address(sushiToken),\n            \"First path must be from SUSHI\"\n        );\n        address token0 = IUniswapV2Pair(_pool).token0();\n        address token1 = IUniswapV2Pair(_pool).token1();\n        for (uint256 i = 0; i < 2; i++) {\n            address rewardToken = _pathsFromRewards[i][0];\n            if (rewardToken == token0 || rewardToken == token1) {\n                require(_pathsFromRewards[i].length == 1, \"Invalid path\");\n            } else {\n                address endToken =\n                _pathsFromRewards[i][_pathsFromRewards[i].length - 1];\n                require(endToken == token0 || endToken == token1, \"Invalid path\");\n            }\n        }\n        pools[_pool].pathsFromRewards = _pathsFromRewards;\n\n        pools[_pool].pid = _pid;\n        pools[_pool]._isSet = true;\n        pools[_pool].extraRewardHandler = IUserTriggeredReward(_extraRewardHandler);\n\n        emit NewPair(_pool, _pid);\n    }","contract":"SushiStakingV2Strategy","time":0},{"type":"external-function ","before":"function rescueTokens(address[] calldata _tokens, uint256[] memory _amounts)\n    public\n    whenPaused\n    isAuthorized(OLib.GUARDIAN_ROLE)\n    {\n        require(_tokens.length == _amounts.length, \"Invalid array sizes\");\n        _rescueTokens(_tokens, _amounts);\n    }","after":"function rescueTokens(address[] calldata _tokens, uint256[] calldata _amounts)\n    public\n    whenPaused\n    isAuthorized(OLib.GUARDIAN_ROLE)\n    {\n        require(_tokens.length == _amounts.length, \"Invalid array sizes\");\n        _rescueTokens(_tokens, _amounts);\n    }","contract":"SushiStakingV2Strategy","time":0}]}