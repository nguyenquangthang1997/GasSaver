{"time":175,"results":[{"type":"state-data-arrangement ","before":"\nbytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\nstring public contentHash = \"QmfXYgfX1qNfzQ6NRyFnupniZusasFPMeiWn5aaDnx7YXo\";\nuint public constant TOKEN_LIMIT = 20000;\nuint public constant SALE_LIMIT = 9000;\nmapping(bytes4 => bool) internal supportedInterfaces;\nmapping(uint256 => address) internal idToOwner;\nmapping(uint256 => uint256) public creatorNftMints;\nmapping(uint256 => address) internal idToApproval;\nmapping(address => mapping(address => bool)) internal ownerToOperators;\nmapping(address => uint256[]) internal ownerToIds;\nmapping(uint256 => uint256) internal idToOwnerIndex;\nstring internal nftName = \"Meebits\";\nstring internal nftSymbol = unicode\"⚇\n  uint internal numTokens = \n  uint internal numSales = \n  address internal punk\n  address internal glyph\n  address payable internal deploye\n  address payable internal beneficiar\n  bool public communityGrant = tru\n  bool public publicSale = fals\n  uint private pric\n  uint public saleStartTim\n  uint public saleDuratio\n  uint internal nonce = \n  uint[TOKEN_LIMIT] internal indice\n  bool public marketPause\n  bool public contractSeale\n  mapping(address => uint256) public ethBalanc\n  mapping(bytes32 => bool) public cancelledOffer\n  bool private reentrancyLock = fals","after":"string public contentHash = \"QmfXYgfX1qNfzQ6NRyFnupniZusasFPMeiWn5aaDnx7YXo\";\nuint public constant TOKEN_LIMIT = 20000;\nuint public constant SALE_LIMIT = 9000;\nmapping(bytes4 => bool) internal supportedInterfaces;\nmapping(uint256 => address) internal idToOwner;\nmapping(uint256 => uint256) public creatorNftMints;\nmapping(uint256 => address) internal idToApproval;\nmapping(address => mapping(address => bool)) internal ownerToOperators;\nmapping(address => uint256[]) internal ownerToIds;\nmapping(uint256 => uint256) internal idToOwnerIndex;\nstring internal nftName = \"Meebits\";\nstring internal nftSymbol = unicode\"⚇\n  uint internal numTokens = \n  uint internal numSales = \n  uint private pric\n  uint public saleStartTim\n  uint public saleDuratio\n  uint internal nonce = \n  uint[TOKEN_LIMIT] internal indice\n  mapping(address => uint256) public ethBalanc\n  mapping(bytes32 => bool) public cancelledOffer\n  address internal punk\n  address internal glyph\n  address payable internal deploye\n  address payable internal beneficiar\nbytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\n  bool public communityGrant = tru\n  bool public publicSale = fals\n  bool public marketPause\n  bool public contractSeale\n  bool private reentrancyLock = fals\n","contract":"Meebits","time":10},{"type":"external-function ","before":"  function hashToSign(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt) public pure returns (bytes32) {\n\n        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);\n\n        return hashOffer(offer);\n\n   ","after":"  function hashToSign(address maker, address taker, uint256 makerWei, uint256[] calldata makerIds, uint256 takerWei, uint256[] calldata takerIds, uint256 expiry, uint256 salt) public pure returns (bytes32) {\n\n        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);\n\n        return hashOffer(offer);\n\n   ","contract":"Meebits","time":0},{"type":"external-function ","before":"  function cancelOffer(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt) external {\n\n        require(maker == msg.sender, \"Only the maker can cancel this offer.\");\n\n        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);\n\n        bytes32 hash = hashOffer(offer);\n\n        cancelledOffers[hash] = true;\n\n        emit OfferCancelled(hash);\n\n   ","after":"  function cancelOffer(address maker, address taker, uint256 makerWei, uint256[] calldata makerIds, uint256 takerWei, uint256[] calldata takerIds, uint256 expiry, uint256 salt) external {\n\n        require(maker == msg.sender, \"Only the maker can cancel this offer.\");\n\n        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);\n\n        bytes32 hash = hashOffer(offer);\n\n        cancelledOffers[hash] = true;\n\n        emit OfferCancelled(hash);\n\n   ","contract":"Meebits","time":0},{"type":"external-function ","before":"  function acceptTrade(address maker, address taker, uint256 makerWei, uint256[] memory makerIds, uint256 takerWei, uint256[] memory takerIds, uint256 expiry, uint256 salt, bytes memory signature) external payable reentrancyGuard {\n\n        require(!marketPaused, \"Market is paused.\");\n\n        require(msg.sender != maker, \"Can't accept ones own trade.\");\n\n        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);\n\n        if (msg.value > 0) {\n\n            ethBalance[msg.sender] = ethBalance[msg.sender].add(msg.value);\n\n            emit Deposit(msg.sender, msg.value);\n\n        }\n\n        require(offer.taker == address(0) || offer.taker == msg.sender, \"Not the recipient of this offer.\");\n\n        require(tradeValid(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt, signature), \"Trade not valid.\");\n\n        require(ethBalance[msg.sender] >= offer.takerWei, \"Insufficient funds to execute trade.\");\n\n        // Transfer ETH\n\n        ethBalance[offer.maker] = ethBalance[offer.maker].sub(offer.makerWei);\n\n        ethBalance[msg.sender] = ethBalance[msg.sender].add(offer.makerWei);\n\n        ethBalance[msg.sender] = ethBalance[msg.sender].sub(offer.takerWei);\n\n        ethBalance[offer.maker] = ethBalance[offer.maker].add(offer.takerWei);\n\n        // Transfer maker ids to taker (msg.sender)\n\n        for (uint i = 0; i < makerIds.length; i++) {\n\n            _transfer(msg.sender, makerIds[i]);\n\n        }\n\n        // Transfer taker ids to maker\n\n        for (uint i = 0; i < takerIds.length; i++) {\n\n            _transfer(maker, takerIds[i]);\n\n        }\n\n        // Prevent a replay attack on this offer\n\n        bytes32 hash = hashOffer(offer);\n\n        cancelledOffers[hash] = true;\n\n        emit Trade(hash, offer.maker, msg.sender, offer.makerWei, offer.makerIds, offer.takerWei, offer.takerIds);\n\n   ","after":"  function acceptTrade(address maker, address taker, uint256 makerWei, uint256[] calldata makerIds, uint256 takerWei, uint256[] calldata takerIds, uint256 expiry, uint256 salt, bytes calldata signature) external payable reentrancyGuard {\n\n        require(!marketPaused, \"Market is paused.\");\n\n        require(msg.sender != maker, \"Can't accept ones own trade.\");\n\n        Offer memory offer = Offer(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt);\n\n        if (msg.value > 0) {\n\n            ethBalance[msg.sender] = ethBalance[msg.sender].add(msg.value);\n\n            emit Deposit(msg.sender, msg.value);\n\n        }\n\n        require(offer.taker == address(0) || offer.taker == msg.sender, \"Not the recipient of this offer.\");\n\n        require(tradeValid(maker, taker, makerWei, makerIds, takerWei, takerIds, expiry, salt, signature), \"Trade not valid.\");\n\n        require(ethBalance[msg.sender] >= offer.takerWei, \"Insufficient funds to execute trade.\");\n\n        // Transfer ETH\n\n        ethBalance[offer.maker] = ethBalance[offer.maker].sub(offer.makerWei);\n\n        ethBalance[msg.sender] = ethBalance[msg.sender].add(offer.makerWei);\n\n        ethBalance[msg.sender] = ethBalance[msg.sender].sub(offer.takerWei);\n\n        ethBalance[offer.maker] = ethBalance[offer.maker].add(offer.takerWei);\n\n        // Transfer maker ids to taker (msg.sender)\n\n        for (uint i = 0; i < makerIds.length; i++) {\n\n            _transfer(msg.sender, makerIds[i]);\n\n        }\n\n        // Transfer taker ids to maker\n\n        for (uint i = 0; i < takerIds.length; i++) {\n\n            _transfer(maker, takerIds[i]);\n\n        }\n\n        // Prevent a replay attack on this offer\n\n        bytes32 hash = hashOffer(offer);\n\n        cancelledOffers[hash] = true;\n\n        emit Trade(hash, offer.maker, msg.sender, offer.makerWei, offer.makerIds, offer.takerWei, offer.takerIds);\n\n   ","contract":"Meebits","time":0},{"type":"constant-restrict-modification  ","before":"string public contentHash = \"QmfXYgfX1qNfzQ6NRyFnupniZusasFPMeiWn5aaDnx7YXo\";","after":"string public constant contentHash = \"QmfXYgfX1qNfzQ6NRyFnupniZusasFPMeiWn5aaDnx7YXo\";","contract":"Meebits","time":1},{"type":"constant-restrict-modification  ","before":"string internal nftName = \"Meebits\";","after":"string internal constant nftName = \"Meebits\";","contract":"Meebits","time":1},{"type":"constant-restrict-modification  ","before":"string internal nftSymbol = unicode\"⚇","after":"string internal constant nftSymbol = unicode\"⚇","contract":"Meebits","time":1},{"type":"immutable-restrict-modification ","before":"  address internal punk","after":"  address internal punk","contract":"Meebits","time":1},{"type":"immutable-restrict-modification ","before":"  address internal glyph","after":"  address internal glyph","contract":"Meebits","time":1},{"type":"immutable-restrict-modification ","before":"  address payable internal deploye","after":"  address payable internal deploye","contract":"Meebits","time":1},{"type":"immutable-restrict-modification ","before":"  address payable internal beneficiar","after":"  address payable internal beneficiar","contract":"Meebits","time":1}]}