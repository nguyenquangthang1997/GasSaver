{"time":259,"results":[{"type":"state-data-arrangement ","before":"\n   AssetRegistry.Storage _assetRegist\n   mapping(bytes32 => bool) _completedOrderHash\n   mapping(bytes32 => bool) _completedWithdrawalHash\n   address payable _custodi\n   uint64 _depositInd\n   mapping(address => mapping(address => uint64)) _balancesInPi\n   mapping(address => NonceInvalidation) _nonceInvalidatio\n   mapping(bytes32 => uint64) _partiallyFilledOrderQuantitiesInPi\n   mapping(address => WalletExit) _walletExi\n   uint256 _chainPropagationPeri\n   address _dispatcherWall\n   address _feeWall\n   uint256 constant _maxChainPropagationPeriod = (7 * 24 * 60 * 60) / \n   uint64 constant _maxTradeFeeBasisPoints = 20 * 1\n   uint64 constant _maxWithdrawalFeeBasisPoints = 20 * 1","after":"   AssetRegistry.Storage _assetRegist\n   mapping(bytes32 => bool) _completedOrderHash\n   mapping(bytes32 => bool) _completedWithdrawalHash\n   mapping(address => mapping(address => uint64)) _balancesInPi\n   mapping(address => NonceInvalidation) _nonceInvalidatio\n   mapping(bytes32 => uint64) _partiallyFilledOrderQuantitiesInPi\n   mapping(address => WalletExit) _walletExi\n   uint256 _chainPropagationPeri\n   uint256 constant _maxChainPropagationPeriod = (7 * 24 * 60 * 60) / \n   address payable _custodi\n   address _dispatcherWall\n   address _feeWall\n   uint64 _depositInd\n   uint64 constant _maxTradeFeeBasisPoints = 20 * 1\n   uint64 constant _maxWithdrawalFeeBasisPoints = 20 * 1\n","contract":"Exchange","time":0},{"type":"external-function ","before":"   function withdraw(Structs.Withdrawal memory withdrawal)\n    public\n    override\n    onlyDispatcher\n    {\n        // Validations\n        require(!isWalletExitFinalized(withdrawal.walletAddress), 'Wallet exited');\n        require(\n            getFeeBasisPoints(withdrawal.gasFeeInPips, withdrawal.quantityInPips) <=\n            _maxWithdrawalFeeBasisPoints,\n            'Excessive withdrawal fee'\n        );\n        bytes32 withdrawalHash = validateWithdrawalSignature(withdrawal);\n        require(\n            !_completedWithdrawalHashes[withdrawalHash],\n            'Hash already withdrawn'\n        );\n\n        // If withdrawal is by asset symbol (most common) then resolve to asset address\n        Structs.Asset memory asset = withdrawal.withdrawalType ==\n        Enums.WithdrawalType.BySymbol\n        ? _assetRegistry.loadAssetBySymbol(\n            withdrawal.assetSymbol,\n            UUID.getTimestampInMsFromUuidV1(withdrawal.nonce)\n        )\n        : _assetRegistry.loadAssetByAddress(withdrawal.assetAddress);\n\n        // SafeMath reverts if balance is overdrawn\n        uint64 netAssetQuantityInPips = withdrawal.quantityInPips.sub(\n            withdrawal.gasFeeInPips\n        );\n        uint256 netAssetQuantityInAssetUnits = AssetUnitConversions\n        .pipsToAssetUnits(netAssetQuantityInPips, asset.decimals);\n        uint64 newExchangeBalanceInPips = _balancesInPips[withdrawal\n        .walletAddress][asset.assetAddress]\n        .sub(withdrawal.quantityInPips);\n        uint256 newExchangeBalanceInAssetUnits = AssetUnitConversions\n        .pipsToAssetUnits(newExchangeBalanceInPips, asset.decimals);\n\n        _balancesInPips[withdrawal.walletAddress][asset\n        .assetAddress] = newExchangeBalanceInPips;\n        _balancesInPips[_feeWallet][asset\n        .assetAddress] = _balancesInPips[_feeWallet][asset.assetAddress].add(\n            withdrawal.gasFeeInPips\n        );\n\n        ICustodian(_custodian).withdraw(\n            withdrawal.walletAddress,\n            asset.assetAddress,\n            netAssetQuantityInAssetUnits\n        );\n\n        _completedWithdrawalHashes[withdrawalHash] = true;\n\n        emit Withdrawn(\n            withdrawal.walletAddress,\n            asset.assetAddress,\n            asset.symbol,\n            withdrawal.quantityInPips,\n            newExchangeBalanceInPips,\n            newExchangeBalanceInAssetUnits\n        );\n  ","after":"   function withdraw(Structs.Withdrawal calldata withdrawal)\n    public\n    override\n    onlyDispatcher\n    {\n        // Validations\n        require(!isWalletExitFinalized(withdrawal.walletAddress), 'Wallet exited');\n        require(\n            getFeeBasisPoints(withdrawal.gasFeeInPips, withdrawal.quantityInPips) <=\n            _maxWithdrawalFeeBasisPoints,\n            'Excessive withdrawal fee'\n        );\n        bytes32 withdrawalHash = validateWithdrawalSignature(withdrawal);\n        require(\n            !_completedWithdrawalHashes[withdrawalHash],\n            'Hash already withdrawn'\n        );\n\n        // If withdrawal is by asset symbol (most common) then resolve to asset address\n        Structs.Asset memory asset = withdrawal.withdrawalType ==\n        Enums.WithdrawalType.BySymbol\n        ? _assetRegistry.loadAssetBySymbol(\n            withdrawal.assetSymbol,\n            UUID.getTimestampInMsFromUuidV1(withdrawal.nonce)\n        )\n        : _assetRegistry.loadAssetByAddress(withdrawal.assetAddress);\n\n        // SafeMath reverts if balance is overdrawn\n        uint64 netAssetQuantityInPips = withdrawal.quantityInPips.sub(\n            withdrawal.gasFeeInPips\n        );\n        uint256 netAssetQuantityInAssetUnits = AssetUnitConversions\n        .pipsToAssetUnits(netAssetQuantityInPips, asset.decimals);\n        uint64 newExchangeBalanceInPips = _balancesInPips[withdrawal\n        .walletAddress][asset.assetAddress]\n        .sub(withdrawal.quantityInPips);\n        uint256 newExchangeBalanceInAssetUnits = AssetUnitConversions\n        .pipsToAssetUnits(newExchangeBalanceInPips, asset.decimals);\n\n        _balancesInPips[withdrawal.walletAddress][asset\n        .assetAddress] = newExchangeBalanceInPips;\n        _balancesInPips[_feeWallet][asset\n        .assetAddress] = _balancesInPips[_feeWallet][asset.assetAddress].add(\n            withdrawal.gasFeeInPips\n        );\n\n        ICustodian(_custodian).withdraw(\n            withdrawal.walletAddress,\n            asset.assetAddress,\n            netAssetQuantityInAssetUnits\n        );\n\n        _completedWithdrawalHashes[withdrawalHash] = true;\n\n        emit Withdrawn(\n            withdrawal.walletAddress,\n            asset.assetAddress,\n            asset.symbol,\n            withdrawal.quantityInPips,\n            newExchangeBalanceInPips,\n            newExchangeBalanceInAssetUnits\n        );\n  ","contract":"Exchange","time":0},{"type":"external-function ","before":"   function executeTrade(\n        Structs.Order memory buy,\n        Structs.Order memory sell,\n        Structs.Trade memory trade\n    ) public override onlyDispatcher {\n        require(\n            !isWalletExitFinalized(buy.walletAddress),\n            'Buy wallet exit finalized'\n        );\n        require(\n            !isWalletExitFinalized(sell.walletAddress),\n            'Sell wallet exit finalized'\n        );\n        require(\n            buy.walletAddress != sell.walletAddress,\n            'Self-trading not allowed'\n        );\n\n        validateAssetPair(buy, sell, trade);\n        validateLimitPrices(buy, sell, trade);\n        validateOrderNonces(buy, sell);\n        (bytes32 buyHash, bytes32 sellHash) = validateOrderSignatures(\n            buy,\n            sell,\n            trade\n        );\n        validateTradeFees(trade);\n\n        updateOrderFilledQuantities(buy, buyHash, sell, sellHash, trade);\n        updateBalancesForTrade(buy, sell, trade);\n\n        emit TradeExecuted(\n            buy.walletAddress,\n            sell.walletAddress,\n            trade.baseAssetSymbol,\n            trade.quoteAssetSymbol,\n            trade.baseAssetSymbol,\n            trade.quoteAssetSymbol,\n            trade.grossBaseQuantityInPips,\n            trade.grossQuoteQuantityInPips,\n            trade.priceInPips,\n            buyHash,\n            sellHash\n        );\n  ","after":"   function executeTrade(\n        Structs.Order calldata buy,\n        Structs.Order calldata sell,\n        Structs.Trade calldata trade\n    ) public override onlyDispatcher {\n        require(\n            !isWalletExitFinalized(buy.walletAddress),\n            'Buy wallet exit finalized'\n        );\n        require(\n            !isWalletExitFinalized(sell.walletAddress),\n            'Sell wallet exit finalized'\n        );\n        require(\n            buy.walletAddress != sell.walletAddress,\n            'Self-trading not allowed'\n        );\n\n        validateAssetPair(buy, sell, trade);\n        validateLimitPrices(buy, sell, trade);\n        validateOrderNonces(buy, sell);\n        (bytes32 buyHash, bytes32 sellHash) = validateOrderSignatures(\n            buy,\n            sell,\n            trade\n        );\n        validateTradeFees(trade);\n\n        updateOrderFilledQuantities(buy, buyHash, sell, sellHash, trade);\n        updateBalancesForTrade(buy, sell, trade);\n\n        emit TradeExecuted(\n            buy.walletAddress,\n            sell.walletAddress,\n            trade.baseAssetSymbol,\n            trade.quoteAssetSymbol,\n            trade.baseAssetSymbol,\n            trade.quoteAssetSymbol,\n            trade.grossBaseQuantityInPips,\n            trade.grossQuoteQuantityInPips,\n            trade.priceInPips,\n            buyHash,\n            sellHash\n        );\n  ","contract":"Exchange","time":0},{"type":"struct-data-arrangement ","before":"\n   uint8 signatureHashVers\n   uint128 no\n   address walletAddr\n   Enums.OrderType orderT\n   Enums.OrderSide s\n   uint64 quantityInP\n   bool isQuantityInQu\n   uint64 limitPriceInP\n   uint64 stopPriceInP\n   string clientOrde\n   Enums.OrderTimeInForce timeInFo\n   Enums.OrderSelfTradePrevention selfTradePrevent\n   uint64 cancelAf\n   bytes walletSignat","after":"   Enums.OrderType orderT\n   Enums.OrderSide s\n   string clientOrde\n   Enums.OrderTimeInForce timeInFo\n   Enums.OrderSelfTradePrevention selfTradePrevent\n   bytes walletSignat\n   address walletAddr\n   uint128 no\n   uint64 quantityInP\n   uint64 limitPriceInP\n   uint64 stopPriceInP\n   uint64 cancelAf\n   uint8 signatureHashVers\n   bool isQuantityInQu\n","contract":"Structs","time":7},{"type":"struct-data-arrangement ","before":"\n   bool exi\n   address assetAddr\n   string sym\n   uint8 decim\n   bool isConfir\n   uint64 confirmedTimestampI","after":"   string sym\n   address assetAddr\n   uint64 confirmedTimestampI\n   bool exi\n   uint8 decim\n   bool isConfir\n","contract":"Structs","time":1},{"type":"struct-data-arrangement ","before":"\n   string baseAssetSym\n   string quoteAssetSym\n   address baseAssetAddr\n   address quoteAssetAddr\n   uint64 grossBaseQuantityInP\n   uint64 grossQuoteQuantityInP\n   uint64 netBaseQuantityInP\n   uint64 netQuoteQuantityInP\n   address makerFeeAssetAddr\n   address takerFeeAssetAddr\n   uint64 makerFeeQuantityInP\n   uint64 takerFeeQuantityInP\n   uint64 priceInP\n   Enums.OrderSide makerS","after":"   string baseAssetSym\n   string quoteAssetSym\n   Enums.OrderSide makerS\n   address baseAssetAddr\n   address quoteAssetAddr\n   address makerFeeAssetAddr\n   address takerFeeAssetAddr\n   uint64 grossBaseQuantityInP\n   uint64 grossQuoteQuantityInP\n   uint64 netBaseQuantityInP\n   uint64 netQuoteQuantityInP\n   uint64 makerFeeQuantityInP\n   uint64 takerFeeQuantityInP\n   uint64 priceInP\n","contract":"Structs","time":2},{"type":"struct-data-arrangement ","before":"\n   Enums.WithdrawalType withdrawalT\n   uint128 no\n   address payable walletAddr\n   string assetSym\n   address assetAddr\n   uint64 quantityInP\n   uint64 gasFeeInP\n   bool autoDispatchEnab\n   bytes walletSignat","after":"   Enums.WithdrawalType withdrawalT\n   string assetSym\n   bytes walletSignat\n   address payable walletAddr\n   address assetAddr\n   uint128 no\n   uint64 quantityInP\n   uint64 gasFeeInP\n   bool autoDispatchEnab\n","contract":"Structs","time":1}]}