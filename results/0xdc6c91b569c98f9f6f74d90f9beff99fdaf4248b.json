{"time":114,"results":[{"type":"immutable-restrict-modification ","before":"bytes32 public EIP712_DOMAIN_HASH;","after":"bytes32 public immutable EIP712_DOMAIN_HASH;","contract":"LibOrder","time":0},{"type":"external-function ","before":"function fillOrderWithToken(\n\n        uint256 userSalt,\n\n        bytes memory data,\n\n        bytes memory userSignature\n\n    )\n\n    public\n\n    {\n\n        require(isEnabled, \"EXCHANGE_DISABLED\");\n\n\n        // decode & assert\n\n        (LibOrder.Order memory order,\n\n        address user,\n\n        address receiver,\n\n        uint16 feeFactor,\n\n        address makerAssetAddr,\n\n        address takerAssetAddr,\n\n        bytes32 transactionHash) = assertTransaction(userSalt, data, userSignature);\n\n\n        // saved transaction\n\n        transactions[transactionHash] = user;\n\n\n        // USER_PROXY transfer user's token\n\n        USER_PROXY.receiveToken(takerAssetAddr, user, order.takerAssetAmount);\n\n\n        // send tx to 0x\n\n        ZX_EXCHANGE.executeTransaction(\n\n            userSalt,\n\n            address(USER_PROXY),\n\n            data,\n\n            userSignature\n\n        );\n\n\n        // settle token/ETH to user\n\n        uint256 acutalMakerAssetAmount = settle(receiver, makerAssetAddr, order.makerAssetAmount, feeFactor);\n\n\n        emit FillOrder(transactionHash, user, receiver, order.takerAssetAmount, acutalMakerAssetAmount);\n\n    }","after":"function fillOrderWithToken(\n\n        uint256 userSalt,\n\n        bytes calldata data,\n\n        bytes calldata userSignature\n\n    )\n\n    public\n\n    {\n\n        require(isEnabled, \"EXCHANGE_DISABLED\");\n\n\n        // decode & assert\n\n        (LibOrder.Order memory order,\n\n        address user,\n\n        address receiver,\n\n        uint16 feeFactor,\n\n        address makerAssetAddr,\n\n        address takerAssetAddr,\n\n        bytes32 transactionHash) = assertTransaction(userSalt, data, userSignature);\n\n\n        // saved transaction\n\n        transactions[transactionHash] = user;\n\n\n        // USER_PROXY transfer user's token\n\n        USER_PROXY.receiveToken(takerAssetAddr, user, order.takerAssetAmount);\n\n\n        // send tx to 0x\n\n        ZX_EXCHANGE.executeTransaction(\n\n            userSalt,\n\n            address(USER_PROXY),\n\n            data,\n\n            userSignature\n\n        );\n\n\n        // settle token/ETH to user\n\n        uint256 acutalMakerAssetAmount = settle(receiver, makerAssetAddr, order.makerAssetAmount, feeFactor);\n\n\n        emit FillOrder(transactionHash, user, receiver, order.takerAssetAmount, acutalMakerAssetAmount);\n\n    }","contract":"TokenlonExchange","time":0},{"type":"external-function ","before":"function fillOrderWithETH(\n\n        uint256 userSalt,\n\n        bytes memory data,\n\n        bytes memory userSignature\n\n    )\n\n    public\n\n    payable\n\n    {\n\n        require(isEnabled, \"EXCHANGE_DISABLED\");\n\n\n        // decode & assert\n\n        (LibOrder.Order memory order,\n\n        address user,\n\n        address receiver,\n\n        uint16 feeFactor,\n\n        address makerAssetAddr,\n\n        address takerAssetAddr,\n\n        bytes32 transactionHash) = assertTransaction(userSalt, data, userSignature);\n\n\n        require(\n\n            msg.sender == user,\n\n            \"SENDER_IS_NOT_USER\"\n\n        );\n\n\n        require(\n\n            WETH_ADDR == takerAssetAddr,\n\n            \"USER_ASSET_NOT_WETH\"\n\n        );\n\n\n        require(\n\n            msg.value == order.takerAssetAmount,\n\n            \"ETH_NOT_ENOUGH\"\n\n        );\n\n\n        // saved transaction\n\n        transactions[transactionHash] = user;\n\n\n        // USER_PROXY receive eth from TokenlonExchange\n\n        USER_PROXY.receiveETH.value(msg.value)(WETH_ADDR);\n\n\n        // send tx to 0x\n\n        ZX_EXCHANGE.executeTransaction(\n\n            userSalt,\n\n            address(USER_PROXY),\n\n            data,\n\n            userSignature\n\n        );\n\n\n        // settle token/ETH to user\n\n        uint256 acutalMakerAssetAmount = settle(receiver, makerAssetAddr, order.makerAssetAmount, feeFactor);\n\n\n        emit FillOrder(transactionHash, user, receiver, order.takerAssetAmount, acutalMakerAssetAmount);\n\n    }","after":"function fillOrderWithETH(\n\n        uint256 userSalt,\n\n        bytes calldata data,\n\n        bytes calldata userSignature\n\n    )\n\n    public\n\n    payable\n\n    {\n\n        require(isEnabled, \"EXCHANGE_DISABLED\");\n\n\n        // decode & assert\n\n        (LibOrder.Order memory order,\n\n        address user,\n\n        address receiver,\n\n        uint16 feeFactor,\n\n        address makerAssetAddr,\n\n        address takerAssetAddr,\n\n        bytes32 transactionHash) = assertTransaction(userSalt, data, userSignature);\n\n\n        require(\n\n            msg.sender == user,\n\n            \"SENDER_IS_NOT_USER\"\n\n        );\n\n\n        require(\n\n            WETH_ADDR == takerAssetAddr,\n\n            \"USER_ASSET_NOT_WETH\"\n\n        );\n\n\n        require(\n\n            msg.value == order.takerAssetAmount,\n\n            \"ETH_NOT_ENOUGH\"\n\n        );\n\n\n        // saved transaction\n\n        transactions[transactionHash] = user;\n\n\n        // USER_PROXY receive eth from TokenlonExchange\n\n        USER_PROXY.receiveETH.value(msg.value)(WETH_ADDR);\n\n\n        // send tx to 0x\n\n        ZX_EXCHANGE.executeTransaction(\n\n            userSalt,\n\n            address(USER_PROXY),\n\n            data,\n\n            userSignature\n\n        );\n\n\n        // settle token/ETH to user\n\n        uint256 acutalMakerAssetAmount = settle(receiver, makerAssetAddr, order.makerAssetAmount, feeFactor);\n\n\n        emit FillOrder(transactionHash, user, receiver, order.takerAssetAmount, acutalMakerAssetAmount);\n\n    }","contract":"TokenlonExchange","time":0},{"type":"constant-restrict-modification  ","before":"string public version = \"0.0.3\";","after":"string public constant version = \"0.0.3\";","contract":"TokenlonExchange","time":1}]}