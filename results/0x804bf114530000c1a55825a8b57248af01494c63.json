{"time":500,"results":[{"type":"external-function ","before":"function addSeries(\n        bytes6 seriesId,\n        bytes6 baseId,\n        uint32 maturity,\n        bytes6[] calldata ilkIds,\n        string memory name,\n        string memory symbol\n    ) external auth {\n        address base = cauldron.assets(baseId);\n        require(base != address(0), \"Base not found\");\n\n        IJoin baseJoin = ladle.joins(baseId);\n        require(address(baseJoin) != address(0), \"Join not found\");\n\n        IOracle oracle = cauldron.lendingOracles(baseId);\n        // The lending oracles in the Cauldron are also configured to return chi\n        require(address(oracle) != address(0), \"Chi oracle not found\");\n\n        AccessControl fyToken = AccessControl(fyTokenFactory.createFYToken(\n                baseId,\n                oracle,\n                baseJoin,\n                maturity,\n                name, // Derive from base and maturity, perhaps\n                symbol    // Derive from base and maturity, perhaps\n            ));\n\n        // Allow the fyToken to pull from the base join for redemption, and to push to mint with underlying\n        bytes4[] memory sigs = new bytes4[](2);\n        sigs[0] = JOIN;\n        sigs[1] = EXIT;\n        AccessControl(address(baseJoin)).grantRoles(sigs, address(fyToken));\n\n        // Allow the ladle to issue and cancel fyToken\n        sigs = new bytes4[](2);\n        sigs[0] = MINT;\n        sigs[1] = BURN;\n        fyToken.grantRoles(sigs, address(ladle));\n\n        // Pass ownership of the fyToken to msg.sender\n        fyToken.grantRole(ROOT, msg.sender);\n        fyToken.renounceRole(ROOT, address(this));\n\n        // Add fyToken/series to the Cauldron and approve ilks for the series\n        cauldron.addSeries(seriesId, baseId, IFYToken(address(fyToken)));\n        cauldron.addIlks(seriesId, ilkIds);\n\n        // Create the pool for the base and fyToken\n        poolFactory.createPool(base, address(fyToken));\n        address pool = poolFactory.calculatePoolAddress(base, address(fyToken));\n\n        // Register pool in Ladle\n        ladle.addPool(seriesId, address(pool));\n    }","after":"function addSeries(\n        bytes6 seriesId,\n        bytes6 baseId,\n        uint32 maturity,\n        bytes6[] calldata ilkIds,\n        string calldata name,\n        string calldata symbol\n    ) external auth {\n        address base = cauldron.assets(baseId);\n        require(base != address(0), \"Base not found\");\n\n        IJoin baseJoin = ladle.joins(baseId);\n        require(address(baseJoin) != address(0), \"Join not found\");\n\n        IOracle oracle = cauldron.lendingOracles(baseId);\n        // The lending oracles in the Cauldron are also configured to return chi\n        require(address(oracle) != address(0), \"Chi oracle not found\");\n\n        AccessControl fyToken = AccessControl(fyTokenFactory.createFYToken(\n                baseId,\n                oracle,\n                baseJoin,\n                maturity,\n                name, // Derive from base and maturity, perhaps\n                symbol    // Derive from base and maturity, perhaps\n            ));\n\n        // Allow the fyToken to pull from the base join for redemption, and to push to mint with underlying\n        bytes4[] memory sigs = new bytes4[](2);\n        sigs[0] = JOIN;\n        sigs[1] = EXIT;\n        AccessControl(address(baseJoin)).grantRoles(sigs, address(fyToken));\n\n        // Allow the ladle to issue and cancel fyToken\n        sigs = new bytes4[](2);\n        sigs[0] = MINT;\n        sigs[1] = BURN;\n        fyToken.grantRoles(sigs, address(ladle));\n\n        // Pass ownership of the fyToken to msg.sender\n        fyToken.grantRole(ROOT, msg.sender);\n        fyToken.renounceRole(ROOT, address(this));\n\n        // Add fyToken/series to the Cauldron and approve ilks for the series\n        cauldron.addSeries(seriesId, baseId, IFYToken(address(fyToken)));\n        cauldron.addIlks(seriesId, ilkIds);\n\n        // Create the pool for the base and fyToken\n        poolFactory.createPool(base, address(fyToken));\n        address pool = poolFactory.calculatePoolAddress(base, address(fyToken));\n\n        // Register pool in Ladle\n        ladle.addPool(seriesId, address(pool));\n    }","contract":"Wand","time":0},{"type":"external-function ","before":"function grantRoles(bytes4[] memory roles, address account) external virtual {\n        for (uint256 i = 0; i < roles.length; i++) {\n            require(_hasRole(_getRoleAdmin(roles[i]), msg.sender), \"Only admin\");\n            _grantRole(roles[i], account);\n        }\n    }","after":"function grantRoles(bytes4[] calldata roles, address account) external virtual {\n        for (uint256 i = 0; i < roles.length; i++) {\n            require(_hasRole(_getRoleAdmin(roles[i]), msg.sender), \"Only admin\");\n            _grantRole(roles[i], account);\n        }\n    }","contract":"Wand","time":0},{"type":"external-function ","before":"function revokeRoles(bytes4[] memory roles, address account) external virtual {\n        for (uint256 i = 0; i < roles.length; i++) {\n            require(_hasRole(_getRoleAdmin(roles[i]), msg.sender), \"Only admin\");\n            _revokeRole(roles[i], account);\n        }\n    }","after":"function revokeRoles(bytes4[] calldata roles, address account) external virtual {\n        for (uint256 i = 0; i < roles.length; i++) {\n            require(_hasRole(_getRoleAdmin(roles[i]), msg.sender), \"Only admin\");\n            _revokeRole(roles[i], account);\n        }\n    }","contract":"Wand","time":0},{"type":"constant-restrict-modification  ","before":"bytes32 CHI = \"CHI\";","after":"bytes32 constant CHI = \"CHI\";","contract":"Wand","time":0},{"type":"constant-restrict-modification  ","before":"bytes32 RATE = \"RATE\";","after":"bytes32 constant RATE = \"RATE\";","contract":"Wand","time":0},{"type":"constant-restrict-modification  ","before":"bytes6 ETH = \"00\";","after":"bytes6 constant ETH = \"00\";","contract":"Wand","time":0}]}