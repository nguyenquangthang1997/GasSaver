{"time":1961,"results":[{"type":"loop-duplication","before":"\nstart line 1314 column 8, end line 1320 column 8\nfor (uint256 i; i < _requestOwners.length; i++) {\n            allInvestmentAmounts[i] = ownerToRequestInfo[_requestOwners[i]].investmentAmount;\n\n            if (allInvestmentAmounts[i] == 0) {\n                existingRequestsCount--;\n            }\n        }\nstart line 1328 column 8, end line 1349 column 8\nfor (uint256 i; i < _requestOwners.length; i++) {\n            if (allInvestmentAmounts[i] == 0) {\n                continue;\n            }\n\n            buyers_[existingRequestsIndex] = _requestOwners[i];\n            investmentAmounts_[existingRequestsIndex] = allInvestmentAmounts[i];\n            minSharesQuantities_[existingRequestsIndex] = ownerToRequestInfo[_requestOwners[i]]\n            .minSharesQuantity;\n            totalInvestmentAmount_ = totalInvestmentAmount_.add(allInvestmentAmounts[i]);\n\n            delete ownerToRequestInfo[_requestOwners[i]];\n\n            emit RequestExecuted(\n                msg.sender,\n                buyers_[existingRequestsIndex],\n                investmentAmounts_[existingRequestsIndex],\n                minSharesQuantities_[existingRequestsIndex]\n            );\n\n            existingRequestsIndex++;\n        }","after":"// merge loop\n\nstart line 1314 column 8, end line 1320 column 8\nfor (uint256 i; i < _requestOwners.length; i++) {\n            allInvestmentAmounts[i] = ownerToRequestInfo[_requestOwners[i]].investmentAmount;\n\n            if (allInvestmentAmounts[i] == 0) {\n                existingRequestsCount--;\n            }\n        }\nstart line 1328 column 8, end line 1349 column 8\nfor (uint256 i; i < _requestOwners.length; i++) {\n            if (allInvestmentAmounts[i] == 0) {\n                continue;\n            }\n\n            buyers_[existingRequestsIndex] = _requestOwners[i];\n            investmentAmounts_[existingRequestsIndex] = allInvestmentAmounts[i];\n            minSharesQuantities_[existingRequestsIndex] = ownerToRequestInfo[_requestOwners[i]]\n            .minSharesQuantity;\n            totalInvestmentAmount_ = totalInvestmentAmount_.add(allInvestmentAmounts[i]);\n\n            delete ownerToRequestInfo[_requestOwners[i]];\n\n            emit RequestExecuted(\n                msg.sender,\n                buyers_[existingRequestsIndex],\n                investmentAmounts_[existingRequestsIndex],\n                minSharesQuantities_[existingRequestsIndex]\n            );\n\n            existingRequestsIndex++;\n        }","contract":"AuthUserExecutedSharesRequestorLib","time":0},{"type":"loop-duplication","before":"\nstart line 3667 column 8, end line 3672 column 8\nfor (uint256 i; i < _additionalAssets.length; i++) {\n            if (!trackedAssetsToPayout.contains(_additionalAssets[i])) {\n                indexesToAdd[i] = true;\n                additionalItemsCount++;\n            }\n        }\nstart line 3682 column 8, end line 3687 column 8\nfor (uint256 i; i < _additionalAssets.length; i++) {\n            if (indexesToAdd[i]) {\n                payoutAssets_[payoutAssetsIndex] = _additionalAssets[i];\n                payoutAssetsIndex++;\n            }\n        }","after":"// merge loop\n\nstart line 3667 column 8, end line 3672 column 8\nfor (uint256 i; i < _additionalAssets.length; i++) {\n            if (!trackedAssetsToPayout.contains(_additionalAssets[i])) {\n                indexesToAdd[i] = true;\n                additionalItemsCount++;\n            }\n        }\nstart line 3682 column 8, end line 3687 column 8\nfor (uint256 i; i < _additionalAssets.length; i++) {\n            if (indexesToAdd[i]) {\n                payoutAssets_[payoutAssetsIndex] = _additionalAssets[i];\n                payoutAssetsIndex++;\n            }\n        }","contract":"ComptrollerLib","time":0},{"type":"immutable-restrict-modification ","before":"bool internal isLib;","after":"bool internal immutable isLib;","contract":"ComptrollerLib","time":1},{"type":"loop-duplication","before":"\nstart line 6319 column 8, end line 6324 column 8\nfor (uint256 i; i < fees.length; i++) {\n            if (feeManagerContract.feeSettlesOnHook(fees[i], IFeeManager.FeeHook.Continuous)) {\n                continuousFeesCount++;\n                implementsContinuousHook[i] = true;\n            }\n        }\nstart line 6334 column 8, end line 6339 column 8\nfor (uint256 i; i < fees.length; i++) {\n            if (implementsContinuousHook[i]) {\n                continuousFees_[continuousFeesIndex] = fees[i];\n                continuousFeesIndex++;\n            }\n        }","after":"// merge loop\n\nstart line 6319 column 8, end line 6324 column 8\nfor (uint256 i; i < fees.length; i++) {\n            if (feeManagerContract.feeSettlesOnHook(fees[i], IFeeManager.FeeHook.Continuous)) {\n                continuousFeesCount++;\n                implementsContinuousHook[i] = true;\n            }\n        }\nstart line 6334 column 8, end line 6339 column 8\nfor (uint256 i; i < fees.length; i++) {\n            if (implementsContinuousHook[i]) {\n                continuousFees_[continuousFeesIndex] = fees[i];\n                continuousFeesIndex++;\n            }\n        }","contract":"FundActionsWrapper","time":0},{"type":"loop-duplication","before":"\nstart line 9196 column 8, end line 9216 column 8\nfor (uint256 i = 0; i < _spendAssets.length; i++) {\n            // If spend asset's initial balance is 0, then it is an incoming asset\n            if (_preCallSpendAssetBalances[i] == 0) {\n                continue;\n            }\n\n            // Handle SpendAssetsHandleType.Remove separately\n            if (_spendAssetsHandleType == SpendAssetsHandleType.Remove) {\n                outgoingAssetsCount++;\n                continue;\n            }\n\n            // Determine if the asset is outgoing or incoming, and store the post-balance for later use\n            postCallSpendAssetBalances[i] = __getVaultAssetBalance(_vaultProxy, _spendAssets[i]);\n            // If the pre- and post- balances are equal, then the asset is neither incoming nor outgoing\n            if (postCallSpendAssetBalances[i] < _preCallSpendAssetBalances[i]) {\n                outgoingAssetsCount++;\n            } else if (postCallSpendAssetBalances[i] > _preCallSpendAssetBalances[i]) {\n                increasedSpendAssetsCount++;\n            }\n        }\nstart line 9225 column 8, end line 9263 column 8\nfor (uint256 i = 0; i < _spendAssets.length; i++) {\n            // If spend asset's initial balance is 0, then it is an incoming asset.\n            if (_preCallSpendAssetBalances[i] == 0) {\n                continue;\n            }\n\n            // Handle SpendAssetsHandleType.Remove separately.\n            // No need to validate the max spend asset amount.\n            if (_spendAssetsHandleType == SpendAssetsHandleType.Remove) {\n                outgoingAssets_[outgoingAssetsIndex] = _spendAssets[i];\n                outgoingAssetAmounts_[outgoingAssetsIndex] = _preCallSpendAssetBalances[i];\n                outgoingAssetsIndex++;\n                continue;\n            }\n\n            // If the pre- and post- balances are equal, then the asset is neither incoming nor outgoing\n            if (postCallSpendAssetBalances[i] < _preCallSpendAssetBalances[i]) {\n                if (postCallSpendAssetBalances[i] == 0) {\n                    __removeTrackedAsset(msg.sender, _spendAssets[i]);\n                    outgoingAssetAmounts_[outgoingAssetsIndex] = _preCallSpendAssetBalances[i];\n                } else {\n                    outgoingAssetAmounts_[outgoingAssetsIndex] = _preCallSpendAssetBalances[i].sub(\n                        postCallSpendAssetBalances[i]\n                    );\n                }\n                require(\n                    outgoingAssetAmounts_[outgoingAssetsIndex] <= _maxSpendAssetAmounts[i],\n                    \"__reconcileCoISpendAssets: Spent amount greater than expected\"\n                );\n\n                outgoingAssets_[outgoingAssetsIndex] = _spendAssets[i];\n                outgoingAssetsIndex++;\n            } else if (postCallSpendAssetBalances[i] > _preCallSpendAssetBalances[i]) {\n                increasedSpendAssetAmounts_[increasedSpendAssetsIndex] = postCallSpendAssetBalances[i]\n                .sub(_preCallSpendAssetBalances[i]);\n                increasedSpendAssets_[increasedSpendAssetsIndex] = _spendAssets[i];\n                increasedSpendAssetsIndex++;\n            }\n        }","after":"// merge loop\n\nstart line 9196 column 8, end line 9216 column 8\nfor (uint256 i = 0; i < _spendAssets.length; i++) {\n            // If spend asset's initial balance is 0, then it is an incoming asset\n            if (_preCallSpendAssetBalances[i] == 0) {\n                continue;\n            }\n\n            // Handle SpendAssetsHandleType.Remove separately\n            if (_spendAssetsHandleType == SpendAssetsHandleType.Remove) {\n                outgoingAssetsCount++;\n                continue;\n            }\n\n            // Determine if the asset is outgoing or incoming, and store the post-balance for later use\n            postCallSpendAssetBalances[i] = __getVaultAssetBalance(_vaultProxy, _spendAssets[i]);\n            // If the pre- and post- balances are equal, then the asset is neither incoming nor outgoing\n            if (postCallSpendAssetBalances[i] < _preCallSpendAssetBalances[i]) {\n                outgoingAssetsCount++;\n            } else if (postCallSpendAssetBalances[i] > _preCallSpendAssetBalances[i]) {\n                increasedSpendAssetsCount++;\n            }\n        }\nstart line 9225 column 8, end line 9263 column 8\nfor (uint256 i = 0; i < _spendAssets.length; i++) {\n            // If spend asset's initial balance is 0, then it is an incoming asset.\n            if (_preCallSpendAssetBalances[i] == 0) {\n                continue;\n            }\n\n            // Handle SpendAssetsHandleType.Remove separately.\n            // No need to validate the max spend asset amount.\n            if (_spendAssetsHandleType == SpendAssetsHandleType.Remove) {\n                outgoingAssets_[outgoingAssetsIndex] = _spendAssets[i];\n                outgoingAssetAmounts_[outgoingAssetsIndex] = _preCallSpendAssetBalances[i];\n                outgoingAssetsIndex++;\n                continue;\n            }\n\n            // If the pre- and post- balances are equal, then the asset is neither incoming nor outgoing\n            if (postCallSpendAssetBalances[i] < _preCallSpendAssetBalances[i]) {\n                if (postCallSpendAssetBalances[i] == 0) {\n                    __removeTrackedAsset(msg.sender, _spendAssets[i]);\n                    outgoingAssetAmounts_[outgoingAssetsIndex] = _preCallSpendAssetBalances[i];\n                } else {\n                    outgoingAssetAmounts_[outgoingAssetsIndex] = _preCallSpendAssetBalances[i].sub(\n                        postCallSpendAssetBalances[i]\n                    );\n                }\n                require(\n                    outgoingAssetAmounts_[outgoingAssetsIndex] <= _maxSpendAssetAmounts[i],\n                    \"__reconcileCoISpendAssets: Spent amount greater than expected\"\n                );\n\n                outgoingAssets_[outgoingAssetsIndex] = _spendAssets[i];\n                outgoingAssetsIndex++;\n            } else if (postCallSpendAssetBalances[i] > _preCallSpendAssetBalances[i]) {\n                increasedSpendAssetAmounts_[increasedSpendAssetsIndex] = postCallSpendAssetBalances[i]\n                .sub(_preCallSpendAssetBalances[i]);\n                increasedSpendAssets_[increasedSpendAssetsIndex] = _spendAssets[i];\n                increasedSpendAssetsIndex++;\n            }\n        }","contract":"IntegrationManager","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"MockCEtherIntegratee","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"MockCEtherIntegratee","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"MockCTokenIntegratee","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"MockCTokenIntegratee","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"MockChaiIntegratee","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"MockChaiIntegratee","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public DECIMALS;","after":"uint256 public immutable DECIMALS;","contract":"MockChainlinkPriceSource","time":0},{"type":"external-function ","before":"function multiSwap(\n        address _fromToken,\n        address _toToken,\n        uint256 _fromAmount,\n        uint256, // toAmount (min received amount)\n        uint256, // expectedAmount\n        IParaSwapAugustusSwapper.Path[] memory _paths,\n        uint256, // mintPrice\n        address, // beneficiary\n        uint256, // donationPercentage\n        string memory // referrer\n    ) public payable returns (uint256) {\n        return __multiSwap(_fromToken, _toToken, _fromAmount, _paths);\n    }","after":"function multiSwap(\n        address _fromToken,\n        address _toToken,\n        uint256 _fromAmount,\n        uint256, // toAmount (min received amount)\n        uint256, // expectedAmount\n        IParaSwapAugustusSwapper.Path[] calldata _paths,\n        uint256, // mintPrice\n        address, // beneficiary\n        uint256, // donationPercentage\n        string calldata // referrer\n    ) public payable returns (uint256) {\n        return __multiSwap(_fromToken, _toToken, _fromAmount, _paths);\n    }","contract":"MockParaSwapIntegratee","time":0},{"type":"immutable-restrict-modification ","before":"uint256 private blockNumberDeviation;","after":"uint256 private immutable blockNumberDeviation;","contract":"MockParaSwapIntegratee","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"MockReentrancyToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"MockReentrancyToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"MockSynthetixToken","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"MockSynthetixToken","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"MockUniswapV2PriceSource","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"MockUniswapV2PriceSource","time":0},{"type":"constant-restrict-modification  ","before":"address internal migrator;","after":"address internal constant migrator;","contract":"MockVaultLib","time":0},{"type":"constant-restrict-modification  ","before":"string internal sharesSymbol;","after":"string internal constant sharesSymbol;","contract":"MockVaultLib","time":0},{"type":"de-morgan-condition ","before":"!policyImplementsHook(_policy, PolicyHook.PreCallOnIntegration) &&\n        !policyImplementsHook(_policy, PolicyHook.PostCallOnIntegration)","after":"!(policyImplementsHook(_policy, PolicyHook.PreCallOnIntegration) &&\n        policyImplementsHook(_policy, PolicyHook.PostCallOnIntegration))","loc":{"start":{"line":13225,"column":12},"end":{"line":13226,"column":71}},"contract":"PolicyManager","time":0},{"type":"constant-restrict-modification  ","before":"string internal sharesSymbol;","after":"string internal constant sharesSymbol;","contract":"VaultLib","time":1}]}