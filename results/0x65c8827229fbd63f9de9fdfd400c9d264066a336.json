{"time":317,"results":[{"type":"external-function ","before":"function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        TokenControllerInterface _controller\n    )\n    public\n    virtual\n    initializer\n    {\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(\"PoolTogether ControlledToken\");\n        controller = _controller;\n        _setupDecimals(_decimals);\n    }","after":"function initialize(\n        string calldata _name,\n        string calldata _symbol,\n        uint8 _decimals,\n        TokenControllerInterface _controller\n    )\n    public\n    virtual\n    initializer\n    {\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(\"PoolTogether ControlledToken\");\n        controller = _controller;\n        _setupDecimals(_decimals);\n    }","contract":"ControlledToken","time":0},{"type":"loop-duplication","before":"\nstart line 2541 column 8, end line 2548 column 8\n   for (i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (_unlockTimestamps[user] <= _currentTime()) {\n                totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);\n                balances[i] = _timelockBalances[user];\n                delete _timelockBalances[user];\n            }\n      \nstart line 2561 column 8, end line 2569 column 8\n   for (i = 0; i < users.length; i++) {\n            if (balances[i] > 0) {\n                delete _unlockTimestamps[users[i]];\n                uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);\n                uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);\n                underlyingToken.safeTransfer(users[i], transferAmount);\n                emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);\n            }\n      ","after":"// merge loop\n\nstart line 2541 column 8, end line 2548 column 8\n   for (i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (_unlockTimestamps[user] <= _currentTime()) {\n                totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);\n                balances[i] = _timelockBalances[user];\n                delete _timelockBalances[user];\n            }\n      \nstart line 2561 column 8, end line 2569 column 8\n   for (i = 0; i < users.length; i++) {\n            if (balances[i] > 0) {\n                delete _unlockTimestamps[users[i]];\n                uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);\n                uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);\n                underlyingToken.safeTransfer(users[i], transferAmount);\n                emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);\n            }\n      ","contract":"PrizePool","time":0},{"type":"external-function ","before":"   function initializeYieldSourcePrizePool(\n        RegistryInterface _reserveRegistry,\n        ControlledTokenInterface[] memory _controlledTokens,\n        uint256 _maxExitFeeMantissa,\n        uint256 _maxTimelockDuration,\n        IYieldSource _yieldSource\n    )\n    public\n    initializer\n    {\n        require(address(_yieldSource) != address(0), \"YieldSourcePrizePool/yield-source-zero\");\n        PrizePool.initialize(\n            _reserveRegistry,\n            _controlledTokens,\n            _maxExitFeeMantissa,\n            _maxTimelockDuration\n        );\n        yieldSource = _yieldSource;\n\n        // A hack to determine whether it's an actual yield source\n        (bool succeeded,) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));\n        require(succeeded, \"YieldSourcePrizePool/invalid-yield-source\");\n\n        emit YieldSourcePrizePoolInitialized(address(_yieldSource));\n  ","after":"   function initializeYieldSourcePrizePool(\n        RegistryInterface _reserveRegistry,\n        ControlledTokenInterface[] calldata _controlledTokens,\n        uint256 _maxExitFeeMantissa,\n        uint256 _maxTimelockDuration,\n        IYieldSource _yieldSource\n    )\n    public\n    initializer\n    {\n        require(address(_yieldSource) != address(0), \"YieldSourcePrizePool/yield-source-zero\");\n        PrizePool.initialize(\n            _reserveRegistry,\n            _controlledTokens,\n            _maxExitFeeMantissa,\n            _maxTimelockDuration\n        );\n        yieldSource = _yieldSource;\n\n        // A hack to determine whether it's an actual yield source\n        (bool succeeded,) = address(_yieldSource).staticcall(abi.encode(_yieldSource.depositToken.selector));\n        require(succeeded, \"YieldSourcePrizePool/invalid-yield-source\");\n\n        emit YieldSourcePrizePoolInitialized(address(_yieldSource));\n  ","contract":"YieldSourcePrizePool","time":0},{"type":"external-function ","before":"   function initialize(\n        RegistryInterface _reserveRegistry,\n        ControlledTokenInterface[] memory _controlledTokens,\n        uint256 _maxExitFeeMantissa,\n        uint256 _maxTimelockDuration\n    )\n    public\n    initializer\n    {\n        require(address(_reserveRegistry) != address(0), \"PrizePool/reserveRegistry-not-zero\");\n        _tokens.initialize();\n        for (uint256 i = 0; i < _controlledTokens.length; i++) {\n            _addControlledToken(_controlledTokens[i]);\n        }\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        _setLiquidityCap(uint256(- 1));\n\n        reserveRegistry = _reserveRegistry;\n        maxExitFeeMantissa = _maxExitFeeMantissa;\n        maxTimelockDuration = _maxTimelockDuration;\n\n        emit Initialized(\n            address(_reserveRegistry),\n            maxExitFeeMantissa,\n            maxTimelockDuration\n        );\n  ","after":"   function initialize(\n        RegistryInterface _reserveRegistry,\n        ControlledTokenInterface[] calldata _controlledTokens,\n        uint256 _maxExitFeeMantissa,\n        uint256 _maxTimelockDuration\n    )\n    public\n    initializer\n    {\n        require(address(_reserveRegistry) != address(0), \"PrizePool/reserveRegistry-not-zero\");\n        _tokens.initialize();\n        for (uint256 i = 0; i < _controlledTokens.length; i++) {\n            _addControlledToken(_controlledTokens[i]);\n        }\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        _setLiquidityCap(uint256(- 1));\n\n        reserveRegistry = _reserveRegistry;\n        maxExitFeeMantissa = _maxExitFeeMantissa;\n        maxTimelockDuration = _maxTimelockDuration;\n\n        emit Initialized(\n            address(_reserveRegistry),\n            maxExitFeeMantissa,\n            maxTimelockDuration\n        );\n  ","contract":"YieldSourcePrizePool","time":0}]}