{"time":201,"results":[{"type":"external-function ","before":"  function tokenAllowAll(\n        address[] memory tokensToApprove,\n        address spender\n    ) external onlyApprover {\n        for (uint i = 0; i < tokensToApprove.length; i++) {\n            IERC20 token = IERC20(tokensToApprove[i]);\n            if (token.allowance(address(this), spender) != uint256(- 1)) {\n                token.safeApprove(spender, uint256(- 1));\n            }\n        }\n   ","after":"  function tokenAllowAll(\n        address[] calldata tokensToApprove,\n        address spender\n    ) external onlyApprover {\n        for (uint i = 0; i < tokensToApprove.length; i++) {\n            IERC20 token = IERC20(tokensToApprove[i]);\n            if (token.allowance(address(this), spender) != uint256(- 1)) {\n                token.safeApprove(spender, uint256(- 1));\n            }\n        }\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function tokenAllow(\n        address[] memory tokensToApprove,\n        uint256[] memory approvalAmounts,\n        address spender\n    ) external onlyApprover {\n        require(tokensToApprove.length == approvalAmounts.length, \"not same length\");\n        for (uint i = 0; i < tokensToApprove.length; i++) {\n            IERC20 token = IERC20(tokensToApprove[i]);\n            if (token.allowance(address(this), spender) != uint256(- 1)) {\n                token.safeApprove(spender, approvalAmounts[i]);\n            }\n        }\n   ","after":"  function tokenAllow(\n        address[] calldata tokensToApprove,\n        uint256[] calldata approvalAmounts,\n        address spender\n    ) external onlyApprover {\n        require(tokensToApprove.length == approvalAmounts.length, \"not same length\");\n        for (uint i = 0; i < tokensToApprove.length; i++) {\n            IERC20 token = IERC20(tokensToApprove[i]);\n            if (token.allowance(address(this), spender) != uint256(- 1)) {\n                token.safeApprove(spender, approvalAmounts[i]);\n            }\n        }\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function estimateQueryCost(bytes memory script, uint256[] memory inputLocations) public {\n        queryEngine.queryAllPrices(script, inputLocations);\n   ","after":"  function estimateQueryCost(bytes calldata script, uint256[] calldata inputLocations) public {\n        queryEngine.queryAllPrices(script, inputLocations);\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function makeTrade(\n        bytes memory executeScript,\n        uint256 ethValue\n    ) public onlyTrader nonReentrant mustBeProfitable(ethValue) {\n        execute(executeScript, ethValue);\n   ","after":"  function makeTrade(\n        bytes calldata executeScript,\n        uint256 ethValue\n    ) public onlyTrader nonReentrant mustBeProfitable(ethValue) {\n        execute(executeScript, ethValue);\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function makeTrade(\n        bytes memory executeScript,\n        uint256 ethValue,\n        uint256 blockDeadline\n    ) public onlyTrader nonReentrant notExpired(blockDeadline) mustBeProfitable(ethValue) {\n        execute(executeScript, ethValue);\n   ","after":"  function makeTrade(\n        bytes calldata executeScript,\n        uint256 ethValue,\n        uint256 blockDeadline\n    ) public onlyTrader nonReentrant notExpired(blockDeadline) mustBeProfitable(ethValue) {\n        execute(executeScript, ethValue);\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function makeTrade(\n        bytes memory executeScript,\n        uint256 ethValue,\n        uint256 minTimestamp,\n        uint256 maxTimestamp\n    ) public onlyTrader nonReentrant onTime(minTimestamp, maxTimestamp) mustBeProfitable(ethValue) {\n        execute(executeScript, ethValue);\n   ","after":"  function makeTrade(\n        bytes calldata executeScript,\n        uint256 ethValue,\n        uint256 minTimestamp,\n        uint256 maxTimestamp\n    ) public onlyTrader nonReentrant onTime(minTimestamp, maxTimestamp) mustBeProfitable(ethValue) {\n        execute(executeScript, ethValue);\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function makeTrade(\n        bytes memory queryScript,\n        uint256[] memory queryInputLocations,\n        bytes memory executeScript,\n        uint256[] memory executeInputLocations,\n        uint256 targetPrice,\n        uint256 ethValue\n    ) public onlyTrader nonReentrant mustBeProfitable(ethValue) {\n        bytes memory prices = queryEngine.queryAllPrices(queryScript, queryInputLocations);\n        require(prices.toUint256(prices.length - 32) > targetPrice, \"Not profitable\");\n        for (uint i = 0; i < executeInputLocations.length; i++) {\n            replaceDataAt(executeScript, prices.slice(i * 32, (i + 1) * 32), executeInputLocations[i]);\n        }\n        execute(executeScript, ethValue);\n   ","after":"  function makeTrade(\n        bytes calldata queryScript,\n        uint256[] calldata queryInputLocations,\n        bytes calldata executeScript,\n        uint256[] calldata executeInputLocations,\n        uint256 targetPrice,\n        uint256 ethValue\n    ) public onlyTrader nonReentrant mustBeProfitable(ethValue) {\n        bytes memory prices = queryEngine.queryAllPrices(queryScript, queryInputLocations);\n        require(prices.toUint256(prices.length - 32) > targetPrice, \"Not profitable\");\n        for (uint i = 0; i < executeInputLocations.length; i++) {\n            replaceDataAt(executeScript, prices.slice(i * 32, (i + 1) * 32), executeInputLocations[i]);\n        }\n        execute(executeScript, ethValue);\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function makeTrade(\n        bytes memory queryScript,\n        uint256[] memory queryInputLocations,\n        bytes memory executeScript,\n        uint256[] memory executeInputLocations,\n        uint256 targetPrice,\n        uint256 ethValue,\n        uint256 blockDeadline\n    ) public onlyTrader nonReentrant notExpired(blockDeadline) mustBeProfitable(ethValue) {\n        bytes memory prices = queryEngine.queryAllPrices(queryScript, queryInputLocations);\n        require(prices.toUint256(prices.length - 32) > targetPrice, \"Not profitable\");\n        for (uint i = 0; i < executeInputLocations.length; i++) {\n            replaceDataAt(executeScript, prices.slice(i * 32, (i + 1) * 32), executeInputLocations[i]);\n        }\n        execute(executeScript, ethValue);\n   ","after":"  function makeTrade(\n        bytes calldata queryScript,\n        uint256[] calldata queryInputLocations,\n        bytes calldata executeScript,\n        uint256[] calldata executeInputLocations,\n        uint256 targetPrice,\n        uint256 ethValue,\n        uint256 blockDeadline\n    ) public onlyTrader nonReentrant notExpired(blockDeadline) mustBeProfitable(ethValue) {\n        bytes memory prices = queryEngine.queryAllPrices(queryScript, queryInputLocations);\n        require(prices.toUint256(prices.length - 32) > targetPrice, \"Not profitable\");\n        for (uint i = 0; i < executeInputLocations.length; i++) {\n            replaceDataAt(executeScript, prices.slice(i * 32, (i + 1) * 32), executeInputLocations[i]);\n        }\n        execute(executeScript, ethValue);\n   ","contract":"Dispatcher","time":0},{"type":"external-function ","before":"  function makeTrade(\n        bytes memory queryScript,\n        uint256[] memory queryInputLocations,\n        bytes memory executeScript,\n        uint256[] memory executeInputLocations,\n        uint256 targetPrice,\n        uint256 ethValue,\n        uint256 minTimestamp,\n        uint256 maxTimestamp\n    ) public onlyTrader nonReentrant onTime(minTimestamp, maxTimestamp) mustBeProfitable(ethValue) {\n        bytes memory prices = queryEngine.queryAllPrices(queryScript, queryInputLocations);\n        require(prices.toUint256(prices.length - 32) > targetPrice, \"Not profitable\");\n        for (uint i = 0; i < executeInputLocations.length; i++) {\n            replaceDataAt(executeScript, prices.slice(i * 32, (i + 1) * 32), executeInputLocations[i]);\n        }\n        execute(executeScript, ethValue);\n   ","after":"  function makeTrade(\n        bytes calldata queryScript,\n        uint256[] calldata queryInputLocations,\n        bytes calldata executeScript,\n        uint256[] calldata executeInputLocations,\n        uint256 targetPrice,\n        uint256 ethValue,\n        uint256 minTimestamp,\n        uint256 maxTimestamp\n    ) public onlyTrader nonReentrant onTime(minTimestamp, maxTimestamp) mustBeProfitable(ethValue) {\n        bytes memory prices = queryEngine.queryAllPrices(queryScript, queryInputLocations);\n        require(prices.toUint256(prices.length - 32) > targetPrice, \"Not profitable\");\n        for (uint i = 0; i < executeInputLocations.length; i++) {\n            replaceDataAt(executeScript, prices.slice(i * 32, (i + 1) * 32), executeInputLocations[i]);\n        }\n        execute(executeScript, ethValue);\n   ","contract":"Dispatcher","time":0},{"type":"immutable-restrict-modification ","before":"  uint8 public versio","after":"  uint8 public versio","contract":"Dispatcher","time":1},{"type":"external-function ","before":"  function createNewDispatcher(\n        address queryEngine,\n        address roleManager,\n        address lpManager,\n        address withdrawer,\n        address trader,\n        address supplier,\n        uint256 initialMaxLiquidity,\n        address[] memory lpWhitelist\n    ) external onlyAdmin returns (\n        address dispatcher\n    ) {\n        Dispatcher newDispatcher = new Dispatcher(\n            version,\n            queryEngine,\n            roleManager,\n            lpManager,\n            withdrawer,\n            trader,\n            supplier,\n            initialMaxLiquidity,\n            lpWhitelist\n        );\n\n        dispatcher = address(newDispatcher);\n\n        emit DispatcherCreated(\n            dispatcher,\n            version,\n            queryEngine,\n            roleManager,\n            lpManager,\n            withdrawer,\n            trader,\n            supplier,\n            initialMaxLiquidity,\n            lpWhitelist.length > 0 ? true : false\n        );\n   ","after":"  function createNewDispatcher(\n        address queryEngine,\n        address roleManager,\n        address lpManager,\n        address withdrawer,\n        address trader,\n        address supplier,\n        uint256 initialMaxLiquidity,\n        address[] calldata lpWhitelist\n    ) external onlyAdmin returns (\n        address dispatcher\n    ) {\n        Dispatcher newDispatcher = new Dispatcher(\n            version,\n            queryEngine,\n            roleManager,\n            lpManager,\n            withdrawer,\n            trader,\n            supplier,\n            initialMaxLiquidity,\n            lpWhitelist\n        );\n\n        dispatcher = address(newDispatcher);\n\n        emit DispatcherCreated(\n            dispatcher,\n            version,\n            queryEngine,\n            roleManager,\n            lpManager,\n            withdrawer,\n            trader,\n            supplier,\n            initialMaxLiquidity,\n            lpWhitelist.length > 0 ? true : false\n        );\n   ","contract":"DispatcherFactory","time":0},{"type":"constant-restrict-modification  ","before":"  uint8 public version = ","after":"  uint8 public constant version = ","contract":"DispatcherFactory","time":0}]}