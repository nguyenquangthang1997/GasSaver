{"time":2273,"results":[{"type":"external-function ","before":"function engage(string memory _exchangeName) external onlyOperator {\n        ActionInfo memory engageInfo = _createActionInfo();\n\n        require(engageInfo.setTotalSupply > 0, \"SetToken must have > 0 supply\");\n        require(engageInfo.collateralBalance > 0, \"Collateral balance must be > 0\");\n        require(engageInfo.borrowBalance == 0, \"Debt must be 0\");\n\n        LeverageInfo memory leverageInfo = LeverageInfo({\n        action : engageInfo,\n        currentLeverageRatio : PreciseUnitMath.preciseUnit(), // 1x leverage in precise units\n        slippageTolerance : execution.slippageTolerance,\n        twapMaxTradeSize : exchangeSettings[_exchangeName].twapMaxTradeSize,\n        exchangeName : _exchangeName\n        });\n\n        // Calculate total rebalance units and kick off TWAP if above max borrow or max trade size\n        (\n        uint256 chunkRebalanceNotional,\n        uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, methodology.targetLeverageRatio, true);\n\n        _lever(leverageInfo, chunkRebalanceNotional);\n\n        _updateRebalanceState(\n            chunkRebalanceNotional,\n            totalRebalanceNotional,\n            methodology.targetLeverageRatio,\n            _exchangeName\n        );\n\n        emit Engaged(\n            leverageInfo.currentLeverageRatio,\n            methodology.targetLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","after":"function engage(string calldata _exchangeName) external onlyOperator {\n        ActionInfo memory engageInfo = _createActionInfo();\n\n        require(engageInfo.setTotalSupply > 0, \"SetToken must have > 0 supply\");\n        require(engageInfo.collateralBalance > 0, \"Collateral balance must be > 0\");\n        require(engageInfo.borrowBalance == 0, \"Debt must be 0\");\n\n        LeverageInfo memory leverageInfo = LeverageInfo({\n        action : engageInfo,\n        currentLeverageRatio : PreciseUnitMath.preciseUnit(), // 1x leverage in precise units\n        slippageTolerance : execution.slippageTolerance,\n        twapMaxTradeSize : exchangeSettings[_exchangeName].twapMaxTradeSize,\n        exchangeName : _exchangeName\n        });\n\n        // Calculate total rebalance units and kick off TWAP if above max borrow or max trade size\n        (\n        uint256 chunkRebalanceNotional,\n        uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, methodology.targetLeverageRatio, true);\n\n        _lever(leverageInfo, chunkRebalanceNotional);\n\n        _updateRebalanceState(\n            chunkRebalanceNotional,\n            totalRebalanceNotional,\n            methodology.targetLeverageRatio,\n            _exchangeName\n        );\n\n        emit Engaged(\n            leverageInfo.currentLeverageRatio,\n            methodology.targetLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","contract":"AaveLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function rebalance(string memory _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        // use globalLastTradeTimestamps to prevent multiple rebalances being called with different exchanges during the epoch rebalance\n        _validateNormalRebalance(leverageInfo, methodology.rebalanceInterval, globalLastTradeTimestamp);\n        _validateNonTWAP();\n\n        uint256 newLeverageRatio = _calculateNewLeverageRatio(leverageInfo.currentLeverageRatio);\n\n        (\n        uint256 chunkRebalanceNotional,\n        uint256 totalRebalanceNotional\n        ) = _handleRebalance(leverageInfo, newLeverageRatio);\n\n        _updateRebalanceState(chunkRebalanceNotional, totalRebalanceNotional, newLeverageRatio, _exchangeName);\n\n        emit Rebalanced(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","after":"function rebalance(string calldata _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        // use globalLastTradeTimestamps to prevent multiple rebalances being called with different exchanges during the epoch rebalance\n        _validateNormalRebalance(leverageInfo, methodology.rebalanceInterval, globalLastTradeTimestamp);\n        _validateNonTWAP();\n\n        uint256 newLeverageRatio = _calculateNewLeverageRatio(leverageInfo.currentLeverageRatio);\n\n        (\n        uint256 chunkRebalanceNotional,\n        uint256 totalRebalanceNotional\n        ) = _handleRebalance(leverageInfo, newLeverageRatio);\n\n        _updateRebalanceState(chunkRebalanceNotional, totalRebalanceNotional, newLeverageRatio, _exchangeName);\n\n        emit Rebalanced(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","contract":"AaveLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function iterateRebalance(string memory _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        // Use the exchangeLastTradeTimestamp since cooldown periods are measured on a per-exchange basis, allowing it to rebalance multiple time in quick\n        // succession with different exchanges\n        _validateNormalRebalance(leverageInfo, execution.twapCooldownPeriod, exchangeSettings[_exchangeName].exchangeLastTradeTimestamp);\n        _validateTWAP();\n\n        uint256 chunkRebalanceNotional;\n        uint256 totalRebalanceNotional;\n        if (!_isAdvantageousTWAP(leverageInfo.currentLeverageRatio)) {\n            (chunkRebalanceNotional, totalRebalanceNotional) = _handleRebalance(leverageInfo, twapLeverageRatio);\n        }\n\n        // If not advantageous, then rebalance is skipped and chunk and total rebalance notional are both 0, which means TWAP state is\n        // cleared\n        _updateIterateState(chunkRebalanceNotional, totalRebalanceNotional, _exchangeName);\n\n        emit RebalanceIterated(\n            leverageInfo.currentLeverageRatio,\n            twapLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","after":"function iterateRebalance(string calldata _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        // Use the exchangeLastTradeTimestamp since cooldown periods are measured on a per-exchange basis, allowing it to rebalance multiple time in quick\n        // succession with different exchanges\n        _validateNormalRebalance(leverageInfo, execution.twapCooldownPeriod, exchangeSettings[_exchangeName].exchangeLastTradeTimestamp);\n        _validateTWAP();\n\n        uint256 chunkRebalanceNotional;\n        uint256 totalRebalanceNotional;\n        if (!_isAdvantageousTWAP(leverageInfo.currentLeverageRatio)) {\n            (chunkRebalanceNotional, totalRebalanceNotional) = _handleRebalance(leverageInfo, twapLeverageRatio);\n        }\n\n        // If not advantageous, then rebalance is skipped and chunk and total rebalance notional are both 0, which means TWAP state is\n        // cleared\n        _updateIterateState(chunkRebalanceNotional, totalRebalanceNotional, _exchangeName);\n\n        emit RebalanceIterated(\n            leverageInfo.currentLeverageRatio,\n            twapLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","contract":"AaveLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function ripcord(string memory _exchangeName) external onlyEOA {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            incentive.incentivizedSlippageTolerance,\n            exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize,\n            _exchangeName\n        );\n\n        // Use the exchangeLastTradeTimestamp so it can ripcord quickly with multiple exchanges\n        _validateRipcord(leverageInfo, exchangeSettings[_exchangeName].exchangeLastTradeTimestamp);\n\n        (uint256 chunkRebalanceNotional,) = _calculateChunkRebalanceNotional(leverageInfo, methodology.maxLeverageRatio, false);\n\n        _delever(leverageInfo, chunkRebalanceNotional);\n\n        _updateRipcordState(_exchangeName);\n\n        uint256 etherTransferred = _transferEtherRewardToCaller(incentive.etherReward);\n\n        emit RipcordCalled(\n            leverageInfo.currentLeverageRatio,\n            methodology.maxLeverageRatio,\n            chunkRebalanceNotional,\n            etherTransferred\n        );\n    }","after":"function ripcord(string calldata _exchangeName) external onlyEOA {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            incentive.incentivizedSlippageTolerance,\n            exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize,\n            _exchangeName\n        );\n\n        // Use the exchangeLastTradeTimestamp so it can ripcord quickly with multiple exchanges\n        _validateRipcord(leverageInfo, exchangeSettings[_exchangeName].exchangeLastTradeTimestamp);\n\n        (uint256 chunkRebalanceNotional,) = _calculateChunkRebalanceNotional(leverageInfo, methodology.maxLeverageRatio, false);\n\n        _delever(leverageInfo, chunkRebalanceNotional);\n\n        _updateRipcordState(_exchangeName);\n\n        uint256 etherTransferred = _transferEtherRewardToCaller(incentive.etherReward);\n\n        emit RipcordCalled(\n            leverageInfo.currentLeverageRatio,\n            methodology.maxLeverageRatio,\n            chunkRebalanceNotional,\n            etherTransferred\n        );\n    }","contract":"AaveLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function disengage(string memory _exchangeName) external onlyOperator {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        uint256 newLeverageRatio = PreciseUnitMath.preciseUnit();\n\n        (\n        uint256 chunkRebalanceNotional,\n        uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, newLeverageRatio, false);\n\n        if (totalRebalanceNotional > chunkRebalanceNotional) {\n            _delever(leverageInfo, chunkRebalanceNotional);\n        } else {\n            _deleverToZeroBorrowBalance(leverageInfo, totalRebalanceNotional);\n        }\n\n        emit Disengaged(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","after":"function disengage(string calldata _exchangeName) external onlyOperator {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        uint256 newLeverageRatio = PreciseUnitMath.preciseUnit();\n\n        (\n        uint256 chunkRebalanceNotional,\n        uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, newLeverageRatio, false);\n\n        if (totalRebalanceNotional > chunkRebalanceNotional) {\n            _delever(leverageInfo, chunkRebalanceNotional);\n        } else {\n            _deleverToZeroBorrowBalance(leverageInfo, totalRebalanceNotional);\n        }\n\n        emit Disengaged(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","contract":"AaveLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function setMethodologySettings(MethodologySettings memory _newMethodologySettings) external onlyOperator noRebalanceInProgress {\n        methodology = _newMethodologySettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit MethodologySettingsUpdated(\n            methodology.targetLeverageRatio,\n            methodology.minLeverageRatio,\n            methodology.maxLeverageRatio,\n            methodology.recenteringSpeed,\n            methodology.rebalanceInterval\n        );\n    }","after":"function setMethodologySettings(MethodologySettings calldata _newMethodologySettings) external onlyOperator noRebalanceInProgress {\n        methodology = _newMethodologySettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit MethodologySettingsUpdated(\n            methodology.targetLeverageRatio,\n            methodology.minLeverageRatio,\n            methodology.maxLeverageRatio,\n            methodology.recenteringSpeed,\n            methodology.rebalanceInterval\n        );\n    }","contract":"AaveLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function setExecutionSettings(ExecutionSettings memory _newExecutionSettings) external onlyOperator noRebalanceInProgress {\n        execution = _newExecutionSettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit ExecutionSettingsUpdated(\n            execution.unutilizedLeveragePercentage,\n            execution.twapCooldownPeriod,\n            execution.slippageTolerance\n        );\n    }","after":"function setExecutionSettings(ExecutionSettings calldata _newExecutionSettings) external onlyOperator noRebalanceInProgress {\n        execution = _newExecutionSettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit ExecutionSettingsUpdated(\n            execution.unutilizedLeveragePercentage,\n            execution.twapCooldownPeriod,\n            execution.slippageTolerance\n        );\n    }","contract":"AaveLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function setIncentiveSettings(IncentiveSettings memory _newIncentiveSettings) external onlyOperator noRebalanceInProgress {\n        incentive = _newIncentiveSettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit IncentiveSettingsUpdated(\n            incentive.etherReward,\n            incentive.incentivizedLeverageRatio,\n            incentive.incentivizedSlippageTolerance,\n            incentive.incentivizedTwapCooldownPeriod\n        );\n    }","after":"function setIncentiveSettings(IncentiveSettings calldata _newIncentiveSettings) external onlyOperator noRebalanceInProgress {\n        incentive = _newIncentiveSettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit IncentiveSettingsUpdated(\n            incentive.etherReward,\n            incentive.incentivizedLeverageRatio,\n            incentive.incentivizedSlippageTolerance,\n            incentive.incentivizedTwapCooldownPeriod\n        );\n    }","contract":"AaveLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function addEnabledExchange(\n        string memory _exchangeName,\n        ExchangeSettings memory _exchangeSettings\n    )\n    external\n    onlyOperator\n    {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize == 0, \"Exchange already enabled\");\n        _validateExchangeSettings(_exchangeSettings);\n\n        exchangeSettings[_exchangeName].twapMaxTradeSize = _exchangeSettings.twapMaxTradeSize;\n        exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize = _exchangeSettings.incentivizedTwapMaxTradeSize;\n        exchangeSettings[_exchangeName].leverExchangeData = _exchangeSettings.leverExchangeData;\n        exchangeSettings[_exchangeName].deleverExchangeData = _exchangeSettings.deleverExchangeData;\n        exchangeSettings[_exchangeName].exchangeLastTradeTimestamp = 0;\n\n        enabledExchanges.push(_exchangeName);\n\n        emit ExchangeAdded(\n            _exchangeName,\n            _exchangeSettings.twapMaxTradeSize,\n            _exchangeSettings.exchangeLastTradeTimestamp,\n            _exchangeSettings.incentivizedTwapMaxTradeSize,\n            _exchangeSettings.leverExchangeData,\n            _exchangeSettings.deleverExchangeData\n        );\n    }","after":"function addEnabledExchange(\n        string calldata _exchangeName,\n        ExchangeSettings calldata _exchangeSettings\n    )\n    external\n    onlyOperator\n    {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize == 0, \"Exchange already enabled\");\n        _validateExchangeSettings(_exchangeSettings);\n\n        exchangeSettings[_exchangeName].twapMaxTradeSize = _exchangeSettings.twapMaxTradeSize;\n        exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize = _exchangeSettings.incentivizedTwapMaxTradeSize;\n        exchangeSettings[_exchangeName].leverExchangeData = _exchangeSettings.leverExchangeData;\n        exchangeSettings[_exchangeName].deleverExchangeData = _exchangeSettings.deleverExchangeData;\n        exchangeSettings[_exchangeName].exchangeLastTradeTimestamp = 0;\n\n        enabledExchanges.push(_exchangeName);\n\n        emit ExchangeAdded(\n            _exchangeName,\n            _exchangeSettings.twapMaxTradeSize,\n            _exchangeSettings.exchangeLastTradeTimestamp,\n            _exchangeSettings.incentivizedTwapMaxTradeSize,\n            _exchangeSettings.leverExchangeData,\n            _exchangeSettings.deleverExchangeData\n        );\n    }","contract":"AaveLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function removeEnabledExchange(string memory _exchangeName) external onlyOperator {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize != 0, \"Exchange not enabled\");\n\n        delete exchangeSettings[_exchangeName];\n        enabledExchanges.removeStorage(_exchangeName);\n\n        emit ExchangeRemoved(_exchangeName);\n    }","after":"function removeEnabledExchange(string calldata _exchangeName) external onlyOperator {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize != 0, \"Exchange not enabled\");\n\n        delete exchangeSettings[_exchangeName];\n        enabledExchanges.removeStorage(_exchangeName);\n\n        emit ExchangeRemoved(_exchangeName);\n    }","contract":"AaveLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function updateEnabledExchange(\n        string memory _exchangeName,\n        ExchangeSettings memory _exchangeSettings\n    )\n    external\n    onlyOperator\n    {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize != 0, \"Exchange not enabled\");\n        _validateExchangeSettings(_exchangeSettings);\n\n        exchangeSettings[_exchangeName].twapMaxTradeSize = _exchangeSettings.twapMaxTradeSize;\n        exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize = _exchangeSettings.incentivizedTwapMaxTradeSize;\n        exchangeSettings[_exchangeName].leverExchangeData = _exchangeSettings.leverExchangeData;\n        exchangeSettings[_exchangeName].deleverExchangeData = _exchangeSettings.deleverExchangeData;\n\n        emit ExchangeUpdated(\n            _exchangeName,\n            _exchangeSettings.twapMaxTradeSize,\n            _exchangeSettings.exchangeLastTradeTimestamp,\n            _exchangeSettings.incentivizedTwapMaxTradeSize,\n            _exchangeSettings.leverExchangeData,\n            _exchangeSettings.deleverExchangeData\n        );\n    }","after":"function updateEnabledExchange(\n        string calldata _exchangeName,\n        ExchangeSettings calldata _exchangeSettings\n    )\n    external\n    onlyOperator\n    {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize != 0, \"Exchange not enabled\");\n        _validateExchangeSettings(_exchangeSettings);\n\n        exchangeSettings[_exchangeName].twapMaxTradeSize = _exchangeSettings.twapMaxTradeSize;\n        exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize = _exchangeSettings.incentivizedTwapMaxTradeSize;\n        exchangeSettings[_exchangeName].leverExchangeData = _exchangeSettings.leverExchangeData;\n        exchangeSettings[_exchangeName].deleverExchangeData = _exchangeSettings.deleverExchangeData;\n\n        emit ExchangeUpdated(\n            _exchangeName,\n            _exchangeSettings.twapMaxTradeSize,\n            _exchangeSettings.exchangeLastTradeTimestamp,\n            _exchangeSettings.incentivizedTwapMaxTradeSize,\n            _exchangeSettings.leverExchangeData,\n            _exchangeSettings.deleverExchangeData\n        );\n    }","contract":"AaveLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function getExchangeSettings(string memory _exchangeName) external view returns (ExchangeSettings memory) {\n        return exchangeSettings[_exchangeName];\n    }","after":"function getExchangeSettings(string calldata _exchangeName) external view returns (ExchangeSettings memory) {\n        return exchangeSettings[_exchangeName];\n    }","contract":"AaveLeverageStrategyExtension","time":0},{"type":"state-data-arrangement ","before":"\nISetToken public setToken;\naddress[] internal extensions;\nmapping(address => bool) public isExtension;\naddress public operator;\naddress public methodologist;\nuint256 public emergencies;\nmapping(address => ProtectedModule) public protectedModules;\naddress[] public protectedModulesList;\nbool public initialized;","after":"ISetToken public setToken;\naddress[] internal extensions;\nmapping(address => bool) public isExtension;\nuint256 public emergencies;\nmapping(address => ProtectedModule) public protectedModules;\naddress[] public protectedModulesList;\naddress public operator;\naddress public methodologist;\nbool public initialized;\n","contract":"BaseManagerV2","time":0},{"type":"external-function ","before":"function interactManager(address _module, bytes memory _data) external onlyExtension {\n        require(initialized, \"Manager not initialized\");\n        require(_module != address(setToken), \"Extensions cannot call SetToken\");\n        require(_senderAuthorizedForModule(_module, msg.sender), \"Extension not authorized for module\");\n\n        // Invoke call to module, assume value will always be 0\n        _module.functionCallWithValue(_data, 0);\n    }","after":"function interactManager(address _module, bytes calldata _data) external onlyExtension {\n        require(initialized, \"Manager not initialized\");\n        require(_module != address(setToken), \"Extensions cannot call SetToken\");\n        require(_senderAuthorizedForModule(_module, msg.sender), \"Extension not authorized for module\");\n\n        // Invoke call to module, assume value will always be 0\n        _module.functionCallWithValue(_data, 0);\n    }","contract":"BaseManagerV2","time":0},{"type":"external-function ","before":"function protectModule(address _module, address[] memory _extensions)\n    external\n    upgradesPermitted\n    onlyOperator\n    {\n        require(setToken.getModules().contains(_module), \"Module not added yet\");\n        _protectModule(_module, _extensions);\n\n        emit ModuleProtected(_module, _extensions);\n    }","after":"function protectModule(address _module, address[] calldata _extensions)\n    external\n    upgradesPermitted\n    onlyOperator\n    {\n        require(setToken.getModules().contains(_module), \"Module not added yet\");\n        _protectModule(_module, _extensions);\n\n        emit ModuleProtected(_module, _extensions);\n    }","contract":"BaseManagerV2","time":0},{"type":"external-function ","before":"function replaceProtectedModule(address _oldModule, address _newModule, address[] memory _newExtensions)\n    external\n    mutualUpgrade(operator, methodologist)\n    {\n        _unProtectModule(_oldModule);\n\n        setToken.removeModule(_oldModule);\n        setToken.addModule(_newModule);\n\n        _protectModule(_newModule, _newExtensions);\n\n        emit ReplacedProtectedModule(_oldModule, _newModule, _newExtensions);\n    }","after":"function replaceProtectedModule(address _oldModule, address _newModule, address[] calldata _newExtensions)\n    external\n    mutualUpgrade(operator, methodologist)\n    {\n        _unProtectModule(_oldModule);\n\n        setToken.removeModule(_oldModule);\n        setToken.addModule(_newModule);\n\n        _protectModule(_newModule, _newExtensions);\n\n        emit ReplacedProtectedModule(_oldModule, _newModule, _newExtensions);\n    }","contract":"BaseManagerV2","time":0},{"type":"external-function ","before":"function emergencyReplaceProtectedModule(\n        address _module,\n        address[] memory _extensions\n    )\n    external\n    mutualUpgrade(operator, methodologist)\n    onlyEmergency\n    {\n        setToken.addModule(_module);\n        _protectModule(_module, _extensions);\n\n        emergencies -= 1;\n\n        emit EmergencyReplacedProtectedModule(_module, _extensions);\n    }","after":"function emergencyReplaceProtectedModule(\n        address _module,\n        address[] calldata _extensions\n    )\n    external\n    mutualUpgrade(operator, methodologist)\n    onlyEmergency\n    {\n        setToken.addModule(_module);\n        _protectModule(_module, _extensions);\n\n        emergencies -= 1;\n\n        emit EmergencyReplacedProtectedModule(_module, _extensions);\n    }","contract":"BaseManagerV2","time":0},{"type":"immutable-restrict-modification ","before":"address public WETH;","after":"address public immutable WETH;","contract":"ExchangeIssuance","time":1},{"type":"immutable-restrict-modification ","before":"address public WETH;","after":"address public immutable WETH;","contract":"ExchangeIssuanceV2","time":1},{"type":"immutable-restrict-modification ","before":"string public uniswapV3ExchangeName;","after":"string public immutable uniswapV3ExchangeName;","contract":"FLIRebalanceViewer","time":0},{"type":"immutable-restrict-modification ","before":"string public uniswapV2ExchangeName;","after":"string public immutable uniswapV2ExchangeName;","contract":"FLIRebalanceViewer","time":0},{"type":"external-function ","before":"function getExchangeSettings(string memory _exchangeName) external view returns (FlexibleLeverageStrategyExtension.ExchangeSettings memory) {\n        return exchangeSettings[_exchangeName];\n    }","after":"function getExchangeSettings(string calldata _exchangeName) external view returns (FlexibleLeverageStrategyExtension.ExchangeSettings memory) {\n        return exchangeSettings[_exchangeName];\n    }","contract":"FLIStrategyExtensionMock","time":0},{"type":"external-function ","before":"function setShouldRebalanceWithBounds(\n        string[] memory _shouldRebalanceNames,\n        FlexibleLeverageStrategyExtension.ShouldRebalance[] memory _shouldRebalancesEnums\n    )\n    external\n    {\n        shouldRebalanceNames = _shouldRebalanceNames;\n        shouldRebalancesEnums = _shouldRebalancesEnums;\n    }","after":"function setShouldRebalanceWithBounds(\n        string[] calldata _shouldRebalanceNames,\n        FlexibleLeverageStrategyExtension.ShouldRebalance[] calldata _shouldRebalancesEnums\n    )\n    external\n    {\n        shouldRebalanceNames = _shouldRebalanceNames;\n        shouldRebalancesEnums = _shouldRebalancesEnums;\n    }","contract":"FLIStrategyExtensionMock","time":0},{"type":"external-function ","before":"function setGetChunkRebalanceWithBounds(\n        uint256[] memory _chunkRebalanceSizes,\n        address _chunkRebalanceSellAsset,\n        address _chunkRebalanceBuyAsset\n    )\n    external\n    {\n        chunkRebalanceSizes = _chunkRebalanceSizes;\n        chunkRebalanceSellAsset = _chunkRebalanceSellAsset;\n        chunkRebalanceBuyAsset = _chunkRebalanceBuyAsset;\n    }","after":"function setGetChunkRebalanceWithBounds(\n        uint256[] calldata _chunkRebalanceSizes,\n        address _chunkRebalanceSellAsset,\n        address _chunkRebalanceBuyAsset\n    )\n    external\n    {\n        chunkRebalanceSizes = _chunkRebalanceSizes;\n        chunkRebalanceSellAsset = _chunkRebalanceSellAsset;\n        chunkRebalanceBuyAsset = _chunkRebalanceBuyAsset;\n    }","contract":"FLIStrategyExtensionMock","time":0},{"type":"external-function ","before":"function setStrategy(FlexibleLeverageStrategyExtension.ContractSettings memory _strategy) external {\n        strategy = _strategy;\n    }","after":"function setStrategy(FlexibleLeverageStrategyExtension.ContractSettings calldata _strategy) external {\n        strategy = _strategy;\n    }","contract":"FLIStrategyExtensionMock","time":0},{"type":"external-function ","before":"function setExchangeSettings(string memory _exchangeName, FlexibleLeverageStrategyExtension.ExchangeSettings memory _settings) external {\n        exchangeSettings[_exchangeName] = _settings;\n    }","after":"function setExchangeSettings(string calldata _exchangeName, FlexibleLeverageStrategyExtension.ExchangeSettings calldata _settings) external {\n        exchangeSettings[_exchangeName] = _settings;\n    }","contract":"FLIStrategyExtensionMock","time":0},{"type":"immutable-restrict-modification ","before":"address public index;","after":"address public immutable index;","contract":"FTCVesting","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public vestingAmount;","after":"uint256 public immutable vestingAmount;","contract":"FTCVesting","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public vestingBegin;","after":"uint256 public immutable vestingBegin;","contract":"FTCVesting","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public vestingCliff;","after":"uint256 public immutable vestingCliff;","contract":"FTCVesting","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public vestingEnd;","after":"uint256 public immutable vestingEnd;","contract":"FTCVesting","time":0},{"type":"external-function ","before":"function initializeStreamingFeeModule(IStreamingFeeModule.FeeState memory _settings)\n    external\n    mutualUpgrade(manager.operator(), manager.methodologist())\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IStreamingFeeModule.initialize.selector,\n            manager.setToken(),\n            _settings\n        );\n\n        invokeManager(address(streamingFeeModule), callData);\n    }","after":"function initializeStreamingFeeModule(IStreamingFeeModule.FeeState calldata _settings)\n    external\n    mutualUpgrade(manager.operator(), manager.methodologist())\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IStreamingFeeModule.initialize.selector,\n            manager.setToken(),\n            _settings\n        );\n\n        invokeManager(address(streamingFeeModule), callData);\n    }","contract":"FeeSplitExtension","time":0},{"type":"external-function ","before":"function engage(string memory _exchangeName) external onlyOperator {\n        ActionInfo memory engageInfo = _createActionInfo();\n\n        require(engageInfo.setTotalSupply > 0, \"SetToken must have > 0 supply\");\n        require(engageInfo.collateralBalance > 0, \"Collateral balance must be > 0\");\n        require(engageInfo.borrowBalance == 0, \"Debt must be 0\");\n\n        LeverageInfo memory leverageInfo = LeverageInfo({\n        action : engageInfo,\n        currentLeverageRatio : PreciseUnitMath.preciseUnit(), // 1x leverage in precise units\n        slippageTolerance : execution.slippageTolerance,\n        twapMaxTradeSize : exchangeSettings[_exchangeName].twapMaxTradeSize,\n        exchangeName : _exchangeName\n        });\n\n        // Calculate total rebalance units and kick off TWAP if above max borrow or max trade size\n        (\n        uint256 chunkRebalanceNotional,\n        uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, methodology.targetLeverageRatio, true);\n\n        _lever(leverageInfo, chunkRebalanceNotional);\n\n        _updateRebalanceState(\n            chunkRebalanceNotional,\n            totalRebalanceNotional,\n            methodology.targetLeverageRatio,\n            _exchangeName\n        );\n\n        emit Engaged(\n            leverageInfo.currentLeverageRatio,\n            methodology.targetLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","after":"function engage(string calldata _exchangeName) external onlyOperator {\n        ActionInfo memory engageInfo = _createActionInfo();\n\n        require(engageInfo.setTotalSupply > 0, \"SetToken must have > 0 supply\");\n        require(engageInfo.collateralBalance > 0, \"Collateral balance must be > 0\");\n        require(engageInfo.borrowBalance == 0, \"Debt must be 0\");\n\n        LeverageInfo memory leverageInfo = LeverageInfo({\n        action : engageInfo,\n        currentLeverageRatio : PreciseUnitMath.preciseUnit(), // 1x leverage in precise units\n        slippageTolerance : execution.slippageTolerance,\n        twapMaxTradeSize : exchangeSettings[_exchangeName].twapMaxTradeSize,\n        exchangeName : _exchangeName\n        });\n\n        // Calculate total rebalance units and kick off TWAP if above max borrow or max trade size\n        (\n        uint256 chunkRebalanceNotional,\n        uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, methodology.targetLeverageRatio, true);\n\n        _lever(leverageInfo, chunkRebalanceNotional);\n\n        _updateRebalanceState(\n            chunkRebalanceNotional,\n            totalRebalanceNotional,\n            methodology.targetLeverageRatio,\n            _exchangeName\n        );\n\n        emit Engaged(\n            leverageInfo.currentLeverageRatio,\n            methodology.targetLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function rebalance(string memory _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        // use globalLastTradeTimestamps to prevent multiple rebalances being called with different exchanges during the epoch rebalance\n        _validateNormalRebalance(leverageInfo, methodology.rebalanceInterval, globalLastTradeTimestamp);\n        _validateNonTWAP();\n\n        uint256 newLeverageRatio = _calculateNewLeverageRatio(leverageInfo.currentLeverageRatio);\n\n        (\n        uint256 chunkRebalanceNotional,\n        uint256 totalRebalanceNotional\n        ) = _handleRebalance(leverageInfo, newLeverageRatio);\n\n        _updateRebalanceState(chunkRebalanceNotional, totalRebalanceNotional, newLeverageRatio, _exchangeName);\n\n        emit Rebalanced(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","after":"function rebalance(string calldata _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        // use globalLastTradeTimestamps to prevent multiple rebalances being called with different exchanges during the epoch rebalance\n        _validateNormalRebalance(leverageInfo, methodology.rebalanceInterval, globalLastTradeTimestamp);\n        _validateNonTWAP();\n\n        uint256 newLeverageRatio = _calculateNewLeverageRatio(leverageInfo.currentLeverageRatio);\n\n        (\n        uint256 chunkRebalanceNotional,\n        uint256 totalRebalanceNotional\n        ) = _handleRebalance(leverageInfo, newLeverageRatio);\n\n        _updateRebalanceState(chunkRebalanceNotional, totalRebalanceNotional, newLeverageRatio, _exchangeName);\n\n        emit Rebalanced(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function iterateRebalance(string memory _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        // Use the exchangeLastTradeTimestamp since cooldown periods are measured on a per-exchange basis, allowing it to rebalance multiple time in quick\n        // succession with different exchanges\n        _validateNormalRebalance(leverageInfo, execution.twapCooldownPeriod, exchangeSettings[_exchangeName].exchangeLastTradeTimestamp);\n        _validateTWAP();\n\n        uint256 chunkRebalanceNotional;\n        uint256 totalRebalanceNotional;\n        if (!_isAdvantageousTWAP(leverageInfo.currentLeverageRatio)) {\n            (chunkRebalanceNotional, totalRebalanceNotional) = _handleRebalance(leverageInfo, twapLeverageRatio);\n        }\n\n        // If not advantageous, then rebalance is skipped and chunk and total rebalance notional are both 0, which means TWAP state is\n        // cleared\n        _updateIterateState(chunkRebalanceNotional, totalRebalanceNotional, _exchangeName);\n\n        emit RebalanceIterated(\n            leverageInfo.currentLeverageRatio,\n            twapLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","after":"function iterateRebalance(string calldata _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        // Use the exchangeLastTradeTimestamp since cooldown periods are measured on a per-exchange basis, allowing it to rebalance multiple time in quick\n        // succession with different exchanges\n        _validateNormalRebalance(leverageInfo, execution.twapCooldownPeriod, exchangeSettings[_exchangeName].exchangeLastTradeTimestamp);\n        _validateTWAP();\n\n        uint256 chunkRebalanceNotional;\n        uint256 totalRebalanceNotional;\n        if (!_isAdvantageousTWAP(leverageInfo.currentLeverageRatio)) {\n            (chunkRebalanceNotional, totalRebalanceNotional) = _handleRebalance(leverageInfo, twapLeverageRatio);\n        }\n\n        // If not advantageous, then rebalance is skipped and chunk and total rebalance notional are both 0, which means TWAP state is\n        // cleared\n        _updateIterateState(chunkRebalanceNotional, totalRebalanceNotional, _exchangeName);\n\n        emit RebalanceIterated(\n            leverageInfo.currentLeverageRatio,\n            twapLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function ripcord(string memory _exchangeName) external onlyEOA {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            incentive.incentivizedSlippageTolerance,\n            exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize,\n            _exchangeName\n        );\n\n        // Use the exchangeLastTradeTimestamp so it can ripcord quickly with multiple exchanges\n        _validateRipcord(leverageInfo, exchangeSettings[_exchangeName].exchangeLastTradeTimestamp);\n\n        (uint256 chunkRebalanceNotional,) = _calculateChunkRebalanceNotional(leverageInfo, methodology.maxLeverageRatio, false);\n\n        _delever(leverageInfo, chunkRebalanceNotional);\n\n        _updateRipcordState(_exchangeName);\n\n        uint256 etherTransferred = _transferEtherRewardToCaller(incentive.etherReward);\n\n        emit RipcordCalled(\n            leverageInfo.currentLeverageRatio,\n            methodology.maxLeverageRatio,\n            chunkRebalanceNotional,\n            etherTransferred\n        );\n    }","after":"function ripcord(string calldata _exchangeName) external onlyEOA {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            incentive.incentivizedSlippageTolerance,\n            exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize,\n            _exchangeName\n        );\n\n        // Use the exchangeLastTradeTimestamp so it can ripcord quickly with multiple exchanges\n        _validateRipcord(leverageInfo, exchangeSettings[_exchangeName].exchangeLastTradeTimestamp);\n\n        (uint256 chunkRebalanceNotional,) = _calculateChunkRebalanceNotional(leverageInfo, methodology.maxLeverageRatio, false);\n\n        _delever(leverageInfo, chunkRebalanceNotional);\n\n        _updateRipcordState(_exchangeName);\n\n        uint256 etherTransferred = _transferEtherRewardToCaller(incentive.etherReward);\n\n        emit RipcordCalled(\n            leverageInfo.currentLeverageRatio,\n            methodology.maxLeverageRatio,\n            chunkRebalanceNotional,\n            etherTransferred\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function disengage(string memory _exchangeName) external onlyOperator {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        uint256 newLeverageRatio = PreciseUnitMath.preciseUnit();\n\n        (\n        uint256 chunkRebalanceNotional,\n        uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, newLeverageRatio, false);\n\n        if (totalRebalanceNotional > chunkRebalanceNotional) {\n            _delever(leverageInfo, chunkRebalanceNotional);\n        } else {\n            _deleverToZeroBorrowBalance(leverageInfo, totalRebalanceNotional);\n        }\n\n        emit Disengaged(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","after":"function disengage(string calldata _exchangeName) external onlyOperator {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        uint256 newLeverageRatio = PreciseUnitMath.preciseUnit();\n\n        (\n        uint256 chunkRebalanceNotional,\n        uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, newLeverageRatio, false);\n\n        if (totalRebalanceNotional > chunkRebalanceNotional) {\n            _delever(leverageInfo, chunkRebalanceNotional);\n        } else {\n            _deleverToZeroBorrowBalance(leverageInfo, totalRebalanceNotional);\n        }\n\n        emit Disengaged(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function setMethodologySettings(MethodologySettings memory _newMethodologySettings) external onlyOperator noRebalanceInProgress {\n        methodology = _newMethodologySettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit MethodologySettingsUpdated(\n            methodology.targetLeverageRatio,\n            methodology.minLeverageRatio,\n            methodology.maxLeverageRatio,\n            methodology.recenteringSpeed,\n            methodology.rebalanceInterval\n        );\n    }","after":"function setMethodologySettings(MethodologySettings calldata _newMethodologySettings) external onlyOperator noRebalanceInProgress {\n        methodology = _newMethodologySettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit MethodologySettingsUpdated(\n            methodology.targetLeverageRatio,\n            methodology.minLeverageRatio,\n            methodology.maxLeverageRatio,\n            methodology.recenteringSpeed,\n            methodology.rebalanceInterval\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function setExecutionSettings(ExecutionSettings memory _newExecutionSettings) external onlyOperator noRebalanceInProgress {\n        execution = _newExecutionSettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit ExecutionSettingsUpdated(\n            execution.unutilizedLeveragePercentage,\n            execution.twapCooldownPeriod,\n            execution.slippageTolerance\n        );\n    }","after":"function setExecutionSettings(ExecutionSettings calldata _newExecutionSettings) external onlyOperator noRebalanceInProgress {\n        execution = _newExecutionSettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit ExecutionSettingsUpdated(\n            execution.unutilizedLeveragePercentage,\n            execution.twapCooldownPeriod,\n            execution.slippageTolerance\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function setIncentiveSettings(IncentiveSettings memory _newIncentiveSettings) external onlyOperator noRebalanceInProgress {\n        incentive = _newIncentiveSettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit IncentiveSettingsUpdated(\n            incentive.etherReward,\n            incentive.incentivizedLeverageRatio,\n            incentive.incentivizedSlippageTolerance,\n            incentive.incentivizedTwapCooldownPeriod\n        );\n    }","after":"function setIncentiveSettings(IncentiveSettings calldata _newIncentiveSettings) external onlyOperator noRebalanceInProgress {\n        incentive = _newIncentiveSettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit IncentiveSettingsUpdated(\n            incentive.etherReward,\n            incentive.incentivizedLeverageRatio,\n            incentive.incentivizedSlippageTolerance,\n            incentive.incentivizedTwapCooldownPeriod\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function addEnabledExchange(\n        string memory _exchangeName,\n        ExchangeSettings memory _exchangeSettings\n    )\n    external\n    onlyOperator\n    {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize == 0, \"Exchange already enabled\");\n        _validateExchangeSettings(_exchangeSettings);\n\n        exchangeSettings[_exchangeName].twapMaxTradeSize = _exchangeSettings.twapMaxTradeSize;\n        exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize = _exchangeSettings.incentivizedTwapMaxTradeSize;\n        exchangeSettings[_exchangeName].leverExchangeData = _exchangeSettings.leverExchangeData;\n        exchangeSettings[_exchangeName].deleverExchangeData = _exchangeSettings.deleverExchangeData;\n        exchangeSettings[_exchangeName].exchangeLastTradeTimestamp = 0;\n\n        enabledExchanges.push(_exchangeName);\n\n        emit ExchangeAdded(\n            _exchangeName,\n            _exchangeSettings.twapMaxTradeSize,\n            _exchangeSettings.exchangeLastTradeTimestamp,\n            _exchangeSettings.incentivizedTwapMaxTradeSize,\n            _exchangeSettings.leverExchangeData,\n            _exchangeSettings.deleverExchangeData\n        );\n    }","after":"function addEnabledExchange(\n        string calldata _exchangeName,\n        ExchangeSettings calldata _exchangeSettings\n    )\n    external\n    onlyOperator\n    {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize == 0, \"Exchange already enabled\");\n        _validateExchangeSettings(_exchangeSettings);\n\n        exchangeSettings[_exchangeName].twapMaxTradeSize = _exchangeSettings.twapMaxTradeSize;\n        exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize = _exchangeSettings.incentivizedTwapMaxTradeSize;\n        exchangeSettings[_exchangeName].leverExchangeData = _exchangeSettings.leverExchangeData;\n        exchangeSettings[_exchangeName].deleverExchangeData = _exchangeSettings.deleverExchangeData;\n        exchangeSettings[_exchangeName].exchangeLastTradeTimestamp = 0;\n\n        enabledExchanges.push(_exchangeName);\n\n        emit ExchangeAdded(\n            _exchangeName,\n            _exchangeSettings.twapMaxTradeSize,\n            _exchangeSettings.exchangeLastTradeTimestamp,\n            _exchangeSettings.incentivizedTwapMaxTradeSize,\n            _exchangeSettings.leverExchangeData,\n            _exchangeSettings.deleverExchangeData\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function removeEnabledExchange(string memory _exchangeName) external onlyOperator {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize != 0, \"Exchange not enabled\");\n\n        delete exchangeSettings[_exchangeName];\n        enabledExchanges.removeStorage(_exchangeName);\n\n        emit ExchangeRemoved(_exchangeName);\n    }","after":"function removeEnabledExchange(string calldata _exchangeName) external onlyOperator {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize != 0, \"Exchange not enabled\");\n\n        delete exchangeSettings[_exchangeName];\n        enabledExchanges.removeStorage(_exchangeName);\n\n        emit ExchangeRemoved(_exchangeName);\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function updateEnabledExchange(\n        string memory _exchangeName,\n        ExchangeSettings memory _exchangeSettings\n    )\n    external\n    onlyOperator\n    {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize != 0, \"Exchange not enabled\");\n        _validateExchangeSettings(_exchangeSettings);\n\n        exchangeSettings[_exchangeName].twapMaxTradeSize = _exchangeSettings.twapMaxTradeSize;\n        exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize = _exchangeSettings.incentivizedTwapMaxTradeSize;\n        exchangeSettings[_exchangeName].leverExchangeData = _exchangeSettings.leverExchangeData;\n        exchangeSettings[_exchangeName].deleverExchangeData = _exchangeSettings.deleverExchangeData;\n\n        emit ExchangeUpdated(\n            _exchangeName,\n            _exchangeSettings.twapMaxTradeSize,\n            _exchangeSettings.exchangeLastTradeTimestamp,\n            _exchangeSettings.incentivizedTwapMaxTradeSize,\n            _exchangeSettings.leverExchangeData,\n            _exchangeSettings.deleverExchangeData\n        );\n    }","after":"function updateEnabledExchange(\n        string calldata _exchangeName,\n        ExchangeSettings calldata _exchangeSettings\n    )\n    external\n    onlyOperator\n    {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize != 0, \"Exchange not enabled\");\n        _validateExchangeSettings(_exchangeSettings);\n\n        exchangeSettings[_exchangeName].twapMaxTradeSize = _exchangeSettings.twapMaxTradeSize;\n        exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize = _exchangeSettings.incentivizedTwapMaxTradeSize;\n        exchangeSettings[_exchangeName].leverExchangeData = _exchangeSettings.leverExchangeData;\n        exchangeSettings[_exchangeName].deleverExchangeData = _exchangeSettings.deleverExchangeData;\n\n        emit ExchangeUpdated(\n            _exchangeName,\n            _exchangeSettings.twapMaxTradeSize,\n            _exchangeSettings.exchangeLastTradeTimestamp,\n            _exchangeSettings.incentivizedTwapMaxTradeSize,\n            _exchangeSettings.leverExchangeData,\n            _exchangeSettings.deleverExchangeData\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function getExchangeSettings(string memory _exchangeName) external view returns (ExchangeSettings memory) {\n        return exchangeSettings[_exchangeName];\n    }","after":"function getExchangeSettings(string calldata _exchangeName) external view returns (ExchangeSettings memory) {\n        return exchangeSettings[_exchangeName];\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function setTradeMaximums(\n        address[] memory _components,\n        uint256[] memory _tradeMaximums\n    )\n    external\n    onlyOperator\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGeneralIndexModule.setTradeMaximums.selector,\n            setToken,\n            _components,\n            _tradeMaximums\n        );\n\n        invokeManager(address(generalIndexModule), callData);\n    }","after":"function setTradeMaximums(\n        address[] calldata _components,\n        uint256[] calldata _tradeMaximums\n    )\n    external\n    onlyOperator\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGeneralIndexModule.setTradeMaximums.selector,\n            setToken,\n            _components,\n            _tradeMaximums\n        );\n\n        invokeManager(address(generalIndexModule), callData);\n    }","contract":"GIMExtension","time":0},{"type":"external-function ","before":"function setExchanges(\n        address[] memory _components,\n        string[] memory _exchangeNames\n    )\n    external\n    onlyOperator\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGeneralIndexModule.setExchanges.selector,\n            setToken,\n            _components,\n            _exchangeNames\n        );\n\n        invokeManager(address(generalIndexModule), callData);\n    }","after":"function setExchanges(\n        address[] calldata _components,\n        string[] calldata _exchangeNames\n    )\n    external\n    onlyOperator\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGeneralIndexModule.setExchanges.selector,\n            setToken,\n            _components,\n            _exchangeNames\n        );\n\n        invokeManager(address(generalIndexModule), callData);\n    }","contract":"GIMExtension","time":0},{"type":"external-function ","before":"function setCoolOffPeriods(\n        address[] memory _components,\n        uint256[] memory _coolOffPeriods\n    )\n    external\n    onlyOperator\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGeneralIndexModule.setCoolOffPeriods.selector,\n            setToken,\n            _components,\n            _coolOffPeriods\n        );\n\n        invokeManager(address(generalIndexModule), callData);\n    }","after":"function setCoolOffPeriods(\n        address[] calldata _components,\n        uint256[] calldata _coolOffPeriods\n    )\n    external\n    onlyOperator\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGeneralIndexModule.setCoolOffPeriods.selector,\n            setToken,\n            _components,\n            _coolOffPeriods\n        );\n\n        invokeManager(address(generalIndexModule), callData);\n    }","contract":"GIMExtension","time":0},{"type":"external-function ","before":"function setExchangeData(\n        address[] memory _components,\n        bytes[] memory _exchangeData\n    )\n    external\n    onlyOperator\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGeneralIndexModule.setExchangeData.selector,\n            setToken,\n            _components,\n            _exchangeData\n        );\n\n        invokeManager(address(generalIndexModule), callData);\n    }","after":"function setExchangeData(\n        address[] calldata _components,\n        bytes[] calldata _exchangeData\n    )\n    external\n    onlyOperator\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGeneralIndexModule.setExchangeData.selector,\n            setToken,\n            _components,\n            _exchangeData\n        );\n\n        invokeManager(address(generalIndexModule), callData);\n    }","contract":"GIMExtension","time":0},{"type":"external-function ","before":"function setTraderStatus(\n        address[] memory _traders,\n        bool[] memory _statuses\n    )\n    external\n    onlyOperator\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGeneralIndexModule.setTraderStatus.selector,\n            setToken,\n            _traders,\n            _statuses\n        );\n\n        invokeManager(address(generalIndexModule), callData);\n    }","after":"function setTraderStatus(\n        address[] calldata _traders,\n        bool[] calldata _statuses\n    )\n    external\n    onlyOperator\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGeneralIndexModule.setTraderStatus.selector,\n            setToken,\n            _traders,\n            _statuses\n        );\n\n        invokeManager(address(generalIndexModule), callData);\n    }","contract":"GIMExtension","time":0},{"type":"external-function ","before":"function delegate(\n        string memory _governanceName,\n        address _delegatee\n    )\n    external\n    onlyAllowedCaller(msg.sender)\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGovernanceModule.delegate.selector,\n            setToken,\n            _governanceName,\n            _delegatee\n        );\n\n        invokeManager(address(governanceModule), callData);\n    }","after":"function delegate(\n        string calldata _governanceName,\n        address _delegatee\n    )\n    external\n    onlyAllowedCaller(msg.sender)\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGovernanceModule.delegate.selector,\n            setToken,\n            _governanceName,\n            _delegatee\n        );\n\n        invokeManager(address(governanceModule), callData);\n    }","contract":"GovernanceExtension","time":0},{"type":"external-function ","before":"function propose(\n        string memory _governanceName,\n        bytes memory _proposalData\n    )\n    external\n    onlyAllowedCaller(msg.sender)\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGovernanceModule.propose.selector,\n            setToken,\n            _governanceName,\n            _proposalData\n        );\n\n        invokeManager(address(governanceModule), callData);\n    }","after":"function propose(\n        string calldata _governanceName,\n        bytes calldata _proposalData\n    )\n    external\n    onlyAllowedCaller(msg.sender)\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGovernanceModule.propose.selector,\n            setToken,\n            _governanceName,\n            _proposalData\n        );\n\n        invokeManager(address(governanceModule), callData);\n    }","contract":"GovernanceExtension","time":0},{"type":"external-function ","before":"function register(string memory _governanceName) external onlyAllowedCaller(msg.sender) {\n        bytes memory callData = abi.encodeWithSelector(\n            IGovernanceModule.register.selector,\n            setToken,\n            _governanceName\n        );\n\n        invokeManager(address(governanceModule), callData);\n    }","after":"function register(string calldata _governanceName) external onlyAllowedCaller(msg.sender) {\n        bytes memory callData = abi.encodeWithSelector(\n            IGovernanceModule.register.selector,\n            setToken,\n            _governanceName\n        );\n\n        invokeManager(address(governanceModule), callData);\n    }","contract":"GovernanceExtension","time":0},{"type":"external-function ","before":"function revoke(string memory _governanceName) external onlyAllowedCaller(msg.sender) {\n        bytes memory callData = abi.encodeWithSelector(\n            IGovernanceModule.revoke.selector,\n            setToken,\n            _governanceName\n        );\n\n        invokeManager(address(governanceModule), callData);\n    }","after":"function revoke(string calldata _governanceName) external onlyAllowedCaller(msg.sender) {\n        bytes memory callData = abi.encodeWithSelector(\n            IGovernanceModule.revoke.selector,\n            setToken,\n            _governanceName\n        );\n\n        invokeManager(address(governanceModule), callData);\n    }","contract":"GovernanceExtension","time":0},{"type":"external-function ","before":"function vote(\n        string memory _governanceName,\n        uint256 _proposalId,\n        bool _support,\n        bytes memory _data\n    )\n    external\n    onlyAllowedCaller(msg.sender)\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGovernanceModule.vote.selector,\n            setToken,\n            _governanceName,\n            _proposalId,\n            _support,\n            _data\n        );\n\n        invokeManager(address(governanceModule), callData);\n    }","after":"function vote(\n        string calldata _governanceName,\n        uint256 _proposalId,\n        bool _support,\n        bytes calldata _data\n    )\n    external\n    onlyAllowedCaller(msg.sender)\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IGovernanceModule.vote.selector,\n            setToken,\n            _governanceName,\n            _proposalId,\n            _support,\n            _data\n        );\n\n        invokeManager(address(governanceModule), callData);\n    }","contract":"GovernanceExtension","time":0},{"type":"struct-data-arrangement ","before":"\naddress component\naddress module\nint256 unit\nuint8 positionState\nbytes data","after":"int256 unit\nbytes data\naddress component\naddress module\nuint8 positionState\n","contract":"ISetToken","time":0},{"type":"immutable-restrict-modification ","before":"address public owner;","after":"address public immutable owner;","contract":"MutualUpgradeMock","time":0},{"type":"immutable-restrict-modification ","before":"address public methodologist;","after":"address public immutable methodologist;","contract":"MutualUpgradeMock","time":0},{"type":"state-data-arrangement ","before":"\naddress public usdc;\naddress public index;\naddress public indexGov;\naddress public beneficiary;\nuint256 public vestingStart;\nuint256 public vestingEnd;\nuint256 public vestingCliff;\nuint256 public usdcAmount;\nuint256 public indexAmount;\nbool hasRun;","after":"uint256 public vestingStart;\nuint256 public vestingEnd;\nuint256 public vestingCliff;\nuint256 public usdcAmount;\nuint256 public indexAmount;\naddress public usdc;\naddress public index;\naddress public indexGov;\naddress public beneficiary;\nbool hasRun;\n","contract":"OtcEscrow","time":0},{"type":"immutable-restrict-modification ","before":"address public usdc;","after":"address public immutable usdc;","contract":"OtcEscrow","time":1},{"type":"immutable-restrict-modification ","before":"address public index;","after":"address public immutable index;","contract":"OtcEscrow","time":1},{"type":"immutable-restrict-modification ","before":"address public indexGov;","after":"address public immutable indexGov;","contract":"OtcEscrow","time":1},{"type":"immutable-restrict-modification ","before":"address public beneficiary;","after":"address public immutable beneficiary;","contract":"OtcEscrow","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public vestingStart;","after":"uint256 public immutable vestingStart;","contract":"OtcEscrow","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public vestingEnd;","after":"uint256 public immutable vestingEnd;","contract":"OtcEscrow","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public vestingCliff;","after":"uint256 public immutable vestingCliff;","contract":"OtcEscrow","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public usdcAmount;","after":"uint256 public immutable usdcAmount;","contract":"OtcEscrow","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public indexAmount;","after":"uint256 public immutable indexAmount;","contract":"OtcEscrow","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public rewardsDuration = 60 days;","after":"uint256 public constant rewardsDuration = 60 days;","contract":"StakingRewards","time":1},{"type":"immutable-restrict-modification ","before":"address public rewardsDistribution;","after":"address public immutable rewardsDistribution;","contract":"StakingRewards","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public rewardsDuration;","after":"uint256 public immutable rewardsDuration;","contract":"StakingRewardsV2","time":1},{"type":"immutable-restrict-modification ","before":"address public rewardsDistribution;","after":"address public immutable rewardsDistribution;","contract":"StakingRewardsV2","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"StandardTokenMock","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"StandardTokenMock","time":1},{"type":"external-function ","before":"function initializeModule(IStreamingFeeModule.FeeState memory _settings)\n    external\n    mutualUpgrade(manager.operator(), manager.methodologist())\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IStreamingFeeModule.initialize.selector,\n            manager.setToken(),\n            _settings\n        );\n\n        invokeManager(address(streamingFeeModule), callData);\n    }","after":"function initializeModule(IStreamingFeeModule.FeeState calldata _settings)\n    external\n    mutualUpgrade(manager.operator(), manager.methodologist())\n    {\n        bytes memory callData = abi.encodeWithSelector(\n            IStreamingFeeModule.initialize.selector,\n            manager.setToken(),\n            _settings\n        );\n\n        invokeManager(address(streamingFeeModule), callData);\n    }","contract":"StreamingFeeSplitExtension","time":0},{"type":"external-function ","before":"function testIndexOf(string[] memory A, string memory a) external pure returns (uint256, bool) {\n        return A.indexOf(a);\n    }","after":"function testIndexOf(string[] calldata A, string calldata a) external pure returns (uint256, bool) {\n        return A.indexOf(a);\n    }","contract":"StringArrayUtilsMock","time":0},{"type":"external-function ","before":"function testRemoveStorage(string memory a) external {\n        storageArray.removeStorage(a);\n    }","after":"function testRemoveStorage(string calldata a) external {\n        storageArray.removeStorage(a);\n    }","contract":"StringArrayUtilsMock","time":0},{"type":"external-function ","before":"function setStorageArray(string[] memory A) external {\n        storageArray = A;\n    }","after":"function setStorageArray(string[] calldata A) external {\n        storageArray = A;\n    }","contract":"StringArrayUtilsMock","time":0},{"type":"external-function ","before":"function getTradeCalldata(\n        address _sourceToken,\n        address _destinationToken,\n        address _destinationAddress,\n        uint256 _sourceQuantity,\n        uint256 _minDestinationQuantity,\n        bytes memory /* _data */\n    )\n    external\n    view\n    returns (address, uint256, bytes memory)\n    {\n        // Encode method data for SetToken to invoke\n        bytes memory methodData = abi.encodeWithSignature(\n            \"trade(address,address,address,uint256,uint256)\",\n            _sourceToken,\n            _destinationToken,\n            _destinationAddress,\n            _sourceQuantity,\n            _minDestinationQuantity\n        );\n\n        return (address(this), 0, methodData);\n    }","after":"function getTradeCalldata(\n        address _sourceToken,\n        address _destinationToken,\n        address _destinationAddress,\n        uint256 _sourceQuantity,\n        uint256 _minDestinationQuantity,\n        bytes calldata /* _data */\n    )\n    external\n    view\n    returns (address, uint256, bytes memory)\n    {\n        // Encode method data for SetToken to invoke\n        bytes memory methodData = abi.encodeWithSignature(\n            \"trade(address,address,address,uint256,uint256)\",\n            _sourceToken,\n            _destinationToken,\n            _destinationAddress,\n            _sourceQuantity,\n            _minDestinationQuantity\n        );\n\n        return (address(this), 0, methodData);\n    }","contract":"TradeAdapterMock","time":0},{"type":"immutable-restrict-modification ","before":"address public index;","after":"address public immutable index;","contract":"Vesting","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public vestingAmount;","after":"uint256 public immutable vestingAmount;","contract":"Vesting","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public vestingBegin;","after":"uint256 public immutable vestingBegin;","contract":"Vesting","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public vestingCliff;","after":"uint256 public immutable vestingCliff;","contract":"Vesting","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public vestingEnd;","after":"uint256 public immutable vestingEnd;","contract":"Vesting","time":0}]}