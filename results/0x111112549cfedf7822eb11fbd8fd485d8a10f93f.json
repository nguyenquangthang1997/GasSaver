{"time":134,"results":[{"type":"external-function ","before":"function aggregate(\n\n        IERC20 fromToken,\n\n        IERC20 toToken,\n\n        uint tokensAmount,\n\n        address[] memory callAddresses,\n\n        bytes memory callDataConcat,\n\n        uint[] memory starts,\n\n        uint[] memory values,\n\n        uint mintGasPrice,\n\n        uint minTokensAmount,\n\n        uint guaranteedAmount,\n\n        address payable referrer\n\n    )\n\n    public\n\n    payable\n\n    returns (uint returnAmount)\n\n    {\n\n        returnAmount = gasleft();\n\n        uint gasTokenBalance = gasToken.balanceOf(address(this));\n\n\n        require(callAddresses.length + 1 == starts.length);\n\n\n        if (address(fromToken) != ETH_ADDRESS) {\n\n\n            spender.claimTokens(fromToken, tx.origin, address(this), tokensAmount);\n\n        }\n\n\n        for (uint i = 0; i < starts.length - 1; i++) {\n\n\n            if (starts[i + 1] - starts[i] > 0) {\n\n\n                require(\n\n                    callDataConcat[starts[i] + 0] != spender.claimTokens.selector[0] ||\n\n                    callDataConcat[starts[i] + 1] != spender.claimTokens.selector[1] ||\n\n                    callDataConcat[starts[i] + 2] != spender.claimTokens.selector[2] ||\n\n                    callDataConcat[starts[i] + 3] != spender.claimTokens.selector[3]\n\n                );\n\n                require(callAddresses[i].externalCall(values[i], callDataConcat, starts[i], starts[i + 1] - starts[i]));\n\n            }\n\n        }\n\n\n        //\n\n\n\n        require(gasTokenBalance == gasToken.balanceOf(address(this)));\n\n        if (mintGasPrice > 0) {\n\n            audoRefundGas(returnAmount, mintGasPrice);\n\n        }\n\n\n        //\n\n\n\n        returnAmount = _balanceOf(toToken, address(this));\n\n        require(returnAmount >= minTokensAmount, \"Return amount is not enough\");\n\n\n        if (returnAmount > guaranteedAmount) {\n\n\n            uint feeAmount = returnAmount.sub(guaranteedAmount).mul(fee).div(10000);\n\n\n            if (feeAmount.mul(10000).div(returnAmount) > 100) {// 1%\n\n\n\n                feeAmount = returnAmount.div(100);\n                // 1%\n\n            }\n\n\n            if (referrer != address(0) && referrer != tx.origin && referrer != tx.origin) {\n\n                if (_transfer(toToken, referrer, feeAmount.div(10), true)) {\n\n                    returnAmount = returnAmount.sub(feeAmount.div(10));\n\n                    emit OneInchFeePaid(toToken, referrer, feeAmount.div(10));\n\n                    feeAmount = feeAmount.mul(9).div(10);\n\n                } else {\n\n                    emit OneInchFeePaid(toToken, address(0), feeAmount);\n\n                }\n\n            } else {\n\n                emit OneInchFeePaid(toToken, address(0), feeAmount);\n\n            }\n\n\n            if (_transfer(toToken, owner, feeAmount, true)) {\n\n                returnAmount = returnAmount.sub(feeAmount);\n\n            }\n\n        }\n\n\n        _transfer(toToken, tx.origin, returnAmount, false);\n\n    }","after":"function aggregate(\n\n        IERC20 fromToken,\n\n        IERC20 toToken,\n\n        uint tokensAmount,\n\n        address[] calldata callAddresses,\n\n        bytes calldata callDataConcat,\n\n        uint[] calldata starts,\n\n        uint[] calldata values,\n\n        uint mintGasPrice,\n\n        uint minTokensAmount,\n\n        uint guaranteedAmount,\n\n        address payable referrer\n\n    )\n\n    public\n\n    payable\n\n    returns (uint returnAmount)\n\n    {\n\n        returnAmount = gasleft();\n\n        uint gasTokenBalance = gasToken.balanceOf(address(this));\n\n\n        require(callAddresses.length + 1 == starts.length);\n\n\n        if (address(fromToken) != ETH_ADDRESS) {\n\n\n            spender.claimTokens(fromToken, tx.origin, address(this), tokensAmount);\n\n        }\n\n\n        for (uint i = 0; i < starts.length - 1; i++) {\n\n\n            if (starts[i + 1] - starts[i] > 0) {\n\n\n                require(\n\n                    callDataConcat[starts[i] + 0] != spender.claimTokens.selector[0] ||\n\n                    callDataConcat[starts[i] + 1] != spender.claimTokens.selector[1] ||\n\n                    callDataConcat[starts[i] + 2] != spender.claimTokens.selector[2] ||\n\n                    callDataConcat[starts[i] + 3] != spender.claimTokens.selector[3]\n\n                );\n\n                require(callAddresses[i].externalCall(values[i], callDataConcat, starts[i], starts[i + 1] - starts[i]));\n\n            }\n\n        }\n\n\n        //\n\n\n\n        require(gasTokenBalance == gasToken.balanceOf(address(this)));\n\n        if (mintGasPrice > 0) {\n\n            audoRefundGas(returnAmount, mintGasPrice);\n\n        }\n\n\n        //\n\n\n\n        returnAmount = _balanceOf(toToken, address(this));\n\n        require(returnAmount >= minTokensAmount, \"Return amount is not enough\");\n\n\n        if (returnAmount > guaranteedAmount) {\n\n\n            uint feeAmount = returnAmount.sub(guaranteedAmount).mul(fee).div(10000);\n\n\n            if (feeAmount.mul(10000).div(returnAmount) > 100) {// 1%\n\n\n\n                feeAmount = returnAmount.div(100);\n                // 1%\n\n            }\n\n\n            if (referrer != address(0) && referrer != tx.origin && referrer != tx.origin) {\n\n                if (_transfer(toToken, referrer, feeAmount.div(10), true)) {\n\n                    returnAmount = returnAmount.sub(feeAmount.div(10));\n\n                    emit OneInchFeePaid(toToken, referrer, feeAmount.div(10));\n\n                    feeAmount = feeAmount.mul(9).div(10);\n\n                } else {\n\n                    emit OneInchFeePaid(toToken, address(0), feeAmount);\n\n                }\n\n            } else {\n\n                emit OneInchFeePaid(toToken, address(0), feeAmount);\n\n            }\n\n\n            if (_transfer(toToken, owner, feeAmount, true)) {\n\n                returnAmount = returnAmount.sub(feeAmount);\n\n            }\n\n        }\n\n\n        _transfer(toToken, tx.origin, returnAmount, false);\n\n    }","contract":"AggregatedTokenSwap","time":0},{"type":"external-function ","before":"function getOrdersInfoRespectingBalancesAndAllowances(\n\n        IERC20 token,\n\n        IZrxExchange zrx,\n\n        address zrxTokenProxy,\n\n        IZrxExchange.Order[] memory orders\n\n    )\n\n    public\n\n    view\n\n    returns (IZrxExchange.OrderInfo[] memory ordersInfo)\n\n    {\n\n        ordersInfo = zrx.getOrdersInfo(orders);\n\n\n        for (uint i = 0; i < ordersInfo.length; i++) {\n\n\n            uint256 balance = token.balanceOf(orders[i].makerAddress);\n\n            uint256 allowance = token.allowance(orders[i].makerAddress, zrxTokenProxy);\n\n            uint256 availableMakerAmount = (allowance < balance) ? allowance : balance;\n\n            uint256 availableTakerAmount = availableMakerAmount.mul(orders[i].takerAssetAmount).div(orders[i].makerAssetAmount);\n\n\n            for (uint j = 0; j < i; j++) {\n\n\n                if (orders[j].makerAddress == orders[i].makerAddress) {\n\n\n                    uint256 orderTakerAssetRemainigAmount = orders[j].takerAssetAmount.sub(\n\n                        ordersInfo[j].orderTakerAssetFilledAmount\n\n                    );\n\n\n                    if (availableTakerAmount > orderTakerAssetRemainigAmount) {\n\n                        availableTakerAmount = availableTakerAmount.sub(orderTakerAssetRemainigAmount);\n\n                    } else {\n\n                        availableTakerAmount = 0;\n\n                        break;\n\n                    }\n\n                }\n\n            }\n\n\n            uint256 remainingTakerAmount = orders[i].takerAssetAmount.sub(\n\n                ordersInfo[i].orderTakerAssetFilledAmount\n\n            );\n\n\n            if (availableTakerAmount < remainingTakerAmount) {\n\n\n                ordersInfo[i].orderTakerAssetFilledAmount = orders[i].takerAssetAmount.sub(availableTakerAmount);\n\n            }\n\n        }\n\n    }","after":"function getOrdersInfoRespectingBalancesAndAllowances(\n\n        IERC20 token,\n\n        IZrxExchange zrx,\n\n        address zrxTokenProxy,\n\n        IZrxExchange.Order[] calldata orders\n\n    )\n\n    public\n\n    view\n\n    returns (IZrxExchange.OrderInfo[] memory ordersInfo)\n\n    {\n\n        ordersInfo = zrx.getOrdersInfo(orders);\n\n\n        for (uint i = 0; i < ordersInfo.length; i++) {\n\n\n            uint256 balance = token.balanceOf(orders[i].makerAddress);\n\n            uint256 allowance = token.allowance(orders[i].makerAddress, zrxTokenProxy);\n\n            uint256 availableMakerAmount = (allowance < balance) ? allowance : balance;\n\n            uint256 availableTakerAmount = availableMakerAmount.mul(orders[i].takerAssetAmount).div(orders[i].makerAssetAmount);\n\n\n            for (uint j = 0; j < i; j++) {\n\n\n                if (orders[j].makerAddress == orders[i].makerAddress) {\n\n\n                    uint256 orderTakerAssetRemainigAmount = orders[j].takerAssetAmount.sub(\n\n                        ordersInfo[j].orderTakerAssetFilledAmount\n\n                    );\n\n\n                    if (availableTakerAmount > orderTakerAssetRemainigAmount) {\n\n                        availableTakerAmount = availableTakerAmount.sub(orderTakerAssetRemainigAmount);\n\n                    } else {\n\n                        availableTakerAmount = 0;\n\n                        break;\n\n                    }\n\n                }\n\n            }\n\n\n            uint256 remainingTakerAmount = orders[i].takerAssetAmount.sub(\n\n                ordersInfo[i].orderTakerAssetFilledAmount\n\n            );\n\n\n            if (availableTakerAmount < remainingTakerAmount) {\n\n\n                ordersInfo[i].orderTakerAssetFilledAmount = orders[i].takerAssetAmount.sub(availableTakerAmount);\n\n            }\n\n        }\n\n    }","contract":"AggregatedTokenSwap","time":0},{"type":"external-function ","before":"function compressedCall(\n\n        address target,\n\n        uint256 totalLength,\n\n        bytes memory zipped\n\n    )\n\n    public\n\n    payable\n\n    returns (bytes memory result)\n\n    {\n\n        (bytes memory data, uint decompressedLength) = decompress(totalLength, zipped);\n\n        require(decompressedLength == totalLength, \"Uncompress error\");\n\n\n        bool success;\n\n        (success, result) = target.call.value(msg.value)(data);\n\n        require(success, \"Decompressed call failed\");\n\n    }","after":"function compressedCall(\n\n        address target,\n\n        uint256 totalLength,\n\n        bytes calldata zipped\n\n    )\n\n    public\n\n    payable\n\n    returns (bytes memory result)\n\n    {\n\n        (bytes memory data, uint decompressedLength) = decompress(totalLength, zipped);\n\n        require(decompressedLength == totalLength, \"Uncompress error\");\n\n\n        bool success;\n\n        (success, result) = target.call.value(msg.value)(data);\n\n        require(success, \"Decompressed call failed\");\n\n    }","contract":"AggregatedTokenSwap","time":0},{"type":"immutable-restrict-modification ","before":"address payable owner;","after":"address payable immutable owner;","contract":"AggregatedTokenSwap","time":0},{"type":"immutable-restrict-modification ","before":"uint fee;","after":"uint immutable fee;","contract":"AggregatedTokenSwap","time":0}]}