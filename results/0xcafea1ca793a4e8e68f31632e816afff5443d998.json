{"time":1914,"results":[{"type":"constant-restrict-modification  ","before":"address public tokenAddress;","after":"address public constant tokenAddress;","contract":"INXMMaster","time":0},{"type":"constant-restrict-modification  ","before":"address public owner;","after":"address public constant owner;","contract":"INXMMaster","time":0},{"type":"constant-restrict-modification  ","before":"uint public pauseTime;","after":"uint public constant pauseTime;","contract":"INXMMaster","time":0},{"type":"struct-data-arrangement ","before":"\naddress voter\nuint tokens\nuint claimId\nint8 verdict\nbool rewardClaimed","after":"uint tokens\nuint claimId\naddress voter\nint8 verdict\nbool rewardClaimed\n","contract":"ClaimsData","time":0},{"type":"constant-restrict-modification  ","before":"string public name = \"NXM\";","after":"string public constant name = \"NXM\";","contract":"NXMToken","time":0},{"type":"constant-restrict-modification  ","before":"string public symbol = \"NXM\";","after":"string public constant symbol = \"NXM\";","contract":"NXMToken","time":0},{"type":"constant-restrict-modification  ","before":"uint8 public decimals = 18;","after":"uint8 public constant decimals = 18;","contract":"NXMToken","time":0},{"type":"state-data-arrangement ","before":"\nIARankDetails[] internal allIARankDetails;\nMcrData[] public allMCRData;\nbytes4[] internal allInvestmentCurrencies;\nbytes4[] internal allCurrencies;\nbytes32[] public allAPIcall;\nmapping(bytes32 => ApiId) public allAPIid;\nmapping(uint64 => uint) internal datewiseId;\nmapping(bytes16 => uint) internal currencyLastIndex;\nmapping(bytes4 => CurrencyAssets) internal allCurrencyAssets;\nmapping(bytes4 => InvestmentAssets) internal allInvestmentAssets;\nmapping(bytes4 => uint) internal caAvgRate;\nmapping(bytes4 => uint) internal iaAvgRate;\naddress public notariseMCR;\naddress public daiFeedAddress;\nuint private constant DECIMAL1E18 = uint(10) ** 18;\nuint public uniswapDeadline;\nuint public liquidityTradeCallbackTime;\nuint public lastLiquidityTradeTrigger;\nuint64 internal lastDate;\nuint public variationPercX100;\nuint public iaRatesTime;\nuint public minCap;\nuint public mcrTime;\nuint public a;\nuint public shockParameter;\nuint public c;\nuint public mcrFailTime;\nuint public ethVolumeLimit;\nuint public capReached;\nuint public capacityLimit;","after":"IARankDetails[] internal allIARankDetails;\nMcrData[] public allMCRData;\nbytes4[] internal allInvestmentCurrencies;\nbytes4[] internal allCurrencies;\nbytes32[] public allAPIcall;\nmapping(bytes32 => ApiId) public allAPIid;\nmapping(uint64 => uint) internal datewiseId;\nmapping(bytes16 => uint) internal currencyLastIndex;\nmapping(bytes4 => CurrencyAssets) internal allCurrencyAssets;\nmapping(bytes4 => InvestmentAssets) internal allInvestmentAssets;\nmapping(bytes4 => uint) internal caAvgRate;\nmapping(bytes4 => uint) internal iaAvgRate;\nuint private constant DECIMAL1E18 = uint(10) ** 18;\nuint public uniswapDeadline;\nuint public liquidityTradeCallbackTime;\nuint public lastLiquidityTradeTrigger;\nuint public variationPercX100;\nuint public iaRatesTime;\nuint public minCap;\nuint public mcrTime;\nuint public a;\nuint public shockParameter;\nuint public c;\nuint public mcrFailTime;\nuint public ethVolumeLimit;\nuint public capReached;\nuint public capacityLimit;\naddress public notariseMCR;\naddress public daiFeedAddress;\nuint64 internal lastDate;\n","contract":"PoolData","time":0},{"type":"struct-data-arrangement ","before":"\nbytes4 typeOf\nbytes4 currency\nuint id\nuint64 dateAdd\nuint64 dateUpd","after":"uint id\nuint64 dateAdd\nuint64 dateUpd\nbytes4 typeOf\nbytes4 currency\n","contract":"PoolData","time":0},{"type":"struct-data-arrangement ","before":"\naddress payable memberAddress\nbytes4 currencyCode\nuint sumAssured\nuint16 coverPeriod\nuint validUntil\naddress scAddress\nuint premiumNXM","after":"uint sumAssured\nuint validUntil\nuint premiumNXM\naddress payable memberAddress\naddress scAddress\nbytes4 currencyCode\nuint16 coverPeriod\n","contract":"QuotationData","time":0},{"type":"struct-data-arrangement ","before":"\nuint holdCoverId\naddress payable userAddress\naddress scAddress\nbytes4 coverCurr\nuint[] coverDetails\nuint16 coverPeriod","after":"uint holdCoverId\nuint[] coverDetails\naddress payable userAddress\naddress scAddress\nbytes4 coverCurr\nuint16 coverPeriod\n","contract":"QuotationData","time":1},{"type":"constant-restrict-modification  ","before":"address public cbAddress;","after":"address public constant cbAddress;","contract":"OraclizeI","time":0},{"type":"state-data-arrangement ","before":"\nOraclizeI oraclize;\nOraclizeAddrResolverI OAR;\nuint constant day = 60 * 60 * 24;\nuint constant week = 60 * 60 * 24 * 7;\nuint constant month = 60 * 60 * 24 * 30;\nbyte constant proofType_NONE = 0x00;\nbyte constant proofType_Ledger = 0x30;\nbyte constant proofType_Native = 0xF0;\nbyte constant proofStorage_IPFS = 0x01;\nbyte constant proofType_Android = 0x40;\nbyte constant proofType_TLSNotary = 0x10;\nstring oraclize_network_name;\nuint8 constant networkID_auto = 0;\nuint8 constant networkID_morden = 2;\nuint8 constant networkID_mainnet = 1;\nuint8 constant networkID_testnet = 2;\nuint8 constant networkID_consensys = 161;\nmapping(bytes32 => bytes32) oraclize_randomDS_args;\nmapping(bytes32 => bool) oraclize_randomDS_sessionKeysHashVerified;","after":"OraclizeI oraclize;\nOraclizeAddrResolverI OAR;\nuint constant day = 60 * 60 * 24;\nuint constant week = 60 * 60 * 24 * 7;\nuint constant month = 60 * 60 * 24 * 30;\nstring oraclize_network_name;\nmapping(bytes32 => bytes32) oraclize_randomDS_args;\nmapping(bytes32 => bool) oraclize_randomDS_sessionKeysHashVerified;\nbyte constant proofType_NONE = 0x00;\nbyte constant proofType_Ledger = 0x30;\nbyte constant proofType_Native = 0xF0;\nbyte constant proofStorage_IPFS = 0x01;\nbyte constant proofType_Android = 0x40;\nbyte constant proofType_TLSNotary = 0x10;\nuint8 constant networkID_auto = 0;\nuint8 constant networkID_morden = 2;\nuint8 constant networkID_mainnet = 1;\nuint8 constant networkID_testnet = 2;\nuint8 constant networkID_consensys = 161;\n","contract":"usingOraclize","time":0},{"type":"external-function ","before":"function makeCoverUsingNXMTokens(\n        uint[] memory coverDetails,\n        uint16 coverPeriod,\n        bytes4 coverCurr,\n        address smartCAdd,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n    public\n    isMemberAndcheckPause\n    {\n\n        tc.burnFrom(msg.sender, coverDetails[2]);\n        //need burn allowance\n        _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n    }","after":"function makeCoverUsingNXMTokens(\n        uint[] calldata coverDetails,\n        uint16 coverPeriod,\n        bytes4 coverCurr,\n        address smartCAdd,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n    public\n    isMemberAndcheckPause\n    {\n\n        tc.burnFrom(msg.sender, coverDetails[2]);\n        //need burn allowance\n        _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n    }","contract":"Quotation","time":0},{"type":"external-function ","before":"function verifyCoverDetails(\n        address payable from,\n        address scAddress,\n        bytes4 coverCurr,\n        uint[] memory coverDetails,\n        uint16 coverPeriod,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n    public\n    onlyInternal\n    {\n        _verifyCoverDetails(\n            from,\n            scAddress,\n            coverCurr,\n            coverDetails,\n            coverPeriod,\n            _v,\n            _r,\n            _s\n        );\n    }","after":"function verifyCoverDetails(\n        address payable from,\n        address scAddress,\n        bytes4 coverCurr,\n        uint[] calldata coverDetails,\n        uint16 coverPeriod,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n    public\n    onlyInternal\n    {\n        _verifyCoverDetails(\n            from,\n            scAddress,\n            coverCurr,\n            coverDetails,\n            coverPeriod,\n            _v,\n            _r,\n            _s\n        );\n    }","contract":"Quotation","time":0},{"type":"external-function ","before":"function initiateMembershipAndCover(\n        address smartCAdd,\n        bytes4 coverCurr,\n        uint[] memory coverDetails,\n        uint16 coverPeriod,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n    public\n    payable\n    checkPause\n    {\n        require(coverDetails[3] > now);\n        require(!qd.timestampRepeated(coverDetails[4]));\n        qd.setTimestampRepeated(coverDetails[4]);\n        require(!ms.isMember(msg.sender));\n        require(qd.refundEligible(msg.sender) == false);\n        uint joinFee = td.joiningFee();\n        uint totalFee = joinFee;\n        if (coverCurr == \"ETH\") {\n            totalFee = joinFee.add(coverDetails[1]);\n        } else {\n            IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n            require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]));\n        }\n        require(msg.value == totalFee);\n        require(verifySign(coverDetails, coverPeriod, coverCurr, smartCAdd, _v, _r, _s));\n        qd.addHoldCover(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod);\n        qd.setRefundEligible(msg.sender, true);\n    }","after":"function initiateMembershipAndCover(\n        address smartCAdd,\n        bytes4 coverCurr,\n        uint[] calldata coverDetails,\n        uint16 coverPeriod,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n    public\n    payable\n    checkPause\n    {\n        require(coverDetails[3] > now);\n        require(!qd.timestampRepeated(coverDetails[4]));\n        qd.setTimestampRepeated(coverDetails[4]);\n        require(!ms.isMember(msg.sender));\n        require(qd.refundEligible(msg.sender) == false);\n        uint joinFee = td.joiningFee();\n        uint totalFee = joinFee;\n        if (coverCurr == \"ETH\") {\n            totalFee = joinFee.add(coverDetails[1]);\n        } else {\n            IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n            require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]));\n        }\n        require(msg.value == totalFee);\n        require(verifySign(coverDetails, coverPeriod, coverCurr, smartCAdd, _v, _r, _s));\n        qd.addHoldCover(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod);\n        qd.setRefundEligible(msg.sender, true);\n    }","contract":"Quotation","time":0},{"type":"state-data-arrangement ","before":"\nMCR internal m1;\nPool1 internal p1;\nPoolData internal pd;\nFactory internal factory;\naddress public uniswapFactoryAddress;\nuint internal constant DECIMAL1E18 = uint(10) ** 18;\nbool internal locked;","after":"MCR internal m1;\nPool1 internal p1;\nPoolData internal pd;\nFactory internal factory;\nuint internal constant DECIMAL1E18 = uint(10) ** 18;\naddress public uniswapFactoryAddress;\nbool internal locked;\n","contract":"Pool2","time":0},{"type":"external-function ","before":"function makeCoverBegin(\n        address smartCAdd,\n        bytes4 coverCurr,\n        uint[] memory coverDetails,\n        uint16 coverPeriod,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n    public\n    isMember\n    checkPause\n    payable\n    {\n        require(msg.value == coverDetails[1]);\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n    }","after":"function makeCoverBegin(\n        address smartCAdd,\n        bytes4 coverCurr,\n        uint[] calldata coverDetails,\n        uint16 coverPeriod,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n    public\n    isMember\n    checkPause\n    payable\n    {\n        require(msg.value == coverDetails[1]);\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n    }","contract":"Pool1","time":0},{"type":"external-function ","before":"function makeCoverUsingCA(\n        address smartCAdd,\n        bytes4 coverCurr,\n        uint[] memory coverDetails,\n        uint16 coverPeriod,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n    public\n    isMember\n    checkPause\n    {\n        IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n        require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]), \"Transfer failed\");\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n    }","after":"function makeCoverUsingCA(\n        address smartCAdd,\n        bytes4 coverCurr,\n        uint[] calldata coverDetails,\n        uint16 coverPeriod,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n    public\n    isMember\n    checkPause\n    {\n        IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n        require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]), \"Transfer failed\");\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n    }","contract":"Pool1","time":0},{"type":"loop-calculation","before":"uint pendingTime;","after":"// move outside for loop\nuint pendingTime;","loc":{"start":{"line":8984,"column":12},"end":{"line":8984,"column":28}},"contract":"Claims","time":0},{"type":"loop-duplication","before":"\nstart line 9507 column 8, end line 9528 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n            voteid = cd.getVoteAddressCA(msg.sender, i);\n            (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n                lastClaimed = i;\n            }\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n            if (perc > 0 && !claimed) {\n                counter++;\n                cd.setRewardClaimed(voteid, true);\n            } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\n                (perc,,) = cd.getClaimRewardDetail(claimId);\n                if (perc == 0) {\n                    counter++;\n                }\n                cd.setRewardClaimed(voteid, true);\n            }\n            if (tokenForVoteId > 0) {\n                total = tokenForVoteId.add(total);\n            }\n        }\nstart line 9544 column 8, end line 9558 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n            voteid = cd.getVoteAddressMember(msg.sender, i);\n            (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n                lastClaimed = i;\n            }\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n            if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\n                cd.setRewardClaimed(voteid, true);\n                counter++;\n            }\n            if (tokenForVoteId > 0) {\n                total = tokenForVoteId.add(total);\n            }\n        }","after":"// merge loop\n\nstart line 9507 column 8, end line 9528 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n            voteid = cd.getVoteAddressCA(msg.sender, i);\n            (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n                lastClaimed = i;\n            }\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n            if (perc > 0 && !claimed) {\n                counter++;\n                cd.setRewardClaimed(voteid, true);\n            } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\n                (perc,,) = cd.getClaimRewardDetail(claimId);\n                if (perc == 0) {\n                    counter++;\n                }\n                cd.setRewardClaimed(voteid, true);\n            }\n            if (tokenForVoteId > 0) {\n                total = tokenForVoteId.add(total);\n            }\n        }\nstart line 9544 column 8, end line 9558 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n            voteid = cd.getVoteAddressMember(msg.sender, i);\n            (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n                lastClaimed = i;\n            }\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n            if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\n                cd.setRewardClaimed(voteid, true);\n                counter++;\n            }\n            if (tokenForVoteId > 0) {\n                total = tokenForVoteId.add(total);\n            }\n        }","contract":"ClaimsReward","time":0},{"type":"state-data-arrangement ","before":"\nTokenController public dAppToken;\nTokenData internal td;\nQuotationData internal qd;\nClaimsReward internal cr;\nGovernance internal gv;\nTokenFunctions internal tf;\nNXMToken public tk;\nMemberRoleDetails[] internal memberRoleData;\nbool internal constructorCheck;\nuint public maxABCount;\nbool public launched;\nuint public launchedOn;","after":"TokenController public dAppToken;\nTokenData internal td;\nQuotationData internal qd;\nClaimsReward internal cr;\nGovernance internal gv;\nTokenFunctions internal tf;\nNXMToken public tk;\nMemberRoleDetails[] internal memberRoleData;\nuint public maxABCount;\nuint public launchedOn;\nbool internal constructorCheck;\nbool public launched;\n","contract":"MemberRoles","time":0},{"type":"external-function ","before":"function addRole(//solhint-disable-line\n        bytes32 _roleName,\n        string memory _roleDescription,\n        address _authorized\n    )\n    public\n    onlyAuthorizedToGovern {\n        _addRole(_roleName, _roleDescription, _authorized);\n    }","after":"function addRole(//solhint-disable-line\n        bytes32 _roleName,\n        string calldata _roleDescription,\n        address _authorized\n    )\n    public\n    onlyAuthorizedToGovern {\n        _addRole(_roleName, _roleDescription, _authorized);\n    }","contract":"MemberRoles","time":0},{"type":"external-function ","before":"function addMembersBeforeLaunch(address[] memory userArray, uint[] memory tokens) public onlyOwner {\n        require(!launched);\n\n        for (uint i = 0; i < userArray.length; i++) {\n            require(!ms.isMember(userArray[i]));\n            dAppToken.addToWhitelist(userArray[i]);\n            _updateRole(userArray[i], uint(Role.Member), true);\n            dAppToken.mint(userArray[i], tokens[i]);\n        }\n        launched = true;\n        launchedOn = now;\n\n    }","after":"function addMembersBeforeLaunch(address[] calldata userArray, uint[] calldata tokens) public onlyOwner {\n        require(!launched);\n\n        for (uint i = 0; i < userArray.length; i++) {\n            require(!ms.isMember(userArray[i]));\n            dAppToken.addToWhitelist(userArray[i]);\n            _updateRole(userArray[i], uint(Role.Member), true);\n            dAppToken.mint(userArray[i], tokens[i]);\n        }\n        launched = true;\n        launchedOn = now;\n\n    }","contract":"MemberRoles","time":0},{"type":"state-data-arrangement ","before":"\nbool public constructorCheck;\nMemberRoles internal mr;\nCategoryStruct[] internal allCategory;\nmapping(uint => CategoryAction) internal categoryActionData;\nmapping(uint => uint) public categoryABReq;\nmapping(uint => uint) public isSpecialResolution;\nmapping(uint => bytes) public categoryActionHashes;\nbool public categoryActionHashUpdated;","after":"MemberRoles internal mr;\nCategoryStruct[] internal allCategory;\nmapping(uint => CategoryAction) internal categoryActionData;\nmapping(uint => uint) public categoryABReq;\nmapping(uint => uint) public isSpecialResolution;\nmapping(uint => bytes) public categoryActionHashes;\nbool public constructorCheck;\nbool public categoryActionHashUpdated;\n","contract":"ProposalCategory","time":0},{"type":"external-function ","before":"function newCategory(\n        string memory _name,\n        uint _memberRoleToVote,\n        uint _majorityVotePerc,\n        uint _quorumPerc,\n        uint[] memory _allowedToCreateProposal,\n        uint _closingTime,\n        string memory _actionHash,\n        address _contractAddress,\n        bytes2 _contractName,\n        uint[] memory _incentives,\n        string memory _functionHash\n    )\n    public\n    onlyAuthorizedToGovern\n    {\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n        //If category is special resolution role authorized should be member\n        if (_incentives[3] == 1) {\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n            _majorityVotePerc = 0;\n            _quorumPerc = 0;\n        }\n\n        _addCategory(\n            _name,\n            _memberRoleToVote,\n            _majorityVotePerc,\n            _quorumPerc,\n            _allowedToCreateProposal,\n            _closingTime,\n            _actionHash,\n            _contractAddress,\n            _contractName,\n            _incentives\n        );\n\n\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n            categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);\n        }\n    }","after":"function newCategory(\n        string calldata _name,\n        uint _memberRoleToVote,\n        uint _majorityVotePerc,\n        uint _quorumPerc,\n        uint[] calldata _allowedToCreateProposal,\n        uint _closingTime,\n        string calldata _actionHash,\n        address _contractAddress,\n        bytes2 _contractName,\n        uint[] calldata _incentives,\n        string calldata _functionHash\n    )\n    public\n    onlyAuthorizedToGovern\n    {\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n        //If category is special resolution role authorized should be member\n        if (_incentives[3] == 1) {\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n            _majorityVotePerc = 0;\n            _quorumPerc = 0;\n        }\n\n        _addCategory(\n            _name,\n            _memberRoleToVote,\n            _majorityVotePerc,\n            _quorumPerc,\n            _allowedToCreateProposal,\n            _closingTime,\n            _actionHash,\n            _contractAddress,\n            _contractName,\n            _incentives\n        );\n\n\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n            categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);\n        }\n    }","contract":"ProposalCategory","time":0},{"type":"external-function ","before":"function editCategory(\n        uint _categoryId,\n        string memory _name,\n        uint _memberRoleToVote,\n        uint _majorityVotePerc,\n        uint _quorumPerc,\n        uint[] memory _allowedToCreateProposal,\n        uint _closingTime,\n        string memory _actionHash,\n        address _contractAddress,\n        bytes2 _contractName,\n        uint[] memory _incentives,\n        string memory _functionHash\n    )\n    public\n    onlyAuthorizedToGovern\n    {\n        require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n        //If category is special resolution role authorized should be member\n        if (_incentives[3] == 1) {\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n            _majorityVotePerc = 0;\n            _quorumPerc = 0;\n        }\n\n        delete categoryActionHashes[_categoryId];\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n            categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\n        }\n        allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\n        allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\n        allCategory[_categoryId].closingTime = _closingTime;\n        allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\n        allCategory[_categoryId].minStake = _incentives[0];\n        allCategory[_categoryId].quorumPerc = _quorumPerc;\n        categoryActionData[_categoryId].defaultIncentive = _incentives[1];\n        categoryActionData[_categoryId].contractName = _contractName;\n        categoryActionData[_categoryId].contractAddress = _contractAddress;\n        categoryABReq[_categoryId] = _incentives[2];\n        isSpecialResolution[_categoryId] = _incentives[3];\n        emit Category(_categoryId, _name, _actionHash);\n    }","after":"function editCategory(\n        uint _categoryId,\n        string calldata _name,\n        uint _memberRoleToVote,\n        uint _majorityVotePerc,\n        uint _quorumPerc,\n        uint[] calldata _allowedToCreateProposal,\n        uint _closingTime,\n        string calldata _actionHash,\n        address _contractAddress,\n        bytes2 _contractName,\n        uint[] calldata _incentives,\n        string calldata _functionHash\n    )\n    public\n    onlyAuthorizedToGovern\n    {\n        require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n        //If category is special resolution role authorized should be member\n        if (_incentives[3] == 1) {\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n            _majorityVotePerc = 0;\n            _quorumPerc = 0;\n        }\n\n        delete categoryActionHashes[_categoryId];\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n            categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\n        }\n        allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\n        allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\n        allCategory[_categoryId].closingTime = _closingTime;\n        allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\n        allCategory[_categoryId].minStake = _incentives[0];\n        allCategory[_categoryId].quorumPerc = _quorumPerc;\n        categoryActionData[_categoryId].defaultIncentive = _incentives[1];\n        categoryActionData[_categoryId].contractName = _contractName;\n        categoryActionData[_categoryId].contractAddress = _contractAddress;\n        categoryABReq[_categoryId] = _incentives[2];\n        isSpecialResolution[_categoryId] = _incentives[3];\n        emit Category(_categoryId, _name, _actionHash);\n    }","contract":"ProposalCategory","time":0},{"type":"constant-restrict-modification  ","before":"bool public constructorCheck;","after":"bool public constant constructorCheck;","contract":"ProposalCategory","time":1},{"type":"state-data-arrangement ","before":"\nProposalVote[] internal allVotes;\nDelegateVote[] public allDelegation;\nmapping(uint => ProposalData) internal allProposalData;\nmapping(uint => bytes[]) internal allProposalSolutions;\nmapping(address => uint[]) internal allVotesByMember;\nmapping(uint => mapping(address => bool)) public rewardClaimed;\nmapping(address => mapping(uint => uint)) public memberProposalVote;\nmapping(address => uint) public followerDelegation;\nmapping(address => uint) internal followerCount;\nmapping(address => uint[]) internal leaderDelegation;\nmapping(uint => VoteTally) public proposalVoteTally;\nmapping(address => bool) public isOpenForDelegation;\nmapping(address => uint) public lastRewardClaimed;\nbool internal constructorCheck;\nuint public tokenHoldingTime;\nuint internal roleIdAllowedToCatgorize;\nuint internal maxVoteWeigthPer;\nuint internal specialResolutionMajPerc;\nuint internal maxFollowers;\nuint internal totalProposals;\nuint internal maxDraftTime;\nMemberRoles internal memberRole;\nProposalCategory internal proposalCategory;\nTokenController internal tokenInstance;\nmapping(uint => uint) public proposalActionStatus;\nmapping(uint => uint) internal proposalExecutionTime;\nmapping(uint => mapping(address => bool)) public proposalRejectedByAB;\nmapping(uint => uint) internal actionRejectedCount;\nbool internal actionParamsInitialised;\nuint internal actionWaitingTime;\nuint constant internal AB_MAJ_TO_REJECT_ACTION = 3;","after":"ProposalVote[] internal allVotes;\nDelegateVote[] public allDelegation;\nmapping(uint => ProposalData) internal allProposalData;\nmapping(uint => bytes[]) internal allProposalSolutions;\nmapping(address => uint[]) internal allVotesByMember;\nmapping(uint => mapping(address => bool)) public rewardClaimed;\nmapping(address => mapping(uint => uint)) public memberProposalVote;\nmapping(address => uint) public followerDelegation;\nmapping(address => uint) internal followerCount;\nmapping(address => uint[]) internal leaderDelegation;\nmapping(uint => VoteTally) public proposalVoteTally;\nmapping(address => bool) public isOpenForDelegation;\nmapping(address => uint) public lastRewardClaimed;\nuint public tokenHoldingTime;\nuint internal roleIdAllowedToCatgorize;\nuint internal maxVoteWeigthPer;\nuint internal specialResolutionMajPerc;\nuint internal maxFollowers;\nuint internal totalProposals;\nuint internal maxDraftTime;\nMemberRoles internal memberRole;\nProposalCategory internal proposalCategory;\nTokenController internal tokenInstance;\nmapping(uint => uint) public proposalActionStatus;\nmapping(uint => uint) internal proposalExecutionTime;\nmapping(uint => mapping(address => bool)) public proposalRejectedByAB;\nmapping(uint => uint) internal actionRejectedCount;\nuint internal actionWaitingTime;\nuint constant internal AB_MAJ_TO_REJECT_ACTION = 3;\nbool internal constructorCheck;\nbool internal actionParamsInitialised;\n","contract":"Governance","time":0},{"type":"constant-restrict-modification  ","before":"bool internal constructorCheck;","after":"bool internal constant constructorCheck;","contract":"Governance","time":1},{"type":"constant-restrict-modification  ","before":"uint internal roleIdAllowedToCatgorize;","after":"uint internal constant roleIdAllowedToCatgorize;","contract":"Governance","time":1},{"type":"constant-restrict-modification  ","before":"uint internal maxVoteWeigthPer;","after":"uint internal constant maxVoteWeigthPer;","contract":"Governance","time":1},{"type":"constant-restrict-modification  ","before":"uint internal specialResolutionMajPerc;","after":"uint internal constant specialResolutionMajPerc;","contract":"Governance","time":1}]}