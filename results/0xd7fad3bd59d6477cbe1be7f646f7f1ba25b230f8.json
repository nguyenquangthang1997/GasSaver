{"time":532,"results":[{"type":"external-function ","before":"function onSwap(\n        SwapRequest memory request,\n        uint256[] memory balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) public view override onlyVault(request.poolId) whenNotPaused returns (uint256) {\n        // In most Pools, swaps involve exchanging one token held by the Pool for another. In this case however, since\n        // one of the three tokens is the BPT itself, a swap might also be a join (main/wrapped for BPT) or an exit\n        // (BPT for main/wrapped).\n        // All three swap types (swaps, joins and exits) are fully disabled if the emergency pause is enabled. Under\n        // these circumstances, the Pool should be exited using the regular Vault.exitPool function.\n\n        // Sanity check: this is not entirely necessary as the Vault's interface enforces the indices to be valid, but\n        // the check is cheap to perform.\n        _require(indexIn < _TOTAL_TOKENS && indexOut < _TOTAL_TOKENS, Errors.OUT_OF_BOUNDS);\n\n        // Note that we already know the indices of the main token, wrapped token and BPT, so there is no need to pass\n        // these indices to the inner functions.\n\n        // Upscale balances by the scaling factors (taking into account the wrapped token rate)\n        uint256[] memory scalingFactors = _scalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 lowerTarget, uint256 upperTarget) = getTargets();\n        LinearMath.Params memory params = LinearMath.Params({\n        fee : getSwapFeePercentage(),\n        lowerTarget : lowerTarget,\n        upperTarget : upperTarget\n        });\n\n        if (request.kind == IVault.SwapKind.GIVEN_IN) {\n            // The amount given is for token in, the amount calculated is for token out\n            request.amount = _upscale(request.amount, scalingFactors[indexIn]);\n            uint256 amountOut = _onSwapGivenIn(request, balances, params);\n\n            // amountOut tokens are exiting the Pool, so we round down.\n            return _downscaleDown(amountOut, scalingFactors[indexOut]);\n        } else {\n            // The amount given is for token out, the amount calculated is for token in\n            request.amount = _upscale(request.amount, scalingFactors[indexOut]);\n            uint256 amountIn = _onSwapGivenOut(request, balances, params);\n\n            // amountIn tokens are entering the Pool, so we round up.\n            return _downscaleUp(amountIn, scalingFactors[indexIn]);\n        }\n    }","after":"function onSwap(\n        SwapRequest calldata request,\n        uint256[] memory balances,\n        uint256 indexIn,\n        uint256 indexOut\n    ) public view override onlyVault(request.poolId) whenNotPaused returns (uint256) {\n        // In most Pools, swaps involve exchanging one token held by the Pool for another. In this case however, since\n        // one of the three tokens is the BPT itself, a swap might also be a join (main/wrapped for BPT) or an exit\n        // (BPT for main/wrapped).\n        // All three swap types (swaps, joins and exits) are fully disabled if the emergency pause is enabled. Under\n        // these circumstances, the Pool should be exited using the regular Vault.exitPool function.\n\n        // Sanity check: this is not entirely necessary as the Vault's interface enforces the indices to be valid, but\n        // the check is cheap to perform.\n        _require(indexIn < _TOTAL_TOKENS && indexOut < _TOTAL_TOKENS, Errors.OUT_OF_BOUNDS);\n\n        // Note that we already know the indices of the main token, wrapped token and BPT, so there is no need to pass\n        // these indices to the inner functions.\n\n        // Upscale balances by the scaling factors (taking into account the wrapped token rate)\n        uint256[] memory scalingFactors = _scalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 lowerTarget, uint256 upperTarget) = getTargets();\n        LinearMath.Params memory params = LinearMath.Params({\n        fee : getSwapFeePercentage(),\n        lowerTarget : lowerTarget,\n        upperTarget : upperTarget\n        });\n\n        if (request.kind == IVault.SwapKind.GIVEN_IN) {\n            // The amount given is for token in, the amount calculated is for token out\n            request.amount = _upscale(request.amount, scalingFactors[indexIn]);\n            uint256 amountOut = _onSwapGivenIn(request, balances, params);\n\n            // amountOut tokens are exiting the Pool, so we round down.\n            return _downscaleDown(amountOut, scalingFactors[indexOut]);\n        } else {\n            // The amount given is for token out, the amount calculated is for token in\n            request.amount = _upscale(request.amount, scalingFactors[indexOut]);\n            uint256 amountIn = _onSwapGivenOut(request, balances, params);\n\n            // amountIn tokens are entering the Pool, so we round up.\n            return _downscaleUp(amountIn, scalingFactors[indexIn]);\n        }\n    }","contract":"AaveLinearPool","time":0},{"type":"external-function ","before":"function setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig)\n    public\n    virtual\n    authenticate\n    whenNotPaused\n    {\n        _setAssetManagerPoolConfig(token, poolConfig);\n    }","after":"function setAssetManagerPoolConfig(IERC20 token, bytes calldata poolConfig)\n    public\n    virtual\n    authenticate\n    whenNotPaused\n    {\n        _setAssetManagerPoolConfig(token, poolConfig);\n    }","contract":"AaveLinearPool","time":0},{"type":"external-function ","before":"function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        if (totalSupply() == 0) {\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(\n                poolId,\n                sender,\n                recipient,\n                scalingFactors,\n                userData\n            );\n\n            // On initialization, we lock _getMinimumBpt() by minting it for the zero address. This BPT acts as a\n            // minimum as it will never be burned, which reduces potential issues with rounding, and also prevents the\n            // Pool from ever being fully drained.\n            _require(bptAmountOut >= _getMinimumBpt(), Errors.MINIMUM_BPT);\n            _mintPoolTokens(address(0), _getMinimumBpt());\n            _mintPoolTokens(recipient, bptAmountOut - _getMinimumBpt());\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n            return (amountsIn, new uint256[](_getTotalTokens()));\n        } else {\n            _upscaleArray(balances, scalingFactors);\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n            return (amountsIn, dueProtocolFeeAmounts);\n        }\n    }","after":"function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        if (totalSupply() == 0) {\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(\n                poolId,\n                sender,\n                recipient,\n                scalingFactors,\n                userData\n            );\n\n            // On initialization, we lock _getMinimumBpt() by minting it for the zero address. This BPT acts as a\n            // minimum as it will never be burned, which reduces potential issues with rounding, and also prevents the\n            // Pool from ever being fully drained.\n            _require(bptAmountOut >= _getMinimumBpt(), Errors.MINIMUM_BPT);\n            _mintPoolTokens(address(0), _getMinimumBpt());\n            _mintPoolTokens(recipient, bptAmountOut - _getMinimumBpt());\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n            return (amountsIn, new uint256[](_getTotalTokens()));\n        } else {\n            _upscaleArray(balances, scalingFactors);\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n            return (amountsIn, dueProtocolFeeAmounts);\n        }\n    }","contract":"AaveLinearPool","time":0},{"type":"external-function ","before":"function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            scalingFactors,\n            userData\n        );\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n        _downscaleDownArray(amountsOut, scalingFactors);\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n        return (amountsOut, dueProtocolFeeAmounts);\n    }","after":"function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            scalingFactors,\n            userData\n        );\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n        _downscaleDownArray(amountsOut, scalingFactors);\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n        return (amountsOut, dueProtocolFeeAmounts);\n    }","contract":"AaveLinearPool","time":0},{"type":"external-function ","before":"function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptOut, amountsIn);\n    }","after":"function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptOut, amountsIn);\n    }","contract":"AaveLinearPool","time":0},{"type":"external-function ","before":"function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptIn, amountsOut);\n    }","after":"function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes calldata userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        return (bptIn, amountsOut);\n    }","contract":"AaveLinearPool","time":0},{"type":"constant-restrict-modification  ","before":"bytes32 private immutable _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");","after":"bytes32 private immutable constant _PERMIT_TYPEHASH =\n    keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");","contract":"AaveLinearPool","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"AaveLinearPool","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"AaveLinearPool","time":1},{"type":"external-function ","before":"function create(\n        string memory name,\n        string memory symbol,\n        IERC20 mainToken,\n        IERC20 wrappedToken,\n        uint256 upperTarget,\n        uint256 swapFeePercentage,\n        address owner\n    ) external returns (LinearPool) {\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        LinearPool pool = AaveLinearPool(\n            _create(\n                abi.encode(\n                    getVault(),\n                    name,\n                    symbol,\n                    mainToken,\n                    wrappedToken,\n                    upperTarget,\n                    swapFeePercentage,\n                    pauseWindowDuration,\n                    bufferPeriodDuration,\n                    owner\n                )\n            )\n        );\n\n        // LinearPools have a separate post-construction initialization step: we perform it here to\n        // ensure deployment and initialization are atomic.\n        pool.initialize();\n\n        return pool;\n    }","after":"function create(\n        string calldata name,\n        string calldata symbol,\n        IERC20 mainToken,\n        IERC20 wrappedToken,\n        uint256 upperTarget,\n        uint256 swapFeePercentage,\n        address owner\n    ) external returns (LinearPool) {\n        (uint256 pauseWindowDuration, uint256 bufferPeriodDuration) = getPauseConfiguration();\n\n        LinearPool pool = AaveLinearPool(\n            _create(\n                abi.encode(\n                    getVault(),\n                    name,\n                    symbol,\n                    mainToken,\n                    wrappedToken,\n                    upperTarget,\n                    swapFeePercentage,\n                    pauseWindowDuration,\n                    bufferPeriodDuration,\n                    owner\n                )\n            )\n        );\n\n        // LinearPools have a separate post-construction initialization step: we perform it here to\n        // ensure deployment and initialization are atomic.\n        pool.initialize();\n\n        return pool;\n    }","contract":"AaveLinearPoolFactory","time":0}]}