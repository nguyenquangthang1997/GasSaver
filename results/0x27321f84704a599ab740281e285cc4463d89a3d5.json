{"time":909,"results":[{"type":"external-function ","before":"sol\";\nimport \"../../TokenStakingEscrow.sol\";\nimport \"../..//utils/BytesLib.sol\";\nimport \"../RolesLookup.sol\";\n\n/// @notice TokenStaking contract library allowing to capture the details of\n/// delegated grants and offering functions allowing to check grantee\n/// authentication for stake delegation management.\nlibrary GrantStaking {\n    using BytesLib for bytes;\n    using RolesLookup for address payable;\n\n    /// @dev Grant ID is flagged with the most significant bit set, to\n    /// distinguish the grant ID `0` from default (null) value. The flag is\n    /// toggled with bitwise XOR (`^`) which kee","after":"sol\";\nimport \"../../TokenStakingEscrow.sol\";\nimport \"../..//utils/BytesLib.sol\";\nimport \"../RolesLookup.sol\";\n\n/// @notice TokenStaking contract library allowing to capture the details of\n/// delegated grants and offering functions allowing to check grantee\n/// authentication for stake delegation management.\nlibrary GrantStaking {\n    using BytesLib for bytes;\n    using RolesLookup for address payable;\n\n    /// @dev Grant ID is flagged with the most significant bit set, to\n    /// distinguish the grant ID `0` from default (null) value. The flag is\n    /// toggled with bitwise XOR (`^`) which kee","contract":"GrantStaking","time":0},{"type":"external-function ","before":"     panicButtons[_operatorContract] != address(0),\n            \"Disabled panic button cannot be updated\"\n        );\n        require(\n            _panicButton != address(0),\n            \"Panic button must be non-zero address\"\n        );\n\n        panicButtons[_operatorContract] = _panicButton;\n\n        emit OperatorContractPanicButtonUpda","after":"     panicButtons[_operatorContract] != address(0),\n            \"Disabled panic button cannot be updated\"\n        );\n        require(\n            _panicButton != address(0),\n            \"Panic button must be non-zero address\"\n        );\n\n        panicButtons[_operatorContract] = _panicButton;\n\n        emit OperatorContractPanicButtonUpda","contract":"KeepToken","time":0},{"type":"immutable-restrict-modification ","before":"{\n        require(acc","after":"{\n        require(acc","contract":"KeepToken","time":0},{"type":"immutable-restrict-modification ","before":"!= address(0), \"ERC20: ","after":"!= address(0), \"ERC20: ","contract":"KeepToken","time":0},{"type":"immutable-restrict-modification ","before":"from the zero address\");","after":"from the zero address\");","contract":"KeepToken","time":0},{"type":"external-function ","before":"e grantee towards the token grant contract,\n/// proxying instructions from the actual grantee.\n/// The address used by the actual grantee\n/// to issue instructions and withdraw tokens\n/// can be reassigned with th","after":"e grantee towards the token grant contract,\n/// proxying instructions from the actual grantee.\n/// The address used by the actual grantee\n/// to issue instructions and withdraw tokens\n/// can be reassigned with th","contract":"ManagedGrant","time":0},{"type":"immutable-restrict-modification ","before":"lockCreator);\n\n    uint256 p","after":"lockCreator);\n\n    uint256 p","contract":"ManagedGrant","time":0},{"type":"immutable-restrict-modification ","before":" constant maximumLockDu","after":" constant maximumLockDu","contract":"ManagedGrant","time":0},{"type":"struct-data-arrangement ","before":"\nc;\n    }\n\n    /**\n  \n dividing two u\ng by zero.\n     *\nvert`\n     * opcode (\n\n     * invalid opcode t\ns:\n     * - Th\n6 a, uint256 b\nequire(b != 0, \"\n ▓▓▓▓\n�▓ ▓▓�\n�▓▓▓▓▓�\n▓▓▓▓�\n▓▓▓▓▓▓▓ ▓▓▓�","after":"g by zero.\n     *\nvert`\n     * opcode (\n\n     * invalid opcode t\n6 a, uint256 b\nequire(b != 0, \"\n ▓▓▓▓\n�▓ ▓▓�\n�▓▓▓▓▓�\n▓▓▓▓�\n▓▓▓▓▓▓▓ ▓▓▓�\nc;\n    }\n\n    /**\n  \n dividing two u\ns:\n     * - Th\n","contract":"TokenGrant","time":0},{"type":"external-function ","before":"presenting the grants balance owned by the passed address.\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    /// @notice Gets the stake balance of the specified address.\n    /// @param _address The address to query the balance of.\n    /// @return An uint256 representing the amount staked by the passed address.\n    function stakeBalanceOf(address _address) public view returns (uint256 balance) {\n        for (uint i = 0; i < grantIndices[_address].length; i++) {\n            uint256 id = grantIndices[_address][i];\n            balance += grants[id].staked;\n        }\n        return balance;\n    }\n\n    /// @notice Gets grant by ID. Returns only basic grant data.\n    /// If you need unlocking schedule for the grant you must call `getGrantUnlockingSchedule()`\n    /// This is to avoid Ethereum `Stack too deep` issue described here:\n    /// https://forum.ethereum.org/discussion/2400/error-stack-too-deep-try-removing-local-variables\n    /// @param _id ID of the token grant.\n    /// @return amount The amount of tokens the grant provides.\n    /// @return withdrawn The amount of tokens that have already been withdrawn\n    ///                   from the grant.\n    /// @return staked The amount of tokens that have been staked from the grant.\n    /// @return revoked A boolean indicating whether the grant has been revoked,\n    ///                 which is to say that it is no longer unlocking.\n    /// @return grantee The grantee of grant.\n    function getGrant(uint256 _id) public view returns (\n        uint256 amount,\n        uint256 withdrawn,\n        uint256 staked,\n        uint256 revokedAmount,\n        uint256 revokedAt,\n        address grantee\n  ","after":"presenting the grants balance owned by the passed address.\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    /// @notice Gets the stake balance of the specified address.\n    /// @param _address The address to query the balance of.\n    /// @return An uint256 representing the amount staked by the passed address.\n    function stakeBalanceOf(address _address) public view returns (uint256 balance) {\n        for (uint i = 0; i < grantIndices[_address].length; i++) {\n            uint256 id = grantIndices[_address][i];\n            balance += grants[id].staked;\n        }\n        return balance;\n    }\n\n    /// @notice Gets grant by ID. Returns only basic grant data.\n    /// If you need unlocking schedule for the grant you must call `getGrantUnlockingSchedule()`\n    /// This is to avoid Ethereum `Stack too deep` issue described here:\n    /// https://forum.ethereum.org/discussion/2400/error-stack-too-deep-try-removing-local-variables\n    /// @param _id ID of the token grant.\n    /// @return amount The amount of tokens the grant provides.\n    /// @return withdrawn The amount of tokens that have already been withdrawn\n    ///                   from the grant.\n    /// @return staked The amount of tokens that have been staked from the grant.\n    /// @return revoked A boolean indicating whether the grant has been revoked,\n    ///                 which is to say that it is no longer unlocking.\n    /// @return grantee The grantee of grant.\n    function getGrant(uint256 _id) public view returns (\n        uint256 amount,\n        uint256 withdrawn,\n        uint256 staked,\n        uint256 revokedAmount,\n        uint256 revokedAt,\n        address grantee\n  ","contract":"TokenGrant","time":0},{"type":"external-function ","before":"afeTransferFrom(_from, address(this), _amount);\n\n        // Maintain a record of the unlocked amount\n        balances[_grantee] = balances[_grantee].add(_amount);\n        emit TokenGrantCreated(id);\n    }\n\n    /// @notice Withdraws Token grant amount to grantee.\n    /// @dev Transfers unlocked tokens of the token grant to grantee.\n    /// @param _id Grant ID.\n    function withdraw(uint256 _id) public {\n        uint256 amount = withdrawable(_id);\n        require(amount > 0, \"Grant available to withdraw amount should be greater than zero.\");\n\n        // Update withdrawn amount.\n        grants[_id].withdrawn = grants[_id].withdrawn.add(amount);\n\n        // Update grantee grants balance.\n        balances[grants[_id].grantee] = balances[grants[_id].grantee].sub(amount);\n\n        // Transfer tokens from this contract balance to the grantee token balance.\n        token.safeTransfer(grants[_id].grantee, amount);\n\n        emit TokenGrantWithdrawn(_id, amount);\n    }\n\n    /// @notice Calculates and returns unlocked grant amount.\n    /// @dev Calculates token grant amount that has already unlocked,\n    /// including any tokens that have already been withdrawn by the grantee as well\n    /// as any tokens that are available to withdraw but have not yet been withdrawn.\n    /// @param _id Grant ID.\n    function unlockedAmount(uint256 _id) public view returns (uint256) {\n        Grant storage grant = grants[_id];\n        return (grant.revokedAt != 0)\n        // Grant revoked -> retur","after":"afeTransferFrom(_from, address(this), _amount);\n\n        // Maintain a record of the unlocked amount\n        balances[_grantee] = balances[_grantee].add(_amount);\n        emit TokenGrantCreated(id);\n    }\n\n    /// @notice Withdraws Token grant amount to grantee.\n    /// @dev Transfers unlocked tokens of the token grant to grantee.\n    /// @param _id Grant ID.\n    function withdraw(uint256 _id) public {\n        uint256 amount = withdrawable(_id);\n        require(amount > 0, \"Grant available to withdraw amount should be greater than zero.\");\n\n        // Update withdrawn amount.\n        grants[_id].withdrawn = grants[_id].withdrawn.add(amount);\n\n        // Update grantee grants balance.\n        balances[grants[_id].grantee] = balances[grants[_id].grantee].sub(amount);\n\n        // Transfer tokens from this contract balance to the grantee token balance.\n        token.safeTransfer(grants[_id].grantee, amount);\n\n        emit TokenGrantWithdrawn(_id, amount);\n    }\n\n    /// @notice Calculates and returns unlocked grant amount.\n    /// @dev Calculates token grant amount that has already unlocked,\n    /// including any tokens that have already been withdrawn by the grantee as well\n    /// as any tokens that are available to withdraw but have not yet been withdrawn.\n    /// @param _id Grant ID.\n    function unlockedAmount(uint256 _id) public view returns (uint256) {\n        Grant storage grant = grants[_id];\n        return (grant.revokedAt != 0)\n        // Grant revoked -> retur","contract":"TokenGrant","time":0},{"type":"external-function ","before":"withdrawn);\n        uint256 stakeable = grant.stakingPolicy.getStakeableAmount(\n            now,\n            amount,\n            grant.duration,\n            grant.start,\n            grant.cliff,\n            withdrawn\n        );\n        // Clamp the stakeable amount to what is left in the grant\n        // in the cas","after":"withdrawn);\n        uint256 stakeable = grant.stakingPolicy.getStakeableAmount(\n            now,\n            amount,\n            grant.duration,\n            grant.start,\n            grant.cliff,\n            withdrawn\n        );\n        // Clamp the stakeable amount to what is left in the grant\n        // in the cas","contract":"TokenGrantStake","time":0},{"type":"immutable-restrict-modification ","before":"king from the grant","after":"king from the grant","contract":"TokenGrantStake","time":0},{"type":"immutable-restrict-modification ","before":" the staking pol","after":" the staking pol","contract":"TokenGrantStake","time":0},{"type":"external-function ","before":"�▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./StakeDelegatable.sol\";\nimport \"./libraries/staking/MinimumStakeSchedule.sol\";\nimport \"./libraries/staking/GrantStaking.sol\";\nimport \"./libraries/staking/Locks.sol\";\nimport \"./libraries/staking/TopUps.sol\";\nimport \"./utils/PercentUtils.sol\";\nimport \"./utils/BytesLib.sol\";\nimport \"./Authorizations.sol\";\nimport \"./TokenStakingEscrow.sol\";\nimport \"./TokenSender.sol\";\n\n\n/// @title TokenStaking\n/// @notice A token staking contract for a specified standard ERC20Burnab","after":"�▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓���▓▓▓▓▓▓▓▓▓  ▓▓▓▓▓▓▓▓▓▓\n\n                           Trust math, not hardware.\n*/\n\npragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\";\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"./StakeDelegatable.sol\";\nimport \"./libraries/staking/MinimumStakeSchedule.sol\";\nimport \"./libraries/staking/GrantStaking.sol\";\nimport \"./libraries/staking/Locks.sol\";\nimport \"./libraries/staking/TopUps.sol\";\nimport \"./utils/PercentUtils.sol\";\nimport \"./utils/BytesLib.sol\";\nimport \"./Authorizations.sol\";\nimport \"./TokenStakingEscrow.sol\";\nimport \"./TokenSender.sol\";\n\n\n/// @title TokenStaking\n/// @notice A token staking contract for a specified standard ERC20Burnab","contract":"TokenStaking","time":0},{"type":"external-function ","before":"nTimestamp\n    ) public {\n        require(\n            msg.sender == _operator ||\n            msg.sender == operators[_operator].owner ||\n            grantStaking.canUndelegate(_operator, tokenGrant),\n            \"Not authorized\"\n        );\n        uint256 oldParams = operators[_operator].packedParams;\n        require(\n            _undelegationTimestamp >= block.timestamp &&\n            _undelegationTimestamp > oldParams.getCreationTimestamp().add(initializationPeriod),\n            \"Invalid timestamp\"\n        );\n        uint256 existingUndelegationTimestamp = oldParams.getUndelegationTimestamp();\n        require(\n        // Undelegation not in progress OR\n            existingUndelegationTimestamp == 0 ||\n            // Undelegating sooner than previously set time OR\n            existingUndelegationTimestamp > _undelegationTimestamp ||\n            // We have already checked above that msg.sender is owner, grantee,\n            // or operator. Only owner and grantee are eligible to postpone the\n            // delegation so it is enough if we exclude operator here.\n            msg.sender != _operator,\n            \"Operator may not postpone\"\n        );\n        operators[_operator].packedParams = oldParams.setUndelegationTimestamp(\n            _undelegationTimestamp\n        );\n        emit Undelegated(_operator, _undelegationTimestamp);\n    }\n\n    /// @notice Recovers staked tokens and transfers them back to the owner.\n    /// Recovering tokens can only be p","after":"nTimestamp\n    ) public {\n        require(\n            msg.sender == _operator ||\n            msg.sender == operators[_operator].owner ||\n            grantStaking.canUndelegate(_operator, tokenGrant),\n            \"Not authorized\"\n        );\n        uint256 oldParams = operators[_operator].packedParams;\n        require(\n            _undelegationTimestamp >= block.timestamp &&\n            _undelegationTimestamp > oldParams.getCreationTimestamp().add(initializationPeriod),\n            \"Invalid timestamp\"\n        );\n        uint256 existingUndelegationTimestamp = oldParams.getUndelegationTimestamp();\n        require(\n        // Undelegation not in progress OR\n            existingUndelegationTimestamp == 0 ||\n            // Undelegating sooner than previously set time OR\n            existingUndelegationTimestamp > _undelegationTimestamp ||\n            // We have already checked above that msg.sender is owner, grantee,\n            // or operator. Only owner and grantee are eligible to postpone the\n            // delegation so it is enough if we exclude operator here.\n            msg.sender != _operator,\n            \"Operator may not postpone\"\n        );\n        operators[_operator].packedParams = oldParams.setUndelegationTimestamp(\n            _undelegationTimestamp\n        );\n        emit Undelegated(_operator, _undelegationTimestamp);\n    }\n\n    /// @notice Recovers staked tokens and transfers them back to the owner.\n    /// Recovering tokens can only be p","contract":"TokenStaking","time":0},{"type":"external-function ","before":"nt256 amount = operatorParams.getAmount();\n\n        // If there is a pending top-up, force-commit it before returning tokens.\n        amount = amount.add(topUps.cancel(_operator));\n\n        operators[_operator].packedParams = operatorParams.setAmount(0);\n        transferOrDeposit(operators[_operator].owner, _operator, amount);\n\n        emit RecoveredStake(_operator);\n    }\n\n    /// @notice Gets stake delegation info for the given operator.\n    /// @param _operator Operator address.\n    /// @return amount The amount of tokens the given operator delegated.\n    /// @return createdAt The time when the stake has been delegated.\n    /// @return undelegatedAt The time when undelegation has been requested.\n    /// If undelegation has not been requested, 0 is returned.\n    function getDelegationInfo(address _operator)\n    public view returns (uint256 amount, uint256 createdAt, uint256 undelegatedAt) {\n        return operators[_operator].packedParams.unpack();\n    }\n\n    /// @notice Locks given operator stake for the specified duration.\n    /// Locked stake may not be recovered until the lock expires or is released,\n    /// even if the normal undelegation period has passed.\n    /// Only previously authorized operator contract can lock the stake.\n    /// @param operator Operator address.\n    /// @param duration Lock duration in seconds.\n    function lockStake(\n        address operator,\n        uint256 duration\n    ) public onlyApprovedOperatorContract(msg.sender) {\n        require(\n            isAuthorizedForOperator(operator, msg.sender),\n            \"Not authorized\"\n        );\n\n        uint256 operatorParams = operators[operator].packedParams;\n\n        require(\n            _isInitialized(operatorParams)","after":"nt256 amount = operatorParams.getAmount();\n\n        // If there is a pending top-up, force-commit it before returning tokens.\n        amount = amount.add(topUps.cancel(_operator));\n\n        operators[_operator].packedParams = operatorParams.setAmount(0);\n        transferOrDeposit(operators[_operator].owner, _operator, amount);\n\n        emit RecoveredStake(_operator);\n    }\n\n    /// @notice Gets stake delegation info for the given operator.\n    /// @param _operator Operator address.\n    /// @return amount The amount of tokens the given operator delegated.\n    /// @return createdAt The time when the stake has been delegated.\n    /// @return undelegatedAt The time when undelegation has been requested.\n    /// If undelegation has not been requested, 0 is returned.\n    function getDelegationInfo(address _operator)\n    public view returns (uint256 amount, uint256 createdAt, uint256 undelegatedAt) {\n        return operators[_operator].packedParams.unpack();\n    }\n\n    /// @notice Locks given operator stake for the specified duration.\n    /// Locked stake may not be recovered until the lock expires or is released,\n    /// even if the normal undelegation period has passed.\n    /// Only previously authorized operator contract can lock the stake.\n    /// @param operator Operator address.\n    /// @param duration Lock duration in seconds.\n    function lockStake(\n        address operator,\n        uint256 duration\n    ) public onlyApprovedOperatorContract(msg.sender) {\n        require(\n            isAuthorizedForOperator(operator, msg.sender),\n            \"Not authorized\"\n        );\n\n        uint256 operatorParams = operators[operator].packedParams;\n\n        require(\n            _isInitialized(operatorParams)","contract":"TokenStaking","time":0},{"type":"immutable-restrict-modification ","before":"// Operator of the stake.\n","after":"// Operator of the stake.\n","contract":"TokenStaking","time":0},{"type":"immutable-restrict-modification ","before":"constructor(\n        address _tokenA","after":"constructor(\n        address _tokenA","contract":"TokenStaking","time":0},{"type":"external-function ","before":"\n    /// false otherwise.\n    function hasMinimumStake(\n        address staker,\n        address operatorContract\n    ) public view returns (bool) {\n        return activeStake(staker, operatorContract) >= minimumStake();\n    }\n\n    /// @notice Is the operator with the given params initialized\n    function _isInitialized(uint256 _operatorParams)\n    internal view returns (bool) {\n        return block.timestamp > _operatorParams.getCreationTimestamp().add(initializationPeriod);\n    }\n\n    /// @notice Is the opera","after":"\n    /// false otherwise.\n    function hasMinimumStake(\n        address staker,\n        address operatorContract\n    ) public view returns (bool) {\n        return activeStake(staker, operatorContract) >= minimumStake();\n    }\n\n    /// @notice Is the operator with the given params initialized\n    function _isInitialized(uint256 _operatorParams)\n    internal view returns (bool) {\n        return block.timestamp > _operatorParams.getCreationTimestamp().add(initializationPeriod);\n    }\n\n    /// @notice Is the opera","contract":"TokenStakingEscrow","time":0},{"type":"external-function ","before":"/ as far as the operator contract is concerned.\n    /// If the operator contract has a lock on the operator,\n    /// the operator's stake is be released when the lock expires.\n    /// Otherwise the stake is released when the operator finishes undelegating.\n    function _isStakeReleased(\n        address _operator,\n        uint256 _operatorParams,\n        address _operatorContract\n    ) internal view returns (bool) {\n        return _isUndelegatingFinished(_operatorParams) &&\n        locks.isStakeReleased(_operator, _operatorContract);\n    }\n\n    function transferOrDeposit(\n        address _owner,\n        address _operator,\n        uint256 _amount\n    ) internal {\n        if (grantStaking.hasGrantDelegated(_operator)) {\n            // For tokens staked from a grant, transfer them to the escrow.\n            TokenSender(address(token)).approveAndCall(\n                address(escrow),\n                _amount,\n                abi.encode(_operator, grantStaking.getGrantForOperator(_operator))\n            );\n        } else {\n            // For liquid tokens staked, transfer them straight to the owner.\n            token.safeTransfer(_owner, _amount);\n        }\n    }\n}\n/**\n�","after":"/ as far as the operator contract is concerned.\n    /// If the operator contract has a lock on the operator,\n    /// the operator's stake is be released when the lock expires.\n    /// Otherwise the stake is released when the operator finishes undelegating.\n    function _isStakeReleased(\n        address _operator,\n        uint256 _operatorParams,\n        address _operatorContract\n    ) internal view returns (bool) {\n        return _isUndelegatingFinished(_operatorParams) &&\n        locks.isStakeReleased(_operator, _operatorContract);\n    }\n\n    function transferOrDeposit(\n        address _owner,\n        address _operator,\n        uint256 _amount\n    ) internal {\n        if (grantStaking.hasGrantDelegated(_operator)) {\n            // For tokens staked from a grant, transfer them to the escrow.\n            TokenSender(address(token)).approveAndCall(\n                address(escrow),\n                _amount,\n                abi.encode(_operator, grantStaking.getGrantForOperator(_operator))\n            );\n        } else {\n            // For liquid tokens staked, transfer them straight to the owner.\n            token.safeTransfer(_owner, _amount);\n        }\n    }\n}\n/**\n�","contract":"TokenStakingEscrow","time":0}]}