{"time":221,"results":[{"type":"external-function ","before":"function withdraw(address[] memory _tokenAddresses, uint256 _pilotAmount) external {\n        uint256 pilotPercentage;\n\n        uint256 circulatingPilotSupply = circulatingSupply();\n\n        uint256 timestamp = block.timestamp;\n\n        address payable sender = payable(msg.sender);\n\n        address contractAddress = address(this);\n\n        pilotPercentage = (_pilotAmount * PRECISION) / circulatingPilotSupply;\n\n        IERC20Burnable(PILOT_ADDRESS).burnFrom(sender, _pilotAmount);\n\n        for (uint256 i = 0; i < _tokenAddresses.length; i++) {\n            bytes32 withdrawnId = keccak256(abi.encode(_tokenAddresses[i], sender, timestamp));\n            require(withdraws[withdrawnId] == false, \"INDEXFUND:: TOKEN_ALREADY_WITHDRAWN\");\n\n            uint256 tokenPercentageToTransfer = _getTokenPercentage(\n                _tokenAddresses[i],\n                contractAddress,\n                pilotPercentage\n            );\n\n            withdraws[withdrawnId] = true;\n\n            _tokenAddresses[i] == address(0)\n            ? sender.transfer(tokenPercentageToTransfer)\n            : IERC20Burnable(_tokenAddresses[i]).safeTransfer(sender, tokenPercentageToTransfer);\n\n            emit Withdrawn(_tokenAddresses[i], _pilotAmount, tokenPercentageToTransfer, circulatingPilotSupply);\n        }\n    }","after":"function withdraw(address[] calldata _tokenAddresses, uint256 _pilotAmount) external {\n        uint256 pilotPercentage;\n\n        uint256 circulatingPilotSupply = circulatingSupply();\n\n        uint256 timestamp = block.timestamp;\n\n        address payable sender = payable(msg.sender);\n\n        address contractAddress = address(this);\n\n        pilotPercentage = (_pilotAmount * PRECISION) / circulatingPilotSupply;\n\n        IERC20Burnable(PILOT_ADDRESS).burnFrom(sender, _pilotAmount);\n\n        for (uint256 i = 0; i < _tokenAddresses.length; i++) {\n            bytes32 withdrawnId = keccak256(abi.encode(_tokenAddresses[i], sender, timestamp));\n            require(withdraws[withdrawnId] == false, \"INDEXFUND:: TOKEN_ALREADY_WITHDRAWN\");\n\n            uint256 tokenPercentageToTransfer = _getTokenPercentage(\n                _tokenAddresses[i],\n                contractAddress,\n                pilotPercentage\n            );\n\n            withdraws[withdrawnId] = true;\n\n            _tokenAddresses[i] == address(0)\n            ? sender.transfer(tokenPercentageToTransfer)\n            : IERC20Burnable(_tokenAddresses[i]).safeTransfer(sender, tokenPercentageToTransfer);\n\n            emit Withdrawn(_tokenAddresses[i], _pilotAmount, tokenPercentageToTransfer, circulatingPilotSupply);\n        }\n    }","contract":"IndexFund","time":0},{"type":"external-function ","before":"function addLockedFundsAddresses(address[] memory _accounts) external onlyTimelock {\n        for (uint24 i = 0; i < _accounts.length; i++) {\n            require(_accounts[i] != address(0), \"INDEX_FUND:: ZERO_ADDRESS\");\n            lockedFundAddresses.push(_accounts[i]);\n        }\n    }","after":"function addLockedFundsAddresses(address[] calldata _accounts) external onlyTimelock {\n        for (uint24 i = 0; i < _accounts.length; i++) {\n            require(_accounts[i] != address(0), \"INDEX_FUND:: ZERO_ADDRESS\");\n            lockedFundAddresses.push(_accounts[i]);\n        }\n    }","contract":"IndexFund","time":0},{"type":"immutable-restrict-modification ","before":"address private _timelock;","after":"address private immutable _timelock;","contract":"IndexFund","time":0}]}