{"time":1224,"results":[{"type":"external-function ","before":"function initialize(address underlying_,\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        // CToken initialize does the bulk of the work\n\n        uint256 initialExchangeRateMantissa_ = 0.2e18;\n\n        uint8 decimals_ = EIP20Interface(underlying_).decimals();\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, reserveFactorMantissa_, adminFeeMantissa_);\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }","after":"function initialize(address underlying_,\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        string calldata name_,\n\n        string calldata symbol_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        // CToken initialize does the bulk of the work\n\n        uint256 initialExchangeRateMantissa_ = 0.2e18;\n\n        uint8 decimals_ = EIP20Interface(underlying_).decimals();\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, reserveFactorMantissa_, adminFeeMantissa_);\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }","contract":"CDaiDelegate","time":0},{"type":"external-function ","before":"function initialize(ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint8 decimals_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        require(msg.sender == address(fuseAdmin), \"only Fuse admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n        // Set reserve factor\n\n        err = _setReserveFactorFresh(reserveFactorMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting reserve factor failed\");\n\n\n        // Set admin fee\n\n        err = _setAdminFeeFresh(adminFeeMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting admin fee failed\");\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n\n    }","after":"function initialize(ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint initialExchangeRateMantissa_,\n\n        string calldata name_,\n\n        string calldata symbol_,\n\n        uint8 decimals_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        require(msg.sender == address(fuseAdmin), \"only Fuse admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n        // Set reserve factor\n\n        err = _setReserveFactorFresh(reserveFactorMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting reserve factor failed\");\n\n\n        // Set admin fee\n\n        err = _setAdminFeeFresh(adminFeeMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting admin fee failed\");\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n\n    }","contract":"CDaiDelegate","time":0},{"type":"constant-restrict-modification  ","before":"  */\n\n    address payable private __pen","after":"  */\n\n    address payable private __pen","contract":"CDaiDelegate","time":8},{"type":"constant-restrict-modification  ","before":"  */\n\n    address public imple","after":"  */\n\n    address public imple","contract":"CErc20Delegator","time":0},{"type":"external-function ","before":"function initialize(ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        // CToken initialize does the bulk of the work\n\n        uint256 initialExchangeRateMantissa_ = 0.2e18;\n\n        uint8 decimals_ = 18;\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, reserveFactorMantissa_, adminFeeMantissa_);\n\n    }","after":"function initialize(ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        string calldata name_,\n\n        string calldata symbol_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        // CToken initialize does the bulk of the work\n\n        uint256 initialExchangeRateMantissa_ = 0.2e18;\n\n        uint8 decimals_ = 18;\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, reserveFactorMantissa_, adminFeeMantissa_);\n\n    }","contract":"CEtherDelegate","time":0},{"type":"external-function ","before":"function initialize(ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint8 decimals_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        require(msg.sender == address(fuseAdmin), \"only Fuse admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n        // Set reserve factor\n\n        err = _setReserveFactorFresh(reserveFactorMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting reserve factor failed\");\n\n\n        // Set admin fee\n\n        err = _setAdminFeeFresh(adminFeeMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting admin fee failed\");\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n\n    }","after":"function initialize(ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint initialExchangeRateMantissa_,\n\n        string calldata name_,\n\n        string calldata symbol_,\n\n        uint8 decimals_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        require(msg.sender == address(fuseAdmin), \"only Fuse admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n        // Set reserve factor\n\n        err = _setReserveFactorFresh(reserveFactorMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting reserve factor failed\");\n\n\n        // Set admin fee\n\n        err = _setAdminFeeFresh(adminFeeMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting admin fee failed\");\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n\n    }","contract":"CEtherDelegate","time":0},{"type":"constant-restrict-modification  ","before":"  */\n\n    address payable private __pen","after":"  */\n\n    address payable private __pen","contract":"CEtherDelegate","time":1},{"type":"constant-restrict-modification  ","before":"  */\n\n    address public u","after":"  */\n\n    address public u","contract":"CEtherDelegate","time":1},{"type":"constant-restrict-modification  ","before":"  */\n\n    address public imple","after":"  */\n\n    address public imple","contract":"CEtherDelegator","time":0},{"type":"state-data-arrangement ","before":"\n  */\n\n    bool internal _n\n  */\n\n    string pu\n  */\n\n    string publ\n  */\n\n    uint8 public\n  */\n\n    uint internal constant borrowRateMaxMantissa = \n  */\n\n    uint internal constant reserveFactorPlusFeesMaxMantis\n  */\n\n    address payable private __pen\n  */\n\n    ComptrollerInterface public co\n  */\n\n    InterestRateModel public interest\n  */\n\n    uint internal initialExchangeRat\n  */\n\n    uint public adminFe\n  */\n\n    uint public fuseFe\n  */\n\n    uint public reserveFacto\n  */\n\n    uint public accrualBl\n  */\n\n    uint public bo\n  */\n\n    uint public tot\n  */\n\n    uint public tota\n  */\n\n    uint public total\n  */\n\n    uint public tota\n  */\n\n    uint public to\n  */\n\n    mapping(address => uint) internal acco\n  */\n\n    mapping(address => mapping(address => uint)) internal transferA\n  */\n\n    mapping(address => BorrowSnapshot) internal accou\n  */\n\n    uint public constant protocolSeizeShareMantissa","after":"  */\n\n    string pu\n  */\n\n    string publ\n  */\n\n    uint internal constant borrowRateMaxMantissa = \n  */\n\n    uint internal constant reserveFactorPlusFeesMaxMantis\n  */\n\n    ComptrollerInterface public co\n  */\n\n    InterestRateModel public interest\n  */\n\n    uint internal initialExchangeRat\n  */\n\n    uint public adminFe\n  */\n\n    uint public fuseFe\n  */\n\n    uint public reserveFacto\n  */\n\n    uint public accrualBl\n  */\n\n    uint public bo\n  */\n\n    uint public tot\n  */\n\n    uint public tota\n  */\n\n    uint public total\n  */\n\n    uint public tota\n  */\n\n    uint public to\n  */\n\n    mapping(address => uint) internal acco\n  */\n\n    mapping(address => mapping(address => uint)) internal transferA\n  */\n\n    mapping(address => BorrowSnapshot) internal accou\n  */\n\n    uint public constant protocolSeizeShareMantissa\n  */\n\n    address payable private __pen\n  */\n\n    bool internal _n\n  */\n\n    uint8 public\n","contract":"CTokenStorage","time":0},{"type":"de-morgan-condition ","before":"ed\n\n        if (!markets[cTokenBorrowed].isListed || !markets[cTokenColl","after":"!(ed\n\n        if (markets[cTokenBorrowed].isListed || markets[cTokenColl)","loc":{"start":{"line":6730,"column":12},"end":{"line":6730,"column":76}},"contract":"Comptroller","time":0},{"type":"de-morgan-condition ","before":"ed\n\n        if (!markets[cTokenCollateral].isListed || !markets[cTokenBo","after":"!(ed\n\n        if (markets[cTokenCollateral].isListed || markets[cTokenBo)","loc":{"start":{"line":6888,"column":12},"end":{"line":6888,"column":76}},"contract":"Comptroller","time":0},{"type":"external-function ","before":"  */\n\n    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n\n        uint len = cTokens.length;\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            CToken cToken = CToken(cTokens[i]);\n\n\n            results[i] = uint(addToMarketInternal(cToken, msg.sender));\n\n        }\n\n\n        return resul","after":"  */\n\n    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n\n        uint len = cTokens.length;\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            CToken cToken = CToken(cTokens[i]);\n\n\n            results[i] = uint(addToMarketInternal(cToken, msg.sender));\n\n        }\n\n\n        return resul","contract":"Comptroller","time":0},{"type":"constant-restrict-modification  ","before":"c pauseGuardian;\n\n    bool publi","after":"c pauseGuardian;\n\n    bool publi","contract":"Comptroller","time":3},{"type":"constant-restrict-modification  ","before":"tGuardianPaused;\n\n    bool public ","after":"tGuardianPaused;\n\n    bool public ","contract":"Comptroller","time":3},{"type":"constant-restrict-modification  ","before":"contract\n\n    */\n\n   ","after":"contract\n\n    */\n\n   ","contract":"Comptroller","time":3},{"type":"constant-restrict-modification  ","before":"contract\n\n    */\n\n    addres","after":"contract\n\n    */\n\n    addres","contract":"Comptroller","time":3},{"type":"constant-restrict-modification  ","before":" rights\n\n     */\n\n    bool public ","after":" rights\n\n     */\n\n    bool public ","contract":"Comptroller","time":3},{"type":"constant-restrict-modification  ","before":"itroller\n\n    */\n\n    address public comp","after":"itroller\n\n    */\n\n    address public comp","contract":"Comptroller","time":3},{"type":"constant-restrict-modification  ","before":"itroller\n\n    */\n\n    address public pendingComp","after":"itroller\n\n    */\n\n    address public pendingComp","contract":"Comptroller","time":3},{"type":"de-morgan-condition ","before":"unused\n\n\n\n        if (!markets[cTokenBorrowed].isListed || !markets[cTok","after":"!(unused\n\n\n\n        if (markets[cTokenBorrowed].isListed || markets[cTok)","loc":{"start":{"line":9371,"column":12},"end":{"line":9371,"column":76}},"contract":"ComptrollerG1","time":0},{"type":"de-morgan-condition ","before":"unused\n\n\n\n        if (!markets[cTokenCollateral].isListed || !markets[cT","after":"!(unused\n\n\n\n        if (markets[cTokenCollateral].isListed || markets[cT)","loc":{"start":{"line":9524,"column":12},"end":{"line":9524,"column":76}},"contract":"ComptrollerG1","time":0},{"type":"external-function ","before":"d\n\n     */\n\n    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n\n        uint len = cTokens.length;\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            CToken cToken = CToken(cTokens[i]);\n\n            Market storage marketToJoin = markets[address(cToken)];\n\n\n            if (!marketToJoin.isListed) {\n\n                // if market is not listed, cannot join move along\n\n                results[i] = uint(Error.MARKET_NOT_LISTED);\n\n                continue;\n\n            }\n\n\n            if (marketToJoin.accountMembership[msg.sender] == true) {\n\n                // if already joined, move along\n\n                results[i] = uint(Error.NO_ERROR);\n\n                continue;\n\n            }\n\n\n            if (accountAssets[msg.sender].length >= maxAssets) {\n\n                // if no space, cannot join, move along\n\n                results[i] = uint(Error.TOO_MANY_ASSETS);\n\n                continue;\n\n            }\n\n\n            // survived the gauntlet, add to list\n\n            // NOTE: we store these somewhat redundantly as a significant optimization\n\n            //  this avoids having to iterate through the list for the most common use cases\n\n            //  that is, only when we need to perform liquidity checks\n\n            //   and not whenever we want to check if an account is in a particular market\n\n            marketToJoin.accountMembership[msg.sender] = true;\n\n            accountAssets[msg.sender].push(cToken);\n\n\n            emit MarketEntered(cToken, msg.sender);\n\n\n            results[i] = uint(Error.NO_ERROR);\n\n        }\n\n\n        return","after":"d\n\n     */\n\n    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n\n        uint len = cTokens.length;\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            CToken cToken = CToken(cTokens[i]);\n\n            Market storage marketToJoin = markets[address(cToken)];\n\n\n            if (!marketToJoin.isListed) {\n\n                // if market is not listed, cannot join move along\n\n                results[i] = uint(Error.MARKET_NOT_LISTED);\n\n                continue;\n\n            }\n\n\n            if (marketToJoin.accountMembership[msg.sender] == true) {\n\n                // if already joined, move along\n\n                results[i] = uint(Error.NO_ERROR);\n\n                continue;\n\n            }\n\n\n            if (accountAssets[msg.sender].length >= maxAssets) {\n\n                // if no space, cannot join, move along\n\n                results[i] = uint(Error.TOO_MANY_ASSETS);\n\n                continue;\n\n            }\n\n\n            // survived the gauntlet, add to list\n\n            // NOTE: we store these somewhat redundantly as a significant optimization\n\n            //  this avoids having to iterate through the list for the most common use cases\n\n            //  that is, only when we need to perform liquidity checks\n\n            //   and not whenever we want to check if an account is in a particular market\n\n            marketToJoin.accountMembership[msg.sender] = true;\n\n            accountAssets[msg.sender].push(cToken);\n\n\n            emit MarketEntered(cToken, msg.sender);\n\n\n            results[i] = uint(Error.NO_ERROR);\n\n        }\n\n\n        return","contract":"ComptrollerG1","time":0},{"type":"immutable-restrict-modification ","before":"contract\n\n    */\n\n   ","after":"contract\n\n    */\n\n   ","contract":"ComptrollerG1","time":1},{"type":"constant-restrict-modification  ","before":"contract\n\n    */\n\n    addres","after":"contract\n\n    */\n\n    addres","contract":"ComptrollerG1","time":1},{"type":"constant-restrict-modification  ","before":" rights\n\n     */\n\n    bool public fuse","after":" rights\n\n     */\n\n    bool public fuse","contract":"ComptrollerG1","time":1},{"type":"constant-restrict-modification  ","before":" rights\n\n     */\n\n    bool public ","after":" rights\n\n     */\n\n    bool public ","contract":"ComptrollerG1","time":1},{"type":"constant-restrict-modification  ","before":"itroller\n\n    */\n\n    address public comp","after":"itroller\n\n    */\n\n    address public comp","contract":"ComptrollerG1","time":1},{"type":"constant-restrict-modification  ","before":"itroller\n\n    */\n\n    address public pendingComp","after":"itroller\n\n    */\n\n    address public pendingComp","contract":"ComptrollerG1","time":1},{"type":"state-data-arrangement ","before":"\npported\n\n     */\n\n    mapping(address => M\nt of all markets\n\n    CToke\nmarkets\n\n     */\n\n    mapping(address => boo\n entered markets\n\n    address[\nBorrowers` array\n\n    mapping(address => uint256) int\nmarkets\n\n     */\n\n    mapping(address => b\n token addresses\n\n    mapping(address => CToken) publi\nlist is enforced\n\n    bool pu\n., mint cTokens)\n\n    mapping(address => b\nelisted accounts\n\n    address[] \nlistArray` array\n\n    mapping(address => uint256) inte\nmarket.\n\n     */\n\n    address\nc pauseGuardian;\n\n    bool publi\ntGuardianPaused;\n\n    bool public \nwGuardianPaused;\n\n    bool public t\nrGuardianPaused;\n\n    bool publi\neGuardianPaused;\n\n    mapping(address => bool) publ\ntGuardianPaused;\n\n    mapping(address => bool) public","after":"pported\n\n     */\n\n    mapping(address => M\nt of all markets\n\n    CToke\nmarkets\n\n     */\n\n    mapping(address => boo\n entered markets\n\n    address[\nBorrowers` array\n\n    mapping(address => uint256) int\nmarkets\n\n     */\n\n    mapping(address => b\n token addresses\n\n    mapping(address => CToken) publi\n., mint cTokens)\n\n    mapping(address => b\nelisted accounts\n\n    address[] \nlistArray` array\n\n    mapping(address => uint256) inte\neGuardianPaused;\n\n    mapping(address => bool) publ\ntGuardianPaused;\n\n    mapping(address => bool) public\nmarket.\n\n     */\n\n    address\nlist is enforced\n\n    bool pu\nc pauseGuardian;\n\n    bool publi\ntGuardianPaused;\n\n    bool public \nwGuardianPaused;\n\n    bool public t\nrGuardianPaused;\n\n    bool publi\n","contract":"ComptrollerV2Storage","time":0},{"type":"state-data-arrangement ","before":"\ngraded.\n\n     */\n\n    bool publ\nhe given market.\n\n    address pub\nmited borrowing.\n\n    mapping(address => ui\nmited supplying.\n\n    mapping(address => ui\nlywheel changes.\n\n    address[] publi\n-entrancy checks\n\n    bool\nbeen initialized\n\n    bool internal _","after":"mited borrowing.\n\n    mapping(address => ui\nmited supplying.\n\n    mapping(address => ui\nlywheel changes.\n\n    address[] publi\nhe given market.\n\n    address pub\ngraded.\n\n     */\n\n    bool publ\n-entrancy checks\n\n    bool\nbeen initialized\n\n    bool internal _\n","contract":"ComptrollerV3Storage","time":0},{"type":"immutable-restrict-modification ","before":"n point\n\n     */\n\n    uint public j","after":"n point\n\n     */\n\n    uint public j","contract":"DAIInterestRateModelV2","time":1},{"type":"immutable-restrict-modification ","before":"applied\n\n     */\n","after":"applied\n\n     */\n","contract":"DAIInterestRateModelV2","time":1},{"type":"constant-restrict-modification  ","before":"lk) public ilks;\n\n  ","after":"lk) public ilks;\n\n  ","contract":"JugLike","time":0},{"type":"immutable-restrict-modification ","before":"rted (immutable)\n\n    ","after":"rted (immutable)\n\n    ","contract":"Reservoir","time":0},{"type":"immutable-restrict-modification ","before":"rget (immutable)\n\n   ","after":"rget (immutable)\n\n   ","contract":"Reservoir","time":0},{"type":"immutable-restrict-modification ","before":"kens (immutable)\n\n    ","after":"kens (immutable)\n\n    ","contract":"Reservoir","time":0},{"type":"external-function ","before":"g market.\n\n     */\n\n    function _setCompSpeeds(CToken[] memory cTokens, uint[] memory supplySpeeds, uint[] memory borrowSpeeds) public {\n\n        require(msg.sender == admin, \"only admin can set comp speed\");\n\n\n        uint numTokens = cTokens.length;\n\n        require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \"RewardsDistributor::_setCompSpeeds invalid input\");\n\n\n        for (uint i = 0; i < numTokens; ++i) {\n\n            setCompSupplySpeedInternal(cTokens[i], supplySpeeds[i]);\n\n            setCompBorrowSpeedInternal(cTokens[i], borrowSpeed","after":"g market.\n\n     */\n\n    function _setCompSpeeds(CToken[] calldata cTokens, uint[] calldata supplySpeeds, uint[] memory borrowSpeeds) public {\n\n        require(msg.sender == admin, \"only admin can set comp speed\");\n\n\n        uint numTokens = cTokens.length;\n\n        require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \"RewardsDistributor::_setCompSpeeds invalid input\");\n\n\n        for (uint i = 0; i < numTokens; ++i) {\n\n            setCompSupplySpeedInternal(cTokens[i], supplySpeeds[i]);\n\n            setCompBorrowSpeedInternal(cTokens[i], borrowSpeed","contract":"RewardsDistributorDelegate","time":0},{"type":"constant-restrict-modification  ","before":"RewardsDistributor\n\n    addres","after":"RewardsDistributor\n\n    addres","contract":"RewardsDistributorDelegate","time":1},{"type":"immutable-restrict-modification ","before":" for this contract\n\n ","after":" for this contract\n\n ","contract":"RewardsDistributorDelegator","time":0},{"type":"constant-restrict-modification  ","before":" for this contract\n\n    addr","after":" for this contract\n\n    addr","contract":"RewardsDistributorDelegator","time":0},{"type":"external-function ","before":"ndingAdmin);\n    }\n\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n    ","after":"ndingAdmin);\n    }\n\n    function queueTransaction(address target, uint value, string calldata signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n    ","contract":"Timelock","time":0},{"type":"external-function ","before":"turn txHash;\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, sign","after":"turn txHash;\n    }\n\n    function cancelTransaction(address target, uint value, string calldata signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, sign","contract":"Timelock","time":0},{"type":"external-function ","before":" data, eta);\n    }\n\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call.value(value)(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        ","after":" data, eta);\n    }\n\n    function executeTransaction(address target, uint value, string calldata signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call.value(value)(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        ","contract":"Timelock","time":0},{"type":"immutable-restrict-modification ","before":"e interest rate\n     */\n    uin","after":"e interest rate\n     */\n    uin","contract":"WhitePaperInterestRateModel","time":0},{"type":"immutable-restrict-modification ","before":"ation rate is 0\n     */\n    u","after":"ation rate is 0\n     */\n    u","contract":"WhitePaperInterestRateModel","time":0}]}