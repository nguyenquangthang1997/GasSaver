{"time":803,"results":[{"type":"external-function ","before":"function getMakerOutAmountWithPath(\n        address _makerAddr,\n        address _takerAssetAddr,\n        address _makerAssetAddr,\n        uint256 _takerAssetAmount,\n        address[] calldata _path,\n        bytes memory _makerSpecificData\n    )\n    public\n    returns (uint256 makerAssetAmount)\n    {\n        GroupedVars memory vars;\n        vars.makerAddr = _makerAddr;\n        vars.takerAssetAddr = _takerAssetAddr;\n        vars.makerAssetAddr = _makerAssetAddr;\n        vars.takerAssetAmount = _takerAssetAmount;\n        vars.path = _path;\n        if (vars.makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS ||\n            vars.makerAddr == SUSHISWAP_ROUTER_ADDRESS) {\n            IUniswapRouterV2 router = IUniswapRouterV2(vars.makerAddr);\n            uint256[] memory amounts = router.getAmountsOut(vars.takerAssetAmount, vars.path);\n            makerAssetAmount = amounts[amounts.length - 1];\n        } else if (vars.makerAddr == UNISWAP_V3_ROUTER_ADDRESS) {\n            IUniswapV3Quoter quoter = IUniswapV3Quoter(UNISWAP_V3_QUOTER_ADDRESS);\n            // swapType:\n            // 1: exactInputSingle, 2: exactInput, 3: exactOuputSingle, 4: exactOutput\n            uint8 swapType = uint8(uint256(_makerSpecificData.readBytes32(0)));\n            if (swapType == 1) {\n                address v3TakerInternalAsset = isETH(vars.takerAssetAddr) ? weth : vars.takerAssetAddr;\n                address v3MakerInternalAsset = isETH(vars.makerAssetAddr) ? weth : vars.makerAssetAddr;\n                (, uint24 poolFee) = abi.decode(_makerSpecificData, (uint8, uint24));\n                makerAssetAmount = quoter.quoteExactInputSingle(v3TakerInternalAsset, v3MakerInternalAsset, poolFee, vars.takerAssetAmount, 0);\n            } else if (swapType == 2) {\n                (, bytes memory path) = abi.decode(_makerSpecificData, (uint8, bytes));\n                makerAssetAmount = quoter.quoteExactInput(path, vars.takerAssetAmount);\n            } else {\n                revert(\"AMMQuoter: Invalid UniswapV3 swap type\");\n            }\n        } else {\n            address curveTakerIntenalAsset = isETH(vars.takerAssetAddr) ? ETH_ADDRESS : vars.takerAssetAddr;\n            address curveMakerIntenalAsset = isETH(vars.makerAssetAddr) ? ETH_ADDRESS : vars.makerAssetAddr;\n            (int128 fromTokenCurveIndex, int128 toTokenCurveIndex, uint16 swapMethod,) = permStorage.getCurvePoolInfo(vars.makerAddr, curveTakerIntenalAsset, curveMakerIntenalAsset);\n            if (fromTokenCurveIndex > 0 && toTokenCurveIndex > 0) {\n                require(swapMethod != 0, \"AMMQuoter: swap method not registered\");\n                // Substract index by 1 because indices stored in `permStorage` starts from 1\n                fromTokenCurveIndex = fromTokenCurveIndex - 1;\n                toTokenCurveIndex = toTokenCurveIndex - 1;\n                ICurveFi curve = ICurveFi(vars.makerAddr);\n                if (swapMethod == 1) {\n                    makerAssetAmount = curve.get_dy(fromTokenCurveIndex, toTokenCurveIndex, vars.takerAssetAmount).sub(1);\n                } else if (swapMethod == 2) {\n                    makerAssetAmount = curve.get_dy_underlying(fromTokenCurveIndex, toTokenCurveIndex, vars.takerAssetAmount).sub(1);\n                }\n            } else {\n                revert(\"AMMQuoter: Unsupported makerAddr\");\n            }\n        }\n        return makerAssetAmount;\n    }","after":"function getMakerOutAmountWithPath(\n        address _makerAddr,\n        address _takerAssetAddr,\n        address _makerAssetAddr,\n        uint256 _takerAssetAmount,\n        address[] calldata _path,\n        bytes calldata _makerSpecificData\n    )\n    public\n    returns (uint256 makerAssetAmount)\n    {\n        GroupedVars memory vars;\n        vars.makerAddr = _makerAddr;\n        vars.takerAssetAddr = _takerAssetAddr;\n        vars.makerAssetAddr = _makerAssetAddr;\n        vars.takerAssetAmount = _takerAssetAmount;\n        vars.path = _path;\n        if (vars.makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS ||\n            vars.makerAddr == SUSHISWAP_ROUTER_ADDRESS) {\n            IUniswapRouterV2 router = IUniswapRouterV2(vars.makerAddr);\n            uint256[] memory amounts = router.getAmountsOut(vars.takerAssetAmount, vars.path);\n            makerAssetAmount = amounts[amounts.length - 1];\n        } else if (vars.makerAddr == UNISWAP_V3_ROUTER_ADDRESS) {\n            IUniswapV3Quoter quoter = IUniswapV3Quoter(UNISWAP_V3_QUOTER_ADDRESS);\n            // swapType:\n            // 1: exactInputSingle, 2: exactInput, 3: exactOuputSingle, 4: exactOutput\n            uint8 swapType = uint8(uint256(_makerSpecificData.readBytes32(0)));\n            if (swapType == 1) {\n                address v3TakerInternalAsset = isETH(vars.takerAssetAddr) ? weth : vars.takerAssetAddr;\n                address v3MakerInternalAsset = isETH(vars.makerAssetAddr) ? weth : vars.makerAssetAddr;\n                (, uint24 poolFee) = abi.decode(_makerSpecificData, (uint8, uint24));\n                makerAssetAmount = quoter.quoteExactInputSingle(v3TakerInternalAsset, v3MakerInternalAsset, poolFee, vars.takerAssetAmount, 0);\n            } else if (swapType == 2) {\n                (, bytes memory path) = abi.decode(_makerSpecificData, (uint8, bytes));\n                makerAssetAmount = quoter.quoteExactInput(path, vars.takerAssetAmount);\n            } else {\n                revert(\"AMMQuoter: Invalid UniswapV3 swap type\");\n            }\n        } else {\n            address curveTakerIntenalAsset = isETH(vars.takerAssetAddr) ? ETH_ADDRESS : vars.takerAssetAddr;\n            address curveMakerIntenalAsset = isETH(vars.makerAssetAddr) ? ETH_ADDRESS : vars.makerAssetAddr;\n            (int128 fromTokenCurveIndex, int128 toTokenCurveIndex, uint16 swapMethod,) = permStorage.getCurvePoolInfo(vars.makerAddr, curveTakerIntenalAsset, curveMakerIntenalAsset);\n            if (fromTokenCurveIndex > 0 && toTokenCurveIndex > 0) {\n                require(swapMethod != 0, \"AMMQuoter: swap method not registered\");\n                // Substract index by 1 because indices stored in `permStorage` starts from 1\n                fromTokenCurveIndex = fromTokenCurveIndex - 1;\n                toTokenCurveIndex = toTokenCurveIndex - 1;\n                ICurveFi curve = ICurveFi(vars.makerAddr);\n                if (swapMethod == 1) {\n                    makerAssetAmount = curve.get_dy(fromTokenCurveIndex, toTokenCurveIndex, vars.takerAssetAmount).sub(1);\n                } else if (swapMethod == 2) {\n                    makerAssetAmount = curve.get_dy_underlying(fromTokenCurveIndex, toTokenCurveIndex, vars.takerAssetAmount).sub(1);\n                }\n            } else {\n                revert(\"AMMQuoter: Unsupported makerAddr\");\n            }\n        }\n        return makerAssetAmount;\n    }","contract":"AMMQuoter","time":0},{"type":"external-function ","before":"function getTakerInAmountWithPath(\n        address _makerAddr,\n        address _takerAssetAddr,\n        address _makerAssetAddr,\n        uint256 _makerAssetAmount,\n        address[] calldata _path,\n        bytes memory _makerSpecificData\n    )\n    public\n    returns (uint256 takerAssetAmount)\n    {\n        GroupedVars memory vars;\n        vars.makerAddr = _makerAddr;\n        vars.takerAssetAddr = _takerAssetAddr;\n        vars.makerAssetAddr = _makerAssetAddr;\n        vars.makerAssetAmount = _makerAssetAmount;\n        vars.path = _path;\n        if (vars.makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS ||\n            vars.makerAddr == SUSHISWAP_ROUTER_ADDRESS) {\n            IUniswapRouterV2 router = IUniswapRouterV2(vars.makerAddr);\n            uint256[] memory amounts = router.getAmountsIn(vars.makerAssetAmount, _path);\n            takerAssetAmount = amounts[0];\n        } else if (vars.makerAddr == UNISWAP_V3_ROUTER_ADDRESS) {\n            IUniswapV3Quoter quoter = IUniswapV3Quoter(UNISWAP_V3_QUOTER_ADDRESS);\n            // swapType:\n            // 1: exactInputSingle, 2: exactInput, 3: exactOuputSingle, 4: exactOutput\n            uint8 swapType = uint8(uint256(_makerSpecificData.readBytes32(0)));\n            if (swapType == 3) {\n                address v3TakerInternalAsset = isETH(vars.takerAssetAddr) ? weth : vars.takerAssetAddr;\n                address v3MakerInternalAsset = isETH(vars.makerAssetAddr) ? weth : vars.makerAssetAddr;\n                (, uint24 poolFee) = abi.decode(_makerSpecificData, (uint8, uint24));\n                takerAssetAmount = quoter.quoteExactOutputSingle(v3TakerInternalAsset, v3MakerInternalAsset, poolFee, vars.makerAssetAmount, 0);\n            } else if (swapType == 4) {\n                (, bytes memory path) = abi.decode(_makerSpecificData, (uint8, bytes));\n                takerAssetAmount = quoter.quoteExactOutput(path, vars.makerAssetAmount);\n            } else {\n                revert(\"AMMQuoter: Invalid UniswapV3 swap type\");\n            }\n        } else {\n            address curveTakerIntenalAsset = isETH(vars.takerAssetAddr) ? ETH_ADDRESS : vars.takerAssetAddr;\n            address curveMakerIntenalAsset = isETH(vars.makerAssetAddr) ? ETH_ADDRESS : vars.makerAssetAddr;\n            (int128 fromTokenCurveIndex, int128 toTokenCurveIndex, uint16 swapMethod, bool supportGetDx) = permStorage.getCurvePoolInfo(vars.makerAddr, curveTakerIntenalAsset, curveMakerIntenalAsset);\n            if (fromTokenCurveIndex > 0 && toTokenCurveIndex > 0) {\n                require(swapMethod != 0, \"AMMQuoter: swap method not registered\");\n                // Substract index by 1 because indices stored in `permStorage` starts from 1\n                fromTokenCurveIndex = fromTokenCurveIndex - 1;\n                toTokenCurveIndex = toTokenCurveIndex - 1;\n                ICurveFi curve = ICurveFi(vars.makerAddr);\n                if (supportGetDx) {\n                    if (swapMethod == 1) {\n                        takerAssetAmount = curve.get_dx(fromTokenCurveIndex, toTokenCurveIndex, vars.makerAssetAmount);\n                    } else if (swapMethod == 2) {\n                        takerAssetAmount = curve.get_dx_underlying(fromTokenCurveIndex, toTokenCurveIndex, vars.makerAssetAmount);\n                    }\n                } else {\n                    if (swapMethod == 1) {\n                        // does not support get_dx_underlying, try to get an estimated rate here\n                        takerAssetAmount = curve.get_dy(toTokenCurveIndex, fromTokenCurveIndex, vars.makerAssetAmount);\n                    } else if (swapMethod == 2) {\n                        takerAssetAmount = curve.get_dy_underlying(toTokenCurveIndex, fromTokenCurveIndex, vars.makerAssetAmount);\n                    }\n                }\n            } else {\n                revert(\"AMMQuoter: Unsupported makerAddr\");\n            }\n        }\n        return takerAssetAmount;\n    }","after":"function getTakerInAmountWithPath(\n        address _makerAddr,\n        address _takerAssetAddr,\n        address _makerAssetAddr,\n        uint256 _makerAssetAmount,\n        address[] calldata _path,\n        bytes calldata _makerSpecificData\n    )\n    public\n    returns (uint256 takerAssetAmount)\n    {\n        GroupedVars memory vars;\n        vars.makerAddr = _makerAddr;\n        vars.takerAssetAddr = _takerAssetAddr;\n        vars.makerAssetAddr = _makerAssetAddr;\n        vars.makerAssetAmount = _makerAssetAmount;\n        vars.path = _path;\n        if (vars.makerAddr == UNISWAP_V2_ROUTER_02_ADDRESS ||\n            vars.makerAddr == SUSHISWAP_ROUTER_ADDRESS) {\n            IUniswapRouterV2 router = IUniswapRouterV2(vars.makerAddr);\n            uint256[] memory amounts = router.getAmountsIn(vars.makerAssetAmount, _path);\n            takerAssetAmount = amounts[0];\n        } else if (vars.makerAddr == UNISWAP_V3_ROUTER_ADDRESS) {\n            IUniswapV3Quoter quoter = IUniswapV3Quoter(UNISWAP_V3_QUOTER_ADDRESS);\n            // swapType:\n            // 1: exactInputSingle, 2: exactInput, 3: exactOuputSingle, 4: exactOutput\n            uint8 swapType = uint8(uint256(_makerSpecificData.readBytes32(0)));\n            if (swapType == 3) {\n                address v3TakerInternalAsset = isETH(vars.takerAssetAddr) ? weth : vars.takerAssetAddr;\n                address v3MakerInternalAsset = isETH(vars.makerAssetAddr) ? weth : vars.makerAssetAddr;\n                (, uint24 poolFee) = abi.decode(_makerSpecificData, (uint8, uint24));\n                takerAssetAmount = quoter.quoteExactOutputSingle(v3TakerInternalAsset, v3MakerInternalAsset, poolFee, vars.makerAssetAmount, 0);\n            } else if (swapType == 4) {\n                (, bytes memory path) = abi.decode(_makerSpecificData, (uint8, bytes));\n                takerAssetAmount = quoter.quoteExactOutput(path, vars.makerAssetAmount);\n            } else {\n                revert(\"AMMQuoter: Invalid UniswapV3 swap type\");\n            }\n        } else {\n            address curveTakerIntenalAsset = isETH(vars.takerAssetAddr) ? ETH_ADDRESS : vars.takerAssetAddr;\n            address curveMakerIntenalAsset = isETH(vars.makerAssetAddr) ? ETH_ADDRESS : vars.makerAssetAddr;\n            (int128 fromTokenCurveIndex, int128 toTokenCurveIndex, uint16 swapMethod, bool supportGetDx) = permStorage.getCurvePoolInfo(vars.makerAddr, curveTakerIntenalAsset, curveMakerIntenalAsset);\n            if (fromTokenCurveIndex > 0 && toTokenCurveIndex > 0) {\n                require(swapMethod != 0, \"AMMQuoter: swap method not registered\");\n                // Substract index by 1 because indices stored in `permStorage` starts from 1\n                fromTokenCurveIndex = fromTokenCurveIndex - 1;\n                toTokenCurveIndex = toTokenCurveIndex - 1;\n                ICurveFi curve = ICurveFi(vars.makerAddr);\n                if (supportGetDx) {\n                    if (swapMethod == 1) {\n                        takerAssetAmount = curve.get_dx(fromTokenCurveIndex, toTokenCurveIndex, vars.makerAssetAmount);\n                    } else if (swapMethod == 2) {\n                        takerAssetAmount = curve.get_dx_underlying(fromTokenCurveIndex, toTokenCurveIndex, vars.makerAssetAmount);\n                    }\n                } else {\n                    if (swapMethod == 1) {\n                        // does not support get_dx_underlying, try to get an estimated rate here\n                        takerAssetAmount = curve.get_dy(toTokenCurveIndex, fromTokenCurveIndex, vars.makerAssetAmount);\n                    } else if (swapMethod == 2) {\n                        takerAssetAmount = curve.get_dy_underlying(toTokenCurveIndex, fromTokenCurveIndex, vars.makerAssetAmount);\n                    }\n                }\n            } else {\n                revert(\"AMMQuoter: Unsupported makerAddr\");\n            }\n        }\n        return takerAssetAmount;\n    }","contract":"AMMQuoter","time":0},{"type":"external-function ","before":"function trade(\n        Order memory _order,\n        uint256 _feeFactor,\n        bytes calldata _sig,\n        bytes calldata _makerSpecificData,\n        address[] calldata _path\n    )\n    payable\n    external\n    nonReentrant\n    onlyUserProxy\n    returns (uint256)\n    {\n        require(_order.deadline >= block.timestamp, \"AMMWrapper: expired order\");\n        TxMetaData memory txMetaData;\n        InternalTxData memory internalTxData;\n\n        // These variables are copied straight from function parameters and\n        // used to bypass stack too deep error.\n        txMetaData.subsidyFactor = uint16(subsidyFactor);\n        txMetaData.feeFactor = uint16(_feeFactor);\n        internalTxData.makerSpecificData = _makerSpecificData;\n        internalTxData.path = _path;\n        if (!permStorage.isRelayerValid(tx.origin)) {\n            txMetaData.feeFactor = (txMetaData.subsidyFactor > txMetaData.feeFactor) ? txMetaData.subsidyFactor : txMetaData.feeFactor;\n            txMetaData.subsidyFactor = 0;\n        }\n\n        // Assign trade vairables\n        internalTxData.fromEth = (_order.takerAssetAddr == ZERO_ADDRESS || _order.takerAssetAddr == ETH_ADDRESS);\n        internalTxData.toEth = (_order.makerAssetAddr == ZERO_ADDRESS || _order.makerAssetAddr == ETH_ADDRESS);\n        if (_isCurve(_order.makerAddr)) {\n            // PermanetStorage can recognize `ETH_ADDRESS` but not `ZERO_ADDRESS`.\n            // Convert it to `ETH_ADDRESS` as passed in `_order.takerAssetAddr` or `_order.makerAssetAddr` might be `ZERO_ADDRESS`.\n            internalTxData.takerAssetInternalAddr = internalTxData.fromEth ? ETH_ADDRESS : _order.takerAssetAddr;\n            internalTxData.makerAssetInternalAddr = internalTxData.toEth ? ETH_ADDRESS : _order.makerAssetAddr;\n        } else {\n            internalTxData.takerAssetInternalAddr = internalTxData.fromEth ? address(weth) : _order.takerAssetAddr;\n            internalTxData.makerAssetInternalAddr = internalTxData.toEth ? address(weth) : _order.makerAssetAddr;\n        }\n\n        txMetaData.transactionHash = _verify(\n            _order,\n            _sig\n        );\n\n        _prepare(_order, internalTxData);\n\n        (txMetaData.source, txMetaData.receivedAmount) = _swapWithPath(\n            _order,\n            txMetaData,\n            internalTxData\n        );\n\n        // Settle\n        txMetaData.settleAmount = _settle(\n            _order,\n            txMetaData,\n            internalTxData\n        );\n\n        emit Swapped(\n            txMetaData,\n            _order\n        );\n\n        return txMetaData.settleAmount;\n    }","after":"function trade(\n        Order calldata _order,\n        uint256 _feeFactor,\n        bytes calldata _sig,\n        bytes calldata _makerSpecificData,\n        address[] calldata _path\n    )\n    payable\n    external\n    nonReentrant\n    onlyUserProxy\n    returns (uint256)\n    {\n        require(_order.deadline >= block.timestamp, \"AMMWrapper: expired order\");\n        TxMetaData memory txMetaData;\n        InternalTxData memory internalTxData;\n\n        // These variables are copied straight from function parameters and\n        // used to bypass stack too deep error.\n        txMetaData.subsidyFactor = uint16(subsidyFactor);\n        txMetaData.feeFactor = uint16(_feeFactor);\n        internalTxData.makerSpecificData = _makerSpecificData;\n        internalTxData.path = _path;\n        if (!permStorage.isRelayerValid(tx.origin)) {\n            txMetaData.feeFactor = (txMetaData.subsidyFactor > txMetaData.feeFactor) ? txMetaData.subsidyFactor : txMetaData.feeFactor;\n            txMetaData.subsidyFactor = 0;\n        }\n\n        // Assign trade vairables\n        internalTxData.fromEth = (_order.takerAssetAddr == ZERO_ADDRESS || _order.takerAssetAddr == ETH_ADDRESS);\n        internalTxData.toEth = (_order.makerAssetAddr == ZERO_ADDRESS || _order.makerAssetAddr == ETH_ADDRESS);\n        if (_isCurve(_order.makerAddr)) {\n            // PermanetStorage can recognize `ETH_ADDRESS` but not `ZERO_ADDRESS`.\n            // Convert it to `ETH_ADDRESS` as passed in `_order.takerAssetAddr` or `_order.makerAssetAddr` might be `ZERO_ADDRESS`.\n            internalTxData.takerAssetInternalAddr = internalTxData.fromEth ? ETH_ADDRESS : _order.takerAssetAddr;\n            internalTxData.makerAssetInternalAddr = internalTxData.toEth ? ETH_ADDRESS : _order.makerAssetAddr;\n        } else {\n            internalTxData.takerAssetInternalAddr = internalTxData.fromEth ? address(weth) : _order.takerAssetAddr;\n            internalTxData.makerAssetInternalAddr = internalTxData.toEth ? address(weth) : _order.makerAssetAddr;\n        }\n\n        txMetaData.transactionHash = _verify(\n            _order,\n            _sig\n        );\n\n        _prepare(_order, internalTxData);\n\n        (txMetaData.source, txMetaData.receivedAmount) = _swapWithPath(\n            _order,\n            txMetaData,\n            internalTxData\n        );\n\n        // Settle\n        txMetaData.settleAmount = _settle(\n            _order,\n            txMetaData,\n            internalTxData\n        );\n\n        emit Swapped(\n            txMetaData,\n            _order\n        );\n\n        return txMetaData.settleAmount;\n    }","contract":"AMMWrapperWithPath","time":0},{"type":"constant-restrict-modification  ","before":"bytes32 public immutable EIP712_DOMAIN_SEPARATOR = keccak256(\n        abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n            getChainID(),\n            address(this)\n        )\n    );","after":"bytes32 public immutable constant EIP712_DOMAIN_SEPARATOR = keccak256(\n        abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n            getChainID(),\n            address(this)\n        )\n    );","contract":"AMMWrapperWithPath","time":1},{"type":"state-data-arrangement ","before":"\nbytes4 constant internal ERC1271_MAGICVALUE = 0x20c13b0b;\nbytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\nuint256 private constant MAX_UINT = 2 ** 256 - 1;\naddress public operator;","after":"uint256 private constant MAX_UINT = 2 ** 256 - 1;\naddress public operator;\nbytes4 constant internal ERC1271_MAGICVALUE = 0x20c13b0b;\nbytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\n","contract":"ERC1271WalletStub","time":0},{"type":"external-function ","before":"function setAllowance(address[] memory _tokenList, address _spender) override external onlyOperator {\n        for (uint256 i = 0; i < _tokenList.length; i++) {\n            IERC20(_tokenList[i]).safeApprove(_spender, MAX_UINT);\n        }\n    }","after":"function setAllowance(address[] calldata _tokenList, address _spender) override external onlyOperator {\n        for (uint256 i = 0; i < _tokenList.length; i++) {\n            IERC20(_tokenList[i]).safeApprove(_spender, MAX_UINT);\n        }\n    }","contract":"ERC1271WalletStub","time":0},{"type":"external-function ","before":"function closeAllowance(address[] memory _tokenList, address _spender) override external onlyOperator {\n        for (uint256 i = 0; i < _tokenList.length; i++) {\n            IERC20(_tokenList[i]).safeApprove(_spender, 0);\n        }\n    }","after":"function closeAllowance(address[] calldata _tokenList, address _spender) override external onlyOperator {\n        for (uint256 i = 0; i < _tokenList.length; i++) {\n            IERC20(_tokenList[i]).safeApprove(_spender, 0);\n        }\n    }","contract":"ERC1271WalletStub","time":0},{"type":"immutable-restrict-modification ","before":"address public operator;","after":"address public immutable operator;","contract":"ERC1271WalletStub","time":0},{"type":"external-function ","before":"function setAllowance(address[] memory token_addrs, address spender) public onlyOperator {\n        for (uint i = 0; i < token_addrs.length; i++) {\n            address token = token_addrs[i];\n            IERC20(token).safeApprove(spender, MAX_UINT);\n        }\n    }","after":"function setAllowance(address[] calldata token_addrs, address spender) public onlyOperator {\n        for (uint i = 0; i < token_addrs.length; i++) {\n            address token = token_addrs[i];\n            IERC20(token).safeApprove(spender, MAX_UINT);\n        }\n    }","contract":"MarketMakerProxy","time":0},{"type":"external-function ","before":"function closeAllowance(address[] memory token_addrs, address spender) public onlyOperator {\n        for (uint i = 0; i < token_addrs.length; i++) {\n            address token = token_addrs[i];\n            IERC20(token).safeApprove(spender, 0);\n        }\n    }","after":"function closeAllowance(address[] calldata token_addrs, address spender) public onlyOperator {\n        for (uint i = 0; i < token_addrs.length; i++) {\n            address token = token_addrs[i];\n            IERC20(token).safeApprove(spender, 0);\n        }\n    }","contract":"MarketMakerProxy","time":0},{"type":"external-function ","before":"function isValidSignature(bytes32 orderHash, bytes memory signature) public view returns (bytes32) {\n        require(\n            SIGNER == _ecrecoverAddress(orderHash, signature),\n            \"MarketMakerProxy: invalid signature\"\n        );\n        return keccak256(\"isValidWalletSignature(bytes32,address,bytes)\");\n    }","after":"function isValidSignature(bytes32 orderHash, bytes calldata signature) public view returns (bytes32) {\n        require(\n            SIGNER == _ecrecoverAddress(orderHash, signature),\n            \"MarketMakerProxy: invalid signature\"\n        );\n        return keccak256(\"isValidWalletSignature(bytes32,address,bytes)\");\n    }","contract":"MarketMakerProxy","time":0},{"type":"external-function ","before":"function submitTransaction(\n        address destination,\n        uint256 value,\n        bytes memory data\n    )\n    public\n    returns (uint256)\n    {\n        uint256 transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId);\n        return transactionId;\n    }","after":"function submitTransaction(\n        address destination,\n        uint256 value,\n        bytes calldata data\n    )\n    public\n    returns (uint256)\n    {\n        uint256 transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId);\n        return transactionId;\n    }","contract":"MiningTreasury","time":0},{"type":"external-function ","before":"function submitTransaction(\n        address signer,\n        uint256 transactionId,\n        address destination,\n        uint256 value,\n        bytes memory data,\n        bytes memory sig\n    )\n    public\n    ownerExists(signer)\n    returns (uint256)\n    {\n        // SUBMIT_TRANSACTION_TYPE_HASH = keccak256(\"submitTransaction(uint256 transactionId,address destination,uint256 value,bytes data)\");\n        bytes32 EIP712SignDigest = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0x01),\n                EIP712_DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        SUBMIT_TRANSACTION_TYPE_HASH,\n                        transactionId,\n                        destination,\n                        value,\n                        data\n                    )\n                )\n            )\n        );\n        validateSignature(signer, EIP712SignDigest, sig);\n\n        uint256 _transactionId = addTransaction(destination, value, data);\n\n        require(transactionId == _transactionId);\n\n        confirmTransactionBySigner(signer, transactionId);\n        return transactionId;\n    }","after":"function submitTransaction(\n        address signer,\n        uint256 transactionId,\n        address destination,\n        uint256 value,\n        bytes calldata data,\n        bytes calldata sig\n    )\n    public\n    ownerExists(signer)\n    returns (uint256)\n    {\n        // SUBMIT_TRANSACTION_TYPE_HASH = keccak256(\"submitTransaction(uint256 transactionId,address destination,uint256 value,bytes data)\");\n        bytes32 EIP712SignDigest = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0x01),\n                EIP712_DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        SUBMIT_TRANSACTION_TYPE_HASH,\n                        transactionId,\n                        destination,\n                        value,\n                        data\n                    )\n                )\n            )\n        );\n        validateSignature(signer, EIP712SignDigest, sig);\n\n        uint256 _transactionId = addTransaction(destination, value, data);\n\n        require(transactionId == _transactionId);\n\n        confirmTransactionBySigner(signer, transactionId);\n        return transactionId;\n    }","contract":"MiningTreasury","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public EIP712_DOMAIN_SEPARATOR;","after":"bytes32 public immutable EIP712_DOMAIN_SEPARATOR;","contract":"MiningTreasury","time":0},{"type":"struct-data-arrangement ","before":"\naddress destination\nuint256 value\nbytes data\nbool executed","after":"uint256 value\nbytes data\naddress destination\nbool executed\n","contract":"MultiSig","time":1},{"type":"external-function ","before":"function fill(\n        uint256 userSalt,\n        bytes memory data,\n        bytes memory userSignature\n    )\n    override\n    public\n    payable\n    onlyUserProxy\n    nonReentrant\n    returns (uint256)\n    {\n        // decode & assert\n        (LibOrder.Order memory order,\n        TradeInfo memory tradeInfo) = _assertTransaction(userSalt, data, userSignature);\n\n        // Deposit to WETH if taker asset is ETH, else transfer from user\n        IWETH weth = IWETH(permStorage.wethAddr());\n        if (address(weth) == tradeInfo.takerAssetAddr) {\n            require(\n                msg.value == order.takerAssetAmount,\n                \"PMM: insufficient ETH\"\n            );\n            weth.deposit{value : msg.value}();\n        } else {\n            spender.spendFromUser(tradeInfo.user, tradeInfo.takerAssetAddr, order.takerAssetAmount);\n        }\n\n        IERC20(tradeInfo.takerAssetAddr).safeIncreaseAllowance(zxERC20Proxy, order.takerAssetAmount);\n\n        // send tx to 0x\n        zeroExchange.executeTransaction(\n            userSalt,\n            address(this),\n            data,\n            \"\"\n        );\n\n        // settle token/ETH to user\n        uint256 settleAmount = _settle(weth, tradeInfo.receiver, tradeInfo.makerAssetAddr, order.makerAssetAmount, tradeInfo.feeFactor);\n        IERC20(tradeInfo.takerAssetAddr).safeApprove(zxERC20Proxy, 0);\n\n        emit FillOrder(\n            SOURCE,\n            tradeInfo.transactionHash,\n            tradeInfo.orderHash,\n            tradeInfo.user,\n            tradeInfo.takerAssetAddr,\n            order.takerAssetAmount,\n            order.makerAddress,\n            tradeInfo.makerAssetAddr,\n            order.makerAssetAmount,\n            tradeInfo.receiver,\n            settleAmount,\n            tradeInfo.feeFactor\n        );\n        return settleAmount;\n    }","after":"function fill(\n        uint256 userSalt,\n        bytes calldata data,\n        bytes calldata userSignature\n    )\n    override\n    public\n    payable\n    onlyUserProxy\n    nonReentrant\n    returns (uint256)\n    {\n        // decode & assert\n        (LibOrder.Order memory order,\n        TradeInfo memory tradeInfo) = _assertTransaction(userSalt, data, userSignature);\n\n        // Deposit to WETH if taker asset is ETH, else transfer from user\n        IWETH weth = IWETH(permStorage.wethAddr());\n        if (address(weth) == tradeInfo.takerAssetAddr) {\n            require(\n                msg.value == order.takerAssetAmount,\n                \"PMM: insufficient ETH\"\n            );\n            weth.deposit{value : msg.value}();\n        } else {\n            spender.spendFromUser(tradeInfo.user, tradeInfo.takerAssetAddr, order.takerAssetAmount);\n        }\n\n        IERC20(tradeInfo.takerAssetAddr).safeIncreaseAllowance(zxERC20Proxy, order.takerAssetAmount);\n\n        // send tx to 0x\n        zeroExchange.executeTransaction(\n            userSalt,\n            address(this),\n            data,\n            \"\"\n        );\n\n        // settle token/ETH to user\n        uint256 settleAmount = _settle(weth, tradeInfo.receiver, tradeInfo.makerAssetAddr, order.makerAssetAmount, tradeInfo.feeFactor);\n        IERC20(tradeInfo.takerAssetAddr).safeApprove(zxERC20Proxy, 0);\n\n        emit FillOrder(\n            SOURCE,\n            tradeInfo.transactionHash,\n            tradeInfo.orderHash,\n            tradeInfo.user,\n            tradeInfo.takerAssetAddr,\n            order.takerAssetAmount,\n            order.makerAddress,\n            tradeInfo.makerAssetAddr,\n            order.makerAssetAmount,\n            tradeInfo.receiver,\n            settleAmount,\n            tradeInfo.feeFactor\n        );\n        return settleAmount;\n    }","contract":"PMM","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public EIP712_DOMAIN_HASH;","after":"bytes32 public immutable EIP712_DOMAIN_HASH;","contract":"PMM","time":1},{"type":"external-function ","before":"function executeMultipleTransactions(\n        uint256[] memory transactionIds\n    )\n    public\n    ownerExists(msg.sender)\n    {\n        for (uint256 i = 0; i < transactionIds.length; i++) {\n            executeTransaction(transactionIds[i]);\n        }\n    }","after":"function executeMultipleTransactions(\n        uint256[] calldata transactionIds\n    )\n    public\n    ownerExists(msg.sender)\n    {\n        for (uint256 i = 0; i < transactionIds.length; i++) {\n            executeTransaction(transactionIds[i]);\n        }\n    }","contract":"PartiallyDelayedMultiSig","time":0},{"type":"external-function ","before":"function submitTransaction(\n        address destination,\n        uint256 value,\n        bytes memory data\n    )\n    public\n    returns (uint256)\n    {\n        uint256 transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId);\n        return transactionId;\n    }","after":"function submitTransaction(\n        address destination,\n        uint256 value,\n        bytes calldata data\n    )\n    public\n    returns (uint256)\n    {\n        uint256 transactionId = addTransaction(destination, value, data);\n        confirmTransaction(transactionId);\n        return transactionId;\n    }","contract":"PartiallyDelayedMultiSig","time":0},{"type":"external-function ","before":"function submitTransaction(\n        address signer,\n        uint256 transactionId,\n        address destination,\n        uint256 value,\n        bytes memory data,\n        bytes memory sig\n    )\n    public\n    ownerExists(signer)\n    returns (uint256)\n    {\n        // SUBMIT_TRANSACTION_TYPE_HASH = keccak256(\"submitTransaction(uint256 transactionId,address destination,uint256 value,bytes data)\");\n        bytes32 EIP712SignDigest = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0x01),\n                EIP712_DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        SUBMIT_TRANSACTION_TYPE_HASH,\n                        transactionId,\n                        destination,\n                        value,\n                        data\n                    )\n                )\n            )\n        );\n        validateSignature(signer, EIP712SignDigest, sig);\n\n        uint256 _transactionId = addTransaction(destination, value, data);\n\n        require(transactionId == _transactionId);\n\n        confirmTransactionBySigner(signer, transactionId);\n        return transactionId;\n    }","after":"function submitTransaction(\n        address signer,\n        uint256 transactionId,\n        address destination,\n        uint256 value,\n        bytes calldata data,\n        bytes calldata sig\n    )\n    public\n    ownerExists(signer)\n    returns (uint256)\n    {\n        // SUBMIT_TRANSACTION_TYPE_HASH = keccak256(\"submitTransaction(uint256 transactionId,address destination,uint256 value,bytes data)\");\n        bytes32 EIP712SignDigest = keccak256(\n            abi.encodePacked(\n                bytes1(0x19),\n                bytes1(0x01),\n                EIP712_DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(\n                        SUBMIT_TRANSACTION_TYPE_HASH,\n                        transactionId,\n                        destination,\n                        value,\n                        data\n                    )\n                )\n            )\n        );\n        validateSignature(signer, EIP712SignDigest, sig);\n\n        uint256 _transactionId = addTransaction(destination, value, data);\n\n        require(transactionId == _transactionId);\n\n        confirmTransactionBySigner(signer, transactionId);\n        return transactionId;\n    }","contract":"PartiallyDelayedMultiSig","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public EIP712_DOMAIN_SEPARATOR;","after":"bytes32 public immutable EIP712_DOMAIN_SEPARATOR;","contract":"PartiallyDelayedMultiSig","time":0},{"type":"external-function ","before":"function fill(\n        RFQLibEIP712.Order memory _order,\n        bytes memory _mmSignature,\n        bytes memory _userSignature\n    )\n    override\n    payable\n    external\n    nonReentrant\n    onlyUserProxy\n    returns (uint256)\n    {\n        // check the order deadline and fee factor\n        require(_order.deadline >= block.timestamp, \"RFQ: expired order\");\n        require(_order.feeFactor < BPS_MAX, \"RFQ: invalid fee factor\");\n\n        GroupedVars memory vars;\n\n        // Validate signatures\n        vars.orderHash = _getOrderHash(_order);\n        require(\n            isValidSignature(\n                _order.makerAddr,\n                _getOrderSignDigestFromHash(vars.orderHash),\n                bytes(\"\"),\n                _mmSignature\n            ),\n            \"RFQ: invalid MM signature\"\n        );\n        vars.transactionHash = _getTransactionHash(_order);\n        require(\n            isValidSignature(\n                _order.takerAddr,\n                _getTransactionSignDigestFromHash(vars.transactionHash),\n                bytes(\"\"),\n                _userSignature\n            ),\n            \"RFQ: invalid user signature\"\n        );\n\n        // Set transaction as seen, PermanentStorage would throw error if transaction already seen.\n        permStorage.setRFQTransactionSeen(vars.transactionHash);\n\n        // Deposit to WETH if taker asset is ETH, else transfer from user\n        if (address(weth) == _order.takerAssetAddr) {\n            require(\n                msg.value == _order.takerAssetAmount,\n                \"RFQ: insufficient ETH\"\n            );\n            weth.deposit{value : msg.value}();\n        } else {\n            spender.spendFromUser(_order.takerAddr, _order.takerAssetAddr, _order.takerAssetAmount);\n        }\n        // Transfer from maker\n        spender.spendFromUser(_order.makerAddr, _order.makerAssetAddr, _order.makerAssetAmount);\n\n        // settle token/ETH to user\n        return _settle(_order, vars);\n    }","after":"function fill(\n        RFQLibEIP712.Order calldata _order,\n        bytes calldata _mmSignature,\n        bytes calldata _userSignature\n    )\n    override\n    payable\n    external\n    nonReentrant\n    onlyUserProxy\n    returns (uint256)\n    {\n        // check the order deadline and fee factor\n        require(_order.deadline >= block.timestamp, \"RFQ: expired order\");\n        require(_order.feeFactor < BPS_MAX, \"RFQ: invalid fee factor\");\n\n        GroupedVars memory vars;\n\n        // Validate signatures\n        vars.orderHash = _getOrderHash(_order);\n        require(\n            isValidSignature(\n                _order.makerAddr,\n                _getOrderSignDigestFromHash(vars.orderHash),\n                bytes(\"\"),\n                _mmSignature\n            ),\n            \"RFQ: invalid MM signature\"\n        );\n        vars.transactionHash = _getTransactionHash(_order);\n        require(\n            isValidSignature(\n                _order.takerAddr,\n                _getTransactionSignDigestFromHash(vars.transactionHash),\n                bytes(\"\"),\n                _userSignature\n            ),\n            \"RFQ: invalid user signature\"\n        );\n\n        // Set transaction as seen, PermanentStorage would throw error if transaction already seen.\n        permStorage.setRFQTransactionSeen(vars.transactionHash);\n\n        // Deposit to WETH if taker asset is ETH, else transfer from user\n        if (address(weth) == _order.takerAssetAddr) {\n            require(\n                msg.value == _order.takerAssetAmount,\n                \"RFQ: insufficient ETH\"\n            );\n            weth.deposit{value : msg.value}();\n        } else {\n            spender.spendFromUser(_order.takerAddr, _order.takerAssetAddr, _order.takerAssetAmount);\n        }\n        // Transfer from maker\n        spender.spendFromUser(_order.makerAddr, _order.makerAssetAddr, _order.makerAssetAmount);\n\n        // settle token/ETH to user\n        return _settle(_order, vars);\n    }","contract":"RFQ","time":1},{"type":"constant-restrict-modification  ","before":"bytes32 public immutable EIP712_DOMAIN_SEPARATOR = keccak256(\n        abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n            getChainID(),\n            address(this)\n        )\n    );","after":"bytes32 public immutable constant EIP712_DOMAIN_SEPARATOR = keccak256(\n        abi.encode(\n            keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n            getChainID(),\n            address(this)\n        )\n    );","contract":"RFQ","time":0},{"type":"state-data-arrangement ","before":"\naddress private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\naddress private constant ZERO_ADDRESS = address(0);\nuint256 constant private TIME_LOCK_DURATION = 1 days;\naddress public operator;\naddress public pendingOperator;\naddress public allowanceTarget;\nmapping(address => bool) private authorized;\nmapping(address => bool) private tokenBlacklist;\nuint256 public numPendingAuthorized;\nmapping(uint256 => address) public pendingAuthorized;\nuint256 public timelockExpirationTime;\nuint256 public contractDeployedTime;\nbool public timelockActivated;\nmapping(address => bool) public consumeGasERC20Tokens;","after":"uint256 constant private TIME_LOCK_DURATION = 1 days;\nmapping(address => bool) private authorized;\nmapping(address => bool) private tokenBlacklist;\nuint256 public numPendingAuthorized;\nmapping(uint256 => address) public pendingAuthorized;\nuint256 public timelockExpirationTime;\nuint256 public contractDeployedTime;\nmapping(address => bool) public consumeGasERC20Tokens;\naddress private constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\naddress private constant ZERO_ADDRESS = address(0);\naddress public operator;\naddress public pendingOperator;\naddress public allowanceTarget;\nbool public timelockActivated;\n","contract":"Spender","time":0},{"type":"external-function ","before":"function setConsumeGasERC20Tokens(address[] memory _consumeGasERC20Tokens) external onlyOperator {\n        for (uint256 i = 0; i < _consumeGasERC20Tokens.length; i++) {\n            consumeGasERC20Tokens[_consumeGasERC20Tokens[i]] = true;\n\n            emit SetConsumeGasERC20Token(_consumeGasERC20Tokens[i]);\n        }\n    }","after":"function setConsumeGasERC20Tokens(address[] calldata _consumeGasERC20Tokens) external onlyOperator {\n        for (uint256 i = 0; i < _consumeGasERC20Tokens.length; i++) {\n            consumeGasERC20Tokens[_consumeGasERC20Tokens[i]] = true;\n\n            emit SetConsumeGasERC20Token(_consumeGasERC20Tokens[i]);\n        }\n    }","contract":"Spender","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public contractDeployedTime;","after":"uint256 public immutable contractDeployedTime;","contract":"Spender","time":1},{"type":"immutable-restrict-modification ","before":"address public operator;","after":"address public immutable operator;","contract":"UserProxyStub","time":0},{"type":"immutable-restrict-modification ","before":"address public weth;","after":"address public immutable weth;","contract":"UserProxyStub","time":0}]}