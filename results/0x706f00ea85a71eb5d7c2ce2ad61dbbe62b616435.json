{"time":395,"results":[{"type":"loop-duplication","before":"\nstart line 1586 column 8, end line 1590 column 8\nfor (uint256 i = 0; i < tokens.length; i++) {\n            require(_newWeights[i] <= constants.MAX_WEIGHT, \"ERR_WEIGHT_ABOVE_MAX\");\n            require(_newWeights[i] >= constants.MIN_WEIGHT, \"ERR_WEIGHT_BELOW_MIN\");\n            weightsSum = weightsSum.badd(_newWeights[i]);\n        }\nstart line 1609 column 8, end line 1612 column 8\nfor (uint256 i = 0; i < tokens.length; i++) {\n            // startWeights are current weights\n            ws.startWeights.push(s.bPool.getDenormalizedWeight(tokens[i]));\n        }","after":"// merge loop\n\nstart line 1586 column 8, end line 1590 column 8\nfor (uint256 i = 0; i < tokens.length; i++) {\n            require(_newWeights[i] <= constants.MAX_WEIGHT, \"ERR_WEIGHT_ABOVE_MAX\");\n            require(_newWeights[i] >= constants.MIN_WEIGHT, \"ERR_WEIGHT_BELOW_MIN\");\n            weightsSum = weightsSum.badd(_newWeights[i]);\n        }\nstart line 1609 column 8, end line 1612 column 8\nfor (uint256 i = 0; i < tokens.length; i++) {\n            // startWeights are current weights\n            ws.startWeights.push(s.bPool.getDenormalizedWeight(tokens[i]));\n        }","contract":"LibWeights","time":0},{"type":"external-function ","before":"function newProxiedSmartPool(\n        string memory _name,\n        string memory _symbol,\n        uint256 _initialSupply,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _weights,\n        uint256 _cap\n    ) public onlyOwner returns (address) {\n        // Deploy proxy contract\n        PProxyPausable proxy = new PProxyPausable();\n\n        // Setup proxy\n        proxy.setImplementation(smartPoolImplementation);\n        proxy.setPauzer(msg.sender);\n        proxy.setProxyOwner(msg.sender);\n\n        // Setup balancer pool\n        address balancerPoolAddress = balancerFactory.newBPool();\n        IBPool bPool = IBPool(balancerPoolAddress);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20 token = IERC20(_tokens[i]);\n            // Transfer tokens to this contract\n            token.transferFrom(msg.sender, address(this), _amounts[i]);\n            // Approve the balancer pool\n            token.safeApprove(balancerPoolAddress, uint256(- 1));\n            // Bind tokens\n            bPool.bind(_tokens[i], _amounts[i], _weights[i]);\n        }\n        bPool.setController(address(proxy));\n\n        // Setup smart pool\n        IPV2SmartPool smartPool = IPV2SmartPool(address(proxy));\n\n        smartPool.init(balancerPoolAddress, _name, _symbol, _initialSupply);\n        smartPool.setCap(_cap);\n        smartPool.setPublicSwapSetter(msg.sender);\n        smartPool.setTokenBinder(msg.sender);\n        smartPool.setController(msg.sender);\n        smartPool.approveTokens();\n\n        isPool[address(smartPool)] = true;\n        pools.push(address(smartPool));\n\n        emit SmartPoolCreated(address(smartPool), _name, _symbol);\n\n        smartPool.transfer(msg.sender, _initialSupply);\n\n        return address(smartPool);\n    }","after":"function newProxiedSmartPool(\n        string calldata _name,\n        string calldata _symbol,\n        uint256 _initialSupply,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        uint256[] calldata _weights,\n        uint256 _cap\n    ) public onlyOwner returns (address) {\n        // Deploy proxy contract\n        PProxyPausable proxy = new PProxyPausable();\n\n        // Setup proxy\n        proxy.setImplementation(smartPoolImplementation);\n        proxy.setPauzer(msg.sender);\n        proxy.setProxyOwner(msg.sender);\n\n        // Setup balancer pool\n        address balancerPoolAddress = balancerFactory.newBPool();\n        IBPool bPool = IBPool(balancerPoolAddress);\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20 token = IERC20(_tokens[i]);\n            // Transfer tokens to this contract\n            token.transferFrom(msg.sender, address(this), _amounts[i]);\n            // Approve the balancer pool\n            token.safeApprove(balancerPoolAddress, uint256(- 1));\n            // Bind tokens\n            bPool.bind(_tokens[i], _amounts[i], _weights[i]);\n        }\n        bPool.setController(address(proxy));\n\n        // Setup smart pool\n        IPV2SmartPool smartPool = IPV2SmartPool(address(proxy));\n\n        smartPool.init(balancerPoolAddress, _name, _symbol, _initialSupply);\n        smartPool.setCap(_cap);\n        smartPool.setPublicSwapSetter(msg.sender);\n        smartPool.setTokenBinder(msg.sender);\n        smartPool.setController(msg.sender);\n        smartPool.approveTokens();\n\n        isPool[address(smartPool)] = true;\n        pools.push(address(smartPool));\n\n        emit SmartPoolCreated(address(smartPool), _name, _symbol);\n\n        smartPool.transfer(msg.sender, _initialSupply);\n\n        return address(smartPool);\n    }","contract":"PProxiedFactory","time":0},{"type":"struct-data-arrangement ","before":"\nuint256 startBlock\nuint256 endBlock\nuint256[] startWeights\nuint256[] newWeights\nNewToken newToken\nbool joinExitEnabled\nuint256 annualFee\nuint256 lastAnnualFeeClaimed\naddress feeRecipient\naddress circuitBreaker","after":"uint256 startBlock\nuint256 endBlock\nuint256[] startWeights\nuint256[] newWeights\nNewToken newToken\nuint256 annualFee\nuint256 lastAnnualFeeClaimed\naddress feeRecipient\naddress circuitBreaker\nbool joinExitEnabled\n","contract":"PV2SmartPoolStorage","time":0}]}