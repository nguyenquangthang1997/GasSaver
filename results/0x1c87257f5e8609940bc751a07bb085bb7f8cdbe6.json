{"time":247,"results":[{"type":"external-function ","before":"function swapExactTokensForTokens(\n\n        uint256 amountIn,\n\n        uint256 amountOutMin,\n\n        address[] memory poolsPath,\n\n        IERC20[] memory path,\n\n        address to,\n\n        uint256 deadline\n\n    ) public virtual override ensure(deadline) returns (uint256[] memory amounts) {\n\n        verifyPoolsPathSwap(poolsPath, path);\n\n        amounts = DMMLibrary.getAmountsOut(amountIn, poolsPath, path);\n\n        require(\n\n            amounts[amounts.length - 1] >= amountOutMin,\n\n            \"DMMRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n\n        );\n\n        IERC20(path[0]).safeTransferFrom(msg.sender, poolsPath[0], amounts[0]);\n\n        _swap(amounts, poolsPath, path, to);\n\n    }","after":"function swapExactTokensForTokens(\n\n        uint256 amountIn,\n\n        uint256 amountOutMin,\n\n        address[] calldata poolsPath,\n\n        IERC20[] calldata path,\n\n        address to,\n\n        uint256 deadline\n\n    ) public virtual override ensure(deadline) returns (uint256[] memory amounts) {\n\n        verifyPoolsPathSwap(poolsPath, path);\n\n        amounts = DMMLibrary.getAmountsOut(amountIn, poolsPath, path);\n\n        require(\n\n            amounts[amounts.length - 1] >= amountOutMin,\n\n            \"DMMRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n\n        );\n\n        IERC20(path[0]).safeTransferFrom(msg.sender, poolsPath[0], amounts[0]);\n\n        _swap(amounts, poolsPath, path, to);\n\n    }","contract":"DMMRouter02","time":0},{"type":"external-function ","before":"function swapTokensForExactTokens(\n\n        uint256 amountOut,\n\n        uint256 amountInMax,\n\n        address[] memory poolsPath,\n\n        IERC20[] memory path,\n\n        address to,\n\n        uint256 deadline\n\n    ) public override ensure(deadline) returns (uint256[] memory amounts) {\n\n        verifyPoolsPathSwap(poolsPath, path);\n\n        amounts = DMMLibrary.getAmountsIn(amountOut, poolsPath, path);\n\n        require(amounts[0] <= amountInMax, \"DMMRouter: EXCESSIVE_INPUT_AMOUNT\");\n\n        path[0].safeTransferFrom(msg.sender, poolsPath[0], amounts[0]);\n\n        _swap(amounts, poolsPath, path, to);\n\n    }","after":"function swapTokensForExactTokens(\n\n        uint256 amountOut,\n\n        uint256 amountInMax,\n\n        address[] calldata poolsPath,\n\n        IERC20[] calldata path,\n\n        address to,\n\n        uint256 deadline\n\n    ) public override ensure(deadline) returns (uint256[] memory amounts) {\n\n        verifyPoolsPathSwap(poolsPath, path);\n\n        amounts = DMMLibrary.getAmountsIn(amountOut, poolsPath, path);\n\n        require(amounts[0] <= amountInMax, \"DMMRouter: EXCESSIVE_INPUT_AMOUNT\");\n\n        path[0].safeTransferFrom(msg.sender, poolsPath[0], amounts[0]);\n\n        _swap(amounts, poolsPath, path, to);\n\n    }","contract":"DMMRouter02","time":0},{"type":"external-function ","before":"function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n\n        uint256 amountIn,\n\n        uint256 amountOutMin,\n\n        address[] memory poolsPath,\n\n        IERC20[] memory path,\n\n        address to,\n\n        uint256 deadline\n\n    ) public override ensure(deadline) {\n\n        path[0].safeTransferFrom(msg.sender, poolsPath[0], amountIn);\n\n        uint256 balanceBefore = path[path.length - 1].balanceOf(to);\n\n        _swapSupportingFeeOnTransferTokens(poolsPath, path, to);\n\n        uint256 balanceAfter = path[path.length - 1].balanceOf(to);\n\n        require(\n\n            balanceAfter >= balanceBefore.add(amountOutMin),\n\n            \"DMMRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n\n        );\n\n    }","after":"function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n\n        uint256 amountIn,\n\n        uint256 amountOutMin,\n\n        address[] calldata poolsPath,\n\n        IERC20[] calldata path,\n\n        address to,\n\n        uint256 deadline\n\n    ) public override ensure(deadline) {\n\n        path[0].safeTransferFrom(msg.sender, poolsPath[0], amountIn);\n\n        uint256 balanceBefore = path[path.length - 1].balanceOf(to);\n\n        _swapSupportingFeeOnTransferTokens(poolsPath, path, to);\n\n        uint256 balanceAfter = path[path.length - 1].balanceOf(to);\n\n        require(\n\n            balanceAfter >= balanceBefore.add(amountOutMin),\n\n            \"DMMRouter: INSUFFICIENT_OUTPUT_AMOUNT\"\n\n        );\n\n    }","contract":"DMMRouter02","time":0}]}