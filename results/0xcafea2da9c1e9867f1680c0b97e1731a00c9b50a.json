{"time":1495,"results":[{"type":"constant-restrict-modification  ","before":"address public tokenAddress;","after":"address public constant tokenAddress;","contract":"INXMMaster","time":0},{"type":"constant-restrict-modification  ","before":"address public owner;","after":"address public constant owner;","contract":"INXMMaster","time":0},{"type":"constant-restrict-modification  ","before":"uint public pauseTime;","after":"uint public constant pauseTime;","contract":"INXMMaster","time":0},{"type":"struct-data-arrangement ","before":"\naddress payable memberAddress\nbytes4 currencyCode\nuint sumAssured\nuint16 coverPeriod\nuint validUntil\naddress scAddress\nuint premiumNXM","after":"uint sumAssured\nuint validUntil\nuint premiumNXM\naddress payable memberAddress\naddress scAddress\nbytes4 currencyCode\nuint16 coverPeriod\n","contract":"QuotationData","time":1},{"type":"struct-data-arrangement ","before":"\nuint holdCoverId\naddress payable userAddress\naddress scAddress\nbytes4 coverCurr\nuint[] coverDetails\nuint16 coverPeriod","after":"uint holdCoverId\nuint[] coverDetails\naddress payable userAddress\naddress scAddress\nbytes4 coverCurr\nuint16 coverPeriod\n","contract":"QuotationData","time":0},{"type":"constant-restrict-modification  ","before":"string public name = \"NXM\";","after":"string public constant name = \"NXM\";","contract":"NXMToken","time":1},{"type":"constant-restrict-modification  ","before":"string public symbol = \"NXM\";","after":"string public constant symbol = \"NXM\";","contract":"NXMToken","time":1},{"type":"constant-restrict-modification  ","before":"uint8 public decimals = 18;","after":"uint8 public constant decimals = 18;","contract":"NXMToken","time":1},{"type":"state-data-arrangement ","before":"\nbool public constructorCheck;\nMemberRoles internal mr;\nCategoryStruct[] internal allCategory;\nmapping(uint => CategoryAction) internal categoryActionData;\nmapping(uint => uint) public categoryABReq;\nmapping(uint => uint) public isSpecialResolution;\nmapping(uint => bytes) public categoryActionHashes;\nbool public categoryActionHashUpdated;","after":"MemberRoles internal mr;\nCategoryStruct[] internal allCategory;\nmapping(uint => CategoryAction) internal categoryActionData;\nmapping(uint => uint) public categoryABReq;\nmapping(uint => uint) public isSpecialResolution;\nmapping(uint => bytes) public categoryActionHashes;\nbool public constructorCheck;\nbool public categoryActionHashUpdated;\n","contract":"ProposalCategory","time":0},{"type":"external-function ","before":"function newCategory(\n\n        string memory _name,\n\n        uint _memberRoleToVote,\n\n        uint _majorityVotePerc,\n\n        uint _quorumPerc,\n\n        uint[] memory _allowedToCreateProposal,\n\n        uint _closingTime,\n\n        string memory _actionHash,\n\n        address _contractAddress,\n\n        bytes2 _contractName,\n\n        uint[] memory _incentives,\n\n        string memory _functionHash\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern\n\n    {\n\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n\n        //If category is special resolution role authorized should be member\n\n        if (_incentives[3] == 1) {\n\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n\n            _majorityVotePerc = 0;\n\n            _quorumPerc = 0;\n\n        }\n\n\n        _addCategory(\n\n            _name,\n\n            _memberRoleToVote,\n\n            _majorityVotePerc,\n\n            _quorumPerc,\n\n            _allowedToCreateProposal,\n\n            _closingTime,\n\n            _actionHash,\n\n            _contractAddress,\n\n            _contractName,\n\n            _incentives\n\n        );\n\n\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n\n            categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);\n\n        }\n\n    }","after":"function newCategory(\n\n        string calldata _name,\n\n        uint _memberRoleToVote,\n\n        uint _majorityVotePerc,\n\n        uint _quorumPerc,\n\n        uint[] calldata _allowedToCreateProposal,\n\n        uint _closingTime,\n\n        string calldata _actionHash,\n\n        address _contractAddress,\n\n        bytes2 _contractName,\n\n        uint[] calldata _incentives,\n\n        string calldata _functionHash\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern\n\n    {\n\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n\n        //If category is special resolution role authorized should be member\n\n        if (_incentives[3] == 1) {\n\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n\n            _majorityVotePerc = 0;\n\n            _quorumPerc = 0;\n\n        }\n\n\n        _addCategory(\n\n            _name,\n\n            _memberRoleToVote,\n\n            _majorityVotePerc,\n\n            _quorumPerc,\n\n            _allowedToCreateProposal,\n\n            _closingTime,\n\n            _actionHash,\n\n            _contractAddress,\n\n            _contractName,\n\n            _incentives\n\n        );\n\n\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n\n            categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);\n\n        }\n\n    }","contract":"ProposalCategory","time":0},{"type":"external-function ","before":"function editCategory(\n\n        uint _categoryId,\n\n        string memory _name,\n\n        uint _memberRoleToVote,\n\n        uint _majorityVotePerc,\n\n        uint _quorumPerc,\n\n        uint[] memory _allowedToCreateProposal,\n\n        uint _closingTime,\n\n        string memory _actionHash,\n\n        address _contractAddress,\n\n        bytes2 _contractName,\n\n        uint[] memory _incentives,\n\n        string memory _functionHash\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern\n\n    {\n\n        require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\n\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n\n        //If category is special resolution role authorized should be member\n\n        if (_incentives[3] == 1) {\n\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n\n            _majorityVotePerc = 0;\n\n            _quorumPerc = 0;\n\n        }\n\n\n        delete categoryActionHashes[_categoryId];\n\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n\n            categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\n\n        }\n\n        allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\n\n        allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\n\n        allCategory[_categoryId].closingTime = _closingTime;\n\n        allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\n\n        allCategory[_categoryId].minStake = _incentives[0];\n\n        allCategory[_categoryId].quorumPerc = _quorumPerc;\n\n        categoryActionData[_categoryId].defaultIncentive = _incentives[1];\n\n        categoryActionData[_categoryId].contractName = _contractName;\n\n        categoryActionData[_categoryId].contractAddress = _contractAddress;\n\n        categoryABReq[_categoryId] = _incentives[2];\n\n        isSpecialResolution[_categoryId] = _incentives[3];\n\n        emit Category(_categoryId, _name, _actionHash);\n\n    }","after":"function editCategory(\n\n        uint _categoryId,\n\n        string calldata _name,\n\n        uint _memberRoleToVote,\n\n        uint _majorityVotePerc,\n\n        uint _quorumPerc,\n\n        uint[] calldata _allowedToCreateProposal,\n\n        uint _closingTime,\n\n        string calldata _actionHash,\n\n        address _contractAddress,\n\n        bytes2 _contractName,\n\n        uint[] calldata _incentives,\n\n        string calldata _functionHash\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern\n\n    {\n\n        require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\n\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n\n        //If category is special resolution role authorized should be member\n\n        if (_incentives[3] == 1) {\n\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n\n            _majorityVotePerc = 0;\n\n            _quorumPerc = 0;\n\n        }\n\n\n        delete categoryActionHashes[_categoryId];\n\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n\n            categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\n\n        }\n\n        allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\n\n        allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\n\n        allCategory[_categoryId].closingTime = _closingTime;\n\n        allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\n\n        allCategory[_categoryId].minStake = _incentives[0];\n\n        allCategory[_categoryId].quorumPerc = _quorumPerc;\n\n        categoryActionData[_categoryId].defaultIncentive = _incentives[1];\n\n        categoryActionData[_categoryId].contractName = _contractName;\n\n        categoryActionData[_categoryId].contractAddress = _contractAddress;\n\n        categoryABReq[_categoryId] = _incentives[2];\n\n        isSpecialResolution[_categoryId] = _incentives[3];\n\n        emit Category(_categoryId, _name, _actionHash);\n\n    }","contract":"ProposalCategory","time":0},{"type":"constant-restrict-modification  ","before":"bool public constructorCheck;","after":"bool public constant constructorCheck;","contract":"ProposalCategory","time":0},{"type":"state-data-arrangement ","before":"\nProposalVote[] internal allVotes;\nDelegateVote[] public allDelegation;\nmapping(uint => ProposalData) internal allProposalData;\nmapping(uint => bytes[]) internal allProposalSolutions;\nmapping(address => uint[]) internal allVotesByMember;\nmapping(uint => mapping(address => bool)) public rewardClaimed;\nmapping(address => mapping(uint => uint)) public memberProposalVote;\nmapping(address => uint) public followerDelegation;\nmapping(address => uint) internal followerCount;\nmapping(address => uint[]) internal leaderDelegation;\nmapping(uint => VoteTally) public proposalVoteTally;\nmapping(address => bool) public isOpenForDelegation;\nmapping(address => uint) public lastRewardClaimed;\nbool internal constructorCheck;\nuint public tokenHoldingTime;\nuint internal roleIdAllowedToCatgorize;\nuint internal maxVoteWeigthPer;\nuint internal specialResolutionMajPerc;\nuint internal maxFollowers;\nuint internal totalProposals;\nuint internal maxDraftTime;\nMemberRoles internal memberRole;\nProposalCategory internal proposalCategory;\nTokenController internal tokenInstance;\nmapping(uint => uint) public proposalActionStatus;\nmapping(uint => uint) internal proposalExecutionTime;\nmapping(uint => mapping(address => bool)) public proposalRejectedByAB;\nmapping(uint => uint) internal actionRejectedCount;\nbool internal actionParamsInitialised;\nuint internal actionWaitingTime;\nuint constant internal AB_MAJ_TO_REJECT_ACTION = 3;","after":"ProposalVote[] internal allVotes;\nDelegateVote[] public allDelegation;\nmapping(uint => ProposalData) internal allProposalData;\nmapping(uint => bytes[]) internal allProposalSolutions;\nmapping(address => uint[]) internal allVotesByMember;\nmapping(uint => mapping(address => bool)) public rewardClaimed;\nmapping(address => mapping(uint => uint)) public memberProposalVote;\nmapping(address => uint) public followerDelegation;\nmapping(address => uint) internal followerCount;\nmapping(address => uint[]) internal leaderDelegation;\nmapping(uint => VoteTally) public proposalVoteTally;\nmapping(address => bool) public isOpenForDelegation;\nmapping(address => uint) public lastRewardClaimed;\nuint public tokenHoldingTime;\nuint internal roleIdAllowedToCatgorize;\nuint internal maxVoteWeigthPer;\nuint internal specialResolutionMajPerc;\nuint internal maxFollowers;\nuint internal totalProposals;\nuint internal maxDraftTime;\nMemberRoles internal memberRole;\nProposalCategory internal proposalCategory;\nTokenController internal tokenInstance;\nmapping(uint => uint) public proposalActionStatus;\nmapping(uint => uint) internal proposalExecutionTime;\nmapping(uint => mapping(address => bool)) public proposalRejectedByAB;\nmapping(uint => uint) internal actionRejectedCount;\nuint internal actionWaitingTime;\nuint constant internal AB_MAJ_TO_REJECT_ACTION = 3;\nbool internal constructorCheck;\nbool internal actionParamsInitialised;\n","contract":"Governance","time":1},{"type":"constant-restrict-modification  ","before":"bool internal constructorCheck;","after":"bool internal constant constructorCheck;","contract":"Governance","time":1},{"type":"constant-restrict-modification  ","before":"uint internal roleIdAllowedToCatgorize;","after":"uint internal constant roleIdAllowedToCatgorize;","contract":"Governance","time":1},{"type":"constant-restrict-modification  ","before":"uint internal maxVoteWeigthPer;","after":"uint internal constant maxVoteWeigthPer;","contract":"Governance","time":1},{"type":"constant-restrict-modification  ","before":"uint internal specialResolutionMajPerc;","after":"uint internal constant specialResolutionMajPerc;","contract":"Governance","time":1},{"type":"struct-data-arrangement ","before":"\naddress voter\nuint tokens\nuint claimId\nint8 verdict\nbool rewardClaimed","after":"uint tokens\nuint claimId\naddress voter\nint8 verdict\nbool rewardClaimed\n","contract":"ClaimsData","time":0},{"type":"loop-calculation","before":"uint pendingTime;","after":"// move outside for loop\nuint pendingTime;","loc":{"start":{"line":13203,"column":12},"end":{"line":13203,"column":28}},"contract":"Claims","time":0},{"type":"loop-duplication","before":"\nstart line 14283 column 8, end line 14324 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n\n            voteid = cd.getVoteAddressCA(msg.sender, i);\n\n            (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\n\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n\n                lastClaimed = i;\n\n            }\n\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n\n            if (perc > 0 && !claimed) {\n\n                counter++;\n\n                cd.setRewardClaimed(voteid, true);\n\n            } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\n\n                (perc,,) = cd.getClaimRewardDetail(claimId);\n\n                if (perc == 0) {\n\n                    counter++;\n\n                }\n\n                cd.setRewardClaimed(voteid, true);\n\n            }\n\n            if (tokenForVoteId > 0) {\n\n                total = tokenForVoteId.add(total);\n\n            }\n\n        }\nstart line 14356 column 8, end line 14384 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n\n            voteid = cd.getVoteAddressMember(msg.sender, i);\n\n            (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\n\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n\n                lastClaimed = i;\n\n            }\n\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n            if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\n\n                cd.setRewardClaimed(voteid, true);\n\n                counter++;\n\n            }\n\n            if (tokenForVoteId > 0) {\n\n                total = tokenForVoteId.add(total);\n\n            }\n\n        }","after":"// merge loop\n\nstart line 14283 column 8, end line 14324 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n\n            voteid = cd.getVoteAddressCA(msg.sender, i);\n\n            (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\n\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n\n                lastClaimed = i;\n\n            }\n\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n\n            if (perc > 0 && !claimed) {\n\n                counter++;\n\n                cd.setRewardClaimed(voteid, true);\n\n            } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\n\n                (perc,,) = cd.getClaimRewardDetail(claimId);\n\n                if (perc == 0) {\n\n                    counter++;\n\n                }\n\n                cd.setRewardClaimed(voteid, true);\n\n            }\n\n            if (tokenForVoteId > 0) {\n\n                total = tokenForVoteId.add(total);\n\n            }\n\n        }\nstart line 14356 column 8, end line 14384 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n\n            voteid = cd.getVoteAddressMember(msg.sender, i);\n\n            (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\n\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n\n                lastClaimed = i;\n\n            }\n\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n            if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\n\n                cd.setRewardClaimed(voteid, true);\n\n                counter++;\n\n            }\n\n            if (tokenForVoteId > 0) {\n\n                total = tokenForVoteId.add(total);\n\n            }\n\n        }","contract":"ClaimsReward","time":0},{"type":"immutable-restrict-modification ","before":"address public DAI;","after":"address public immutable DAI;","contract":"ClaimsReward","time":0},{"type":"state-data-arrangement ","before":"\nTokenController public dAppToken;\nTokenData internal td;\nQuotationData internal qd;\nClaimsReward internal cr;\nGovernance internal gv;\nTokenFunctions internal tf;\nNXMToken public tk;\nMemberRoleDetails[] internal memberRoleData;\nbool internal constructorCheck;\nuint public maxABCount;\nbool public launched;\nuint public launchedOn;\nmapping(address => address payable) internal claimPayoutAddress;","after":"TokenController public dAppToken;\nTokenData internal td;\nQuotationData internal qd;\nClaimsReward internal cr;\nGovernance internal gv;\nTokenFunctions internal tf;\nNXMToken public tk;\nMemberRoleDetails[] internal memberRoleData;\nuint public maxABCount;\nuint public launchedOn;\nmapping(address => address payable) internal claimPayoutAddress;\nbool internal constructorCheck;\nbool public launched;\n","contract":"MemberRoles","time":0},{"type":"external-function ","before":"function addRole(//solhint-disable-line\n\n        bytes32 _roleName,\n\n        string memory _roleDescription,\n\n        address _authorized\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern {\n\n        _addRole(_roleName, _roleDescription, _authorized);\n\n    }","after":"function addRole(//solhint-disable-line\n\n        bytes32 _roleName,\n\n        string calldata _roleDescription,\n\n        address _authorized\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern {\n\n        _addRole(_roleName, _roleDescription, _authorized);\n\n    }","contract":"MemberRoles","time":0},{"type":"external-function ","before":"function addMembersBeforeLaunch(address[] memory userArray, uint[] memory tokens) public onlyOwner {\n\n        require(!launched);\n\n\n        for (uint i = 0; i < userArray.length; i++) {\n\n            require(!ms.isMember(userArray[i]));\n\n            dAppToken.addToWhitelist(userArray[i]);\n\n            _updateRole(userArray[i], uint(Role.Member), true);\n\n            dAppToken.mint(userArray[i], tokens[i]);\n\n        }\n\n        launched = true;\n\n        launchedOn = now;\n\n\n    }","after":"function addMembersBeforeLaunch(address[] calldata userArray, uint[] calldata tokens) public onlyOwner {\n\n        require(!launched);\n\n\n        for (uint i = 0; i < userArray.length; i++) {\n\n            require(!ms.isMember(userArray[i]));\n\n            dAppToken.addToWhitelist(userArray[i]);\n\n            _updateRole(userArray[i], uint(Role.Member), true);\n\n            dAppToken.mint(userArray[i], tokens[i]);\n\n        }\n\n        launched = true;\n\n        launchedOn = now;\n\n\n    }","contract":"MemberRoles","time":0},{"type":"immutable-restrict-modification ","before":"address public daiAddress;","after":"address public immutable daiAddress;","contract":"PriceFeedOracle","time":0},{"type":"state-data-arrangement ","before":"\nIARankDetails[] internal allIARankDetails;\nMcrData[] public allMCRData;\nbytes4[] internal allInvestmentCurrencies;\nbytes4[] internal allCurrencies;\nbytes32[] public allAPIcall;\nmapping(bytes32 => ApiId) public allAPIid;\nmapping(uint64 => uint) internal datewiseId;\nmapping(bytes16 => uint) internal currencyLastIndex;\nmapping(bytes4 => CurrencyAssets) internal allCurrencyAssets;\nmapping(bytes4 => InvestmentAssets) internal allInvestmentAssets;\nmapping(bytes4 => uint) internal caAvgRate;\nmapping(bytes4 => uint) internal iaAvgRate;\naddress public notariseMCR;\naddress public daiFeedAddress;\nuint private constant DECIMAL1E18 = uint(10) ** 18;\nuint public uniswapDeadline;\nuint public liquidityTradeCallbackTime;\nuint public lastLiquidityTradeTrigger;\nuint64 internal lastDate;\nuint public variationPercX100;\nuint public iaRatesTime;\nuint public minCap;\nuint public mcrTime;\nuint public a;\nuint public shockParameter;\nuint public c;\nuint public mcrFailTime;\nuint public ethVolumeLimit;\nuint public capReached;\nuint public capacityLimit;","after":"IARankDetails[] internal allIARankDetails;\nMcrData[] public allMCRData;\nbytes4[] internal allInvestmentCurrencies;\nbytes4[] internal allCurrencies;\nbytes32[] public allAPIcall;\nmapping(bytes32 => ApiId) public allAPIid;\nmapping(uint64 => uint) internal datewiseId;\nmapping(bytes16 => uint) internal currencyLastIndex;\nmapping(bytes4 => CurrencyAssets) internal allCurrencyAssets;\nmapping(bytes4 => InvestmentAssets) internal allInvestmentAssets;\nmapping(bytes4 => uint) internal caAvgRate;\nmapping(bytes4 => uint) internal iaAvgRate;\nuint private constant DECIMAL1E18 = uint(10) ** 18;\nuint public uniswapDeadline;\nuint public liquidityTradeCallbackTime;\nuint public lastLiquidityTradeTrigger;\nuint public variationPercX100;\nuint public iaRatesTime;\nuint public minCap;\nuint public mcrTime;\nuint public a;\nuint public shockParameter;\nuint public c;\nuint public mcrFailTime;\nuint public ethVolumeLimit;\nuint public capReached;\nuint public capacityLimit;\naddress public notariseMCR;\naddress public daiFeedAddress;\nuint64 internal lastDate;\n","contract":"PoolData","time":1},{"type":"struct-data-arrangement ","before":"\nbytes4 typeOf\nbytes4 currency\nuint id\nuint64 dateAdd\nuint64 dateUpd","after":"uint id\nuint64 dateAdd\nuint64 dateUpd\nbytes4 typeOf\nbytes4 currency\n","contract":"PoolData","time":0},{"type":"external-function ","before":"function makeCoverUsingNXMTokens(\n\n        uint[] memory coverDetails,\n\n        uint16 coverPeriod,\n\n        bytes4 coverCurr,\n\n        address smartCAdd,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    isMemberAndcheckPause\n\n    {\n\n\n        tc.burnFrom(msg.sender, coverDetails[2]);\n        // need burn allowance\n\n        _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s, true);\n\n    }","after":"function makeCoverUsingNXMTokens(\n\n        uint[] calldata coverDetails,\n\n        uint16 coverPeriod,\n\n        bytes4 coverCurr,\n\n        address smartCAdd,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    isMemberAndcheckPause\n\n    {\n\n\n        tc.burnFrom(msg.sender, coverDetails[2]);\n        // need burn allowance\n\n        _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s, true);\n\n    }","contract":"Quotation","time":0},{"type":"external-function ","before":"function verifyCoverDetails(\n\n        address payable from,\n\n        address scAddress,\n\n        bytes4 coverCurr,\n\n        uint[] memory coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    onlyInternal\n\n    {\n\n        _verifyCoverDetails(\n\n            from,\n\n            scAddress,\n\n            coverCurr,\n\n            coverDetails,\n\n            coverPeriod,\n\n            _v,\n\n            _r,\n\n            _s,\n\n            false\n\n        );\n\n    }","after":"function verifyCoverDetails(\n\n        address payable from,\n\n        address scAddress,\n\n        bytes4 coverCurr,\n\n        uint[] calldata coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    onlyInternal\n\n    {\n\n        _verifyCoverDetails(\n\n            from,\n\n            scAddress,\n\n            coverCurr,\n\n            coverDetails,\n\n            coverPeriod,\n\n            _v,\n\n            _r,\n\n            _s,\n\n            false\n\n        );\n\n    }","contract":"Quotation","time":0},{"type":"loop-calculation","before":"uint index = timestampToIndex(block.timestamp);","after":"// move outside for loop\nuint index = timestampToIndex(block.timestamp);","loc":{"start":{"line":19247,"column":12},"end":{"line":19247,"column":58}},"contract":"TwapOracle","time":0},{"type":"immutable-restrict-modification ","before":"address public factory;","after":"address public immutable factory;","contract":"TwapOracle","time":0},{"type":"external-function ","before":"function makeCoverBegin(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] memory coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    ) public payable onlyMember whenNotPaused {\n\n\n        require(coverCurr == \"ETH\", \"Pool: Unexpected asset type\");\n\n        require(msg.value == coverDetails[1], \"Pool: ETH amount does not match premium\");\n\n\n        quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","after":"function makeCoverBegin(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] calldata coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    ) public payable onlyMember whenNotPaused {\n\n\n        require(coverCurr == \"ETH\", \"Pool: Unexpected asset type\");\n\n        require(msg.value == coverDetails[1], \"Pool: ETH amount does not match premium\");\n\n\n        quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","contract":"Pool","time":0},{"type":"external-function ","before":"function makeCoverUsingCA(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] memory coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    ) public onlyMember whenNotPaused {\n\n        require(coverCurr != \"ETH\", \"Pool: Unexpected asset type\");\n\n        quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","after":"function makeCoverUsingCA(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] calldata coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    ) public onlyMember whenNotPaused {\n\n        require(coverCurr != \"ETH\", \"Pool: Unexpected asset type\");\n\n        quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","contract":"Pool","time":0}]}