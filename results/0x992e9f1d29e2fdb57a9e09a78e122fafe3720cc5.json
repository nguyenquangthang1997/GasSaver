{"time":480,"results":[{"type":"external-function ","before":"function call(\n        address[] memory _targets,\n        bytes[] memory _calldata,\n        uint256[] memory _values\n    ) public override noReentry protectedCall {\n        require(\n            _targets.length == _calldata.length && _values.length == _calldata.length,\n            \"ARRAY_LENGTH_MISMATCH\"\n        );\n\n        for (uint256 i = 0; i < _targets.length; i++) {\n            _call(_targets[i], _calldata[i], _values[i]);\n        }\n    }","after":"function call(\n        address[] calldata _targets,\n        bytes[] calldata _calldata,\n        uint256[] calldata _values\n    ) public override noReentry protectedCall {\n        require(\n            _targets.length == _calldata.length && _values.length == _calldata.length,\n            \"ARRAY_LENGTH_MISMATCH\"\n        );\n\n        for (uint256 i = 0; i < _targets.length; i++) {\n            _call(_targets[i], _calldata[i], _values[i]);\n        }\n    }","contract":"CallFacet","time":0},{"type":"external-function ","before":"function callNoValue(\n        address[] memory _targets,\n        bytes[] memory _calldata\n    ) public override noReentry protectedCall {\n        require(\n            _targets.length == _calldata.length,\n            \"ARRAY_LENGTH_MISMATCH\"\n        );\n\n        for (uint256 i = 0; i < _targets.length; i++) {\n            _call(_targets[i], _calldata[i], 0);\n        }\n    }","after":"function callNoValue(\n        address[] calldata _targets,\n        bytes[] calldata _calldata\n    ) public override noReentry protectedCall {\n        require(\n            _targets.length == _calldata.length,\n            \"ARRAY_LENGTH_MISMATCH\"\n        );\n\n        for (uint256 i = 0; i < _targets.length; i++) {\n            _call(_targets[i], _calldata[i], 0);\n        }\n    }","contract":"CallFacet","time":0},{"type":"external-function ","before":"function deployNewDiamond(\n        address _owner,\n        IDiamondCut.FacetCut[] memory _diamondCut\n    ) public returns (address) {\n        Diamond d = new Diamond(_diamondCut, _owner);\n\n        diamonds.push(address(d));\n        isDiamond[address(d)] = true;\n\n        emit DiamondCreated(address(d));\n    }","after":"function deployNewDiamond(\n        address _owner,\n        IDiamondCut.FacetCut[] calldata _diamondCut\n    ) public returns (address) {\n        Diamond d = new Diamond(_diamondCut, _owner);\n\n        diamonds.push(address(d));\n        isDiamond[address(d)] = true;\n\n        emit DiamondCreated(address(d));\n    }","contract":"DiamondFactoryContract","time":0},{"type":"loop-calculation","before":"address facetAddress_ = address(bytes20(ds.facets[selector]));","after":"// move outside for loop\naddress facetAddress_ = address(bytes20(ds.facets[selector]));","loc":{"start":{"line":863,"column":16},"end":{"line":863,"column":77}},"contract":"DiamondLoupeFacet","time":0},{"type":"loop-calculation","before":"address facet = address(bytes20(ds.facets[selector]));","after":"// move outside for loop\naddress facet = address(bytes20(ds.facets[selector]));","loc":{"start":{"line":971,"column":16},"end":{"line":971,"column":69}},"contract":"DiamondLoupeFacet","time":0},{"type":"loop-calculation","before":"address facetAddress_ = address(bytes20(ds.facets[selector]));","after":"// move outside for loop\naddress facetAddress_ = address(bytes20(ds.facets[selector]));","loc":{"start":{"line":1029,"column":16},"end":{"line":1029,"column":77}},"contract":"DiamondLoupeFacet","time":0},{"type":"external-function ","before":"function initialize(\n        uint256 _initialSupply,\n        string memory _name,\n        string memory _symbol\n    ) external override {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n        require(msg.sender == ds.contractOwner, \"Must own the contract.\");\n\n        LibERC20.mint(msg.sender, _initialSupply);\n\n        es.name = _name;\n        es.symbol = _symbol;\n    }","after":"function initialize(\n        uint256 _initialSupply,\n        string calldata _name,\n        string calldata _symbol\n    ) external override {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        LibERC20Storage.ERC20Storage storage es = LibERC20Storage.erc20Storage();\n\n        require(msg.sender == ds.contractOwner, \"Must own the contract.\");\n\n        LibERC20.mint(msg.sender, _initialSupply);\n\n        es.name = _name;\n        es.symbol = _symbol;\n    }","contract":"ERC20Facet","time":0},{"type":"external-function ","before":"function deployNewToken(\n        string memory _name,\n        string memory _symbol,\n        uint256 _totalSupply,\n        address _issuer\n    ) public returns (address) {\n        MockToken t = new MockToken(_name, _symbol);\n        t.mint(_totalSupply, _issuer);\n        emit TokenCreated(address(t));\n    }","after":"function deployNewToken(\n        string calldata _name,\n        string calldata _symbol,\n        uint256 _totalSupply,\n        address _issuer\n    ) public returns (address) {\n        MockToken t = new MockToken(_name, _symbol);\n        t.mint(_totalSupply, _issuer);\n        emit TokenCreated(address(t));\n    }","contract":"ERC20FactoryContract","time":0},{"type":"immutable-restrict-modification ","before":"uint16 public referralCode;","after":"uint16 public immutable referralCode;","contract":"LendingLogicAave","time":0},{"type":"struct-data-arrangement ","before":"\nmapping(bytes4 => bytes32) facets\nmapping(uint256 => bytes32) selectorSlots\nuint16 selectorCount\nmapping(bytes4 => bool) supportedInterfaces\naddress contractOwner","after":"mapping(bytes4 => bytes32) facets\nmapping(uint256 => bytes32) selectorSlots\nmapping(bytes4 => bool) supportedInterfaces\naddress contractOwner\nuint16 selectorCount\n","contract":"LibDiamond","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"MockAToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"MockAToken","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public exchangeRate = 1 ether / 5;","after":"uint256 public constant exchangeRate = 1 ether / 5;","contract":"MockCToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"MockCToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"MockCToken","time":0},{"type":"external-function ","before":"function addFacet(IDiamondCut.FacetCut memory _facet) external onlyOwner {\n        defaultCut.push(_facet);\n        emit FacetAdded(_facet);\n    }","after":"function addFacet(IDiamondCut.FacetCut calldata _facet) external onlyOwner {\n        defaultCut.push(_facet);\n        emit FacetAdded(_facet);\n    }","contract":"PieFactoryContract","time":0},{"type":"external-function ","before":"function bakePie(\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256 _initialSupply,\n        string memory _symbol,\n        string memory _name\n    ) external {\n        Diamond d = new Diamond(defaultCut, address(this));\n\n        pies.push(address(d));\n        isPie[address(d)] = true;\n\n        // emit DiamondCreated(address(d));\n        require(_tokens.length != 0, \"CANNOT_CREATE_ZERO_TOKEN_LENGTH_PIE\");\n        require(_tokens.length == _amounts.length, \"ARRAY_LENGTH_MISMATCH\");\n\n        IExperiPie pie = IExperiPie(address(d));\n\n        // Init erc20 facet\n        pie.initialize(_initialSupply, _name, _symbol);\n\n        // Transfer and add tokens\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20 token = IERC20(_tokens[i]);\n            token.safeTransferFrom(msg.sender, address(pie), _amounts[i]);\n            pie.addToken(_tokens[i]);\n        }\n\n        // Unlock pool\n        pie.setLock(1);\n\n        // Uncap pool\n        pie.setCap(uint256(- 1));\n\n        // Send minted pie to msg.sender\n        pie.transfer(msg.sender, _initialSupply);\n        pie.transferOwnership(defaultController);\n\n        emit PieCreated(address(d), msg.sender, pies.length - 1);\n    }","after":"function bakePie(\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        uint256 _initialSupply,\n        string calldata _symbol,\n        string calldata _name\n    ) external {\n        Diamond d = new Diamond(defaultCut, address(this));\n\n        pies.push(address(d));\n        isPie[address(d)] = true;\n\n        // emit DiamondCreated(address(d));\n        require(_tokens.length != 0, \"CANNOT_CREATE_ZERO_TOKEN_LENGTH_PIE\");\n        require(_tokens.length == _amounts.length, \"ARRAY_LENGTH_MISMATCH\");\n\n        IExperiPie pie = IExperiPie(address(d));\n\n        // Init erc20 facet\n        pie.initialize(_initialSupply, _name, _symbol);\n\n        // Transfer and add tokens\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            IERC20 token = IERC20(_tokens[i]);\n            token.safeTransferFrom(msg.sender, address(pie), _amounts[i]);\n            pie.addToken(_tokens[i]);\n        }\n\n        // Unlock pool\n        pie.setLock(1);\n\n        // Uncap pool\n        pie.setCap(uint256(- 1));\n\n        // Send minted pie to msg.sender\n        pie.transfer(msg.sender, _initialSupply);\n        pie.transferOwnership(defaultController);\n\n        emit PieCreated(address(d), msg.sender, pies.length - 1);\n    }","contract":"PieFactoryContract","time":0},{"type":"struct-data-arrangement ","before":"\nuint80 roundId\nint256 answer\nuint256 startedAt\nuint256 updatedAt\nuint80 answeredInRound","after":"int256 answer\nuint256 startedAt\nuint256 updatedAt\nuint80 roundId\nuint80 answeredInRound\n","contract":"RSISynthetixManager","time":0}]}