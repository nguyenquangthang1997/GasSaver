{"time":324,"results":[{"type":"loop-calculation","before":"uint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);","after":"// move outside for loop\nuint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);","loc":{"start":{"line":3001,"column":0},"end":{"line":3001,"column":110}},"contract":"MixinWrapperFunctions","time":0},{"type":"loop-calculation","before":"uint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);","after":"// move outside for loop\nuint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);","loc":{"start":{"line":3045,"column":0},"end":{"line":3045,"column":110}},"contract":"MixinWrapperFunctions","time":0},{"type":"loop-calculation","before":"uint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);","after":"// move outside for loop\nuint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);","loc":{"start":{"line":3089,"column":0},"end":{"line":3089,"column":110}},"contract":"MixinWrapperFunctions","time":0},{"type":"loop-calculation","before":"uint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);","after":"// move outside for loop\nuint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);","loc":{"start":{"line":3141,"column":0},"end":{"line":3141,"column":110}},"contract":"MixinWrapperFunctions","time":0},{"type":"external-function ","before":"function fillOrder(\n        Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n    public\n    nonReentrant\n    returns (FillResults memory fillResults)\n    {\n        fillResults = fillOrderInternal(\n            order,\n            takerAssetFillAmount,\n            signature\n        );\n        return fillResults;\n    }","after":"function fillOrder(\n        Order calldata order,\n        uint256 takerAssetFillAmount,\n        bytes calldata signature\n    )\n    public\n    nonReentrant\n    returns (FillResults memory fillResults)\n    {\n        fillResults = fillOrderInternal(\n            order,\n            takerAssetFillAmount,\n            signature\n        );\n        return fillResults;\n    }","contract":"Exchange","time":0},{"type":"external-function ","before":"function cancelOrder(Order memory order)\n    public\n    nonReentrant\n    {\n        cancelOrderInternal(order);\n    }","after":"function cancelOrder(Order calldata order)\n    public\n    nonReentrant\n    {\n        cancelOrderInternal(order);\n    }","contract":"Exchange","time":0},{"type":"external-function ","before":"function matchOrders(\nLibOrder.Order memory leftOrder,\nLibOrder.Order memory rightOrder,\nbytes memory leftSignature,\nbytes memory rightSignature\n)\npublic\nnonReentrant\nreturns (LibFillResults.MatchedFillResults memory matchedFillResults)\n{\n// We assume that rightOrder.takerAssetData == leftOrder.makerAssetData and rightOrder.makerAssetData == leftOrder.takerAssetData.\n// If this assumption isn't true, the match will fail at signature validation.\nrightOrder.makerAssetData = leftOrder.takerAssetData;\nrightOrder.takerAssetData = leftOrder.makerAssetData;\n\n// Get left & right order info\nLibOrder.OrderInfo memory leftOrderInfo = getOrderInfo(leftOrder);\nLibOrder.OrderInfo memory rightOrderInfo = getOrderInfo(rightOrder);\n\n// Fetch taker address\naddress takerAddress = getCurrentContextAddress();\n\n// Either our context is valid or we revert\nassertFillableOrder(\nleftOrder,\nleftOrderInfo,\ntakerAddress,\nleftSignature\n);\nassertFillableOrder(\nrightOrder,\nrightOrderInfo,\ntakerAddress,\nrightSignature\n);\nassertValidMatch(leftOrder, rightOrder);\n\n// Compute proportional fill amounts\nmatchedFillResults = calculateMatchedFillResults(\nleftOrder,\nrightOrder,\nleftOrderInfo.orderTakerAssetFilledAmount,\nrightOrderInfo.orderTakerAssetFilledAmount\n);\n\n// Validate fill contexts\nassertValidFill(\nleftOrder,\nleftOrderInfo,\nmatchedFillResults.left.takerAssetFilledAmount,\nmatchedFillResults.left.takerAssetFilledAmount,\nmatchedFillResults.left.makerAssetFilledAmount\n);\nassertValidFill(\nrightOrder,\nrightOrderInfo,\nmatchedFillResults.right.takerAssetFilledAmount,\nmatchedFillResults.right.takerAssetFilledAmount,\nmatchedFillResults.right.makerAssetFilledAmount\n);\n\n// Update exchange state\nupdateFilledState(\nleftOrder,\ntakerAddress,\nleftOrderInfo.orderHash,\nleftOrderInfo.orderTakerAssetFilledAmount,\nmatchedFillResults.left\n);\nupdateFilledState(\nrightOrder,\ntakerAddress,\nrightOrderInfo.orderHash,\nrightOrderInfo.orderTakerAssetFilledAmount,\nmatchedFillResults.right\n);\n\n// Settle matched orders. Succeeds or throws.\nsettleMatchedOrders(\nleftOrder,\nrightOrder,\ntakerAddress,\nmatchedFillResults\n);\n\nreturn matchedFillResults;\n}","after":"function matchOrders(\nLibOrder.Order calldata leftOrder,\nLibOrder.Order calldata rightOrder,\nbytes calldata leftSignature,\nbytes memory rightSignature\n)\npublic\nnonReentrant\nreturns (LibFillResults.MatchedFillResults memory matchedFillResults)\n{\n// We assume that rightOrder.takerAssetData == leftOrder.makerAssetData and rightOrder.makerAssetData == leftOrder.takerAssetData.\n// If this assumption isn't true, the match will fail at signature validation.\nrightOrder.makerAssetData = leftOrder.takerAssetData;\nrightOrder.takerAssetData = leftOrder.makerAssetData;\n\n// Get left & right order info\nLibOrder.OrderInfo memory leftOrderInfo = getOrderInfo(leftOrder);\nLibOrder.OrderInfo memory rightOrderInfo = getOrderInfo(rightOrder);\n\n// Fetch taker address\naddress takerAddress = getCurrentContextAddress();\n\n// Either our context is valid or we revert\nassertFillableOrder(\nleftOrder,\nleftOrderInfo,\ntakerAddress,\nleftSignature\n);\nassertFillableOrder(\nrightOrder,\nrightOrderInfo,\ntakerAddress,\nrightSignature\n);\nassertValidMatch(leftOrder, rightOrder);\n\n// Compute proportional fill amounts\nmatchedFillResults = calculateMatchedFillResults(\nleftOrder,\nrightOrder,\nleftOrderInfo.orderTakerAssetFilledAmount,\nrightOrderInfo.orderTakerAssetFilledAmount\n);\n\n// Validate fill contexts\nassertValidFill(\nleftOrder,\nleftOrderInfo,\nmatchedFillResults.left.takerAssetFilledAmount,\nmatchedFillResults.left.takerAssetFilledAmount,\nmatchedFillResults.left.makerAssetFilledAmount\n);\nassertValidFill(\nrightOrder,\nrightOrderInfo,\nmatchedFillResults.right.takerAssetFilledAmount,\nmatchedFillResults.right.takerAssetFilledAmount,\nmatchedFillResults.right.makerAssetFilledAmount\n);\n\n// Update exchange state\nupdateFilledState(\nleftOrder,\ntakerAddress,\nleftOrderInfo.orderHash,\nleftOrderInfo.orderTakerAssetFilledAmount,\nmatchedFillResults.left\n);\nupdateFilledState(\nrightOrder,\ntakerAddress,\nrightOrderInfo.orderHash,\nrightOrderInfo.orderTakerAssetFilledAmount,\nmatchedFillResults.right\n);\n\n// Settle matched orders. Succeeds or throws.\nsettleMatchedOrders(\nleftOrder,\nrightOrder,\ntakerAddress,\nmatchedFillResults\n);\n\nreturn matchedFillResults;\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function fillOrKillOrder(\nLibOrder.Order memory order,\nuint256 takerAssetFillAmount,\nbytes memory signature\n)\npublic\nnonReentrant\nreturns (FillResults memory fillResults)\n{\nfillResults = fillOrKillOrderInternal(\norder,\ntakerAssetFillAmount,\nsignature\n);\nreturn fillResults;\n}","after":"function fillOrKillOrder(\nLibOrder.Order calldata order,\nuint256 takerAssetFillAmount,\nbytes calldata signature\n)\npublic\nnonReentrant\nreturns (FillResults memory fillResults)\n{\nfillResults = fillOrKillOrderInternal(\norder,\ntakerAssetFillAmount,\nsignature\n);\nreturn fillResults;\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function batchFillOrders(\nLibOrder.Order[] memory orders,\nuint256[] memory takerAssetFillAmounts,\nbytes[] memory signatures\n)\npublic\nnonReentrant\nreturns (FillResults memory totalFillResults)\n{\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\nFillResults memory singleFillResults = fillOrderInternal(\norders[i],\ntakerAssetFillAmounts[i],\nsignatures[i]\n);\naddFillResults(totalFillResults, singleFillResults);\n}\nreturn totalFillResults;\n}","after":"function batchFillOrders(\nLibOrder.Order[] calldata orders,\nuint256[] calldata takerAssetFillAmounts,\nbytes[] calldata signatures\n)\npublic\nnonReentrant\nreturns (FillResults memory totalFillResults)\n{\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\nFillResults memory singleFillResults = fillOrderInternal(\norders[i],\ntakerAssetFillAmounts[i],\nsignatures[i]\n);\naddFillResults(totalFillResults, singleFillResults);\n}\nreturn totalFillResults;\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function batchFillOrKillOrders(\nLibOrder.Order[] memory orders,\nuint256[] memory takerAssetFillAmounts,\nbytes[] memory signatures\n)\npublic\nnonReentrant\nreturns (FillResults memory totalFillResults)\n{\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\nFillResults memory singleFillResults = fillOrKillOrderInternal(\norders[i],\ntakerAssetFillAmounts[i],\nsignatures[i]\n);\naddFillResults(totalFillResults, singleFillResults);\n}\nreturn totalFillResults;\n}","after":"function batchFillOrKillOrders(\nLibOrder.Order[] calldata orders,\nuint256[] calldata takerAssetFillAmounts,\nbytes[] calldata signatures\n)\npublic\nnonReentrant\nreturns (FillResults memory totalFillResults)\n{\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\nFillResults memory singleFillResults = fillOrKillOrderInternal(\norders[i],\ntakerAssetFillAmounts[i],\nsignatures[i]\n);\naddFillResults(totalFillResults, singleFillResults);\n}\nreturn totalFillResults;\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function batchFillOrdersNoThrow(\nLibOrder.Order[] memory orders,\nuint256[] memory takerAssetFillAmounts,\nbytes[] memory signatures\n)\npublic\nreturns (FillResults memory totalFillResults)\n{\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\nFillResults memory singleFillResults = fillOrderNoThrow(\norders[i],\ntakerAssetFillAmounts[i],\nsignatures[i]\n);\naddFillResults(totalFillResults, singleFillResults);\n}\nreturn totalFillResults;\n}","after":"function batchFillOrdersNoThrow(\nLibOrder.Order[] calldata orders,\nuint256[] calldata takerAssetFillAmounts,\nbytes[] calldata signatures\n)\npublic\nreturns (FillResults memory totalFillResults)\n{\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\nFillResults memory singleFillResults = fillOrderNoThrow(\norders[i],\ntakerAssetFillAmounts[i],\nsignatures[i]\n);\naddFillResults(totalFillResults, singleFillResults);\n}\nreturn totalFillResults;\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function marketSellOrders(\nLibOrder.Order[] memory orders,\nuint256 takerAssetFillAmount,\nbytes[] memory signatures\n)\npublic\nnonReentrant\nreturns (FillResults memory totalFillResults)\n{\nbytes memory takerAssetData = orders[0].takerAssetData;\n\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n// We assume that asset being sold by taker is the same for each order.\n// Rather than passing this in as calldata, we use the takerAssetData from the first order in all later orders.\norders[i].takerAssetData = takerAssetData;\n\n// Calculate the remaining amount of takerAsset to sell\nuint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);\n\n// Attempt to sell the remaining amount of takerAsset\nFillResults memory singleFillResults = fillOrderInternal(\norders[i],\nremainingTakerAssetFillAmount,\nsignatures[i]\n);\n\n// Update amounts filled and fees paid by maker and taker\naddFillResults(totalFillResults, singleFillResults);\n\n// Stop execution if the entire amount of takerAsset has been sold\nif (totalFillResults.takerAssetFilledAmount >= takerAssetFillAmount) {\nbreak;\n}\n}\nreturn totalFillResults;\n}","after":"function marketSellOrders(\nLibOrder.Order[] calldata orders,\nuint256 takerAssetFillAmount,\nbytes[] memory signatures\n)\npublic\nnonReentrant\nreturns (FillResults memory totalFillResults)\n{\nbytes memory takerAssetData = orders[0].takerAssetData;\n\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n// We assume that asset being sold by taker is the same for each order.\n// Rather than passing this in as calldata, we use the takerAssetData from the first order in all later orders.\norders[i].takerAssetData = takerAssetData;\n\n// Calculate the remaining amount of takerAsset to sell\nuint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);\n\n// Attempt to sell the remaining amount of takerAsset\nFillResults memory singleFillResults = fillOrderInternal(\norders[i],\nremainingTakerAssetFillAmount,\nsignatures[i]\n);\n\n// Update amounts filled and fees paid by maker and taker\naddFillResults(totalFillResults, singleFillResults);\n\n// Stop execution if the entire amount of takerAsset has been sold\nif (totalFillResults.takerAssetFilledAmount >= takerAssetFillAmount) {\nbreak;\n}\n}\nreturn totalFillResults;\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function marketSellOrdersNoThrow(\nLibOrder.Order[] memory orders,\nuint256 takerAssetFillAmount,\nbytes[] memory signatures\n)\npublic\nreturns (FillResults memory totalFillResults)\n{\nbytes memory takerAssetData = orders[0].takerAssetData;\n\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n// We assume that asset being sold by taker is the same for each order.\n// Rather than passing this in as calldata, we use the takerAssetData from the first order in all later orders.\norders[i].takerAssetData = takerAssetData;\n\n// Calculate the remaining amount of takerAsset to sell\nuint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);\n\n// Attempt to sell the remaining amount of takerAsset\nFillResults memory singleFillResults = fillOrderNoThrow(\norders[i],\nremainingTakerAssetFillAmount,\nsignatures[i]\n);\n\n// Update amounts filled and fees paid by maker and taker\naddFillResults(totalFillResults, singleFillResults);\n\n// Stop execution if the entire amount of takerAsset has been sold\nif (totalFillResults.takerAssetFilledAmount >= takerAssetFillAmount) {\nbreak;\n}\n}\nreturn totalFillResults;\n}","after":"function marketSellOrdersNoThrow(\nLibOrder.Order[] calldata orders,\nuint256 takerAssetFillAmount,\nbytes[] memory signatures\n)\npublic\nreturns (FillResults memory totalFillResults)\n{\nbytes memory takerAssetData = orders[0].takerAssetData;\n\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n// We assume that asset being sold by taker is the same for each order.\n// Rather than passing this in as calldata, we use the takerAssetData from the first order in all later orders.\norders[i].takerAssetData = takerAssetData;\n\n// Calculate the remaining amount of takerAsset to sell\nuint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);\n\n// Attempt to sell the remaining amount of takerAsset\nFillResults memory singleFillResults = fillOrderNoThrow(\norders[i],\nremainingTakerAssetFillAmount,\nsignatures[i]\n);\n\n// Update amounts filled and fees paid by maker and taker\naddFillResults(totalFillResults, singleFillResults);\n\n// Stop execution if the entire amount of takerAsset has been sold\nif (totalFillResults.takerAssetFilledAmount >= takerAssetFillAmount) {\nbreak;\n}\n}\nreturn totalFillResults;\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function marketBuyOrders(\nLibOrder.Order[] memory orders,\nuint256 makerAssetFillAmount,\nbytes[] memory signatures\n)\npublic\nnonReentrant\nreturns (FillResults memory totalFillResults)\n{\nbytes memory makerAssetData = orders[0].makerAssetData;\n\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n// We assume that asset being bought by taker is the same for each order.\n// Rather than passing this in as calldata, we copy the makerAssetData from the first order onto all later orders.\norders[i].makerAssetData = makerAssetData;\n\n// Calculate the remaining amount of makerAsset to buy\nuint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);\n\n// Convert the remaining amount of makerAsset to buy into remaining amount\n// of takerAsset to sell, assuming entire amount can be sold in the current order\nuint256 remainingTakerAssetFillAmount = getPartialAmountFloor(\norders[i].takerAssetAmount,\norders[i].makerAssetAmount,\nremainingMakerAssetFillAmount\n);\n\n// Attempt to sell the remaining amount of takerAsset\nFillResults memory singleFillResults = fillOrderInternal(\norders[i],\nremainingTakerAssetFillAmount,\nsignatures[i]\n);\n\n// Update amounts filled and fees paid by maker and taker\naddFillResults(totalFillResults, singleFillResults);\n\n// Stop execution if the entire amount of makerAsset has been bought\nif (totalFillResults.makerAssetFilledAmount >= makerAssetFillAmount) {\nbreak;\n}\n}\nreturn totalFillResults;\n}","after":"function marketBuyOrders(\nLibOrder.Order[] calldata orders,\nuint256 makerAssetFillAmount,\nbytes[] memory signatures\n)\npublic\nnonReentrant\nreturns (FillResults memory totalFillResults)\n{\nbytes memory makerAssetData = orders[0].makerAssetData;\n\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n// We assume that asset being bought by taker is the same for each order.\n// Rather than passing this in as calldata, we copy the makerAssetData from the first order onto all later orders.\norders[i].makerAssetData = makerAssetData;\n\n// Calculate the remaining amount of makerAsset to buy\nuint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);\n\n// Convert the remaining amount of makerAsset to buy into remaining amount\n// of takerAsset to sell, assuming entire amount can be sold in the current order\nuint256 remainingTakerAssetFillAmount = getPartialAmountFloor(\norders[i].takerAssetAmount,\norders[i].makerAssetAmount,\nremainingMakerAssetFillAmount\n);\n\n// Attempt to sell the remaining amount of takerAsset\nFillResults memory singleFillResults = fillOrderInternal(\norders[i],\nremainingTakerAssetFillAmount,\nsignatures[i]\n);\n\n// Update amounts filled and fees paid by maker and taker\naddFillResults(totalFillResults, singleFillResults);\n\n// Stop execution if the entire amount of makerAsset has been bought\nif (totalFillResults.makerAssetFilledAmount >= makerAssetFillAmount) {\nbreak;\n}\n}\nreturn totalFillResults;\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function marketBuyOrdersNoThrow(\nLibOrder.Order[] memory orders,\nuint256 makerAssetFillAmount,\nbytes[] memory signatures\n)\npublic\nreturns (FillResults memory totalFillResults)\n{\nbytes memory makerAssetData = orders[0].makerAssetData;\n\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n// We assume that asset being bought by taker is the same for each order.\n// Rather than passing this in as calldata, we copy the makerAssetData from the first order onto all later orders.\norders[i].makerAssetData = makerAssetData;\n\n// Calculate the remaining amount of makerAsset to buy\nuint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);\n\n// Convert the remaining amount of makerAsset to buy into remaining amount\n// of takerAsset to sell, assuming entire amount can be sold in the current order\nuint256 remainingTakerAssetFillAmount = getPartialAmountFloor(\norders[i].takerAssetAmount,\norders[i].makerAssetAmount,\nremainingMakerAssetFillAmount\n);\n\n// Attempt to sell the remaining amount of takerAsset\nFillResults memory singleFillResults = fillOrderNoThrow(\norders[i],\nremainingTakerAssetFillAmount,\nsignatures[i]\n);\n\n// Update amounts filled and fees paid by maker and taker\naddFillResults(totalFillResults, singleFillResults);\n\n// Stop execution if the entire amount of makerAsset has been bought\nif (totalFillResults.makerAssetFilledAmount >= makerAssetFillAmount) {\nbreak;\n}\n}\nreturn totalFillResults;\n}","after":"function marketBuyOrdersNoThrow(\nLibOrder.Order[] calldata orders,\nuint256 makerAssetFillAmount,\nbytes[] memory signatures\n)\npublic\nreturns (FillResults memory totalFillResults)\n{\nbytes memory makerAssetData = orders[0].makerAssetData;\n\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n// We assume that asset being bought by taker is the same for each order.\n// Rather than passing this in as calldata, we copy the makerAssetData from the first order onto all later orders.\norders[i].makerAssetData = makerAssetData;\n\n// Calculate the remaining amount of makerAsset to buy\nuint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);\n\n// Convert the remaining amount of makerAsset to buy into remaining amount\n// of takerAsset to sell, assuming entire amount can be sold in the current order\nuint256 remainingTakerAssetFillAmount = getPartialAmountFloor(\norders[i].takerAssetAmount,\norders[i].makerAssetAmount,\nremainingMakerAssetFillAmount\n);\n\n// Attempt to sell the remaining amount of takerAsset\nFillResults memory singleFillResults = fillOrderNoThrow(\norders[i],\nremainingTakerAssetFillAmount,\nsignatures[i]\n);\n\n// Update amounts filled and fees paid by maker and taker\naddFillResults(totalFillResults, singleFillResults);\n\n// Stop execution if the entire amount of makerAsset has been bought\nif (totalFillResults.makerAssetFilledAmount >= makerAssetFillAmount) {\nbreak;\n}\n}\nreturn totalFillResults;\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function batchCancelOrders(LibOrder.Order[] memory orders)\npublic\nnonReentrant\n{\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\ncancelOrderInternal(orders[i]);\n}\n}","after":"function batchCancelOrders(LibOrder.Order[] calldata orders)\npublic\nnonReentrant\n{\nuint256 ordersLength = orders.length;\nfor (uint256 i = 0; i != ordersLength; i++) {\ncancelOrderInternal(orders[i]);\n}\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function getOrdersInfo(LibOrder.Order[] memory orders)\npublic\nview\nreturns (LibOrder.OrderInfo[] memory)\n{\nuint256 ordersLength = orders.length;\nLibOrder.OrderInfo[] memory ordersInfo = new LibOrder.OrderInfo[](ordersLength);\nfor (uint256 i = 0; i != ordersLength; i++) {\nordersInfo[i] = getOrderInfo(orders[i]);\n}\nreturn ordersInfo;\n}","after":"function getOrdersInfo(LibOrder.Order[] calldata orders)\npublic\nview\nreturns (LibOrder.OrderInfo[] memory)\n{\nuint256 ordersLength = orders.length;\nLibOrder.OrderInfo[] memory ordersInfo = new LibOrder.OrderInfo[](ordersLength);\nfor (uint256 i = 0; i != ordersLength; i++) {\nordersInfo[i] = getOrderInfo(orders[i]);\n}\nreturn ordersInfo;\n}","contract":"Exchange","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public EIP712_DOMAIN_HASH;","after":"bytes32 public immutable EIP712_DOMAIN_HASH;","contract":"Exchange","time":1}]}