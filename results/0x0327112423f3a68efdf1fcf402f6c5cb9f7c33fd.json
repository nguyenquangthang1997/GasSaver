{"time":219,"results":[{"type":"external-function ","before":"function newProxiedSmartPool(\n\n        string memory _name,\n\n        string memory _symbol,\n\n        uint256 _initialSupply,\n\n        address[] memory _tokens,\n\n        uint256[] memory _amounts,\n\n        uint256[] memory _weights,\n\n        uint256 _cap\n\n    ) public onlyOwner returns (address) {\n\n        // Deploy proxy contract\n\n        PProxyPausable proxy = new PProxyPausable();\n\n\n        // Setup proxy\n\n        proxy.setImplementation(smartPoolImplementation);\n\n        proxy.setPauzer(msg.sender);\n\n        proxy.setProxyOwner(msg.sender);\n\n\n        // Setup balancer pool\n\n        address balancerPoolAddress = balancerFactory.newBPool();\n\n        IBPool bPool = IBPool(balancerPoolAddress);\n\n\n        for (uint256 i = 0; i < _tokens.length; i ++) {\n\n            IERC20 token = IERC20(_tokens[i]);\n\n            // Transfer tokens to this contract\n\n            token.transferFrom(msg.sender, address(this), _amounts[i]);\n\n            // Approve the balancer pool\n\n            token.approve(balancerPoolAddress, uint256(- 1));\n\n            // Bind tokens\n\n            bPool.bind(_tokens[i], _amounts[i], _weights[i]);\n\n        }\n\n        bPool.setController(address(proxy));\n\n\n        // Setup smart pool\n\n        PCappedSmartPool smartPool = PCappedSmartPool(address(proxy));\n\n\n        smartPool.init(balancerPoolAddress, _name, _symbol, _initialSupply);\n\n        smartPool.setCap(_cap);\n\n        smartPool.setPublicSwapSetter(msg.sender);\n\n        smartPool.setTokenBinder(msg.sender);\n\n        smartPool.setController(msg.sender);\n\n        smartPool.approveTokens();\n\n\n        isPool[address(smartPool)] = true;\n\n        pools.push(address(smartPool));\n\n\n        emit SmartPoolCreated(address(smartPool), _name, _symbol);\n\n\n        smartPool.transfer(msg.sender, _initialSupply);\n\n\n        return address(smartPool);\n\n    }","after":"function newProxiedSmartPool(\n\n        string calldata _name,\n\n        string calldata _symbol,\n\n        uint256 _initialSupply,\n\n        address[] calldata _tokens,\n\n        uint256[] calldata _amounts,\n\n        uint256[] calldata _weights,\n\n        uint256 _cap\n\n    ) public onlyOwner returns (address) {\n\n        // Deploy proxy contract\n\n        PProxyPausable proxy = new PProxyPausable();\n\n\n        // Setup proxy\n\n        proxy.setImplementation(smartPoolImplementation);\n\n        proxy.setPauzer(msg.sender);\n\n        proxy.setProxyOwner(msg.sender);\n\n\n        // Setup balancer pool\n\n        address balancerPoolAddress = balancerFactory.newBPool();\n\n        IBPool bPool = IBPool(balancerPoolAddress);\n\n\n        for (uint256 i = 0; i < _tokens.length; i ++) {\n\n            IERC20 token = IERC20(_tokens[i]);\n\n            // Transfer tokens to this contract\n\n            token.transferFrom(msg.sender, address(this), _amounts[i]);\n\n            // Approve the balancer pool\n\n            token.approve(balancerPoolAddress, uint256(- 1));\n\n            // Bind tokens\n\n            bPool.bind(_tokens[i], _amounts[i], _weights[i]);\n\n        }\n\n        bPool.setController(address(proxy));\n\n\n        // Setup smart pool\n\n        PCappedSmartPool smartPool = PCappedSmartPool(address(proxy));\n\n\n        smartPool.init(balancerPoolAddress, _name, _symbol, _initialSupply);\n\n        smartPool.setCap(_cap);\n\n        smartPool.setPublicSwapSetter(msg.sender);\n\n        smartPool.setTokenBinder(msg.sender);\n\n        smartPool.setController(msg.sender);\n\n        smartPool.approveTokens();\n\n\n        isPool[address(smartPool)] = true;\n\n        pools.push(address(smartPool));\n\n\n        emit SmartPoolCreated(address(smartPool), _name, _symbol);\n\n\n        smartPool.transfer(msg.sender, _initialSupply);\n\n\n        return address(smartPool);\n\n    }","contract":"PProxiedFactory","time":0},{"type":"external-function ","before":"function initUK(address _pool, address _uniswapFactory, address _kyber, address[] memory _swapOnKyber, address _feeReciever) public {\n\n        // UnsiwapRecipe enforces that init can only be called once\n\n        ukprs storage s = lukprs();\n\n\n        PUniswapPoolRecipe.init(_pool, _uniswapFactory);\n\n        s.kyber = IKyberNetwork(_kyber);\n\n        s.feeReceiver = _feeReciever;\n\n\n        _setOwner(msg.sender);\n\n\n        for (uint256 i = 0; i < _swapOnKyber.length; i ++) {\n\n            s.swapOnKyber[_swapOnKyber[i]] = true;\n\n        }\n\n    }","after":"function initUK(address _pool, address _uniswapFactory, address _kyber, address[] calldata _swapOnKyber, address _feeReciever) public {\n\n        // UnsiwapRecipe enforces that init can only be called once\n\n        ukprs storage s = lukprs();\n\n\n        PUniswapPoolRecipe.init(_pool, _uniswapFactory);\n\n        s.kyber = IKyberNetwork(_kyber);\n\n        s.feeReceiver = _feeReciever;\n\n\n        _setOwner(msg.sender);\n\n\n        for (uint256 i = 0; i < _swapOnKyber.length; i ++) {\n\n            s.swapOnKyber[_swapOnKyber[i]] = true;\n\n        }\n\n    }","contract":"PUniswapKyberPoolRecipe","time":0}]}