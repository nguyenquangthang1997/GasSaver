{"time":414,"results":[{"type":"constant-restrict-modification  ","before":"uint256 maxDriipNonce;","after":"uint256 constant maxDriipNonce;","contract":"CommunityVote","time":0},{"type":"constant-restrict-modification  ","before":"uint256 maxNullNonce;","after":"uint256 constant maxNullNonce;","contract":"CommunityVote","time":0},{"type":"immutable-restrict-modification ","before":"bool dataAvailable;","after":"bool immutable dataAvailable;","contract":"CommunityVote","time":0},{"type":"external-function ","before":"function transferController(address currencyCt, string memory standard)\npublic\nview\nreturns (TransferController)\n{\nif (bytes(standard).length > 0) {\nbytes32 standardHash = keccak256(abi.encodePacked(standard));\n\nrequire(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\nreturn TransferController(registeredTransferControllers[standardHash]);\n}\n\nrequire(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\nrequire(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\naddress controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\nrequire(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\nreturn TransferController(controllerAddress);\n}","after":"function transferController(address currencyCt, string calldata standard)\npublic\nview\nreturns (TransferController)\n{\nif (bytes(standard).length > 0) {\nbytes32 standardHash = keccak256(abi.encodePacked(standard));\n\nrequire(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\nreturn TransferController(registeredTransferControllers[standardHash]);\n}\n\nrequire(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\nrequire(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\naddress controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\nrequire(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\nreturn TransferController(controllerAddress);\n}","contract":"TransferControllerManager","time":0},{"type":"external-function ","before":"function receiveTokens(string memory balanceType, int256 amount, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\nreceiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);\n}","after":"function receiveTokens(string calldata balanceType, int256 amount, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\nreceiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);\n}","contract":"RevenueFund","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\npublic\nonlyOperator\n{\nrequire(\nConstantsLib.PARTS_PER() == totalBeneficiaryFraction,\n\"Total beneficiary fraction out of bounds [RevenueFund.sol:236]\"\n);\n\n// Execute transfer\nfor (uint256 i = 0; i < currencies.length; i++) {\nMonetaryTypesLib.Currency memory currency = currencies[i];\n\nint256 remaining = periodAccrual.get(currency.ct, currency.id);\n\nif (0 >= remaining)\ncontinue;\n\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\nif (beneficiaryFraction(beneficiary) > 0) {\nint256 transferable = periodAccrual.get(currency.ct, currency.id)\n.mul(beneficiaryFraction(beneficiary))\n.div(ConstantsLib.PARTS_PER());\n\nif (transferable > remaining)\ntransferable = remaining;\n\nif (transferable > 0) {\n// Transfer ETH to the beneficiary\nif (currency.ct == address(0))\nbeneficiary.receiveEthersTo.value(uint256(transferable))(address(0), \"\");\n\n// Transfer token to the beneficiary\nelse {\nTransferController controller = transferController(currency.ct, \"\");\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(transferable), currency.ct, currency.id\n)\n);\nrequire(success, \"Approval by controller failed [RevenueFund.sol:274]\");\n\nbeneficiary.receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\n}\n\nremaining = remaining.sub(transferable);\n}\n}\n}\n\n// Roll over remaining to next accrual period\nperiodAccrual.set(remaining, currency.ct, currency.id);\n}\n\n// Close accrual period of accrual beneficiaries\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n// Require that beneficiary fraction is strictly positive\nif (0 >= beneficiaryFraction(beneficiary))\ncontinue;\n\n// Close accrual period\nbeneficiary.closeAccrualPeriod(currencies);\n}\n\n// Emit event\nemit CloseAccrualPeriodEvent();\n}","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata currencies)\npublic\nonlyOperator\n{\nrequire(\nConstantsLib.PARTS_PER() == totalBeneficiaryFraction,\n\"Total beneficiary fraction out of bounds [RevenueFund.sol:236]\"\n);\n\n// Execute transfer\nfor (uint256 i = 0; i < currencies.length; i++) {\nMonetaryTypesLib.Currency memory currency = currencies[i];\n\nint256 remaining = periodAccrual.get(currency.ct, currency.id);\n\nif (0 >= remaining)\ncontinue;\n\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\nif (beneficiaryFraction(beneficiary) > 0) {\nint256 transferable = periodAccrual.get(currency.ct, currency.id)\n.mul(beneficiaryFraction(beneficiary))\n.div(ConstantsLib.PARTS_PER());\n\nif (transferable > remaining)\ntransferable = remaining;\n\nif (transferable > 0) {\n// Transfer ETH to the beneficiary\nif (currency.ct == address(0))\nbeneficiary.receiveEthersTo.value(uint256(transferable))(address(0), \"\");\n\n// Transfer token to the beneficiary\nelse {\nTransferController controller = transferController(currency.ct, \"\");\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(transferable), currency.ct, currency.id\n)\n);\nrequire(success, \"Approval by controller failed [RevenueFund.sol:274]\");\n\nbeneficiary.receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\n}\n\nremaining = remaining.sub(transferable);\n}\n}\n}\n\n// Roll over remaining to next accrual period\nperiodAccrual.set(remaining, currency.ct, currency.id);\n}\n\n// Close accrual period of accrual beneficiaries\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n// Require that beneficiary fraction is strictly positive\nif (0 >= beneficiaryFraction(beneficiary))\ncontinue;\n\n// Close accrual period\nbeneficiary.closeAccrualPeriod(currencies);\n}\n\n// Emit event\nemit CloseAccrualPeriodEvent();\n}","contract":"RevenueFund","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }","contract":"RevenueFund","time":0},{"type":"struct-data-arrangement ","before":"\n{\nbytes32 nameHa\n\n\nuint256 f\n;\naddress wall\n;\nuint256 ind\n\n\nbool operatorCanUpda\n;\nbool partnerCanUpda\n\n\nFungibleBalanceLib.Balance acti\n;\nFungibleBalanceLib.Balance stag\n\n\nTxHistoryLib.TxHistory txHisto\n;\nFullBalanceHistory[] fullBalanceHisto","after":"{\nbytes32 nameHa\n\n\nuint256 f\n;\nuint256 ind\n\n\nFungibleBalanceLib.Balance acti\n;\nFungibleBalanceLib.Balance stag\n\n\nTxHistoryLib.TxHistory txHisto\n;\nFullBalanceHistory[] fullBalanceHisto\n;\naddress wall\n\n\nbool operatorCanUpda\n;\nbool partnerCanUpda\n","contract":"PartnerFund","time":0},{"type":"external-function ","before":"r\nfunction receiveEthersTo(address tag, string memory)\npublic\npayable\n{\n_receiveEthersTo(\nuint256(tag) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\n);","after":"r\nfunction receiveEthersTo(address tag, string memory)\npublic\npayable\n{\n_receiveEthersTo(\nuint256(tag) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\n);","contract":"PartnerFund","time":0},{"type":"external-function ","before":")\nfunction receiveTokens(string memory, int256 amount, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\n_receiveTokensTo(\nindexByWallet(msg.sender) - 1, amount, currencyCt, currencyId, standard\n);","after":")\nfunction receiveTokens(string calldata, int256 amount, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\n_receiveTokensTo(\nindexByWallet(msg.sender) - 1, amount, currencyCt, currencyId, standard\n);","contract":"PartnerFund","time":0},{"type":"external-function ","before":")\nfunction receiveTokensTo(address tag, string memory, int256 amount, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\n_receiveTokensTo(\nuint256(tag) - 1, amount, currencyCt, currencyId, standard\n);","after":")\nfunction receiveTokensTo(address tag, string calldata, int256 amount, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\n_receiveTokensTo(\nuint256(tag) - 1, amount, currencyCt, currencyId, standard\n);","contract":"PartnerFund","time":0},{"type":"external-function ","before":"s\nfunction depositByName(string memory name, uint depositIndex)\npublic\nview\nreturns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n{\n// Implicitly require that partner name is registered\nreturn _depositByIndices(indexByName(name) - 1, depositIndex);","after":"s\nfunction depositByName(string calldata name, uint depositIndex)\npublic\nview\nreturns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n{\n// Implicitly require that partner name is registered\nreturn _depositByIndices(indexByName(name) - 1, depositIndex);","contract":"PartnerFund","time":0},{"type":"external-function ","before":"t\nfunction depositsCountByName(string memory name)\npublic\nview\nreturns (uint256)\n{\n// Implicitly require that partner name is registered\nreturn _depositsCountByIndex(indexByName(name) - 1);","after":"t\nfunction depositsCountByName(string calldata name)\npublic\nview\nreturns (uint256)\n{\n// Implicitly require that partner name is registered\nreturn _depositsCountByIndex(indexByName(name) - 1);","contract":"PartnerFund","time":0},{"type":"external-function ","before":"e\nfunction activeBalanceByName(string memory name, address currencyCt, uint256 currencyId)\npublic\nview\nreturns (int256)\n{\n// Implicitly require that partner name is registered\nreturn _activeBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);","after":"e\nfunction activeBalanceByName(string calldata name, address currencyCt, uint256 currencyId)\npublic\nview\nreturns (int256)\n{\n// Implicitly require that partner name is registered\nreturn _activeBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);","contract":"PartnerFund","time":0},{"type":"external-function ","before":"e\nfunction stagedBalanceByName(string memory name, address currencyCt, uint256 currencyId)\npublic\nview\nreturns (int256)\n{\n// Implicitly require that partner name is registered\nreturn _stagedBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);","after":"e\nfunction stagedBalanceByName(string calldata name, address currencyCt, uint256 currencyId)\npublic\nview\nreturns (int256)\n{\n// Implicitly require that partner name is registered\nreturn _stagedBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);","contract":"PartnerFund","time":0},{"type":"external-function ","before":"t\nfunction registerByName(string memory name, uint256 fee, address wallet,\nbool partnerCanUpdate, bool operatorCanUpdate)\npublic\nonlyOperator\n{\n// Require not empty name string\nrequire(bytes(name).length > 0, \"Some error message when require fails [PartnerFund.sol:392]\");\n\n// Hash name\nbytes32 nameHash = hashName(name);\n\n// Register partner\n_registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\n\n// Emit event\nemit RegisterPartnerByNameEvent(name, fee, wallet);","after":"t\nfunction registerByName(string calldata name, uint256 fee, address wallet,\nbool partnerCanUpdate, bool operatorCanUpdate)\npublic\nonlyOperator\n{\n// Require not empty name string\nrequire(bytes(name).length > 0, \"Some error message when require fails [PartnerFund.sol:392]\");\n\n// Hash name\nbytes32 nameHash = hashName(name);\n\n// Register partner\n_registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\n\n// Emit event\nemit RegisterPartnerByNameEvent(name, fee, wallet);","contract":"PartnerFund","time":0},{"type":"external-function ","before":"e\nfunction isRegisteredByName(string memory name)\npublic\nview\nreturns (bool)\n{\nreturn (0 < _indexByNameHash[hashName(name)]);","after":"e\nfunction isRegisteredByName(string calldata name)\npublic\nview\nreturns (bool)\n{\nreturn (0 < _indexByNameHash[hashName(name)]);","contract":"PartnerFund","time":0},{"type":"external-function ","before":"n\nfunction feeByName(string memory name)\npublic\nview\nreturns (uint256)\n{\n// Get fee, implicitly requiring that partner name is registered\nreturn _partnerFeeByIndex(indexByName(name) - 1);","after":"n\nfunction feeByName(string calldata name)\npublic\nview\nreturns (uint256)\n{\n// Get fee, implicitly requiring that partner name is registered\nreturn _partnerFeeByIndex(indexByName(name) - 1);","contract":"PartnerFund","time":0},{"type":"external-function ","before":"n\nfunction setFeeByName(string memory name, uint256 newFee)\npublic\n{\n// Update fee, implicitly requiring that partner name is registered\nuint256 oldFee = _setPartnerFeeByIndex(indexByName(name) - 1, newFee);\n\n// Emit event\nemit SetFeeByNameEvent(name, oldFee, newFee);","after":"n\nfunction setFeeByName(string calldata name, uint256 newFee)\npublic\n{\n// Update fee, implicitly requiring that partner name is registered\nuint256 oldFee = _setPartnerFeeByIndex(indexByName(name) - 1, newFee);\n\n// Emit event\nemit SetFeeByNameEvent(name, oldFee, newFee);","contract":"PartnerFund","time":0},{"type":"external-function ","before":"t\nfunction walletByName(string memory name)\npublic\nview\nreturns (address)\n{\n// Get wallet, implicitly requiring that partner name is registered\nreturn partners[indexByName(name) - 1].wallet;","after":"t\nfunction walletByName(string calldata name)\npublic\nview\nreturns (address)\n{\n// Get wallet, implicitly requiring that partner name is registered\nreturn partners[indexByName(name) - 1].wallet;","contract":"PartnerFund","time":0},{"type":"external-function ","before":"t\nfunction setWalletByName(string memory name, address newWallet)\npublic\n{\n// Update wallet\naddress oldWallet = _setPartnerWalletByIndex(indexByName(name) - 1, newWallet);\n\n// Emit event\nemit SetPartnerWalletByNameEvent(name, oldWallet, newWallet);","after":"t\nfunction setWalletByName(string calldata name, address newWallet)\npublic\n{\n// Update wallet\naddress oldWallet = _setPartnerWalletByIndex(indexByName(name) - 1, newWallet);\n\n// Emit event\nemit SetPartnerWalletByNameEvent(name, oldWallet, newWallet);","contract":"PartnerFund","time":0},{"type":"external-function ","before":")\nfunction withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\n// Get index, implicitly requiring that msg.sender is wallet of registered partner\nuint256 index = indexByWallet(msg.sender);\n\n// Require positive amount\nrequire(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:736]\");\n\n// Clamp amount to move\namount = amount.clampMax(partners[index - 1].staged.get(currencyCt, currencyId));\n\npartners[index - 1].staged.sub(amount, currencyCt, currencyId);\n\n// Execute transfer\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Some error message when require fails [PartnerFund.sol:754]\");\n}\n\n// Emit event\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId);","after":")\nfunction withdraw(int256 amount, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\n// Get index, implicitly requiring that msg.sender is wallet of registered partner\nuint256 index = indexByWallet(msg.sender);\n\n// Require positive amount\nrequire(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:736]\");\n\n// Clamp amount to move\namount = amount.clampMax(partners[index - 1].staged.get(currencyCt, currencyId));\n\npartners[index - 1].staged.sub(amount, currencyCt, currencyId);\n\n// Execute transfer\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Some error message when require fails [PartnerFund.sol:754]\");\n}\n\n// Emit event\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId);","contract":"PartnerFund","time":0},{"type":"external-function ","before":"t\nfunction initSettlement(string memory settledKind, bytes32 settledHash, address originWallet,\nuint256 originNonce, address targetWallet, uint256 targetNonce)\npublic\nonlyEnabledServiceAction(INIT_SETTLEMENT_ACTION)\n{\nif (\n0 == walletNonceSettlementIndex[originWallet][originNonce] &&\n0 == walletNonceSettlementIndex[targetWallet][targetNonce]\n) {\n// Create new settlement\nsettlements.length++;\n\n// Get the 0-based index\nuint256 index = settlements.length - 1;\n\n// Update settlement\nsettlements[index].settledKind = settledKind;\nsettlements[index].settledHash = settledHash;\nsettlements[index].origin.nonce = originNonce;\nsettlements[index].origin.wallet = originWallet;\nsettlements[index].target.nonce = targetNonce;\nsettlements[index].target.wallet = targetWallet;\n\n// Emit event\nemit InitSettlementEvent(settlements[index]);\n\n// Store 1-based index value\nindex++;\nwalletSettlementIndices[originWallet].push(index);\nwalletSettlementIndices[targetWallet].push(index);\nwalletNonceSettlementIndex[originWallet][originNonce] = index;\nwalletNonceSettlementIndex[targetWallet][targetNonce] = index;\n}","after":"t\nfunction initSettlement(string calldata settledKind, bytes32 settledHash, address originWallet,\nuint256 originNonce, address targetWallet, uint256 targetNonce)\npublic\nonlyEnabledServiceAction(INIT_SETTLEMENT_ACTION)\n{\nif (\n0 == walletNonceSettlementIndex[originWallet][originNonce] &&\n0 == walletNonceSettlementIndex[targetWallet][targetNonce]\n) {\n// Create new settlement\nsettlements.length++;\n\n// Get the 0-based index\nuint256 index = settlements.length - 1;\n\n// Update settlement\nsettlements[index].settledKind = settledKind;\nsettlements[index].settledHash = settledHash;\nsettlements[index].origin.nonce = originNonce;\nsettlements[index].origin.wallet = originWallet;\nsettlements[index].target.nonce = targetNonce;\nsettlements[index].target.wallet = targetWallet;\n\n// Emit event\nemit InitSettlementEvent(settlements[index]);\n\n// Store 1-based index value\nindex++;\nwalletSettlementIndices[originWallet].push(index);\nwalletSettlementIndices[targetWallet].push(index);\nwalletNonceSettlementIndex[originWallet][originNonce] = index;\nwalletNonceSettlementIndex[targetWallet][targetNonce] = index;\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"e\nfunction maxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nreturn walletCurrencyMaxNonce[wallet][currency.ct][currency.id];","after":"e\nfunction maxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nreturn walletCurrencyMaxNonce[wallet][currency.ct][currency.id];","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"e\nfunction setMaxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency,\nuint256 maxNonce)\npublic\nonlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n{\n// Update max nonce value\nwalletCurrencyMaxNonce[wallet][currency.ct][currency.id] = maxNonce;\n\n// Emit event\nemit SetMaxNonceByWalletAndCurrencyEvent(wallet, currency, maxNonce);","after":"e\nfunction setMaxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency calldata currency,\nuint256 maxNonce)\npublic\nonlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n{\n// Update max nonce value\nwalletCurrencyMaxNonce[wallet][currency.ct][currency.id] = maxNonce;\n\n// Emit event\nemit SetMaxNonceByWalletAndCurrencyEvent(wallet, currency, maxNonce);","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"e\nfunction totalFee(address wallet, Beneficiary beneficiary, address destination,\nMonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (MonetaryTypesLib.NoncedAmount memory)\n{\nreturn totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id];","after":"e\nfunction totalFee(address wallet, Beneficiary beneficiary, address destination,\nMonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (MonetaryTypesLib.NoncedAmount memory)\n{\nreturn totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id];","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"e\nfunction setTotalFee(address wallet, Beneficiary beneficiary, address destination,\nMonetaryTypesLib.Currency memory currency, MonetaryTypesLib.NoncedAmount memory _totalFee)\npublic\nonlyEnabledServiceAction(SET_FEE_TOTAL_ACTION)\n{\n// Update total fees value\ntotalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id] = _totalFee;\n\n// Emit event\nemit SetTotalFeeEvent(wallet, beneficiary, destination, currency, _totalFee);","after":"e\nfunction setTotalFee(address wallet, Beneficiary beneficiary, address destination,\nMonetaryTypesLib.Currency calldata currency, MonetaryTypesLib.NoncedAmount calldata _totalFee)\npublic\nonlyEnabledServiceAction(SET_FEE_TOTAL_ACTION)\n{\n// Update total fees value\ntotalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id] = _totalFee;\n\n// Emit event\nemit SetTotalFeeEvent(wallet, beneficiary, destination, currency, _totalFee);","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"e\nfunction upgradeSettlement(string memory settledKind, bytes32 settledHash,\naddress originWallet, uint256 originNonce, bool originDone, uint256 originDoneBlockNumber,\naddress targetWallet, uint256 targetNonce, bool targetDone, uint256 targetDoneBlockNumber)\npublic\nonlyDeployer\n{\n// Require that upgrades have not been frozen\nrequire(!upgradesFrozen, \"Upgrades have been frozen [DriipSettlementState.sol:413]\");\n\n// Require that settlement has not been initialized/upgraded already\nrequire(0 == walletNonceSettlementIndex[originWallet][originNonce], \"Settlement exists for origin wallet and nonce [DriipSettlementState.sol:416]\");\nrequire(0 == walletNonceSettlementIndex[targetWallet][targetNonce], \"Settlement exists for target wallet and nonce [DriipSettlementState.sol:417]\");\n\n// Create new settlement\nsettlements.length++;\n\n// Get the 0-based index\nuint256 index = settlements.length - 1;\n\n// Update settlement\nsettlements[index].settledKind = settledKind;\nsettlements[index].settledHash = settledHash;\nsettlements[index].origin.nonce = originNonce;\nsettlements[index].origin.wallet = originWallet;\nsettlements[index].origin.done = originDone;\nsettlements[index].origin.doneBlockNumber = originDoneBlockNumber;\nsettlements[index].target.nonce = targetNonce;\nsettlements[index].target.wallet = targetWallet;\nsettlements[index].target.done = targetDone;\nsettlements[index].target.doneBlockNumber = targetDoneBlockNumber;\n\n// Emit event\nemit UpgradeSettlementEvent(settlements[index]);\n\n// Store 1-based index value\nindex++;\nwalletSettlementIndices[originWallet].push(index);\nwalletSettlementIndices[targetWallet].push(index);\nwalletNonceSettlementIndex[originWallet][originNonce] = index;\nwalletNonceSettlementIndex[targetWallet][targetNonce] = index;","after":"e\nfunction upgradeSettlement(string calldata settledKind, bytes32 settledHash,\naddress originWallet, uint256 originNonce, bool originDone, uint256 originDoneBlockNumber,\naddress targetWallet, uint256 targetNonce, bool targetDone, uint256 targetDoneBlockNumber)\npublic\nonlyDeployer\n{\n// Require that upgrades have not been frozen\nrequire(!upgradesFrozen, \"Upgrades have been frozen [DriipSettlementState.sol:413]\");\n\n// Require that settlement has not been initialized/upgraded already\nrequire(0 == walletNonceSettlementIndex[originWallet][originNonce], \"Settlement exists for origin wallet and nonce [DriipSettlementState.sol:416]\");\nrequire(0 == walletNonceSettlementIndex[targetWallet][targetNonce], \"Settlement exists for target wallet and nonce [DriipSettlementState.sol:417]\");\n\n// Create new settlement\nsettlements.length++;\n\n// Get the 0-based index\nuint256 index = settlements.length - 1;\n\n// Update settlement\nsettlements[index].settledKind = settledKind;\nsettlements[index].settledHash = settledHash;\nsettlements[index].origin.nonce = originNonce;\nsettlements[index].origin.wallet = originWallet;\nsettlements[index].origin.done = originDone;\nsettlements[index].origin.doneBlockNumber = originDoneBlockNumber;\nsettlements[index].target.nonce = targetNonce;\nsettlements[index].target.wallet = targetWallet;\nsettlements[index].target.done = targetDone;\nsettlements[index].target.doneBlockNumber = targetDoneBlockNumber;\n\n// Emit event\nemit UpgradeSettlementEvent(settlements[index]);\n\n// Store 1-based index value\nindex++;\nwalletSettlementIndices[originWallet].push(index);\nwalletSettlementIndices[targetWallet].push(index);\nwalletNonceSettlementIndex[originWallet][originNonce] = index;\nwalletNonceSettlementIndex[targetWallet][targetNonce] = index;","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"DriipSettlementState","time":0}]}