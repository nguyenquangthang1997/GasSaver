{"time":184,"results":[{"type":"struct-data-arrangement ","before":"\nbool hasVoted\nuint256 votes\nbool support","after":"uint256 votes\nbool hasVoted\nbool support\n","contract":"Governance","time":0},{"type":"struct-data-arrangement ","before":"\nuint256 id\naddress proposer\nstring description\nstring title\naddress[] targets\nuint256[] values\nstring[] signatures\nbytes[] calldatas\nuint256 createTime\nuint256 eta\nuint256 forVotes\nuint256 againstVotes\nbool canceled\nbool executed\nmapping(address => Receipt) receipts\nProposalParameters parameters","after":"uint256 id\nstring description\nstring title\naddress[] targets\nuint256[] values\nstring[] signatures\nbytes[] calldatas\nuint256 createTime\nuint256 eta\nuint256 forVotes\nuint256 againstVotes\nmapping(address => Receipt) receipts\nProposalParameters parameters\naddress proposer\nbool canceled\nbool executed\n","contract":"Governance","time":0},{"type":"external-function ","before":"function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description,\n        string memory title\n    )\n    public returns (uint256)\n    {\n        if (!isActive) {\n            require(supernova.xyzStaked() >= ACTIVATION_THRESHOLD, \"DAO not yet active\");\n            isActive = true;\n        }\n\n        require(\n            supernova.votingPowerAtTs(msg.sender, block.timestamp - 1) >= _getCreationThreshold(),\n            \"Creation threshold not met\"\n        );\n        require(\n            targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\n            \"Proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"Must provide actions\");\n        require(targets.length <= PROPOSAL_MAX_ACTIONS, \"Too many actions on a vote\");\n        require(bytes(title).length > 0, \"title can't be empty\");\n        require(bytes(description).length > 0, \"description can't be empty\");\n\n        // check if user has another running vote\n        uint256 previousProposalId = latestProposalIds[msg.sender];\n        if (previousProposalId != 0) {\n            require(_isLiveState(previousProposalId) == false, \"One live proposal per proposer\");\n        }\n\n        uint256 newProposalId = lastProposalId + 1;\n        Proposal storage newProposal = proposals[newProposalId];\n        newProposal.id = newProposalId;\n        newProposal.proposer = msg.sender;\n        newProposal.description = description;\n        newProposal.title = title;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.createTime = block.timestamp - 1;\n        newProposal.parameters.warmUpDuration = warmUpDuration;\n        newProposal.parameters.activeDuration = activeDuration;\n        newProposal.parameters.queueDuration = queueDuration;\n        newProposal.parameters.gracePeriodDuration = gracePeriodDuration;\n        newProposal.parameters.acceptanceThreshold = acceptanceThreshold;\n        newProposal.parameters.minQuorum = minQuorum;\n\n        lastProposalId = newProposalId;\n        latestProposalIds[msg.sender] = newProposalId;\n\n        emit ProposalCreated(newProposalId);\n\n        return newProposalId;\n    }","after":"function propose(\n        address[] calldata targets,\n        uint256[] calldata values,\n        string[] calldata signatures,\n        bytes[] calldata calldatas,\n        string calldata description,\n        string calldata title\n    )\n    public returns (uint256)\n    {\n        if (!isActive) {\n            require(supernova.xyzStaked() >= ACTIVATION_THRESHOLD, \"DAO not yet active\");\n            isActive = true;\n        }\n\n        require(\n            supernova.votingPowerAtTs(msg.sender, block.timestamp - 1) >= _getCreationThreshold(),\n            \"Creation threshold not met\"\n        );\n        require(\n            targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\n            \"Proposal function information arity mismatch\"\n        );\n        require(targets.length != 0, \"Must provide actions\");\n        require(targets.length <= PROPOSAL_MAX_ACTIONS, \"Too many actions on a vote\");\n        require(bytes(title).length > 0, \"title can't be empty\");\n        require(bytes(description).length > 0, \"description can't be empty\");\n\n        // check if user has another running vote\n        uint256 previousProposalId = latestProposalIds[msg.sender];\n        if (previousProposalId != 0) {\n            require(_isLiveState(previousProposalId) == false, \"One live proposal per proposer\");\n        }\n\n        uint256 newProposalId = lastProposalId + 1;\n        Proposal storage newProposal = proposals[newProposalId];\n        newProposal.id = newProposalId;\n        newProposal.proposer = msg.sender;\n        newProposal.description = description;\n        newProposal.title = title;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.createTime = block.timestamp - 1;\n        newProposal.parameters.warmUpDuration = warmUpDuration;\n        newProposal.parameters.activeDuration = activeDuration;\n        newProposal.parameters.queueDuration = queueDuration;\n        newProposal.parameters.gracePeriodDuration = gracePeriodDuration;\n        newProposal.parameters.acceptanceThreshold = acceptanceThreshold;\n        newProposal.parameters.minQuorum = minQuorum;\n\n        lastProposalId = newProposalId;\n        latestProposalIds[msg.sender] = newProposalId;\n\n        emit ProposalCreated(newProposalId);\n\n        return newProposalId;\n    }","contract":"Governance","time":0},{"type":"external-function ","before":"function startAbrogationProposal(uint256 proposalId, string memory description) public {\n        require(state(proposalId) == ProposalState.Queued, \"Proposal must be in queue\");\n        require(\n            supernova.votingPowerAtTs(msg.sender, block.timestamp - 1) >= _getCreationThreshold(),\n            \"Creation threshold not met\"\n        );\n\n        AbrogationProposal storage ap = abrogationProposals[proposalId];\n\n        require(ap.createTime == 0, \"Abrogation proposal already exists\");\n        require(bytes(description).length > 0, \"description can't be empty\");\n\n        ap.createTime = block.timestamp;\n        ap.creator = msg.sender;\n        ap.description = description;\n\n        emit AbrogationProposalStarted(proposalId, msg.sender);\n    }","after":"function startAbrogationProposal(uint256 proposalId, string calldata description) public {\n        require(state(proposalId) == ProposalState.Queued, \"Proposal must be in queue\");\n        require(\n            supernova.votingPowerAtTs(msg.sender, block.timestamp - 1) >= _getCreationThreshold(),\n            \"Creation threshold not met\"\n        );\n\n        AbrogationProposal storage ap = abrogationProposals[proposalId];\n\n        require(ap.createTime == 0, \"Abrogation proposal already exists\");\n        require(bytes(description).length > 0, \"description can't be empty\");\n\n        ap.createTime = block.timestamp;\n        ap.creator = msg.sender;\n        ap.description = description;\n\n        emit AbrogationProposalStarted(proposalId, msg.sender);\n    }","contract":"Governance","time":0}]}