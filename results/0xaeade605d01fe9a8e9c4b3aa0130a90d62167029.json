{"time":101,"results":[{"type":"loop-duplication","before":"\nstart line 742 column 8, end line 746 column 8\nfor (uint256 i = 0; i < coins.length; i++) {\n\n            balances[i] = coins[i].balanceOf(address(this));\n\n        }\nstart line 754 column 8, end line 762 column 8\nfor (uint256 i = 0; i < coins.length; i++) {\n\n            balances[i] = coins[i].balanceOf(address(this)).sub(balances[i]);\n\n            if (i == 0) continue;\n\n            require(coins[i].transfer(_coinDestination, balances[i]));\n\n        }","after":"// merge loop\n\nstart line 742 column 8, end line 746 column 8\nfor (uint256 i = 0; i < coins.length; i++) {\n\n            balances[i] = coins[i].balanceOf(address(this));\n\n        }\nstart line 754 column 8, end line 762 column 8\nfor (uint256 i = 0; i < coins.length; i++) {\n\n            balances[i] = coins[i].balanceOf(address(this)).sub(balances[i]);\n\n            if (i == 0) continue;\n\n            require(coins[i].transfer(_coinDestination, balances[i]));\n\n        }","contract":"CurveExchangeAdapterSBTC","time":0},{"type":"loop-duplication","before":"\nstart line 778 column 8, end line 782 column 8\nfor (uint256 i = 0; i < coins.length; i++) {\n\n            balances[i] = coins[i].balanceOf(address(this));\n\n        }\nstart line 802 column 8, end line 810 column 8\nfor (uint256 i = 0; i < coins.length; i++) {\n\n            balances[i] = coins[i].balanceOf(address(this)).sub(balances[i]);\n\n            if (i == 0) continue;\n\n            require(coins[i].transfer(_coinDestination, balances[i]));\n\n        }","after":"// merge loop\n\nstart line 778 column 8, end line 782 column 8\nfor (uint256 i = 0; i < coins.length; i++) {\n\n            balances[i] = coins[i].balanceOf(address(this));\n\n        }\nstart line 802 column 8, end line 810 column 8\nfor (uint256 i = 0; i < coins.length; i++) {\n\n            balances[i] = coins[i].balanceOf(address(this)).sub(balances[i]);\n\n            if (i == 0) continue;\n\n            require(coins[i].transfer(_coinDestination, balances[i]));\n\n        }","contract":"CurveExchangeAdapterSBTC","time":0},{"type":"external-function ","before":"function executeMetaTransaction(address userAddress,\n\n        bytes memory functionSignature, string memory message, string memory length,\n\n        bytes32 sigR, bytes32 sigS, uint8 sigV) public payable returns (bytes memory) {\n\n\n        require(verify(userAddress, message, length, nonces[userAddress], getChainID(), sigR, sigS, sigV), \"Signer and signature do not match\");\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n\n        (bool success, bytes memory returnData) = address(this).call(abi.encodePacked(functionSignature, userAddress));\n\n\n        require(success, \"Function call not successfull\");\n\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(userAddress, msg.sender, functionSignature);\n\n        return returnData;\n\n    }","after":"function executeMetaTransaction(address userAddress,\n\n        bytes calldata functionSignature, string calldata message, string calldata length,\n\n        bytes32 sigR, bytes32 sigS, uint8 sigV) public payable returns (bytes memory) {\n\n\n        require(verify(userAddress, message, length, nonces[userAddress], getChainID(), sigR, sigS, sigV), \"Signer and signature do not match\");\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n\n        (bool success, bytes memory returnData) = address(this).call(abi.encodePacked(functionSignature, userAddress));\n\n\n        require(success, \"Function call not successfull\");\n\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(userAddress, msg.sender, functionSignature);\n\n        return returnData;\n\n    }","contract":"CurveExchangeAdapterSBTC","time":0}]}