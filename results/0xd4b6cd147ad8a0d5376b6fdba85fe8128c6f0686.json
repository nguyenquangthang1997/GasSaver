{"time":187,"results":[{"type":"struct-data-arrangement ","before":"\n address toke\n Types.TotalPar totalPa\n Interest.Index inde\n IPriceOracle priceOracl\n IInterestSetter interestSette\n Decimal.D256 marginPremiu\n Decimal.D256 spreadPremiu\n bool isClosin","after":" Types.TotalPar totalPa\n Interest.Index inde\n IPriceOracle priceOracl\n IInterestSetter interestSette\n Decimal.D256 marginPremiu\n Decimal.D256 spreadPremiu\n address toke\n bool isClosin\n","contract":"Storage","time":0},{"type":"external-function ","before":" function liquidate(\n\n        Account.Info memory fromAccount,\n\n        Account.Info memory liquidAccount,\n\n        Decimal.D256 memory minLiquidatorRatio,\n\n        uint256 minValueLiquidated,\n\n        uint256[] memory owedPreferences,\n\n        uint256[] memory heldPreferences\n\n    )\n\n    public\n\n    nonReentrant\n\n    {\n\n        // put all values that will not change into a single struct\n\n        Constants memory constants = Constants({\n\n        fromAccount : fromAccount,\n\n        liquidAccount : liquidAccount,\n\n        minLiquidatorRatio : minLiquidatorRatio,\n\n        markets : getMarketsInfo()\n\n        });\n\n\n        // validate the msg.sender and that the liquidAccount can be liquidated\n\n        checkRequirements(constants);\n\n\n        // keep a running tally of how much value will be attempted to be liquidated\n\n        uint256 totalValueLiquidated = 0;\n\n\n        // for each owedMarket\n\n        for (uint256 owedIndex = 0; owedIndex < owedPreferences.length; owedIndex++) {\n\n            uint256 owedMarket = owedPreferences[owedIndex];\n\n\n            // for each heldMarket\n\n            for (uint256 heldIndex = 0; heldIndex < heldPreferences.length; heldIndex++) {\n\n                uint256 heldMarket = heldPreferences[heldIndex];\n\n\n                // cannot use the same market\n\n                if (heldMarket == owedMarket) {\n\n                    continue;\n\n                }\n\n\n                // cannot liquidate non-negative markets\n\n                if (!SOLO_MARGIN.getAccountPar(liquidAccount, owedMarket).isNegative()) {\n\n                    break;\n\n                }\n\n\n                // cannot use non-positive markets as collateral\n\n                if (!SOLO_MARGIN.getAccountPar(liquidAccount, heldMarket).isPositive()) {\n\n                    continue;\n\n                }\n\n\n                // get all relevant values\n\n                Cache memory cache = initializeCache(\n\n                    constants,\n\n                    heldMarket,\n\n                    owedMarket\n\n                );\n\n\n                // get the liquidation amount (before liquidator decreases in collateralization)\n\n                calculateSafeLiquidationAmount(cache);\n\n\n                // get the max liquidation amount (before liquidator reaches minLiquidatorRatio)\n\n                calculateMaxLiquidationAmount(constants, cache);\n\n\n                // if nothing to liquidate, do nothing\n\n                if (cache.toLiquidate == 0) {\n\n                    continue;\n\n                }\n\n\n                // execute the liquidations\n\n                SOLO_MARGIN.operate(\n\n                    constructAccountsArray(constants),\n\n                    constructActionsArray(cache)\n\n                );\n\n\n                // increment the total value liquidated\n\n                totalValueLiquidated =\n\n                totalValueLiquidated.add(cache.toLiquidate.mul(cache.owedPrice));\n\n            }\n\n        }\n\n\n        // revert if liquidator account does not have a lot of overhead to liquidate these pairs\n\n        Require.that(\n\n            totalValueLiquidated >= minValueLiquidated,\n\n            FILE,\n\n            \"Not enough liquidatable value\",\n\n            totalValueLiquidated,\n\n            minValueLiquidated\n\n        );\n\n    ","after":" function liquidate(\n\n        Account.Info calldata fromAccount,\n\n        Account.Info calldata liquidAccount,\n\n        Decimal.D256 calldata minLiquidatorRatio,\n\n        uint256 minValueLiquidated,\n\n        uint256[] calldata owedPreferences,\n\n        uint256[] calldata heldPreferences\n\n    )\n\n    public\n\n    nonReentrant\n\n    {\n\n        // put all values that will not change into a single struct\n\n        Constants memory constants = Constants({\n\n        fromAccount : fromAccount,\n\n        liquidAccount : liquidAccount,\n\n        minLiquidatorRatio : minLiquidatorRatio,\n\n        markets : getMarketsInfo()\n\n        });\n\n\n        // validate the msg.sender and that the liquidAccount can be liquidated\n\n        checkRequirements(constants);\n\n\n        // keep a running tally of how much value will be attempted to be liquidated\n\n        uint256 totalValueLiquidated = 0;\n\n\n        // for each owedMarket\n\n        for (uint256 owedIndex = 0; owedIndex < owedPreferences.length; owedIndex++) {\n\n            uint256 owedMarket = owedPreferences[owedIndex];\n\n\n            // for each heldMarket\n\n            for (uint256 heldIndex = 0; heldIndex < heldPreferences.length; heldIndex++) {\n\n                uint256 heldMarket = heldPreferences[heldIndex];\n\n\n                // cannot use the same market\n\n                if (heldMarket == owedMarket) {\n\n                    continue;\n\n                }\n\n\n                // cannot liquidate non-negative markets\n\n                if (!SOLO_MARGIN.getAccountPar(liquidAccount, owedMarket).isNegative()) {\n\n                    break;\n\n                }\n\n\n                // cannot use non-positive markets as collateral\n\n                if (!SOLO_MARGIN.getAccountPar(liquidAccount, heldMarket).isPositive()) {\n\n                    continue;\n\n                }\n\n\n                // get all relevant values\n\n                Cache memory cache = initializeCache(\n\n                    constants,\n\n                    heldMarket,\n\n                    owedMarket\n\n                );\n\n\n                // get the liquidation amount (before liquidator decreases in collateralization)\n\n                calculateSafeLiquidationAmount(cache);\n\n\n                // get the max liquidation amount (before liquidator reaches minLiquidatorRatio)\n\n                calculateMaxLiquidationAmount(constants, cache);\n\n\n                // if nothing to liquidate, do nothing\n\n                if (cache.toLiquidate == 0) {\n\n                    continue;\n\n                }\n\n\n                // execute the liquidations\n\n                SOLO_MARGIN.operate(\n\n                    constructAccountsArray(constants),\n\n                    constructActionsArray(cache)\n\n                );\n\n\n                // increment the total value liquidated\n\n                totalValueLiquidated =\n\n                totalValueLiquidated.add(cache.toLiquidate.mul(cache.owedPrice));\n\n            }\n\n        }\n\n\n        // revert if liquidator account does not have a lot of overhead to liquidate these pairs\n\n        Require.that(\n\n            totalValueLiquidated >= minValueLiquidated,\n\n            FILE,\n\n            \"Not enough liquidatable value\",\n\n            totalValueLiquidated,\n\n            minValueLiquidated\n\n        );\n\n    ","contract":"LiquidatorProxyV1ForSoloMargin","time":0}]}