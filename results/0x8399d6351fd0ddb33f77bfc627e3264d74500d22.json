{"time":178,"results":[{"type":"de-morgan-condition ","before":"   !(char >= 0x30 && char <= 0x39) && //9-0\n            !(char >= 0x41 && char <= 0x","after":"!(   (char >= 0x30 && char <= 0x39) && //9-0\n            (char >= 0x41 && char <= 0x)","loc":{"start":{"line":2096,"column":16},"end":{"line":2097,"column":42}},"contract":"ShogunNFT","time":0},{"type":"state-data-arrangement ","before":"\n   IShogunToken public SHOGUN_TOK\n   address payable public treasu\n   address public stakingContractAddre\n   address private signerAddressPubl\n   address private signerAddressPresa\n   string public baseU\n   string public notRevealedU\n   uint256 public cost = 0.08 eth\n   uint256 public maxSupply = 88\n   uint256 public maxMintPerTxn =\n   uint256 public nftPerAddressLimitPublic =\n   uint256 public nftPerAddressLimitPresale =\n   uint256 public nameChangePrice = 300 eth\n   uint256 public presaleWindow = 24 hou\n   uint256 public presaleStartTime = 16343424\n   uint256 public publicSaleStartTime = 16344432\n   bool public paused = fal\n   bool public revealed = fal\n   mapping(uint256 => string) public shogunNa\n   bool public presaleOpen = fal\n   bool public publicSaleOpen = fal\n   mapping(uint256 => bool) private _isLock\n   mapping(address => bool) public whitelistedAddress\n   mapping(address => uint256) private presaleAddressMintedAmou\n   mapping(address => uint256) private publicAddressMintedAmou\n   mapping(bytes => bool) private _nonceUs","after":"   IShogunToken public SHOGUN_TOK\n   string public baseU\n   string public notRevealedU\n   uint256 public cost = 0.08 eth\n   uint256 public maxSupply = 88\n   uint256 public maxMintPerTxn =\n   uint256 public nftPerAddressLimitPublic =\n   uint256 public nftPerAddressLimitPresale =\n   uint256 public nameChangePrice = 300 eth\n   uint256 public presaleWindow = 24 hou\n   uint256 public presaleStartTime = 16343424\n   uint256 public publicSaleStartTime = 16344432\n   mapping(uint256 => string) public shogunNa\n   mapping(uint256 => bool) private _isLock\n   mapping(address => bool) public whitelistedAddress\n   mapping(address => uint256) private presaleAddressMintedAmou\n   mapping(address => uint256) private publicAddressMintedAmou\n   mapping(bytes => bool) private _nonceUs\n   address payable public treasu\n   address public stakingContractAddre\n   address private signerAddressPubl\n   address private signerAddressPresa\n   bool public paused = fal\n   bool public revealed = fal\n   bool public presaleOpen = fal\n   bool public publicSaleOpen = fal\n","contract":"ShogunNFT","time":1},{"type":"external-function ","before":"   function publicMint(\n        bytes memory nonce,\n        bytes memory signature,\n        uint256 _mintAmount\n    ) public payable onlyEOA {\n        require(!paused);\n        require(\n            (isPublicSaleOpen() || publicSaleOpen),\n            \"SHOGUN: public sale has not started\"\n        );\n        require(!_nonceUsed[nonce], \"SHOGUN: nonce was used\");\n        require(\n            isSignedBySigner(msg.sender, nonce, signature, signerAddressPublic),\n            \"invalid signature\"\n        );\n        uint256 supply = totalSupply();\n        require(\n            publicAddressMintedAmount[msg.sender] + _mintAmount <=\n            nftPerAddressLimitPublic,\n            \"SHOGUN: You have exceeded max amount of mints\"\n        );\n        require(\n            _mintAmount <= maxMintPerTxn,\n            \"SHOGUN: exceeded max mint amount per transaction\"\n        );\n        require(\n            supply + _mintAmount <= maxSupply,\n            \"SHOGUN: total mint amount exceeded supply, try lowering amount\"\n        );\n\n        (bool success,) = treasury.call{value : msg.value}(\"\");\n        // forward amount to treasury wallet\n        require(success, \"SHOGUN: not able to forward msg value to treasury\");\n\n        require(\n            msg.value == cost * _mintAmount,\n            \"SHOGUN: not enough ether sent for mint amount\"\n        );\n\n        for (uint256 i = 1; i <= _mintAmount; i++) {\n            publicAddressMintedAmount[msg.sender]++;\n            _safeMint(msg.sender, supply + i);\n        }\n        _nonceUsed[nonce] = true;\n  ","after":"   function publicMint(\n        bytes calldata nonce,\n        bytes calldata signature,\n        uint256 _mintAmount\n    ) public payable onlyEOA {\n        require(!paused);\n        require(\n            (isPublicSaleOpen() || publicSaleOpen),\n            \"SHOGUN: public sale has not started\"\n        );\n        require(!_nonceUsed[nonce], \"SHOGUN: nonce was used\");\n        require(\n            isSignedBySigner(msg.sender, nonce, signature, signerAddressPublic),\n            \"invalid signature\"\n        );\n        uint256 supply = totalSupply();\n        require(\n            publicAddressMintedAmount[msg.sender] + _mintAmount <=\n            nftPerAddressLimitPublic,\n            \"SHOGUN: You have exceeded max amount of mints\"\n        );\n        require(\n            _mintAmount <= maxMintPerTxn,\n            \"SHOGUN: exceeded max mint amount per transaction\"\n        );\n        require(\n            supply + _mintAmount <= maxSupply,\n            \"SHOGUN: total mint amount exceeded supply, try lowering amount\"\n        );\n\n        (bool success,) = treasury.call{value : msg.value}(\"\");\n        // forward amount to treasury wallet\n        require(success, \"SHOGUN: not able to forward msg value to treasury\");\n\n        require(\n            msg.value == cost * _mintAmount,\n            \"SHOGUN: not enough ether sent for mint amount\"\n        );\n\n        for (uint256 i = 1; i <= _mintAmount; i++) {\n            publicAddressMintedAmount[msg.sender]++;\n            _safeMint(msg.sender, supply + i);\n        }\n        _nonceUsed[nonce] = true;\n  ","contract":"ShogunNFT","time":0},{"type":"external-function ","before":"   function presaleMint(\n        bytes memory nonce,\n        bytes memory signature,\n        uint256 _mintAmount\n    ) public payable onlyEOA {\n        require(!paused, \"SHOGUN: contract is paused\");\n        require(\n            (isPresaleOpen() || presaleOpen),\n            \"SHOGUN: presale has not started or it has ended\"\n        );\n        require(\n            whitelistedAddresses[msg.sender],\n            \"SHOGUN: you are not in the whitelist\"\n        );\n        require(!_nonceUsed[nonce], \"SHOGUN: nonce was used\");\n        require(\n            isSignedBySigner(msg.sender, nonce, signature, signerAddressPresale),\n            \"SHOGUN: invalid signature\"\n        );\n        uint256 supply = totalSupply();\n        require(\n            presaleAddressMintedAmount[msg.sender] + _mintAmount <=\n            nftPerAddressLimitPresale,\n            \"SHOGUN: you can only mint a maximum of two nft during presale\"\n        );\n        require(\n            msg.value >= cost * _mintAmount,\n            \"SHOGUN: not enought ethere sent for mint amount\"\n        );\n\n        (bool success,) = treasury.call{value : msg.value}(\"\");\n        // forward amount to treasury wallet\n        require(success, \"SHOGUN: not able to forward msg value to treasury\");\n\n        for (uint256 i = 1; i <= _mintAmount; i++) {\n            presaleAddressMintedAmount[msg.sender]++;\n            _safeMint(msg.sender, supply + i);\n        }\n        _nonceUsed[nonce] = true;\n  ","after":"   function presaleMint(\n        bytes calldata nonce,\n        bytes calldata signature,\n        uint256 _mintAmount\n    ) public payable onlyEOA {\n        require(!paused, \"SHOGUN: contract is paused\");\n        require(\n            (isPresaleOpen() || presaleOpen),\n            \"SHOGUN: presale has not started or it has ended\"\n        );\n        require(\n            whitelistedAddresses[msg.sender],\n            \"SHOGUN: you are not in the whitelist\"\n        );\n        require(!_nonceUsed[nonce], \"SHOGUN: nonce was used\");\n        require(\n            isSignedBySigner(msg.sender, nonce, signature, signerAddressPresale),\n            \"SHOGUN: invalid signature\"\n        );\n        uint256 supply = totalSupply();\n        require(\n            presaleAddressMintedAmount[msg.sender] + _mintAmount <=\n            nftPerAddressLimitPresale,\n            \"SHOGUN: you can only mint a maximum of two nft during presale\"\n        );\n        require(\n            msg.value >= cost * _mintAmount,\n            \"SHOGUN: not enought ethere sent for mint amount\"\n        );\n\n        (bool success,) = treasury.call{value : msg.value}(\"\");\n        // forward amount to treasury wallet\n        require(success, \"SHOGUN: not able to forward msg value to treasury\");\n\n        for (uint256 i = 1; i <= _mintAmount; i++) {\n            presaleAddressMintedAmount[msg.sender]++;\n            _safeMint(msg.sender, supply + i);\n        }\n        _nonceUsed[nonce] = true;\n  ","contract":"ShogunNFT","time":0},{"type":"external-function ","before":"   function airdrop(address[] memory giveawayList) public onlyEOA onlyOwner {\n        require(!paused, \"SHOGUN: contract is paused\");\n        require(\n            balanceOf(msg.sender) >= giveawayList.length,\n            \"SHOGUN: not enough in wallet for airdrop amount\"\n        );\n        uint256[] memory ownerWallet = walletOfOwner(msg.sender);\n\n        for (uint256 i = 0; i < giveawayList.length; i++) {\n            _safeTransfer(msg.sender, giveawayList[i], ownerWallet[i], \"0x00\");\n        }\n  ","after":"   function airdrop(address[] calldata giveawayList) public onlyEOA onlyOwner {\n        require(!paused, \"SHOGUN: contract is paused\");\n        require(\n            balanceOf(msg.sender) >= giveawayList.length,\n            \"SHOGUN: not enough in wallet for airdrop amount\"\n        );\n        uint256[] memory ownerWallet = walletOfOwner(msg.sender);\n\n        for (uint256 i = 0; i < giveawayList.length; i++) {\n            _safeTransfer(msg.sender, giveawayList[i], ownerWallet[i], \"0x00\");\n        }\n  ","contract":"ShogunNFT","time":0},{"type":"external-function ","before":"   function setNotRevealedUri(string memory _notRevealedUri)\n    public\n    onlyOwner\n    {\n        notRevealedUri = _notRevealedUri;\n  ","after":"   function setNotRevealedUri(string calldata _notRevealedUri)\n    public\n    onlyOwner\n    {\n        notRevealedUri = _notRevealedUri;\n  ","contract":"ShogunNFT","time":0},{"type":"external-function ","before":"   function changeName(uint256 tokenId, string memory newName) public virtual {\n        address owner = ownerOf(tokenId);\n        require(_msgSender() == owner, \"ERC721: caller is not the owner\");\n        require(validateName(newName) == true, \"SHOGUN: Not a valid new name\");\n        require(\n            sha256(bytes(newName)) != sha256(bytes(shogunName[tokenId])),\n            \"SHOGUN: New name is same as the current one\"\n        );\n\n        SHOGUN_TOKEN.burn(_msgSender(), nameChangePrice);\n        shogunName[tokenId] = newName;\n  ","after":"   function changeName(uint256 tokenId, string calldata newName) public virtual {\n        address owner = ownerOf(tokenId);\n        require(_msgSender() == owner, \"ERC721: caller is not the owner\");\n        require(validateName(newName) == true, \"SHOGUN: Not a valid new name\");\n        require(\n            sha256(bytes(newName)) != sha256(bytes(shogunName[tokenId])),\n            \"SHOGUN: New name is same as the current one\"\n        );\n\n        SHOGUN_TOKEN.burn(_msgSender(), nameChangePrice);\n        shogunName[tokenId] = newName;\n  ","contract":"ShogunNFT","time":0},{"type":"external-function ","before":"   function lockToken(uint256[] memory _tokenIds) external onlyStakingContract {\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            _isLocked[_tokenIds[i]] = true;\n        }\n  ","after":"   function lockToken(uint256[] calldata _tokenIds) external onlyStakingContract {\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            _isLocked[_tokenIds[i]] = true;\n        }\n  ","contract":"ShogunNFT","time":0},{"type":"external-function ","before":"   function unlockToken(uint256[] memory _tokenIds)\n    external\n    onlyStakingContract\n    {\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            _isLocked[_tokenIds[i]] = false;\n        }\n  ","after":"   function unlockToken(uint256[] calldata _tokenIds)\n    external\n    onlyStakingContract\n    {\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            _isLocked[_tokenIds[i]] = false;\n        }\n  ","contract":"ShogunNFT","time":0},{"type":"immutable-restrict-modification ","before":"   address payable public treasu","after":"   address payable public treasu","contract":"ShogunNFT","time":2},{"type":"constant-restrict-modification  ","before":"   uint256 public cost = 0.08 eth","after":"   uint256 public constant cost = 0.08 eth","contract":"ShogunNFT","time":2},{"type":"constant-restrict-modification  ","before":"   uint256 public maxSupply = 88","after":"   uint256 public constant maxSupply = 88","contract":"ShogunNFT","time":2},{"type":"constant-restrict-modification  ","before":"   uint256 public maxMintPerTxn =","after":"   uint256 public constant maxMintPerTxn =","contract":"ShogunNFT","time":2},{"type":"constant-restrict-modification  ","before":"   uint256 public nftPerAddressLimitPublic =","after":"   uint256 public constant nftPerAddressLimitPublic =","contract":"ShogunNFT","time":2},{"type":"constant-restrict-modification  ","before":"   uint256 public nftPerAddressLimitPresale =","after":"   uint256 public constant nftPerAddressLimitPresale =","contract":"ShogunNFT","time":2},{"type":"constant-restrict-modification  ","before":"   uint256 public presaleWindow = 24 hou","after":"   uint256 public constant presaleWindow = 24 hou","contract":"ShogunNFT","time":2},{"type":"constant-restrict-modification  ","before":"   uint256 public presaleStartTime = 16343424","after":"   uint256 public constant presaleStartTime = 16343424","contract":"ShogunNFT","time":2},{"type":"constant-restrict-modification  ","before":"   uint256 public publicSaleStartTime = 16344432","after":"   uint256 public constant publicSaleStartTime = 16344432","contract":"ShogunNFT","time":2},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"ShogunNFT","time":2},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"ShogunNFT","time":2}]}