{"time":465,"results":[{"type":"external-function ","before":"function endFailedAuction(\n\n        uint256 _startingCurrentSetAmount,\n\n        uint256 _calculatedUnitShares,\n\n        address _currentSet,\n\n        address _coreAddress,\n\n        RebalancingLibrary.AuctionPriceParameters memory _auctionPriceParameters,\n\n        RebalancingLibrary.BiddingParameters memory _biddingParameters,\n\n        uint8 _rebalanceState\n\n    )\n\n    public\n\n    returns (uint8)\n\n    {\n\n        // Token must be in Rebalance State\n\n        require(\n\n            _rebalanceState == uint8(RebalancingLibrary.State.Rebalance),\n\n            \"RebalanceAuctionModule.endFailedAuction: Rebalancing Set Token must be in Rebalance State\"\n\n        );\n\n\n        // Calculate timestamp when pivot is reached\n\n        uint256 revertAuctionTime = _auctionPriceParameters.auctionStartTime.add(\n\n            _auctionPriceParameters.auctionTimeToPivot\n\n        );\n\n\n        // Make sure auction has gone past pivot point\n\n        require(\n\n            block.timestamp >= revertAuctionTime,\n\n            \"RebalanceAuctionModule.endFailedAuction: Can only be called after auction reaches pivot\"\n\n        );\n\n\n        uint8 newRebalanceState;\n\n        /**\n\n         * If not enough sets have been bid on then allow auction to fail where no bids being registered\n\n         * returns the rebalancing set token to pre-auction state and some bids being registered puts the\n\n         * rebalancing set token in Drawdown mode.\n\n         *\n\n         * However, if enough sets have been bid on. Then allow auction to fail and enter Drawdown state if\n\n         * and only if the calculated post-auction unitShares is equal to 0.\n\n         */\n\n        if (_biddingParameters.remainingCurrentSets >= _biddingParameters.minimumBid) {\n\n            // Check if any bids have been placed\n\n            if (_startingCurrentSetAmount == _biddingParameters.remainingCurrentSets) {\n\n                // If bid not placed, reissue current Set\n\n                ICore(_coreAddress).issueInVault(\n\n                    _currentSet,\n\n                    _startingCurrentSetAmount\n\n                );\n\n\n                // Set Rebalance Set Token state to Default\n\n                newRebalanceState = uint8(RebalancingLibrary.State.Default);\n\n            } else {\n\n                // Set Rebalancing Set Token to Drawdown state\n\n                newRebalanceState = uint8(RebalancingLibrary.State.Drawdown);\n\n            }\n\n        } else {\n\n            // If settleRebalance can be called then endFailedAuction can't be unless calculatedUnitShares\n\n            // equals 0\n\n            require(\n\n                _calculatedUnitShares == 0,\n\n                \"RebalancingSetToken.endFailedAuction: Cannot be called if rebalance is viably completed\"\n\n            );\n\n\n            // If calculated unitShares equals 0 set to Drawdown state\n\n            newRebalanceState = uint8(RebalancingLibrary.State.Drawdown);\n\n        }\n\n\n        return newRebalanceState;\n\n    }","after":"function endFailedAuction(\n\n        uint256 _startingCurrentSetAmount,\n\n        uint256 _calculatedUnitShares,\n\n        address _currentSet,\n\n        address _coreAddress,\n\n        RebalancingLibrary.AuctionPriceParameters calldata _auctionPriceParameters,\n\n        RebalancingLibrary.BiddingParameters calldata _biddingParameters,\n\n        uint8 _rebalanceState\n\n    )\n\n    public\n\n    returns (uint8)\n\n    {\n\n        // Token must be in Rebalance State\n\n        require(\n\n            _rebalanceState == uint8(RebalancingLibrary.State.Rebalance),\n\n            \"RebalanceAuctionModule.endFailedAuction: Rebalancing Set Token must be in Rebalance State\"\n\n        );\n\n\n        // Calculate timestamp when pivot is reached\n\n        uint256 revertAuctionTime = _auctionPriceParameters.auctionStartTime.add(\n\n            _auctionPriceParameters.auctionTimeToPivot\n\n        );\n\n\n        // Make sure auction has gone past pivot point\n\n        require(\n\n            block.timestamp >= revertAuctionTime,\n\n            \"RebalanceAuctionModule.endFailedAuction: Can only be called after auction reaches pivot\"\n\n        );\n\n\n        uint8 newRebalanceState;\n\n        /**\n\n         * If not enough sets have been bid on then allow auction to fail where no bids being registered\n\n         * returns the rebalancing set token to pre-auction state and some bids being registered puts the\n\n         * rebalancing set token in Drawdown mode.\n\n         *\n\n         * However, if enough sets have been bid on. Then allow auction to fail and enter Drawdown state if\n\n         * and only if the calculated post-auction unitShares is equal to 0.\n\n         */\n\n        if (_biddingParameters.remainingCurrentSets >= _biddingParameters.minimumBid) {\n\n            // Check if any bids have been placed\n\n            if (_startingCurrentSetAmount == _biddingParameters.remainingCurrentSets) {\n\n                // If bid not placed, reissue current Set\n\n                ICore(_coreAddress).issueInVault(\n\n                    _currentSet,\n\n                    _startingCurrentSetAmount\n\n                );\n\n\n                // Set Rebalance Set Token state to Default\n\n                newRebalanceState = uint8(RebalancingLibrary.State.Default);\n\n            } else {\n\n                // Set Rebalancing Set Token to Drawdown state\n\n                newRebalanceState = uint8(RebalancingLibrary.State.Drawdown);\n\n            }\n\n        } else {\n\n            // If settleRebalance can be called then endFailedAuction can't be unless calculatedUnitShares\n\n            // equals 0\n\n            require(\n\n                _calculatedUnitShares == 0,\n\n                \"RebalancingSetToken.endFailedAuction: Cannot be called if rebalance is viably completed\"\n\n            );\n\n\n            // If calculated unitShares equals 0 set to Drawdown state\n\n            newRebalanceState = uint8(RebalancingLibrary.State.Drawdown);\n\n        }\n\n\n        return newRebalanceState;\n\n    }","contract":"FailAuctionLibrary","time":1},{"type":"external-function ","before":"function validatePlaceBid(\n\n        uint256 _quantity,\n\n        address _coreAddress,\n\n        RebalancingLibrary.BiddingParameters memory _biddingParameters\n\n    )\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        // Make sure sender is a module\n\n        require(\n\n            ICore(_coreAddress).validModules(msg.sender),\n\n            \"RebalancingSetToken.placeBid: Sender must be approved module\"\n\n        );\n\n\n        // Make sure that bid amount is greater than zero\n\n        require(\n\n            _quantity > 0,\n\n            \"RebalancingSetToken.placeBid: Bid must be > 0\"\n\n        );\n\n\n        // Make sure that bid amount is multiple of minimum bid amount\n\n        require(\n\n            _quantity.mod(_biddingParameters.minimumBid) == 0,\n\n            \"RebalancingSetToken.placeBid: Must bid multiple of minimum bid\"\n\n        );\n\n\n        // Make sure that bid Amount is less than remainingCurrentSets\n\n        require(\n\n            _quantity <= _biddingParameters.remainingCurrentSets,\n\n            \"RebalancingSetToken.placeBid: Bid exceeds remaining current sets\"\n\n        );\n\n    }","after":"function validatePlaceBid(\n\n        uint256 _quantity,\n\n        address _coreAddress,\n\n        RebalancingLibrary.BiddingParameters calldata _biddingParameters\n\n    )\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        // Make sure sender is a module\n\n        require(\n\n            ICore(_coreAddress).validModules(msg.sender),\n\n            \"RebalancingSetToken.placeBid: Sender must be approved module\"\n\n        );\n\n\n        // Make sure that bid amount is greater than zero\n\n        require(\n\n            _quantity > 0,\n\n            \"RebalancingSetToken.placeBid: Bid must be > 0\"\n\n        );\n\n\n        // Make sure that bid amount is multiple of minimum bid amount\n\n        require(\n\n            _quantity.mod(_biddingParameters.minimumBid) == 0,\n\n            \"RebalancingSetToken.placeBid: Must bid multiple of minimum bid\"\n\n        );\n\n\n        // Make sure that bid Amount is less than remainingCurrentSets\n\n        require(\n\n            _quantity <= _biddingParameters.remainingCurrentSets,\n\n            \"RebalancingSetToken.placeBid: Bid exceeds remaining current sets\"\n\n        );\n\n    }","contract":"PlaceBidLibrary","time":0},{"type":"external-function ","before":"function getBidPrice(\n\n        uint256 _quantity,\n\n        address _auctionLibrary,\n\n        RebalancingLibrary.BiddingParameters memory _biddingParameters,\n\n        RebalancingLibrary.AuctionPriceParameters memory _auctionPriceParameters,\n\n        uint8 _rebalanceState\n\n    )\n\n    public\n\n    view\n\n    returns (uint256[] memory, uint256[] memory)\n\n    {\n\n        // Confirm in Rebalance State\n\n        require(\n\n            _rebalanceState == uint8(RebalancingLibrary.State.Rebalance),\n\n            \"RebalancingSetToken.getBidPrice: State must be Rebalance\"\n\n        );\n\n\n        // Get bid conversion price, currently static placeholder for calling auctionlibrary\n\n        uint256 priceNumerator;\n\n        uint256 priceDivisor;\n\n        (priceNumerator, priceDivisor) = IAuctionPriceCurve(_auctionLibrary).getCurrentPrice(\n\n            _auctionPriceParameters\n\n        );\n\n\n        // Normalized quantity amount\n\n        uint256 unitsMultiplier = _quantity.div(_biddingParameters.minimumBid).mul(priceDivisor);\n\n\n        // Calculate token flow arrays\n\n        return createTokenFlowArrays(\n\n            unitsMultiplier,\n\n            priceNumerator,\n\n            priceDivisor,\n\n            _biddingParameters\n\n        );\n\n    }","after":"function getBidPrice(\n\n        uint256 _quantity,\n\n        address _auctionLibrary,\n\n        RebalancingLibrary.BiddingParameters calldata _biddingParameters,\n\n        RebalancingLibrary.AuctionPriceParameters calldata _auctionPriceParameters,\n\n        uint8 _rebalanceState\n\n    )\n\n    public\n\n    view\n\n    returns (uint256[] memory, uint256[] memory)\n\n    {\n\n        // Confirm in Rebalance State\n\n        require(\n\n            _rebalanceState == uint8(RebalancingLibrary.State.Rebalance),\n\n            \"RebalancingSetToken.getBidPrice: State must be Rebalance\"\n\n        );\n\n\n        // Get bid conversion price, currently static placeholder for calling auctionlibrary\n\n        uint256 priceNumerator;\n\n        uint256 priceDivisor;\n\n        (priceNumerator, priceDivisor) = IAuctionPriceCurve(_auctionLibrary).getCurrentPrice(\n\n            _auctionPriceParameters\n\n        );\n\n\n        // Normalized quantity amount\n\n        uint256 unitsMultiplier = _quantity.div(_biddingParameters.minimumBid).mul(priceDivisor);\n\n\n        // Calculate token flow arrays\n\n        return createTokenFlowArrays(\n\n            unitsMultiplier,\n\n            priceNumerator,\n\n            priceDivisor,\n\n            _biddingParameters\n\n        );\n\n    }","contract":"PlaceBidLibrary","time":0},{"type":"struct-data-arrangement ","before":"\naddress manager\naddress currentSet\naddress coreAddress\naddress componentWhitelist\naddress factoryAddress\nuint256 lastRebalanceTimestamp\nuint256 rebalanceInterval\nuint8 rebalanceState","after":"uint256 lastRebalanceTimestamp\nuint256 rebalanceInterval\naddress manager\naddress currentSet\naddress coreAddress\naddress componentWhitelist\naddress factoryAddress\nuint8 rebalanceState\n","contract":"ProposeLibrary","time":0},{"type":"external-function ","before":"function validateProposal(\n\n        address _nextSet,\n\n        address _auctionLibrary,\n\n        ProposalContext memory _proposalContext,\n\n        RebalancingLibrary.AuctionPriceParameters memory _auctionPriceParameters\n\n    )\n\n    public\n\n    {\n\n        ICore coreInstance = ICore(_proposalContext.coreAddress);\n\n        IRebalancingSetFactory factoryInstance = IRebalancingSetFactory(_proposalContext.factoryAddress);\n\n\n        // Make sure it is manager that is proposing the rebalance\n\n        require(\n\n            msg.sender == _proposalContext.manager,\n\n            \"ProposeLibrary.validateProposal: Sender must be manager\"\n\n        );\n\n\n        // New Proposal can only be made in Default and Proposal state\n\n        require(\n\n            _proposalContext.rebalanceState == uint8(RebalancingLibrary.State.Default) ||\n\n            _proposalContext.rebalanceState == uint8(RebalancingLibrary.State.Proposal),\n\n            \"ProposeLibrary.validateProposal: State must be in Propose or Default\"\n\n        );\n\n\n        // Make sure enough time has passed from last rebalance to start a new proposal\n\n        require(\n\n            block.timestamp >= _proposalContext.lastRebalanceTimestamp.add(\n\n            _proposalContext.rebalanceInterval\n\n        ),\n\n            \"ProposeLibrary.validateProposal: Rebalance interval not elapsed\"\n\n        );\n\n\n        // Check that new proposed Set is valid Set created by Core\n\n        require(\n\n            coreInstance.validSets(_nextSet),\n\n            \"ProposeLibrary.validateProposal: Invalid or disabled proposed SetToken address\"\n\n        );\n\n\n        // Check proposed components on whitelist. This is to ensure managers are unable to add contract addresses\n\n        // to a propose that prohibit the set from carrying out an auction i.e. a token that only the manager possesses\n\n        require(\n\n            IWhiteList(\n\n                _proposalContext.componentWhitelist\n\n            ).areValidAddresses(ISetToken(_nextSet).getComponents()),\n\n            \"ProposeLibrary.validateProposal: Proposed set contains invalid component token\"\n\n        );\n\n\n        // Check that the auction library is a valid priceLibrary tracked by Core\n\n        require(\n\n            coreInstance.validPriceLibraries(_auctionLibrary),\n\n            \"ProposeLibrary.validateProposal: Invalid or disabled PriceLibrary address\"\n\n        );\n\n\n        // Check that auctionTimeToPivot is greater than or equal to 6 hours\n\n        require(\n\n            _auctionPriceParameters.auctionTimeToPivot >= factoryInstance.minimumTimeToPivot(),\n\n            \"ProposeLibrary.validateProposal: Time to pivot must be greater than minimum\"\n\n        );\n\n\n        // Check that auctionTimeToPivot is less than or equal to 3 days\n\n        require(\n\n            _auctionPriceParameters.auctionTimeToPivot <= factoryInstance.maximumTimeToPivot(),\n\n            \"ProposeLibrary.validateProposal: Time to pivot must be greater than maximum\"\n\n        );\n\n\n        // Check that the proposed set natural unit is a multiple of current set natural unit, or vice versa.\n\n        // Done to make sure that when calculating token units there will are no rounding errors.\n\n        uint256 currentNaturalUnit = ISetToken(_proposalContext.currentSet).naturalUnit();\n\n        uint256 nextSetNaturalUnit = ISetToken(_nextSet).naturalUnit();\n\n        require(\n\n            Math.max(currentNaturalUnit, nextSetNaturalUnit).mod(\n\n                Math.min(currentNaturalUnit, nextSetNaturalUnit)\n\n            ) == 0,\n\n            \"ProposeLibrary.validateProposal: Invalid proposed Set natural unit\"\n\n        );\n\n\n        // Check that pivot price is compliant with library restrictions\n\n        IAuctionPriceCurve(_auctionLibrary).validateAuctionPriceParameters(\n\n            _auctionPriceParameters\n\n        );\n\n    }","after":"function validateProposal(\n\n        address _nextSet,\n\n        address _auctionLibrary,\n\n        ProposalContext calldata _proposalContext,\n\n        RebalancingLibrary.AuctionPriceParameters calldata _auctionPriceParameters\n\n    )\n\n    public\n\n    {\n\n        ICore coreInstance = ICore(_proposalContext.coreAddress);\n\n        IRebalancingSetFactory factoryInstance = IRebalancingSetFactory(_proposalContext.factoryAddress);\n\n\n        // Make sure it is manager that is proposing the rebalance\n\n        require(\n\n            msg.sender == _proposalContext.manager,\n\n            \"ProposeLibrary.validateProposal: Sender must be manager\"\n\n        );\n\n\n        // New Proposal can only be made in Default and Proposal state\n\n        require(\n\n            _proposalContext.rebalanceState == uint8(RebalancingLibrary.State.Default) ||\n\n            _proposalContext.rebalanceState == uint8(RebalancingLibrary.State.Proposal),\n\n            \"ProposeLibrary.validateProposal: State must be in Propose or Default\"\n\n        );\n\n\n        // Make sure enough time has passed from last rebalance to start a new proposal\n\n        require(\n\n            block.timestamp >= _proposalContext.lastRebalanceTimestamp.add(\n\n            _proposalContext.rebalanceInterval\n\n        ),\n\n            \"ProposeLibrary.validateProposal: Rebalance interval not elapsed\"\n\n        );\n\n\n        // Check that new proposed Set is valid Set created by Core\n\n        require(\n\n            coreInstance.validSets(_nextSet),\n\n            \"ProposeLibrary.validateProposal: Invalid or disabled proposed SetToken address\"\n\n        );\n\n\n        // Check proposed components on whitelist. This is to ensure managers are unable to add contract addresses\n\n        // to a propose that prohibit the set from carrying out an auction i.e. a token that only the manager possesses\n\n        require(\n\n            IWhiteList(\n\n                _proposalContext.componentWhitelist\n\n            ).areValidAddresses(ISetToken(_nextSet).getComponents()),\n\n            \"ProposeLibrary.validateProposal: Proposed set contains invalid component token\"\n\n        );\n\n\n        // Check that the auction library is a valid priceLibrary tracked by Core\n\n        require(\n\n            coreInstance.validPriceLibraries(_auctionLibrary),\n\n            \"ProposeLibrary.validateProposal: Invalid or disabled PriceLibrary address\"\n\n        );\n\n\n        // Check that auctionTimeToPivot is greater than or equal to 6 hours\n\n        require(\n\n            _auctionPriceParameters.auctionTimeToPivot >= factoryInstance.minimumTimeToPivot(),\n\n            \"ProposeLibrary.validateProposal: Time to pivot must be greater than minimum\"\n\n        );\n\n\n        // Check that auctionTimeToPivot is less than or equal to 3 days\n\n        require(\n\n            _auctionPriceParameters.auctionTimeToPivot <= factoryInstance.maximumTimeToPivot(),\n\n            \"ProposeLibrary.validateProposal: Time to pivot must be greater than maximum\"\n\n        );\n\n\n        // Check that the proposed set natural unit is a multiple of current set natural unit, or vice versa.\n\n        // Done to make sure that when calculating token units there will are no rounding errors.\n\n        uint256 currentNaturalUnit = ISetToken(_proposalContext.currentSet).naturalUnit();\n\n        uint256 nextSetNaturalUnit = ISetToken(_nextSet).naturalUnit();\n\n        require(\n\n            Math.max(currentNaturalUnit, nextSetNaturalUnit).mod(\n\n                Math.min(currentNaturalUnit, nextSetNaturalUnit)\n\n            ) == 0,\n\n            \"ProposeLibrary.validateProposal: Invalid proposed Set natural unit\"\n\n        );\n\n\n        // Check that pivot price is compliant with library restrictions\n\n        IAuctionPriceCurve(_auctionLibrary).validateAuctionPriceParameters(\n\n            _auctionPriceParameters\n\n        );\n\n    }","contract":"ProposeLibrary","time":0},{"type":"immutable-restrict-modification ","before":"address public core;","after":"address public immutable core;","contract":"RebalancingSetToken","time":1},{"type":"immutable-restrict-modification ","before":"address public factory;","after":"address public immutable factory;","contract":"RebalancingSetToken","time":1},{"type":"immutable-restrict-modification ","before":"address public vault;","after":"address public immutable vault;","contract":"RebalancingSetToken","time":1},{"type":"immutable-restrict-modification ","before":"address public componentWhiteListAddress;","after":"address public immutable componentWhiteListAddress;","contract":"RebalancingSetToken","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public naturalUnit;","after":"uint256 public immutable naturalUnit;","contract":"RebalancingSetToken","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public proposalPeriod;","after":"uint256 public immutable proposalPeriod;","contract":"RebalancingSetToken","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public rebalanceInterval;","after":"uint256 public immutable rebalanceInterval;","contract":"RebalancingSetToken","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"RebalancingSetToken","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"RebalancingSetToken","time":1},{"type":"immutable-restrict-modification ","before":"uint8 private _decimals;","after":"uint8 private immutable _decimals;","contract":"RebalancingSetToken","time":1},{"type":"immutable-restrict-modification ","before":"address public core;","after":"address public immutable core;","contract":"RebalancingSetTokenFactory","time":0},{"type":"immutable-restrict-modification ","before":"address public rebalanceComponentWhitelist;","after":"address public immutable rebalanceComponentWhitelist;","contract":"RebalancingSetTokenFactory","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public minimumRebalanceInterval;","after":"uint256 public immutable minimumRebalanceInterval;","contract":"RebalancingSetTokenFactory","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public minimumProposalPeriod;","after":"uint256 public immutable minimumProposalPeriod;","contract":"RebalancingSetTokenFactory","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public minimumTimeToPivot;","after":"uint256 public immutable minimumTimeToPivot;","contract":"RebalancingSetTokenFactory","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public maximumTimeToPivot;","after":"uint256 public immutable maximumTimeToPivot;","contract":"RebalancingSetTokenFactory","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public minimumNaturalUnit;","after":"uint256 public immutable minimumNaturalUnit;","contract":"RebalancingSetTokenFactory","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public maximumNaturalUnit;","after":"uint256 public immutable maximumNaturalUnit;","contract":"RebalancingSetTokenFactory","time":0}]}