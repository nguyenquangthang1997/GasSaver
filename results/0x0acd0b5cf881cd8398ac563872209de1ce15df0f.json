{"time":215,"results":[{"type":"constant-restrict-modification  ","before":"bytes32 public EIP712_DOMAIN_HASH;","after":"bytes32 public constant EIP712_DOMAIN_HASH;","contract":"LibOrder","time":0},{"type":"loop-calculation","before":"uint256 orderBodyStart;","after":"// move outside for loop\nuint256 orderBodyStart;","loc":{"start":{"line":4497,"column":12},"end":{"line":4497,"column":34}},"contract":"ZeroExExchangeWrapper","time":0},{"type":"external-function ","before":"function exchange(\n\n        ExchangeWrapperLibrary.ExchangeData memory _exchangeData,\n\n        bytes memory _ordersData\n\n    )\n\n    public\n\n    returns (ExchangeWrapperLibrary.ExchangeResults memory)\n\n    {\n\n        require(\n\n            ICore(core).validModules(msg.sender),\n\n            \"ZeroExExchangeWrapper.exchange: Sender must be approved module\"\n\n        );\n\n\n        uint256 tradesCount = _exchangeData.orderCount;\n\n        address[] memory sendTokens = new address[](tradesCount);\n\n        address[] memory receiveTokens = new address[](tradesCount);\n\n        uint256[] memory receiveTokenAmounts = new uint256[](tradesCount);\n\n\n        uint256 scannedBytes = 0;\n\n        for (uint256 i = 0; i < _exchangeData.orderCount; i++) {\n\n            ZeroExOrderLibrary.ZeroExOrderInformation memory orderInformation;\n\n            uint256 orderBodyStart;\n\n\n            // Parse order i's information\n\n            (orderInformation, orderBodyStart) = parseOrderInformation(\n\n                _ordersData,\n\n                scannedBytes\n\n            );\n\n\n            // Track the send tokens to ensure any leftovers are returned to the user\n\n            sendTokens[i] = orderInformation.takerToken;\n\n\n            // Fill the order via the 0x exchange\n\n            (receiveTokens[i], receiveTokenAmounts[i]) = fillZeroExOrder(\n\n                _exchangeData.caller,\n\n                orderInformation\n\n            );\n\n\n            // Ensure the received token can be transfered via the Set transfer proxy\n\n            ERC20Wrapper.ensureAllowance(\n\n                receiveTokens[i],\n\n                address(this),\n\n                setTransferProxy,\n\n                receiveTokenAmounts[i]\n\n            );\n\n\n            // Update current bytes\n\n            scannedBytes = orderBodyStart.add(384);\n\n        }\n\n\n        // Return leftover send tokens to the original caller\n\n        ExchangeWrapperLibrary.returnLeftoverSendTokens(\n\n            sendTokens,\n\n            _exchangeData.caller\n\n        );\n\n\n        return ExchangeWrapperLibrary.ExchangeResults({\n\n        receiveTokens : receiveTokens,\n\n        receiveTokenAmounts : receiveTokenAmounts\n\n        });\n\n    }","after":"function exchange(\n\n        ExchangeWrapperLibrary.ExchangeData calldata _exchangeData,\n\n        bytes calldata _ordersData\n\n    )\n\n    public\n\n    returns (ExchangeWrapperLibrary.ExchangeResults memory)\n\n    {\n\n        require(\n\n            ICore(core).validModules(msg.sender),\n\n            \"ZeroExExchangeWrapper.exchange: Sender must be approved module\"\n\n        );\n\n\n        uint256 tradesCount = _exchangeData.orderCount;\n\n        address[] memory sendTokens = new address[](tradesCount);\n\n        address[] memory receiveTokens = new address[](tradesCount);\n\n        uint256[] memory receiveTokenAmounts = new uint256[](tradesCount);\n\n\n        uint256 scannedBytes = 0;\n\n        for (uint256 i = 0; i < _exchangeData.orderCount; i++) {\n\n            ZeroExOrderLibrary.ZeroExOrderInformation memory orderInformation;\n\n            uint256 orderBodyStart;\n\n\n            // Parse order i's information\n\n            (orderInformation, orderBodyStart) = parseOrderInformation(\n\n                _ordersData,\n\n                scannedBytes\n\n            );\n\n\n            // Track the send tokens to ensure any leftovers are returned to the user\n\n            sendTokens[i] = orderInformation.takerToken;\n\n\n            // Fill the order via the 0x exchange\n\n            (receiveTokens[i], receiveTokenAmounts[i]) = fillZeroExOrder(\n\n                _exchangeData.caller,\n\n                orderInformation\n\n            );\n\n\n            // Ensure the received token can be transfered via the Set transfer proxy\n\n            ERC20Wrapper.ensureAllowance(\n\n                receiveTokens[i],\n\n                address(this),\n\n                setTransferProxy,\n\n                receiveTokenAmounts[i]\n\n            );\n\n\n            // Update current bytes\n\n            scannedBytes = orderBodyStart.add(384);\n\n        }\n\n\n        // Return leftover send tokens to the original caller\n\n        ExchangeWrapperLibrary.returnLeftoverSendTokens(\n\n            sendTokens,\n\n            _exchangeData.caller\n\n        );\n\n\n        return ExchangeWrapperLibrary.ExchangeResults({\n\n        receiveTokens : receiveTokens,\n\n        receiveTokenAmounts : receiveTokenAmounts\n\n        });\n\n    }","contract":"ZeroExExchangeWrapper","time":0},{"type":"immutable-restrict-modification ","before":"address public core;","after":"address public immutable core;","contract":"ZeroExExchangeWrapper","time":0},{"type":"immutable-restrict-modification ","before":"address public zeroExExchange;","after":"address public immutable zeroExExchange;","contract":"ZeroExExchangeWrapper","time":0},{"type":"immutable-restrict-modification ","before":"address public zeroExProxy;","after":"address public immutable zeroExProxy;","contract":"ZeroExExchangeWrapper","time":0},{"type":"immutable-restrict-modification ","before":"address public zeroExToken;","after":"address public immutable zeroExToken;","contract":"ZeroExExchangeWrapper","time":0},{"type":"immutable-restrict-modification ","before":"address public setTransferProxy;","after":"address public immutable setTransferProxy;","contract":"ZeroExExchangeWrapper","time":0}]}