{"time":187,"results":[{"type":"external-function ","before":"function setAddress(\n        string memory _name,\n        address _address\n    )\n    external\n    onlyOwner\n    {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(\n            _name,\n            _address,\n            oldAddress\n        );\n    }","after":"function setAddress(\n        string calldata _name,\n        address _address\n    )\n    external\n    onlyOwner\n    {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(\n            _name,\n            _address,\n            oldAddress\n        );\n    }","contract":"Lib_AddressManager","time":0},{"type":"external-function ","before":"function getAddress(\n        string memory _name\n    )\n    external\n    view\n    returns (\n        address\n    )\n    {\n        return addresses[_getNameHash(_name)];\n    }","after":"function getAddress(\n        string calldata _name\n    )\n    external\n    view\n    returns (\n        address\n    )\n    {\n        return addresses[_getNameHash(_name)];\n    }","contract":"Lib_AddressManager","time":0},{"type":"loop-calculation","before":"uint256 listPtr;","after":"// move outside for loop\nuint256 listPtr;","loc":{"start":{"line":1924,"column":12},"end":{"line":1924,"column":27}},"contract":"Lib_RLPWriter","time":0},{"type":"external-function ","before":"function appendStateBatch(\n        bytes32[] memory _batch,\n        uint256 _shouldStartAtElement\n    )\n    override\n    public\n    {\n        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\n        // publication of batches by some other user.\n        require(\n            _shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );\n\n        // Proposers must have previously staked at the BondManager\n        require(\n            iOVM_BondManager(resolve(\"OVM_BondManager\")).isCollateralized(msg.sender),\n            \"Proposer does not have enough collateral posted\"\n        );\n\n        require(\n            _batch.length > 0,\n            \"Cannot submit an empty state batch.\"\n        );\n\n        require(\n            getTotalElements() + _batch.length <= iOVM_CanonicalTransactionChain(resolve(\"OVM_CanonicalTransactionChain\")).getTotalElements(),\n            \"Number of state roots cannot exceed the number of canonical transactions.\"\n        );\n\n        // Pass the block's timestamp and the publisher of the data\n        // to be used in the fraud proofs\n        _appendBatch(\n            _batch,\n            abi.encode(block.timestamp, msg.sender)\n        );\n    }","after":"function appendStateBatch(\n        bytes32[] calldata _batch,\n        uint256 _shouldStartAtElement\n    )\n    override\n    public\n    {\n        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\n        // publication of batches by some other user.\n        require(\n            _shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );\n\n        // Proposers must have previously staked at the BondManager\n        require(\n            iOVM_BondManager(resolve(\"OVM_BondManager\")).isCollateralized(msg.sender),\n            \"Proposer does not have enough collateral posted\"\n        );\n\n        require(\n            _batch.length > 0,\n            \"Cannot submit an empty state batch.\"\n        );\n\n        require(\n            getTotalElements() + _batch.length <= iOVM_CanonicalTransactionChain(resolve(\"OVM_CanonicalTransactionChain\")).getTotalElements(),\n            \"Number of state roots cannot exceed the number of canonical transactions.\"\n        );\n\n        // Pass the block's timestamp and the publisher of the data\n        // to be used in the fraud proofs\n        _appendBatch(\n            _batch,\n            abi.encode(block.timestamp, msg.sender)\n        );\n    }","contract":"OVM_StateCommitmentChain","time":0},{"type":"external-function ","before":"function deleteStateBatch(\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\n    )\n    override\n    public\n    {\n        require(\n            msg.sender == resolve(\"OVM_FraudVerifier\"),\n            \"State batches can only be deleted by the OVM_FraudVerifier.\"\n        );\n\n        require(\n            _isValidBatchHeader(_batchHeader),\n            \"Invalid batch header.\"\n        );\n\n        require(\n            insideFraudProofWindow(_batchHeader),\n            \"State batches can only be deleted within the fraud proof window.\"\n        );\n\n        _deleteBatch(_batchHeader);\n    }","after":"function deleteStateBatch(\n        Lib_OVMCodec.ChainBatchHeader calldata _batchHeader\n    )\n    override\n    public\n    {\n        require(\n            msg.sender == resolve(\"OVM_FraudVerifier\"),\n            \"State batches can only be deleted by the OVM_FraudVerifier.\"\n        );\n\n        require(\n            _isValidBatchHeader(_batchHeader),\n            \"Invalid batch header.\"\n        );\n\n        require(\n            insideFraudProofWindow(_batchHeader),\n            \"State batches can only be deleted within the fraud proof window.\"\n        );\n\n        _deleteBatch(_batchHeader);\n    }","contract":"OVM_StateCommitmentChain","time":0},{"type":"external-function ","before":"function verifyStateCommitment(\n        bytes32 _element,\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _proof\n    )\n    override\n    public\n    view\n    returns (\n        bool\n    )\n    {\n        require(\n            _isValidBatchHeader(_batchHeader),\n            \"Invalid batch header.\"\n        );\n\n        require(\n            Lib_MerkleTree.verify(\n                _batchHeader.batchRoot,\n                _element,\n                _proof.index,\n                _proof.siblings,\n                _batchHeader.batchSize\n            ),\n            \"Invalid inclusion proof.\"\n        );\n\n        return true;\n    }","after":"function verifyStateCommitment(\n        bytes32 _element,\n        Lib_OVMCodec.ChainBatchHeader calldata _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof calldata _proof\n    )\n    override\n    public\n    view\n    returns (\n        bool\n    )\n    {\n        require(\n            _isValidBatchHeader(_batchHeader),\n            \"Invalid batch header.\"\n        );\n\n        require(\n            Lib_MerkleTree.verify(\n                _batchHeader.batchRoot,\n                _element,\n                _proof.index,\n                _proof.siblings,\n                _batchHeader.batchSize\n            ),\n            \"Invalid inclusion proof.\"\n        );\n\n        return true;\n    }","contract":"OVM_StateCommitmentChain","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public FRAUD_PROOF_WINDOW;","after":"uint256 public immutable FRAUD_PROOF_WINDOW;","contract":"OVM_StateCommitmentChain","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public SEQUENCER_PUBLISH_WINDOW;","after":"uint256 public immutable SEQUENCER_PUBLISH_WINDOW;","contract":"OVM_StateCommitmentChain","time":0}]}