{"time":1140,"results":[{"type":"external-function ","before":"function _becomeImplementation(bytes memory data) public {\n\n        // Shh -- currently unused\n\n        data;\n\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n        require(hasAdminRights(), \"only the admin may call _becomeImplementation\");\n\n    }","after":"function _becomeImplementation(bytes calldata data) public {\n\n        // Shh -- currently unused\n\n        data;\n\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n        require(hasAdminRights(), \"only the admin may call _becomeImplementation\");\n\n    }","contract":"CErc20Delegate","time":0},{"type":"external-function ","before":"function initialize(address underlying_,\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint8 decimals_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, reserveFactorMantissa_, adminFeeMantissa_);\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }","after":"function initialize(address underlying_,\n\n        ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint initialExchangeRateMantissa_,\n\n        string calldata name_,\n\n        string calldata symbol_,\n\n        uint8 decimals_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, reserveFactorMantissa_, adminFeeMantissa_);\n\n\n        // Set underlying and sanity check it\n\n        underlying = underlying_;\n\n        EIP20Interface(underlying).totalSupply();\n\n    }","contract":"CErc20Delegate","time":0},{"type":"external-function ","before":"function initialize(ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint8 decimals_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        require(hasAdminRights(), \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n        // Set reserve factor\n\n        err = _setReserveFactorFresh(reserveFactorMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting reserve factor failed\");\n\n\n        // Set admin fee\n\n        err = _setAdminFeeFresh(adminFeeMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting admin fee failed\");\n\n\n        // Set Fuse fee\n\n        err = _setFuseFeeFresh(getPendingFuseFeeFromAdmin());\n\n        require(err == uint(Error.NO_ERROR), \"setting Fuse fee failed\");\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n\n    }","after":"function initialize(ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint initialExchangeRateMantissa_,\n\n        string calldata name_,\n\n        string calldata symbol_,\n\n        uint8 decimals_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        require(hasAdminRights(), \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n        // Set reserve factor\n\n        err = _setReserveFactorFresh(reserveFactorMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting reserve factor failed\");\n\n\n        // Set admin fee\n\n        err = _setAdminFeeFresh(adminFeeMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting admin fee failed\");\n\n\n        // Set Fuse fee\n\n        err = _setFuseFeeFresh(getPendingFuseFeeFromAdmin());\n\n        require(err == uint(Error.NO_ERROR), \"setting Fuse fee failed\");\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n\n    }","contract":"CErc20Delegate","time":0},{"type":"immutable-restrict-modification ","before":"\n     */\n\n    address payable","after":"\n     */\n\n    address payable","contract":"CErc20Delegator","time":0},{"type":"constant-restrict-modification  ","before":"\n     */\n\n    bool public fuseAdminHas","after":"\n     */\n\n    bool public fuseAdminHas","contract":"CErc20Delegator","time":0},{"type":"constant-restrict-modification  ","before":"\n     */\n\n    bool public adminHas","after":"\n     */\n\n    bool public adminHas","contract":"CErc20Delegator","time":0},{"type":"external-function ","before":"function _becomeImplementation(bytes memory data) public {\n\n        // Shh -- currently unused\n\n        data;\n\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n        require(hasAdminRights(), \"only the admin may call _becomeImplementation\");\n\n    }","after":"function _becomeImplementation(bytes calldata data) public {\n\n        // Shh -- currently unused\n\n        data;\n\n\n        // Shh -- we don't ever want this hook to be marked pure\n\n        if (false) {\n\n            implementation = address(0);\n\n        }\n\n\n        require(hasAdminRights(), \"only the admin may call _becomeImplementation\");\n\n    }","contract":"CEtherDelegate","time":0},{"type":"external-function ","before":"function initialize(ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint8 decimals_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, reserveFactorMantissa_, adminFeeMantissa_);\n\n    }","after":"function initialize(ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint initialExchangeRateMantissa_,\n\n        string calldata name_,\n\n        string calldata symbol_,\n\n        uint8 decimals_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        // CToken initialize does the bulk of the work\n\n        super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_, reserveFactorMantissa_, adminFeeMantissa_);\n\n    }","contract":"CEtherDelegate","time":0},{"type":"external-function ","before":"function initialize(ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint initialExchangeRateMantissa_,\n\n        string memory name_,\n\n        string memory symbol_,\n\n        uint8 decimals_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        require(hasAdminRights(), \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n        // Set reserve factor\n\n        err = _setReserveFactorFresh(reserveFactorMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting reserve factor failed\");\n\n\n        // Set admin fee\n\n        err = _setAdminFeeFresh(adminFeeMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting admin fee failed\");\n\n\n        // Set Fuse fee\n\n        err = _setFuseFeeFresh(getPendingFuseFeeFromAdmin());\n\n        require(err == uint(Error.NO_ERROR), \"setting Fuse fee failed\");\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n\n    }","after":"function initialize(ComptrollerInterface comptroller_,\n\n        InterestRateModel interestRateModel_,\n\n        uint initialExchangeRateMantissa_,\n\n        string calldata name_,\n\n        string calldata symbol_,\n\n        uint8 decimals_,\n\n        uint256 reserveFactorMantissa_,\n\n        uint256 adminFeeMantissa_) public {\n\n        require(hasAdminRights(), \"only admin may initialize the market\");\n\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n\n        // Set initial exchange rate\n\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n\n        // Set the comptroller\n\n        uint err = _setComptroller(comptroller_);\n\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n\n        accrualBlockNumber = getBlockNumber();\n\n        borrowIndex = mantissaOne;\n\n\n        // Set the interest rate model (depends on block number / borrow index)\n\n        err = _setInterestRateModelFresh(interestRateModel_);\n\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n\n        name = name_;\n\n        symbol = symbol_;\n\n        decimals = decimals_;\n\n\n        // Set reserve factor\n\n        err = _setReserveFactorFresh(reserveFactorMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting reserve factor failed\");\n\n\n        // Set admin fee\n\n        err = _setAdminFeeFresh(adminFeeMantissa_);\n\n        require(err == uint(Error.NO_ERROR), \"setting admin fee failed\");\n\n\n        // Set Fuse fee\n\n        err = _setFuseFeeFresh(getPendingFuseFeeFromAdmin());\n\n        require(err == uint(Error.NO_ERROR), \"setting Fuse fee failed\");\n\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n\n        _notEntered = true;\n\n    }","contract":"CEtherDelegate","time":0},{"type":"constant-restrict-modification  ","before":"\n     */\n\n    address publ","after":"\n     */\n\n    address publ","contract":"CEtherDelegate","time":1},{"type":"immutable-restrict-modification ","before":"\n     */\n\n    address payable","after":"\n     */\n\n    address payable","contract":"CEtherDelegator","time":0},{"type":"constant-restrict-modification  ","before":"\n     */\n\n    bool public fuseAdminHas","after":"\n     */\n\n    bool public fuseAdminHas","contract":"CEtherDelegator","time":0},{"type":"constant-restrict-modification  ","before":"\n     */\n\n    bool public adminHas","after":"\n     */\n\n    bool public adminHas","contract":"CEtherDelegator","time":0},{"type":"state-data-arrangement ","before":"\n\n     */\n\n    bool interna\n\n     */\n\n    strin\n\n     */\n\n    string \n\n     */\n\n    uint8 pu\n\n     */\n\n    uint internal constant borrowRateMaxMantiss\n\n     */\n\n    uint internal constant reserveFactorPlusFeesMaxMa\n\n     */\n\n    address payable public\n\n     */\n\n    ComptrollerInterface publi\n\n     */\n\n    InterestRateModel public inte\n\n     */\n\n    uint internal initialExchang\n\n     */\n\n    uint public adm\n\n     */\n\n    uint public fu\n\n     */\n\n    uint public reserveF\n\n     */\n\n    uint public accru\n\n     */\n\n    uint publi\n\n     */\n\n    uint public\n\n     */\n\n    uint public \n\n     */\n\n    uint public t\n\n     */\n\n    uint public \n\n     */\n\n    uint publi\n\n     */\n\n    mapping(address => uint) internal \n\n     */\n\n    mapping(address => mapping(address => uint)) internal trans\n\n     */\n\n    mapping(address => BorrowSnapshot) internal a","after":"\n     */\n\n    strin\n\n     */\n\n    string \n\n     */\n\n    uint internal constant borrowRateMaxMantiss\n\n     */\n\n    uint internal constant reserveFactorPlusFeesMaxMa\n\n     */\n\n    ComptrollerInterface publi\n\n     */\n\n    InterestRateModel public inte\n\n     */\n\n    uint internal initialExchang\n\n     */\n\n    uint public adm\n\n     */\n\n    uint public fu\n\n     */\n\n    uint public reserveF\n\n     */\n\n    uint public accru\n\n     */\n\n    uint publi\n\n     */\n\n    uint public\n\n     */\n\n    uint public \n\n     */\n\n    uint public t\n\n     */\n\n    uint public \n\n     */\n\n    uint publi\n\n     */\n\n    mapping(address => uint) internal \n\n     */\n\n    mapping(address => mapping(address => uint)) internal trans\n\n     */\n\n    mapping(address => BorrowSnapshot) internal a\n\n     */\n\n    address payable public\n\n     */\n\n    bool interna\n\n     */\n\n    uint8 pu\n","contract":"CTokenStorage","time":5},{"type":"de-morgan-condition ","before":"ator;\n\n\n        if (!markets[cTokenBorrowed].isListed || !markets[cToken","after":"!(ator;\n\n\n        if (markets[cTokenBorrowed].isListed || markets[cToken)","loc":{"start":{"line":6445,"column":12},"end":{"line":6445,"column":76}},"contract":"Comptroller","time":0},{"type":"de-morgan-condition ","before":"kens;\n\n\n        if (!markets[cTokenCollateral].isListed || !markets[cTok","after":"!(kens;\n\n\n        if (markets[cTokenCollateral].isListed || markets[cTok)","loc":{"start":{"line":6597,"column":12},"end":{"line":6597,"column":76}},"contract":"Comptroller","time":0},{"type":"de-morgan-condition ","before":"ount;\n\n\n        if (!isBorrow && !markets[address(cTokenModify)].accountMe","after":"!(ount;\n\n\n        if (isBorrow && markets[address(cTokenModify)].accountMe)","loc":{"start":{"line":7136,"column":12},"end":{"line":7136,"column":85}},"contract":"Comptroller","time":0},{"type":"external-function ","before":"\n     */\n\n    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n\n        uint len = cTokens.length;\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            CToken cToken = CToken(cTokens[i]);\n\n\n            results[i] = uint(addToMarketInternal(cToken, msg.sender));\n\n        }\n\n\n        return r","after":"\n     */\n\n    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n\n        uint len = cTokens.length;\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            CToken cToken = CToken(cTokens[i]);\n\n\n            results[i] = uint(addToMarketInternal(cToken, msg.sender));\n\n        }\n\n\n        return r","contract":"Comptroller","time":0},{"type":"constant-restrict-modification  ","before":"hitelist is enforced\n\n    boo","after":"hitelist is enforced\n\n    boo","contract":"Comptroller","time":6},{"type":"constant-restrict-modification  ","before":"ublic pauseGuardian;\n\n    bool p","after":"ublic pauseGuardian;\n\n    bool p","contract":"Comptroller","time":6},{"type":"constant-restrict-modification  ","before":"_mintGuardianPaused;\n\n    bool pub","after":"_mintGuardianPaused;\n\n    bool pub","contract":"Comptroller","time":6},{"type":"immutable-restrict-modification ","before":"his contract\n\n    */\n","after":"his contract\n\n    */\n","contract":"Comptroller","time":6},{"type":"constant-restrict-modification  ","before":"his contract\n\n    */\n\n    ad","after":"his contract\n\n    */\n\n    ad","contract":"Comptroller","time":6},{"type":"constant-restrict-modification  ","before":"dmin rights\n\n     */\n\n    bool public ","after":"dmin rights\n\n     */\n\n    bool public ","contract":"Comptroller","time":6},{"type":"constant-restrict-modification  ","before":"dmin rights\n\n     */\n\n    bool pub","after":"dmin rights\n\n     */\n\n    bool pub","contract":"Comptroller","time":6},{"type":"constant-restrict-modification  ","before":"f Unitroller\n\n    */\n\n    address public ","after":"f Unitroller\n\n    */\n\n    address public ","contract":"Comptroller","time":6},{"type":"constant-restrict-modification  ","before":"f Unitroller\n\n    */\n\n    address public pending","after":"f Unitroller\n\n    */\n\n    address public pending","contract":"Comptroller","time":6},{"type":"de-morgan-condition ","before":"tly unused\n\n\n\n        if (!markets[cTokenBorrowed].isListed || !markets[","after":"!(tly unused\n\n\n\n        if (markets[cTokenBorrowed].isListed || markets[)","loc":{"start":{"line":8735,"column":12},"end":{"line":8735,"column":76}},"contract":"ComptrollerG1","time":0},{"type":"de-morgan-condition ","before":"tly unused\n\n\n\n        if (!markets[cTokenCollateral].isListed || !market","after":"!(tly unused\n\n\n\n        if (markets[cTokenCollateral].isListed || market)","loc":{"start":{"line":8888,"column":12},"end":{"line":8888,"column":76}},"contract":"ComptrollerG1","time":0},{"type":"external-function ","before":"tered\n\n     */\n\n    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n\n        uint len = cTokens.length;\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            CToken cToken = CToken(cTokens[i]);\n\n            Market storage marketToJoin = markets[address(cToken)];\n\n\n            if (!marketToJoin.isListed) {\n\n                // if market is not listed, cannot join move along\n\n                results[i] = uint(Error.MARKET_NOT_LISTED);\n\n                continue;\n\n            }\n\n\n            if (marketToJoin.accountMembership[msg.sender] == true) {\n\n                // if already joined, move along\n\n                results[i] = uint(Error.NO_ERROR);\n\n                continue;\n\n            }\n\n\n            if (accountAssets[msg.sender].length >= maxAssets) {\n\n                // if no space, cannot join, move along\n\n                results[i] = uint(Error.TOO_MANY_ASSETS);\n\n                continue;\n\n            }\n\n\n            // survived the gauntlet, add to list\n\n            // NOTE: we store these somewhat redundantly as a significant optimization\n\n            //  this avoids having to iterate through the list for the most common use cases\n\n            //  that is, only when we need to perform liquidity checks\n\n            //   and not whenever we want to check if an account is in a particular market\n\n            marketToJoin.accountMembership[msg.sender] = true;\n\n            accountAssets[msg.sender].push(cToken);\n\n\n            emit MarketEntered(cToken, msg.sender);\n\n\n            results[i] = uint(Error.NO_ERROR);\n\n        }\n\n\n        re","after":"tered\n\n     */\n\n    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n\n        uint len = cTokens.length;\n\n\n        uint[] memory results = new uint[](len);\n\n        for (uint i = 0; i < len; i++) {\n\n            CToken cToken = CToken(cTokens[i]);\n\n            Market storage marketToJoin = markets[address(cToken)];\n\n\n            if (!marketToJoin.isListed) {\n\n                // if market is not listed, cannot join move along\n\n                results[i] = uint(Error.MARKET_NOT_LISTED);\n\n                continue;\n\n            }\n\n\n            if (marketToJoin.accountMembership[msg.sender] == true) {\n\n                // if already joined, move along\n\n                results[i] = uint(Error.NO_ERROR);\n\n                continue;\n\n            }\n\n\n            if (accountAssets[msg.sender].length >= maxAssets) {\n\n                // if no space, cannot join, move along\n\n                results[i] = uint(Error.TOO_MANY_ASSETS);\n\n                continue;\n\n            }\n\n\n            // survived the gauntlet, add to list\n\n            // NOTE: we store these somewhat redundantly as a significant optimization\n\n            //  this avoids having to iterate through the list for the most common use cases\n\n            //  that is, only when we need to perform liquidity checks\n\n            //   and not whenever we want to check if an account is in a particular market\n\n            marketToJoin.accountMembership[msg.sender] = true;\n\n            accountAssets[msg.sender].push(cToken);\n\n\n            emit MarketEntered(cToken, msg.sender);\n\n\n            results[i] = uint(Error.NO_ERROR);\n\n        }\n\n\n        re","contract":"ComptrollerG1","time":0},{"type":"immutable-restrict-modification ","before":"his contract\n\n    */\n","after":"his contract\n\n    */\n","contract":"ComptrollerG1","time":1},{"type":"constant-restrict-modification  ","before":"his contract\n\n    */\n\n    ad","after":"his contract\n\n    */\n\n    ad","contract":"ComptrollerG1","time":1},{"type":"constant-restrict-modification  ","before":"dmin rights\n\n     */\n\n    bool public ","after":"dmin rights\n\n     */\n\n    bool public ","contract":"ComptrollerG1","time":1},{"type":"constant-restrict-modification  ","before":"dmin rights\n\n     */\n\n    bool pub","after":"dmin rights\n\n     */\n\n    bool pub","contract":"ComptrollerG1","time":1},{"type":"constant-restrict-modification  ","before":"f Unitroller\n\n    */\n\n    address public ","after":"f Unitroller\n\n    */\n\n    address public ","contract":"ComptrollerG1","time":1},{"type":"constant-restrict-modification  ","before":"f Unitroller\n\n    */\n\n    address public pending","after":"f Unitroller\n\n    */\n\n    address public pending","contract":"ComptrollerG1","time":1},{"type":"state-data-arrangement ","before":"\ns supported\n\n     */\n\n    mapping(address \n list of all markets\n\n    C\nany markets\n\n     */\n\n    mapping(address =>\nhave entered markets\n\n    addr\n`allBorrowers` array\n\n    mapping(address => uint256)\nany markets\n\n     */\n\n    mapping(address \nying token addresses\n\n    mapping(address => CToken) p\nhitelist is enforced\n\n    boo\n(i.e., mint cTokens)\n\n    mapping(address \nwhitelisted accounts\n\n    addres\nhitelistArray` array\n\n    mapping(address => uint256) \n by market.\n\n     */\n\n    add\nublic pauseGuardian;\n\n    bool p\n_mintGuardianPaused;\n\n    bool pub\norrowGuardianPaused;\n\n    bool publ\nnsferGuardianPaused;\n\n    bool p\nseizeGuardianPaused;\n\n    mapping(address => bool) \n mintGuardianPaused;\n\n    mapping(address => bool) pu","after":"s supported\n\n     */\n\n    mapping(address \n list of all markets\n\n    C\nany markets\n\n     */\n\n    mapping(address =>\nhave entered markets\n\n    addr\n`allBorrowers` array\n\n    mapping(address => uint256)\nany markets\n\n     */\n\n    mapping(address \nying token addresses\n\n    mapping(address => CToken) p\n(i.e., mint cTokens)\n\n    mapping(address \nwhitelisted accounts\n\n    addres\nhitelistArray` array\n\n    mapping(address => uint256) \nseizeGuardianPaused;\n\n    mapping(address => bool) \n mintGuardianPaused;\n\n    mapping(address => bool) pu\n by market.\n\n     */\n\n    add\nhitelist is enforced\n\n    boo\nublic pauseGuardian;\n\n    bool p\n_mintGuardianPaused;\n\n    bool pub\norrowGuardianPaused;\n\n    bool publ\nnsferGuardianPaused;\n\n    bool p\n","contract":"ComptrollerV2Storage","time":0},{"type":"immutable-restrict-modification ","before":"interest rate\n     */\n    uint ","after":"interest rate\n     */\n    uint ","contract":"JumpRateModel","time":1},{"type":"immutable-restrict-modification ","before":"ion rate is 0\n     */\n    uin","after":"ion rate is 0\n     */\n    uin","contract":"JumpRateModel","time":1},{"type":"immutable-restrict-modification ","before":"ization point\n     */\n    uint publ","after":"ization point\n     */\n    uint publ","contract":"JumpRateModel","time":1},{"type":"immutable-restrict-modification ","before":"er is applied\n   ","after":"er is applied\n   ","contract":"JumpRateModel","time":1},{"type":"immutable-restrict-modification ","before":"the interest rate\n     */\n    u","after":"the interest rate\n     */\n    u","contract":"WhitePaperInterestRateModel","time":0},{"type":"immutable-restrict-modification ","before":"ization rate is 0\n     */\n   ","after":"ization rate is 0\n     */\n   ","contract":"WhitePaperInterestRateModel","time":0}]}