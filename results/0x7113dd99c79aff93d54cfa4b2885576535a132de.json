{"time":194,"results":[{"type":"immutable-restrict-modification ","before":"address target;","after":"address immutable target;","contract":"PartnerRegistry","time":0},{"type":"external-function ","before":"function payout(\n\n        address[] memory tokens,\n\n        uint256[] memory amounts\n\n    ) public {\n\n        uint totalFeePercentage = getTotalFeePercentage();\n\n        address payable companyBeneficiary = companyBeneficiary();\n\n        // Payout both the partner and the company at the same time\n\n        for (uint256 index = 0; index < tokens.length; index++) {\n\n            uint256 partnerAmount = SafeMath.div(SafeMath.mul(amounts[index], partnerPercentage), getTotalFeePercentage());\n\n            uint256 companyAmount = amounts[index] - partnerAmount;\n\n            if (tokens[index] == Utils.eth_address()) {\n\n                partnerBeneficiary.transfer(partnerAmount);\n\n                companyBeneficiary.transfer(companyAmount);\n\n            } else {\n\n                ERC20SafeTransfer.safeTransfer(tokens[index], partnerBeneficiary, partnerAmount);\n\n                ERC20SafeTransfer.safeTransfer(tokens[index], companyBeneficiary, companyAmount);\n\n            }\n\n        }\n\n        emit LogPayout(tokens, amounts);\n\n    }","after":"function payout(\n\n        address[] calldata tokens,\n\n        uint256[] calldata amounts\n\n    ) public {\n\n        uint totalFeePercentage = getTotalFeePercentage();\n\n        address payable companyBeneficiary = companyBeneficiary();\n\n        // Payout both the partner and the company at the same time\n\n        for (uint256 index = 0; index < tokens.length; index++) {\n\n            uint256 partnerAmount = SafeMath.div(SafeMath.mul(amounts[index], partnerPercentage), getTotalFeePercentage());\n\n            uint256 companyAmount = amounts[index] - partnerAmount;\n\n            if (tokens[index] == Utils.eth_address()) {\n\n                partnerBeneficiary.transfer(partnerAmount);\n\n                companyBeneficiary.transfer(companyAmount);\n\n            } else {\n\n                ERC20SafeTransfer.safeTransfer(tokens[index], partnerBeneficiary, partnerAmount);\n\n                ERC20SafeTransfer.safeTransfer(tokens[index], companyBeneficiary, companyAmount);\n\n            }\n\n        }\n\n        emit LogPayout(tokens, amounts);\n\n    }","contract":"Partner","time":0},{"type":"struct-data-arrangement ","before":"\naddress sourceToken\naddress destinationToken\nuint256 amount\nbool isSourceAmount\nOrder[] orders","after":"uint256 amount\nOrder[] orders\naddress sourceToken\naddress destinationToken\nbool isSourceAmount\n","contract":"TotlePrimary","time":0},{"type":"struct-data-arrangement ","before":"\nSwap[] swaps\naddress payable partnerContract\nuint256 expirationBlock\nbytes32 id\nuint256 maxGasPrice\nuint8 v\nbytes32 r\nbytes32 s","after":"Swap[] swaps\nuint256 expirationBlock\nbytes32 id\nuint256 maxGasPrice\nbytes32 r\nbytes32 s\naddress payable partnerContract\nuint8 v\n","contract":"TotlePrimary","time":0},{"type":"external-function ","before":"function performSwapCollection(SwapCollection memory swaps)\n\n    public\n\n    payable\n\n    whenNotPaused\n\n    notExpired(swaps)\n\n    validSignature(swaps)\n\n    notAboveMaxGas(swaps)\n\n    {\n\n        uint256 startingGas = 0;\n\n        if (tx.gasprice >= MIN_REFUND_GAS_PRICE) {\n\n            startingGas = gasleft();\n\n        }\n\n\n        TokenBalanceLibrary.TokenBalance[20] memory balances;\n\n        balances[0] = TokenBalanceLibrary.TokenBalance(\n\n            address(Utils.eth_address()),\n\n            msg.value\n\n        );\n\n        for (\n\n            uint256 swapIndex = 0;\n\n            swapIndex < swaps.swaps.length;\n\n            swapIndex++\n\n        ) {\n\n            performSwap(\n\n                swaps.id,\n\n                swaps.swaps[swapIndex],\n\n                balances,\n\n                swaps.partnerContract\n\n            );\n\n        }\n\n        emit LogSwapCollection(swaps.id, swaps.partnerContract, msg.sender);\n\n        transferAllTokensToUser(balances);\n\n        if (startingGas > 0) {\n\n            refundGas(startingGas);\n\n        }\n\n    }","after":"function performSwapCollection(SwapCollection calldata swaps)\n\n    public\n\n    payable\n\n    whenNotPaused\n\n    notExpired(swaps)\n\n    validSignature(swaps)\n\n    notAboveMaxGas(swaps)\n\n    {\n\n        uint256 startingGas = 0;\n\n        if (tx.gasprice >= MIN_REFUND_GAS_PRICE) {\n\n            startingGas = gasleft();\n\n        }\n\n\n        TokenBalanceLibrary.TokenBalance[20] memory balances;\n\n        balances[0] = TokenBalanceLibrary.TokenBalance(\n\n            address(Utils.eth_address()),\n\n            msg.value\n\n        );\n\n        for (\n\n            uint256 swapIndex = 0;\n\n            swapIndex < swaps.swaps.length;\n\n            swapIndex++\n\n        ) {\n\n            performSwap(\n\n                swaps.id,\n\n                swaps.swaps[swapIndex],\n\n                balances,\n\n                swaps.partnerContract\n\n            );\n\n        }\n\n        emit LogSwapCollection(swaps.id, swaps.partnerContract, msg.sender);\n\n        transferAllTokensToUser(balances);\n\n        if (startingGas > 0) {\n\n            refundGas(startingGas);\n\n        }\n\n    }","contract":"TotlePrimary","time":0}]}