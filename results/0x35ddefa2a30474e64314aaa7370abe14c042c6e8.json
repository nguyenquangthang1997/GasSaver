{"time":2260,"results":[{"type":"external-function ","before":"    function marketSellOrdersFillOrKill(LibOrder.Order[] memory orders, bytes[] memory signatures, uint256 takerAssetFillAmount, uint256 protocolFee) public returns (uint256[2] memory) {\n\n        require(orders.length > 0, \"At least one order and matching signature is required.\");\n\n        require(orders.length == signatures.length, \"Mismatch between number of orders and signatures.\");\n\n        require(takerAssetFillAmount > 0, \"Taker asset fill amount must be greater than 0.\");\n\n        LibFillResults.FillResults memory fillResults = _exchange.marketSellOrdersFillOrKill.value(protocolFee)(orders, takerAssetFillAmount, signatures);\n\n        return [fillResults.takerAssetFilledAmount, fillResults.makerAssetFilledAmount];\n\n ","after":"    function marketSellOrdersFillOrKill(LibOrder.Order[] calldata orders, bytes[] calldata signatures, uint256 takerAssetFillAmount, uint256 protocolFee) public returns (uint256[2] memory) {\n\n        require(orders.length > 0, \"At least one order and matching signature is required.\");\n\n        require(orders.length == signatures.length, \"Mismatch between number of orders and signatures.\");\n\n        require(takerAssetFillAmount > 0, \"Taker asset fill amount must be greater than 0.\");\n\n        LibFillResults.FillResults memory fillResults = _exchange.marketSellOrdersFillOrKill.value(protocolFee)(orders, takerAssetFillAmount, signatures);\n\n        return [fillResults.takerAssetFilledAmount, fillResults.makerAssetFilledAmount];\n\n ","contract":"ZeroExExchangeController","time":0},{"type":"external-function ","before":"    function marketBuyOrdersFillOrKill(LibOrder.Order[] memory orders, bytes[] memory signatures, uint256 makerAssetFillAmount, uint256 protocolFee) public returns (uint256[2] memory) {\n\n        require(orders.length > 0, \"At least one order and matching signature is required.\");\n\n        require(orders.length == signatures.length, \"Mismatch between number of orders and signatures.\");\n\n        require(makerAssetFillAmount > 0, \"Maker asset fill amount must be greater than 0.\");\n\n        LibFillResults.FillResults memory fillResults = _exchange.marketBuyOrdersFillOrKill.value(protocolFee)(orders, makerAssetFillAmount, signatures);\n\n        return [fillResults.takerAssetFilledAmount, fillResults.makerAssetFilledAmount];\n\n ","after":"    function marketBuyOrdersFillOrKill(LibOrder.Order[] calldata orders, bytes[] calldata signatures, uint256 makerAssetFillAmount, uint256 protocolFee) public returns (uint256[2] memory) {\n\n        require(orders.length > 0, \"At least one order and matching signature is required.\");\n\n        require(orders.length == signatures.length, \"Mismatch between number of orders and signatures.\");\n\n        require(makerAssetFillAmount > 0, \"Maker asset fill amount must be greater than 0.\");\n\n        LibFillResults.FillResults memory fillResults = _exchange.marketBuyOrdersFillOrKill.value(protocolFee)(orders, makerAssetFillAmount, signatures);\n\n        return [fillResults.takerAssetFilledAmount, fillResults.makerAssetFilledAmount];\n\n ","contract":"ZeroExExchangeController","time":0},{"type":"external-function ","before":"\n    function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\n\n        _name = name;\n\n        _symbol = symbol;\n\n        _decimals = decimals;\n\n","after":"\n    function initialize(string calldata name, string calldata symbol, uint8 decimals) public initializer {\n\n        _name = name;\n\n        _symbol = symbol;\n\n        _decimals = decimals;\n\n","contract":"RariFundToken","time":0},{"type":"struct-data-arrangement ","before":"\n       addre\n       BassetStatus\n       bool isTransferFee\n       uint25\n       uint256 ma\n       uint256 vault","after":"       BassetStatus\n       uint25\n       uint256 ma\n       uint256 vault\n       addre\n       bool isTransferFee\n","contract":"MassetStructs","time":0},{"type":"loop-duplication","before":"\nstart line 11344 column 8, end line 11344 column 129\n\n        for (uint256 i = 0; i < _supportedCurrencies.length; i++) if (_acceptedCurrencies[_supportedCurrencies[i]]) array\nstart line 11351 column 8, end line 11357 column 8\n\n        for (uint256 i = 0; i < _supportedCurrencies.length; i++) if (_acceptedCurrencies[_supportedCurrencies[i]]) {\n\n            acceptedCurrencies[index] = _supportedCurrencies[i];\n\n            index++;\n\n","after":"// merge loop\n\nstart line 11344 column 8, end line 11344 column 129\n\n        for (uint256 i = 0; i < _supportedCurrencies.length; i++) if (_acceptedCurrencies[_supportedCurrencies[i]]) array\nstart line 11351 column 8, end line 11357 column 8\n\n        for (uint256 i = 0; i < _supportedCurrencies.length; i++) if (_acceptedCurrencies[_supportedCurrencies[i]]) {\n\n            acceptedCurrencies[index] = _supportedCurrencies[i];\n\n            index++;\n\n","contract":"RariFundManager","time":0},{"type":"constant-restrict-modification  ","before":"ract {\n\n    uint256 public e","after":"ract {\n\n    uint256 public e","contract":"ISavingsContract","time":0},{"type":"state-data-arrangement ","before":"\n\n\n     */\n\n    bool public constant IS_RARI_FUND_CON\n\n\n     */\n\n    bool publi\n\n\n     */\n\n    address private _rariFundM\n\n\n     */\n\n    RariFundManager public r\n\n\n     */\n\n    address private _rariFundReb\n\n\n     */\n\n    string[] private _suppo\n\n\n     */\n\n    mapping(string => uint8) private _c\n\n\n     */\n\n    mapping(string => uint256) private _cu\n\n\n     */\n\n    mapping(string => address) private _\n\n\n     */\n\n    mapping(string => LiquidityPool[]) private _p\n\n\n     */\n\n    mapping(string => mapping(uint8 => bool)) _\n\n\n     */\n\n    uint16 _aa\n\n\n     */\n\n    uint256 private _dail\n\n\n     */\n\n    CurrencyExchangeLoss[] private _l","after":"\n\n     */\n\n    RariFundManager public r\n\n\n     */\n\n    string[] private _suppo\n\n\n     */\n\n    mapping(string => uint8) private _c\n\n\n     */\n\n    mapping(string => uint256) private _cu\n\n\n     */\n\n    mapping(string => address) private _\n\n\n     */\n\n    mapping(string => LiquidityPool[]) private _p\n\n\n     */\n\n    mapping(string => mapping(uint8 => bool)) _\n\n\n     */\n\n    uint256 private _dail\n\n\n     */\n\n    CurrencyExchangeLoss[] private _l\n\n\n     */\n\n    address private _rariFundM\n\n\n     */\n\n    address private _rariFundReb\n\n\n     */\n\n    uint16 _aa\n\n\n     */\n\n    bool public constant IS_RARI_FUND_CON\n\n\n     */\n\n    bool publi\n","contract":"RariFundController","time":0},{"type":"external-function ","before":"\n\n     */\n\n    function getPoolBalance(LiquidityPool pool, string memory currencyCode) public returns (uint256) {\n\n        if (!_poolsWithFunds[currencyCode][uint8(pool)]) return 0;\n\n        return _getPoolBalance(pool, curren","after":"\n\n     */\n\n    function getPoolBalance(LiquidityPool pool, string memory currencyCode) public returns (uint256) {\n\n        if (!_poolsWithFunds[currencyCode][uint8(pool)]) return 0;\n\n        return _getPoolBalance(pool, curren","contract":"RariFundController","time":0},{"type":"external-function ","before":"\n\n     */\n\n    function marketSell0xOrdersFillOrKill(string memory inputCurrencyCode, string memory outputCurrencyCode, LibOrder.Order[] memory orders, bytes[] memory signatures, uint256 takerAssetFillAmount) public payable fundEnabled onlyRebalancer {\n\n        // Check if input is a supported stablecoin and make sure output is a supported stablecoin\n\n        address inputErc20Contract = _erc20Contracts[inputCurrencyCode];\n\n        address outputErc20Contract = _erc20Contracts[outputCurrencyCode];\n\n        require(outputErc20Contract != address(0), \"Invalid output currency code.\");\n\n\n        // Check orders (if inputting a supported stablecoin)\n\n        if (inputErc20Contract != address(0)) for (uint256 i = 0; i < orders.length; i++) {\n\n            address takerAssetAddress = ZeroExExchangeController.decodeTokenAddress(orders[i].takerAssetData);\n\n            require(inputErc20Contract == takerAssetAddress, \"Not all input assets correspond to input currency code.\");\n\n            address makerAssetAddress = ZeroExExchangeController.decodeTokenAddress(orders[i].makerAssetData);\n\n            require(outputErc20Contract == makerAssetAddress, \"Not all output assets correspond to output currency code.\");\n\n            if (orders[i].takerFee > 0) require(orders[i].takerFeeAssetData.length == 0, \"Taker fees are not supported.\");\n            // TODO: Support orders with taker fees (need to include taker fees in loss calculation)\n\n        }\n\n\n        // Get prices and raw fund balance before exchange\n\n        uint256[] memory pricesInUsd;\n\n        uint256 rawFundBalanceBeforeExchange;\n\n\n        if (inputErc20Contract != address(0)) {\n\n            pricesInUsd = rariFundManager.rariFundPriceConsumer().getCurrencyPricesInUsd();\n\n            rawFundBalanceBeforeExchange = rariFundManager.getRawFundBalance(pricesInUsd);\n\n        }\n\n\n        // Market sell\n\n        uint256[2] memory filledAmounts = ZeroExExchangeController.marketSellOrdersFillOrKill(orders, signatures, takerAssetFillAmount, msg.value);\n\n\n        // Check 24-hour loss rate limit (if inputting a supported stablecoin)\n\n        uint256 inputFilledAmountUsd = 0;\n\n        uint256 outputFilledAmountUsd = 0;\n\n\n        if (inputErc20Contract != address(0)) {\n\n            inputFilledAmountUsd = toUsd(inputCurrencyCode, filledAmounts[0], pricesInUsd);\n\n            outputFilledAmountUsd = toUsd(inputCurrencyCode, filledAmounts[1], pricesInUsd);\n\n            handleExchangeLoss(inputFilledAmountUsd, outputFilledAmountUsd, rawFundBalanceBeforeExchange);\n\n        }\n\n\n        // Emit event\n\n        emit CurrencyTrade(inputCurrencyCode, outputCurrencyCode, filledAmounts[0], inputFilledAmountUsd, filledAmounts[1], outputFilledAmountUsd, CurrencyExchange.ZeroEx);\n\n\n        // Refund unused ETH\n\n        uint256 ethBalance = address(this).balance;\n\n\n        if (ethBalance > 0) {\n\n            (bool success,) = msg.sender.call.value(ethBalance)(\"\");\n\n            require(success, \"Failed to transfer ETH to msg.sender after exchange.\");\n\n ","after":"\n\n     */\n\n    function marketSell0xOrdersFillOrKill(string calldata inputCurrencyCode, string calldata outputCurrencyCode, LibOrder.Order[] calldata orders, bytes[] calldata signatures, uint256 takerAssetFillAmount) public payable fundEnabled onlyRebalancer {\n\n        // Check if input is a supported stablecoin and make sure output is a supported stablecoin\n\n        address inputErc20Contract = _erc20Contracts[inputCurrencyCode];\n\n        address outputErc20Contract = _erc20Contracts[outputCurrencyCode];\n\n        require(outputErc20Contract != address(0), \"Invalid output currency code.\");\n\n\n        // Check orders (if inputting a supported stablecoin)\n\n        if (inputErc20Contract != address(0)) for (uint256 i = 0; i < orders.length; i++) {\n\n            address takerAssetAddress = ZeroExExchangeController.decodeTokenAddress(orders[i].takerAssetData);\n\n            require(inputErc20Contract == takerAssetAddress, \"Not all input assets correspond to input currency code.\");\n\n            address makerAssetAddress = ZeroExExchangeController.decodeTokenAddress(orders[i].makerAssetData);\n\n            require(outputErc20Contract == makerAssetAddress, \"Not all output assets correspond to output currency code.\");\n\n            if (orders[i].takerFee > 0) require(orders[i].takerFeeAssetData.length == 0, \"Taker fees are not supported.\");\n            // TODO: Support orders with taker fees (need to include taker fees in loss calculation)\n\n        }\n\n\n        // Get prices and raw fund balance before exchange\n\n        uint256[] memory pricesInUsd;\n\n        uint256 rawFundBalanceBeforeExchange;\n\n\n        if (inputErc20Contract != address(0)) {\n\n            pricesInUsd = rariFundManager.rariFundPriceConsumer().getCurrencyPricesInUsd();\n\n            rawFundBalanceBeforeExchange = rariFundManager.getRawFundBalance(pricesInUsd);\n\n        }\n\n\n        // Market sell\n\n        uint256[2] memory filledAmounts = ZeroExExchangeController.marketSellOrdersFillOrKill(orders, signatures, takerAssetFillAmount, msg.value);\n\n\n        // Check 24-hour loss rate limit (if inputting a supported stablecoin)\n\n        uint256 inputFilledAmountUsd = 0;\n\n        uint256 outputFilledAmountUsd = 0;\n\n\n        if (inputErc20Contract != address(0)) {\n\n            inputFilledAmountUsd = toUsd(inputCurrencyCode, filledAmounts[0], pricesInUsd);\n\n            outputFilledAmountUsd = toUsd(inputCurrencyCode, filledAmounts[1], pricesInUsd);\n\n            handleExchangeLoss(inputFilledAmountUsd, outputFilledAmountUsd, rawFundBalanceBeforeExchange);\n\n        }\n\n\n        // Emit event\n\n        emit CurrencyTrade(inputCurrencyCode, outputCurrencyCode, filledAmounts[0], inputFilledAmountUsd, filledAmounts[1], outputFilledAmountUsd, CurrencyExchange.ZeroEx);\n\n\n        // Refund unused ETH\n\n        uint256 ethBalance = address(this).balance;\n\n\n        if (ethBalance > 0) {\n\n            (bool success,) = msg.sender.call.value(ethBalance)(\"\");\n\n            require(success, \"Failed to transfer ETH to msg.sender after exchange.\");\n\n ","contract":"RariFundController","time":0},{"type":"external-function ","before":".\n\n     */\n\n    function exchangeAndDeposit(address inputErc20Contract, uint256 inputAmount, string memory outputCurrencyCode, LibOrder.Order[] memory orders, bytes[] memory signatures, uint256 takerAssetFillAmount) public payable {\n\n        // Input validation\n\n        require(_rariFundManagerContract != address(0), \"Fund manager contract not set. This may be due to an upgrade of this proxy contract.\");\n\n        require(inputAmount > 0, \"Input amount must be greater than 0.\");\n\n        address outputErc20Contract = _erc20Contracts[outputCurrencyCode];\n\n        require(outputErc20Contract != address(0), \"Invalid output currency code.\");\n\n        require(inputErc20Contract != outputErc20Contract, \"Input and output currencies cannot be the same.\");\n\n        require(orders.length > 0, \"Orders array is empty.\");\n\n        require(orders.length == signatures.length, \"Length of orders and signatures arrays must be equal.\");\n\n        require(takerAssetFillAmount > 0, \"Taker asset fill amount must be greater than 0.\");\n\n\n        if (inputErc20Contract == address(0)) {\n\n            // Wrap ETH\n\n            _weth.deposit.value(inputAmount)();\n\n        } else {\n\n            // Transfer input tokens from msg.sender if not inputting ETH\n\n            IERC20(inputErc20Contract).safeTransferFrom(msg.sender, address(this), inputAmount);\n            // The user must approve the transfer of tokens beforehand\n\n        }\n\n\n        // Approve and exchange tokens\n\n        if (inputAmount > ZeroExExchangeController.allowance(inputErc20Contract == address(0) ? WETH_CONTRACT : inputErc20Contract)) ZeroExExchangeController.approve(inputErc20Contract == address(0) ? WETH_CONTRACT : inputErc20Contract, uint256(- 1));\n\n        uint256[2] memory filledAmounts = ZeroExExchangeController.marketSellOrdersFillOrKill(orders, signatures, takerAssetFillAmount, inputErc20Contract == address(0) ? msg.value.sub(inputAmount) : msg.value);\n\n\n        if (inputErc20Contract == address(0)) {\n\n            // Unwrap unused ETH\n\n            uint256 wethBalance = _weth.balanceOf(address(this));\n\n            if (wethBalance > 0) _weth.withdraw(wethBalance);\n\n        } else {\n\n            // Refund unused input tokens\n\n            IERC20 inputToken = IERC20(inputErc20Contract);\n\n            uint256 inputTokenBalance = inputToken.balanceOf(address(this));\n\n            if (inputTokenBalance > 0) inputToken.safeTransfer(msg.sender, inputTokenBalance);\n\n        }\n\n\n        // Emit event\n\n        emit PreDepositExchange(inputErc20Contract, outputCurrencyCode, msg.sender, filledAmounts[0], filledAmounts[1]);\n\n\n        // Deposit output tokens\n\n        rariFundManager.depositTo(msg.sender, outputCurrencyCode, filledAmounts[1]);\n\n\n        // Refund unused ETH\n\n        uint256 ethBalance = address(this).balance;\n\n\n        if (ethBalance > 0) {\n\n            (bool success,) = msg.sender.call.value(ethBalance)(\"\");\n\n            require(success, \"Failed to transfer ETH to msg.sender after exchange.\");\n\n","after":".\n\n     */\n\n    function exchangeAndDeposit(address inputErc20Contract, uint256 inputAmount, string calldata outputCurrencyCode, LibOrder.Order[] calldata orders, bytes[] calldata signatures, uint256 takerAssetFillAmount) public payable {\n\n        // Input validation\n\n        require(_rariFundManagerContract != address(0), \"Fund manager contract not set. This may be due to an upgrade of this proxy contract.\");\n\n        require(inputAmount > 0, \"Input amount must be greater than 0.\");\n\n        address outputErc20Contract = _erc20Contracts[outputCurrencyCode];\n\n        require(outputErc20Contract != address(0), \"Invalid output currency code.\");\n\n        require(inputErc20Contract != outputErc20Contract, \"Input and output currencies cannot be the same.\");\n\n        require(orders.length > 0, \"Orders array is empty.\");\n\n        require(orders.length == signatures.length, \"Length of orders and signatures arrays must be equal.\");\n\n        require(takerAssetFillAmount > 0, \"Taker asset fill amount must be greater than 0.\");\n\n\n        if (inputErc20Contract == address(0)) {\n\n            // Wrap ETH\n\n            _weth.deposit.value(inputAmount)();\n\n        } else {\n\n            // Transfer input tokens from msg.sender if not inputting ETH\n\n            IERC20(inputErc20Contract).safeTransferFrom(msg.sender, address(this), inputAmount);\n            // The user must approve the transfer of tokens beforehand\n\n        }\n\n\n        // Approve and exchange tokens\n\n        if (inputAmount > ZeroExExchangeController.allowance(inputErc20Contract == address(0) ? WETH_CONTRACT : inputErc20Contract)) ZeroExExchangeController.approve(inputErc20Contract == address(0) ? WETH_CONTRACT : inputErc20Contract, uint256(- 1));\n\n        uint256[2] memory filledAmounts = ZeroExExchangeController.marketSellOrdersFillOrKill(orders, signatures, takerAssetFillAmount, inputErc20Contract == address(0) ? msg.value.sub(inputAmount) : msg.value);\n\n\n        if (inputErc20Contract == address(0)) {\n\n            // Unwrap unused ETH\n\n            uint256 wethBalance = _weth.balanceOf(address(this));\n\n            if (wethBalance > 0) _weth.withdraw(wethBalance);\n\n        } else {\n\n            // Refund unused input tokens\n\n            IERC20 inputToken = IERC20(inputErc20Contract);\n\n            uint256 inputTokenBalance = inputToken.balanceOf(address(this));\n\n            if (inputTokenBalance > 0) inputToken.safeTransfer(msg.sender, inputTokenBalance);\n\n        }\n\n\n        // Emit event\n\n        emit PreDepositExchange(inputErc20Contract, outputCurrencyCode, msg.sender, filledAmounts[0], filledAmounts[1]);\n\n\n        // Deposit output tokens\n\n        rariFundManager.depositTo(msg.sender, outputCurrencyCode, filledAmounts[1]);\n\n\n        // Refund unused ETH\n\n        uint256 ethBalance = address(this).balance;\n\n\n        if (ethBalance > 0) {\n\n            (bool success,) = msg.sender.call.value(ethBalance)(\"\");\n\n            require(success, \"Failed to transfer ETH to msg.sender after exchange.\");\n\n","contract":"RariFundProxy","time":0},{"type":"external-function ","before":".\n\n     */\n\n    function withdrawAndExchange(string[] memory inputCurrencyCodes, uint256[] memory inputAmounts, address outputErc20Contract, LibOrder.Order[][] memory orders, bytes[][] memory signatures, uint256[] memory makerAssetFillAmounts, uint256[] memory protocolFees) public payable {\n\n        // Input validation\n\n        require(_rariFundManagerContract != address(0), \"Fund manager contract not set. This may be due to an upgrade of this proxy contract.\");\n\n        require(inputCurrencyCodes.length == inputAmounts.length && inputCurrencyCodes.length == orders.length && inputCurrencyCodes.length == signatures.length && inputCurrencyCodes.length == makerAssetFillAmounts.length && inputCurrencyCodes.length == protocolFees.length, \"Array parameters are not all the same length.\");\n\n\n        // Withdraw input tokens\n\n        uint256[] memory inputAmountsAfterFees = rariFundManager.withdrawFrom(msg.sender, inputCurrencyCodes, inputAmounts);\n\n\n        // For each input currency\n\n        for (uint256 i = 0; i < inputCurrencyCodes.length; i++) {\n\n            // Input validation\n\n            address inputErc20Contract = _erc20Contracts[inputCurrencyCodes[i]];\n\n            require(inputErc20Contract != address(0), \"One or more input currency codes are invalid.\");\n\n            require(inputAmounts[i] > 0 && inputAmountsAfterFees[i] > 0, \"All input amounts (before and after the withdrawal fee) must be greater than 0.\");\n\n\n            if (inputErc20Contract != outputErc20Contract) {\n\n                // Exchange input tokens for output tokens\n\n                if (orders[i].length > 0 && signatures[i].length > 0 && makerAssetFillAmounts[i] > 0) {\n\n                    // Input validation\n\n                    require(orders.length == signatures.length, \"Lengths of all orders and signatures arrays must be equal.\");\n\n\n                    // Exchange tokens and emit event\n\n                    if (inputAmountsAfterFees[i] < inputAmounts[i]) makerAssetFillAmounts[i] = makerAssetFillAmounts[i].mul(inputAmountsAfterFees[i]).div(inputAmounts[i]);\n\n                    uint256[2] memory filledAmounts = ZeroExExchangeController.marketBuyOrdersFillOrKill(orders[i], signatures[i], makerAssetFillAmounts[i], protocolFees[i]);\n\n                    emit PostWithdrawalExchange(inputCurrencyCodes[i], outputErc20Contract, msg.sender, inputAmounts[i], inputAmountsAfterFees[i], filledAmounts[1]);\n\n                } else if ((_mStableExchangeErc20Contracts[inputErc20Contract] || inputErc20Contract == 0xe2f2a5C287993345a840Db3B0845fbC70f5935a5) && (_mStableExchangeErc20Contracts[outputErc20Contract] || outputErc20Contract == 0xe2f2a5C287993345a840Db3B0845fbC70f5935a5)) {\n\n                    // Mint, redeem, or swap via mUSD\n\n                    uint256 realOutputAmount;\n\n\n                    if (inputErc20Contract == 0xe2f2a5C287993345a840Db3B0845fbC70f5935a5) {\n\n                        uint256 outputDecimals = _erc20Decimals[outputErc20Contract];\n\n                        uint256 outputAmount = 18 >= outputDecimals ? inputAmountsAfterFees[i].div(10 ** (uint256(18).sub(outputDecimals))) : inputAmountsAfterFees[i].mul(10 ** (outputDecimals.sub(18)));\n\n                        MStableExchangeController.redeem(outputErc20Contract, outputAmount);\n\n                        realOutputAmount = outputAmount.sub(outputAmount.mul(MStableExchangeController.getSwapFee()).div(1e18));\n\n                    } else if (outputErc20Contract == 0xe2f2a5C287993345a840Db3B0845fbC70f5935a5) {\n\n                        realOutputAmount = MStableExchangeController.mint(inputErc20Contract, inputAmountsAfterFees[i]);\n\n                    } else {\n\n                        uint256 outputAmount = MStableExchangeController.swap(inputErc20Contract, outputErc20Contract, inputAmountsAfterFees[i]);\n\n                        realOutputAmount = outputAmount.sub(outputAmount.mul(MStableExchangeController.getSwapFee()).div(1e18));\n\n                    }\n\n\n                    emit PostWithdrawalExchange(inputCurrencyCodes[i], outputErc20Contract, msg.sender, inputAmounts[i], inputAmountsAfterFees[i], realOutputAmount);\n\n                } else revert(\"No 0x orders supplied and exchange not supported via mStable for at least one currency pair.\");\n\n            }\n\n        }\n\n\n        if (outputErc20Contract == address(0)) {\n\n            // Unwrap WETH if output currency is ETH\n\n            uint256 wethBalance = _weth.balanceOf(address(this));\n\n            _weth.withdraw(wethBalance);\n\n        } else {\n\n            // Forward tokens if output currency is a token\n\n            IERC20 outputToken = IERC20(outputErc20Contract);\n\n            uint256 outputTokenBalance = outputToken.balanceOf(address(this));\n\n            if (outputTokenBalance > 0) outputToken.safeTransfer(msg.sender, outputTokenBalance);\n\n        }\n\n\n        // Forward all ETH\n\n        uint256 ethBalance = address(this).balance;\n\n\n        if (ethBalance > 0) {\n\n            (bool success,) = msg.sender.call.value(ethBalance)(\"\");\n\n            require(success, \"Failed to transfer ETH to msg.sender after exchange.\");\n\n","after":".\n\n     */\n\n    function withdrawAndExchange(string[] calldata inputCurrencyCodes, uint256[] calldata inputAmounts, address outputErc20Contract, LibOrder.Order[][] calldata orders, bytes[][] calldata signatures, uint256[] calldata makerAssetFillAmounts, uint256[] memory protocolFees) public payable {\n\n        // Input validation\n\n        require(_rariFundManagerContract != address(0), \"Fund manager contract not set. This may be due to an upgrade of this proxy contract.\");\n\n        require(inputCurrencyCodes.length == inputAmounts.length && inputCurrencyCodes.length == orders.length && inputCurrencyCodes.length == signatures.length && inputCurrencyCodes.length == makerAssetFillAmounts.length && inputCurrencyCodes.length == protocolFees.length, \"Array parameters are not all the same length.\");\n\n\n        // Withdraw input tokens\n\n        uint256[] memory inputAmountsAfterFees = rariFundManager.withdrawFrom(msg.sender, inputCurrencyCodes, inputAmounts);\n\n\n        // For each input currency\n\n        for (uint256 i = 0; i < inputCurrencyCodes.length; i++) {\n\n            // Input validation\n\n            address inputErc20Contract = _erc20Contracts[inputCurrencyCodes[i]];\n\n            require(inputErc20Contract != address(0), \"One or more input currency codes are invalid.\");\n\n            require(inputAmounts[i] > 0 && inputAmountsAfterFees[i] > 0, \"All input amounts (before and after the withdrawal fee) must be greater than 0.\");\n\n\n            if (inputErc20Contract != outputErc20Contract) {\n\n                // Exchange input tokens for output tokens\n\n                if (orders[i].length > 0 && signatures[i].length > 0 && makerAssetFillAmounts[i] > 0) {\n\n                    // Input validation\n\n                    require(orders.length == signatures.length, \"Lengths of all orders and signatures arrays must be equal.\");\n\n\n                    // Exchange tokens and emit event\n\n                    if (inputAmountsAfterFees[i] < inputAmounts[i]) makerAssetFillAmounts[i] = makerAssetFillAmounts[i].mul(inputAmountsAfterFees[i]).div(inputAmounts[i]);\n\n                    uint256[2] memory filledAmounts = ZeroExExchangeController.marketBuyOrdersFillOrKill(orders[i], signatures[i], makerAssetFillAmounts[i], protocolFees[i]);\n\n                    emit PostWithdrawalExchange(inputCurrencyCodes[i], outputErc20Contract, msg.sender, inputAmounts[i], inputAmountsAfterFees[i], filledAmounts[1]);\n\n                } else if ((_mStableExchangeErc20Contracts[inputErc20Contract] || inputErc20Contract == 0xe2f2a5C287993345a840Db3B0845fbC70f5935a5) && (_mStableExchangeErc20Contracts[outputErc20Contract] || outputErc20Contract == 0xe2f2a5C287993345a840Db3B0845fbC70f5935a5)) {\n\n                    // Mint, redeem, or swap via mUSD\n\n                    uint256 realOutputAmount;\n\n\n                    if (inputErc20Contract == 0xe2f2a5C287993345a840Db3B0845fbC70f5935a5) {\n\n                        uint256 outputDecimals = _erc20Decimals[outputErc20Contract];\n\n                        uint256 outputAmount = 18 >= outputDecimals ? inputAmountsAfterFees[i].div(10 ** (uint256(18).sub(outputDecimals))) : inputAmountsAfterFees[i].mul(10 ** (outputDecimals.sub(18)));\n\n                        MStableExchangeController.redeem(outputErc20Contract, outputAmount);\n\n                        realOutputAmount = outputAmount.sub(outputAmount.mul(MStableExchangeController.getSwapFee()).div(1e18));\n\n                    } else if (outputErc20Contract == 0xe2f2a5C287993345a840Db3B0845fbC70f5935a5) {\n\n                        realOutputAmount = MStableExchangeController.mint(inputErc20Contract, inputAmountsAfterFees[i]);\n\n                    } else {\n\n                        uint256 outputAmount = MStableExchangeController.swap(inputErc20Contract, outputErc20Contract, inputAmountsAfterFees[i]);\n\n                        realOutputAmount = outputAmount.sub(outputAmount.mul(MStableExchangeController.getSwapFee()).div(1e18));\n\n                    }\n\n\n                    emit PostWithdrawalExchange(inputCurrencyCodes[i], outputErc20Contract, msg.sender, inputAmounts[i], inputAmountsAfterFees[i], realOutputAmount);\n\n                } else revert(\"No 0x orders supplied and exchange not supported via mStable for at least one currency pair.\");\n\n            }\n\n        }\n\n\n        if (outputErc20Contract == address(0)) {\n\n            // Unwrap WETH if output currency is ETH\n\n            uint256 wethBalance = _weth.balanceOf(address(this));\n\n            _weth.withdraw(wethBalance);\n\n        } else {\n\n            // Forward tokens if output currency is a token\n\n            IERC20 outputToken = IERC20(outputErc20Contract);\n\n            uint256 outputTokenBalance = outputToken.balanceOf(address(this));\n\n            if (outputTokenBalance > 0) outputToken.safeTransfer(msg.sender, outputTokenBalance);\n\n        }\n\n\n        // Forward all ETH\n\n        uint256 ethBalance = address(this).balance;\n\n\n        if (ethBalance > 0) {\n\n            (bool success,) = msg.sender.call.value(ethBalance)(\"\");\n\n            require(success, \"Failed to transfer ETH to msg.sender after exchange.\");\n\n","contract":"RariFundProxy","time":0}]}