{"time":84,"results":[{"type":"struct-data-arrangement ","before":"\nuint id\naddress proposer\nuint eta\naddress[] targets\nuint[] values\nstring[] signatures\nbytes[] calldatas\nuint startBlock\nuint endBlock\nuint forVotes\nuint againstVotes\nbool canceled\nbool executed\nmapping(address => Receipt) receipts","after":"uint id\nuint eta\naddress[] targets\nuint[] values\nstring[] signatures\nbytes[] calldatas\nuint startBlock\nuint endBlock\nuint forVotes\nuint againstVotes\nmapping(address => Receipt) receipts\naddress proposer\nbool canceled\nbool executed\n","contract":"GovernorAlpha","time":0},{"type":"external-function ","before":"function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n        require(gtc.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information parity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        }\n\n        uint startBlock = add256(block.number, votingDelay());\n        uint endBlock = add256(startBlock, votingPeriod());\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n        id : proposalCount,\n        proposer : msg.sender,\n        eta : 0,\n        targets : targets,\n        values : values,\n        signatures : signatures,\n        calldatas : calldatas,\n        startBlock : startBlock,\n        endBlock : endBlock,\n        forVotes : 0,\n        againstVotes : 0,\n        canceled : false,\n        executed : false\n        });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;\n    }","after":"function propose(address[] calldata targets, uint[] calldata values, string[] calldata signatures, bytes[] calldata calldatas, string calldata description) public returns (uint) {\n        require(gtc.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information parity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        }\n\n        uint startBlock = add256(block.number, votingDelay());\n        uint endBlock = add256(startBlock, votingPeriod());\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n        id : proposalCount,\n        proposer : msg.sender,\n        eta : 0,\n        targets : targets,\n        values : values,\n        signatures : signatures,\n        calldatas : calldatas,\n        startBlock : startBlock,\n        endBlock : endBlock,\n        forVotes : 0,\n        againstVotes : 0,\n        canceled : false,\n        executed : false\n        });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;\n    }","contract":"GovernorAlpha","time":0}]}