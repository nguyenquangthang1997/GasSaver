{"time":390,"results":[{"type":"state-data-arrangement ","before":"\nIERC20 public immutable underlying;\nuint8 public immutable underlyingDecimals;\nIERC20 public immutable bond;\nuint8 public immutable bondDecimals;\nuint256 public immutable expiration;\nuint256 public immutable unitSeconds;\nIVault private immutable _vault;\nbytes32 private immutable _poolId;\nuint128 public feesUnderlying;\nuint128 public feesBond;\naddress public immutable governance;\nuint256 public immutable percentFee;\nuint256 public immutable percentFeeGov;\nuint256 internal immutable baseIndex;\nuint256 internal immutable bondIndex;\nuint256 public constant FEE_BOUND = 3e17;","after":"IERC20 public immutable underlying;\nIERC20 public immutable bond;\nuint256 public immutable expiration;\nuint256 public immutable unitSeconds;\nIVault private immutable _vault;\nbytes32 private immutable _poolId;\nuint256 public immutable percentFee;\nuint256 public immutable percentFeeGov;\nuint256 internal immutable baseIndex;\nuint256 internal immutable bondIndex;\nuint256 public constant FEE_BOUND = 3e17;\naddress public immutable governance;\nuint128 public feesUnderlying;\nuint128 public feesBond;\nuint8 public immutable underlyingDecimals;\nuint8 public immutable bondDecimals;\n","contract":"ConvergentCurvePool","time":0},{"type":"external-function ","before":"function onSwap(\n        SwapRequest memory swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) public override returns (uint256) {\n        // Check that the sender is pool, we change state so must make\n        // this check.\n        require(msg.sender == address(_vault), \"Non Vault caller\");\n        // Tokens amounts are passed to us in decimal form of the tokens\n        // But we want theme in 18 point\n        uint256 amount;\n        bool isOutputSwap = swapRequest.kind == IVault.SwapKind.GIVEN_IN;\n        if (isOutputSwap) {\n            amount = _tokenToFixed(swapRequest.amount, swapRequest.tokenIn);\n        } else {\n            amount = _tokenToFixed(swapRequest.amount, swapRequest.tokenOut);\n        }\n        currentBalanceTokenIn = _tokenToFixed(\n            currentBalanceTokenIn,\n            swapRequest.tokenIn\n        );\n        currentBalanceTokenOut = _tokenToFixed(\n            currentBalanceTokenOut,\n            swapRequest.tokenOut\n        );\n\n        // We apply the trick which is used in the paper and\n        // double count the reserves because the curve provisions liquidity\n        // for prices above one underlying per bond, which we don't want to be accessible\n        (uint256 tokenInReserve, uint256 tokenOutReserve) = _adjustedReserve(\n            currentBalanceTokenIn,\n            swapRequest.tokenIn,\n            currentBalanceTokenOut,\n            swapRequest.tokenOut\n        );\n\n        // We switch on if this is an input or output case\n        if (isOutputSwap) {\n            // We get quote\n            uint256 quote = solveTradeInvariant(\n                amount,\n                tokenInReserve,\n                tokenOutReserve,\n                isOutputSwap\n            );\n            // We assign the trade fee\n            quote = _assignTradeFee(amount, quote, swapRequest.tokenOut, false);\n            // We return the quote\n            return _fixedToToken(quote, swapRequest.tokenOut);\n        } else {\n            // We get the quote\n            uint256 quote = solveTradeInvariant(\n                amount,\n                tokenOutReserve,\n                tokenInReserve,\n                isOutputSwap\n            );\n            // We assign the trade fee\n            quote = _assignTradeFee(quote, amount, swapRequest.tokenOut, true);\n            // We return the output\n            return _fixedToToken(quote, swapRequest.tokenIn);\n        }\n    }","after":"function onSwap(\n        SwapRequest calldata swapRequest,\n        uint256 currentBalanceTokenIn,\n        uint256 currentBalanceTokenOut\n    ) public override returns (uint256) {\n        // Check that the sender is pool, we change state so must make\n        // this check.\n        require(msg.sender == address(_vault), \"Non Vault caller\");\n        // Tokens amounts are passed to us in decimal form of the tokens\n        // But we want theme in 18 point\n        uint256 amount;\n        bool isOutputSwap = swapRequest.kind == IVault.SwapKind.GIVEN_IN;\n        if (isOutputSwap) {\n            amount = _tokenToFixed(swapRequest.amount, swapRequest.tokenIn);\n        } else {\n            amount = _tokenToFixed(swapRequest.amount, swapRequest.tokenOut);\n        }\n        currentBalanceTokenIn = _tokenToFixed(\n            currentBalanceTokenIn,\n            swapRequest.tokenIn\n        );\n        currentBalanceTokenOut = _tokenToFixed(\n            currentBalanceTokenOut,\n            swapRequest.tokenOut\n        );\n\n        // We apply the trick which is used in the paper and\n        // double count the reserves because the curve provisions liquidity\n        // for prices above one underlying per bond, which we don't want to be accessible\n        (uint256 tokenInReserve, uint256 tokenOutReserve) = _adjustedReserve(\n            currentBalanceTokenIn,\n            swapRequest.tokenIn,\n            currentBalanceTokenOut,\n            swapRequest.tokenOut\n        );\n\n        // We switch on if this is an input or output case\n        if (isOutputSwap) {\n            // We get quote\n            uint256 quote = solveTradeInvariant(\n                amount,\n                tokenInReserve,\n                tokenOutReserve,\n                isOutputSwap\n            );\n            // We assign the trade fee\n            quote = _assignTradeFee(amount, quote, swapRequest.tokenOut, false);\n            // We return the quote\n            return _fixedToToken(quote, swapRequest.tokenOut);\n        } else {\n            // We get the quote\n            uint256 quote = solveTradeInvariant(\n                amount,\n                tokenOutReserve,\n                tokenInReserve,\n                isOutputSwap\n            );\n            // We assign the trade fee\n            quote = _assignTradeFee(quote, amount, swapRequest.tokenOut, true);\n            // We return the output\n            return _fixedToToken(quote, swapRequest.tokenIn);\n        }\n    }","contract":"ConvergentCurvePool","time":0},{"type":"external-function ","before":"function onJoinPool(\n        bytes32 poolId,\n        address, // sender\n        address recipient,\n        uint256[] memory currentBalances,\n        uint256,\n        uint256 protocolSwapFee,\n        bytes calldata userData\n    )\n    external\n    override\n    returns (\n        uint256[] memory amountsIn,\n        uint256[] memory dueProtocolFeeAmounts\n    )\n    {\n        // Default checks\n        require(msg.sender == address(_vault), \"Non Vault caller\");\n        require(poolId == _poolId, \"Wrong pool id\");\n        uint256[] memory maxAmountsIn = abi.decode(userData, (uint256[]));\n        require(\n            currentBalances.length == 2 && maxAmountsIn.length == 2,\n            \"Invalid format\"\n        );\n        // We must normalize the inputs to 18 point\n        _normalizeSortedArray(currentBalances);\n        _normalizeSortedArray(maxAmountsIn);\n\n        // Mint LP to the governance address.\n        // The {} zoning here helps solidity figure out the stack\n        {\n            (\n            uint256 localFeeUnderlying,\n            uint256 localFeeBond\n            ) = _mintGovernanceLP(currentBalances);\n            dueProtocolFeeAmounts = new uint256[](2);\n\n            dueProtocolFeeAmounts[baseIndex] = localFeeUnderlying.mulDown(\n                protocolSwapFee\n            );\n            dueProtocolFeeAmounts[bondIndex] = localFeeBond.mulDown(\n                protocolSwapFee\n            );\n        }\n        // Mint for the user\n        amountsIn = _mintLP(\n            maxAmountsIn[baseIndex],\n            maxAmountsIn[bondIndex],\n            currentBalances,\n            recipient\n        );\n\n        // We now have make the outputs have the correct decimals\n        _denormalizeSortedArray(amountsIn);\n        _denormalizeSortedArray(dueProtocolFeeAmounts);\n    }","after":"function onJoinPool(\n        bytes32 poolId,\n        address, // sender\n        address recipient,\n        uint256[] calldata currentBalances,\n        uint256,\n        uint256 protocolSwapFee,\n        bytes calldata userData\n    )\n    external\n    override\n    returns (\n        uint256[] memory amountsIn,\n        uint256[] memory dueProtocolFeeAmounts\n    )\n    {\n        // Default checks\n        require(msg.sender == address(_vault), \"Non Vault caller\");\n        require(poolId == _poolId, \"Wrong pool id\");\n        uint256[] memory maxAmountsIn = abi.decode(userData, (uint256[]));\n        require(\n            currentBalances.length == 2 && maxAmountsIn.length == 2,\n            \"Invalid format\"\n        );\n        // We must normalize the inputs to 18 point\n        _normalizeSortedArray(currentBalances);\n        _normalizeSortedArray(maxAmountsIn);\n\n        // Mint LP to the governance address.\n        // The {} zoning here helps solidity figure out the stack\n        {\n            (\n            uint256 localFeeUnderlying,\n            uint256 localFeeBond\n            ) = _mintGovernanceLP(currentBalances);\n            dueProtocolFeeAmounts = new uint256[](2);\n\n            dueProtocolFeeAmounts[baseIndex] = localFeeUnderlying.mulDown(\n                protocolSwapFee\n            );\n            dueProtocolFeeAmounts[bondIndex] = localFeeBond.mulDown(\n                protocolSwapFee\n            );\n        }\n        // Mint for the user\n        amountsIn = _mintLP(\n            maxAmountsIn[baseIndex],\n            maxAmountsIn[bondIndex],\n            currentBalances,\n            recipient\n        );\n\n        // We now have make the outputs have the correct decimals\n        _denormalizeSortedArray(amountsIn);\n        _denormalizeSortedArray(dueProtocolFeeAmounts);\n    }","contract":"ConvergentCurvePool","time":0},{"type":"external-function ","before":"function onExitPool(\n        bytes32 poolId,\n        address,\n        address recipient,\n        uint256[] memory currentBalances,\n        uint256,\n        uint256 protocolSwapFee,\n        bytes calldata userData\n    )\n    external\n    override\n    returns (\n        uint256[] memory amountsOut,\n        uint256[] memory dueProtocolFeeAmounts\n    )\n    {\n        // Default checks\n        require(msg.sender == address(_vault), \"Non Vault caller\");\n        require(poolId == _poolId, \"Wrong pool id\");\n        uint256[] memory minAmountsOut = abi.decode(userData, (uint256[]));\n        require(\n            currentBalances.length == 2 && minAmountsOut.length == 2,\n            \"Invalid format\"\n        );\n        // We have to convert to 18 decimals\n        _normalizeSortedArray(currentBalances);\n        _normalizeSortedArray(minAmountsOut);\n\n        // Mint LP for the governance address.\n        // {} zones to help solidity figure out the stack\n        {\n            (\n            uint256 localFeeUnderlying,\n            uint256 localFeeBond\n            ) = _mintGovernanceLP(currentBalances);\n\n            // Calculate the amount of fees for balancer to collect\n            dueProtocolFeeAmounts = new uint256[](2);\n            dueProtocolFeeAmounts[baseIndex] = localFeeUnderlying.mulDown(\n                protocolSwapFee\n            );\n            dueProtocolFeeAmounts[bondIndex] = localFeeBond.mulDown(\n                protocolSwapFee\n            );\n        }\n\n        amountsOut = _burnLP(\n            minAmountsOut[baseIndex],\n            minAmountsOut[bondIndex],\n            currentBalances,\n            recipient\n        );\n\n        // We need to convert the balancer outputs to token decimals instead of 18\n        _denormalizeSortedArray(amountsOut);\n        _denormalizeSortedArray(dueProtocolFeeAmounts);\n        return (amountsOut, dueProtocolFeeAmounts);\n    }","after":"function onExitPool(\n        bytes32 poolId,\n        address,\n        address recipient,\n        uint256[] calldata currentBalances,\n        uint256,\n        uint256 protocolSwapFee,\n        bytes calldata userData\n    )\n    external\n    override\n    returns (\n        uint256[] memory amountsOut,\n        uint256[] memory dueProtocolFeeAmounts\n    )\n    {\n        // Default checks\n        require(msg.sender == address(_vault), \"Non Vault caller\");\n        require(poolId == _poolId, \"Wrong pool id\");\n        uint256[] memory minAmountsOut = abi.decode(userData, (uint256[]));\n        require(\n            currentBalances.length == 2 && minAmountsOut.length == 2,\n            \"Invalid format\"\n        );\n        // We have to convert to 18 decimals\n        _normalizeSortedArray(currentBalances);\n        _normalizeSortedArray(minAmountsOut);\n\n        // Mint LP for the governance address.\n        // {} zones to help solidity figure out the stack\n        {\n            (\n            uint256 localFeeUnderlying,\n            uint256 localFeeBond\n            ) = _mintGovernanceLP(currentBalances);\n\n            // Calculate the amount of fees for balancer to collect\n            dueProtocolFeeAmounts = new uint256[](2);\n            dueProtocolFeeAmounts[baseIndex] = localFeeUnderlying.mulDown(\n                protocolSwapFee\n            );\n            dueProtocolFeeAmounts[bondIndex] = localFeeBond.mulDown(\n                protocolSwapFee\n            );\n        }\n\n        amountsOut = _burnLP(\n            minAmountsOut[baseIndex],\n            minAmountsOut[bondIndex],\n            currentBalances,\n            recipient\n        );\n\n        // We need to convert the balancer outputs to token decimals instead of 18\n        _denormalizeSortedArray(amountsOut);\n        _denormalizeSortedArray(dueProtocolFeeAmounts);\n        return (amountsOut, dueProtocolFeeAmounts);\n    }","contract":"ConvergentCurvePool","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ConvergentCurvePool","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ConvergentCurvePool","time":1},{"type":"constant-restrict-modification  ","before":"bytes32 private immutable _PERMIT_TYPE_HASH = keccak256(\n        \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    );","after":"bytes32 private immutable constant _PERMIT_TYPE_HASH = keccak256(\n        \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n    );","contract":"ConvergentCurvePool","time":1},{"type":"external-function ","before":"function create(\n        address _underlying,\n        address _bond,\n        uint256 _expiration,\n        uint256 _unitSeconds,\n        uint256 _percentFee,\n        string memory _name,\n        string memory _symbol\n    ) external returns (address) {\n        address pool = address(\n            new ConvergentCurvePool(\n                IERC20(_underlying),\n                IERC20(_bond),\n                _expiration,\n                _unitSeconds,\n                getVault(),\n                _percentFee,\n                percentFeeGov,\n                governance,\n                _name,\n                _symbol\n            )\n        );\n        // Register the pool with the vault\n        _register(pool);\n        // Emit a creation event\n        emit CCPoolCreated(pool, _bond);\n        return pool;\n    }","after":"function create(\n        address _underlying,\n        address _bond,\n        uint256 _expiration,\n        uint256 _unitSeconds,\n        uint256 _percentFee,\n        string calldata _name,\n        string calldata _symbol\n    ) external returns (address) {\n        address pool = address(\n            new ConvergentCurvePool(\n                IERC20(_underlying),\n                IERC20(_bond),\n                _expiration,\n                _unitSeconds,\n                getVault(),\n                _percentFee,\n                percentFeeGov,\n                governance,\n                _name,\n                _symbol\n            )\n        );\n        // Register the pool with the vault\n        _register(pool);\n        // Emit a creation event\n        emit CCPoolCreated(pool, _bond);\n        return pool;\n    }","contract":"ConvergentPoolFactory","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC20","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC20","time":0},{"type":"external-function ","before":"shLoanFeePercentage;\n    }\n\n    function getCollectedFeeAmounts(IERC20[] memory tokens) external view returns (uint256[] memory feeAmounts) {\n        feeAmounts = new uint256[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            feeAmounts[i] = tokens[i].balanceOf","after":"shLoanFeePercentage;\n    }\n\n    function getCollectedFeeAmounts(IERC20[] memory tokens) external view returns (uint256[] memory feeAmounts) {\n        feeAmounts = new uint256[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            feeAmounts[i] = tokens[i].balanceOf","contract":"ProtocolFeesCollector","time":0}]}