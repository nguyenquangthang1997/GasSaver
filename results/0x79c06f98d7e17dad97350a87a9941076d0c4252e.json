{"time":261,"results":[{"type":"external-function ","before":"function retrieveRewards(uint roundId, VotingInterface.PendingRequest[] memory toRetrieve)\n\n    public\n\n    onlyRoleHolder(uint(Roles.Voter))\n\n    returns (FixedPoint.Unsigned memory rewardsIssued)\n\n    {\n\n        return _getVotingAddress().retrieveRewards(address(this), roundId, toRetrieve);\n\n    }","after":"function retrieveRewards(uint roundId, VotingInterface.PendingRequest[] calldata toRetrieve)\n\n    public\n\n    onlyRoleHolder(uint(Roles.Voter))\n\n    returns (FixedPoint.Unsigned memory rewardsIssued)\n\n    {\n\n        return _getVotingAddress().retrieveRewards(address(this), roundId, toRetrieve);\n\n    }","contract":"DesignatedVoting","time":0},{"type":"external-function ","before":"function setInflationRate(FixedPoint.Unsigned memory _inflationRate) public onlyOwner {\n\n        inflationRate = _inflationRate;\n\n    }","after":"function setInflationRate(FixedPoint.Unsigned calldata _inflationRate) public onlyOwner {\n\n        inflationRate = _inflationRate;\n\n    }","contract":"Voting","time":0},{"type":"external-function ","before":"function retrieveRewards(address voterAddress, uint roundId, PendingRequest[] memory toRetrieve)\n\n    public\n\n    returns (FixedPoint.Unsigned memory totalRewardToIssue)\n\n    {\n\n        if (migratedAddress != address(0)) {\n\n            require(msg.sender == migratedAddress);\n\n        }\n\n        uint blockTime = getCurrentTime();\n\n        _updateRound(blockTime);\n\n        require(roundId < voteTiming.computeCurrentRoundId(blockTime));\n\n\n        Round storage round = rounds[roundId];\n\n        FixedPoint.Unsigned memory snapshotBalance = FixedPoint.Unsigned(\n\n            votingToken.balanceOfAt(voterAddress, round.snapshotId));\n\n\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\n\n        FixedPoint.Unsigned memory snapshotTotalSupply = FixedPoint.Unsigned(\n\n            votingToken.totalSupplyAt(round.snapshotId));\n\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\n\n\n        // Keep track of the voter's accumulated token reward.\n\n        totalRewardToIssue = FixedPoint.Unsigned(0);\n\n\n        for (uint i = 0; i < toRetrieve.length; i++) {\n\n            PriceRequest storage priceRequest = _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time);\n\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n\n\n            require(priceRequest.lastVotingRound == roundId, \"Only retrieve rewards for votes resolved in same round\");\n\n\n            _resolvePriceRequest(priceRequest, voteInstance);\n\n\n            if (voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)) {\n\n                // The price was successfully resolved during the voter's last voting round, the voter revealed and was\n\n                // correct, so they are elgible for a reward.\n\n                FixedPoint.Unsigned memory correctTokens = voteInstance.resultComputation.\n\n                getTotalCorrectlyVotedTokens();\n\n\n                // Compute the reward and add to the cumulative reward.\n\n                FixedPoint.Unsigned memory reward = snapshotBalance.mul(totalRewardPerVote).div(correctTokens);\n\n                totalRewardToIssue = totalRewardToIssue.add(reward);\n\n\n                // Emit reward retrieval for this vote.\n\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time,\n\n                    reward.rawValue);\n\n            } else {\n\n                // Emit a 0 token retrieval on incorrect votes.\n\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n\n            }\n\n\n            // Delete the submission to capture any refund and clean up storage.\n\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\n\n        }\n\n\n        // Issue any accumulated rewards.\n\n        if (totalRewardToIssue.isGreaterThan(0)) {\n\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue));\n\n        }\n\n    }","after":"function retrieveRewards(address voterAddress, uint roundId, PendingRequest[] calldata toRetrieve)\n\n    public\n\n    returns (FixedPoint.Unsigned memory totalRewardToIssue)\n\n    {\n\n        if (migratedAddress != address(0)) {\n\n            require(msg.sender == migratedAddress);\n\n        }\n\n        uint blockTime = getCurrentTime();\n\n        _updateRound(blockTime);\n\n        require(roundId < voteTiming.computeCurrentRoundId(blockTime));\n\n\n        Round storage round = rounds[roundId];\n\n        FixedPoint.Unsigned memory snapshotBalance = FixedPoint.Unsigned(\n\n            votingToken.balanceOfAt(voterAddress, round.snapshotId));\n\n\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\n\n        FixedPoint.Unsigned memory snapshotTotalSupply = FixedPoint.Unsigned(\n\n            votingToken.totalSupplyAt(round.snapshotId));\n\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\n\n\n        // Keep track of the voter's accumulated token reward.\n\n        totalRewardToIssue = FixedPoint.Unsigned(0);\n\n\n        for (uint i = 0; i < toRetrieve.length; i++) {\n\n            PriceRequest storage priceRequest = _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time);\n\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n\n\n            require(priceRequest.lastVotingRound == roundId, \"Only retrieve rewards for votes resolved in same round\");\n\n\n            _resolvePriceRequest(priceRequest, voteInstance);\n\n\n            if (voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)) {\n\n                // The price was successfully resolved during the voter's last voting round, the voter revealed and was\n\n                // correct, so they are elgible for a reward.\n\n                FixedPoint.Unsigned memory correctTokens = voteInstance.resultComputation.\n\n                getTotalCorrectlyVotedTokens();\n\n\n                // Compute the reward and add to the cumulative reward.\n\n                FixedPoint.Unsigned memory reward = snapshotBalance.mul(totalRewardPerVote).div(correctTokens);\n\n                totalRewardToIssue = totalRewardToIssue.add(reward);\n\n\n                // Emit reward retrieval for this vote.\n\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time,\n\n                    reward.rawValue);\n\n            } else {\n\n                // Emit a 0 token retrieval on incorrect votes.\n\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n\n            }\n\n\n            // Delete the submission to capture any refund and clean up storage.\n\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\n\n        }\n\n\n        // Issue any accumulated rewards.\n\n        if (totalRewardToIssue.isGreaterThan(0)) {\n\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue));\n\n        }\n\n    }","contract":"Voting","time":0},{"type":"external-function ","before":"function setPublicKey(bytes memory publicKey, bytes32 topicHash) public {\n\n        require(publicKey.length == 64, \"Public key is the wrong length\");\n\n        recipients[msg.sender].topics[topicHash].publicKey = publicKey;\n\n    }","after":"function setPublicKey(bytes calldata publicKey, bytes32 topicHash) public {\n\n        require(publicKey.length == 64, \"Public key is the wrong length\");\n\n        recipients[msg.sender].topics[topicHash].publicKey = publicKey;\n\n    }","contract":"Voting","time":0},{"type":"immutable-restrict-modification ","before":"bool public isTest;","after":"bool public immutable isTest;","contract":"Voting","time":2}]}