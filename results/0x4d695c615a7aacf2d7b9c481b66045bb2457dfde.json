{"time":736,"results":[{"type":"external-function ","before":"function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        TokenControllerInterface _controller\n    )\n    public\n    virtual\n    initializer\n    {\n        __ERC20_init(_name, _symbol);\n        controller = _controller;\n        _setupDecimals(_decimals);\n    }","after":"function initialize(\n        string calldata _name,\n        string calldata _symbol,\n        uint8 _decimals,\n        TokenControllerInterface _controller\n    )\n    public\n    virtual\n    initializer\n    {\n        __ERC20_init(_name, _symbol);\n        controller = _controller;\n        _setupDecimals(_decimals);\n    }","contract":"ControlledToken","time":0},{"type":"external-function ","before":"function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n    public\n    view\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }","after":"function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    )\n    public\n    view\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }","contract":"ERC1155Mintable","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n    public\n    virtual\n    override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n    public\n    virtual\n    override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"ERC1155Mintable","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n    public\n    virtual\n    override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n    public\n    virtual\n    override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"ERC1155Mintable","time":0},{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping(address => uint256) private _tokenCounts;\nmapping(uint256 => address) private _tokenOwners;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nstring private _name;\nstring private _symbol;\nmapping(uint256 => string) private _tokenURIs;\nstring private _baseURI;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;","after":"mapping(address => uint256) private _tokenCounts;\nmapping(uint256 => address) private _tokenOwners;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nstring private _name;\nstring private _symbol;\nmapping(uint256 => string) private _tokenURIs;\nstring private _baseURI;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n","contract":"ERC721","time":1},{"type":"external-function ","before":"function initialize(\n        string memory name,\n        string memory symbol,\n        string memory baseURI,\n        address admin\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __setBaseURI(baseURI);\n        _setupRole(DEFAULT_ADMIN_ROLE, admin);\n\n        emit ERC721ControlledInitialized(name, symbol);\n    }","after":"function initialize(\n        string calldata name,\n        string calldata symbol,\n        string calldata baseURI,\n        address admin\n    ) public initializer {\n        __ERC721_init(name, symbol);\n        __setBaseURI(baseURI);\n        _setupRole(DEFAULT_ADMIN_ROLE, admin);\n\n        emit ERC721ControlledInitialized(name, symbol);\n    }","contract":"ERC721Controlled","time":0},{"type":"external-function ","before":"function setBaseURI(string memory _baseURI) external onlyAdmin {\n        __setBaseURI(_baseURI);\n    }","after":"function setBaseURI(string calldata _baseURI) external onlyAdmin {\n        __setBaseURI(_baseURI);\n    }","contract":"ERC721Controlled","time":0},{"type":"external-function ","before":"function createERC721Controlled(\n        string memory name,\n        string memory symbol,\n        string memory baseURI\n    ) external returns (ERC721Controlled) {\n        ERC721Controlled result = new ERC721Controlled();\n        result.initialize(name, symbol, baseURI, msg.sender);\n        emit ERC721ControlledCreated(address(result));\n        return result;\n    }","after":"function createERC721Controlled(\n        string calldata name,\n        string calldata symbol,\n        string calldata baseURI\n    ) external returns (ERC721Controlled) {\n        ERC721Controlled result = new ERC721Controlled();\n        result.initialize(name, symbol, baseURI, msg.sender);\n        emit ERC721ControlledCreated(address(result));\n        return result;\n    }","contract":"ERC721ControlledFactory","time":0},{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping(address => EnumerableSetUpgradeable.UintSet) private _holderTokens;\nEnumerableMapUpgradeable.UintToAddressMap private _tokenOwners;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nstring private _name;\nstring private _symbol;\nmapping(uint256 => string) private _tokenURIs;\nstring private _baseURI;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\nbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\nuint256[41] private __gap;","after":"mapping(address => EnumerableSetUpgradeable.UintSet) private _holderTokens;\nEnumerableMapUpgradeable.UintToAddressMap private _tokenOwners;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nstring private _name;\nstring private _symbol;\nmapping(uint256 => string) private _tokenURIs;\nstring private _baseURI;\nuint256[41] private __gap;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\nbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n","contract":"ERC721Upgradeable","time":0},{"type":"external-function ","before":"function mint(address to, uint256 amount, bytes memory userData, bytes memory operatorData) external returns (address) {\n        _mint(to, amount, userData, operatorData);\n    }","after":"function mint(address to, uint256 amount, bytes calldata userData, bytes calldata operatorData) external returns (address) {\n        _mint(to, amount, userData, operatorData);\n    }","contract":"ERC777Mintable","time":0},{"type":"external-function ","before":"function send(address recipient, uint256 amount, bytes memory data) public override {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n    }","after":"function send(address recipient, uint256 amount, bytes calldata data) public override {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n    }","contract":"ERC777Mintable","time":0},{"type":"external-function ","before":"function burn(uint256 amount, bytes memory data) public override {\n        _burn(_msgSender(), amount, data, \"\");\n    }","after":"function burn(uint256 amount, bytes calldata data) public override {\n        _burn(_msgSender(), amount, data, \"\");\n    }","contract":"ERC777Mintable","time":0},{"type":"external-function ","before":"function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n    public override\n    {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n    }","after":"function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    )\n    public override\n    {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n    }","contract":"ERC777Mintable","time":0},{"type":"external-function ","before":"function operatorBurn(address account, uint256 amount, bytes memory data, bytes memory operatorData) public override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n    }","after":"function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) public override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n    }","contract":"ERC777Mintable","time":0},{"type":"external-function ","before":"function plunder(\n        IERC20Upgradeable[] memory erc20,\n        WithdrawERC721[] memory erc721,\n        WithdrawERC1155[] memory erc1155,\n        address payable to\n    ) external onlyOwner {\n        require(to != address(0), \"LootBox/non-zero-to\");\n        _withdrawERC20(erc20, to);\n        _withdrawERC721(erc721, to);\n        _withdrawERC1155(erc1155, to);\n        _transferEther(to, address(this).balance);\n    }","after":"function plunder(\n        IERC20Upgradeable[] calldata erc20,\n        WithdrawERC721[] calldata erc721,\n        WithdrawERC1155[] calldata erc1155,\n        address payable to\n    ) external onlyOwner {\n        require(to != address(0), \"LootBox/non-zero-to\");\n        _withdrawERC20(erc20, to);\n        _withdrawERC721(erc721, to);\n        _withdrawERC1155(erc1155, to);\n        _transferEther(to, address(this).balance);\n    }","contract":"LootBox","time":0},{"type":"immutable-restrict-modification ","before":"bytes internal lootBoxBytecode;","after":"bytes internal immutable lootBoxBytecode;","contract":"LootBoxController","time":0},{"type":"external-function ","before":"function initialize(\n        uint256 _prizePeriodStart,\n        uint256 _prizePeriodSeconds,\n        PrizePool _prizePool,\n        TicketInterface _ticket,\n        IERC20Upgradeable _sponsorship,\n        RNGInterface _rng,\n        IERC20Upgradeable[] memory externalErc20Awards\n    ) public initializer {\n        require(_prizePeriodSeconds > 0, \"PeriodicPrizeStrategy/prize-period-greater-than-zero\");\n        require(address(_prizePool) != address(0), \"PeriodicPrizeStrategy/prize-pool-not-zero\");\n        require(address(_ticket) != address(0), \"PeriodicPrizeStrategy/ticket-not-zero\");\n        require(address(_sponsorship) != address(0), \"PeriodicPrizeStrategy/sponsorship-not-zero\");\n        require(address(_rng) != address(0), \"PeriodicPrizeStrategy/rng-not-zero\");\n        prizePool = _prizePool;\n        ticket = _ticket;\n        rng = _rng;\n        sponsorship = _sponsorship;\n\n        __Ownable_init();\n        Constants.REGISTRY.setInterfaceImplementer(address(this), Constants.TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n\n        externalErc20s.initialize();\n        for (uint256 i = 0; i < externalErc20Awards.length; i++) {\n            _addExternalErc20Award(externalErc20Awards[i]);\n        }\n\n        prizePeriodSeconds = _prizePeriodSeconds;\n        prizePeriodStartedAt = _prizePeriodStart;\n\n        externalErc721s.initialize();\n\n        // 30 min timeout\n        _setRngRequestTimeout(1800);\n\n        emit Initialized(\n            _prizePeriodStart,\n            _prizePeriodSeconds,\n            _prizePool,\n            _ticket,\n            _sponsorship,\n            _rng,\n            externalErc20Awards\n        );\n        emit PrizePoolOpened(_msgSender(), prizePeriodStartedAt);\n    }","after":"function initialize(\n        uint256 _prizePeriodStart,\n        uint256 _prizePeriodSeconds,\n        PrizePool _prizePool,\n        TicketInterface _ticket,\n        IERC20Upgradeable _sponsorship,\n        RNGInterface _rng,\n        IERC20Upgradeable[] calldata externalErc20Awards\n    ) public initializer {\n        require(_prizePeriodSeconds > 0, \"PeriodicPrizeStrategy/prize-period-greater-than-zero\");\n        require(address(_prizePool) != address(0), \"PeriodicPrizeStrategy/prize-pool-not-zero\");\n        require(address(_ticket) != address(0), \"PeriodicPrizeStrategy/ticket-not-zero\");\n        require(address(_sponsorship) != address(0), \"PeriodicPrizeStrategy/sponsorship-not-zero\");\n        require(address(_rng) != address(0), \"PeriodicPrizeStrategy/rng-not-zero\");\n        prizePool = _prizePool;\n        ticket = _ticket;\n        rng = _rng;\n        sponsorship = _sponsorship;\n\n        __Ownable_init();\n        Constants.REGISTRY.setInterfaceImplementer(address(this), Constants.TOKENS_RECIPIENT_INTERFACE_HASH, address(this));\n\n        externalErc20s.initialize();\n        for (uint256 i = 0; i < externalErc20Awards.length; i++) {\n            _addExternalErc20Award(externalErc20Awards[i]);\n        }\n\n        prizePeriodSeconds = _prizePeriodSeconds;\n        prizePeriodStartedAt = _prizePeriodStart;\n\n        externalErc721s.initialize();\n\n        // 30 min timeout\n        _setRngRequestTimeout(1800);\n\n        emit Initialized(\n            _prizePeriodStart,\n            _prizePeriodSeconds,\n            _prizePool,\n            _ticket,\n            _sponsorship,\n            _rng,\n            externalErc20Awards\n        );\n        emit PrizePoolOpened(_msgSender(), prizePeriodStartedAt);\n    }","contract":"PeriodicPrizeStrategy","time":0},{"type":"loop-duplication","before":"\nstart line 6713 column 8, end line 6720 column 8\nfor (i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (_unlockTimestamps[user] <= _currentTime()) {\n                totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);\n                balances[i] = _timelockBalances[user];\n                delete _timelockBalances[user];\n            }\n        }\nstart line 6733 column 8, end line 6741 column 8\nfor (i = 0; i < users.length; i++) {\n            if (balances[i] > 0) {\n                delete _unlockTimestamps[users[i]];\n                uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);\n                uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);\n                underlyingToken.safeTransfer(users[i], transferAmount);\n                emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);\n            }\n        }","after":"// merge loop\n\nstart line 6713 column 8, end line 6720 column 8\nfor (i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (_unlockTimestamps[user] <= _currentTime()) {\n                totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);\n                balances[i] = _timelockBalances[user];\n                delete _timelockBalances[user];\n            }\n        }\nstart line 6733 column 8, end line 6741 column 8\nfor (i = 0; i < users.length; i++) {\n            if (balances[i] > 0) {\n                delete _unlockTimestamps[users[i]];\n                uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);\n                uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);\n                underlyingToken.safeTransfer(users[i], transferAmount);\n                emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);\n            }\n        }","contract":"PrizePool","time":0},{"type":"external-function ","before":"function initialize(\n        RegistryInterface _reserveRegistry,\n        ControlledTokenInterface[] memory _controlledTokens,\n        uint256 _maxExitFeeMantissa,\n        uint256 _maxTimelockDuration\n    )\n    public\n    initializer\n    {\n        require(address(_reserveRegistry) != address(0), \"PrizePool/reserveRegistry-not-zero\");\n        _tokens.initialize();\n        for (uint256 i = 0; i < _controlledTokens.length; i++) {\n            _addControlledToken(_controlledTokens[i]);\n        }\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        _setLiquidityCap(uint256(- 1));\n\n        reserveRegistry = _reserveRegistry;\n        maxExitFeeMantissa = _maxExitFeeMantissa;\n        maxTimelockDuration = _maxTimelockDuration;\n\n        emit Initialized(\n            address(_reserveRegistry),\n            maxExitFeeMantissa,\n            maxTimelockDuration\n        );\n    }","after":"function initialize(\n        RegistryInterface _reserveRegistry,\n        ControlledTokenInterface[] calldata _controlledTokens,\n        uint256 _maxExitFeeMantissa,\n        uint256 _maxTimelockDuration\n    )\n    public\n    initializer\n    {\n        require(address(_reserveRegistry) != address(0), \"PrizePool/reserveRegistry-not-zero\");\n        _tokens.initialize();\n        for (uint256 i = 0; i < _controlledTokens.length; i++) {\n            _addControlledToken(_controlledTokens[i]);\n        }\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        _setLiquidityCap(uint256(- 1));\n\n        reserveRegistry = _reserveRegistry;\n        maxExitFeeMantissa = _maxExitFeeMantissa;\n        maxTimelockDuration = _maxTimelockDuration;\n\n        emit Initialized(\n            address(_reserveRegistry),\n            maxExitFeeMantissa,\n            maxTimelockDuration\n        );\n    }","contract":"PrizePool","time":0}]}