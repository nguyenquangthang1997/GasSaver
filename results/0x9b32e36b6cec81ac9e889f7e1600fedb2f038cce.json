{"time":763,"results":[{"type":"external-function ","before":"function initialize(ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_) public {\n        require(msg.sender == admin, \"only admin may initialize the market\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint err = _setComptroller(comptroller_);\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }","after":"function initialize(ComptrollerInterface comptroller_,\n        InterestRateModel interestRateModel_,\n        uint initialExchangeRateMantissa_,\n        string calldata name_,\n        string calldata symbol_,\n        uint8 decimals_) public {\n        require(msg.sender == admin, \"only admin may initialize the market\");\n        require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n        // Set initial exchange rate\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\n        require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n        // Set the comptroller\n        uint err = _setComptroller(comptroller_);\n        require(err == uint(Error.NO_ERROR), \"setting comptroller failed\");\n\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n        accrualBlockNumber = getBlockNumber();\n        borrowIndex = mantissaOne;\n\n        // Set the interest rate model (depends on block number / borrow index)\n        err = _setInterestRateModelFresh(interestRateModel_);\n        require(err == uint(Error.NO_ERROR), \"setting interest rate model failed\");\n\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n        _notEntered = true;\n    }","contract":"CToken","time":0},{"type":"state-data-arrangement ","before":"\n/\n    bool internal _notEn\n/\n    string public\n/\n    string public s\n/\n    uint8 public dec\n\n\n    uint internal constant borrowRateMaxMantissa = 0.00\n/\n    uint internal constant reserveFactorMaxMantissa =\n/\n    address payable public \n/\n    address payable public pending\n/\n    ComptrollerInterface public comptr\n/\n    InterestRateModel public interestRate\n/\n    uint internal initialExchangeRateMan\n/\n    uint public reserveFactorMan\n/\n    uint public accrualBlockN\n/\n    uint public borrow\n/\n    uint public totalBo\n/\n    uint public totalRes\n/\n    uint public totalS\n/\n    mapping(address => uint) internal accountT\n/\n    mapping(address => mapping(address => uint)) internal transferAllow\n/\n    mapping(address => BorrowSnapshot) internal accountBo\n/\n    uint public constant protocolSeizeShareMantissa = 2","after":"/\n    string public\n/\n    string public s\n\n\n    uint internal constant borrowRateMaxMantissa = 0.00\n/\n    uint internal constant reserveFactorMaxMantissa =\n/\n    ComptrollerInterface public comptr\n/\n    InterestRateModel public interestRate\n/\n    uint internal initialExchangeRateMan\n/\n    uint public reserveFactorMan\n/\n    uint public accrualBlockN\n/\n    uint public borrow\n/\n    uint public totalBo\n/\n    uint public totalRes\n/\n    uint public totalS\n/\n    mapping(address => uint) internal accountT\n/\n    mapping(address => mapping(address => uint)) internal transferAllow\n/\n    mapping(address => BorrowSnapshot) internal accountBo\n/\n    uint public constant protocolSeizeShareMantissa = 2\n/\n    address payable public \n/\n    address payable public pending\n/\n    bool internal _notEn\n/\n    uint8 public dec\n","contract":"CTokenStorage","time":0},{"type":"constant-restrict-modification  ","before":"/\n    address public under","after":"/\n    address public under","contract":"CErc20Interface","time":0},{"type":"constant-restrict-modification  ","before":"/\n    address public implement","after":"/\n    address public implement","contract":"CDelegatorInterface","time":0},{"type":"constant-restrict-modification  ","before":"/\n    address public implement","after":"/\n    address public implement","contract":"CDelegateInterface","time":0},{"type":"de-morgan-condition ","before":"        if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollater","after":"!(        if (markets[cTokenBorrowed].isListed || markets[cTokenCollater)","loc":{"start":{"line":2659,"column":12},"end":{"line":2659,"column":76}},"contract":"Comptroller","time":0},{"type":"de-morgan-condition ","before":"        if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrow","after":"!(        if (markets[cTokenCollateral].isListed || markets[cTokenBorrow)","loc":{"start":{"line":2737,"column":12},"end":{"line":2737,"column":76}},"contract":"Comptroller","time":0},{"type":"external-function ","before":"/\n    function enterMarkets(address[] memory cTokens) public returns (uint[] memory) {\n        uint len = cTokens.length;\n\n        uint[] memory results = new uint[](len);\n        for (uint i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n\n            results[i] = uint(addToMarketInternal(cToken, msg.sender));\n        }\n\n        return results;","after":"/\n    function enterMarkets(address[] calldata cTokens) public returns (uint[] memory) {\n        uint len = cTokens.length;\n\n        uint[] memory results = new uint[](len);\n        for (uint i = 0; i < len; i++) {\n            CToken cToken = CToken(cTokens[i]);\n\n            results[i] = uint(addToMarketInternal(cToken, msg.sender));\n        }\n\n        return results;","contract":"Comptroller","time":0},{"type":"external-function ","before":"     */\n    function _setCompSpeeds(CToken[] memory cTokens, uint[] memory supplySpeeds, uint[] memory borrowSpeeds) public {\n        require(adminOrInitializing(), \"only admin can set comp speed\");\n\n        uint numTokens = cTokens.length;\n        require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \"Comptroller::_setCompSpeeds invalid input\");\n\n        for (uint i = 0; i < numTokens; ++i) {\n            setCompSpeedInternal(cTokens[i], supplySpeeds[i], borrowSpeeds[i]);\n   ","after":"     */\n    function _setCompSpeeds(CToken[] calldata cTokens, uint[] calldata supplySpeeds, uint[] calldata borrowSpeeds) public {\n        require(adminOrInitializing(), \"only admin can set comp speed\");\n\n        uint numTokens = cTokens.length;\n        require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \"Comptroller::_setCompSpeeds invalid input\");\n\n        for (uint i = 0; i < numTokens; ++i) {\n            setCompSpeedInternal(cTokens[i], supplySpeeds[i], borrowSpeeds[i]);\n   ","contract":"Comptroller","time":0},{"type":"constant-restrict-modification  ","before":"r block\n    uint publ","after":"r block\n    uint publ","contract":"Comptroller","time":2},{"type":"constant-restrict-modification  ","before":"ardian;\n    bool public _mintGua","after":"ardian;\n    bool public _mintGua","contract":"Comptroller","time":2},{"type":"constant-restrict-modification  ","before":"Paused;\n    bool public _borrowGua","after":"Paused;\n    bool public _borrowGua","contract":"Comptroller","time":2},{"type":"immutable-restrict-modification ","before":"\n    */\n    address p","after":"\n    */\n    address p","contract":"Comptroller","time":2},{"type":"constant-restrict-modification  ","before":"\n    */\n    address public p","after":"\n    */\n    address public p","contract":"Comptroller","time":2},{"type":"constant-restrict-modification  ","before":"\n    */\n    address public comptrollerImp","after":"\n    */\n    address public comptrollerImp","contract":"Comptroller","time":2},{"type":"constant-restrict-modification  ","before":"\n    */\n    address public pendingComptrollerImp","after":"\n    */\n    address public pendingComptrollerImp","contract":"Comptroller","time":2},{"type":"struct-data-arrangement ","before":"\nted\n        b\n */\n        uint collateralFa\net\"\n        mapping(address => bool) accou\nOMP\n        b","after":" */\n        uint collateralFa\net\"\n        mapping(address => bool) accou\nted\n        b\nOMP\n        b\n","contract":"ComptrollerV2Storage","time":0}]}