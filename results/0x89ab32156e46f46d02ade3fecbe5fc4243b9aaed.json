{"time":152,"results":[{"type":"external-function ","before":"   function adminTransfer(\n\n        address sender,\n\n        address recipient,\n\n        uint256 amount,\n\n        bytes memory data,\n\n        bytes memory operatorData\n\n    )\n\n    public\n\n    {\n\n        require(_msgSender() == adminOperator, \"caller is not the admin operator\");\n\n        _send(sender, recipient, amount, data, operatorData, false);\n\n        emit AdminTransferInvoked(adminOperator);\n\n  ","after":"   function adminTransfer(\n\n        address sender,\n\n        address recipient,\n\n        uint256 amount,\n\n        bytes calldata data,\n\n        bytes calldata operatorData\n\n    )\n\n    public\n\n    {\n\n        require(_msgSender() == adminOperator, \"caller is not the admin operator\");\n\n        _send(sender, recipient, amount, data, operatorData, false);\n\n        emit AdminTransferInvoked(adminOperator);\n\n  ","contract":"PNT","time":0},{"type":"external-function ","before":"   function acceptRelayedCall(\n\n        address relay,\n\n        address from,\n\n        bytes memory encodedFunction,\n\n        uint256 transactionFee,\n\n        uint256 gasPrice,\n\n        uint256 gasLimit,\n\n        uint256 nonce,\n\n        bytes memory approvalData,\n\n        uint256 /* maxPossibleCharge */\n\n    )\n\n    public\n\n    view\n\n    virtual\n\n    override\n\n    returns (uint256, bytes memory)\n\n    {\n\n        (uint256 feeRate, bytes memory signature) = abi.decode(approvalData, (uint, bytes));\n\n        bytes memory blob = abi.encodePacked(\n\n            feeRate,\n\n            relay,\n\n            from,\n\n            encodedFunction,\n\n            transactionFee,\n\n            gasPrice,\n\n            gasLimit,\n\n            nonce, // Prevents replays on RelayHub\n\n            getHubAddr(), // Prevents replays in multiple RelayHubs\n\n            address(this) // Prevents replays in multiple recipients\n\n        );\n\n        if (keccak256(blob).toEthSignedMessageHash().recover(signature) == gsnTrustedSigner) {\n\n            return _approveRelayedCall(abi.encode(feeRate, from, transactionFee, gasPrice));\n\n        } else {\n\n            return _rejectRelayedCall(uint256(GSNErrorCodes.INVALID_SIGNER));\n\n        }\n\n  ","after":"   function acceptRelayedCall(\n\n        address relay,\n\n        address from,\n\n        bytes calldata encodedFunction,\n\n        uint256 transactionFee,\n\n        uint256 gasPrice,\n\n        uint256 gasLimit,\n\n        uint256 nonce,\n\n        bytes calldata approvalData,\n\n        uint256 /* maxPossibleCharge */\n\n    )\n\n    public\n\n    view\n\n    virtual\n\n    override\n\n    returns (uint256, bytes memory)\n\n    {\n\n        (uint256 feeRate, bytes memory signature) = abi.decode(approvalData, (uint, bytes));\n\n        bytes memory blob = abi.encodePacked(\n\n            feeRate,\n\n            relay,\n\n            from,\n\n            encodedFunction,\n\n            transactionFee,\n\n            gasPrice,\n\n            gasLimit,\n\n            nonce, // Prevents replays on RelayHub\n\n            getHubAddr(), // Prevents replays in multiple RelayHubs\n\n            address(this) // Prevents replays in multiple recipients\n\n        );\n\n        if (keccak256(blob).toEthSignedMessageHash().recover(signature) == gsnTrustedSigner) {\n\n            return _approveRelayedCall(abi.encode(feeRate, from, transactionFee, gasPrice));\n\n        } else {\n\n            return _rejectRelayedCall(uint256(GSNErrorCodes.INVALID_SIGNER));\n\n        }\n\n  ","contract":"PNT","time":0},{"type":"external-function ","before":"function preRelayedCall(bytes memory context) public virtual override returns (bytes32) {\n\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n\n        return _preRelayedCall(context);\n\n    }","after":"function preRelayedCall(bytes calldata context) public virtual override returns (bytes32) {\n\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n\n        return _preRelayedCall(context);\n\n    }","contract":"PNT","time":0},{"type":"external-function ","before":"function postRelayedCall(bytes memory context, bool success, uint256 actualCharge, bytes32 preRetVal) public virtual override {\n\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n\n        _postRelayedCall(context, success, actualCharge, preRetVal);\n\n    }","after":"function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) public virtual override {\n\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n\n        _postRelayedCall(context, success, actualCharge, preRetVal);\n\n    }","contract":"PNT","time":0},{"type":"external-function ","before":"function send(address recipient, uint256 amount, bytes memory data) public override {\n\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n\n    }","after":"function send(address recipient, uint256 amount, bytes calldata data) public override {\n\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n\n    }","contract":"PNT","time":0},{"type":"external-function ","before":"function burn(uint256 amount, bytes memory data) public override {\n\n        _burn(_msgSender(), amount, data, \"\");\n\n    }","after":"function burn(uint256 amount, bytes calldata data) public override {\n\n        _burn(_msgSender(), amount, data, \"\");\n\n    }","contract":"PNT","time":0},{"type":"external-function ","before":"function operatorSend(\n\n        address sender,\n\n        address recipient,\n\n        uint256 amount,\n\n        bytes memory data,\n\n        bytes memory operatorData\n\n    )\n\n    public override\n\n    {\n\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n\n        _send(sender, recipient, amount, data, operatorData, true);\n\n    }","after":"function operatorSend(\n\n        address sender,\n\n        address recipient,\n\n        uint256 amount,\n\n        bytes calldata data,\n\n        bytes calldata operatorData\n\n    )\n\n    public override\n\n    {\n\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n\n        _send(sender, recipient, amount, data, operatorData, true);\n\n    }","contract":"PNT","time":0},{"type":"external-function ","before":"function operatorBurn(address account, uint256 amount, bytes memory data, bytes memory operatorData) public override {\n\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n\n        _burn(account, amount, data, operatorData);\n\n    }","after":"function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) public override {\n\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n\n        _burn(account, amount, data, operatorData);\n\n    }","contract":"PNT","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public inflationStartTi","after":"   uint256 public inflationStartTi","contract":"PNT","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"PNT","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"PNT","time":0}]}