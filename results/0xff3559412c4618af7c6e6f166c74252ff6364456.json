{"time":379,"results":[{"type":"state-data-arrangement ","before":"\n address public contractOwner\n address payable public receiverAccount\n uint256 public price\n bool public forSale\n bool public permanentlyStop\n bytes32 internal keyHash\n uint256 internal fee\n uint256 internal randomResult\n mapping(bytes32 => address) buyerAddress","after":" uint256 public price\n bytes32 internal keyHash\n uint256 internal fee\n uint256 internal randomResult\n mapping(bytes32 => address) buyerAddress\n address public contractOwner\n address payable public receiverAccount\n bool public forSale\n bool public permanentlyStop\n","contract":"BuyEtherCatsFoundersSeries","time":0},{"type":"external-function ","before":" function burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) public {\n\n        require(account == msg.sender, \"You can only burn your own tokens.\");\n\n        _burnBatch(account, ids, amounts);\n\n    ","after":" function burnBatch(address account, uint256[] calldata ids, uint256[] calldata amounts) public {\n\n        require(account == msg.sender, \"You can only burn your own tokens.\");\n\n        _burnBatch(account, ids, amounts);\n\n    ","contract":"BuyEtherCatsFoundersSeries","time":0},{"type":"external-function ","before":" function setURI(string memory newuri) public onlyOwner {\n\n        _uri = newuri;\n\n    ","after":" function setURI(string calldata newuri) public onlyOwner {\n\n        _uri = newuri;\n\n    ","contract":"BuyEtherCatsFoundersSeries","time":0},{"type":"external-function ","before":"function balanceOfBatch(\n\n        address[] memory accounts,\n\n        uint256[] memory ids\n\n    )\n\n    public\n\n    view\n\n    override\n\n    returns (uint256[] memory) {\n\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\n\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n\n        }\n\n\n        return batchBalances;\n\n    }","after":"function balanceOfBatch(\n\n        address[] calldata accounts,\n\n        uint256[] calldata ids\n\n    )\n\n    public\n\n    view\n\n    override\n\n    returns (uint256[] memory) {\n\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\n\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n\n        }\n\n\n        return batchBalances;\n\n    }","contract":"BuyEtherCatsFoundersSeries","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n\n        address from,\n\n        address to,\n\n        uint256 id,\n\n        uint256 amount,\n\n        bytes memory data\n\n    )\n\n    public\n\n    virtual\n\n    override {\n\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        require(\n\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n\n            \"ERC1155: caller is not owner nor approved\"\n\n        );\n\n\n        address operator = _msgSender();\n\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n\n        _balances[id][to] = _balances[id][to].add(amount);\n\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n\n    }","after":"function safeTransferFrom(\n\n        address from,\n\n        address to,\n\n        uint256 id,\n\n        uint256 amount,\n\n        bytes calldata data\n\n    )\n\n    public\n\n    virtual\n\n    override {\n\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        require(\n\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n\n            \"ERC1155: caller is not owner nor approved\"\n\n        );\n\n\n        address operator = _msgSender();\n\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n\n        _balances[id][to] = _balances[id][to].add(amount);\n\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n\n    }","contract":"BuyEtherCatsFoundersSeries","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n\n        address from,\n\n        address to,\n\n        uint256[] memory ids,\n\n        uint256[] memory amounts,\n\n        bytes memory data\n\n    )\n\n    public\n\n    virtual\n\n    override {\n\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        require(\n\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n\n            \"ERC1155: transfer caller is not owner nor approved\"\n\n        );\n\n\n        address operator = _msgSender();\n\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n\n            uint256 id = ids[i];\n\n            uint256 amount = amounts[i];\n\n\n            _balances[id][from] = _balances[id][from].sub(\n\n                amount,\n\n                \"ERC1155: insufficient balance for transfer\"\n\n            );\n\n            _balances[id][to] = _balances[id][to].add(amount);\n\n        }\n\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n\n    }","after":"function safeBatchTransferFrom(\n\n        address from,\n\n        address to,\n\n        uint256[] calldata ids,\n\n        uint256[] calldata amounts,\n\n        bytes calldata data\n\n    )\n\n    public\n\n    virtual\n\n    override {\n\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        require(\n\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n\n            \"ERC1155: transfer caller is not owner nor approved\"\n\n        );\n\n\n        address operator = _msgSender();\n\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n\n            uint256 id = ids[i];\n\n            uint256 amount = amounts[i];\n\n\n            _balances[id][from] = _balances[id][from].sub(\n\n                amount,\n\n                \"ERC1155: insufficient balance for transfer\"\n\n            );\n\n            _balances[id][to] = _balances[id][to].add(amount);\n\n        }\n\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n\n    }","contract":"BuyEtherCatsFoundersSeries","time":0},{"type":"immutable-restrict-modification ","before":" address public contractOwner","after":" address public immutable contractOwner","contract":"BuyEtherCatsFoundersSeries","time":1},{"type":"immutable-restrict-modification ","before":" bytes32 internal keyHash","after":" bytes32 internal immutable keyHash","contract":"BuyEtherCatsFoundersSeries","time":1},{"type":"immutable-restrict-modification ","before":" uint256 internal fee","after":" uint256 internal immutable fee","contract":"BuyEtherCatsFoundersSeries","time":1},{"type":"constant-restrict-modification  ","before":" uint256 internal randomResult","after":" uint256 internal constant randomResult","contract":"BuyEtherCatsFoundersSeries","time":1}]}