{"time":69,"results":[{"type":"de-morgan-condition ","before":"!stopped && !hidden","after":"!(stopped && hidden)","loc":{"start":{"line":2398,"column":15},"end":{"line":2398,"column":28}},"contract":"KeyPurchaser","time":0},{"type":"external-function ","before":"function config(\n\n        string memory _name,\n\n        bool _hidden\n\n    ) public\n\n    onlyLockManager(lock)\n\n    {\n\n        name = _name;\n\n        hidden = _hidden;\n\n    }","after":"function config(\n\n        string calldata _name,\n\n        bool _hidden\n\n    ) public\n\n    onlyLockManager(lock)\n\n    {\n\n        name = _name;\n\n        hidden = _hidden;\n\n    }","contract":"KeyPurchaser","time":0},{"type":"external-function ","before":"function readyToPurchaseFor(\n\n        address payable _recipient,\n\n        address _referrer,\n\n        bytes memory _data\n\n    ) public view\n\n    {\n\n        uint purchasePrice = _readyToPurchaseFor(_recipient, _referrer, _data);\n\n        purchasePrice = purchasePrice.add(msgSenderReward);\n\n\n        // It's okay if the lock changes tokenAddress as the ERC-20 approval is specifically\n\n        // for the token the endUser wanted to spend\n\n        IERC20 token = IERC20(lock.tokenAddress());\n\n        require(token.balanceOf(_recipient) >= purchasePrice, 'INSUFFICIENT_BALANCE');\n\n        require(token.allowance(_recipient, address(this)) >= purchasePrice, 'INSUFFICIENT_ALLOWANCE');\n\n    }","after":"function readyToPurchaseFor(\n\n        address payable _recipient,\n\n        address _referrer,\n\n        bytes calldata _data\n\n    ) public view\n\n    {\n\n        uint purchasePrice = _readyToPurchaseFor(_recipient, _referrer, _data);\n\n        purchasePrice = purchasePrice.add(msgSenderReward);\n\n\n        // It's okay if the lock changes tokenAddress as the ERC-20 approval is specifically\n\n        // for the token the endUser wanted to spend\n\n        IERC20 token = IERC20(lock.tokenAddress());\n\n        require(token.balanceOf(_recipient) >= purchasePrice, 'INSUFFICIENT_BALANCE');\n\n        require(token.allowance(_recipient, address(this)) >= purchasePrice, 'INSUFFICIENT_ALLOWANCE');\n\n    }","contract":"KeyPurchaser","time":0},{"type":"external-function ","before":"function purchaseFor(\n\n        address payable _recipient,\n\n        address _referrer,\n\n        bytes memory _data\n\n    ) public\n\n    {\n\n        // It's okay if the lock changes tokenAddress as the ERC-20 approval is specifically\n\n        // the token the endUser wanted to spend\n\n        IERC20 token = IERC20(lock.tokenAddress());\n\n\n        uint keyPrice = _readyToPurchaseFor(_recipient, _referrer, _data);\n\n        uint totalCost = keyPrice.add(msgSenderReward);\n\n        if (totalCost > 0)\n\n        {\n\n            // We don't need safeTransfer as if these do not work the purchase will fail\n\n            token.transferFrom(_recipient, address(this), totalCost);\n\n            if (msgSenderReward > 0)\n\n            {\n\n                token.transfer(msg.sender, msgSenderReward);\n\n            }\n\n\n            // approve from this contract to the lock is already complete\n\n        }\n\n\n        lock.purchase(keyPrice, _recipient, _referrer, _data);\n\n        timestampOfLastPurchase[_recipient] = now;\n\n\n        // RE events: it's not clear emitting an event adds value over the ones from purchase and the token transfer\n\n    }","after":"function purchaseFor(\n\n        address payable _recipient,\n\n        address _referrer,\n\n        bytes calldata _data\n\n    ) public\n\n    {\n\n        // It's okay if the lock changes tokenAddress as the ERC-20 approval is specifically\n\n        // the token the endUser wanted to spend\n\n        IERC20 token = IERC20(lock.tokenAddress());\n\n\n        uint keyPrice = _readyToPurchaseFor(_recipient, _referrer, _data);\n\n        uint totalCost = keyPrice.add(msgSenderReward);\n\n        if (totalCost > 0)\n\n        {\n\n            // We don't need safeTransfer as if these do not work the purchase will fail\n\n            token.transferFrom(_recipient, address(this), totalCost);\n\n            if (msgSenderReward > 0)\n\n            {\n\n                token.transfer(msg.sender, msgSenderReward);\n\n            }\n\n\n            // approve from this contract to the lock is already complete\n\n        }\n\n\n        lock.purchase(keyPrice, _recipient, _referrer, _data);\n\n        timestampOfLastPurchase[_recipient] = now;\n\n\n        // RE events: it's not clear emitting an event adds value over the ones from purchase and the token transfer\n\n    }","contract":"KeyPurchaser","time":0}]}