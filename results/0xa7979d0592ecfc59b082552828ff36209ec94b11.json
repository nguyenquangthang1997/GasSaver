{"time":2139,"results":[{"type":"struct-data-arrangement ","before":"\n    int24 baseTickL\n    int24 baseTickU\n    uint128 baseLiqui\n    int24 rangeTickL\n    int24 rangeTickU\n    uint128 rangeLiqui\n    uint256 f\n    uint256 f\n    uint256 feeGrowthGlo\n    uint256 feeGrowthGlo\n    uint256 totalLiqui\n    bool feesInP\n    address ora\n    address ora\n    uint256 times\n    uint8 cou\n    bool st\n    bool man","after":"    uint256 f\n    uint256 f\n    uint256 feeGrowthGlo\n    uint256 feeGrowthGlo\n    uint256 totalLiqui\n    uint256 times\n    address ora\n    address ora\n    uint128 baseLiqui\n    uint128 rangeLiqui\n    int24 baseTickL\n    int24 baseTickU\n    int24 rangeTickL\n    int24 rangeTickU\n    bool feesInP\n    uint8 cou\n    bool st\n    bool man\n","contract":"IUniswapLiquidityManager","time":1628},{"type":"struct-data-arrangement ","before":"\n    uint8 swapPercen\n    uint24 swapPriceThres\n    uint256 pre\n    uint256 gasPriceL\n    uint256 userPilotPercen\n    uint256 feesPercentageIndex\n    uint24 readjustFrequency\n    uint16 poolCardinalityDes\n    address pilotWeth\n    address or\n    address index\n    address uniStra\n    address unip","after":"    uint256 pre\n    uint256 gasPriceL\n    uint256 userPilotPercen\n    uint256 feesPercentageIndex\n    address pilotWeth\n    address or\n    address index\n    address uniStra\n    address unip\n    uint24 swapPriceThres\n    uint24 readjustFrequency\n    uint16 poolCardinalityDes\n    uint8 swapPercen\n","contract":"IUniswapLiquidityManager","time":10},{"type":"struct-data-arrangement ","before":"\n    address to\n    address to\n    uint24\n    int24 current\n    uint128 baseLiqui\n    uint256 baseAmo\n    uint256 baseAmo\n    uint128 rangeLiqui\n    uint256 rangeAmo\n    uint256 rangeAmo","after":"    uint256 baseAmo\n    uint256 baseAmo\n    uint256 rangeAmo\n    uint256 rangeAmo\n    address to\n    address to\n    uint128 baseLiqui\n    uint128 rangeLiqui\n    uint24\n    int24 current\n","contract":"IUniswapLiquidityManager","time":0},{"type":"external-function ","before":"    function createPair(\n        address _token0,\n        address _token1,\n        bytes memory data\n    ) external override returns (address _pool) {\n        (uint24 _fee, uint160 _sqrtPriceX96) = abi.decode(data, (uint24, uint160));\n        _pool = IUniswapV3Factory(uniswapFactory).createPool(_token0, _token1, _fee);\n        IUniswapV3Pool(_pool).initialize(_sqrtPriceX96);\n        emit PoolCreated(_token0, _token1, _pool, _fee, _sqrtPriceX96);\n ","after":"    function createPair(\n        address _token0,\n        address _token1,\n        bytes calldata data\n    ) external override returns (address _pool) {\n        (uint24 _fee, uint160 _sqrtPriceX96) = abi.decode(data, (uint24, uint160));\n        _pool = IUniswapV3Factory(uniswapFactory).createPool(_token0, _token1, _fee);\n        IUniswapV3Pool(_pool).initialize(_sqrtPriceX96);\n        emit PoolCreated(_token0, _token1, _pool, _fee, _sqrtPriceX96);\n ","contract":"UniswapLiquidityManager","time":0},{"type":"external-function ","before":"    function deposit(\n        address token0,\n        address token1,\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        uint256 shares,\n        uint256 tokenId,\n        bool isTokenMinted,\n        bytes memory data\n    ) external payable override onlyUnipilot {\n        DepositVars memory b;\n        b.fee = abi.decode(data, (uint24));\n        b.pool = getPoolAddress(token0, token1, b.fee);\n        LiquidityPosition storage poolPosition = liquidityPositions[b.pool];\n\n        // updating the feeGrowthGlobal of pool for new user\n        if (poolPosition.totalLiquidity > 0) _collectPositionFees(b.pool);\n        (\n        b.amount0Base,\n        b.amount1Base,\n        b.amount0Range,\n        b.amount1Range\n        ) = _addLiquidityInManager(\n            AddLiquidityManagerParams({\n        pool : b.pool,\n        amount0Desired : amount0Desired,\n        amount1Desired : amount1Desired,\n        shares : shares\n        })\n        );\n\n        if (!isTokenMinted) {\n            Position storage userPosition = positions[tokenId];\n            require(b.pool == userPosition.pool);\n            userPosition.tokensOwed0 += FullMath.mulDiv(\n                poolPosition.feeGrowthGlobal0 - userPosition.feeGrowth0,\n                userPosition.liquidity,\n                FixedPoint128.Q128\n            );\n            userPosition.tokensOwed1 += FullMath.mulDiv(\n                poolPosition.feeGrowthGlobal1 - userPosition.feeGrowth1,\n                userPosition.liquidity,\n                FixedPoint128.Q128\n            );\n            userPosition.liquidity += shares;\n            userPosition.feeGrowth0 = poolPosition.feeGrowthGlobal0;\n            userPosition.feeGrowth1 = poolPosition.feeGrowthGlobal1;\n        } else {\n            positions[tokenId] = Position({\n            nonce : 0,\n            pool : b.pool,\n            liquidity : shares,\n            feeGrowth0 : poolPosition.feeGrowthGlobal0,\n            feeGrowth1 : poolPosition.feeGrowthGlobal1,\n            tokensOwed0 : 0,\n            tokensOwed1 : 0\n            });\n        }\n\n        _checkDustAmount(\n            b.pool,\n            (b.amount0Base + b.amount0Range),\n            (b.amount1Base + b.amount1Range),\n            amount0Desired,\n            amount1Desired\n        );\n\n        emit Deposited(b.pool, tokenId, amount0Desired, amount1Desired, shares);\n ","after":"    function deposit(\n        address token0,\n        address token1,\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        uint256 shares,\n        uint256 tokenId,\n        bool isTokenMinted,\n        bytes calldata data\n    ) external payable override onlyUnipilot {\n        DepositVars memory b;\n        b.fee = abi.decode(data, (uint24));\n        b.pool = getPoolAddress(token0, token1, b.fee);\n        LiquidityPosition storage poolPosition = liquidityPositions[b.pool];\n\n        // updating the feeGrowthGlobal of pool for new user\n        if (poolPosition.totalLiquidity > 0) _collectPositionFees(b.pool);\n        (\n        b.amount0Base,\n        b.amount1Base,\n        b.amount0Range,\n        b.amount1Range\n        ) = _addLiquidityInManager(\n            AddLiquidityManagerParams({\n        pool : b.pool,\n        amount0Desired : amount0Desired,\n        amount1Desired : amount1Desired,\n        shares : shares\n        })\n        );\n\n        if (!isTokenMinted) {\n            Position storage userPosition = positions[tokenId];\n            require(b.pool == userPosition.pool);\n            userPosition.tokensOwed0 += FullMath.mulDiv(\n                poolPosition.feeGrowthGlobal0 - userPosition.feeGrowth0,\n                userPosition.liquidity,\n                FixedPoint128.Q128\n            );\n            userPosition.tokensOwed1 += FullMath.mulDiv(\n                poolPosition.feeGrowthGlobal1 - userPosition.feeGrowth1,\n                userPosition.liquidity,\n                FixedPoint128.Q128\n            );\n            userPosition.liquidity += shares;\n            userPosition.feeGrowth0 = poolPosition.feeGrowthGlobal0;\n            userPosition.feeGrowth1 = poolPosition.feeGrowthGlobal1;\n        } else {\n            positions[tokenId] = Position({\n            nonce : 0,\n            pool : b.pool,\n            liquidity : shares,\n            feeGrowth0 : poolPosition.feeGrowthGlobal0,\n            feeGrowth1 : poolPosition.feeGrowthGlobal1,\n            tokensOwed0 : 0,\n            tokensOwed1 : 0\n            });\n        }\n\n        _checkDustAmount(\n            b.pool,\n            (b.amount0Base + b.amount0Range),\n            (b.amount1Base + b.amount1Range),\n            amount0Desired,\n            amount1Desired\n        );\n\n        emit Deposited(b.pool, tokenId, amount0Desired, amount1Desired, shares);\n ","contract":"UniswapLiquidityManager","time":0},{"type":"external-function ","before":"    function withdraw(\n        bool pilotToken,\n        bool wethToken,\n        uint256 liquidity,\n        uint256 tokenId,\n        bytes memory data\n    ) external payable override onlyUnipilot nonReentrant {\n        Position storage position = positions[tokenId];\n        require(liquidity > 0);\n        require(liquidity <= position.liquidity);\n        WithdrawVars memory c;\n        c.recipient = abi.decode(data, (address));\n\n        (c.amount0Removed, c.amount1Removed) = _removeLiquidityUniswap(\n            false,\n            position.pool,\n            liquidity\n        );\n\n        (c.userAmount0, c.userAmount1, c.pilotAmount) = _distributeFeesAndLiquidity(\n            DistributeFeesParams({\n        pilotToken : pilotToken,\n        wethToken : wethToken,\n        pool : position.pool,\n        recipient : c.recipient,\n        tokenId : tokenId,\n        liquidity : liquidity,\n        amount0Removed : c.amount0Removed,\n        amount1Removed : c.amount1Removed\n        })\n        );\n\n        emit Withdrawn(\n            position.pool,\n            c.recipient,\n            tokenId,\n            c.amount0Removed,\n            c.amount1Removed\n        );\n ","after":"    function withdraw(\n        bool pilotToken,\n        bool wethToken,\n        uint256 liquidity,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable override onlyUnipilot nonReentrant {\n        Position storage position = positions[tokenId];\n        require(liquidity > 0);\n        require(liquidity <= position.liquidity);\n        WithdrawVars memory c;\n        c.recipient = abi.decode(data, (address));\n\n        (c.amount0Removed, c.amount1Removed) = _removeLiquidityUniswap(\n            false,\n            position.pool,\n            liquidity\n        );\n\n        (c.userAmount0, c.userAmount1, c.pilotAmount) = _distributeFeesAndLiquidity(\n            DistributeFeesParams({\n        pilotToken : pilotToken,\n        wethToken : wethToken,\n        pool : position.pool,\n        recipient : c.recipient,\n        tokenId : tokenId,\n        liquidity : liquidity,\n        amount0Removed : c.amount0Removed,\n        amount1Removed : c.amount1Removed\n        })\n        );\n\n        emit Withdrawn(\n            position.pool,\n            c.recipient,\n            tokenId,\n            c.amount0Removed,\n            c.amount1Removed\n        );\n ","contract":"UniswapLiquidityManager","time":0},{"type":"external-function ","before":"    function collect(\n        bool pilotToken,\n        bool wethToken,\n        uint256 tokenId,\n        bytes memory data\n    ) external payable override onlyUnipilot nonReentrant {\n        Position memory position = positions[tokenId];\n        require(position.liquidity > 0);\n        address recipient = abi.decode(data, (address));\n\n        _collectPositionFees(position.pool);\n\n        _distributeFeesAndLiquidity(\n            DistributeFeesParams({\n        pilotToken : pilotToken,\n        wethToken : wethToken,\n        pool : position.pool,\n        recipient : recipient,\n        tokenId : tokenId,\n        liquidity : 0,\n        amount0Removed : 0,\n        amount1Removed : 0\n        })\n        );\n ","after":"    function collect(\n        bool pilotToken,\n        bool wethToken,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable override onlyUnipilot nonReentrant {\n        Position memory position = positions[tokenId];\n        require(position.liquidity > 0);\n        address recipient = abi.decode(data, (address));\n\n        _collectPositionFees(position.pool);\n\n        _distributeFeesAndLiquidity(\n            DistributeFeesParams({\n        pilotToken : pilotToken,\n        wethToken : wethToken,\n        pool : position.pool,\n        recipient : recipient,\n        tokenId : tokenId,\n        liquidity : 0,\n        amount0Removed : 0,\n        amount1Removed : 0\n        })\n        );\n ","contract":"UniswapLiquidityManager","time":0},{"type":"external-function ","before":"    function emergencyExit(address recipient, bytes[10] memory data)\n    external\n    onlyGovernance\n    {\n        for (uint256 i = 0; i < data.length; ++i) {\n            (\n            address token,\n            address pool,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity\n            ) = abi.decode(data[i], (address, address, int24, int24, uint128));\n\n            if (pool != address(0)) {\n                IUniswapV3Pool(pool).burn(tickLower, tickUpper, liquidity);\n\n                IUniswapV3Pool(pool).collect(\n                    recipient,\n                    tickLower,\n                    tickUpper,\n                    MAX_UINT128,\n                    MAX_UINT128\n                );\n            }\n\n            uint256 balanceToken = IERC20(token).balanceOf(address(this));\n            if (balanceToken > 0) {\n                TransferHelper.safeTransfer(token, recipient, balanceToken);\n            }\n        }\n ","after":"    function emergencyExit(address recipient, bytes[10] calldata data)\n    external\n    onlyGovernance\n    {\n        for (uint256 i = 0; i < data.length; ++i) {\n            (\n            address token,\n            address pool,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity\n            ) = abi.decode(data[i], (address, address, int24, int24, uint128));\n\n            if (pool != address(0)) {\n                IUniswapV3Pool(pool).burn(tickLower, tickUpper, liquidity);\n\n                IUniswapV3Pool(pool).collect(\n                    recipient,\n                    tickLower,\n                    tickUpper,\n                    MAX_UINT128,\n                    MAX_UINT128\n                );\n            }\n\n            uint256 balanceToken = IERC20(token).balanceOf(address(this));\n            if (balanceToken > 0) {\n                TransferHelper.safeTransfer(token, recipient, balanceToken);\n            }\n        }\n ","contract":"UniswapLiquidityManager","time":0}]}