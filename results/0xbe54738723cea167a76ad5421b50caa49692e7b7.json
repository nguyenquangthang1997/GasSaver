{"time":517,"results":[{"type":"constant-restrict-modification  ","before":"address private vaultAddress;","after":"address private constant vaultAddress;","contract":"D2Token","time":0},{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping(address => EnumerableSet.UintSet) private _holderTokens;\nEnumerableMap.UintToAddressMap private _tokenOwners;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nstring private _name;\nstring private _symbol;\nmapping(uint256 => string) private _tokenURIs;\nstring private _baseURI;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\nbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;","after":"mapping(address => EnumerableSet.UintSet) private _holderTokens;\nEnumerableMap.UintToAddressMap private _tokenOwners;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nstring private _name;\nstring private _symbol;\nmapping(uint256 => string) private _tokenURIs;\nstring private _baseURI;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\nbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n","contract":"ERC721","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public minTokenId;","after":"uint256 public immutable minTokenId;","contract":"ERC721Public","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public maxTokenId;","after":"uint256 public immutable maxTokenId;","contract":"ERC721Public","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC721Public","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC721Public","time":1},{"type":"struct-data-arrangement ","before":"\naddress xTokenAddress\naddress nftAddress\naddress manager\nIXToken xToken\nIERC721 nft\nEnumerableSet.UintSet holdings\nEnumerableSet.UintSet reserves\nmapping(uint256 => address) requester\nmapping(uint256 => bool) isEligible\nmapping(uint256 => bool) shouldReserve\nbool allowMintRequests\nbool flipEligOnRedeem\nbool negateEligibility\nbool isFinalized\nbool isClosed\nFeeParams mintFees\nFeeParams burnFees\nFeeParams dualFees\nBountyParams supplierBounty\nuint256 ethBalance\nuint256 tokenBalance\nbool isD2Vault\naddress d2AssetAddress\nIERC20 d2Asset\nuint256 d2Holdings","after":"IXToken xToken\nIERC721 nft\nEnumerableSet.UintSet holdings\nEnumerableSet.UintSet reserves\nmapping(uint256 => address) requester\nmapping(uint256 => bool) isEligible\nmapping(uint256 => bool) shouldReserve\nFeeParams mintFees\nFeeParams burnFees\nFeeParams dualFees\nBountyParams supplierBounty\nuint256 ethBalance\nuint256 tokenBalance\nIERC20 d2Asset\nuint256 d2Holdings\naddress xTokenAddress\naddress nftAddress\naddress manager\naddress d2AssetAddress\nbool allowMintRequests\nbool flipEligOnRedeem\nbool negateEligibility\nbool isFinalized\nbool isClosed\nbool isD2Vault\n","contract":"IXStore","time":3},{"type":"external-function ","before":"function requestMint(uint256 vaultId, uint256[] memory nftIds)\n    public\n    payable\n    virtual\n    nonReentrant\n    {\n        onlyOwnerIfPaused(1);\n        require(store.allowMintRequests(vaultId), \"Not allowed\");\n        // TODO: implement bounty + fees\n        for (uint256 i = 0; i < nftIds.length; i = i.add(1)) {\n            require(\n                store.nft(vaultId).ownerOf(nftIds[i]) != address(this),\n                \"Already owner\"\n            );\n            store.nft(vaultId).safeTransferFrom(\n                msg.sender,\n                address(this),\n                nftIds[i]\n            );\n            require(\n                store.nft(vaultId).ownerOf(nftIds[i]) == address(this),\n                \"Not received\"\n            );\n            store.setRequester(vaultId, nftIds[i], msg.sender);\n        }\n        emit MintRequested(vaultId, nftIds, msg.sender);\n    }","after":"function requestMint(uint256 vaultId, uint256[] calldata nftIds)\n    public\n    payable\n    virtual\n    nonReentrant\n    {\n        onlyOwnerIfPaused(1);\n        require(store.allowMintRequests(vaultId), \"Not allowed\");\n        // TODO: implement bounty + fees\n        for (uint256 i = 0; i < nftIds.length; i = i.add(1)) {\n            require(\n                store.nft(vaultId).ownerOf(nftIds[i]) != address(this),\n                \"Already owner\"\n            );\n            store.nft(vaultId).safeTransferFrom(\n                msg.sender,\n                address(this),\n                nftIds[i]\n            );\n            require(\n                store.nft(vaultId).ownerOf(nftIds[i]) == address(this),\n                \"Not received\"\n            );\n            store.setRequester(vaultId, nftIds[i], msg.sender);\n        }\n        emit MintRequested(vaultId, nftIds, msg.sender);\n    }","contract":"NFTXv2","time":0},{"type":"external-function ","before":"function revokeMintRequests(uint256 vaultId, uint256[] memory nftIds)\n    public\n    virtual\n    nonReentrant\n    {\n        for (uint256 i = 0; i < nftIds.length; i = i.add(1)) {\n            require(\n                store.requester(vaultId, nftIds[i]) == msg.sender,\n                \"Not requester\"\n            );\n            store.setRequester(vaultId, nftIds[i], address(0));\n            store.nft(vaultId).safeTransferFrom(\n                address(this),\n                msg.sender,\n                nftIds[i]\n            );\n        }\n    }","after":"function revokeMintRequests(uint256 vaultId, uint256[] calldata nftIds)\n    public\n    virtual\n    nonReentrant\n    {\n        for (uint256 i = 0; i < nftIds.length; i = i.add(1)) {\n            require(\n                store.requester(vaultId, nftIds[i]) == msg.sender,\n                \"Not requester\"\n            );\n            store.setRequester(vaultId, nftIds[i], address(0));\n            store.nft(vaultId).safeTransferFrom(\n                address(this),\n                msg.sender,\n                nftIds[i]\n            );\n        }\n    }","contract":"NFTXv2","time":0},{"type":"external-function ","before":"function approveMintRequest(uint256 vaultId, uint256[] memory nftIds)\n    public\n    virtual\n    {\n        onlyPrivileged(vaultId);\n        for (uint256 i = 0; i < nftIds.length; i = i.add(1)) {\n            address requester = store.requester(vaultId, nftIds[i]);\n            require(requester != address(0), \"No request\");\n            require(\n                store.nft(vaultId).ownerOf(nftIds[i]) == address(this),\n                \"Not owner\"\n            );\n            store.setRequester(vaultId, nftIds[i], address(0));\n            store.setIsEligible(vaultId, nftIds[i], true);\n            if (store.shouldReserve(vaultId, nftIds[i])) {\n                store.reservesAdd(vaultId, nftIds[i]);\n            } else {\n                store.holdingsAdd(vaultId, nftIds[i]);\n            }\n            store.xToken(vaultId).mint(requester, 10 ** 18);\n        }\n    }","after":"function approveMintRequest(uint256 vaultId, uint256[] calldata nftIds)\n    public\n    virtual\n    {\n        onlyPrivileged(vaultId);\n        for (uint256 i = 0; i < nftIds.length; i = i.add(1)) {\n            address requester = store.requester(vaultId, nftIds[i]);\n            require(requester != address(0), \"No request\");\n            require(\n                store.nft(vaultId).ownerOf(nftIds[i]) == address(this),\n                \"Not owner\"\n            );\n            store.setRequester(vaultId, nftIds[i], address(0));\n            store.setIsEligible(vaultId, nftIds[i], true);\n            if (store.shouldReserve(vaultId, nftIds[i])) {\n                store.reservesAdd(vaultId, nftIds[i]);\n            } else {\n                store.holdingsAdd(vaultId, nftIds[i]);\n            }\n            store.xToken(vaultId).mint(requester, 10 ** 18);\n        }\n    }","contract":"NFTXv2","time":0},{"type":"external-function ","before":"function mint(uint256 vaultId, uint256[] memory nftIds, uint256 d2Amount)\n    public\n    payable\n    virtual\n    nonReentrant\n    {\n        onlyOwnerIfPaused(1);\n        uint256 amount = store.isD2Vault(vaultId) ? d2Amount : nftIds.length;\n        uint256 ethBounty = store.isD2Vault(vaultId)\n        ? _calcBountyD2(vaultId, d2Amount, false)\n        : _calcBounty(vaultId, amount, false);\n        (uint256 ethBase, uint256 ethStep) = store.mintFees(vaultId);\n        uint256 ethFee = _calcFee(\n            amount,\n            ethBase,\n            ethStep,\n            store.isD2Vault(vaultId)\n        );\n        if (ethFee > ethBounty) {\n            _receiveEthToVault(vaultId, ethFee.sub(ethBounty), msg.value);\n        }\n        if (store.isD2Vault(vaultId)) {\n            _mintD2(vaultId, d2Amount);\n        } else {\n            _mint(vaultId, nftIds, false);\n        }\n        if (ethBounty > ethFee) {\n            _payEthFromVault(vaultId, ethBounty.sub(ethFee), msg.sender);\n        }\n        emit Mint(vaultId, nftIds, d2Amount, msg.sender);\n    }","after":"function mint(uint256 vaultId, uint256[] calldata nftIds, uint256 d2Amount)\n    public\n    payable\n    virtual\n    nonReentrant\n    {\n        onlyOwnerIfPaused(1);\n        uint256 amount = store.isD2Vault(vaultId) ? d2Amount : nftIds.length;\n        uint256 ethBounty = store.isD2Vault(vaultId)\n        ? _calcBountyD2(vaultId, d2Amount, false)\n        : _calcBounty(vaultId, amount, false);\n        (uint256 ethBase, uint256 ethStep) = store.mintFees(vaultId);\n        uint256 ethFee = _calcFee(\n            amount,\n            ethBase,\n            ethStep,\n            store.isD2Vault(vaultId)\n        );\n        if (ethFee > ethBounty) {\n            _receiveEthToVault(vaultId, ethFee.sub(ethBounty), msg.value);\n        }\n        if (store.isD2Vault(vaultId)) {\n            _mintD2(vaultId, d2Amount);\n        } else {\n            _mint(vaultId, nftIds, false);\n        }\n        if (ethBounty > ethFee) {\n            _payEthFromVault(vaultId, ethBounty.sub(ethFee), msg.sender);\n        }\n        emit Mint(vaultId, nftIds, d2Amount, msg.sender);\n    }","contract":"NFTXv2","time":0},{"type":"external-function ","before":"function setIsEligible(\n        uint256 vaultId,\n        uint256[] memory nftIds,\n        bool _boolean\n    ) public virtual {\n        onlyPrivileged(vaultId);\n        for (uint256 i = 0; i < nftIds.length; i = i.add(1)) {\n            store.setIsEligible(vaultId, nftIds[i], _boolean);\n        }\n    }","after":"function setIsEligible(\n        uint256 vaultId,\n        uint256[] calldata nftIds,\n        bool _boolean\n    ) public virtual {\n        onlyPrivileged(vaultId);\n        for (uint256 i = 0; i < nftIds.length; i = i.add(1)) {\n            store.setIsEligible(vaultId, nftIds[i], _boolean);\n        }\n    }","contract":"NFTXv2","time":0},{"type":"external-function ","before":"function changeTokenName(uint256 vaultId, string memory newName)\n    public\n    virtual\n    {\n        onlyPrivileged(vaultId);\n        store.xToken(vaultId).changeName(newName);\n    }","after":"function changeTokenName(uint256 vaultId, string calldata newName)\n    public\n    virtual\n    {\n        onlyPrivileged(vaultId);\n        store.xToken(vaultId).changeName(newName);\n    }","contract":"NFTXv2","time":0},{"type":"external-function ","before":"function changeTokenSymbol(uint256 vaultId, string memory newSymbol)\n    public\n    virtual\n    {\n        onlyPrivileged(vaultId);\n        store.xToken(vaultId).changeSymbol(newSymbol);\n    }","after":"function changeTokenSymbol(uint256 vaultId, string calldata newSymbol)\n    public\n    virtual\n    {\n        onlyPrivileged(vaultId);\n        store.xToken(vaultId).changeSymbol(newSymbol);\n    }","contract":"NFTXv2","time":0},{"type":"external-function ","before":"function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }","after":"function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }","contract":"NFTXv2","time":0},{"type":"external-function ","before":"function stageFuncCall(\n        uint256 _funcIndex,\n        address payable _addressParam,\n        uint256[] memory _uintArrayParam\n    ) public virtual onlyOwner {\n        uint256 fcId = numFuncCalls;\n        numFuncCalls = numFuncCalls.add(1);\n        time[fcId] = now;\n        funcIndex[fcId] = _funcIndex;\n        addressParam[fcId] = _addressParam;\n        uintArrayParam[fcId] = _uintArrayParam;\n    }","after":"function stageFuncCall(\n        uint256 _funcIndex,\n        address payable _addressParam,\n        uint256[] calldata _uintArrayParam\n    ) public virtual onlyOwner {\n        uint256 fcId = numFuncCalls;\n        numFuncCalls = numFuncCalls.add(1);\n        time[fcId] = now;\n        funcIndex[fcId] = _funcIndex;\n        addressParam[fcId] = _addressParam;\n        uintArrayParam[fcId] = _uintArrayParam;\n    }","contract":"UpgradeController","time":0},{"type":"external-function ","before":"function stageFuncCall(\n        uint256 _funcIndex,\n        address payable _addressParam,\n        uint256 _uintParam,\n        string memory _stringParam,\n        uint256[] memory _uintArrayParam,\n        bool _boolParam\n    ) public virtual {\n        onlyOwnerOrLeadDev(_funcIndex);\n        uint256 fcId = numFuncCalls;\n        numFuncCalls = numFuncCalls.add(1);\n        time[fcId] = 1;\n        funcIndex[fcId] = _funcIndex;\n        addressParam[fcId] = _addressParam;\n        uintParam[fcId] = _uintParam;\n        stringParam[fcId] = _stringParam;\n        uintArrayParam[fcId] = _uintArrayParam;\n        boolParam[fcId] = _boolParam;\n        if (\n            funcIndex[fcId] == 4 &&\n            store.negateEligibility(uintParam[fcId]) != !boolParam[fcId]\n        ) {\n            pendingEligAdditions[uintParam[fcId]] = pendingEligAdditions[uintParam[fcId]]\n            .add(uintArrayParam[fcId].length);\n        }\n    }","after":"function stageFuncCall(\n        uint256 _funcIndex,\n        address payable _addressParam,\n        uint256 _uintParam,\n        string calldata _stringParam,\n        uint256[] calldata _uintArrayParam,\n        bool _boolParam\n    ) public virtual {\n        onlyOwnerOrLeadDev(_funcIndex);\n        uint256 fcId = numFuncCalls;\n        numFuncCalls = numFuncCalls.add(1);\n        time[fcId] = 1;\n        funcIndex[fcId] = _funcIndex;\n        addressParam[fcId] = _addressParam;\n        uintParam[fcId] = _uintParam;\n        stringParam[fcId] = _stringParam;\n        uintArrayParam[fcId] = _uintArrayParam;\n        boolParam[fcId] = _boolParam;\n        if (\n            funcIndex[fcId] == 4 &&\n            store.negateEligibility(uintParam[fcId]) != !boolParam[fcId]\n        ) {\n            pendingEligAdditions[uintParam[fcId]] = pendingEligAdditions[uintParam[fcId]]\n            .add(uintArrayParam[fcId].length);\n        }\n    }","contract":"XController","time":0},{"type":"external-function ","before":"function stageFuncCall(\n        uint256 _funcIndex,\n        address payable _addressParam,\n        uint256[] memory _uintArrayParam\n    ) public virtual onlyOwner {\n        uint256 fcId = numFuncCalls;\n        numFuncCalls = numFuncCalls.add(1);\n        time[fcId] = now;\n        funcIndex[fcId] = _funcIndex;\n        addressParam[fcId] = _addressParam;\n        uintArrayParam[fcId] = _uintArrayParam;\n    }","after":"function stageFuncCall(\n        uint256 _funcIndex,\n        address payable _addressParam,\n        uint256[] calldata _uintArrayParam\n    ) public virtual onlyOwner {\n        uint256 fcId = numFuncCalls;\n        numFuncCalls = numFuncCalls.add(1);\n        time[fcId] = now;\n        funcIndex[fcId] = _funcIndex;\n        addressParam[fcId] = _addressParam;\n        uintArrayParam[fcId] = _uintArrayParam;\n    }","contract":"XController","time":0},{"type":"struct-data-arrangement ","before":"\naddress xTokenAddress\naddress nftAddress\naddress manager\nIXToken xToken\nIERC721 nft\nEnumerableSet.UintSet holdings\nEnumerableSet.UintSet reserves\nmapping(uint256 => address) requester\nmapping(uint256 => bool) isEligible\nmapping(uint256 => bool) shouldReserve\nbool allowMintRequests\nbool flipEligOnRedeem\nbool negateEligibility\nbool isFinalized\nbool isClosed\nFeeParams mintFees\nFeeParams burnFees\nFeeParams dualFees\nBountyParams supplierBounty\nuint256 ethBalance\nuint256 tokenBalance\nbool isD2Vault\naddress d2AssetAddress\nIERC20 d2Asset\nuint256 d2Holdings","after":"IXToken xToken\nIERC721 nft\nEnumerableSet.UintSet holdings\nEnumerableSet.UintSet reserves\nmapping(uint256 => address) requester\nmapping(uint256 => bool) isEligible\nmapping(uint256 => bool) shouldReserve\nFeeParams mintFees\nFeeParams burnFees\nFeeParams dualFees\nBountyParams supplierBounty\nuint256 ethBalance\nuint256 tokenBalance\nIERC20 d2Asset\nuint256 d2Holdings\naddress xTokenAddress\naddress nftAddress\naddress manager\naddress d2AssetAddress\nbool allowMintRequests\nbool flipEligOnRedeem\nbool negateEligibility\nbool isFinalized\nbool isClosed\nbool isD2Vault\n","contract":"XStore","time":1},{"type":"external-function ","before":"function changeName(string memory name) public onlyOwner {\n        _changeName(name);\n    }","after":"function changeName(string calldata name) public onlyOwner {\n        _changeName(name);\n    }","contract":"XToken","time":0},{"type":"external-function ","before":"function changeSymbol(string memory symbol) public onlyOwner {\n        _changeSymbol(symbol);\n    }","after":"function changeSymbol(string calldata symbol) public onlyOwner {\n        _changeSymbol(symbol);\n    }","contract":"XToken","time":0}]}