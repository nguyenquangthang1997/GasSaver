{"time":601,"results":[{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"FraudChallenge","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"FraudChallenge","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"FraudChallenge","time":0},{"type":"external-function ","before":"function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }","after":"function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function hashPaymentAsWallet(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 amountCurrencyHash = hashPaymentAmountCurrency(payment);\n        bytes32 senderHash = hashPaymentSenderPartyAsWallet(payment.sender);\n        bytes32 recipientHash = hashAddress(payment.recipient.wallet);\n\n        return keccak256(abi.encodePacked(amountCurrencyHash, senderHash, recipientHash));\n    }","after":"function hashPaymentAsWallet(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 amountCurrencyHash = hashPaymentAmountCurrency(payment);\n        bytes32 senderHash = hashPaymentSenderPartyAsWallet(payment.sender);\n        bytes32 recipientHash = hashAddress(payment.recipient.wallet);\n\n        return keccak256(abi.encodePacked(amountCurrencyHash, senderHash, recipientHash));\n    }","contract":"PaymentHasher","time":0},{"type":"external-function ","before":"function hashPaymentAsOperator(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 walletSignatureHash = hashSignature(payment.seals.wallet.signature);\n        bytes32 senderHash = hashPaymentSenderPartyAsOperator(payment.sender);\n        bytes32 recipientHash = hashPaymentRecipientPartyAsOperator(payment.recipient);\n        bytes32 transfersHash = hashSingleTotalInt256(payment.transfers);\n        bytes32 operatorHash = hashString(payment.operator.data);\n\n        return keccak256(abi.encodePacked(\n                walletSignatureHash, senderHash, recipientHash, transfersHash, operatorHash\n            ));\n    }","after":"function hashPaymentAsOperator(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 walletSignatureHash = hashSignature(payment.seals.wallet.signature);\n        bytes32 senderHash = hashPaymentSenderPartyAsOperator(payment.sender);\n        bytes32 recipientHash = hashPaymentRecipientPartyAsOperator(payment.recipient);\n        bytes32 transfersHash = hashSingleTotalInt256(payment.transfers);\n        bytes32 operatorHash = hashString(payment.operator.data);\n\n        return keccak256(abi.encodePacked(\n                walletSignatureHash, senderHash, recipientHash, transfersHash, operatorHash\n            ));\n    }","contract":"PaymentHasher","time":0},{"type":"external-function ","before":"function isGenuinePaymentSeals(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentWalletSeal(payment) && isGenuinePaymentOperatorSeal(payment);\n    }","after":"function isGenuinePaymentSeals(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentWalletSeal(payment) && isGenuinePaymentOperatorSeal(payment);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentFeeOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        int256 feePartsPer = int256(ConstantsLib.PARTS_PER());\n\n        int256 feeAmount = payment.amount\n        .mul(\n            configuration.currencyPaymentFee(\n                payment.blockNumber, payment.currency.ct, payment.currency.id, payment.amount\n            )\n        ).div(feePartsPer);\n\n        if (1 > feeAmount)\n            feeAmount = 1;\n\n        return (payment.sender.fees.single.amount == feeAmount);\n    }","after":"function isGenuinePaymentFeeOfFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        int256 feePartsPer = int256(ConstantsLib.PARTS_PER());\n\n        int256 feeAmount = payment.amount\n        .mul(\n            configuration.currencyPaymentFee(\n                payment.blockNumber, payment.currency.ct, payment.currency.id, payment.amount\n            )\n        ).div(feePartsPer);\n\n        if (1 > feeAmount)\n            feeAmount = 1;\n\n        return (payment.sender.fees.single.amount == feeAmount);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentFeeOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        (address feeCurrencyCt, uint256 feeCurrencyId) = configuration.feeCurrency(\n            payment.blockNumber, payment.currency.ct, payment.currency.id\n        );\n\n        return feeCurrencyCt == payment.sender.fees.single.currency.ct\n        && feeCurrencyId == payment.sender.fees.single.currency.id;\n    }","after":"function isGenuinePaymentFeeOfNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        (address feeCurrencyCt, uint256 feeCurrencyId) = configuration.feeCurrency(\n            payment.blockNumber, payment.currency.ct, payment.currency.id\n        );\n\n        return feeCurrencyCt == payment.sender.fees.single.currency.ct\n        && feeCurrencyId == payment.sender.fees.single.currency.id;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentSenderOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet))\n        && (payment.sender.balances.current == payment.sender.balances.previous.sub(payment.transfers.single).sub(payment.sender.fees.single.amount));\n    }","after":"function isGenuinePaymentSenderOfFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet))\n        && (payment.sender.balances.current == payment.sender.balances.previous.sub(payment.transfers.single).sub(payment.sender.fees.single.amount));\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentRecipientOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (payment.recipient.balances.current == payment.recipient.balances.previous.add(payment.transfers.single));\n    }","after":"function isGenuinePaymentRecipientOfFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (payment.recipient.balances.current == payment.recipient.balances.previous.add(payment.transfers.single));\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentSenderOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet));\n    }","after":"function isGenuinePaymentSenderOfNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet));\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentRecipientOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet);\n    }","after":"function isGenuinePaymentRecipientOfNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isSuccessivePaymentsPartyNonces(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment memory lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole\n    )\n    public\n    pure\n    returns (bool)\n    {\n        uint256 firstNonce = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.nonce : firstPayment.recipient.nonce);\n        uint256 lastNonce = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.nonce : lastPayment.recipient.nonce);\n        return lastNonce == firstNonce.add(1);\n    }","after":"function isSuccessivePaymentsPartyNonces(\n        PaymentTypesLib.Payment calldata firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment calldata lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole\n    )\n    public\n    pure\n    returns (bool)\n    {\n        uint256 firstNonce = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.nonce : firstPayment.recipient.nonce);\n        uint256 lastNonce = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.nonce : lastPayment.recipient.nonce);\n        return lastNonce == firstNonce.add(1);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuineSuccessivePaymentsBalances(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment memory lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole,\n        int256 delta\n    )\n    public\n    pure\n    returns (bool)\n    {\n        NahmiiTypesLib.CurrentPreviousInt256 memory firstCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.balances : firstPayment.recipient.balances);\n        NahmiiTypesLib.CurrentPreviousInt256 memory lastCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.balances : lastPayment.recipient.balances);\n\n        return lastCurrentPreviousBalances.previous == firstCurrentPreviousBalances.current.add(delta);\n    }","after":"function isGenuineSuccessivePaymentsBalances(\n        PaymentTypesLib.Payment calldata firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment calldata lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole,\n        int256 delta\n    )\n    public\n    pure\n    returns (bool)\n    {\n        NahmiiTypesLib.CurrentPreviousInt256 memory firstCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.balances : firstPayment.recipient.balances);\n        NahmiiTypesLib.CurrentPreviousInt256 memory lastCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.balances : lastPayment.recipient.balances);\n\n        return lastCurrentPreviousBalances.previous == firstCurrentPreviousBalances.current.add(delta);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuineSuccessivePaymentsTotalFees(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.Payment memory lastPayment\n    )\n    public\n    pure\n    returns (bool)\n    {\n        MonetaryTypesLib.Figure memory firstTotalFee = getProtocolFigureByCurrency(firstPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        MonetaryTypesLib.Figure memory lastTotalFee = getProtocolFigureByCurrency(lastPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        return lastTotalFee.amount == firstTotalFee.amount.add(lastPayment.sender.fees.single.amount);\n    }","after":"function isGenuineSuccessivePaymentsTotalFees(\n        PaymentTypesLib.Payment calldata firstPayment,\n        PaymentTypesLib.Payment calldata lastPayment\n    )\n    public\n    pure\n    returns (bool)\n    {\n        MonetaryTypesLib.Figure memory firstTotalFee = getProtocolFigureByCurrency(firstPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        MonetaryTypesLib.Figure memory lastTotalFee = getProtocolFigureByCurrency(lastPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        return lastTotalFee.amount == firstTotalFee.amount.add(lastPayment.sender.fees.single.amount);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentParty(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet || wallet == payment.recipient.wallet;\n    }","after":"function isPaymentParty(PaymentTypesLib.Payment calldata payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet || wallet == payment.recipient.wallet;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentSender(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet;\n    }","after":"function isPaymentSender(PaymentTypesLib.Payment calldata payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentRecipient(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.recipient.wallet;\n    }","after":"function isPaymentRecipient(PaymentTypesLib.Payment calldata payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.recipient.wallet;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentCurrency(PaymentTypesLib.Payment memory payment, MonetaryTypesLib.Currency memory currency)\n    public\n    pure\n    returns (bool)\n    {\n        return currency.ct == payment.currency.ct && currency.id == payment.currency.id;\n    }","after":"function isPaymentCurrency(PaymentTypesLib.Payment calldata payment, MonetaryTypesLib.Currency calldata currency)\n    public\n    pure\n    returns (bool)\n    {\n        return currency.ct == payment.currency.ct && currency.id == payment.currency.id;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentCurrencyNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return payment.currency.ct != payment.sender.fees.single.currency.ct\n        || payment.currency.id != payment.sender.fees.single.currency.id;\n    }","after":"function isPaymentCurrencyNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bool)\n    {\n        return payment.currency.ct != payment.sender.fees.single.currency.ct\n        || payment.currency.id != payment.sender.fees.single.currency.id;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function transferController(address currencyCt, string memory standard)\npublic\nview\nreturns (TransferController)\n{\nif (bytes(standard).length > 0) {\nbytes32 standardHash = keccak256(abi.encodePacked(standard));\n\nrequire(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\nreturn TransferController(registeredTransferControllers[standardHash]);\n}\n\nrequire(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\nrequire(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\naddress controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\nrequire(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\nreturn TransferController(controllerAddress);\n}","after":"function transferController(address currencyCt, string calldata standard)\npublic\nview\nreturns (TransferController)\n{\nif (bytes(standard).length > 0) {\nbytes32 standardHash = keccak256(abi.encodePacked(standard));\n\nrequire(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\nreturn TransferController(registeredTransferControllers[standardHash]);\n}\n\nrequire(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\nrequire(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\naddress controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\nrequire(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\nreturn TransferController(controllerAddress);\n}","contract":"TransferControllerManager","time":0},{"type":"external-function ","before":"function receiveTokens(string memory, int256 amount, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\nreceiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n}","after":"function receiveTokens(string calldata, int256 amount, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\nreceiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n}","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function claimAndTransferToBeneficiary(Beneficiary beneficiary, string memory balanceType, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\n// Claim reward\nint256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n// Subtract from deposited balance\ndeposited.sub(claimedAmount, currencyCt, currencyId);\n\n// Execute transfer\nif (address(0) == currencyCt && 0 == currencyId)\nbeneficiary.receiveEthersTo.value(uint256(claimedAmount))(msg.sender, balanceType);\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\n)\n);\nrequire(success, \"Approval by controller failed [SecurityBond.sol:350]\");\nbeneficiary.receiveTokensTo(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}\n\n// Emit event\nemit ClaimAndTransferToBeneficiaryEvent(msg.sender, beneficiary, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}","after":"function claimAndTransferToBeneficiary(Beneficiary beneficiary, string calldata balanceType, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\n// Claim reward\nint256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n// Subtract from deposited balance\ndeposited.sub(claimedAmount, currencyCt, currencyId);\n\n// Execute transfer\nif (address(0) == currencyCt && 0 == currencyId)\nbeneficiary.receiveEthersTo.value(uint256(claimedAmount))(msg.sender, balanceType);\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\n)\n);\nrequire(success, \"Approval by controller failed [SecurityBond.sol:350]\");\nbeneficiary.receiveTokensTo(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}\n\n// Emit event\nemit ClaimAndTransferToBeneficiaryEvent(msg.sender, beneficiary, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\n// Require that amount is strictly positive\nrequire(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [SecurityBond.sol:386]\");\n\n// Clamp amount to the max given by staged balance\namount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n// Subtract to per-wallet staged balance\nstagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n// Execute transfer\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Dispatch by controller failed [SecurityBond.sol:405]\");\n}\n\n// Emit event\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n}","after":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\n// Require that amount is strictly positive\nrequire(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [SecurityBond.sol:386]\");\n\n// Clamp amount to the max given by staged balance\namount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n// Subtract to per-wallet staged balance\nstagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n// Execute transfer\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Dispatch by controller failed [SecurityBond.sol:405]\");\n}\n\n// Emit event\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n}","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function lockNonFungibleByProxy(address lockedWallet, address lockerWallet, int256[] memory ids,\naddress currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\npublic\nonlyAuthorizedService(lockedWallet)\n{\n// Require that locked and locker wallets are not identical\nrequire(lockedWallet != lockerWallet);\n\n// Get index of lock\nuint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n// Require that there is no existing conflicting lock\nrequire(\n(0 == lockIndex) ||\n(block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n);\n\n// Add lock object for this triplet of locked wallet, currency and locker wallet if it does not exist\nif (0 == lockIndex) {\nlockIndex = ++(walletNonFungibleLocks[lockedWallet].length);\nlockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\nwalletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n}\n\n// Update lock parameters\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].ids = ids;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\nblock.timestamp.add(visibleTimeoutInSeconds);\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\nblock.timestamp.add(configuration.walletLockTimeout());\n\n// Emit event\nemit LockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId, visibleTimeoutInSeconds);\n}","after":"function lockNonFungibleByProxy(address lockedWallet, address lockerWallet, int256[] calldata ids,\naddress currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\npublic\nonlyAuthorizedService(lockedWallet)\n{\n// Require that locked and locker wallets are not identical\nrequire(lockedWallet != lockerWallet);\n\n// Get index of lock\nuint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n// Require that there is no existing conflicting lock\nrequire(\n(0 == lockIndex) ||\n(block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n);\n\n// Add lock object for this triplet of locked wallet, currency and locker wallet if it does not exist\nif (0 == lockIndex) {\nlockIndex = ++(walletNonFungibleLocks[lockedWallet].length);\nlockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\nwalletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n}\n\n// Update lock parameters\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].ids = ids;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\nblock.timestamp.add(visibleTimeoutInSeconds);\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\nblock.timestamp.add(configuration.walletLockTimeout());\n\n// Emit event\nemit LockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId, visibleTimeoutInSeconds);\n}","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function authorizeRegisteredServiceAction(address service, string memory action)\npublic\nnotNullOrThisAddress(service)\n{\nrequire(msg.sender != service);\n\nbytes32 actionHash = hashString(action);\n\n// Ensure service action is registered\nrequire(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n// Ensure service is not initial\nrequire(!initialServiceAuthorizedMap[service]);\n\n// Enable service action for given wallet\nserviceWalletAuthorizedMap[service][msg.sender] = false;\nserviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\nif (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\nserviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\nserviceWalletActionList[service][msg.sender].push(actionHash);\n}\n\n// Emit event\nemit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n}","after":"function authorizeRegisteredServiceAction(address service, string calldata action)\npublic\nnotNullOrThisAddress(service)\n{\nrequire(msg.sender != service);\n\nbytes32 actionHash = hashString(action);\n\n// Ensure service action is registered\nrequire(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n// Ensure service is not initial\nrequire(!initialServiceAuthorizedMap[service]);\n\n// Enable service action for given wallet\nserviceWalletAuthorizedMap[service][msg.sender] = false;\nserviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\nif (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\nserviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\nserviceWalletActionList[service][msg.sender].push(actionHash);\n}\n\n// Emit event\nemit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n}","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function unauthorizeRegisteredServiceAction(address service, string memory action)\npublic\nnotNullOrThisAddress(service)\n{\nrequire(msg.sender != service);\n\nbytes32 actionHash = hashString(action);\n\n// Ensure service is registered and action enabled\nrequire(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n// Ensure service is not initial as it can not be unauthorized per action\nrequire(!initialServiceAuthorizedMap[service]);\n\n// Disable service action for given wallet\nserviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n// Emit event\nemit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n}","after":"function unauthorizeRegisteredServiceAction(address service, string calldata action)\npublic\nnotNullOrThisAddress(service)\n{\nrequire(msg.sender != service);\n\nbytes32 actionHash = hashString(action);\n\n// Ensure service is registered and action enabled\nrequire(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n// Ensure service is not initial as it can not be unauthorized per action\nrequire(!initialServiceAuthorizedMap[service]);\n\n// Disable service action for given wallet\nserviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n// Emit event\nemit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n}","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function isAuthorizedRegisteredServiceAction(address service, string memory action, address wallet)\npublic\nview\nreturns (bool)\n{\nbytes32 actionHash = hashString(action);\n\nreturn isEnabledServiceAction(service, action) &&\n(\nisInitialServiceAuthorizedForWallet(service, wallet) ||\nserviceWalletAuthorizedMap[service][wallet] ||\nserviceActionWalletAuthorizedMap[service][actionHash][wallet]\n);\n}","after":"function isAuthorizedRegisteredServiceAction(address service, string calldata action, address wallet)\npublic\nview\nreturns (bool)\n{\nbytes32 actionHash = hashString(action);\n\nreturn isEnabledServiceAction(service, action) &&\n(\nisInitialServiceAuthorizedForWallet(service, wallet) ||\nserviceWalletAuthorizedMap[service][wallet] ||\nserviceActionWalletAuthorizedMap[service][actionHash][wallet]\n);\n}","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function challenge(PaymentTypesLib.Payment memory payment)\npublic\nonlyOperationalModeNormal\nonlyOperatorSealedPayment(payment)\n{\nrequire(validator.isGenuinePaymentWalletHash(payment), \"Not genuine payment wallet hash found [FraudChallengeByPayment.sol:48]\");\n\n// Genuineness affected by wallet not having signed the payment\nbool genuineWalletSignature = validator.isGenuineWalletSignature(\npayment.seals.wallet.hash, payment.seals.wallet.signature, payment.sender.wallet\n);\n\n// Genuineness affected by sender and recipient\n(bool genuineSenderAndFee, bool genuineRecipient) =\nvalidator.isPaymentCurrencyNonFungible(payment) ?\n(\nvalidator.isGenuinePaymentSenderOfNonFungible(payment) && validator.isGenuinePaymentFeeOfNonFungible(payment),\nvalidator.isGenuinePaymentRecipientOfNonFungible(payment)\n) :\n(\nvalidator.isGenuinePaymentSenderOfFungible(payment) && validator.isGenuinePaymentFeeOfFungible(payment),\nvalidator.isGenuinePaymentRecipientOfFungible(payment)\n);\n\n// Require existence of fraud signal\nrequire(!(genuineWalletSignature && genuineSenderAndFee && genuineRecipient), \"Fraud signal not found [FraudChallengeByPayment.sol:68]\");\n\n// Toggle operational mode exit\nconfiguration.setOperationalModeExit();\n\n// Tag payment (hash) as fraudulent\nfraudChallenge.addFraudulentPaymentHash(payment.seals.operator.hash);\n\n// Reward stake fraction\nsecurityBond.rewardFractional(msg.sender, configuration.fraudStakeFraction(), 0);\n\n// Lock amount of size equivalent to payment amount of sender\nif (!genuineSenderAndFee)\nwalletLocker.lockFungibleByProxy(\npayment.sender.wallet, msg.sender, payment.sender.balances.current,\npayment.currency.ct, payment.currency.id, 0\n);\n\n// Lock amount of size equivalent to payment amount of recipient\nif (!genuineRecipient)\nwalletLocker.lockFungibleByProxy(\npayment.recipient.wallet, msg.sender, payment.recipient.balances.current,\npayment.currency.ct, payment.currency.id, 0\n);\n\n// Emit event\nemit ChallengeByPaymentEvent(\npayment.seals.operator.hash, msg.sender,\ngenuineSenderAndFee ? address(0) : payment.sender.wallet,\ngenuineRecipient ? address(0) : payment.recipient.wallet\n);\n}","after":"function challenge(PaymentTypesLib.Payment calldata payment)\npublic\nonlyOperationalModeNormal\nonlyOperatorSealedPayment(payment)\n{\nrequire(validator.isGenuinePaymentWalletHash(payment), \"Not genuine payment wallet hash found [FraudChallengeByPayment.sol:48]\");\n\n// Genuineness affected by wallet not having signed the payment\nbool genuineWalletSignature = validator.isGenuineWalletSignature(\npayment.seals.wallet.hash, payment.seals.wallet.signature, payment.sender.wallet\n);\n\n// Genuineness affected by sender and recipient\n(bool genuineSenderAndFee, bool genuineRecipient) =\nvalidator.isPaymentCurrencyNonFungible(payment) ?\n(\nvalidator.isGenuinePaymentSenderOfNonFungible(payment) && validator.isGenuinePaymentFeeOfNonFungible(payment),\nvalidator.isGenuinePaymentRecipientOfNonFungible(payment)\n) :\n(\nvalidator.isGenuinePaymentSenderOfFungible(payment) && validator.isGenuinePaymentFeeOfFungible(payment),\nvalidator.isGenuinePaymentRecipientOfFungible(payment)\n);\n\n// Require existence of fraud signal\nrequire(!(genuineWalletSignature && genuineSenderAndFee && genuineRecipient), \"Fraud signal not found [FraudChallengeByPayment.sol:68]\");\n\n// Toggle operational mode exit\nconfiguration.setOperationalModeExit();\n\n// Tag payment (hash) as fraudulent\nfraudChallenge.addFraudulentPaymentHash(payment.seals.operator.hash);\n\n// Reward stake fraction\nsecurityBond.rewardFractional(msg.sender, configuration.fraudStakeFraction(), 0);\n\n// Lock amount of size equivalent to payment amount of sender\nif (!genuineSenderAndFee)\nwalletLocker.lockFungibleByProxy(\npayment.sender.wallet, msg.sender, payment.sender.balances.current,\npayment.currency.ct, payment.currency.id, 0\n);\n\n// Lock amount of size equivalent to payment amount of recipient\nif (!genuineRecipient)\nwalletLocker.lockFungibleByProxy(\npayment.recipient.wallet, msg.sender, payment.recipient.balances.current,\npayment.currency.ct, payment.currency.id, 0\n);\n\n// Emit event\nemit ChallengeByPaymentEvent(\npayment.seals.operator.hash, msg.sender,\ngenuineSenderAndFee ? address(0) : payment.sender.wallet,\ngenuineRecipient ? address(0) : payment.recipient.wallet\n);\n}","contract":"FraudChallengeByPayment","time":0}]}