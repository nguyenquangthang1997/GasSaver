{"time":287,"results":[{"type":"external-function ","before":"function mint(address account, uint id, uint amount, bytes memory data) external override onlyRevestController {\n        supply[id] += amount;\n        _mint(account, id, amount, data);\n        fnftsCreated += 1;\n    }","after":"function mint(address account, uint id, uint amount, bytes calldata data) external override onlyRevestController {\n        supply[id] += amount;\n        _mint(account, id, amount, data);\n        fnftsCreated += 1;\n    }","contract":"FNFTHandler","time":0},{"type":"external-function ","before":"function mintBatchRec(address[] calldata recipients, uint[] calldata quantities, uint id, uint newSupply, bytes memory data) external override onlyRevestController {\n        supply[id] += newSupply;\n        for (uint i = 0; i < quantities.length; i++) {\n            _mint(recipients[i], id, quantities[i], data);\n        }\n        fnftsCreated += 1;\n    }","after":"function mintBatchRec(address[] calldata recipients, uint[] calldata quantities, uint id, uint newSupply, bytes calldata data) external override onlyRevestController {\n        supply[id] += newSupply;\n        for (uint i = 0; i < quantities.length; i++) {\n            _mint(recipients[i], id, quantities[i], data);\n        }\n        fnftsCreated += 1;\n    }","contract":"FNFTHandler","time":0},{"type":"external-function ","before":"function mintBatch(address to, uint[] memory ids, uint[] memory amounts, bytes memory data) external override onlyRevestController {\n        _mintBatch(to, ids, amounts, data);\n    }","after":"function mintBatch(address to, uint[] calldata ids, uint[] calldata amounts, bytes calldata data) external override onlyRevestController {\n        _mintBatch(to, ids, amounts, data);\n    }","contract":"FNFTHandler","time":0},{"type":"external-function ","before":"function setURI(string memory newuri) external override onlyRevestController {\n        _setURI(newuri);\n    }","after":"function setURI(string calldata newuri) external override onlyRevestController {\n        _setURI(newuri);\n    }","contract":"FNFTHandler","time":0},{"type":"external-function ","before":"function burnBatch(address account, uint[] memory ids, uint[] memory amounts) external override onlyRevestController {\n        _burnBatch(account, ids, amounts);\n    }","after":"function burnBatch(address account, uint[] calldata ids, uint[] calldata amounts) external override onlyRevestController {\n        _burnBatch(account, ids, amounts);\n    }","contract":"FNFTHandler","time":0},{"type":"external-function ","before":"function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n    public\n    view\n    virtual\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","after":"function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    public\n    view\n    virtual\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","contract":"FNFTHandler","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"FNFTHandler","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"FNFTHandler","time":0},{"type":"immutable-restrict-modification ","before":"  address addressProvide","after":"  address addressProvide","contract":"FNFTHandler","time":1},{"type":"struct-data-arrangement ","before":"\naddress asset\naddress pipeToContract\nuint depositAmount\nuint depositMul\nuint split\nuint depositStopTime\nbool maturityExtension\nbool isMulti\nbool nontransferrable","after":"uint depositAmount\nuint depositMul\nuint split\nuint depositStopTime\naddress asset\naddress pipeToContract\nbool maturityExtension\nbool isMulti\nbool nontransferrable\n","contract":"IRevest","time":1},{"type":"struct-data-arrangement ","before":"\naddress addressLock\nLockType lockType\nValueLock valueLock\nuint timeLockExpiry\nuint creationTime\nbool unlocked","after":"LockType lockType\nValueLock valueLock\nuint timeLockExpiry\nuint creationTime\naddress addressLock\nbool unlocked\n","contract":"IRevest","time":0},{"type":"struct-data-arrangement ","before":"\naddress asset\naddress compareTo\naddress oracle\nuint unlockValue\nbool unlockRisingEdge","after":"uint unlockValue\naddress asset\naddress compareTo\naddress oracle\nbool unlockRisingEdge\n","contract":"IRevest","time":0},{"type":"external-function ","before":"  function mintTimeLock(\n        uint endTime,\n        address[] memory recipients,\n        uint[] memory quantities,\n        IRevest.FNFTConfig memory fnftConfig\n    ) external payable override returns (uint) {\n        // Get the next id\n        uint fnftId = getFNFTHandler().getNextId();\n        // Get or create lock based on time, assign lock to ID\n        {\n            IRevest.LockParam memory timeLock;\n            timeLock.lockType = IRevest.LockType.TimeLock;\n            timeLock.timeLockExpiry = endTime;\n            getLockManager().createLock(fnftId, timeLock);\n        }\n        doMint(recipients, quantities, fnftId, fnftConfig, msg.value);\n\n        emit FNFTTimeLockMinted(fnftConfig.asset, _msgSender(), fnftId, endTime, quantities, fnftConfig);\n\n        return fnftId;\n   ","after":"  function mintTimeLock(\n        uint endTime,\n        address[] calldata recipients,\n        uint[] calldata quantities,\n        IRevest.FNFTConfig calldata fnftConfig\n    ) external payable override returns (uint) {\n        // Get the next id\n        uint fnftId = getFNFTHandler().getNextId();\n        // Get or create lock based on time, assign lock to ID\n        {\n            IRevest.LockParam memory timeLock;\n            timeLock.lockType = IRevest.LockType.TimeLock;\n            timeLock.timeLockExpiry = endTime;\n            getLockManager().createLock(fnftId, timeLock);\n        }\n        doMint(recipients, quantities, fnftId, fnftConfig, msg.value);\n\n        emit FNFTTimeLockMinted(fnftConfig.asset, _msgSender(), fnftId, endTime, quantities, fnftConfig);\n\n        return fnftId;\n   ","contract":"Revest","time":0},{"type":"external-function ","before":"  function mintValueLock(\n        address primaryAsset,\n        address compareTo,\n        uint unlockValue,\n        bool unlockRisingEdge,\n        address oracleDispatch,\n        address[] memory recipients,\n        uint[] memory quantities,\n        IRevest.FNFTConfig memory fnftConfig\n    ) external payable override returns (uint) {\n        // copy the fnftId\n        uint fnftId = getFNFTHandler().getNextId();\n        // Initialize the lock structure\n        {\n            IRevest.LockParam memory valueLock;\n            valueLock.lockType = IRevest.LockType.ValueLock;\n            valueLock.valueLock.unlockRisingEdge = unlockRisingEdge;\n            valueLock.valueLock.unlockValue = unlockValue;\n            valueLock.valueLock.asset = primaryAsset;\n            valueLock.valueLock.compareTo = compareTo;\n            valueLock.valueLock.oracle = oracleDispatch;\n\n            getLockManager().createLock(fnftId, valueLock);\n        }\n\n        doMint(recipients, quantities, fnftId, fnftConfig, msg.value);\n\n        emit FNFTValueLockMinted(primaryAsset, _msgSender(), fnftId, compareTo, oracleDispatch, quantities, fnftConfig);\n\n        return fnftId;\n   ","after":"  function mintValueLock(\n        address primaryAsset,\n        address compareTo,\n        uint unlockValue,\n        bool unlockRisingEdge,\n        address oracleDispatch,\n        address[] calldata recipients,\n        uint[] calldata quantities,\n        IRevest.FNFTConfig calldata fnftConfig\n    ) external payable override returns (uint) {\n        // copy the fnftId\n        uint fnftId = getFNFTHandler().getNextId();\n        // Initialize the lock structure\n        {\n            IRevest.LockParam memory valueLock;\n            valueLock.lockType = IRevest.LockType.ValueLock;\n            valueLock.valueLock.unlockRisingEdge = unlockRisingEdge;\n            valueLock.valueLock.unlockValue = unlockValue;\n            valueLock.valueLock.asset = primaryAsset;\n            valueLock.valueLock.compareTo = compareTo;\n            valueLock.valueLock.oracle = oracleDispatch;\n\n            getLockManager().createLock(fnftId, valueLock);\n        }\n\n        doMint(recipients, quantities, fnftId, fnftConfig, msg.value);\n\n        emit FNFTValueLockMinted(primaryAsset, _msgSender(), fnftId, compareTo, oracleDispatch, quantities, fnftConfig);\n\n        return fnftId;\n   ","contract":"Revest","time":0},{"type":"external-function ","before":"  function mintAddressLock(\n        address trigger,\n        bytes memory arguments,\n        address[] memory recipients,\n        uint[] memory quantities,\n        IRevest.FNFTConfig memory fnftConfig\n    ) external payable override returns (uint) {\n        uint fnftId = getFNFTHandler().getNextId();\n\n        {\n            IRevest.LockParam memory addressLock;\n            addressLock.addressLock = trigger;\n            addressLock.lockType = IRevest.LockType.AddressLock;\n            // Get or create lock based on address which can trigger unlock, assign lock to ID\n            uint lockId = getLockManager().createLock(fnftId, addressLock);\n\n            if (trigger.supportsInterface(ADDRESS_LOCK_INTERFACE_ID)) {\n                IAddressLock(trigger).createLock(fnftId, lockId, arguments);\n            }\n        }\n        // This is a public call to a third-party contract. Must be done after everything else.\n        // Safe for reentry\n        doMint(recipients, quantities, fnftId, fnftConfig, msg.value);\n\n        emit FNFTAddressLockMinted(fnftConfig.asset, _msgSender(), fnftId, trigger, quantities, fnftConfig);\n\n        return fnftId;\n   ","after":"  function mintAddressLock(\n        address trigger,\n        bytes calldata arguments,\n        address[] calldata recipients,\n        uint[] calldata quantities,\n        IRevest.FNFTConfig calldata fnftConfig\n    ) external payable override returns (uint) {\n        uint fnftId = getFNFTHandler().getNextId();\n\n        {\n            IRevest.LockParam memory addressLock;\n            addressLock.addressLock = trigger;\n            addressLock.lockType = IRevest.LockType.AddressLock;\n            // Get or create lock based on address which can trigger unlock, assign lock to ID\n            uint lockId = getLockManager().createLock(fnftId, addressLock);\n\n            if (trigger.supportsInterface(ADDRESS_LOCK_INTERFACE_ID)) {\n                IAddressLock(trigger).createLock(fnftId, lockId, arguments);\n            }\n        }\n        // This is a public call to a third-party contract. Must be done after everything else.\n        // Safe for reentry\n        doMint(recipients, quantities, fnftId, fnftConfig, msg.value);\n\n        emit FNFTAddressLockMinted(fnftConfig.asset, _msgSender(), fnftId, trigger, quantities, fnftConfig);\n\n        return fnftId;\n   ","contract":"Revest","time":0},{"type":"external-function ","before":"  function splitFNFT(\n        uint fnftId,\n        uint[] memory proportions,\n        uint quantity\n    ) external override returns (uint[] memory) {\n        // Check if the user making this call has ANY FNFT's\n        require(getFNFTHandler().getBalance(_msgSender(), fnftId) > 0, \"E032\");\n        // Checking if the FNFT is allowing splitting\n        require(getTokenVault().getSplitsRemaining(fnftId) > 0, \"E023\");\n        uint[] memory newFNFTIds = new uint[](proportions.length);\n        uint start = getFNFTHandler().getNextId();\n        uint lockId = getLockManager().fnftIdToLockId(fnftId);\n        getFNFTHandler().burn(_msgSender(), fnftId, quantity);\n        for (uint i = 0; i < proportions.length; i++) {\n            newFNFTIds[i] = start + i;\n            getFNFTHandler().mint(_msgSender(), newFNFTIds[i], quantity, \"\");\n            getLockManager().pointFNFTToLock(newFNFTIds[i], lockId);\n        }\n        getTokenVault().splitFNFT(fnftId, newFNFTIds, proportions, quantity);\n\n        emit FNFTSplit(_msgSender(), newFNFTIds, proportions, quantity);\n\n        return newFNFTIds;\n   ","after":"  function splitFNFT(\n        uint fnftId,\n        uint[] calldata proportions,\n        uint quantity\n    ) external override returns (uint[] memory) {\n        // Check if the user making this call has ANY FNFT's\n        require(getFNFTHandler().getBalance(_msgSender(), fnftId) > 0, \"E032\");\n        // Checking if the FNFT is allowing splitting\n        require(getTokenVault().getSplitsRemaining(fnftId) > 0, \"E023\");\n        uint[] memory newFNFTIds = new uint[](proportions.length);\n        uint start = getFNFTHandler().getNextId();\n        uint lockId = getLockManager().fnftIdToLockId(fnftId);\n        getFNFTHandler().burn(_msgSender(), fnftId, quantity);\n        for (uint i = 0; i < proportions.length; i++) {\n            newFNFTIds[i] = start + i;\n            getFNFTHandler().mint(_msgSender(), newFNFTIds[i], quantity, \"\");\n            getLockManager().pointFNFTToLock(newFNFTIds[i], lockId);\n        }\n        getTokenVault().splitFNFT(fnftId, newFNFTIds, proportions, quantity);\n\n        emit FNFTSplit(_msgSender(), newFNFTIds, proportions, quantity);\n\n        return newFNFTIds;\n   ","contract":"Revest","time":0},{"type":"immutable-restrict-modification ","before":"  address addressProvide","after":"  address addressProvide","contract":"Revest","time":0}]}