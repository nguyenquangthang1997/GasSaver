{"time":874,"results":[{"type":"external-function ","before":"function withdrawBatch(uint256 _pid, uint256[] memory _nftIds) public {\n        for (uint256 i = 0; i < _nftIds.length; i++) {\n            withdraw(_pid, _nftIds[i]);\n        }\n    }","after":"function withdrawBatch(uint256 _pid, uint256[] calldata _nftIds) public {\n        for (uint256 i = 0; i < _nftIds.length; i++) {\n            withdraw(_pid, _nftIds[i]);\n        }\n    }","contract":"DuckChef2","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public bonusEndBlock;","after":"uint256 public immutable bonusEndBlock;","contract":"DuckChef2","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public tokenPerBlock;","after":"uint256 public immutable tokenPerBlock;","contract":"DuckChef2","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public startBlock;","after":"uint256 public immutable startBlock;","contract":"DuckChef2","time":1},{"type":"external-function ","before":"function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","after":"function onERC1155Received(address, address, uint256, uint256, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","contract":"DutchAuction","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","after":"function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","contract":"DutchAuction","time":0},{"type":"external-function ","before":"function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }","after":"function onERC721Received(address, address, uint256, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }","contract":"DutchAuction","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public daoFee;","after":"uint256 public immutable daoFee;","contract":"DutchAuction","time":0},{"type":"immutable-restrict-modification ","before":"address public daoAddress;","after":"address public immutable daoAddress;","contract":"DutchAuction","time":0},{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping(address => EnumerableSet.UintSet) private _holderTokens;\nEnumerableMap.UintToAddressMap private _tokenOwners;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nstring private _name;\nstring private _symbol;\nmapping(uint256 => string) private _tokenURIs;\nstring private _baseURI;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\nbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;","after":"mapping(address => EnumerableSet.UintSet) private _holderTokens;\nEnumerableMap.UintToAddressMap private _tokenOwners;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nstring private _name;\nstring private _symbol;\nmapping(uint256 => string) private _tokenURIs;\nstring private _baseURI;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\nbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n","contract":"ERC721","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public bonusEndBlock;","after":"uint256 public immutable bonusEndBlock;","contract":"MasterChef","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public pointsPerBlock;","after":"uint256 public immutable pointsPerBlock;","contract":"MasterChef","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public startBlock;","after":"uint256 public immutable startBlock;","contract":"MasterChef","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"NFT20","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"NFT20","time":0},{"type":"external-function ","before":"function init(\n        string memory name,\n        string memory symbol,\n        address _nftAddress,\n        uint256 _nftType\n    ) public {\n        super.init(name, symbol);\n        nftAddress = _nftAddress;\n        nftType = _nftType;\n    }","after":"function init(\n        string calldata name,\n        string calldata symbol,\n        address _nftAddress,\n        uint256 _nftType\n    ) public {\n        super.init(name, symbol);\n        nftAddress = _nftAddress;\n        nftType = _nftType;\n    }","contract":"NFT20Pair","time":0},{"type":"external-function ","before":"function onERC721Received(\n        address operator,\n        address,\n        uint256 tokenId,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        require(nftAddress == msg.sender, \"forbidden\");\n        require(!lockedNfts.contains(tokenId), \"forbidden\");\n        lockedNfts.add(tokenId);\n        uint256 fee = IFactory(factory).fee();\n        _mint(factory, nftValue.mul(fee).div(100));\n        _mint(operator, nftValue.mul(uint256(100).sub(fee)).div(100));\n        return this.onERC721Received.selector;\n    }","after":"function onERC721Received(\n        address operator,\n        address,\n        uint256 tokenId,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        require(nftAddress == msg.sender, \"forbidden\");\n        require(!lockedNfts.contains(tokenId), \"forbidden\");\n        lockedNfts.add(tokenId);\n        uint256 fee = IFactory(factory).fee();\n        _mint(factory, nftValue.mul(fee).div(100));\n        _mint(operator, nftValue.mul(uint256(100).sub(fee)).div(100));\n        return this.onERC721Received.selector;\n    }","contract":"NFT20Pair","time":0},{"type":"external-function ","before":"function onERC1155Received(\n        address operator,\n        address,\n        uint256 id,\n        uint256 value,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        require(nftAddress == msg.sender, \"forbidden\");\n\n        if (!lockedNfts.contains(id)) {\n            lockedNfts.add(id);\n        }\n\n        track1155[id] = track1155[id].add(value);\n        uint256 fee = IFactory(factory).fee();\n        _mint(factory, (nftValue.mul(value)).mul(fee).div(100));\n        _mint(\n            operator,\n            (nftValue.mul(value)).mul(uint256(100).sub(fee)).div(100)\n        );\n        return this.onERC1155Received.selector;\n    }","after":"function onERC1155Received(\n        address operator,\n        address,\n        uint256 id,\n        uint256 value,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        require(nftAddress == msg.sender, \"forbidden\");\n\n        if (!lockedNfts.contains(id)) {\n            lockedNfts.add(id);\n        }\n\n        track1155[id] = track1155[id].add(value);\n        uint256 fee = IFactory(factory).fee();\n        _mint(factory, (nftValue.mul(value)).mul(fee).div(100));\n        _mint(\n            operator,\n            (nftValue.mul(value)).mul(uint256(100).sub(fee)).div(100)\n        );\n        return this.onERC1155Received.selector;\n    }","contract":"NFT20Pair","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(\n        address operator,\n        address,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        require(nftType == 1155, \"forbidden\");\n        require(nftAddress == msg.sender, \"forbidden\");\n\n        uint256 qty = 0;\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (!lockedNfts.contains(ids[i])) {\n                lockedNfts.add(ids[i]);\n            }\n\n            qty = qty + values[i];\n\n            track1155[ids[i]] = track1155[ids[i]].add(values[i]);\n        }\n        uint256 fee = IFactory(factory).fee();\n        _mint(\n            operator,\n            (nftValue.mul(qty)).mul(uint256(100).sub(fee)).div(100)\n        );\n\n        _mint(factory, (nftValue.mul(qty)).mul(fee).div(100));\n\n        return this.onERC1155BatchReceived.selector;\n    }","after":"function onERC1155BatchReceived(\n        address operator,\n        address,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        require(nftType == 1155, \"forbidden\");\n        require(nftAddress == msg.sender, \"forbidden\");\n\n        uint256 qty = 0;\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            if (!lockedNfts.contains(ids[i])) {\n                lockedNfts.add(ids[i]);\n            }\n\n            qty = qty + values[i];\n\n            track1155[ids[i]] = track1155[ids[i]].add(values[i]);\n        }\n        uint256 fee = IFactory(factory).fee();\n        _mint(\n            operator,\n            (nftValue.mul(qty)).mul(uint256(100).sub(fee)).div(100)\n        );\n\n        _mint(factory, (nftValue.mul(qty)).mul(fee).div(100));\n\n        return this.onERC1155BatchReceived.selector;\n    }","contract":"NFT20Pair","time":0},{"type":"immutable-restrict-modification ","before":"address public factory;","after":"address public immutable factory;","contract":"NFT20Pair","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public nftValue = 100 * 10 ** 18;","after":"uint256 public constant nftValue = 100 * 10 ** 18;","contract":"NFT20Pair","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"NFTLP","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"NFTLP","time":0},{"type":"external-function ","before":"function mint(address to, uint256 id, uint256 amount, bytes memory data) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mint(to, id, amount, data);\n    }","after":"function mint(address to, uint256 id, uint256 amount, bytes calldata data) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mint(to, id, amount, data);\n    }","contract":"Test1155","time":0},{"type":"external-function ","before":"function mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mintBatch(to, ids, amounts, data);\n    }","after":"function mintBatch(address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mintBatch(to, ids, amounts, data);\n    }","contract":"Test1155","time":0},{"type":"external-function ","before":"function burnBatch(address account, uint256[] memory ids, uint256[] memory values) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }","after":"function burnBatch(address account, uint256[] calldata ids, uint256[] calldata values) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }","contract":"Test1155","time":0},{"type":"external-function ","before":"function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n    public\n    view\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }","after":"function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    )\n    public\n    view\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }","contract":"Test1155","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n    public\n    virtual\n    override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n    public\n    virtual\n    override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"Test1155","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n    public\n    virtual\n    override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n    public\n    virtual\n    override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"Test1155","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseURI_) public onlyOwner {\n        _setBaseURI(baseURI_);\n    }","after":"function setBaseURI(string calldata baseURI_) public onlyOwner {\n        _setBaseURI(baseURI_);\n    }","contract":"Test721","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"Test721","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"Test721","time":1}]}