{"time":248,"results":[{"type":"immutable-restrict-modification ","before":"address public owner;","after":"address public immutable owner;","contract":"TokenSpender","time":0},{"type":"external-function ","before":"function swap(\n\n        IERC20 inToken,\n\n        IERC20 outToken,\n\n        uint256 inAmount,\n\n        uint256 minOutAmount,\n\n        uint256, /*guaranteedAmount*/\n\n        address payable referrer,\n\n        address[] memory addressesToCall,\n\n        bytes memory dataToCall,\n\n        uint256[] memory offsets,\n\n        uint256[] memory gasLimitsAndValues\n\n    ) public payable notShutdown returns (uint256 outAmount) {\n\n        require(minOutAmount > 0, \"Min out amount should be greater than zero\");\n\n        require(addressesToCall.length > 0, \"Call data should exists\");\n\n        require((msg.value != 0) == inToken.isETH(), \"OpenOcean: msg.value should be used only for ETH swap\");\n\n\n        if (!inToken.isETH()) {\n\n            spender.claimToken(inToken, msg.sender, address(this), inAmount);\n\n        }\n\n\n        for (uint256 i = 0; i < addressesToCall.length; i++) {\n\n            require(addressesToCall[i] != address(spender), \"Access denied\");\n\n            require(\n\n                addressesToCall[i].externalCall(\n\n                    gasLimitsAndValues[i] & ((1 << 128) - 1),\n\n                    dataToCall,\n\n                    offsets[i],\n\n                    offsets[i + 1] - offsets[i],\n\n                    gasLimitsAndValues[i] >> 128\n\n                )\n\n            );\n\n        }\n\n\n        inToken.universalTransfer(msg.sender, inToken.universalBalanceOf(address(this)));\n\n        outAmount = outToken.universalBalanceOf(address(this));\n\n\n        require(outAmount >= minOutAmount, \"Return amount less than the minimum required amount\");\n\n        outToken.universalTransfer(msg.sender, outAmount);\n\n\n        emit Order(msg.sender, inToken, outToken, inAmount, outAmount);\n\n        emit Swapped(inToken, outToken, referrer, inAmount, outAmount, 0, 0);\n\n    }","after":"function swap(\n\n        IERC20 inToken,\n\n        IERC20 outToken,\n\n        uint256 inAmount,\n\n        uint256 minOutAmount,\n\n        uint256, /*guaranteedAmount*/\n\n        address payable referrer,\n\n        address[] calldata addressesToCall,\n\n        bytes calldata dataToCall,\n\n        uint256[] calldata offsets,\n\n        uint256[] calldata gasLimitsAndValues\n\n    ) public payable notShutdown returns (uint256 outAmount) {\n\n        require(minOutAmount > 0, \"Min out amount should be greater than zero\");\n\n        require(addressesToCall.length > 0, \"Call data should exists\");\n\n        require((msg.value != 0) == inToken.isETH(), \"OpenOcean: msg.value should be used only for ETH swap\");\n\n\n        if (!inToken.isETH()) {\n\n            spender.claimToken(inToken, msg.sender, address(this), inAmount);\n\n        }\n\n\n        for (uint256 i = 0; i < addressesToCall.length; i++) {\n\n            require(addressesToCall[i] != address(spender), \"Access denied\");\n\n            require(\n\n                addressesToCall[i].externalCall(\n\n                    gasLimitsAndValues[i] & ((1 << 128) - 1),\n\n                    dataToCall,\n\n                    offsets[i],\n\n                    offsets[i + 1] - offsets[i],\n\n                    gasLimitsAndValues[i] >> 128\n\n                )\n\n            );\n\n        }\n\n\n        inToken.universalTransfer(msg.sender, inToken.universalBalanceOf(address(this)));\n\n        outAmount = outToken.universalBalanceOf(address(this));\n\n\n        require(outAmount >= minOutAmount, \"Return amount less than the minimum required amount\");\n\n        outToken.universalTransfer(msg.sender, outAmount);\n\n\n        emit Order(msg.sender, inToken, outToken, inAmount, outAmount);\n\n        emit Swapped(inToken, outToken, referrer, inAmount, outAmount, 0, 0);\n\n    }","contract":"OpenOceanExchange","time":0}]}