{"time":309,"results":[{"type":"external-function ","before":"function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n\n    public\n\n    onlyOperator\n\n    onlyDelayedBlockNumber(fromBlockNumber)\n\n    {\n\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n\n    }","after":"function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n\n    public\n\n    onlyOperator\n\n    onlyDelayedBlockNumber(fromBlockNumber)\n\n    {\n\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n\n    public\n\n    onlyOperator\n\n    onlyDelayedBlockNumber(fromBlockNumber)\n\n    {\n\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n\n    }","after":"function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n\n    public\n\n    onlyOperator\n\n    onlyDelayedBlockNumber(fromBlockNumber)\n\n    {\n\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n\n    public\n\n    onlyOperator\n\n    onlyDelayedBlockNumber(fromBlockNumber)\n\n    {\n\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n\n    }","after":"function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n\n    public\n\n    onlyOperator\n\n    onlyDelayedBlockNumber(fromBlockNumber)\n\n    {\n\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n\n        int256[] memory discountTiers, int256[] memory discountValues)\n\n    public\n\n    onlyOperator\n\n    onlyDelayedBlockNumber(fromBlockNumber)\n\n    {\n\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n\n            fromBlockNumber, nominal, discountTiers, discountValues\n\n        );\n\n        emit SetCurrencyPaymentFeeEvent(\n\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n\n        );\n\n    }","after":"function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n\n        int256[] calldata discountTiers, int256[] calldata discountValues)\n\n    public\n\n    onlyOperator\n\n    onlyDelayedBlockNumber(fromBlockNumber)\n\n    {\n\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n\n            fromBlockNumber, nominal, discountTiers, discountValues\n\n        );\n\n        emit SetCurrencyPaymentFeeEvent(\n\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n\n        );\n\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n\n    public\n\n    onlyDeployer\n\n    notNullOrThisAddress(service)\n\n    {\n\n        require(registeredServicesMap[service].registered);\n\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n\n    }","after":"function enableServiceAction(address service, string calldata action)\n\n    public\n\n    onlyDeployer\n\n    notNullOrThisAddress(service)\n\n    {\n\n        require(registeredServicesMap[service].registered);\n\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n\n    public\n\n    onlyDeployer\n\n    notNullOrThisAddress(service)\n\n    {\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n\n    }","after":"function disableServiceAction(address service, string calldata action)\n\n    public\n\n    onlyDeployer\n\n    notNullOrThisAddress(service)\n\n    {\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n        bytes32 actionHash = hashString(action);\n\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n        bytes32 actionHash = hashString(action);\n\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n\n    }","contract":"Configuration","time":0},{"type":"struct-data-arrangement ","before":"\naddress wallet\nuint256 nonce\nuint256 referenceBlockNumber\nuint256 definitionBlockNumber\nuint256 expirationTime\nStatus status\nAmounts amounts\nMonetaryTypesLib.Currency currency\nDriip challenged\nbool walletInitiated\nbool terminated\nDisqualification disqualification","after":"uint256 nonce\nuint256 referenceBlockNumber\nuint256 definitionBlockNumber\nuint256 expirationTime\nStatus status\nAmounts amounts\nMonetaryTypesLib.Currency currency\nDriip challenged\nDisqualification disqualification\naddress wallet\nbool walletInitiated\nbool terminated\n","contract":"SettlementChallengeTypesLib","time":0},{"type":"external-function ","before":"function initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated,\n\n        bytes32 challengedHash, string memory challengedKind)\n\n    public\n\n    onlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n\n    {\n\n\n        _initiateProposal(\n\n            wallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\n\n            currency, blockNumber, walletInitiated, challengedHash, challengedKind\n\n        );\n\n\n        emit InitiateProposalEvent(\n\n            wallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\n\n            blockNumber, walletInitiated, challengedHash, challengedKind\n\n        );\n\n    }","after":"function initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\n\n        int256 targetBalanceAmount, MonetaryTypesLib.Currency calldata currency, uint256 blockNumber, bool walletInitiated,\n\n        bytes32 challengedHash, string calldata challengedKind)\n\n    public\n\n    onlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n\n    {\n\n\n        _initiateProposal(\n\n            wallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\n\n            currency, blockNumber, walletInitiated, challengedHash, challengedKind\n\n        );\n\n\n        emit InitiateProposalEvent(\n\n            wallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\n\n            blockNumber, walletInitiated, challengedHash, challengedKind\n\n        );\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce)\n\n    public\n\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\n        if (0 == index)\n\n            return;\n\n\n        if (clearNonce)\n\n            proposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n\n        proposals[index - 1].terminated = true;\n\n\n        emit TerminateProposalEvent(\n\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n\n        );\n\n    }","after":"function terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool clearNonce)\n\n    public\n\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\n        if (0 == index)\n\n            return;\n\n\n        if (clearNonce)\n\n            proposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n\n        proposals[index - 1].terminated = true;\n\n\n        emit TerminateProposalEvent(\n\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n\n        );\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce,\n\n        bool walletTerminated)\n\n    public\n\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\n        if (0 == index)\n\n            return;\n\n\n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:165]\");\n\n\n        if (clearNonce)\n\n            proposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n\n        proposals[index - 1].terminated = true;\n\n\n        emit TerminateProposalEvent(\n\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n\n        );\n\n    }","after":"function terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool clearNonce,\n\n        bool walletTerminated)\n\n    public\n\n    onlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\n        if (0 == index)\n\n            return;\n\n\n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:165]\");\n\n\n        if (clearNonce)\n\n            proposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n\n        proposals[index - 1].terminated = true;\n\n\n        emit TerminateProposalEvent(\n\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n\n        );\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\n        if (0 == index)\n\n            return;\n\n\n        emit RemoveProposalEvent(\n\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n\n        );\n\n\n        _removeProposal(index);\n\n    }","after":"function removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\n        if (0 == index)\n\n            return;\n\n\n        emit RemoveProposalEvent(\n\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n\n        );\n\n\n        _removeProposal(index);\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\n\n    public\n\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\n        if (0 == index)\n\n            return;\n\n\n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:225]\");\n\n\n        emit RemoveProposalEvent(\n\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n\n        );\n\n\n        _removeProposal(index);\n\n    }","after":"function removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool walletTerminated)\n\n    public\n\n    onlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\n        if (0 == index)\n\n            return;\n\n\n        require(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:225]\");\n\n\n        emit RemoveProposalEvent(\n\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n\n            proposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n\n        );\n\n\n        _removeProposal(index);\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\n\n        uint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\n\n    public\n\n    onlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:255]\");\n\n\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\n\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n\n        proposals[index - 1].disqualification.challenger = challengerWallet;\n\n        proposals[index - 1].disqualification.nonce = candidateNonce;\n\n        proposals[index - 1].disqualification.blockNumber = blockNumber;\n\n        proposals[index - 1].disqualification.candidate.hash = candidateHash;\n\n        proposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n\n        emit DisqualifyProposalEvent(\n\n            challengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\n\n            currency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n\n            challengerWallet, candidateNonce, candidateHash, candidateKind\n\n        );\n\n    }","after":"function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency calldata currency, address challengerWallet,\n\n        uint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string calldata candidateKind)\n\n    public\n\n    onlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:255]\");\n\n\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\n\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n\n        proposals[index - 1].disqualification.challenger = challengerWallet;\n\n        proposals[index - 1].disqualification.nonce = candidateNonce;\n\n        proposals[index - 1].disqualification.blockNumber = blockNumber;\n\n        proposals[index - 1].disqualification.candidate.hash = candidateHash;\n\n        proposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n\n        emit DisqualifyProposalEvent(\n\n            challengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\n\n            currency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n\n            challengerWallet, candidateNonce, candidateHash, candidateKind\n\n        );\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function qualifyProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    onlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:284]\");\n\n\n        emit QualifyProposalEvent(\n\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n\n            proposals[index - 1].disqualification.challenger,\n\n            proposals[index - 1].disqualification.nonce,\n\n            proposals[index - 1].disqualification.candidate.hash,\n\n            proposals[index - 1].disqualification.candidate.kind\n\n        );\n\n\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\n\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n\n        delete proposals[index - 1].disqualification;\n\n    }","after":"function qualifyProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    onlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:284]\");\n\n\n        emit QualifyProposalEvent(\n\n            wallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\n\n            proposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\n\n            proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\n\n            proposals[index - 1].disqualification.challenger,\n\n            proposals[index - 1].disqualification.nonce,\n\n            proposals[index - 1].disqualification.candidate.hash,\n\n            proposals[index - 1].disqualification.candidate.kind\n\n        );\n\n\n        proposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\n\n        proposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\n\n        delete proposals[index - 1].disqualification;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n\n        return 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];\n\n    }","after":"function hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n\n        return 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n\n        return 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n    }","after":"function hasProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n\n        return 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:342]\");\n\n        return proposals[index - 1].terminated;\n\n    }","after":"function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:342]\");\n\n        return proposals[index - 1].terminated;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:357]\");\n\n        return block.timestamp >= proposals[index - 1].expirationTime;\n\n    }","after":"function hasProposalExpired(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:357]\");\n\n        return block.timestamp >= proposals[index - 1].expirationTime;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:371]\");\n\n        return proposals[index - 1].nonce;\n\n    }","after":"function proposalNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:371]\");\n\n        return proposals[index - 1].nonce;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:385]\");\n\n        return proposals[index - 1].referenceBlockNumber;\n\n    }","after":"function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:385]\");\n\n        return proposals[index - 1].referenceBlockNumber;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:399]\");\n\n        return proposals[index - 1].definitionBlockNumber;\n\n    }","after":"function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:399]\");\n\n        return proposals[index - 1].definitionBlockNumber;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:413]\");\n\n        return proposals[index - 1].expirationTime;\n\n    }","after":"function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:413]\");\n\n        return proposals[index - 1].expirationTime;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (SettlementChallengeTypesLib.Status)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:427]\");\n\n        return proposals[index - 1].status;\n\n    }","after":"function proposalStatus(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (SettlementChallengeTypesLib.Status)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:427]\");\n\n        return proposals[index - 1].status;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (int256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:441]\");\n\n        return proposals[index - 1].amounts.cumulativeTransfer;\n\n    }","after":"function proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (int256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:441]\");\n\n        return proposals[index - 1].amounts.cumulativeTransfer;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (int256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:455]\");\n\n        return proposals[index - 1].amounts.stage;\n\n    }","after":"function proposalStageAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (int256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:455]\");\n\n        return proposals[index - 1].amounts.stage;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (int256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:469]\");\n\n        return proposals[index - 1].amounts.targetBalance;\n\n    }","after":"function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (int256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:469]\");\n\n        return proposals[index - 1].amounts.targetBalance;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalChallengedHash(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (bytes32)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:483]\");\n\n        return proposals[index - 1].challenged.hash;\n\n    }","after":"function proposalChallengedHash(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (bytes32)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:483]\");\n\n        return proposals[index - 1].challenged.hash;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalChallengedKind(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (string memory)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:497]\");\n\n        return proposals[index - 1].challenged.kind;\n\n    }","after":"function proposalChallengedKind(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (string memory)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:497]\");\n\n        return proposals[index - 1].challenged.kind;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:511]\");\n\n        return proposals[index - 1].walletInitiated;\n\n    }","after":"function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:511]\");\n\n        return proposals[index - 1].walletInitiated;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (address)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:525]\");\n\n        return proposals[index - 1].disqualification.challenger;\n\n    }","after":"function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (address)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:525]\");\n\n        return proposals[index - 1].disqualification.challenger;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:539]\");\n\n        return proposals[index - 1].disqualification.nonce;\n\n    }","after":"function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:539]\");\n\n        return proposals[index - 1].disqualification.nonce;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:553]\");\n\n        return proposals[index - 1].disqualification.blockNumber;\n\n    }","after":"function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (uint256)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:553]\");\n\n        return proposals[index - 1].disqualification.blockNumber;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (bytes32)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:567]\");\n\n        return proposals[index - 1].disqualification.candidate.hash;\n\n    }","after":"function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (bytes32)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:567]\");\n\n        return proposals[index - 1].disqualification.candidate.hash;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\n\n    public\n\n    view\n\n    returns (string memory)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:581]\");\n\n        return proposals[index - 1].disqualification.candidate.kind;\n\n    }","after":"function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency calldata currency)\n\n    public\n\n    view\n\n    returns (string memory)\n\n    {\n\n        uint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n        require(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:581]\");\n\n        return proposals[index - 1].disqualification.candidate.kind;\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function upgradeProposal(SettlementChallengeTypesLib.Proposal memory proposal)\n\n    public\n\n    onlyWhenUpgrading\n\n    {\n\n\n        require(\n\n            0 == proposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id],\n\n            \"Proposal exists for wallet, nonce and currency [DriipSettlementChallengeState.sol:592]\"\n\n        );\n\n\n        proposals.push(proposal);\n\n\n        uint256 index = proposals.length;\n\n\n        proposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id] = index;\n\n        proposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id] = index;\n\n\n        emit UpgradeProposalEvent(proposal);\n\n    }","after":"function upgradeProposal(SettlementChallengeTypesLib.Proposal calldata proposal)\n\n    public\n\n    onlyWhenUpgrading\n\n    {\n\n\n        require(\n\n            0 == proposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id],\n\n            \"Proposal exists for wallet, nonce and currency [DriipSettlementChallengeState.sol:592]\"\n\n        );\n\n\n        proposals.push(proposal);\n\n\n        uint256 index = proposals.length;\n\n\n        proposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id] = index;\n\n        proposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id] = index;\n\n\n        emit UpgradeProposalEvent(proposal);\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n\n    public\n\n    onlyDeployer\n\n    notNullOrThisAddress(service)\n\n    {\n\n        require(registeredServicesMap[service].registered);\n\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n\n    }","after":"function enableServiceAction(address service, string calldata action)\n\n    public\n\n    onlyDeployer\n\n    notNullOrThisAddress(service)\n\n    {\n\n        require(registeredServicesMap[service].registered);\n\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n\n    public\n\n    onlyDeployer\n\n    notNullOrThisAddress(service)\n\n    {\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n\n    }","after":"function disableServiceAction(address service, string calldata action)\n\n    public\n\n    onlyDeployer\n\n    notNullOrThisAddress(service)\n\n    {\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n        bytes32 actionHash = hashString(action);\n\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n\n    public\n\n    view\n\n    returns (bool)\n\n    {\n\n        bytes32 actionHash = hashString(action);\n\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n\n    }","contract":"DriipSettlementChallengeState","time":0}]}