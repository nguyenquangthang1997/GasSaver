{"time":394,"results":[{"type":"external-function ","before":"um number\n    function max(int[] memory nums) public pure returns (int maxNum) {\n        require(nums.length > 0);\n        maxNum = - 2 ** 255;\n        for (uint i = 0; i < nums.length; i++) if (nums[i] > maxNum) maxNum = ","after":"um number\n    function max(int[] memory nums) public pure returns (int maxNum) {\n        require(nums.length > 0);\n        maxNum = - 2 ** 255;\n        for (uint i = 0; i < nums.length; i++) if (nums[i] > maxNum) maxNum = ","contract":"GnosisMath","time":0},{"type":"immutable-restrict-modification ","before":"Proxied {\n    address publ","after":"Proxied {\n    address publ","contract":"Proxy","time":0},{"type":"de-morgan-condition ","before":"{\n        if (!balances[msg.sender].safeToSub(value) || !balances[to].sa","after":"!({\n        if (balances[msg.sender].safeToSub(value) || balances[to].sa)","loc":{"start":{"line":1004,"column":12},"end":{"line":1004,"column":83}},"contract":"GnosisStandardToken","time":0},{"type":"de-morgan-condition ","before":"{\n        if (!balances[from].safeToSub(value) || !allowances[from][msg.sender].safeToSub(\n            v","after":"!({\n        if (balances[from].safeToSub(value) || allowances[from][msg.sender].safeToSub(\n            v)","loc":{"start":{"line":1020,"column":12},"end":{"line":1022,"column":8}},"contract":"GnosisStandardToken","time":0},{"type":"state-data-arrangement ","before":"\nh for *;\n\n    string public constant name \nL Token\";\n    string public constant s\n = \"OWL\";\n    uint8 public constant \ne;\n    }\n\n    masterCopyCountdownType master\nuntdown;\n\n    address p\n creator;\n    address ","after":"h for *;\n\n    string public constant name \nL Token\";\n    string public constant s\ne;\n    }\n\n    masterCopyCountdownType master\nuntdown;\n\n    address p\n creator;\n    address \n = \"OWL\";\n    uint8 public constant \n","contract":"TokenOWL","time":0},{"type":"loop-duplication","before":"\nstart line 2197 column 8, end line 2222 column 8\n = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            require(checkOrderValidity(order, batchId), \"Order is invalid\");\n            (uint128 executedBuyAmount, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            require(executedBuyAmount >= AMOUNT_MINIMUM, \"buy amount less than AMOUNT_MINIMUM\");\n            require(executedSellAmount >= AMOUNT_MINIMUM, \"sell amount less than AMOUNT_MINIMUM\");\n            tokenConservation.updateTokenConservation(\n                order.buyToken,\n                order.sellToken,\n                tokenIdsForPrice,\n                executedBuyAmount,\n                executedSellAmount\n            );\n            require(getRemainingAmount(order) >= executedSellAmount, \"executedSellAmount bigger than specified in order\");\n            // Ensure executed price is not lower than the order price:\n            //       executedSellAmount / executedBuyAmount <= order.priceDenominator / order.priceNumerator\n            require(\n                executedSellAmount.mul(order.priceNumerator) <= executedBuyAmount.mul(order.priceDenominator),\n                \"limit price not satisfied\"\n            );\n            // accumulate utility before updateRemainingOrder, but after limitPrice verified!\n            utility = utility.add(evaluateUtility(executedBuyAmount, order));\n            updateRemainingOrder(owners[i], orderIds[i], executedSellAmount);\n            addBalanceAndBlockWithdrawForThisBatch(owners[i], tokenIdToAddressMap(order.buyToken), executedBuyAmount);\n            emit Trade(owners[i], orderIds[i], order.sellToken, order.buyToken, executedSellAmount, executedBuyAmou\nstart line 2224 column 8, end line 2228 column 8\nalues\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            (, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            subtractBalance(owners[i], tokenIdToAddressMap(order.sellToken), executedSellAmou\nstart line 2230 column 8, end line 2232 column 8\n = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            disregardedUtility = disregardedUtility.add(evaluateDisregardedUtility(orders[owners[i]][orderIds[i]], owners[i","after":"// merge loop\n\nstart line 2197 column 8, end line 2222 column 8\n = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            require(checkOrderValidity(order, batchId), \"Order is invalid\");\n            (uint128 executedBuyAmount, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            require(executedBuyAmount >= AMOUNT_MINIMUM, \"buy amount less than AMOUNT_MINIMUM\");\n            require(executedSellAmount >= AMOUNT_MINIMUM, \"sell amount less than AMOUNT_MINIMUM\");\n            tokenConservation.updateTokenConservation(\n                order.buyToken,\n                order.sellToken,\n                tokenIdsForPrice,\n                executedBuyAmount,\n                executedSellAmount\n            );\n            require(getRemainingAmount(order) >= executedSellAmount, \"executedSellAmount bigger than specified in order\");\n            // Ensure executed price is not lower than the order price:\n            //       executedSellAmount / executedBuyAmount <= order.priceDenominator / order.priceNumerator\n            require(\n                executedSellAmount.mul(order.priceNumerator) <= executedBuyAmount.mul(order.priceDenominator),\n                \"limit price not satisfied\"\n            );\n            // accumulate utility before updateRemainingOrder, but after limitPrice verified!\n            utility = utility.add(evaluateUtility(executedBuyAmount, order));\n            updateRemainingOrder(owners[i], orderIds[i], executedSellAmount);\n            addBalanceAndBlockWithdrawForThisBatch(owners[i], tokenIdToAddressMap(order.buyToken), executedBuyAmount);\n            emit Trade(owners[i], orderIds[i], order.sellToken, order.buyToken, executedSellAmount, executedBuyAmou\nstart line 2224 column 8, end line 2228 column 8\nalues\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            (, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            subtractBalance(owners[i], tokenIdToAddressMap(order.sellToken), executedSellAmou\nstart line 2230 column 8, end line 2232 column 8\n = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            disregardedUtility = disregardedUtility.add(evaluateDisregardedUtility(orders[owners[i]][orderIds[i]], owners[i","contract":"BatchExchange","time":0},{"type":"loop-calculation","before":"              Order memory order = orders[ow","after":"// move outside for loop\n              Order memory order = orders[ow","loc":{"start":{"line":2523,"column":16},"end":{"line":2523,"column":59}},"contract":"BatchExchange","time":0},{"type":"loop-calculation","before":"              Order memory order = orders[ow","after":"// move outside for loop\n              Order memory order = orders[ow","loc":{"start":{"line":2530,"column":16},"end":{"line":2530,"column":59}},"contract":"BatchExchange","time":0},{"type":"loop-duplication","before":"\nstart line 2520 column 12, end line 2526 column 12\n{\n            for (uint256 i = 0; i < latestSolution.trades.length; i++) {\n                address owner = latestSolution.trades[i].owner;\n                uint16 orderId = latestSolution.trades[i].orderId;\n                Order memory order = orders[owner][orderId];\n                (, uint128 sellAmount) = getTradedAmounts(latestSolution.trades[i].volume, order);\n                addBalance(owner, tokenIdToAddressMap(order.sellToken), sellAmount);\nstart line 2527 column 12, end line 2535 column 12\n}\n            for (uint256 i = 0; i < latestSolution.trades.length; i++) {\n                address owner = latestSolution.trades[i].owner;\n                uint16 orderId = latestSolution.trades[i].orderId;\n                Order memory order = orders[owner][orderId];\n                (uint128 buyAmount, uint128 sellAmount) = getTradedAmounts(latestSolution.trades[i].volume, order);\n                revertRemainingOrder(owner, orderId, sellAmount);\n                subtractBalanceUnchecked(owner, tokenIdToAddressMap(order.buyToken), buyAmount);\n                emit TradeReversion(owner, orderId, order.sellToken, order.buyToken, sellAmount, buyAmount);","after":"// merge loop\n\nstart line 2520 column 12, end line 2526 column 12\n{\n            for (uint256 i = 0; i < latestSolution.trades.length; i++) {\n                address owner = latestSolution.trades[i].owner;\n                uint16 orderId = latestSolution.trades[i].orderId;\n                Order memory order = orders[owner][orderId];\n                (, uint128 sellAmount) = getTradedAmounts(latestSolution.trades[i].volume, order);\n                addBalance(owner, tokenIdToAddressMap(order.sellToken), sellAmount);\nstart line 2527 column 12, end line 2535 column 12\n}\n            for (uint256 i = 0; i < latestSolution.trades.length; i++) {\n                address owner = latestSolution.trades[i].owner;\n                uint16 orderId = latestSolution.trades[i].orderId;\n                Order memory order = orders[owner][orderId];\n                (uint128 buyAmount, uint128 sellAmount) = getTradedAmounts(latestSolution.trades[i].volume, order);\n                revertRemainingOrder(owner, orderId, sellAmount);\n                subtractBalanceUnchecked(owner, tokenIdToAddressMap(order.buyToken), buyAmount);\n                emit TradeReversion(owner, orderId, order.sellToken, order.buyToken, sellAmount, buyAmount);","contract":"BatchExchange","time":0},{"type":"struct-data-arrangement ","before":"\nata {\n        \nchId;\n        Trad\nades;\n        uint16[] to\nrice;\n        address sol\ntter;\n        uin\nward;\n        uint256 ","after":"chId;\n        Trad\nades;\n        uint16[] to\ntter;\n        uin\nward;\n        uint256 \nrice;\n        address sol\nata {\n        \n","contract":"BatchExchange","time":0},{"type":"external-function ","before":"\n      */\n    function replaceOrders(\n        uint16[] memory cancellations,\n        uint16[] memory buyTokens,\n        uint16[] memory sellTokens,\n        uint32[] memory validFroms,\n        uint32[] memory validUntils,\n        uint128[] memory buyAmounts,\n        uint128[] memory sellAmounts\n    ) public returns (uint16[] memory) {\n        cancelOrders(cancellations);\n        return placeValidFromOrders(buyTokens, sellTokens, validFroms, validUntils, buyAmounts, sellA","after":"\n      */\n    function replaceOrders(\n        uint16[] calldata cancellations,\n        uint16[] calldata buyTokens,\n        uint16[] calldata sellTokens,\n        uint32[] calldata validFroms,\n        uint32[] calldata validUntils,\n        uint128[] calldata buyAmounts,\n        uint128[] memory sellAmounts\n    ) public returns (uint16[] memory) {\n        cancelOrders(cancellations);\n        return placeValidFromOrders(buyTokens, sellTokens, validFroms, validUntils, buyAmounts, sellA","contract":"BatchExchange","time":0},{"type":"external-function ","before":"\n      */\n    function submitSolution(\n        uint32 batchId,\n        uint256 claimedObjectiveValue,\n        address[] memory owners,\n        uint16[] memory orderIds,\n        uint128[] memory buyVolumes,\n        uint128[] memory prices,\n        uint16[] memory tokenIdsForPrice\n    ) public returns (uint256) {\n        require(acceptingSolutions(batchId), \"Solutions are no longer accepted for this batch\");\n        require(\n            isObjectiveValueSufficientlyImproved(claimedObjectiveValue),\n            \"Claimed objective doesn't sufficiently improve current solution\"\n        );\n        require(verifyAmountThreshold(prices), \"At least one price lower than AMOUNT_MINIMUM\");\n        require(tokenIdsForPrice[0] != 0, \"Fee token has fixed price!\");\n        require(tokenIdsForPrice.checkPriceOrdering(), \"prices are not ordered by tokenId\");\n        require(owners.length <= MAX_TOUCHED_ORDERS, \"Solution exceeds MAX_TOUCHED_ORDERS\");\n        // Further assumptions are: owners.length == orderIds.length && owners.length == buyVolumes.length\n        // && prices.length == tokenIdsForPrice.length\n        // These assumptions are not checked explicitly, as violations of these constraints can not be used\n        // to create a beneficial situation\n        uint256 lastAuctionBurntFees = burnPreviousAuctionFees();\n        undoCurrentSolution();\n        updateCurrentPrices(prices, tokenIdsForPrice);\n        delete latestSolution.trades;\n        int256[] memory tokenConservation = TokenConservation.init(tokenIdsForPrice);\n        uint256 utility = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            require(checkOrderValidity(order, batchId), \"Order is invalid\");\n            (uint128 executedBuyAmount, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            require(executedBuyAmount >= AMOUNT_MINIMUM, \"buy amount less than AMOUNT_MINIMUM\");\n            require(executedSellAmount >= AMOUNT_MINIMUM, \"sell amount less than AMOUNT_MINIMUM\");\n            tokenConservation.updateTokenConservation(\n                order.buyToken,\n                order.sellToken,\n                tokenIdsForPrice,\n                executedBuyAmount,\n                executedSellAmount\n            );\n            require(getRemainingAmount(order) >= executedSellAmount, \"executedSellAmount bigger than specified in order\");\n            // Ensure executed price is not lower than the order price:\n            //       executedSellAmount / executedBuyAmount <= order.priceDenominator / order.priceNumerator\n            require(\n                executedSellAmount.mul(order.priceNumerator) <= executedBuyAmount.mul(order.priceDenominator),\n                \"limit price not satisfied\"\n            );\n            // accumulate utility before updateRemainingOrder, but after limitPrice verified!\n            utility = utility.add(evaluateUtility(executedBuyAmount, order));\n            updateRemainingOrder(owners[i], orderIds[i], executedSellAmount);\n            addBalanceAndBlockWithdrawForThisBatch(owners[i], tokenIdToAddressMap(order.buyToken), executedBuyAmount);\n            emit Trade(owners[i], orderIds[i], order.sellToken, order.buyToken, executedSellAmount, executedBuyAmount);\n        }\n        // Perform all subtractions after additions to avoid negative values\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            (, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            subtractBalance(owners[i], tokenIdToAddressMap(order.sellToken), executedSellAmount);\n        }\n        uint256 disregardedUtility = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            disregardedUtility = disregardedUtility.add(evaluateDisregardedUtility(orders[owners[i]][orderIds[i]], owners[i]));\n        }\n        uint256 burntFees = uint256(tokenConservation.feeTokenImbalance()) / 2;\n        // burntFees ensures direct trades (when available) yield better solutions than longer rings\n        uint256 objectiveValue = utility.add(burntFees).sub(disregardedUtility);\n        checkAndOverrideObjectiveValue(objectiveValue);\n        grantRewardToSolutionSubmitter(burntFees);\n        tokenConservation.checkTokenConservation();\n        documentTrades(batchId, owners, orderIds, buyVolumes, tokenIdsForPrice);\n\n        emit SolutionSubmission(\n            msg.sender,\n            utility,\n            disregardedUtility,\n            burntFees,\n            lastAuctionBurntFees,\n            prices,\n            tokenIdsForPrice\n        );\n        return (objectiv","after":"\n      */\n    function submitSolution(\n        uint32 batchId,\n        uint256 claimedObjectiveValue,\n        address[] calldata owners,\n        uint16[] calldata orderIds,\n        uint128[] calldata buyVolumes,\n        uint128[] calldata prices,\n        uint16[] calldata tokenIdsForPrice\n    ) public returns (uint256) {\n        require(acceptingSolutions(batchId), \"Solutions are no longer accepted for this batch\");\n        require(\n            isObjectiveValueSufficientlyImproved(claimedObjectiveValue),\n            \"Claimed objective doesn't sufficiently improve current solution\"\n        );\n        require(verifyAmountThreshold(prices), \"At least one price lower than AMOUNT_MINIMUM\");\n        require(tokenIdsForPrice[0] != 0, \"Fee token has fixed price!\");\n        require(tokenIdsForPrice.checkPriceOrdering(), \"prices are not ordered by tokenId\");\n        require(owners.length <= MAX_TOUCHED_ORDERS, \"Solution exceeds MAX_TOUCHED_ORDERS\");\n        // Further assumptions are: owners.length == orderIds.length && owners.length == buyVolumes.length\n        // && prices.length == tokenIdsForPrice.length\n        // These assumptions are not checked explicitly, as violations of these constraints can not be used\n        // to create a beneficial situation\n        uint256 lastAuctionBurntFees = burnPreviousAuctionFees();\n        undoCurrentSolution();\n        updateCurrentPrices(prices, tokenIdsForPrice);\n        delete latestSolution.trades;\n        int256[] memory tokenConservation = TokenConservation.init(tokenIdsForPrice);\n        uint256 utility = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            require(checkOrderValidity(order, batchId), \"Order is invalid\");\n            (uint128 executedBuyAmount, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            require(executedBuyAmount >= AMOUNT_MINIMUM, \"buy amount less than AMOUNT_MINIMUM\");\n            require(executedSellAmount >= AMOUNT_MINIMUM, \"sell amount less than AMOUNT_MINIMUM\");\n            tokenConservation.updateTokenConservation(\n                order.buyToken,\n                order.sellToken,\n                tokenIdsForPrice,\n                executedBuyAmount,\n                executedSellAmount\n            );\n            require(getRemainingAmount(order) >= executedSellAmount, \"executedSellAmount bigger than specified in order\");\n            // Ensure executed price is not lower than the order price:\n            //       executedSellAmount / executedBuyAmount <= order.priceDenominator / order.priceNumerator\n            require(\n                executedSellAmount.mul(order.priceNumerator) <= executedBuyAmount.mul(order.priceDenominator),\n                \"limit price not satisfied\"\n            );\n            // accumulate utility before updateRemainingOrder, but after limitPrice verified!\n            utility = utility.add(evaluateUtility(executedBuyAmount, order));\n            updateRemainingOrder(owners[i], orderIds[i], executedSellAmount);\n            addBalanceAndBlockWithdrawForThisBatch(owners[i], tokenIdToAddressMap(order.buyToken), executedBuyAmount);\n            emit Trade(owners[i], orderIds[i], order.sellToken, order.buyToken, executedSellAmount, executedBuyAmount);\n        }\n        // Perform all subtractions after additions to avoid negative values\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            (, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            subtractBalance(owners[i], tokenIdToAddressMap(order.sellToken), executedSellAmount);\n        }\n        uint256 disregardedUtility = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            disregardedUtility = disregardedUtility.add(evaluateDisregardedUtility(orders[owners[i]][orderIds[i]], owners[i]));\n        }\n        uint256 burntFees = uint256(tokenConservation.feeTokenImbalance()) / 2;\n        // burntFees ensures direct trades (when available) yield better solutions than longer rings\n        uint256 objectiveValue = utility.add(burntFees).sub(disregardedUtility);\n        checkAndOverrideObjectiveValue(objectiveValue);\n        grantRewardToSolutionSubmitter(burntFees);\n        tokenConservation.checkTokenConservation();\n        documentTrades(batchId, owners, orderIds, buyVolumes, tokenIdsForPrice);\n\n        emit SolutionSubmission(\n            msg.sender,\n            utility,\n            disregardedUtility,\n            burntFees,\n            lastAuctionBurntFees,\n            prices,\n            tokenIdsForPrice\n        );\n        return (objectiv","contract":"BatchExchange","time":0},{"type":"immutable-restrict-modification ","before":"mixedcase\n    uint256 publ","after":"mixedcase\n    uint256 publ","contract":"BatchExchange","time":0}]}