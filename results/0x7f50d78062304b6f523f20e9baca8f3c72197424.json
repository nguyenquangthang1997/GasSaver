{"time":246,"results":[{"type":"constant-restrict-modification  ","before":"address public WETH;","after":"address public constant WETH;","contract":"ChainlinkedKeydonixOracleMainAssetAbstract","time":0},{"type":"external-function ","before":"function spawn(\n        address asset,\n        uint mainAmount,\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory mainPriceProof,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory colPriceProof\n    )\n    public\n    nonReentrant\n    {\n        require(usdpAmount != 0, \"Unit Protocol: ZERO_BORROWING\");\n\n        // check whether the position is spawned\n        require(vault.getTotalDebt(asset, msg.sender) == 0, \"Unit Protocol: SPAWNED_POSITION\");\n\n        // oracle availability check\n        require(vault.vaultParameters().isOracleTypeEnabled(ORACLE_TYPE, asset), \"Unit Protocol: WRONG_ORACLE_TYPE\");\n\n        // USDP minting triggers the spawn of a position\n        vault.spawn(asset, msg.sender, ORACLE_TYPE);\n\n\n        _depositAndBorrow(asset, msg.sender, mainAmount, colAmount, usdpAmount, mainPriceProof, colPriceProof);\n\n        // fire an event\n        emit Join(asset, msg.sender, mainAmount, colAmount, usdpAmount);\n    }","after":"function spawn(\n        address asset,\n        uint mainAmount,\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata mainPriceProof,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata colPriceProof\n    )\n    public\n    nonReentrant\n    {\n        require(usdpAmount != 0, \"Unit Protocol: ZERO_BORROWING\");\n\n        // check whether the position is spawned\n        require(vault.getTotalDebt(asset, msg.sender) == 0, \"Unit Protocol: SPAWNED_POSITION\");\n\n        // oracle availability check\n        require(vault.vaultParameters().isOracleTypeEnabled(ORACLE_TYPE, asset), \"Unit Protocol: WRONG_ORACLE_TYPE\");\n\n        // USDP minting triggers the spawn of a position\n        vault.spawn(asset, msg.sender, ORACLE_TYPE);\n\n\n        _depositAndBorrow(asset, msg.sender, mainAmount, colAmount, usdpAmount, mainPriceProof, colPriceProof);\n\n        // fire an event\n        emit Join(asset, msg.sender, mainAmount, colAmount, usdpAmount);\n    }","contract":"VaultManagerKeydonixMainAsset","time":0},{"type":"external-function ","before":"function spawn_Eth(\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory colPriceProof\n    )\n    public\n    payable\n    nonReentrant\n    {\n        require(usdpAmount != 0, \"Unit Protocol: ZERO_BORROWING\");\n\n        // check whether the position is spawned\n        require(vault.getTotalDebt(vault.weth(), msg.sender) == 0, \"Unit Protocol: SPAWNED_POSITION\");\n\n        // oracle availability check\n        require(vault.vaultParameters().isOracleTypeEnabled(ORACLE_TYPE, vault.weth()), \"Unit Protocol: WRONG_ORACLE_TYPE\");\n\n        // USDP minting triggers the spawn of a position\n        vault.spawn(vault.weth(), msg.sender, ORACLE_TYPE);\n\n        _depositAndBorrow_Eth(msg.sender, colAmount, usdpAmount, colPriceProof);\n\n        // fire an event\n        emit Join(vault.weth(), msg.sender, msg.value, colAmount, usdpAmount);\n    }","after":"function spawn_Eth(\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata colPriceProof\n    )\n    public\n    payable\n    nonReentrant\n    {\n        require(usdpAmount != 0, \"Unit Protocol: ZERO_BORROWING\");\n\n        // check whether the position is spawned\n        require(vault.getTotalDebt(vault.weth(), msg.sender) == 0, \"Unit Protocol: SPAWNED_POSITION\");\n\n        // oracle availability check\n        require(vault.vaultParameters().isOracleTypeEnabled(ORACLE_TYPE, vault.weth()), \"Unit Protocol: WRONG_ORACLE_TYPE\");\n\n        // USDP minting triggers the spawn of a position\n        vault.spawn(vault.weth(), msg.sender, ORACLE_TYPE);\n\n        _depositAndBorrow_Eth(msg.sender, colAmount, usdpAmount, colPriceProof);\n\n        // fire an event\n        emit Join(vault.weth(), msg.sender, msg.value, colAmount, usdpAmount);\n    }","contract":"VaultManagerKeydonixMainAsset","time":0},{"type":"external-function ","before":"function depositAndBorrow(\n        address asset,\n        uint mainAmount,\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory mainPriceProof,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory colPriceProof\n    )\n    public\n    spawned(asset, msg.sender)\n    nonReentrant\n    {\n        require(usdpAmount != 0, \"Unit Protocol: ZERO_BORROWING\");\n\n        _depositAndBorrow(asset, msg.sender, mainAmount, colAmount, usdpAmount, mainPriceProof, colPriceProof);\n\n        // fire an event\n        emit Join(asset, msg.sender, mainAmount, colAmount, usdpAmount);\n    }","after":"function depositAndBorrow(\n        address asset,\n        uint mainAmount,\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata mainPriceProof,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata colPriceProof\n    )\n    public\n    spawned(asset, msg.sender)\n    nonReentrant\n    {\n        require(usdpAmount != 0, \"Unit Protocol: ZERO_BORROWING\");\n\n        _depositAndBorrow(asset, msg.sender, mainAmount, colAmount, usdpAmount, mainPriceProof, colPriceProof);\n\n        // fire an event\n        emit Join(asset, msg.sender, mainAmount, colAmount, usdpAmount);\n    }","contract":"VaultManagerKeydonixMainAsset","time":0},{"type":"external-function ","before":"function depositAndBorrow_Eth(\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory colPriceProof\n    )\n    public\n    payable\n    spawned(vault.weth(), msg.sender)\n    nonReentrant\n    {\n        require(usdpAmount != 0, \"Unit Protocol: ZERO_BORROWING\");\n\n        _depositAndBorrow_Eth(msg.sender, colAmount, usdpAmount, colPriceProof);\n\n        // fire an event\n        emit Join(vault.weth(), msg.sender, msg.value, colAmount, usdpAmount);\n    }","after":"function depositAndBorrow_Eth(\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata colPriceProof\n    )\n    public\n    payable\n    spawned(vault.weth(), msg.sender)\n    nonReentrant\n    {\n        require(usdpAmount != 0, \"Unit Protocol: ZERO_BORROWING\");\n\n        _depositAndBorrow_Eth(msg.sender, colAmount, usdpAmount, colPriceProof);\n\n        // fire an event\n        emit Join(vault.weth(), msg.sender, msg.value, colAmount, usdpAmount);\n    }","contract":"VaultManagerKeydonixMainAsset","time":0},{"type":"external-function ","before":"function withdrawAndRepay(\n        address asset,\n        uint mainAmount,\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory mainPriceProof,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory colPriceProof\n    )\n    public\n    spawned(asset, msg.sender)\n    nonReentrant\n    {\n        // check usefulness of tx\n        require(mainAmount != 0 || colAmount != 0, \"Unit Protocol: USELESS_TX\");\n\n        uint debt = vault.debts(asset, msg.sender);\n        require(debt != 0 && usdpAmount != debt, \"Unit Protocol: USE_REPAY_ALL_INSTEAD\");\n\n        if (mainAmount != 0) {\n            // withdraw main collateral to the user address\n            vault.withdrawMain(asset, msg.sender, mainAmount);\n        }\n\n        if (colAmount != 0) {\n            // withdraw COL tokens to the user's address\n            vault.withdrawCol(asset, msg.sender, colAmount);\n        }\n\n        if (usdpAmount != 0) {\n            uint fee = vault.calculateFee(asset, msg.sender, usdpAmount);\n            vault.chargeFee(vault.usdp(), msg.sender, fee);\n            vault.repay(asset, msg.sender, usdpAmount);\n        }\n\n        vault.update(asset, msg.sender);\n\n        _ensureCollateralizationTroughProofs(asset, msg.sender, mainPriceProof, colPriceProof);\n\n        // fire an event\n        emit Exit(asset, msg.sender, mainAmount, colAmount, usdpAmount);\n    }","after":"function withdrawAndRepay(\n        address asset,\n        uint mainAmount,\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata mainPriceProof,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata colPriceProof\n    )\n    public\n    spawned(asset, msg.sender)\n    nonReentrant\n    {\n        // check usefulness of tx\n        require(mainAmount != 0 || colAmount != 0, \"Unit Protocol: USELESS_TX\");\n\n        uint debt = vault.debts(asset, msg.sender);\n        require(debt != 0 && usdpAmount != debt, \"Unit Protocol: USE_REPAY_ALL_INSTEAD\");\n\n        if (mainAmount != 0) {\n            // withdraw main collateral to the user address\n            vault.withdrawMain(asset, msg.sender, mainAmount);\n        }\n\n        if (colAmount != 0) {\n            // withdraw COL tokens to the user's address\n            vault.withdrawCol(asset, msg.sender, colAmount);\n        }\n\n        if (usdpAmount != 0) {\n            uint fee = vault.calculateFee(asset, msg.sender, usdpAmount);\n            vault.chargeFee(vault.usdp(), msg.sender, fee);\n            vault.repay(asset, msg.sender, usdpAmount);\n        }\n\n        vault.update(asset, msg.sender);\n\n        _ensureCollateralizationTroughProofs(asset, msg.sender, mainPriceProof, colPriceProof);\n\n        // fire an event\n        emit Exit(asset, msg.sender, mainAmount, colAmount, usdpAmount);\n    }","contract":"VaultManagerKeydonixMainAsset","time":0},{"type":"external-function ","before":"function withdrawAndRepay_Eth(\n        uint ethAmount,\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory colPriceProof\n    )\n    public\n    spawned(vault.weth(), msg.sender)\n    nonReentrant\n    {\n        // check usefulness of tx\n        require(ethAmount != 0 || colAmount != 0, \"Unit Protocol: USELESS_TX\");\n\n        uint debt = vault.debts(vault.weth(), msg.sender);\n        require(debt != 0 && usdpAmount != debt, \"Unit Protocol: USE_REPAY_ALL_INSTEAD\");\n\n        if (ethAmount != 0) {\n            // withdraw main collateral to the user address\n            vault.withdrawEth(msg.sender, ethAmount);\n        }\n\n        if (colAmount != 0) {\n            // withdraw COL tokens to the user's address\n            vault.withdrawCol(vault.weth(), msg.sender, colAmount);\n        }\n\n        if (usdpAmount != 0) {\n            uint fee = vault.calculateFee(vault.weth(), msg.sender, usdpAmount);\n            vault.chargeFee(vault.usdp(), msg.sender, fee);\n            vault.repay(vault.weth(), msg.sender, usdpAmount);\n        }\n\n        vault.update(vault.weth(), msg.sender);\n\n        _ensureCollateralizationTroughProofs_Eth(msg.sender, colPriceProof);\n\n        // fire an event\n        emit Exit(vault.weth(), msg.sender, ethAmount, colAmount, usdpAmount);\n    }","after":"function withdrawAndRepay_Eth(\n        uint ethAmount,\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata colPriceProof\n    )\n    public\n    spawned(vault.weth(), msg.sender)\n    nonReentrant\n    {\n        // check usefulness of tx\n        require(ethAmount != 0 || colAmount != 0, \"Unit Protocol: USELESS_TX\");\n\n        uint debt = vault.debts(vault.weth(), msg.sender);\n        require(debt != 0 && usdpAmount != debt, \"Unit Protocol: USE_REPAY_ALL_INSTEAD\");\n\n        if (ethAmount != 0) {\n            // withdraw main collateral to the user address\n            vault.withdrawEth(msg.sender, ethAmount);\n        }\n\n        if (colAmount != 0) {\n            // withdraw COL tokens to the user's address\n            vault.withdrawCol(vault.weth(), msg.sender, colAmount);\n        }\n\n        if (usdpAmount != 0) {\n            uint fee = vault.calculateFee(vault.weth(), msg.sender, usdpAmount);\n            vault.chargeFee(vault.usdp(), msg.sender, fee);\n            vault.repay(vault.weth(), msg.sender, usdpAmount);\n        }\n\n        vault.update(vault.weth(), msg.sender);\n\n        _ensureCollateralizationTroughProofs_Eth(msg.sender, colPriceProof);\n\n        // fire an event\n        emit Exit(vault.weth(), msg.sender, ethAmount, colAmount, usdpAmount);\n    }","contract":"VaultManagerKeydonixMainAsset","time":0},{"type":"external-function ","before":"function repayUsingCol(\n        address asset,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory colPriceProof\n    )\n    public\n    spawned(asset, msg.sender)\n    nonReentrant\n    {\n        // check usefulness of tx\n        require(usdpAmount != 0, \"Unit Protocol: USELESS_TX\");\n\n        // COL token price in USD\n        uint colUsdPrice_q112 = uniswapOracleMainAsset.assetToUsd(vault.col(), 1, colPriceProof);\n\n        uint fee = vault.calculateFee(asset, msg.sender, usdpAmount);\n        uint feeInCol = fee.mul(Q112).div(colUsdPrice_q112);\n        vault.chargeFee(vault.col(), msg.sender, feeInCol);\n        vault.repay(asset, msg.sender, usdpAmount);\n\n        // fire an event\n        emit Exit(asset, msg.sender, 0, 0, usdpAmount);\n    }","after":"function repayUsingCol(\n        address asset,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata colPriceProof\n    )\n    public\n    spawned(asset, msg.sender)\n    nonReentrant\n    {\n        // check usefulness of tx\n        require(usdpAmount != 0, \"Unit Protocol: USELESS_TX\");\n\n        // COL token price in USD\n        uint colUsdPrice_q112 = uniswapOracleMainAsset.assetToUsd(vault.col(), 1, colPriceProof);\n\n        uint fee = vault.calculateFee(asset, msg.sender, usdpAmount);\n        uint feeInCol = fee.mul(Q112).div(colUsdPrice_q112);\n        vault.chargeFee(vault.col(), msg.sender, feeInCol);\n        vault.repay(asset, msg.sender, usdpAmount);\n\n        // fire an event\n        emit Exit(asset, msg.sender, 0, 0, usdpAmount);\n    }","contract":"VaultManagerKeydonixMainAsset","time":0},{"type":"external-function ","before":"function withdrawAndRepayUsingCol(\n        address asset,\n        uint mainAmount,\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory mainPriceProof,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory colPriceProof\n    )\n    public\n    spawned(asset, msg.sender)\n    nonReentrant\n    {\n        // check usefulness of tx\n        require(mainAmount != 0 || colAmount != 0, \"Unit Protocol: USELESS_TX\");\n\n        // fix 'Stack too deep'\n        {\n            uint debt = vault.debts(asset, msg.sender);\n            require(debt != 0 && usdpAmount != debt, \"Unit Protocol: USE_REPAY_ALL_INSTEAD\");\n\n            if (mainAmount != 0) {\n                // withdraw main collateral to the user address\n                vault.withdrawMain(asset, msg.sender, mainAmount);\n            }\n\n            if (colAmount != 0) {\n                // withdraw COL tokens to the user's address\n                vault.withdrawCol(asset, msg.sender, colAmount);\n            }\n        }\n\n        uint colDeposit = vault.colToken(asset, msg.sender);\n\n        // main collateral value of the position in USD\n        uint mainUsdValue_q112 = uniswapOracleMainAsset.assetToUsd(asset, vault.collaterals(asset, msg.sender), mainPriceProof);\n\n        // COL token value of the position in USD\n        uint colUsdValue_q112 = uniswapOracleMainAsset.assetToUsd(vault.col(), colDeposit, colPriceProof);\n\n        if (usdpAmount != 0) {\n            uint fee = vault.calculateFee(asset, msg.sender, usdpAmount);\n            uint feeInCol = fee.mul(Q112).mul(colDeposit).div(colUsdValue_q112);\n            vault.chargeFee(vault.col(), msg.sender, feeInCol);\n            vault.repay(asset, msg.sender, usdpAmount);\n        }\n\n        vault.update(asset, msg.sender);\n\n        _ensureCollateralization(asset, msg.sender, mainUsdValue_q112, colUsdValue_q112);\n\n        // fire an event\n        emit Exit(asset, msg.sender, mainAmount, colAmount, usdpAmount);\n    }","after":"function withdrawAndRepayUsingCol(\n        address asset,\n        uint mainAmount,\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata mainPriceProof,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata colPriceProof\n    )\n    public\n    spawned(asset, msg.sender)\n    nonReentrant\n    {\n        // check usefulness of tx\n        require(mainAmount != 0 || colAmount != 0, \"Unit Protocol: USELESS_TX\");\n\n        // fix 'Stack too deep'\n        {\n            uint debt = vault.debts(asset, msg.sender);\n            require(debt != 0 && usdpAmount != debt, \"Unit Protocol: USE_REPAY_ALL_INSTEAD\");\n\n            if (mainAmount != 0) {\n                // withdraw main collateral to the user address\n                vault.withdrawMain(asset, msg.sender, mainAmount);\n            }\n\n            if (colAmount != 0) {\n                // withdraw COL tokens to the user's address\n                vault.withdrawCol(asset, msg.sender, colAmount);\n            }\n        }\n\n        uint colDeposit = vault.colToken(asset, msg.sender);\n\n        // main collateral value of the position in USD\n        uint mainUsdValue_q112 = uniswapOracleMainAsset.assetToUsd(asset, vault.collaterals(asset, msg.sender), mainPriceProof);\n\n        // COL token value of the position in USD\n        uint colUsdValue_q112 = uniswapOracleMainAsset.assetToUsd(vault.col(), colDeposit, colPriceProof);\n\n        if (usdpAmount != 0) {\n            uint fee = vault.calculateFee(asset, msg.sender, usdpAmount);\n            uint feeInCol = fee.mul(Q112).mul(colDeposit).div(colUsdValue_q112);\n            vault.chargeFee(vault.col(), msg.sender, feeInCol);\n            vault.repay(asset, msg.sender, usdpAmount);\n        }\n\n        vault.update(asset, msg.sender);\n\n        _ensureCollateralization(asset, msg.sender, mainUsdValue_q112, colUsdValue_q112);\n\n        // fire an event\n        emit Exit(asset, msg.sender, mainAmount, colAmount, usdpAmount);\n    }","contract":"VaultManagerKeydonixMainAsset","time":0},{"type":"external-function ","before":"function withdrawAndRepayUsingCol_Eth(\n        uint ethAmount,\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory mainPriceProof,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory colPriceProof\n    )\n    public\n    spawned(vault.weth(), msg.sender)\n    nonReentrant\n    {\n        // fix 'Stack too deep'\n        {\n            // check usefulness of tx\n            require(ethAmount != 0 || colAmount != 0, \"Unit Protocol: USELESS_TX\");\n\n            uint debt = vault.debts(vault.weth(), msg.sender);\n            require(debt != 0 && usdpAmount != debt, \"Unit Protocol: USE_REPAY_ALL_INSTEAD\");\n\n            if (ethAmount != 0) {\n                // withdraw main collateral to the user address\n                vault.withdrawEth(msg.sender, ethAmount);\n            }\n\n            if (colAmount != 0) {\n                // withdraw COL tokens to the user's address\n                vault.withdrawCol(vault.weth(), msg.sender, colAmount);\n            }\n        }\n\n        uint colDeposit = vault.colToken(vault.weth(), msg.sender);\n\n        // main collateral value of the position in USD\n        uint mainUsdValue_q112 = uniswapOracleMainAsset.assetToUsd(vault.weth(), vault.collaterals(vault.weth(), msg.sender), mainPriceProof);\n\n        // COL token value of the position in USD\n        uint colUsdValue_q112 = uniswapOracleMainAsset.assetToUsd(vault.col(), colDeposit, colPriceProof);\n\n        if (usdpAmount != 0) {\n            uint fee = vault.calculateFee(vault.weth(), msg.sender, usdpAmount);\n            uint feeInCol = fee.mul(Q112).mul(colDeposit).div(colUsdValue_q112);\n            vault.chargeFee(vault.col(), msg.sender, feeInCol);\n            vault.repay(vault.weth(), msg.sender, usdpAmount);\n        }\n\n        vault.update(vault.weth(), msg.sender);\n\n        _ensureCollateralization(vault.weth(), msg.sender, mainUsdValue_q112, colUsdValue_q112);\n\n        // fire an event\n        emit Exit(vault.weth(), msg.sender, ethAmount, colAmount, usdpAmount);\n    }","after":"function withdrawAndRepayUsingCol_Eth(\n        uint ethAmount,\n        uint colAmount,\n        uint usdpAmount,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata mainPriceProof,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata colPriceProof\n    )\n    public\n    spawned(vault.weth(), msg.sender)\n    nonReentrant\n    {\n        // fix 'Stack too deep'\n        {\n            // check usefulness of tx\n            require(ethAmount != 0 || colAmount != 0, \"Unit Protocol: USELESS_TX\");\n\n            uint debt = vault.debts(vault.weth(), msg.sender);\n            require(debt != 0 && usdpAmount != debt, \"Unit Protocol: USE_REPAY_ALL_INSTEAD\");\n\n            if (ethAmount != 0) {\n                // withdraw main collateral to the user address\n                vault.withdrawEth(msg.sender, ethAmount);\n            }\n\n            if (colAmount != 0) {\n                // withdraw COL tokens to the user's address\n                vault.withdrawCol(vault.weth(), msg.sender, colAmount);\n            }\n        }\n\n        uint colDeposit = vault.colToken(vault.weth(), msg.sender);\n\n        // main collateral value of the position in USD\n        uint mainUsdValue_q112 = uniswapOracleMainAsset.assetToUsd(vault.weth(), vault.collaterals(vault.weth(), msg.sender), mainPriceProof);\n\n        // COL token value of the position in USD\n        uint colUsdValue_q112 = uniswapOracleMainAsset.assetToUsd(vault.col(), colDeposit, colPriceProof);\n\n        if (usdpAmount != 0) {\n            uint fee = vault.calculateFee(vault.weth(), msg.sender, usdpAmount);\n            uint feeInCol = fee.mul(Q112).mul(colDeposit).div(colUsdValue_q112);\n            vault.chargeFee(vault.col(), msg.sender, feeInCol);\n            vault.repay(vault.weth(), msg.sender, usdpAmount);\n        }\n\n        vault.update(vault.weth(), msg.sender);\n\n        _ensureCollateralization(vault.weth(), msg.sender, mainUsdValue_q112, colUsdValue_q112);\n\n        // fire an event\n        emit Exit(vault.weth(), msg.sender, ethAmount, colAmount, usdpAmount);\n    }","contract":"VaultManagerKeydonixMainAsset","time":0},{"type":"immutable-restrict-modification ","before":"address payable public vault;","after":"address payable public immutable vault;","contract":"VaultParameters","time":0}]}