{"time":177,"results":[{"type":"state-data-arrangement ","before":"\nbytes32 constant private FILE = \"LimitOrders\";\nbytes2 constant private EIP191_HEADER = 0x1901;\nstring constant private EIP712_DOMAIN_NAME = \"LimitOrders\";\nstring constant private EIP712_DOMAIN_VERSION = \"1.1\";\nbytes32 constant private EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n\n            \"EIP712Domain(\",\n\n            \"string name,\",\n\n            \"string version,\",\n\n            \"uint256 chainId,\",\n\n            \"address verifyingContract\",\n\n            \")\"\n\n        ));\nbytes32 constant private EIP712_LIMIT_ORDER_STRUCT_SCHEMA_HASH = keccak256(abi.encodePacked(\n\n            \"LimitOrder(\",\n\n            \"uint256 makerMarket,\",\n\n            \"uint256 takerMarket,\",\n\n            \"uint256 makerAmount,\",\n\n            \"uint256 takerAmount,\",\n\n            \"address makerAccountOwner,\",\n\n            \"uint256 makerAccountNumber,\",\n\n            \"address takerAccountOwner,\",\n\n            \"uint256 takerAccountNumber,\",\n\n            \"uint256 expiration,\",\n\n            \"uint256 salt\",\n\n            \")\"\n\n        ));\nuint256 constant private NUM_ORDER_BYTES = 320;\nuint256 constant private NUM_SIGNATURE_BYTES = 66;\nuint256 constant private NUM_CALLFUNCTIONDATA_BYTES = 32 + NUM_ORDER_BYTES;\nbytes32 public EIP712_DOMAIN_HASH;\nbool public g_isOperational;\nmapping(bytes32 => uint256) public g_makerFilledAmount;\nmapping(bytes32 => OrderStatus) public g_status;","after":"bytes32 constant private FILE = \"LimitOrders\";\nstring constant private EIP712_DOMAIN_NAME = \"LimitOrders\";\nstring constant private EIP712_DOMAIN_VERSION = \"1.1\";\nbytes32 constant private EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n\n            \"EIP712Domain(\",\n\n            \"string name,\",\n\n            \"string version,\",\n\n            \"uint256 chainId,\",\n\n            \"address verifyingContract\",\n\n            \")\"\n\n        ));\nbytes32 constant private EIP712_LIMIT_ORDER_STRUCT_SCHEMA_HASH = keccak256(abi.encodePacked(\n\n            \"LimitOrder(\",\n\n            \"uint256 makerMarket,\",\n\n            \"uint256 takerMarket,\",\n\n            \"uint256 makerAmount,\",\n\n            \"uint256 takerAmount,\",\n\n            \"address makerAccountOwner,\",\n\n            \"uint256 makerAccountNumber,\",\n\n            \"address takerAccountOwner,\",\n\n            \"uint256 takerAccountNumber,\",\n\n            \"uint256 expiration,\",\n\n            \"uint256 salt\",\n\n            \")\"\n\n        ));\nuint256 constant private NUM_ORDER_BYTES = 320;\nuint256 constant private NUM_SIGNATURE_BYTES = 66;\nuint256 constant private NUM_CALLFUNCTIONDATA_BYTES = 32 + NUM_ORDER_BYTES;\nbytes32 public EIP712_DOMAIN_HASH;\nmapping(bytes32 => uint256) public g_makerFilledAmount;\nmapping(bytes32 => OrderStatus) public g_status;\nbytes2 constant private EIP191_HEADER = 0x1901;\nbool public g_isOperational;\n","contract":"LimitOrders","time":0},{"type":"external-function ","before":"function cancelOrder(\n\n        Order memory order\n\n    )\n\n    public\n\n    {\n\n        cancelOrderInternal(msg.sender, order);\n\n    }","after":"function cancelOrder(\n\n        Order calldata order\n\n    )\n\n    public\n\n    {\n\n        cancelOrderInternal(msg.sender, order);\n\n    }","contract":"LimitOrders","time":0},{"type":"external-function ","before":"function approveOrder(\n\n        Order memory order\n\n    )\n\n    public\n\n    {\n\n        approveOrderInternal(msg.sender, order);\n\n    }","after":"function approveOrder(\n\n        Order calldata order\n\n    )\n\n    public\n\n    {\n\n        approveOrderInternal(msg.sender, order);\n\n    }","contract":"LimitOrders","time":0},{"type":"external-function ","before":"function getTradeCost(\n\n        uint256 inputMarketId,\n\n        uint256 outputMarketId,\n\n        Account.Info memory makerAccount,\n\n        Account.Info memory takerAccount,\n\n        Types.Par memory /* oldInputPar */,\n\n        Types.Par memory /* newInputPar */,\n\n        Types.Wei memory inputWei,\n\n        bytes memory data\n\n    )\n\n    public\n\n    onlySolo(msg.sender)\n\n    returns (Types.AssetAmount memory)\n\n    {\n\n        Require.that(\n\n            g_isOperational,\n\n            FILE,\n\n            \"Contract is not operational\"\n\n        );\n\n\n        OrderInfo memory orderInfo = getOrderAndValidateSignature(data);\n\n\n        verifyOrderAndAccountsAndMarkets(\n\n            orderInfo,\n\n            makerAccount,\n\n            takerAccount,\n\n            inputMarketId,\n\n            outputMarketId,\n\n            inputWei\n\n        );\n\n\n        return getOutputAssetAmount(\n\n            inputMarketId,\n\n            outputMarketId,\n\n            inputWei,\n\n            orderInfo\n\n        );\n\n    }","after":"function getTradeCost(\n\n        uint256 inputMarketId,\n\n        uint256 outputMarketId,\n\n        Account.Info calldata makerAccount,\n\n        Account.Info calldata takerAccount,\n\n        Types.Par calldata /* oldInputPar */,\n\n        Types.Par calldata /* newInputPar */,\n\n        Types.Wei calldata inputWei,\n\n        bytes calldata data\n\n    )\n\n    public\n\n    onlySolo(msg.sender)\n\n    returns (Types.AssetAmount memory)\n\n    {\n\n        Require.that(\n\n            g_isOperational,\n\n            FILE,\n\n            \"Contract is not operational\"\n\n        );\n\n\n        OrderInfo memory orderInfo = getOrderAndValidateSignature(data);\n\n\n        verifyOrderAndAccountsAndMarkets(\n\n            orderInfo,\n\n            makerAccount,\n\n            takerAccount,\n\n            inputMarketId,\n\n            outputMarketId,\n\n            inputWei\n\n        );\n\n\n        return getOutputAssetAmount(\n\n            inputMarketId,\n\n            outputMarketId,\n\n            inputWei,\n\n            orderInfo\n\n        );\n\n    }","contract":"LimitOrders","time":0},{"type":"external-function ","before":"function callFunction(\n\n        address /* sender */,\n\n        Account.Info memory accountInfo,\n\n        bytes memory data\n\n    )\n\n    public\n\n    onlySolo(msg.sender)\n\n    {\n\n        Require.that(\n\n            data.length == NUM_CALLFUNCTIONDATA_BYTES,\n\n            FILE,\n\n            \"Cannot parse CallFunctionData\"\n\n        );\n\n\n        CallFunctionData memory cfd = abi.decode(data, (CallFunctionData));\n\n\n        if (cfd.callType == CallFunctionType.Approve) {\n\n            approveOrderInternal(accountInfo.owner, cfd.order);\n\n        } else {\n\n            assert(cfd.callType == CallFunctionType.Cancel);\n\n            cancelOrderInternal(accountInfo.owner, cfd.order);\n\n        }\n\n    }","after":"function callFunction(\n\n        address /* sender */,\n\n        Account.Info calldata accountInfo,\n\n        bytes calldata data\n\n    )\n\n    public\n\n    onlySolo(msg.sender)\n\n    {\n\n        Require.that(\n\n            data.length == NUM_CALLFUNCTIONDATA_BYTES,\n\n            FILE,\n\n            \"Cannot parse CallFunctionData\"\n\n        );\n\n\n        CallFunctionData memory cfd = abi.decode(data, (CallFunctionData));\n\n\n        if (cfd.callType == CallFunctionType.Approve) {\n\n            approveOrderInternal(accountInfo.owner, cfd.order);\n\n        } else {\n\n            assert(cfd.callType == CallFunctionType.Cancel);\n\n            cancelOrderInternal(accountInfo.owner, cfd.order);\n\n        }\n\n    }","contract":"LimitOrders","time":0},{"type":"external-function ","before":"function getOrderStates(\n\n        bytes32[] memory orderHashes\n\n    )\n\n    public\n\n    view\n\n    returns (OrderQueryOutput[] memory)\n\n    {\n\n        uint256 numOrders = orderHashes.length;\n\n        OrderQueryOutput[] memory output = new OrderQueryOutput[](numOrders);\n\n\n        // for each order\n\n        for (uint256 i = 0; i < numOrders; i++) {\n\n            bytes32 orderHash = orderHashes[i];\n\n            output[i] = OrderQueryOutput({\n\n            orderStatus : g_status[orderHash],\n\n            orderMakerFilledAmount : g_makerFilledAmount[orderHash]\n\n            });\n\n        }\n\n        return output;\n\n    }","after":"function getOrderStates(\n\n        bytes32[] calldata orderHashes\n\n    )\n\n    public\n\n    view\n\n    returns (OrderQueryOutput[] memory)\n\n    {\n\n        uint256 numOrders = orderHashes.length;\n\n        OrderQueryOutput[] memory output = new OrderQueryOutput[](numOrders);\n\n\n        // for each order\n\n        for (uint256 i = 0; i < numOrders; i++) {\n\n            bytes32 orderHash = orderHashes[i];\n\n            output[i] = OrderQueryOutput({\n\n            orderStatus : g_status[orderHash],\n\n            orderMakerFilledAmount : g_makerFilledAmount[orderHash]\n\n            });\n\n        }\n\n        return output;\n\n    }","contract":"LimitOrders","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public EIP712_DOMAIN_HASH;","after":"bytes32 public immutable EIP712_DOMAIN_HASH;","contract":"LimitOrders","time":1}]}