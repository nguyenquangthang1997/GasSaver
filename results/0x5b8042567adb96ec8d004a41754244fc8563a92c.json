{"time":713,"results":[{"type":"external-function ","before":"function canClaim(\n        address proxy,\n        uint256 deadline,\n        bytes memory params,\n        address,\n        uint256 bidPrice,\n        address,\n        uint256,\n        uint256\n    ) external view override returns (bool) {\n        (uint256 startPrice, uint256 endPrice, uint256 startedAt) = abi.decode(params, (uint256, uint256, uint256));\n        require(startPrice > endPrice, \"SHOYU: INVALID_PRICE_RANGE\");\n        require(startedAt < deadline, \"SHOYU: INVALID_STARTED_AT\");\n\n        uint256 tickPerBlock = (startPrice - endPrice) / (deadline - startedAt);\n        uint256 currentPrice =\n        block.timestamp >= deadline ? endPrice : startPrice - ((block.timestamp - startedAt) * tickPerBlock);\n\n        return (proxy != address(0) || block.timestamp <= deadline) && bidPrice >= currentPrice;\n    }","after":"function canClaim(\n        address proxy,\n        uint256 deadline,\n        bytes calldata params,\n        address,\n        uint256 bidPrice,\n        address,\n        uint256,\n        uint256\n    ) external view override returns (bool) {\n        (uint256 startPrice, uint256 endPrice, uint256 startedAt) = abi.decode(params, (uint256, uint256, uint256));\n        require(startPrice > endPrice, \"SHOYU: INVALID_PRICE_RANGE\");\n        require(startedAt < deadline, \"SHOYU: INVALID_STARTED_AT\");\n\n        uint256 tickPerBlock = (startPrice - endPrice) / (deadline - startedAt);\n        uint256 currentPrice =\n        block.timestamp >= deadline ? endPrice : startPrice - ((block.timestamp - startedAt) * tickPerBlock);\n\n        return (proxy != address(0) || block.timestamp <= deadline) && bidPrice >= currentPrice;\n    }","contract":"DutchAuction","time":0},{"type":"external-function ","before":"function canBid(\n        address,\n        uint256,\n        bytes memory,\n        address,\n        uint256,\n        address,\n        uint256,\n        uint256\n    ) external pure override returns (bool) {\n        return false;\n    }","after":"function canBid(\n        address,\n        uint256,\n        bytes calldata,\n        address,\n        uint256,\n        address,\n        uint256,\n        uint256\n    ) external pure override returns (bool) {\n        return false;\n    }","contract":"DutchAuction","time":0},{"type":"external-function ","before":"function cancel(Orders.Ask memory order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","after":"function cancel(Orders.Ask calldata order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","contract":"ERC1155ExchangeV0","time":0},{"type":"external-function ","before":"function bid(Orders.Ask memory askOrder, Orders.Bid memory bidOrder)\n    external\n    override\n    nonReentrant\n    returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n        _bid(\n            askOrder,\n            askHash,\n            bidOrder.signer,\n            bidOrder.amount,\n            bidOrder.price,\n            bidOrder.recipient,\n            bidOrder.referrer\n        );\n    }","after":"function bid(Orders.Ask calldata askOrder, Orders.Bid calldata bidOrder)\n    external\n    override\n    nonReentrant\n    returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n        _bid(\n            askOrder,\n            askHash,\n            bidOrder.signer,\n            bidOrder.amount,\n            bidOrder.price,\n            bidOrder.recipient,\n            bidOrder.referrer\n        );\n    }","contract":"ERC1155ExchangeV0","time":0},{"type":"external-function ","before":"function bid(\n        Orders.Ask memory askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","after":"function bid(\n        Orders.Ask calldata askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","contract":"ERC1155ExchangeV0","time":0},{"type":"external-function ","before":"function claim(Orders.Ask memory askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","after":"function claim(Orders.Ask calldata askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","contract":"ERC1155ExchangeV0","time":0},{"type":"external-function ","before":"function mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external {\n        _mint(account, id, amount, data);\n    }","after":"function mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external {\n        _mint(account, id, amount, data);\n    }","contract":"ERC1155Mock","time":0},{"type":"external-function ","before":"function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external {\n        _mintBatch(to, ids, amounts, data);\n    }","after":"function mintBatch(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external {\n        _mintBatch(to, ids, amounts, data);\n    }","contract":"ERC1155Mock","time":0},{"type":"external-function ","before":"function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n    public\n    view\n    virtual\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","after":"function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    )\n    public\n    view\n    virtual\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","contract":"ERC1155Mock","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n    public\n    virtual\n    override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n    public\n    virtual\n    override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"ERC1155Mock","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n    public\n    virtual\n    override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n    public\n    virtual\n    override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"ERC1155Mock","time":0},{"type":"external-function ","before":"function mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external {\n        _mint(account, id, amount, data);\n    }","after":"function mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external {\n        _mint(account, id, amount, data);\n    }","contract":"ERC1155RoyaltyMock","time":0},{"type":"external-function ","before":"function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external {\n        _mintBatch(to, ids, amounts, data);\n    }","after":"function mintBatch(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external {\n        _mintBatch(to, ids, amounts, data);\n    }","contract":"ERC1155RoyaltyMock","time":0},{"type":"external-function ","before":"function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n    public\n    view\n    virtual\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","after":"function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    )\n    public\n    view\n    virtual\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","contract":"ERC1155RoyaltyMock","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n    public\n    virtual\n    override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n    public\n    virtual\n    override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"ERC1155RoyaltyMock","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n    public\n    virtual\n    override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n    public\n    virtual\n    override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"ERC1155RoyaltyMock","time":0},{"type":"immutable-restrict-modification ","before":"address public owner;","after":"address public immutable owner;","contract":"ERC1155RoyaltyMock","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC20Mock","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC20Mock","time":0},{"type":"external-function ","before":"function cancel(Orders.Ask memory order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","after":"function cancel(Orders.Ask calldata order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","contract":"ERC721ExchangeV0","time":0},{"type":"external-function ","before":"function bid(Orders.Ask memory askOrder, Orders.Bid memory bidOrder)\n    external\n    override\n    nonReentrant\n    returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n        _bid(\n            askOrder,\n            askHash,\n            bidOrder.signer,\n            bidOrder.amount,\n            bidOrder.price,\n            bidOrder.recipient,\n            bidOrder.referrer\n        );\n    }","after":"function bid(Orders.Ask calldata askOrder, Orders.Bid calldata bidOrder)\n    external\n    override\n    nonReentrant\n    returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n        _bid(\n            askOrder,\n            askHash,\n            bidOrder.signer,\n            bidOrder.amount,\n            bidOrder.price,\n            bidOrder.recipient,\n            bidOrder.referrer\n        );\n    }","contract":"ERC721ExchangeV0","time":0},{"type":"external-function ","before":"function bid(\n        Orders.Ask memory askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","after":"function bid(\n        Orders.Ask calldata askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","contract":"ERC721ExchangeV0","time":0},{"type":"external-function ","before":"function claim(Orders.Ask memory askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","after":"function claim(Orders.Ask calldata askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","contract":"ERC721ExchangeV0","time":0},{"type":"external-function ","before":"function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external {\n        _safeMint(to, tokenId, data);\n    }","after":"function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external {\n        _safeMint(to, tokenId, data);\n    }","contract":"ERC721Mock","time":0},{"type":"external-function ","before":"function safeMintBatch0(\n        address[] calldata to,\n        uint256[] calldata tokenId,\n        bytes memory data\n    ) external {\n        require(to.length == tokenId.length);\n        for (uint256 i = 0; i < to.length; i++) {\n            _safeMint(to[i], tokenId[i], data);\n        }\n    }","after":"function safeMintBatch0(\n        address[] calldata to,\n        uint256[] calldata tokenId,\n        bytes calldata data\n    ) external {\n        require(to.length == tokenId.length);\n        for (uint256 i = 0; i < to.length; i++) {\n            _safeMint(to[i], tokenId[i], data);\n        }\n    }","contract":"ERC721Mock","time":0},{"type":"external-function ","before":"function safeMintBatch1(\n        address to,\n        uint256[] calldata tokenId,\n        bytes memory data\n    ) external {\n        for (uint256 i = 0; i < tokenId.length; i++) {\n            _safeMint(to, tokenId[i], data);\n        }\n    }","after":"function safeMintBatch1(\n        address to,\n        uint256[] calldata tokenId,\n        bytes calldata data\n    ) external {\n        for (uint256 i = 0; i < tokenId.length; i++) {\n            _safeMint(to, tokenId[i], data);\n        }\n    }","contract":"ERC721Mock","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC721Mock","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC721Mock","time":1},{"type":"external-function ","before":"function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external {\n        _safeMint(to, tokenId, data);\n    }","after":"function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external {\n        _safeMint(to, tokenId, data);\n    }","contract":"ERC721RoyaltyMock","time":0},{"type":"external-function ","before":"function safeMintBatch0(\n        address[] calldata to,\n        uint256[] calldata tokenId,\n        bytes memory data\n    ) external {\n        require(to.length == tokenId.length);\n        for (uint256 i = 0; i < to.length; i++) {\n            _safeMint(to[i], tokenId[i], data);\n        }\n    }","after":"function safeMintBatch0(\n        address[] calldata to,\n        uint256[] calldata tokenId,\n        bytes calldata data\n    ) external {\n        require(to.length == tokenId.length);\n        for (uint256 i = 0; i < to.length; i++) {\n            _safeMint(to[i], tokenId[i], data);\n        }\n    }","contract":"ERC721RoyaltyMock","time":0},{"type":"external-function ","before":"function safeMintBatch1(\n        address to,\n        uint256[] calldata tokenId,\n        bytes memory data\n    ) external {\n        for (uint256 i = 0; i < tokenId.length; i++) {\n            _safeMint(to, tokenId[i], data);\n        }\n    }","after":"function safeMintBatch1(\n        address to,\n        uint256[] calldata tokenId,\n        bytes calldata data\n    ) external {\n        for (uint256 i = 0; i < tokenId.length; i++) {\n            _safeMint(to, tokenId[i], data);\n        }\n    }","contract":"ERC721RoyaltyMock","time":0},{"type":"immutable-restrict-modification ","before":"address public owner;","after":"address public immutable owner;","contract":"ERC721RoyaltyMock","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC721RoyaltyMock","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC721RoyaltyMock","time":1},{"type":"external-function ","before":"function canClaim(\n        address proxy,\n        uint256 deadline,\n        bytes memory params,\n        address bidder,\n        uint256 bidPrice,\n        address bestBidder,\n        uint256 bestBidPrice,\n        uint256\n    ) external view override returns (bool) {\n        if (proxy == address(0)) {\n            return bidder == bestBidder && bidPrice == bestBidPrice && deadline < block.timestamp;\n        } else {\n            uint256 startPrice = abi.decode(params, (uint256));\n            require(startPrice > 0, \"SHOYU: INVALID_START_PRICE\");\n\n            return bidPrice >= startPrice && deadline < block.timestamp;\n        }\n    }","after":"function canClaim(\n        address proxy,\n        uint256 deadline,\n        bytes calldata params,\n        address bidder,\n        uint256 bidPrice,\n        address bestBidder,\n        uint256 bestBidPrice,\n        uint256\n    ) external view override returns (bool) {\n        if (proxy == address(0)) {\n            return bidder == bestBidder && bidPrice == bestBidPrice && deadline < block.timestamp;\n        } else {\n            uint256 startPrice = abi.decode(params, (uint256));\n            require(startPrice > 0, \"SHOYU: INVALID_START_PRICE\");\n\n            return bidPrice >= startPrice && deadline < block.timestamp;\n        }\n    }","contract":"EnglishAuction","time":0},{"type":"external-function ","before":"function canBid(\n        address proxy,\n        uint256 deadline,\n        bytes memory params,\n        address,\n        uint256 bidPrice,\n        address,\n        uint256 bestBidPrice,\n        uint256\n    ) external view override returns (bool) {\n        if (proxy == address(0)) {\n            uint256 startPrice = abi.decode(params, (uint256));\n            require(startPrice > 0, \"SHOYU: INVALID_START_PRICE\");\n\n            return block.timestamp <= deadline && bidPrice >= startPrice && bidPrice > bestBidPrice;\n        } else {\n            return false;\n        }\n    }","after":"function canBid(\n        address proxy,\n        uint256 deadline,\n        bytes calldata params,\n        address,\n        uint256 bidPrice,\n        address,\n        uint256 bestBidPrice,\n        uint256\n    ) external view override returns (bool) {\n        if (proxy == address(0)) {\n            uint256 startPrice = abi.decode(params, (uint256));\n            require(startPrice > 0, \"SHOYU: INVALID_START_PRICE\");\n\n            return block.timestamp <= deadline && bidPrice >= startPrice && bidPrice > bestBidPrice;\n        } else {\n            return false;\n        }\n    }","contract":"EnglishAuction","time":0},{"type":"external-function ","before":"function canClaim(\n        address proxy,\n        uint256 deadline,\n        bytes memory params,\n        address,\n        uint256 bidPrice,\n        address,\n        uint256,\n        uint256\n    ) external view override returns (bool) {\n        (uint256 price, uint256 startedAt) = abi.decode(params, (uint256, uint256));\n        require(price > 0, \"SHOYU: INVALID_PRICE\");\n        require(startedAt < deadline, \"SHOYU: INVALID_STARTED_AT\");\n        uint256 timestamp = block.timestamp;\n        return (proxy != address(0) || (startedAt <= timestamp && timestamp < deadline)) && bidPrice == price;\n    }","after":"function canClaim(\n        address proxy,\n        uint256 deadline,\n        bytes calldata params,\n        address,\n        uint256 bidPrice,\n        address,\n        uint256,\n        uint256\n    ) external view override returns (bool) {\n        (uint256 price, uint256 startedAt) = abi.decode(params, (uint256, uint256));\n        require(price > 0, \"SHOYU: INVALID_PRICE\");\n        require(startedAt < deadline, \"SHOYU: INVALID_STARTED_AT\");\n        uint256 timestamp = block.timestamp;\n        return (proxy != address(0) || (startedAt <= timestamp && timestamp < deadline)) && bidPrice == price;\n    }","contract":"FixedPriceSale","time":0},{"type":"external-function ","before":"function canBid(\n        address,\n        uint256,\n        bytes memory,\n        address,\n        uint256,\n        address,\n        uint256,\n        uint256\n    ) external pure override returns (bool) {\n        return false;\n    }","after":"function canBid(\n        address,\n        uint256,\n        bytes calldata,\n        address,\n        uint256,\n        address,\n        uint256,\n        uint256\n    ) external pure override returns (bool) {\n        return false;\n    }","contract":"FixedPriceSale","time":0},{"type":"external-function ","before":"function setURI(uint256 id, string memory newURI) external override onlyOwner {\n        _uris[id] = newURI;\n\n        emit SetURI(id, newURI);\n    }","after":"function setURI(uint256 id, string calldata newURI) external override onlyOwner {\n        _uris[id] = newURI;\n\n        emit SetURI(id, newURI);\n    }","contract":"NFT1155V2","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseURI) external override onlyOwner {\n        _baseURI = baseURI;\n\n        emit SetBaseURI(baseURI);\n    }","after":"function setBaseURI(string calldata baseURI) external override onlyOwner {\n        _baseURI = baseURI;\n\n        emit SetBaseURI(baseURI);\n    }","contract":"NFT1155V2","time":0},{"type":"external-function ","before":"function mint(\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes memory data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _mint(to, tokenId, amount, data);\n    }","after":"function mint(\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes calldata data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _mint(to, tokenId, amount, data);\n    }","contract":"NFT1155V2","time":0},{"type":"external-function ","before":"function mintBatch(\n        address to,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _mintBatch(to, tokenIds, amounts, data);\n    }","after":"function mintBatch(\n        address to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _mintBatch(to, tokenIds, amounts, data);\n    }","contract":"NFT1155V2","time":0},{"type":"external-function ","before":"function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n    public\n    view\n    virtual\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"SHOYU: LENGTHS_NOT_EQUAL\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","after":"function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    public\n    view\n    virtual\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"SHOYU: LENGTHS_NOT_EQUAL\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","contract":"NFT1155V2","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(to != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(from == msg.sender || isApprovedForAll(from, msg.sender), \"SHOYU: FORBIDDEN\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _transfer(from, to, id, amount);\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(to != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(from == msg.sender || isApprovedForAll(from, msg.sender), \"SHOYU: FORBIDDEN\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _transfer(from, to, id, amount);\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"NFT1155V2","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(ids.length == amounts.length, \"SHOYU: LENGTHS_NOT_EQUAL\");\n        require(to != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(from == msg.sender || isApprovedForAll(from, msg.sender), \"SHOYU: FORBIDDEN\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"SHOYU: INSUFFICIENT_BALANCE\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(ids.length == amounts.length, \"SHOYU: LENGTHS_NOT_EQUAL\");\n        require(to != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(from == msg.sender || isApprovedForAll(from, msg.sender), \"SHOYU: FORBIDDEN\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"SHOYU: INSUFFICIENT_BALANCE\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"NFT1155V2","time":0},{"type":"external-function ","before":"function cancel(Orders.Ask memory order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","after":"function cancel(Orders.Ask calldata order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","contract":"NFT1155V2","time":0},{"type":"external-function ","before":"function bid(Orders.Ask memory askOrder, Orders.Bid memory bidOrder)\n    external\n    override\n    nonReentrant\n    returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n        _bid(\n            askOrder,\n            askHash,\n            bidOrder.signer,\n            bidOrder.amount,\n            bidOrder.price,\n            bidOrder.recipient,\n            bidOrder.referrer\n        );\n    }","after":"function bid(Orders.Ask calldata askOrder, Orders.Bid calldata bidOrder)\n    external\n    override\n    nonReentrant\n    returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n        _bid(\n            askOrder,\n            askHash,\n            bidOrder.signer,\n            bidOrder.amount,\n            bidOrder.price,\n            bidOrder.recipient,\n            bidOrder.referrer\n        );\n    }","contract":"NFT1155V2","time":0},{"type":"external-function ","before":"function bid(\n        Orders.Ask memory askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","after":"function bid(\n        Orders.Ask calldata askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","contract":"NFT1155V2","time":0},{"type":"external-function ","before":"function claim(Orders.Ask memory askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","after":"function claim(Orders.Ask calldata askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","contract":"NFT1155V2","time":0},{"type":"constant-restrict-modification  ","before":"uint8 internal MAX_ROYALTY_FEE;","after":"uint8 internal constant MAX_ROYALTY_FEE;","contract":"NFT1155V2","time":1},{"type":"external-function ","before":"function setTokenURI(uint256 id, string memory newURI) external override onlyOwner {\n        _uris[id] = newURI;\n\n        emit SetTokenURI(id, newURI);\n    }","after":"function setTokenURI(uint256 id, string calldata newURI) external override onlyOwner {\n        _uris[id] = newURI;\n\n        emit SetTokenURI(id, newURI);\n    }","contract":"NFT721V1","time":0},{"type":"external-function ","before":"function setBaseURI(string memory uri) external override onlyOwner {\n        __baseURI = uri;\n\n        emit SetBaseURI(uri);\n    }","after":"function setBaseURI(string calldata uri) external override onlyOwner {\n        __baseURI = uri;\n\n        emit SetBaseURI(uri);\n    }","contract":"NFT721V1","time":0},{"type":"external-function ","before":"function mint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _safeMint(to, tokenId, data);\n    }","after":"function mint(\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _safeMint(to, tokenId, data);\n    }","contract":"NFT721V1","time":0},{"type":"external-function ","before":"function mintBatch(\n        address to,\n        uint256[] memory tokenIds,\n        bytes memory data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _safeMint(to, tokenIds[i], data);\n        }\n    }","after":"function mintBatch(\n        address to,\n        uint256[] calldata tokenIds,\n        bytes calldata data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _safeMint(to, tokenIds[i], data);\n        }\n    }","contract":"NFT721V1","time":0},{"type":"external-function ","before":"function burnBatch(uint256[] memory tokenIds) external override {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            require(ownerOf(tokenId) == msg.sender, \"SHOYU: FORBIDDEN\");\n\n            _burn(tokenId);\n        }\n    }","after":"function burnBatch(uint256[] calldata tokenIds) external override {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            require(ownerOf(tokenId) == msg.sender, \"SHOYU: FORBIDDEN\");\n\n            _burn(tokenId);\n        }\n    }","contract":"NFT721V1","time":0},{"type":"external-function ","before":"function cancel(Orders.Ask memory order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","after":"function cancel(Orders.Ask calldata order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","contract":"NFT721V1","time":0},{"type":"external-function ","before":"function bid(Orders.Ask memory askOrder, Orders.Bid memory bidOrder)\n    external\n    override\n    nonReentrant\n    returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n        _bid(\n            askOrder,\n            askHash,\n            bidOrder.signer,\n            bidOrder.amount,\n            bidOrder.price,\n            bidOrder.recipient,\n            bidOrder.referrer\n        );\n    }","after":"function bid(Orders.Ask calldata askOrder, Orders.Bid calldata bidOrder)\n    external\n    override\n    nonReentrant\n    returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n        _bid(\n            askOrder,\n            askHash,\n            bidOrder.signer,\n            bidOrder.amount,\n            bidOrder.price,\n            bidOrder.recipient,\n            bidOrder.referrer\n        );\n    }","contract":"NFT721V1","time":0},{"type":"external-function ","before":"function bid(\n        Orders.Ask memory askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","after":"function bid(\n        Orders.Ask calldata askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","contract":"NFT721V1","time":0},{"type":"external-function ","before":"function claim(Orders.Ask memory askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","after":"function claim(Orders.Ask calldata askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","contract":"NFT721V1","time":0},{"type":"struct-data-arrangement ","before":"\naddress signer\naddress proxy\naddress token\nuint256 tokenId\nuint256 amount\naddress strategy\naddress currency\naddress recipient\nuint256 deadline\nbytes params\nuint8 v\nbytes32 r\nbytes32 s","after":"uint256 tokenId\nuint256 amount\nuint256 deadline\nbytes params\nbytes32 r\nbytes32 s\naddress signer\naddress proxy\naddress token\naddress strategy\naddress currency\naddress recipient\nuint8 v\n","contract":"Orders","time":0},{"type":"immutable-restrict-modification ","before":"address internal _target;","after":"address internal immutable _target;","contract":"PaymentSplitterFactory","time":0},{"type":"external-function ","before":"   function initialize(\n        address _owner,\n        string memory _name,\n        string memory _symbol,\n        address _dividendToken,\n        uint256 initialSupply\n    ) external override initializer {\n        __Ownable_init(_owner);\n        __DividendPayingERC20_init(_name, _symbol, _dividendToken);\n        _factory = msg.sender;\n        _mint(_owner, initialSupply);\n\n        _CACHED_CHAIN_ID = block.chainid;\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n            // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                keccak256(bytes(Strings.toHexString(uint160(address(this))))),\n                0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, // keccak256(bytes(\"1\"))\n                block.chainid,\n                address(this)\n            )\n        );\n  ","after":"   function initialize(\n        address _owner,\n        string calldata _name,\n        string calldata _symbol,\n        address _dividendToken,\n        uint256 initialSupply\n    ) external override initializer {\n        __Ownable_init(_owner);\n        __DividendPayingERC20_init(_name, _symbol, _dividendToken);\n        _factory = msg.sender;\n        _mint(_owner, initialSupply);\n\n        _CACHED_CHAIN_ID = block.chainid;\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n            // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                keccak256(bytes(Strings.toHexString(uint160(address(this))))),\n                0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, // keccak256(bytes(\"1\"))\n                block.chainid,\n                address(this)\n            )\n        );\n  ","contract":"SocialTokenV0","time":0},{"type":"state-data-arrangement ","before":"\n   uint8 public constant override MAX_ROYALTY_FEE = 2\n   uint8 public constant override MAX_OPERATIONAL_FEE = \n   bytes32 public constant override PARK_TOKEN_IDS_721_TYPEHASH =\n    0x3fddacac0a7d8b05f741f01ff6becadd9986be8631a2af41a675f365dd7409\n   bytes32 public constant override MINT_BATCH_721_TYPEHASH =\n    0x884adba7f4e17962aed36c871036adea39c6d9f81fb25407a78db239e9731e\n   bytes32 public constant override MINT_BATCH_1155_TYPEHASH =\n    0xb47ce0f6456fcc2f16b7d6e7b0255eb73822b401248e672a4543c2b3d71830\n   bytes32 public constant override MINT_SOCIAL_TOKEN_TYPEHASH =\n    0x8f4bf92e5271f5ec2f59dc3fc74368af0064fb84b40a3de9150dd26c08cda1\n   bytes32 internal immutable _DOMAIN_SEPARAT\n   uint256 internal immutable _CACHED_CHAIN_\n   address[] internal _targets7\n   address[] internal _targets11\n   address[] internal _targetsSocialTok\n   address internal _protocolFeeRecipie\n   uint8 internal _protocolF\n   address internal _operationalFeeRecipie\n   uint8 internal _operationalF\n   mapping(address => uint256) public override nonc\n   string public override baseURI7\n   string public override baseURI11\n   address public override erc721Exchan\n   address public override erc1155Exchan\n   mapping(address => bool) public override isDeployerWhitelist\n   mapping(address => bool) public override isStrategyWhitelist","after":"   bytes32 public constant override PARK_TOKEN_IDS_721_TYPEHASH =\n    0x3fddacac0a7d8b05f741f01ff6becadd9986be8631a2af41a675f365dd7409\n   bytes32 public constant override MINT_BATCH_721_TYPEHASH =\n    0x884adba7f4e17962aed36c871036adea39c6d9f81fb25407a78db239e9731e\n   bytes32 public constant override MINT_BATCH_1155_TYPEHASH =\n    0xb47ce0f6456fcc2f16b7d6e7b0255eb73822b401248e672a4543c2b3d71830\n   bytes32 public constant override MINT_SOCIAL_TOKEN_TYPEHASH =\n    0x8f4bf92e5271f5ec2f59dc3fc74368af0064fb84b40a3de9150dd26c08cda1\n   bytes32 internal immutable _DOMAIN_SEPARAT\n   uint256 internal immutable _CACHED_CHAIN_\n   address[] internal _targets7\n   address[] internal _targets11\n   address[] internal _targetsSocialTok\n   mapping(address => uint256) public override nonc\n   string public override baseURI7\n   string public override baseURI11\n   mapping(address => bool) public override isDeployerWhitelist\n   mapping(address => bool) public override isStrategyWhitelist\n   address internal _protocolFeeRecipie\n   address internal _operationalFeeRecipie\n   address public override erc721Exchan\n   address public override erc1155Exchan\n   uint8 public constant override MAX_ROYALTY_FEE = 2\n   uint8 public constant override MAX_OPERATIONAL_FEE = \n   uint8 internal _protocolF\n   uint8 internal _operationalF\n","contract":"TokenFactory","time":0},{"type":"external-function ","before":"   function setBaseURI721(string memory uri) external override onlyOwner {\n        baseURI721 = uri;\n\n        emit SetBaseURI721(uri);\n  ","after":"   function setBaseURI721(string calldata uri) external override onlyOwner {\n        baseURI721 = uri;\n\n        emit SetBaseURI721(uri);\n  ","contract":"TokenFactory","time":0},{"type":"external-function ","before":"   function setBaseURI1155(string memory uri) external override onlyOwner {\n        baseURI1155 = uri;\n\n        emit SetBaseURI1155(uri);\n  ","after":"   function setBaseURI1155(string calldata uri) external override onlyOwner {\n        baseURI1155 = uri;\n\n        emit SetBaseURI1155(uri);\n  ","contract":"TokenFactory","time":0},{"type":"external-function ","before":"   function deployNFT721AndMintBatch(\n        address owner,\n        string calldata name,\n        string calldata symbol,\n        uint256[] memory tokenIds,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external override onlyDeployer returns (address nft) {\n        require(bytes(name).length > 0, \"SHOYU: INVALID_NAME\");\n        require(bytes(symbol).length > 0, \"SHOYU: INVALID_SYMBOL\");\n        require(owner != address(0), \"SHOYU: INVALID_ADDRESS\");\n\n        nft = _createProxy(\n            _targets721[_targets721.length - 1],\n            abi.encodeWithSignature(\n                \"initialize(address,string,string,uint256[],address,uint8)\",\n                owner,\n                name,\n                symbol,\n                tokenIds,\n                royaltyFeeRecipient,\n                royaltyFee\n            )\n        );\n\n        emit DeployNFT721AndMintBatch(nft, owner, name, symbol, tokenIds, royaltyFeeRecipient, royaltyFee);\n  ","after":"   function deployNFT721AndMintBatch(\n        address owner,\n        string calldata name,\n        string calldata symbol,\n        uint256[] calldata tokenIds,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external override onlyDeployer returns (address nft) {\n        require(bytes(name).length > 0, \"SHOYU: INVALID_NAME\");\n        require(bytes(symbol).length > 0, \"SHOYU: INVALID_SYMBOL\");\n        require(owner != address(0), \"SHOYU: INVALID_ADDRESS\");\n\n        nft = _createProxy(\n            _targets721[_targets721.length - 1],\n            abi.encodeWithSignature(\n                \"initialize(address,string,string,uint256[],address,uint8)\",\n                owner,\n                name,\n                symbol,\n                tokenIds,\n                royaltyFeeRecipient,\n                royaltyFee\n            )\n        );\n\n        emit DeployNFT721AndMintBatch(nft, owner, name, symbol, tokenIds, royaltyFeeRecipient, royaltyFee);\n  ","contract":"TokenFactory","time":0},{"type":"external-function ","before":"   function deployNFT1155AndMintBatch(\n        address owner,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external override onlyDeployer returns (address nft) {\n        require(owner != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(tokenIds.length == amounts.length, \"SHOYU: LENGTHS_NOT_EQUAL\");\n        nft = _createProxy(\n            _targets1155[_targets1155.length - 1],\n            abi.encodeWithSignature(\n                \"initialize(address,uint256[],uint256[],address,uint8)\",\n                owner,\n                tokenIds,\n                amounts,\n                royaltyFeeRecipient,\n                royaltyFee\n            )\n        );\n\n        emit DeployNFT1155AndMintBatch(nft, owner, tokenIds, amounts, royaltyFeeRecipient, royaltyFee);\n  ","after":"   function deployNFT1155AndMintBatch(\n        address owner,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external override onlyDeployer returns (address nft) {\n        require(owner != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(tokenIds.length == amounts.length, \"SHOYU: LENGTHS_NOT_EQUAL\");\n        nft = _createProxy(\n            _targets1155[_targets1155.length - 1],\n            abi.encodeWithSignature(\n                \"initialize(address,uint256[],uint256[],address,uint8)\",\n                owner,\n                tokenIds,\n                amounts,\n                royaltyFeeRecipient,\n                royaltyFee\n            )\n        );\n\n        emit DeployNFT1155AndMintBatch(nft, owner, tokenIds, amounts, royaltyFeeRecipient, royaltyFee);\n  ","contract":"TokenFactory","time":0},{"type":"external-function ","before":"   function deploySocialToken(\n        address owner,\n        string memory name,\n        string memory symbol,\n        address dividendToken,\n        uint256 initialSupply\n    ) external override onlyDeployer returns (address proxy) {\n        require(bytes(name).length > 0, \"SHOYU: INVALID_NAME\");\n        require(bytes(symbol).length > 0, \"SHOYU: INVALID_SYMBOL\");\n        require(owner != address(0), \"SHOYU: INVALID_ADDRESS\");\n\n        bytes memory initData =\n        abi.encodeWithSignature(\n            \"initialize(address,string,string,address,uint256)\",\n            owner,\n            name,\n            symbol,\n            dividendToken,\n            initialSupply\n        );\n        proxy = _createProxy(_targetsSocialToken[_targetsSocialToken.length - 1], initData);\n\n        emit DeploySocialToken(proxy, owner, name, symbol, dividendToken, initialSupply);\n  ","after":"   function deploySocialToken(\n        address owner,\n        string calldata name,\n        string calldata symbol,\n        address dividendToken,\n        uint256 initialSupply\n    ) external override onlyDeployer returns (address proxy) {\n        require(bytes(name).length > 0, \"SHOYU: INVALID_NAME\");\n        require(bytes(symbol).length > 0, \"SHOYU: INVALID_SYMBOL\");\n        require(owner != address(0), \"SHOYU: INVALID_ADDRESS\");\n\n        bytes memory initData =\n        abi.encodeWithSignature(\n            \"initialize(address,string,string,address,uint256)\",\n            owner,\n            name,\n            symbol,\n            dividendToken,\n            initialSupply\n        );\n        proxy = _createProxy(_targetsSocialToken[_targetsSocialToken.length - 1], initData);\n\n        emit DeploySocialToken(proxy, owner, name, symbol, dividendToken, initialSupply);\n  ","contract":"TokenFactory","time":0},{"type":"immutable-restrict-modification ","before":"   uint8 internal _protocolF","after":"   uint8 internal _protocolF","contract":"TokenFactory","time":0}]}