{"time":851,"results":[{"type":"state-data-arrangement ","before":"\n�▓▓▓\n▓▓▓�\n��▓ ▐▓▓▓▓▓�\n▓▓▓  ▓▓▓▓▓▓�\nport \"./api/IBondingMan\nmport \"openzeppelin-so\nndedECDSAKeep is IBondedECDSAKeep {\n    usi\n    // Status of the keep.\n    // Active mean\nAddress of the keep's owner.\n    addres\nof honest keep members required to produce a signature.\nbytes, where X and Y coordinates\n    // are padded with\nests requested to be signed. Used to validate submit\nionStartTimestamp;\n\n   \ne timestamp at which signing process\nress. When set to `0` indica","after":"��▓ ▐▓▓▓▓▓�\n▓▓▓  ▓▓▓▓▓▓�\nport \"./api/IBondingMan\nmport \"openzeppelin-so\nndedECDSAKeep is IBondedECDSAKeep {\n    usi\n    // Status of the keep.\n    // Active mean\nAddress of the keep's owner.\n    addres\nof honest keep members required to produce a signature.\nbytes, where X and Y coordinates\n    // are padded with\nests requested to be signed. Used to validate submit\nionStartTimestamp;\n\n   \ne timestamp at which signing process\n�▓▓▓\n▓▓▓�\nress. When set to `0` indica\n","contract":"AbstractBondedECDSAKeep","time":0},{"type":"external-function ","before":"ract itself.\n    /// Authorize `getAuthoritySource(operatorContract)`\n    /// to grant `operatorContract` the authority to penalize an operator.\n    function getAuthoritySource(\n        address operatorContract\n    ) public view returns (address) {\n        address delegatedAuthoritySource = delegatedAuthority[operatorContract];\n        if (delegatedAuthoritySource == address(0)) {\n            return operatorContract;\n        }\n        return getAuthoritySource(delegatedAuthoritySource);\n    }\n}\n/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓�","after":"ract itself.\n    /// Authorize `getAuthoritySource(operatorContract)`\n    /// to grant `operatorContract` the authority to penalize an operator.\n    function getAuthoritySource(\n        address operatorContract\n    ) public view returns (address) {\n        address delegatedAuthoritySource = delegatedAuthority[operatorContract];\n        if (delegatedAuthoritySource == address(0)) {\n            return operatorContract;\n        }\n        return getAuthoritySource(delegatedAuthoritySource);\n    }\n}\n/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓�","contract":"BondedECDSAKeep","time":0},{"type":"immutable-restrict-modification ","before":"ure.\ninterface IRandomBeaconConsu","after":"ure.\ninterface IRandomBeaconConsu","contract":"BondedECDSAKeepFactory","time":1},{"type":"external-function ","before":"llowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\npragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of `ERC20` that allows token holders to destroy both their own\n * tokens and thos","after":"llowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\n     * from the caller's allowance.\n     *\n     * See `_burn` and `_approve`.\n     */\n    function _burnFrom(address account, uint256 amount) internal {\n        _burn(account, amount);\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\n    }\n}\npragma solidity ^0.5.0;\n\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of `ERC20` that allows token holders to destroy both their own\n * tokens and thos","contract":"GrantStaking","time":0},{"type":"external-function ","before":"�▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓","after":"�▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓���▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓","contract":"KeepToken","time":0},{"type":"immutable-restrict-modification ","before":" msg.sender, _allowan","after":" msg.sender, _allowan","contract":"KeepToken","time":1},{"type":"immutable-restrict-modification ","before":"ender][msg.sender].sub(","after":"ender][msg.sender].sub(","contract":"KeepToken","time":1},{"type":"immutable-restrict-modification ","before":"t));\n        return true","after":"t));\n        return true","contract":"KeepToken","time":1},{"type":"external-function ","before":"ock,\n        uint256 _weight\n    ) internal pure returns (uint256) {\n        // Converting a bytesX type into a larger type\n        // adds zero bytes on the right.\n        uint256 op = uint256(bytes32(bytes20(_op","after":"ock,\n        uint256 _weight\n    ) internal pure returns (uint256) {\n        // Converting a bytesX type into a larger type\n        // adds zero bytes on the right.\n        uint256 op = uint256(bytes32(bytes20(_op","contract":"ManagedGrant","time":0},{"type":"immutable-restrict-modification ","before":"       panicButtons[operator","after":"       panicButtons[operator","contract":"ManagedGrant","time":0},{"type":"immutable-restrict-modification ","before":"act] = defaultPanicButt","after":"act] = defaultPanicButt","contract":"ManagedGrant","time":0},{"type":"struct-data-arrangement ","before":"\n {\n        // Solidi\n dividing by 0\n\n= a / b;\n        \n hold\n\n        return\nding two unsigned intege\nro.\n     *\n   \n uses a `rever\nuntouched) while\n     * Requir\n256 a, uint25\nSafeMath: modulo \ny 0.5.17;\n\nimp\n\"./Position.sol\";\nimport \"./Leaf","after":"= a / b;\n        \n hold\n\n        return\nding two unsigned intege\n uses a `rever\nuntouched) while\n     * Requir\n256 a, uint25\nSafeMath: modulo \ny 0.5.17;\n\nimp\n\"./Position.sol\";\nimport \"./Leaf\n {\n        // Solidi\n dividing by 0\n\nro.\n     *\n   \n","contract":"TokenGrant","time":0},{"type":"external-function ","before":"is full\");\n            return emptyLeaves.stackPop();\n        }\n    }\n\n    function leavesInStack() internal view returns (bool) {\n        return emptyLeaves.getSize() > 0;\n    }\n}\npragma solidity 0.5.17;\n\nlibrary StackLib {\n    function stackPeek(uint256[] storage _array) internal view returns (uint256) {\n        require(_array.length > 0, \"No value to peek, array is empty\");\n        return (_array[_array.length - 1]);\n    }\n\n    function stackPush(uint256[] storage _array, uint256 _element) public {\n        _array.push(_element);\n    }\n\n    function stackPop(uint256[] storage _array) internal returns (uint256) {\n        require(_array.length > 0, \"No value to pop, array is empty\");\n        uint256 value = _array[_array.length - 1];\n        _array.length -= 1;\n        return value;\n    }\n\n    function getSize(uint256[] storage _array) internal view returns (uint256) {\n        return _array.length;\n    }\n}\n/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   �","after":"is full\");\n            return emptyLeaves.stackPop();\n        }\n    }\n\n    function leavesInStack() internal view returns (bool) {\n        return emptyLeaves.getSize() > 0;\n    }\n}\npragma solidity 0.5.17;\n\nlibrary StackLib {\n    function stackPeek(uint256[] storage _array) internal view returns (uint256) {\n        require(_array.length > 0, \"No value to peek, array is empty\");\n        return (_array[_array.length - 1]);\n    }\n\n    function stackPush(uint256[] storage _array, uint256 _element) public {\n        _array.push(_element);\n    }\n\n    function stackPop(uint256[] storage _array) internal returns (uint256) {\n        require(_array.length > 0, \"No value to pop, array is empty\");\n        uint256 value = _array[_array.length - 1];\n        _array.length -= 1;\n        return value;\n    }\n\n    function getSize(uint256[] storage _array) internal view returns (uint256) {\n        return _array.length;\n    }\n}\n/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   �","contract":"TokenGrant","time":0},{"type":"external-function ","before":"rnal stakingContracts;\n\n    // Token grants.\n    mapping(uint256 => Grant) public grants;\n\n    // Token grants stakes.\n    mapping(address => TokenGrantStake) public grantStakes;\n\n    // Mapping of token grant IDs per particular address\n    // involved in a grant as a grantee or as a grant manager.\n    mapping(address => uint256[]) public grantIndices;\n\n    // Token grants balances. Sum of all granted tokens to a grantee.\n    // This includes granted tokens that are already unlocked and\n    // available to be withdrawn to the grantee\n    mapping(address => uint256) public balances;\n\n    // Mapping of operator addresses per particular grantee address.\n    mapping(address => address[]) public granteesToOperators;\n\n    /// @notice Creates a token grant contract for a provided Standard ERC20Burnable token.\n    /// @param _tokenAddress address of a token that will be linked to this contract.\n    constructor(address _tokenAddress) public {\n        require(_tokenAddress != address(0x0), \"Token address can't be zero.\");\n        token = ERC20Burnable(_tokenAddress);\n    }\n\n    /// @notice Used by grant manager to authorize staking contract with the given\n    /// address.\n    function authorizeStakingContract(address _stakingContract) public {\n        require(\n            _stakingContract != address(0x0),\n            \"Staking contract address can't be zero\"\n        );\n        stakingContracts[msg.sender][_stakingContract] = true;\n        emit StakingContractAuthorized(msg.sende","after":"rnal stakingContracts;\n\n    // Token grants.\n    mapping(uint256 => Grant) public grants;\n\n    // Token grants stakes.\n    mapping(address => TokenGrantStake) public grantStakes;\n\n    // Mapping of token grant IDs per particular address\n    // involved in a grant as a grantee or as a grant manager.\n    mapping(address => uint256[]) public grantIndices;\n\n    // Token grants balances. Sum of all granted tokens to a grantee.\n    // This includes granted tokens that are already unlocked and\n    // available to be withdrawn to the grantee\n    mapping(address => uint256) public balances;\n\n    // Mapping of operator addresses per particular grantee address.\n    mapping(address => address[]) public granteesToOperators;\n\n    /// @notice Creates a token grant contract for a provided Standard ERC20Burnable token.\n    /// @param _tokenAddress address of a token that will be linked to this contract.\n    constructor(address _tokenAddress) public {\n        require(_tokenAddress != address(0x0), \"Token address can't be zero.\");\n        token = ERC20Burnable(_tokenAddress);\n    }\n\n    /// @notice Used by grant manager to authorize staking contract with the given\n    /// address.\n    function authorizeStakingContract(address _stakingContract) public {\n        require(\n            _stakingContract != address(0x0),\n            \"Staking contract address can't be zero\"\n        );\n        stakingContracts[msg.sender][_stakingContract] = true;\n        emit StakingContractAuthorized(msg.sende","contract":"TokenGrant","time":0},{"type":"external-function ","before":"dress)\n        );\n\n        require(_grantee != address(0), \"Grantee address can't be zero.\");\n        require(\n            _cliffDuration <= _duration,\n            \"Unlocking cliff duration must be less or equal total unlocking duration.\"\n        );\n\n        require(_stakingPolicy != address(0), \"Staking policy can","after":"dress)\n        );\n\n        require(_grantee != address(0), \"Grantee address can't be zero.\");\n        require(\n            _cliffDuration <= _duration,\n            \"Unlocking cliff duration must be less or equal total unlocking duration.\"\n        );\n\n        require(_stakingPolicy != address(0), \"Staking policy can","contract":"TokenGrantStake","time":0},{"type":"immutable-restrict-modification ","before":"Whether the token g","after":"Whether the token g","contract":"TokenGrantStake","time":0},{"type":"immutable-restrict-modification ","before":"ingPolicy (addre","after":"ingPolicy (addre","contract":"TokenGrantStake","time":0},{"type":"external-function ","before":"akeable amount to what is left in the grant\n        // in the case of a malfunctioning staking policy.\n        if (stakeable > remaining) {\n            stakeable = remaining;\n        }\n\n        return stakeable.sub(grant.staked);\n    }\n\n    /// @notice Cancels delegation within the operator initialization period\n    /// without being subjected to the stake lockup for the undelegation period.\n    /// This can be used to undo mistaken delegation to the wrong operator address.\n    /// @param _operator Address of the stake operator.\n    function cancelStake(address _operator) public {\n        TokenGrantStake grantStake = grantStakes[_operator];\n        uint256 grantId = grantStake.getGrantId();\n        require(\n            msg.sender == _operator || msg.sender == grants[grantId].grantee,\n            \"Only operator or grantee can cancel the delegation.\"\n        );\n\n        uint256 returned = grantStake.cancelStake();\n        grants[grantId","after":"akeable amount to what is left in the grant\n        // in the case of a malfunctioning staking policy.\n        if (stakeable > remaining) {\n            stakeable = remaining;\n        }\n\n        return stakeable.sub(grant.staked);\n    }\n\n    /// @notice Cancels delegation within the operator initialization period\n    /// without being subjected to the stake lockup for the undelegation period.\n    /// This can be used to undo mistaken delegation to the wrong operator address.\n    /// @param _operator Address of the stake operator.\n    function cancelStake(address _operator) public {\n        TokenGrantStake grantStake = grantStakes[_operator];\n        uint256 grantId = grantStake.getGrantId();\n        require(\n            msg.sender == _operator || msg.sender == grants[grantId].grantee,\n            \"Only operator or grantee can cancel the delegation.\"\n        );\n\n        uint256 returned = grantStake.cancelStake();\n        grants[grantId","contract":"TokenStaking","time":0},{"type":"external-function ","before":"  /// @dev Requires that the provided token contract be the same one linked to\n    /// this contract.\n    /// @param _from The owner of the tokens who approved them to transfer.\n    /// @param _value Approved amount for the transfer and stake.\n    /// @param _token Token contract address.\n    /// @param _extraData Data for stake delegation. This byte array must have\n    /// the following values concatenated:\n    /// - Beneficiary address (20 bytes), ignored for a top-up\n    /// - Operator address (20 bytes)\n    /// - Authorizer address (20 bytes), ignored for a top-up\n    /// - Grant ID (32 bytes) - required only when called by TokenStakingEscrow\n    function receiveApproval(\n        address _from,\n        uint256 _value,\n        address _token,\n        bytes memory _extraData\n    ) public {\n        require(ERC20Burnable(_token) == token, \"Unrecognized token\");\n        require(_extraData.length >= 60, \"Corrupted delegation data\");\n\n        // Transfer tokens to this contract.\n        token.safeTransferFrom(_from, address(this), _value);\n\n        address operator = _extraData.toAddress(20);\n        // See if there is an existing delegation for this operator...\n        if (operators[operator].packedParams.getCreationTimestamp() == 0) {\n            // If there is no existing delegation, delegate tokens using\n            // beneficiary and authorizer passed in _extraData.\n            delegate(_from, _value, operator, _extraData);\n        } else {\n         ","after":"  /// @dev Requires that the provided token contract be the same one linked to\n    /// this contract.\n    /// @param _from The owner of the tokens who approved them to transfer.\n    /// @param _value Approved amount for the transfer and stake.\n    /// @param _token Token contract address.\n    /// @param _extraData Data for stake delegation. This byte array must have\n    /// the following values concatenated:\n    /// - Beneficiary address (20 bytes), ignored for a top-up\n    /// - Operator address (20 bytes)\n    /// - Authorizer address (20 bytes), ignored for a top-up\n    /// - Grant ID (32 bytes) - required only when called by TokenStakingEscrow\n    function receiveApproval(\n        address _from,\n        uint256 _value,\n        address _token,\n        bytes memory _extraData\n    ) public {\n        require(ERC20Burnable(_token) == token, \"Unrecognized token\");\n        require(_extraData.length >= 60, \"Corrupted delegation data\");\n\n        // Transfer tokens to this contract.\n        token.safeTransferFrom(_from, address(this), _value);\n\n        address operator = _extraData.toAddress(20);\n        // See if there is an existing delegation for this operator...\n        if (operators[operator].packedParams.getCreationTimestamp() == 0) {\n            // If there is no existing delegation, delegate tokens using\n            // beneficiary and authorizer passed in _extraData.\n            delegate(_from, _value, operator, _extraData);\n        } else {\n         ","contract":"TokenStaking","time":0},{"type":"external-function ","before":"   address _from,\n        uint256 _value,\n        address _operator,\n        bytes memory _extraData\n    ) internal {\n        require(_value >= minimumStake(), \"Less than the minimum stake\");\n\n        address payable beneficiary = address(uint160(_extraData.toAddress(0)));\n        address authorizer = _extraData.toAddress(40);\n\n        operators[_operator] = Operator(\n            OperatorParams.pack(_value, block.timestamp, 0),\n            _from,\n            beneficiary,\n            authorizer\n        );\n\n        grantStaking.tryCapturingDelegationData(\n            tokenGrant,\n            address(escrow),\n            _from,\n            _operator,\n            _extraData\n        );\n\n        emit StakeDelegated(_from, _operator);\n        emit OperatorStaked(_operator, beneficiary, authorizer, _value);\n    }\n\n    /// @notice Performs top-up to an existing operator. Tokens added during\n    /// stake initialization period are immediatelly added to the stake and\n    /// stake initialization timer is reset to the current block. Tokens added\n    /// in a top-up after the stake initialization period is over are not\n    /// included in the operator stake until the initialization period for\n    /// a top-up passes and top-up is committed. Operator must not have the stake\n    /// undelegated. It is expected that the top-up is done from the same source\n    /// of tokens as the initial delegation. That is, if the tokens were\n    /// delegated from a grant, top-up has to be performed from the same grant.\n    /// If the delegation was done using liquid tokens, only liquid tokens from\n    /// the same owner can be used to top-up the stake.\n    /// Top-up can not be cancelled so it is important to be careful with","after":"   address _from,\n        uint256 _value,\n        address _operator,\n        bytes calldata _extraData\n    ) internal {\n        require(_value >= minimumStake(), \"Less than the minimum stake\");\n\n        address payable beneficiary = address(uint160(_extraData.toAddress(0)));\n        address authorizer = _extraData.toAddress(40);\n\n        operators[_operator] = Operator(\n            OperatorParams.pack(_value, block.timestamp, 0),\n            _from,\n            beneficiary,\n            authorizer\n        );\n\n        grantStaking.tryCapturingDelegationData(\n            tokenGrant,\n            address(escrow),\n            _from,\n            _operator,\n            _extraData\n        );\n\n        emit StakeDelegated(_from, _operator);\n        emit OperatorStaked(_operator, beneficiary, authorizer, _value);\n    }\n\n    /// @notice Performs top-up to an existing operator. Tokens added during\n    /// stake initialization period are immediatelly added to the stake and\n    /// stake initialization timer is reset to the current block. Tokens added\n    /// in a top-up after the stake initialization period is over are not\n    /// included in the operator stake until the initialization period for\n    /// a top-up passes and top-up is committed. Operator must not have the stake\n    /// undelegated. It is expected that the top-up is done from the same source\n    /// of tokens as the initial delegation. That is, if the tokens were\n    /// delegated from a grant, top-up has to be performed from the same grant.\n    /// If the delegation was done using liquid tokens, only liquid tokens from\n    /// the same owner can be used to top-up the stake.\n    /// Top-up can not be cancelled so it is important to be careful with","contract":"TokenStaking","time":0},{"type":"immutable-restrict-modification ","before":"re(\n            grant.gran","after":"re(\n            grant.gran","contract":"TokenStaking","time":0},{"type":"immutable-restrict-modification ","before":"ger == msg.sender,\n            \"Only","after":"ger == msg.sender,\n            \"Only","contract":"TokenStaking","time":0},{"type":"external-function ","before":"n the operator.\n    /// @return creators The addresses of operator contracts\n    /// that have placed a lock on the operator.\n    /// @return expirations The expiration times\n    /// of the locks placed on the operator.\n    function getLocks(address operator)\n    public\n    view\n    returns (address[] memory creators, uint256[] memory expirations) {\n        return locks.getLocks(operator);\n    }\n\n    /// @notice Slash provided token amount from every member in the misbehaved\n    /// operators array and burn 10","after":"n the operator.\n    /// @return creators The addresses of operator contracts\n    /// that have placed a lock on the operator.\n    /// @return expirations The expiration times\n    /// of the locks placed on the operator.\n    function getLocks(address operator)\n    public\n    view\n    returns (address[] memory creators, uint256[] memory expirations) {\n        return locks.getLocks(operator);\n    }\n\n    /// @notice Slash provided token amount from every member in the misbehaved\n    /// operators array and burn 10","contract":"TokenStakingEscrow","time":0},{"type":"external-function ","before":" require(\n                _isInitialized(operatorParams),\n                \"Inactive stake\"\n            );\n\n            require(\n                !_isStakeReleased(operator, operatorParams, msg.sender),\n                \"Stake is released\"\n            );\n\n            uint256 currentAmount = operatorParams.getAmount();\n\n            if (currentAmount < amountToSlash) {\n                totalAmountToBurn = totalAmountToBurn.add(currentAmount);\n                operators[operator].packedParams = operatorParams.setAmount(0);\n                emit TokensSlashed(operator, currentAmount);\n            } else {\n                totalAmountToBurn = totalAmountToBurn.add(amountToSlash);\n                operators[operator].packedParams = operatorParams.setAmount(\n                    currentAmount.sub(amountToSlash)\n                );\n                emit TokensSlashed(operator, amountToSlash);\n            }\n        }\n\n        token.burn(totalAmountToBurn);\n    }\n\n    /// @notice Seize provided token amount from every member in the misbehaved\n    /// operators array. The tattletale is rewarded with 5% of the total seized\n    /// amount scaled by the reward adjustment parameter and the ","after":" require(\n                _isInitialized(operatorParams),\n                \"Inactive stake\"\n            );\n\n            require(\n                !_isStakeReleased(operator, operatorParams, msg.sender),\n                \"Stake is released\"\n            );\n\n            uint256 currentAmount = operatorParams.getAmount();\n\n            if (currentAmount < amountToSlash) {\n                totalAmountToBurn = totalAmountToBurn.add(currentAmount);\n                operators[operator].packedParams = operatorParams.setAmount(0);\n                emit TokensSlashed(operator, currentAmount);\n            } else {\n                totalAmountToBurn = totalAmountToBurn.add(amountToSlash);\n                operators[operator].packedParams = operatorParams.setAmount(\n                    currentAmount.sub(amountToSlash)\n                );\n                emit TokensSlashed(operator, amountToSlash);\n            }\n        }\n\n        token.burn(totalAmountToBurn);\n    }\n\n    /// @notice Seize provided token amount from every member in the misbehaved\n    /// operators array. The tattletale is rewarded with 5% of the total seized\n    /// amount scaled by the reward adjustment parameter and the ","contract":"TokenStakingEscrow","time":0}]}