{"time":137,"results":[{"type":"state-data-arrangement ","before":"\n   uint256 public constant TOKEN_PRICE = 0.08 eth\n   uint public constant MAX_PURCHASE =\n   uint256 public constant MAX_TOTAL_SUPPLY = 100\n   string public provenanceHa\n   address public sign\n   mapping(string => bool) private usedNonc\n   bool public saleIsActive = fal\n   uint public presaleActiveUntil =\n   mapping(address => uint) private presaleAccessLi\n   mapping(address => uint) private presaleTokensClaim\n   address public omniFusionAddre\n   string public baseU\n   address payable public member1Addre\n   address payable public member2Addre\n   address payable public member3Addre","after":"   uint256 public constant TOKEN_PRICE = 0.08 eth\n   uint public constant MAX_PURCHASE =\n   uint256 public constant MAX_TOTAL_SUPPLY = 100\n   string public provenanceHa\n   mapping(string => bool) private usedNonc\n   uint public presaleActiveUntil =\n   mapping(address => uint) private presaleAccessLi\n   mapping(address => uint) private presaleTokensClaim\n   string public baseU\n   address public sign\n   address public omniFusionAddre\n   address payable public member1Addre\n   address payable public member2Addre\n   address payable public member3Addre\n   bool public saleIsActive = fal\n","contract":"Omnimorphs","time":0},{"type":"external-function ","before":"   function setBaseURI(string memory newBaseURI) external onlyOwner {\n        baseURI = newBaseURI;\n  ","after":"   function setBaseURI(string calldata newBaseURI) external onlyOwner {\n        baseURI = newBaseURI;\n  ","contract":"Omnimorphs","time":0},{"type":"external-function ","before":"   function setProvenanceHash(string memory hash) external onlyOwner {\n        provenanceHash = hash;\n  ","after":"   function setProvenanceHash(string calldata hash) external onlyOwner {\n        provenanceHash = hash;\n  ","contract":"Omnimorphs","time":0},{"type":"external-function ","before":"   function mintTokens(bytes32 hash, bytes memory signature, string memory nonce, uint numberOfTokens) external payable {\n        require(saleIsActive, \"Sale is not currently active\");\n        require(totalSupply() + numberOfTokens <= MAX_TOTAL_SUPPLY, \"Minting would exceed MAX_TOTAL_SUPPLY\");\n        require(numberOfTokens <= MAX_PURCHASE, \"Trying to mint too many tokens\");\n        require(numberOfTokens > 0, \"Number of tokens cannot be lower than, or equal to 0\");\n        require(TOKEN_PRICE * numberOfTokens == msg.value, \"Ether value sent is not correct\");\n        require(matchAddressSigner(hash, signature), \"Direct minting is not allowed\");\n        require(!usedNonces[nonce], \"Nonce was already used\");\n        require(hashTransaction(msg.sender, numberOfTokens, nonce) == hash, \"Hash mismatch\");\n\n        usedNonces[nonce] = true;\n        _mintTokens(numberOfTokens);\n  ","after":"   function mintTokens(bytes32 hash, bytes calldata signature, string calldata nonce, uint numberOfTokens) external payable {\n        require(saleIsActive, \"Sale is not currently active\");\n        require(totalSupply() + numberOfTokens <= MAX_TOTAL_SUPPLY, \"Minting would exceed MAX_TOTAL_SUPPLY\");\n        require(numberOfTokens <= MAX_PURCHASE, \"Trying to mint too many tokens\");\n        require(numberOfTokens > 0, \"Number of tokens cannot be lower than, or equal to 0\");\n        require(TOKEN_PRICE * numberOfTokens == msg.value, \"Ether value sent is not correct\");\n        require(matchAddressSigner(hash, signature), \"Direct minting is not allowed\");\n        require(!usedNonces[nonce], \"Nonce was already used\");\n        require(hashTransaction(msg.sender, numberOfTokens, nonce) == hash, \"Hash mismatch\");\n\n        usedNonces[nonce] = true;\n        _mintTokens(numberOfTokens);\n  ","contract":"Omnimorphs","time":0},{"type":"external-function ","before":"   function fuseTokens(uint toFuse, uint toBurn, bytes memory payload) external {\n        IOmniFusion(omniFusionAddress).fuseTokens(msg.sender, toFuse, toBurn, payload);\n        _burn(toBurn);\n  ","after":"   function fuseTokens(uint toFuse, uint toBurn, bytes calldata payload) external {\n        IOmniFusion(omniFusionAddress).fuseTokens(msg.sender, toFuse, toBurn, payload);\n        _burn(toBurn);\n  ","contract":"Omnimorphs","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"Omnimorphs","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"Omnimorphs","time":1}]}