{"time":258,"results":[{"type":"loop-duplication","before":"\nstart line 2105 column 8, end line 2109 column 8\nfor (uint256 i = 0; i < 2; i++) {\n            if (_reserveTokens[i] == NATIVE_TOKEN_ADDRESS) {\n                require(_reserveAmounts[i] == msg.value, \"ERR_ETH_AMOUNT_MISMATCH\");\n            }\n        }\nstart line 2147 column 8, end line 2169 column 8\nfor (uint256 i = 0; i < 2; i++) {\n            IERC20 reserveToken = _reserveTokens[i];\n            uint256 reserveAmount = reserveAmounts[i];\n            require(reserveAmount > 0, \"ERR_ZERO_TARGET_AMOUNT\");\n            assert(reserveAmount <= _reserveAmounts[i]);\n\n            // transfer each one of the reserve amounts from the user to the pool\n            if (reserveToken != NATIVE_TOKEN_ADDRESS) {\n                // ETH has already been transferred as part of the transaction\n                reserveToken.safeTransferFrom(msg.sender, address(this), reserveAmount);\n            } else if (_reserveAmounts[i] > reserveAmount) {\n                // transfer the extra amount of ETH back to the user\n                msg.sender.transfer(_reserveAmounts[i] - reserveAmount);\n            }\n\n            // save the new reserve balance\n            newReserveBalances[i] = prevReserveBalances[i].add(reserveAmount);\n\n            emit LiquidityAdded(msg.sender, reserveToken, reserveAmount, newReserveBalances[i], newPoolTokenSupply);\n\n            // dispatch the `TokenRateUpdate` event for the pool token\n            emit TokenRateUpdate(poolToken, reserveToken, newReserveBalances[i], newPoolTokenSupply);\n        }","after":"// merge loop\n\nstart line 2105 column 8, end line 2109 column 8\nfor (uint256 i = 0; i < 2; i++) {\n            if (_reserveTokens[i] == NATIVE_TOKEN_ADDRESS) {\n                require(_reserveAmounts[i] == msg.value, \"ERR_ETH_AMOUNT_MISMATCH\");\n            }\n        }\nstart line 2147 column 8, end line 2169 column 8\nfor (uint256 i = 0; i < 2; i++) {\n            IERC20 reserveToken = _reserveTokens[i];\n            uint256 reserveAmount = reserveAmounts[i];\n            require(reserveAmount > 0, \"ERR_ZERO_TARGET_AMOUNT\");\n            assert(reserveAmount <= _reserveAmounts[i]);\n\n            // transfer each one of the reserve amounts from the user to the pool\n            if (reserveToken != NATIVE_TOKEN_ADDRESS) {\n                // ETH has already been transferred as part of the transaction\n                reserveToken.safeTransferFrom(msg.sender, address(this), reserveAmount);\n            } else if (_reserveAmounts[i] > reserveAmount) {\n                // transfer the extra amount of ETH back to the user\n                msg.sender.transfer(_reserveAmounts[i] - reserveAmount);\n            }\n\n            // save the new reserve balance\n            newReserveBalances[i] = prevReserveBalances[i].add(reserveAmount);\n\n            emit LiquidityAdded(msg.sender, reserveToken, reserveAmount, newReserveBalances[i], newPoolTokenSupply);\n\n            // dispatch the `TokenRateUpdate` event for the pool token\n            emit TokenRateUpdate(poolToken, reserveToken, newReserveBalances[i], newPoolTokenSupply);\n        }","contract":"StandardPoolConverter","time":0},{"type":"external-function ","before":"function addLiquidity(\n        IERC20[] memory _reserveTokens,\n        uint256[] memory _reserveAmounts,\n        uint256 _minReturn\n    ) public payable protected active returns (uint256) {\n        // verify the user input\n        verifyLiquidityInput(_reserveTokens, _reserveAmounts, _minReturn);\n\n        // if one of the reserves is ETH, then verify that the input amount of ETH is equal to the input value of ETH\n        for (uint256 i = 0; i < 2; i++) {\n            if (_reserveTokens[i] == NATIVE_TOKEN_ADDRESS) {\n                require(_reserveAmounts[i] == msg.value, \"ERR_ETH_AMOUNT_MISMATCH\");\n            }\n        }\n\n        // if the input value of ETH is larger than zero, then verify that one of the reserves is ETH\n        if (msg.value > 0) {\n            require(__reserveIds[NATIVE_TOKEN_ADDRESS] != 0, \"ERR_NO_ETH_RESERVE\");\n        }\n\n        // save a local copy of the pool token\n        IDSToken poolToken = IDSToken(address(anchor));\n\n        // get the total supply\n        uint256 totalSupply = poolToken.totalSupply();\n\n        uint256[2] memory prevReserveBalances;\n        uint256[2] memory newReserveBalances;\n\n        // process the network fees and get the reserve balances\n        (prevReserveBalances[0], prevReserveBalances[1]) = processNetworkFees(msg.value);\n\n        uint256 amount;\n        uint256[2] memory reserveAmounts;\n\n        // calculate the amount of pool tokens to mint for the caller\n        // and the amount of reserve tokens to transfer from the caller\n        if (totalSupply == 0) {\n            amount = MathEx.geometricMean(_reserveAmounts);\n            reserveAmounts[0] = _reserveAmounts[0];\n            reserveAmounts[1] = _reserveAmounts[1];\n        } else {\n            (amount, reserveAmounts) = addLiquidityAmounts(\n                _reserveTokens,\n                _reserveAmounts,\n                prevReserveBalances,\n                totalSupply\n            );\n        }\n\n        uint256 newPoolTokenSupply = totalSupply.add(amount);\n        for (uint256 i = 0; i < 2; i++) {\n            IERC20 reserveToken = _reserveTokens[i];\n            uint256 reserveAmount = reserveAmounts[i];\n            require(reserveAmount > 0, \"ERR_ZERO_TARGET_AMOUNT\");\n            assert(reserveAmount <= _reserveAmounts[i]);\n\n            // transfer each one of the reserve amounts from the user to the pool\n            if (reserveToken != NATIVE_TOKEN_ADDRESS) {\n                // ETH has already been transferred as part of the transaction\n                reserveToken.safeTransferFrom(msg.sender, address(this), reserveAmount);\n            } else if (_reserveAmounts[i] > reserveAmount) {\n                // transfer the extra amount of ETH back to the user\n                msg.sender.transfer(_reserveAmounts[i] - reserveAmount);\n            }\n\n            // save the new reserve balance\n            newReserveBalances[i] = prevReserveBalances[i].add(reserveAmount);\n\n            emit LiquidityAdded(msg.sender, reserveToken, reserveAmount, newReserveBalances[i], newPoolTokenSupply);\n\n            // dispatch the `TokenRateUpdate` event for the pool token\n            emit TokenRateUpdate(poolToken, reserveToken, newReserveBalances[i], newPoolTokenSupply);\n        }\n\n        // set the reserve balances\n        setReserveBalances(1, 2, newReserveBalances[0], newReserveBalances[1]);\n\n        // set the reserve balances product\n        _reserveBalancesProduct = newReserveBalances[0] * newReserveBalances[1];\n\n        // verify that the equivalent amount of tokens is equal to or larger than the user's expectation\n        require(amount >= _minReturn, \"ERR_RETURN_TOO_LOW\");\n\n        // issue the tokens to the user\n        poolToken.issue(msg.sender, amount);\n\n        // return the amount of pool tokens issued\n        return amount;\n    }","after":"function addLiquidity(\n        IERC20[] calldata _reserveTokens,\n        uint256[] calldata _reserveAmounts,\n        uint256 _minReturn\n    ) public payable protected active returns (uint256) {\n        // verify the user input\n        verifyLiquidityInput(_reserveTokens, _reserveAmounts, _minReturn);\n\n        // if one of the reserves is ETH, then verify that the input amount of ETH is equal to the input value of ETH\n        for (uint256 i = 0; i < 2; i++) {\n            if (_reserveTokens[i] == NATIVE_TOKEN_ADDRESS) {\n                require(_reserveAmounts[i] == msg.value, \"ERR_ETH_AMOUNT_MISMATCH\");\n            }\n        }\n\n        // if the input value of ETH is larger than zero, then verify that one of the reserves is ETH\n        if (msg.value > 0) {\n            require(__reserveIds[NATIVE_TOKEN_ADDRESS] != 0, \"ERR_NO_ETH_RESERVE\");\n        }\n\n        // save a local copy of the pool token\n        IDSToken poolToken = IDSToken(address(anchor));\n\n        // get the total supply\n        uint256 totalSupply = poolToken.totalSupply();\n\n        uint256[2] memory prevReserveBalances;\n        uint256[2] memory newReserveBalances;\n\n        // process the network fees and get the reserve balances\n        (prevReserveBalances[0], prevReserveBalances[1]) = processNetworkFees(msg.value);\n\n        uint256 amount;\n        uint256[2] memory reserveAmounts;\n\n        // calculate the amount of pool tokens to mint for the caller\n        // and the amount of reserve tokens to transfer from the caller\n        if (totalSupply == 0) {\n            amount = MathEx.geometricMean(_reserveAmounts);\n            reserveAmounts[0] = _reserveAmounts[0];\n            reserveAmounts[1] = _reserveAmounts[1];\n        } else {\n            (amount, reserveAmounts) = addLiquidityAmounts(\n                _reserveTokens,\n                _reserveAmounts,\n                prevReserveBalances,\n                totalSupply\n            );\n        }\n\n        uint256 newPoolTokenSupply = totalSupply.add(amount);\n        for (uint256 i = 0; i < 2; i++) {\n            IERC20 reserveToken = _reserveTokens[i];\n            uint256 reserveAmount = reserveAmounts[i];\n            require(reserveAmount > 0, \"ERR_ZERO_TARGET_AMOUNT\");\n            assert(reserveAmount <= _reserveAmounts[i]);\n\n            // transfer each one of the reserve amounts from the user to the pool\n            if (reserveToken != NATIVE_TOKEN_ADDRESS) {\n                // ETH has already been transferred as part of the transaction\n                reserveToken.safeTransferFrom(msg.sender, address(this), reserveAmount);\n            } else if (_reserveAmounts[i] > reserveAmount) {\n                // transfer the extra amount of ETH back to the user\n                msg.sender.transfer(_reserveAmounts[i] - reserveAmount);\n            }\n\n            // save the new reserve balance\n            newReserveBalances[i] = prevReserveBalances[i].add(reserveAmount);\n\n            emit LiquidityAdded(msg.sender, reserveToken, reserveAmount, newReserveBalances[i], newPoolTokenSupply);\n\n            // dispatch the `TokenRateUpdate` event for the pool token\n            emit TokenRateUpdate(poolToken, reserveToken, newReserveBalances[i], newPoolTokenSupply);\n        }\n\n        // set the reserve balances\n        setReserveBalances(1, 2, newReserveBalances[0], newReserveBalances[1]);\n\n        // set the reserve balances product\n        _reserveBalancesProduct = newReserveBalances[0] * newReserveBalances[1];\n\n        // verify that the equivalent amount of tokens is equal to or larger than the user's expectation\n        require(amount >= _minReturn, \"ERR_RETURN_TOO_LOW\");\n\n        // issue the tokens to the user\n        poolToken.issue(msg.sender, amount);\n\n        // return the amount of pool tokens issued\n        return amount;\n    }","contract":"StandardPoolConverter","time":0},{"type":"external-function ","before":"function removeLiquidity(\n        uint256 _amount,\n        IERC20[] memory _reserveTokens,\n        uint256[] memory _reserveMinReturnAmounts\n    ) public protected active returns (uint256[] memory) {\n        // verify the user input\n        bool inputRearranged = verifyLiquidityInput(_reserveTokens, _reserveMinReturnAmounts, _amount);\n\n        // save a local copy of the pool token\n        IDSToken poolToken = IDSToken(address(anchor));\n\n        // get the total supply BEFORE destroying the user tokens\n        uint256 totalSupply = poolToken.totalSupply();\n\n        // destroy the user tokens\n        poolToken.destroy(msg.sender, _amount);\n\n        uint256 newPoolTokenSupply = totalSupply.sub(_amount);\n\n        uint256[2] memory prevReserveBalances;\n        uint256[2] memory newReserveBalances;\n\n        // process the network fees and get the reserve balances\n        (prevReserveBalances[0], prevReserveBalances[1]) = processNetworkFees(0);\n\n        uint256[] memory reserveAmounts = removeLiquidityReserveAmounts(_amount, totalSupply, prevReserveBalances);\n\n        for (uint256 i = 0; i < 2; i++) {\n            IERC20 reserveToken = _reserveTokens[i];\n            uint256 reserveAmount = reserveAmounts[i];\n            require(reserveAmount >= _reserveMinReturnAmounts[i], \"ERR_ZERO_TARGET_AMOUNT\");\n\n            // save the new reserve balance\n            newReserveBalances[i] = prevReserveBalances[i].sub(reserveAmount);\n\n            // transfer each one of the reserve amounts from the pool to the user\n            safeTransfer(reserveToken, msg.sender, reserveAmount);\n\n            emit LiquidityRemoved(msg.sender, reserveToken, reserveAmount, newReserveBalances[i], newPoolTokenSupply);\n\n            // dispatch the `TokenRateUpdate` event for the pool token\n            emit TokenRateUpdate(poolToken, reserveToken, newReserveBalances[i], newPoolTokenSupply);\n        }\n\n        // set the reserve balances\n        setReserveBalances(1, 2, newReserveBalances[0], newReserveBalances[1]);\n\n        // set the reserve balances product\n        _reserveBalancesProduct = newReserveBalances[0] * newReserveBalances[1];\n\n        if (inputRearranged) {\n            uint256 tempReserveAmount = reserveAmounts[0];\n            reserveAmounts[0] = reserveAmounts[1];\n            reserveAmounts[1] = tempReserveAmount;\n        }\n\n        // return the amount of each reserve token granted for the given amount of pool tokens\n        return reserveAmounts;\n    }","after":"function removeLiquidity(\n        uint256 _amount,\n        IERC20[] calldata _reserveTokens,\n        uint256[] calldata _reserveMinReturnAmounts\n    ) public protected active returns (uint256[] memory) {\n        // verify the user input\n        bool inputRearranged = verifyLiquidityInput(_reserveTokens, _reserveMinReturnAmounts, _amount);\n\n        // save a local copy of the pool token\n        IDSToken poolToken = IDSToken(address(anchor));\n\n        // get the total supply BEFORE destroying the user tokens\n        uint256 totalSupply = poolToken.totalSupply();\n\n        // destroy the user tokens\n        poolToken.destroy(msg.sender, _amount);\n\n        uint256 newPoolTokenSupply = totalSupply.sub(_amount);\n\n        uint256[2] memory prevReserveBalances;\n        uint256[2] memory newReserveBalances;\n\n        // process the network fees and get the reserve balances\n        (prevReserveBalances[0], prevReserveBalances[1]) = processNetworkFees(0);\n\n        uint256[] memory reserveAmounts = removeLiquidityReserveAmounts(_amount, totalSupply, prevReserveBalances);\n\n        for (uint256 i = 0; i < 2; i++) {\n            IERC20 reserveToken = _reserveTokens[i];\n            uint256 reserveAmount = reserveAmounts[i];\n            require(reserveAmount >= _reserveMinReturnAmounts[i], \"ERR_ZERO_TARGET_AMOUNT\");\n\n            // save the new reserve balance\n            newReserveBalances[i] = prevReserveBalances[i].sub(reserveAmount);\n\n            // transfer each one of the reserve amounts from the pool to the user\n            safeTransfer(reserveToken, msg.sender, reserveAmount);\n\n            emit LiquidityRemoved(msg.sender, reserveToken, reserveAmount, newReserveBalances[i], newPoolTokenSupply);\n\n            // dispatch the `TokenRateUpdate` event for the pool token\n            emit TokenRateUpdate(poolToken, reserveToken, newReserveBalances[i], newPoolTokenSupply);\n        }\n\n        // set the reserve balances\n        setReserveBalances(1, 2, newReserveBalances[0], newReserveBalances[1]);\n\n        // set the reserve balances product\n        _reserveBalancesProduct = newReserveBalances[0] * newReserveBalances[1];\n\n        if (inputRearranged) {\n            uint256 tempReserveAmount = reserveAmounts[0];\n            reserveAmounts[0] = reserveAmounts[1];\n            reserveAmounts[1] = tempReserveAmount;\n        }\n\n        // return the amount of each reserve token granted for the given amount of pool tokens\n        return reserveAmounts;\n    }","contract":"StandardPoolConverter","time":0},{"type":"external-function ","before":"function addLiquidityCost(\n        IERC20[] memory _reserveTokens,\n        uint256 _reserveTokenIndex,\n        uint256 _reserveAmount\n    ) public view returns (uint256[] memory) {\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\n        uint256[2] memory baseBalances = baseReserveBalances(_reserveTokens);\n        uint256 amount = fundSupplyAmount(totalSupply, baseBalances[_reserveTokenIndex], _reserveAmount);\n\n        uint256[] memory reserveAmounts = new uint256[](2);\n        reserveAmounts[0] = fundCost(totalSupply, baseBalances[0], amount);\n        reserveAmounts[1] = fundCost(totalSupply, baseBalances[1], amount);\n        return reserveAmounts;\n    }","after":"function addLiquidityCost(\n        IERC20[] calldata _reserveTokens,\n        uint256 _reserveTokenIndex,\n        uint256 _reserveAmount\n    ) public view returns (uint256[] memory) {\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\n        uint256[2] memory baseBalances = baseReserveBalances(_reserveTokens);\n        uint256 amount = fundSupplyAmount(totalSupply, baseBalances[_reserveTokenIndex], _reserveAmount);\n\n        uint256[] memory reserveAmounts = new uint256[](2);\n        reserveAmounts[0] = fundCost(totalSupply, baseBalances[0], amount);\n        reserveAmounts[1] = fundCost(totalSupply, baseBalances[1], amount);\n        return reserveAmounts;\n    }","contract":"StandardPoolConverter","time":1},{"type":"external-function ","before":"function addLiquidityReturn(IERC20[] memory _reserveTokens, uint256[] memory _reserveAmounts)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\n        uint256[2] memory baseBalances = baseReserveBalances(_reserveTokens);\n        (uint256 amount,) = addLiquidityAmounts(_reserveTokens, _reserveAmounts, baseBalances, totalSupply);\n        return amount;\n    }","after":"function addLiquidityReturn(IERC20[] calldata _reserveTokens, uint256[] calldata _reserveAmounts)\n    public\n    view\n    returns (uint256)\n    {\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\n        uint256[2] memory baseBalances = baseReserveBalances(_reserveTokens);\n        (uint256 amount,) = addLiquidityAmounts(_reserveTokens, _reserveAmounts, baseBalances, totalSupply);\n        return amount;\n    }","contract":"StandardPoolConverter","time":0},{"type":"external-function ","before":"function removeLiquidityReturn(uint256 _amount, IERC20[] memory _reserveTokens)\n    public\n    view\n    returns (uint256[] memory)\n    {\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\n        uint256[2] memory baseBalances = baseReserveBalances(_reserveTokens);\n        return removeLiquidityReserveAmounts(_amount, totalSupply, baseBalances);\n    }","after":"function removeLiquidityReturn(uint256 _amount, IERC20[] calldata _reserveTokens)\n    public\n    view\n    returns (uint256[] memory)\n    {\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\n        uint256[2] memory baseBalances = baseReserveBalances(_reserveTokens);\n        return removeLiquidityReserveAmounts(_amount, totalSupply, baseBalances);\n    }","contract":"StandardPoolConverter","time":0},{"type":"immutable-restrict-modification ","before":"uint32 public override maxConversionFee;","after":"uint32 public override immutable maxConversionFee;","contract":"StandardPoolConverter","time":1}]}