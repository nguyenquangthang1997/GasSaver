{"time":611,"results":[{"type":"external-function ","before":"function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\n\n        _name = name;\n\n        _symbol = symbol;\n\n        _decimals = decimals;\n\n    }","after":"function initialize(string calldata name, string calldata symbol, uint8 decimals) public initializer {\n\n        _name = name;\n\n        _symbol = symbol;\n\n        _decimals = decimals;\n\n    }","contract":"RariFundToken","time":0},{"type":"struct-data-arrangement ","before":"\n  address ad\n  BassetStatus stat\n  bool isTransferFeeCharg\n  uint256 rat\n  uint256 maxWeig\n  uint256 vaultBalan","after":"  BassetStatus stat\n  uint256 rat\n  uint256 maxWeig\n  uint256 vaultBalan\n  address ad\n  bool isTransferFeeCharg\n","contract":"MassetStructs","time":0},{"type":"loop-duplication","before":"\nstart line 4718 column 8, end line 4718 column 129\n    for (uint256 i = 0; i < _supportedCurrencies.length; i++) if (_acceptedCurrencies[_supportedCurrencies[i]]) arrayLengt\nstart line 4725 column 8, end line 4731 column 8\n    for (uint256 i = 0; i < _supportedCurrencies.length; i++) if (_acceptedCurrencies[_supportedCurrencies[i]]) {\n\n            acceptedCurrencies[index] = _supportedCurrencies[i];\n\n            index++;\n\n     ","after":"// merge loop\n\nstart line 4718 column 8, end line 4718 column 129\n    for (uint256 i = 0; i < _supportedCurrencies.length; i++) if (_acceptedCurrencies[_supportedCurrencies[i]]) arrayLengt\nstart line 4725 column 8, end line 4731 column 8\n    for (uint256 i = 0; i < _supportedCurrencies.length; i++) if (_acceptedCurrencies[_supportedCurrencies[i]]) {\n\n            acceptedCurrencies[index] = _supportedCurrencies[i];\n\n            index++;\n\n     ","contract":"RariFundManager","time":0},{"type":"constant-restrict-modification  ","before":"    uint256 private _accountBalanceLimitDefa","after":"    uint256 private _accountBalanceLimitDefa","contract":"RariFundManager","time":0},{"type":"constant-restrict-modification  ","before":"{\n\n    uint256 public exchan","after":"{\n\n    uint256 public exchan","contract":"ISavingsContract","time":0},{"type":"external-function ","before":" */\n\n    function marketSellOrdersFillOrKill(LibOrder.Order[] memory orders, bytes[] memory signatures, uint256 takerAssetFillAmount, uint256 protocolFee) public returns (uint256[2] memory) {\n\n        require(orders.length > 0, \"At least one order and matching signature is required.\");\n\n        require(orders.length == signatures.length, \"Mismatch between number of orders and signatures.\");\n\n        require(takerAssetFillAmount > 0, \"Taker asset fill amount must be greater than 0.\");\n\n        LibFillResults.FillResults memory fillResults = _exchange.marketSellOrdersFillOrKill.value(protocolFee)(orders, takerAssetFillAmount, signatures);\n\n        return [fillResults.takerAssetFilledAmount, fillResults.makerAssetFilledAmount","after":" */\n\n    function marketSellOrdersFillOrKill(LibOrder.Order[] calldata orders, bytes[] calldata signatures, uint256 takerAssetFillAmount, uint256 protocolFee) public returns (uint256[2] memory) {\n\n        require(orders.length > 0, \"At least one order and matching signature is required.\");\n\n        require(orders.length == signatures.length, \"Mismatch between number of orders and signatures.\");\n\n        require(takerAssetFillAmount > 0, \"Taker asset fill amount must be greater than 0.\");\n\n        LibFillResults.FillResults memory fillResults = _exchange.marketSellOrdersFillOrKill.value(protocolFee)(orders, takerAssetFillAmount, signatures);\n\n        return [fillResults.takerAssetFilledAmount, fillResults.makerAssetFilledAmount","contract":"ZeroExExchangeController","time":0},{"type":"external-function ","before":" */\n\n    function marketBuyOrdersFillOrKill(LibOrder.Order[] memory orders, bytes[] memory signatures, uint256 makerAssetFillAmount, uint256 protocolFee) public returns (uint256[2] memory) {\n\n        require(orders.length > 0, \"At least one order and matching signature is required.\");\n\n        require(orders.length == signatures.length, \"Mismatch between number of orders and signatures.\");\n\n        require(makerAssetFillAmount > 0, \"Maker asset fill amount must be greater than 0.\");\n\n        LibFillResults.FillResults memory fillResults = _exchange.marketBuyOrdersFillOrKill.value(protocolFee)(orders, makerAssetFillAmount, signatures);\n\n        return [fillResults.takerAssetFilledAmount, fillResults.makerAssetFilledAmount","after":" */\n\n    function marketBuyOrdersFillOrKill(LibOrder.Order[] calldata orders, bytes[] calldata signatures, uint256 makerAssetFillAmount, uint256 protocolFee) public returns (uint256[2] memory) {\n\n        require(orders.length > 0, \"At least one order and matching signature is required.\");\n\n        require(orders.length == signatures.length, \"Mismatch between number of orders and signatures.\");\n\n        require(makerAssetFillAmount > 0, \"Maker asset fill amount must be greater than 0.\");\n\n        LibFillResults.FillResults memory fillResults = _exchange.marketBuyOrdersFillOrKill.value(protocolFee)(orders, makerAssetFillAmount, signatures);\n\n        return [fillResults.takerAssetFilledAmount, fillResults.makerAssetFilledAmount","contract":"ZeroExExchangeController","time":0},{"type":"state-data-arrangement ","before":"\n   */\n\n    bool public constant IS_RARI_FUND_CONTROL\n   */\n\n    bool private _fu\n   */\n\n    address private _rariFundManag\n   */\n\n    RariFundManager public rariF\n   */\n\n    address private _rariFundRebalan\n   */\n\n    string[] private _supported\n   */\n\n    mapping(string => uint8) private _curre\n   */\n\n    mapping(string => uint256) private _curren\n   */\n\n    mapping(string => address) private _erc2\n   */\n\n    mapping(string => LiquidityPool[]) private _pools\n   */\n\n    mapping(string => mapping(uint8 => bool)) _pool\n   */\n\n    uint16 _aaveRe\n   */\n\n    uint256 private _dailyLos\n   */\n\n    CurrencyExchangeLoss[] private _lossR","after":"   */\n\n    RariFundManager public rariF\n   */\n\n    string[] private _supported\n   */\n\n    mapping(string => uint8) private _curre\n   */\n\n    mapping(string => uint256) private _curren\n   */\n\n    mapping(string => address) private _erc2\n   */\n\n    mapping(string => LiquidityPool[]) private _pools\n   */\n\n    mapping(string => mapping(uint8 => bool)) _pool\n   */\n\n    uint256 private _dailyLos\n   */\n\n    CurrencyExchangeLoss[] private _lossR\n   */\n\n    address private _rariFundManag\n   */\n\n    address private _rariFundRebalan\n   */\n\n    uint16 _aaveRe\n   */\n\n    bool public constant IS_RARI_FUND_CONTROL\n   */\n\n    bool private _fu\n","contract":"RariFundController","time":0},{"type":"external-function ","before":"   */\n\n    function getPoolBalance(LiquidityPool pool, string memory currencyCode) public returns (uint256) {\n\n        if (!_poolsWithFunds[currencyCode][uint8(pool)]) return 0;\n\n        return _getPoolBalance(pool, currencyCo","after":"   */\n\n    function getPoolBalance(LiquidityPool pool, string calldata currencyCode) public returns (uint256) {\n\n        if (!_poolsWithFunds[currencyCode][uint8(pool)]) return 0;\n\n        return _getPoolBalance(pool, currencyCo","contract":"RariFundController","time":0},{"type":"external-function ","before":"   */\n\n    function marketSell0xOrdersFillOrKill(string memory inputCurrencyCode, string memory outputCurrencyCode, LibOrder.Order[] memory orders, bytes[] memory signatures, uint256 takerAssetFillAmount) public payable fundEnabled onlyRebalancer {\n\n        // Check if input is a supported stablecoin and make sure output is a supported stablecoin\n\n        address inputErc20Contract = _erc20Contracts[inputCurrencyCode];\n\n        address outputErc20Contract = _erc20Contracts[outputCurrencyCode];\n\n        require(outputErc20Contract != address(0), \"Invalid output currency code.\");\n\n\n        // Check orders (if inputting a supported stablecoin)\n\n        if (inputErc20Contract != address(0)) for (uint256 i = 0; i < orders.length; i++) {\n\n            address takerAssetAddress = ZeroExExchangeController.decodeTokenAddress(orders[i].takerAssetData);\n\n            require(inputErc20Contract == takerAssetAddress, \"Not all input assets correspond to input currency code.\");\n\n            address makerAssetAddress = ZeroExExchangeController.decodeTokenAddress(orders[i].makerAssetData);\n\n            require(outputErc20Contract == makerAssetAddress, \"Not all output assets correspond to output currency code.\");\n\n            if (orders[i].takerFee > 0) require(orders[i].takerFeeAssetData.length == 0, \"Taker fees are not supported.\");\n            // TODO: Support orders with taker fees (need to include taker fees in loss calculation)\n\n        }\n\n\n        // Get prices and raw fund balance before exchange\n\n        uint256[] memory pricesInUsd;\n\n        uint256 rawFundBalanceBeforeExchange;\n\n\n        if (inputErc20Contract != address(0)) {\n\n            pricesInUsd = rariFundManager.rariFundPriceConsumer().getCurrencyPricesInUsd();\n\n            rawFundBalanceBeforeExchange = rariFundManager.getRawFundBalance(pricesInUsd);\n\n        }\n\n\n        // Market sell\n\n        uint256[2] memory filledAmounts = ZeroExExchangeController.marketSellOrdersFillOrKill(orders, signatures, takerAssetFillAmount, msg.value);\n\n\n        // Check 24-hour loss rate limit (if inputting a supported stablecoin)\n\n        uint256 inputFilledAmountUsd = 0;\n\n        uint256 outputFilledAmountUsd = 0;\n\n\n        if (inputErc20Contract != address(0)) {\n\n            inputFilledAmountUsd = toUsd(inputCurrencyCode, filledAmounts[0], pricesInUsd);\n\n            outputFilledAmountUsd = toUsd(outputCurrencyCode, filledAmounts[1], pricesInUsd);\n\n            handleExchangeLoss(inputFilledAmountUsd, outputFilledAmountUsd, rawFundBalanceBeforeExchange);\n\n        }\n\n\n        // Emit event\n\n        emit CurrencyTrade(inputCurrencyCode, outputCurrencyCode, filledAmounts[0], inputFilledAmountUsd, filledAmounts[1], outputFilledAmountUsd, CurrencyExchange.ZeroEx);\n\n\n        // Refund unused ETH\n\n        uint256 ethBalance = address(this).balance;\n\n\n        if (ethBalance > 0) {\n\n            (bool success,) = msg.sender.call.value(ethBalance)(\"\");\n\n            require(success, \"Failed to transfer ETH to msg.sender after exchange.\");\n\n     ","after":"   */\n\n    function marketSell0xOrdersFillOrKill(string calldata inputCurrencyCode, string calldata outputCurrencyCode, LibOrder.Order[] calldata orders, bytes[] calldata signatures, uint256 takerAssetFillAmount) public payable fundEnabled onlyRebalancer {\n\n        // Check if input is a supported stablecoin and make sure output is a supported stablecoin\n\n        address inputErc20Contract = _erc20Contracts[inputCurrencyCode];\n\n        address outputErc20Contract = _erc20Contracts[outputCurrencyCode];\n\n        require(outputErc20Contract != address(0), \"Invalid output currency code.\");\n\n\n        // Check orders (if inputting a supported stablecoin)\n\n        if (inputErc20Contract != address(0)) for (uint256 i = 0; i < orders.length; i++) {\n\n            address takerAssetAddress = ZeroExExchangeController.decodeTokenAddress(orders[i].takerAssetData);\n\n            require(inputErc20Contract == takerAssetAddress, \"Not all input assets correspond to input currency code.\");\n\n            address makerAssetAddress = ZeroExExchangeController.decodeTokenAddress(orders[i].makerAssetData);\n\n            require(outputErc20Contract == makerAssetAddress, \"Not all output assets correspond to output currency code.\");\n\n            if (orders[i].takerFee > 0) require(orders[i].takerFeeAssetData.length == 0, \"Taker fees are not supported.\");\n            // TODO: Support orders with taker fees (need to include taker fees in loss calculation)\n\n        }\n\n\n        // Get prices and raw fund balance before exchange\n\n        uint256[] memory pricesInUsd;\n\n        uint256 rawFundBalanceBeforeExchange;\n\n\n        if (inputErc20Contract != address(0)) {\n\n            pricesInUsd = rariFundManager.rariFundPriceConsumer().getCurrencyPricesInUsd();\n\n            rawFundBalanceBeforeExchange = rariFundManager.getRawFundBalance(pricesInUsd);\n\n        }\n\n\n        // Market sell\n\n        uint256[2] memory filledAmounts = ZeroExExchangeController.marketSellOrdersFillOrKill(orders, signatures, takerAssetFillAmount, msg.value);\n\n\n        // Check 24-hour loss rate limit (if inputting a supported stablecoin)\n\n        uint256 inputFilledAmountUsd = 0;\n\n        uint256 outputFilledAmountUsd = 0;\n\n\n        if (inputErc20Contract != address(0)) {\n\n            inputFilledAmountUsd = toUsd(inputCurrencyCode, filledAmounts[0], pricesInUsd);\n\n            outputFilledAmountUsd = toUsd(outputCurrencyCode, filledAmounts[1], pricesInUsd);\n\n            handleExchangeLoss(inputFilledAmountUsd, outputFilledAmountUsd, rawFundBalanceBeforeExchange);\n\n        }\n\n\n        // Emit event\n\n        emit CurrencyTrade(inputCurrencyCode, outputCurrencyCode, filledAmounts[0], inputFilledAmountUsd, filledAmounts[1], outputFilledAmountUsd, CurrencyExchange.ZeroEx);\n\n\n        // Refund unused ETH\n\n        uint256 ethBalance = address(this).balance;\n\n\n        if (ethBalance > 0) {\n\n            (bool success,) = msg.sender.call.value(ethBalance)(\"\");\n\n            require(success, \"Failed to transfer ETH to msg.sender after exchange.\");\n\n     ","contract":"RariFundController","time":0}]}