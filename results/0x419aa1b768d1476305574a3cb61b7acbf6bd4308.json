{"time":220,"results":[{"type":"loop-duplication","before":"\nstart line 458 column 8, end line 470 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            uint256 e = A[i];\n\n            if (!contains(B, e)) {\n\n                includeMap[i] = true;\n\n                count++;\n\n            }\n\n    \nstart line 478 column 8, end line 490 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            if (includeMap[i]) {\n\n                newUints[j] = A[i];\n\n                newUintsIdxs[j] = i;\n\n                j++;\n\n            }\n\n    ","after":"// merge loop\n\nstart line 458 column 8, end line 470 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            uint256 e = A[i];\n\n            if (!contains(B, e)) {\n\n                includeMap[i] = true;\n\n                count++;\n\n            }\n\n    \nstart line 478 column 8, end line 490 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            if (includeMap[i]) {\n\n                newUints[j] = A[i];\n\n                newUintsIdxs[j] = i;\n\n                j++;\n\n            }\n\n    ","contract":"UintArray","time":0},{"type":"loop-duplication","before":"\nstart line 505 column 8, end line 515 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            if (contains(B, A[i])) {\n\n                includeMap[i] = true;\n\n                newLength++;\n\n            }\n\n    \nstart line 525 column 8, end line 539 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            if (includeMap[i]) {\n\n                newUints[j] = A[i];\n\n                newUintsAIdxs[j] = i;\n\n                (newUintsBIdxs[j],) = indexOf(B, A[i]);\n\n                j++;\n\n            }\n\n    ","after":"// merge loop\n\nstart line 505 column 8, end line 515 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            if (contains(B, A[i])) {\n\n                includeMap[i] = true;\n\n                newLength++;\n\n            }\n\n    \nstart line 525 column 8, end line 539 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            if (includeMap[i]) {\n\n                newUints[j] = A[i];\n\n                newUintsAIdxs[j] = i;\n\n                (newUintsBIdxs[j],) = indexOf(B, A[i]);\n\n                j++;\n\n            }\n\n    ","contract":"UintArray","time":0},{"type":"immutable-restrict-modification ","before":"\n    address public initial","after":"\n    address public initial","contract":"Registry","time":0},{"type":"external-function ","before":"\n    function compose(uint256[] memory _tokenIds, uint256[] memory _tokenRatio, uint256 _quantity) public {\n\n        require(_tokenIds.length == _tokenRatio.length, \"TOKEN_MINTER:TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n\n            _burn(msg.sender, _tokenIds[i], _tokenRatio[i].mul(_quantity));\n\n        }\n\n\n        uint256 portfolioId = uint256(keccak256(abi.encodePacked(\n\n                _tokenIds,\n\n                _tokenRatio\n\n            )));\n\n\n        _registerPortfolio(portfolioId, _tokenIds, _tokenRatio);\n\n        _mint(portfolioId, msg.sender, _quantity);\n\n","after":"\n    function compose(uint256[] calldata _tokenIds, uint256[] calldata _tokenRatio, uint256 _quantity) public {\n\n        require(_tokenIds.length == _tokenRatio.length, \"TOKEN_MINTER:TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n\n            _burn(msg.sender, _tokenIds[i], _tokenRatio[i].mul(_quantity));\n\n        }\n\n\n        uint256 portfolioId = uint256(keccak256(abi.encodePacked(\n\n                _tokenIds,\n\n                _tokenRatio\n\n            )));\n\n\n        _registerPortfolio(portfolioId, _tokenIds, _tokenRatio);\n\n        _mint(portfolioId, msg.sender, _quantity);\n\n","contract":"TokenMinter","time":0},{"type":"external-function ","before":"\n    function decompose(uint256 _portfolioId, uint256[] memory _tokenIds, uint256[] memory _tokenRatio, uint256 _quantity) public {\n\n        require(_tokenIds.length == _tokenRatio.length, \"TOKEN_MINTER:TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n\n        uint256 portfolioId = uint256(keccak256(abi.encodePacked(\n\n                _tokenIds,\n\n                _tokenRatio\n\n            )));\n\n\n        require(portfolioId == _portfolioId, \"TOKEN_MINTER:WRONG_PORTFOLIO_ID\");\n\n        _burn(msg.sender, _portfolioId, _quantity);\n\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n\n            _mint(_tokenIds[i], msg.sender, _tokenRatio[i].mul(_quantity));\n\n        }\n\n","after":"\n    function decompose(uint256 _portfolioId, uint256[] calldata _tokenIds, uint256[] calldata _tokenRatio, uint256 _quantity) public {\n\n        require(_tokenIds.length == _tokenRatio.length, \"TOKEN_MINTER:TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n\n        uint256 portfolioId = uint256(keccak256(abi.encodePacked(\n\n                _tokenIds,\n\n                _tokenRatio\n\n            )));\n\n\n        require(portfolioId == _portfolioId, \"TOKEN_MINTER:WRONG_PORTFOLIO_ID\");\n\n        _burn(msg.sender, _portfolioId, _quantity);\n\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n\n            _mint(_tokenIds[i], msg.sender, _tokenRatio[i].mul(_quantity));\n\n        }\n\n","contract":"TokenMinter","time":1},{"type":"external-function ","before":"\n    function recompose(\n\n        uint256 _portfolioId,\n\n        uint256[] memory _initialTokenIds,\n\n        uint256[] memory _initialTokenRatio,\n\n        uint256[] memory _finalTokenIds,\n\n        uint256[] memory _finalTokenRatio,\n\n        uint256 _quantity\n\n    ) public {\n\n        require(_initialTokenIds.length == _initialTokenRatio.length, \"TOKEN_MINTER:INITIAL_TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_finalTokenIds.length == _finalTokenRatio.length, \"TOKEN_MINTER:FINAL_TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_initialTokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_finalTokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_initialTokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n        require(_finalTokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n\n        uint256 oldPortfolioId = uint256(keccak256(abi.encodePacked(\n\n                _initialTokenIds,\n\n                _initialTokenRatio\n\n            )));\n\n\n        require(oldPortfolioId == _portfolioId, \"TOKEN_MINTER:WRONG_PORTFOLIO_ID\");\n\n        _burn(msg.sender, _portfolioId, _quantity);\n\n\n        _removedIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n\n        _addedIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n\n        _keptIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n\n\n        uint256 newPortfolioId = uint256(keccak256(abi.encodePacked(\n\n                _finalTokenIds,\n\n                _finalTokenRatio\n\n            )));\n\n\n        _registerPortfolio(newPortfolioId, _finalTokenIds, _finalTokenRatio);\n\n        _mint(newPortfolioId, msg.sender, _quantity);\n\n","after":"\n    function recompose(\n\n        uint256 _portfolioId,\n\n        uint256[] calldata _initialTokenIds,\n\n        uint256[] calldata _initialTokenRatio,\n\n        uint256[] calldata _finalTokenIds,\n\n        uint256[] calldata _finalTokenRatio,\n\n        uint256 _quantity\n\n    ) public {\n\n        require(_initialTokenIds.length == _initialTokenRatio.length, \"TOKEN_MINTER:INITIAL_TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_finalTokenIds.length == _finalTokenRatio.length, \"TOKEN_MINTER:FINAL_TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_initialTokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_finalTokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_initialTokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n        require(_finalTokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n\n        uint256 oldPortfolioId = uint256(keccak256(abi.encodePacked(\n\n                _initialTokenIds,\n\n                _initialTokenRatio\n\n            )));\n\n\n        require(oldPortfolioId == _portfolioId, \"TOKEN_MINTER:WRONG_PORTFOLIO_ID\");\n\n        _burn(msg.sender, _portfolioId, _quantity);\n\n\n        _removedIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n\n        _addedIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n\n        _keptIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n\n\n        uint256 newPortfolioId = uint256(keccak256(abi.encodePacked(\n\n                _finalTokenIds,\n\n                _finalTokenRatio\n\n            )));\n\n\n        _registerPortfolio(newPortfolioId, _finalTokenIds, _finalTokenRatio);\n\n        _mint(newPortfolioId, msg.sender, _quantity);\n\n","contract":"TokenMinter","time":0},{"type":"external-function ","before":"\n    function batchTransferFrom(address _from, address _to, uint256[] memory _tokenIds, uint256[] memory _amounts) public {\n\n        // Batch Transfering\n\n        _batchTransferFrom(_from, _to, _tokenIds, _amounts);\n\n","after":"\n    function batchTransferFrom(address _from, address _to, uint256[] calldata _tokenIds, uint256[] calldata _amounts) public {\n\n        // Batch Transfering\n\n        _batchTransferFrom(_from, _to, _tokenIds, _amounts);\n\n","contract":"TokenMinter","time":0},{"type":"immutable-restrict-modification ","before":"\n    string internal baseToke","after":"\n    string internal baseToke","contract":"TokenMinter","time":0},{"type":"immutable-restrict-modification ","before":"\n    bytes32 public DOMAIN_SEPAR","after":"\n    bytes32 public DOMAIN_SEPAR","contract":"TokenMinter","time":0},{"type":"immutable-restrict-modification ","before":"\n    bytes32 public PERMIT_TYPE","after":"\n    bytes32 public PERMIT_TYPE","contract":"TokenMinter","time":0}]}