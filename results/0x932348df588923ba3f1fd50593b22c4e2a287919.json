{"time":267,"results":[{"type":"external-function ","before":"function trade(\n\n        IERC20 fromToken,\n\n        IERC20 toToken,\n\n        uint256 tokensAmount,\n\n        address[] memory callAddresses,\n\n        address[] memory approvals,\n\n        bytes memory callDataConcat,\n\n        uint256[] memory starts,\n\n        uint256[] memory values,\n\n        uint256 minTokensAmount\n\n    ) public payable {\n\n        require(callAddresses.length > 0, 'No Call Addresses');\n\n\n        if (address(fromToken) != ETH_ADDRESS) {\n\n            spender.claimTokens(fromToken, msg.sender, address(this), tokensAmount);\n\n        }\n\n\n        for (uint i = 0; i < callAddresses.length; i++) {\n\n            require(callAddresses[i] != address(spender) && isContract(callAddresses[i]), 'Invalid Call Address');\n\n            if (approvals[i] != address(0)) {\n\n                infiniteApproveIfNeeded(fromToken, approvals[i]);\n\n            } else {\n\n                infiniteApproveIfNeeded(fromToken, callAddresses[i]);\n\n            }\n\n            require(external_call(callAddresses[i], values[i], starts[i], starts[i + 1] - starts[i], callDataConcat), 'External Call Failed');\n\n        }\n\n\n        uint256 returnAmount = _balanceOf(toToken, address(this));\n\n        require(returnAmount >= minTokensAmount, 'Trade returned less than the minimum amount');\n\n\n        uint256 leftover = _balanceOf(fromToken, address(this));\n\n        if (leftover > 0) {\n\n            _transfer(fromToken, msg.sender, leftover, false);\n\n        }\n\n\n        _transfer(toToken, msg.sender, _balanceOf(toToken, address(this)), false);\n\n\n        emit Trade(address(fromToken), address(toToken), returnAmount, msg.sender, callAddresses);\n\n    }","after":"function trade(\n\n        IERC20 fromToken,\n\n        IERC20 toToken,\n\n        uint256 tokensAmount,\n\n        address[] calldata callAddresses,\n\n        address[] calldata approvals,\n\n        bytes calldata callDataConcat,\n\n        uint256[] calldata starts,\n\n        uint256[] calldata values,\n\n        uint256 minTokensAmount\n\n    ) public payable {\n\n        require(callAddresses.length > 0, 'No Call Addresses');\n\n\n        if (address(fromToken) != ETH_ADDRESS) {\n\n            spender.claimTokens(fromToken, msg.sender, address(this), tokensAmount);\n\n        }\n\n\n        for (uint i = 0; i < callAddresses.length; i++) {\n\n            require(callAddresses[i] != address(spender) && isContract(callAddresses[i]), 'Invalid Call Address');\n\n            if (approvals[i] != address(0)) {\n\n                infiniteApproveIfNeeded(fromToken, approvals[i]);\n\n            } else {\n\n                infiniteApproveIfNeeded(fromToken, callAddresses[i]);\n\n            }\n\n            require(external_call(callAddresses[i], values[i], starts[i], starts[i + 1] - starts[i], callDataConcat), 'External Call Failed');\n\n        }\n\n\n        uint256 returnAmount = _balanceOf(toToken, address(this));\n\n        require(returnAmount >= minTokensAmount, 'Trade returned less than the minimum amount');\n\n\n        uint256 leftover = _balanceOf(fromToken, address(this));\n\n        if (leftover > 0) {\n\n            _transfer(fromToken, msg.sender, leftover, false);\n\n        }\n\n\n        _transfer(toToken, msg.sender, _balanceOf(toToken, address(this)), false);\n\n\n        emit Trade(address(fromToken), address(toToken), returnAmount, msg.sender, callAddresses);\n\n    }","contract":"BasicTrading","time":0}]}