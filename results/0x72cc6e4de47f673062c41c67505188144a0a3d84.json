{"time":185,"results":[{"type":"state-data-arrangement ","before":"\nnterfaces/ILP.sol\";\nimport \"../interfaces/IAdapt\nr EnumerableSet.AddressSet;\n    using SafeE\nss;\n    using Address for address payable;\n\n\n    uint32 public constant VOTI\n /*----STATE------------------\n  // These addresses can rule w\nt.AddressSet private\n= address(0);\n\n    // Quorum >=1 <=100\n  \n8 public quorum;\n\n    // Executed Voting\n  \ntamp;\n        bytes32 txHash;\n        bytes[]\n  ExecutedVoting[] internal \ntedVoting;\n\n    mapping(byte","after":"r EnumerableSet.AddressSet;\n    using SafeE\nss;\n    using Address for address payable;\n= address(0);\n\n    // Quorum >=1 <=100\n  \n8 public quorum;\n\n    // Executed Voting\n  \ntamp;\n        bytes32 txHash;\n        bytes[]\n\n\n    uint32 public constant VOTI\n /*----STATE------------------\n  // These addresses can rule w\nnterfaces/ILP.sol\";\nimport \"../interfaces/IAdapt\nt.AddressSet private\n  ExecutedVoting[] internal \ntedVoting;\n\n    mapping(byte\n","contract":"Dao","time":1},{"type":"external-function ","before":"g.sender);\n\n        if (_data.length == 0) {\n            payable(_target).sendValue(_value);\n        } else {\n            if (_value == 0) {\n                _target.functionCall(_data);\n            } else {\n                _target.functionCallWithValue(_data, _value);\n            }\n        }\n\n        return true;\n    }\n\n    function execute(\n        address _target,\n        bytes calldata _data,\n        uint256 _value,\n        uint256 _nonce,\n        uint256 _timestamp,\n        bytes[] memory _sigs\n    ) external nonReentrant returns (bool) {\n        require(checkSubscription(), \"DAO: subscription not paid\");\n\n        require(balanceOf(msg.sender) > 0, \"DAO: only for members\");\n\n        require(\n            _timestamp + VOTING_DURATION >= block.timestamp,\n            \"DAO: voting is over\"\n        );\n\n        bytes32 txHash = getTxHash(_target, _data, _value, _nonce, _timestamp);\n\n        require(!executedTx[txHash], \"DAO: voting already executed\");\n\n        require(_checkSigs(_sigs, txHash), \"DAO: quorum is not reached\");\n\n        executedTx[txHash] = true;\n\n        executedVoting.push(\n            ExecutedVoting({\n        target : _target,\n        data : _data,\n        value : _value,\n        nonce : _nonce,\n        timestamp : _timestamp,\n        executionTimestamp : block.timestamp,\n        txHash : txHash,\n        sigs : _sigs\n        })\n        );\n\n        emit Executed(\n            _target,\n            _data,\n            _value,\n            _nonce,\n            _timestamp,\n            block.timestamp,\n            txHash,\n            ","after":"g.sender);\n\n        if (_data.length == 0) {\n            payable(_target).sendValue(_value);\n        } else {\n            if (_value == 0) {\n                _target.functionCall(_data);\n            } else {\n                _target.functionCallWithValue(_data, _value);\n            }\n        }\n\n        return true;\n    }\n\n    function execute(\n        address _target,\n        bytes calldata _data,\n        uint256 _value,\n        uint256 _nonce,\n        uint256 _timestamp,\n        bytes[] memory _sigs\n    ) external nonReentrant returns (bool) {\n        require(checkSubscription(), \"DAO: subscription not paid\");\n\n        require(balanceOf(msg.sender) > 0, \"DAO: only for members\");\n\n        require(\n            _timestamp + VOTING_DURATION >= block.timestamp,\n            \"DAO: voting is over\"\n        );\n\n        bytes32 txHash = getTxHash(_target, _data, _value, _nonce, _timestamp);\n\n        require(!executedTx[txHash], \"DAO: voting already executed\");\n\n        require(_checkSigs(_sigs, txHash), \"DAO: quorum is not reached\");\n\n        executedTx[txHash] = true;\n\n        executedVoting.push(\n            ExecutedVoting({\n        target : _target,\n        data : _data,\n        value : _value,\n        nonce : _nonce,\n        timestamp : _timestamp,\n        executionTimestamp : block.timestamp,\n        txHash : txHash,\n        sigs : _sigs\n        })\n        );\n\n        emit Executed(\n            _target,\n            _data,\n            _value,\n            _nonce,\n            _timestamp,\n            block.timestamp,\n            txHash,\n            ","contract":"Dao","time":0},{"type":"external-function ","before":"ubscription() public view returns (bool) {\n        if (\n            IFactory(factory).monthlyCost() > 0 &&\n            IFactory(factory).subscriptions(address(this)) < block.timestamp\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /*----BURN LP TOKENS---------------------------------*/\n\n    function burnLp(\n        address _recipient,\n        uint256 _share,\n        address[] memory _tokens,\n        address[] memory _adapters,\n        address[] memory _pools\n    ) external nonReentrant returns (bool) {\n        require(lp != address(0), \"DAO: LP not set yet\");\n\n        require(msg.sender == lp, \"DAO: only for LP\");\n\n        require(\n            !_hasDuplicate(_tokens),\n            \"DAO: duplicates are prohibited (tokens)\"\n        );\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            require(\n                _tokens[i] != lp && _tokens[i] != address(this),\n                \"DAO: LP and GT cannot be part of a share\"\n            );\n        }\n\n        require(_adapters.length == _pools.length, \"DAO: adapters error\");\n\n        if (_adapters.length > 0) {\n            uint256 length = _adapters.length;\n\n            if (length > 1) {\n                for (uint256 i = 0; i < length - 1; i++) {\n                    for (uint256 j = i + 1; j < length; j++) {\n                        require(\n                            !(_adapters[i] == _adapters[j] &&\n                        _pools[i] == _pools[j]),\n                            \"DAO: duplicates are prohibited (adapters)\"\n                        );\n                    }\n                }\n            }\n        }\n\n        // ETH\n\n        payable(_recipient).sendValue((address(this).balance * _share) / 1e18);\n\n        // Tokens\n\n        if (_tokens.length > 0) {\n            uint256[] memory _tokenShares = new uint256[](_tokens.length);\n\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                _tokenShares[i] = ((IERC20(_tokens[i]).balanceOf(\n                    address(this)\n                ) * _share) / 1e18);\n            }\n\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                IERC20(_tokens[i]).safeTransfer(_recipient, _tokenShares[i]);\n            }\n        }\n\n        // Adapters\n\n        if (_adapters.length > 0) {\n            uint256 length = _adapters.length;\n\n            for (uint256 i = 0; i < length; i++) {\n                require(\n                    adapters.contains(_adapters[i]),\n                    \"DAO: this is not an adapter\"\n                );\n\n                require(\n                    permitted.contains(_adapters[i]),\n                    \"DA","after":"ubscription() public view returns (bool) {\n        if (\n            IFactory(factory).monthlyCost() > 0 &&\n            IFactory(factory).subscriptions(address(this)) < block.timestamp\n        ) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /*----BURN LP TOKENS---------------------------------*/\n\n    function burnLp(\n        address _recipient,\n        uint256 _share,\n        address[] memory _tokens,\n        address[] memory _adapters,\n        address[] memory _pools\n    ) external nonReentrant returns (bool) {\n        require(lp != address(0), \"DAO: LP not set yet\");\n\n        require(msg.sender == lp, \"DAO: only for LP\");\n\n        require(\n            !_hasDuplicate(_tokens),\n            \"DAO: duplicates are prohibited (tokens)\"\n        );\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            require(\n                _tokens[i] != lp && _tokens[i] != address(this),\n                \"DAO: LP and GT cannot be part of a share\"\n            );\n        }\n\n        require(_adapters.length == _pools.length, \"DAO: adapters error\");\n\n        if (_adapters.length > 0) {\n            uint256 length = _adapters.length;\n\n            if (length > 1) {\n                for (uint256 i = 0; i < length - 1; i++) {\n                    for (uint256 j = i + 1; j < length; j++) {\n                        require(\n                            !(_adapters[i] == _adapters[j] &&\n                        _pools[i] == _pools[j]),\n                            \"DAO: duplicates are prohibited (adapters)\"\n                        );\n                    }\n                }\n            }\n        }\n\n        // ETH\n\n        payable(_recipient).sendValue((address(this).balance * _share) / 1e18);\n\n        // Tokens\n\n        if (_tokens.length > 0) {\n            uint256[] memory _tokenShares = new uint256[](_tokens.length);\n\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                _tokenShares[i] = ((IERC20(_tokens[i]).balanceOf(\n                    address(this)\n                ) * _share) / 1e18);\n            }\n\n            for (uint256 i = 0; i < _tokens.length; i++) {\n                IERC20(_tokens[i]).safeTransfer(_recipient, _tokenShares[i]);\n            }\n        }\n\n        // Adapters\n\n        if (_adapters.length > 0) {\n            uint256 length = _adapters.length;\n\n            for (uint256 i = 0; i < length; i++) {\n                require(\n                    adapters.contains(_adapters[i]),\n                    \"DAO: this is not an adapter\"\n                );\n\n                require(\n                    permitted.contains(_adapters[i]),\n                    \"DA","contract":"Dao","time":0},{"type":"immutable-restrict-modification ","before":"tions have been added","after":"tions have been added","contract":"Dao","time":1},{"type":"immutable-restrict-modification ","before":"itigate the well-known ","after":"itigate the well-known ","contract":"Dao","time":1},{"type":"external-function ","before":"ntains(_dao));\n\n        if (subscriptions[_dao] < block.timestamp) {\n            subscriptions[_dao] = block.timestamp + 30 days;\n        } else {\n            subscriptions[_dao] += 30 days;\n        }\n\n        IERC20(xdao).safeTransferFrom(msg.sender, owner(), monthlyCost);\n\n        return true;\n    }\n\n    function changeMonthlyCost(uint256 _m) external onlyOwner returns (bool) {\n        monthlyCost = _m;\n\n        return true;\n    }\n\n    function changeFreeT","after":"ntains(_dao));\n\n        if (subscriptions[_dao] < block.timestamp) {\n            subscriptions[_dao] = block.timestamp + 30 days;\n        } else {\n            subscriptions[_dao] += 30 days;\n        }\n\n        IERC20(xdao).safeTransferFrom(msg.sender, owner(), monthlyCost);\n\n        return true;\n    }\n\n    function changeMonthlyCost(uint256 _m) external onlyOwner returns (bool) {\n        monthlyCost = _m;\n\n        return true;\n    }\n\n    function changeFreeT","contract":"Factory","time":0}]}