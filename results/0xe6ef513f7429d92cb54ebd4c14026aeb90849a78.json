{"time":237,"results":[{"type":"loop-calculation","before":"   Tier memory _tokenTier = tokenTier[tokenI","after":"// move outside for loop\n   Tier memory _tokenTier = tokenTier[tokenI","loc":{"start":{"line":4640,"column":12},"end":{"line":4640,"column":55}},"contract":"ImpactTheoryFoundersKey","time":0},{"type":"state-data-arrangement ","before":"\n   string private baseTokenU\n   string private baseTokenURIForMetada\n   bytes16 private constant HEX_ALPHABET = \"0123456789abcde\n   string private constant IPFS_PREFIX = \"f0155122\n   address private paymentAddress = 0x681EA99a65E6f392f0F5276Af396AE8CaD140E\n   address private royaltyAddress = 0x681EA99a65E6f392f0F5276Af396AE8CaD140E\n   address private signerAddress = 0x4A2034e724034F31b46117d918E789c42EBE0C\n   uint256 private royaltyBasisPoints = 10\n   string public constant TOKEN_NAME = \"Impact Theory Founder's Ke\n   string public constant TOKEN_SYMBOL = \"ITF\n   uint256 public constant CLOSED_PRESALE_DURATION = 1 da\n   uint256 public constant PRESALE_DURATION = 1 da\n   uint256 public constant AUCTION_DURATION = 1 da\n   uint256 public constant AUCTION_PRICE_CHANGE = 1 hou\n   uint256 public constant DURATION_BETWEEN_TIERS = 1 da\n   uint256 public publicSaleStartTi\n   bool public publicSaleActi\n   Tier public tier1 = Tier({id : 1, name : \"Legendary\"\n   TierInfo private tier1Info =\n\n    TierInfo({\n\n    tier : tier1,\n\n    startingOffset : 1,\n\n    totalSupply : 2700,\n\n    startingPrice : 3 ether,\n\n    endingPrice : 1.5 ether,\n\n    maxPerClosedPresale : 1,\n\n    maxTotalMint : 4,\n\n    saleEnded : false\n\n    \n   Tier public tier2 = Tier({id : 2, name : \"Heroic\"\n   TierInfo private tier2Info =\n\n    TierInfo({\n\n    tier : tier2,\n\n    startingOffset : 2701,\n\n    totalSupply : 7300,\n\n    startingPrice : 1.5 ether,\n\n    endingPrice : .75 ether,\n\n    maxPerClosedPresale : 2,\n\n    maxTotalMint : 5,\n\n    saleEnded : false\n\n    \n   Tier public tier3 = Tier({id : 3, name : \"Relentless\"\n   TierInfo private tier3Info =\n\n    TierInfo({\n\n    tier : tier3,\n\n    startingOffset : 10001,\n\n    totalSupply : 10000,\n\n    startingPrice : .1 ether,\n\n    endingPrice : .05 ether,\n\n    maxPerClosedPresale : 1,\n\n    maxTotalMint : 5,\n\n    saleEnded : false\n\n    \n   Tier[] public allTiersArr\n   TierInfo[] private allTiersInfoArr\n   uint256[] public allTierI\n   mapping(uint256 => Tier) public allTie\n   mapping(uint256 => TierInfo) private allTiersIn\n   mapping(uint256 => Tier) public tokenTi\n   mapping(uint256 => uint256) public tokenMinted\n   mapping(uint256 => uint256) public tokenLastTransferred\n   mapping(uint256 => uint256) public tierCoun\n   mapping(uint256 => bytes32[]) public tokenMetada\n   mapping(address => uint256[]) private presaleWhiteli\n   mapping(string => bool) private usedNonc","after":"   string private baseTokenU\n   string private baseTokenURIForMetada\n   string private constant IPFS_PREFIX = \"f0155122\n   uint256 private royaltyBasisPoints = 10\n   string public constant TOKEN_NAME = \"Impact Theory Founder's Ke\n   string public constant TOKEN_SYMBOL = \"ITF\n   uint256 public constant CLOSED_PRESALE_DURATION = 1 da\n   uint256 public constant PRESALE_DURATION = 1 da\n   uint256 public constant AUCTION_DURATION = 1 da\n   uint256 public constant AUCTION_PRICE_CHANGE = 1 hou\n   uint256 public constant DURATION_BETWEEN_TIERS = 1 da\n   uint256 public publicSaleStartTi\n   Tier public tier1 = Tier({id : 1, name : \"Legendary\"\n   TierInfo private tier1Info =\n\n    TierInfo({\n\n    tier : tier1,\n\n    startingOffset : 1,\n\n    totalSupply : 2700,\n\n    startingPrice : 3 ether,\n\n    endingPrice : 1.5 ether,\n\n    maxPerClosedPresale : 1,\n\n    maxTotalMint : 4,\n\n    saleEnded : false\n\n    \n   Tier public tier2 = Tier({id : 2, name : \"Heroic\"\n   TierInfo private tier2Info =\n\n    TierInfo({\n\n    tier : tier2,\n\n    startingOffset : 2701,\n\n    totalSupply : 7300,\n\n    startingPrice : 1.5 ether,\n\n    endingPrice : .75 ether,\n\n    maxPerClosedPresale : 2,\n\n    maxTotalMint : 5,\n\n    saleEnded : false\n\n    \n   Tier public tier3 = Tier({id : 3, name : \"Relentless\"\n   TierInfo private tier3Info =\n\n    TierInfo({\n\n    tier : tier3,\n\n    startingOffset : 10001,\n\n    totalSupply : 10000,\n\n    startingPrice : .1 ether,\n\n    endingPrice : .05 ether,\n\n    maxPerClosedPresale : 1,\n\n    maxTotalMint : 5,\n\n    saleEnded : false\n\n    \n   Tier[] public allTiersArr\n   TierInfo[] private allTiersInfoArr\n   uint256[] public allTierI\n   mapping(uint256 => Tier) public allTie\n   mapping(uint256 => TierInfo) private allTiersIn\n   mapping(uint256 => Tier) public tokenTi\n   mapping(uint256 => uint256) public tokenMinted\n   mapping(uint256 => uint256) public tokenLastTransferred\n   mapping(uint256 => uint256) public tierCoun\n   mapping(uint256 => bytes32[]) public tokenMetada\n   mapping(address => uint256[]) private presaleWhiteli\n   mapping(string => bool) private usedNonc\n   address private paymentAddress = 0x681EA99a65E6f392f0F5276Af396AE8CaD140E\n   address private royaltyAddress = 0x681EA99a65E6f392f0F5276Af396AE8CaD140E\n   address private signerAddress = 0x4A2034e724034F31b46117d918E789c42EBE0C\n   bytes16 private constant HEX_ALPHABET = \"0123456789abcde\n   bool public publicSaleActi\n","contract":"ImpactTheoryFoundersKey","time":1},{"type":"external-function ","before":"   function addToPresaleWhitelist(uint256 _tierId, address[] memory _addresses)\n\n    external\n\n    onlyOwner\n\n    {\n\n        Tier memory tier = allTiers[_tierId];\n\n\n        require(tier.id == _tierId, \"Invalid tier\");\n\n\n        for (uint256 i = 0; i < _addresses.length; i++) {\n\n            address _address = _addresses[i];\n\n\n            uint256[] storage tierIds = presaleWhitelist[_address];\n\n\n            bool exists = false;\n\n            for (uint256 j = 0; j < tierIds.length; j++) {\n\n                if (tierIds[j] == tier.id) {\n\n                    exists = true;\n\n                }\n\n            }\n\n\n            if (!exists) {\n\n                tierIds.push(tier.id);\n\n            }\n\n\n            presaleWhitelist[_address] = tierIds;\n\n        }\n\n  ","after":"   function addToPresaleWhitelist(uint256 _tierId, address[] calldata _addresses)\n\n    external\n\n    onlyOwner\n\n    {\n\n        Tier memory tier = allTiers[_tierId];\n\n\n        require(tier.id == _tierId, \"Invalid tier\");\n\n\n        for (uint256 i = 0; i < _addresses.length; i++) {\n\n            address _address = _addresses[i];\n\n\n            uint256[] storage tierIds = presaleWhitelist[_address];\n\n\n            bool exists = false;\n\n            for (uint256 j = 0; j < tierIds.length; j++) {\n\n                if (tierIds[j] == tier.id) {\n\n                    exists = true;\n\n                }\n\n            }\n\n\n            if (!exists) {\n\n                tierIds.push(tier.id);\n\n            }\n\n\n            presaleWhitelist[_address] = tierIds;\n\n        }\n\n  ","contract":"ImpactTheoryFoundersKey","time":0},{"type":"external-function ","before":"   function mint(\n\n        uint256 _tierId,\n\n        uint256 _amount,\n\n        bytes32 _hash,\n\n        bytes memory _signature,\n\n        string memory _nonce\n\n    ) public payable whenOwnerOrPublicSaleActive {\n\n        require(\n\n            matchAddressSigner(_hash, _signature),\n\n            \"Direct mint disallowed\"\n\n        );\n\n        require(!usedNonces[_nonce], \"Hash already used\");\n\n        require(\n\n            hashTransaction(_msgSender(), _amount, _nonce) == _hash,\n\n            \"Hash failed\"\n\n        );\n\n\n        Tier memory tier = allTiers[_tierId];\n\n        TierInfo memory tierInfo = allTiersInfo[_tierId];\n\n\n        require(tier.id == _tierId, \"Invalid tier\");\n\n\n        // Must mint at least one\n\n        require(_amount > 0, \"Must mint at least one\");\n\n\n        // Check there enough mints left for tier\n\n        require(\n\n            getMintsLeft(tier.id).sub(_amount) >= 0,\n\n            \"Minting would exceed max supply\"\n\n        );\n\n\n        // Get current address total balance\n\n        uint256 currentTotalAmount = super.balanceOf(_msgSender());\n\n\n        // Loop over all tokens for address and get current tier count\n\n        uint256 currentTierAmount = 0;\n\n        for (uint256 i = 0; i < currentTotalAmount; i++) {\n\n            uint256 tokenId = super.tokenOfOwnerByIndex(_msgSender(), i);\n\n            Tier memory _tokenTier = tokenTier[tokenId];\n\n            if (_tokenTier.id == tier.id) {\n\n                currentTierAmount++;\n\n            }\n\n        }\n\n\n        uint256 costToMint = 0;\n\n        uint256 amount = _amount;\n\n\n        // Is owner\n\n        bool isOwner = owner() == _msgSender();\n\n\n        // If not owner, check amounts are not more than max amounts\n\n        if (!isOwner) {\n\n            // Get elapsed sale time\n\n            uint256 elapsed = getElapsedSaleTime();\n\n\n            // Time logic based on tier and constants\n\n            uint256 closedPresaleStart = (tier.id - 1).mul(\n\n                DURATION_BETWEEN_TIERS\n\n            );\n\n            uint256 closedPresaleEnd = closedPresaleStart.add(\n\n                CLOSED_PRESALE_DURATION\n\n            );\n\n\n            // If still in the closed whitelist, do not allow more than max per closed presale\n\n            if (elapsed <= closedPresaleEnd) {\n\n                require(\n\n                    currentTierAmount.add(amount) <= tierInfo.maxPerClosedPresale,\n\n                    \"Requested amount exceeds maximum whitelist mint amount\"\n\n                );\n\n            }\n\n\n            // Do not allow more than max total mint\n\n            require(\n\n                currentTierAmount.add(amount) <= tierInfo.maxTotalMint,\n\n                \"Requested amount exceeds maximum total mint amount\"\n\n            );\n\n        }\n\n\n        // Get cost to mint\n\n        costToMint = getMintPrice(tier.id).mul(amount);\n\n\n        // Check cost to mint for tier, and if enough ETH is passed to mint\n\n        require(costToMint <= msg.value, \"ETH amount sent is not correct\");\n\n\n        for (uint256 i = 0; i < amount; i++) {\n\n            // Token id is tier starting offset plus count of already minted\n\n            uint256 tokenId = tierInfo.startingOffset.add(tierCounts[tier.id]);\n\n\n            // Safe mint\n\n            _safeMint(_msgSender(), tokenId);\n\n\n            // Attribute token id with tier\n\n            tokenTier[tokenId] = tier;\n\n\n            // Store minted at timestamp by token id\n\n            tokenMintedAt[tokenId] = block.timestamp;\n\n\n            // Increment tier counter\n\n            tierCounts[tier.id] = tierCounts[tier.id].add(1);\n\n        }\n\n\n        usedNonces[_nonce] = true;\n\n\n        // Send mint cost to payment address\n\n        Address.sendValue(payable(paymentAddress), costToMint);\n\n\n        // Return unused value\n\n        if (msg.value > costToMint) {\n\n            Address.sendValue(payable(_msgSender()), msg.value.sub(costToMint));\n\n        }\n\n  ","after":"   function mint(\n\n        uint256 _tierId,\n\n        uint256 _amount,\n\n        bytes32 _hash,\n\n        bytes calldata _signature,\n\n        string calldata _nonce\n\n    ) public payable whenOwnerOrPublicSaleActive {\n\n        require(\n\n            matchAddressSigner(_hash, _signature),\n\n            \"Direct mint disallowed\"\n\n        );\n\n        require(!usedNonces[_nonce], \"Hash already used\");\n\n        require(\n\n            hashTransaction(_msgSender(), _amount, _nonce) == _hash,\n\n            \"Hash failed\"\n\n        );\n\n\n        Tier memory tier = allTiers[_tierId];\n\n        TierInfo memory tierInfo = allTiersInfo[_tierId];\n\n\n        require(tier.id == _tierId, \"Invalid tier\");\n\n\n        // Must mint at least one\n\n        require(_amount > 0, \"Must mint at least one\");\n\n\n        // Check there enough mints left for tier\n\n        require(\n\n            getMintsLeft(tier.id).sub(_amount) >= 0,\n\n            \"Minting would exceed max supply\"\n\n        );\n\n\n        // Get current address total balance\n\n        uint256 currentTotalAmount = super.balanceOf(_msgSender());\n\n\n        // Loop over all tokens for address and get current tier count\n\n        uint256 currentTierAmount = 0;\n\n        for (uint256 i = 0; i < currentTotalAmount; i++) {\n\n            uint256 tokenId = super.tokenOfOwnerByIndex(_msgSender(), i);\n\n            Tier memory _tokenTier = tokenTier[tokenId];\n\n            if (_tokenTier.id == tier.id) {\n\n                currentTierAmount++;\n\n            }\n\n        }\n\n\n        uint256 costToMint = 0;\n\n        uint256 amount = _amount;\n\n\n        // Is owner\n\n        bool isOwner = owner() == _msgSender();\n\n\n        // If not owner, check amounts are not more than max amounts\n\n        if (!isOwner) {\n\n            // Get elapsed sale time\n\n            uint256 elapsed = getElapsedSaleTime();\n\n\n            // Time logic based on tier and constants\n\n            uint256 closedPresaleStart = (tier.id - 1).mul(\n\n                DURATION_BETWEEN_TIERS\n\n            );\n\n            uint256 closedPresaleEnd = closedPresaleStart.add(\n\n                CLOSED_PRESALE_DURATION\n\n            );\n\n\n            // If still in the closed whitelist, do not allow more than max per closed presale\n\n            if (elapsed <= closedPresaleEnd) {\n\n                require(\n\n                    currentTierAmount.add(amount) <= tierInfo.maxPerClosedPresale,\n\n                    \"Requested amount exceeds maximum whitelist mint amount\"\n\n                );\n\n            }\n\n\n            // Do not allow more than max total mint\n\n            require(\n\n                currentTierAmount.add(amount) <= tierInfo.maxTotalMint,\n\n                \"Requested amount exceeds maximum total mint amount\"\n\n            );\n\n        }\n\n\n        // Get cost to mint\n\n        costToMint = getMintPrice(tier.id).mul(amount);\n\n\n        // Check cost to mint for tier, and if enough ETH is passed to mint\n\n        require(costToMint <= msg.value, \"ETH amount sent is not correct\");\n\n\n        for (uint256 i = 0; i < amount; i++) {\n\n            // Token id is tier starting offset plus count of already minted\n\n            uint256 tokenId = tierInfo.startingOffset.add(tierCounts[tier.id]);\n\n\n            // Safe mint\n\n            _safeMint(_msgSender(), tokenId);\n\n\n            // Attribute token id with tier\n\n            tokenTier[tokenId] = tier;\n\n\n            // Store minted at timestamp by token id\n\n            tokenMintedAt[tokenId] = block.timestamp;\n\n\n            // Increment tier counter\n\n            tierCounts[tier.id] = tierCounts[tier.id].add(1);\n\n        }\n\n\n        usedNonces[_nonce] = true;\n\n\n        // Send mint cost to payment address\n\n        Address.sendValue(payable(paymentAddress), costToMint);\n\n\n        // Return unused value\n\n        if (msg.value > costToMint) {\n\n            Address.sendValue(payable(_msgSender()), msg.value.sub(costToMint));\n\n        }\n\n  ","contract":"ImpactTheoryFoundersKey","time":0},{"type":"external-function ","before":"   function burnMultiple(uint256[] memory _tokenIds) public onlyOwner {\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n\n            // Token id\n\n            uint256 tokenId = _tokenIds[i];\n\n\n            _burn(tokenId);\n\n        }\n\n  ","after":"   function burnMultiple(uint256[] calldata _tokenIds) public onlyOwner {\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n\n            // Token id\n\n            uint256 tokenId = _tokenIds[i];\n\n\n            _burn(tokenId);\n\n        }\n\n  ","contract":"ImpactTheoryFoundersKey","time":0},{"type":"external-function ","before":"   function setBaseURI(string memory _uri) public onlyOwner {\n\n        baseTokenURI = _uri;\n\n  ","after":"   function setBaseURI(string calldata _uri) public onlyOwner {\n\n        baseTokenURI = _uri;\n\n  ","contract":"ImpactTheoryFoundersKey","time":0},{"type":"external-function ","before":"   function setBaseURIForMetadata(string memory _uri) public onlyOwner {\n\n        baseTokenURIForMetadata = _uri;\n\n  ","after":"   function setBaseURIForMetadata(string calldata _uri) public onlyOwner {\n\n        baseTokenURIForMetadata = _uri;\n\n  ","contract":"ImpactTheoryFoundersKey","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"ImpactTheoryFoundersKey","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"ImpactTheoryFoundersKey","time":1}]}