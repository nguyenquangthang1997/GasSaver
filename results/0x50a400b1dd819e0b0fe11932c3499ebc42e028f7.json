{"time":75,"results":[{"type":"state-data-arrangement ","before":"\naddress public _owner;\naddress[] public _approvedMinters;\nbool public _closedMintToOwner = false;\nbool public _freezeApprovedMintersList = false;\nISpiritOrbPetsv0 public SOPV0Contract;\nuint256 public INITIAL_ALLOTMENT = 100 * (10 ** 18);\nuint256 public _emissionStart = 0;\nuint256 public _emissionEnd = 0;\nuint256 public _emissionPerDay = 10 * (10 ** 18);\nmapping(uint256 => uint256) private _lastClaim;","after":"address[] public _approvedMinters;\nISpiritOrbPetsv0 public SOPV0Contract;\nuint256 public INITIAL_ALLOTMENT = 100 * (10 ** 18);\nuint256 public _emissionStart = 0;\nuint256 public _emissionEnd = 0;\nuint256 public _emissionPerDay = 10 * (10 ** 18);\nmapping(uint256 => uint256) private _lastClaim;\naddress public _owner;\nbool public _closedMintToOwner = false;\nbool public _freezeApprovedMintersList = false;\n","contract":"CareToken","time":0},{"type":"external-function ","before":"function claim(uint256[] memory tokenIndices) public returns (uint256) {\n\n        require(_emissionStart != 0 && _emissionEnd != 0, \"Emission has not started yet\");\n\n\n        uint256 totalClaimQty = 0;\n\n        for (uint i = 0; i < tokenIndices.length; i++) {\n\n            // Sanity check for non-minted index\n\n            require(tokenIndices[i] < SOPV0Contract.totalSupply(), \"NFT at index has not been minted yet\");\n\n            // Duplicate token index check\n\n            for (uint j = i + 1; j < tokenIndices.length; j++) {\n\n                require(tokenIndices[i] != tokenIndices[j], \"Duplicate token index\");\n\n            }\n\n\n            uint tokenIndex = tokenIndices[i];\n\n            require(SOPV0Contract.ownerOf(tokenIndex) == msg.sender, \"Sender is not the owner\");\n\n\n            uint256 claimQty = accumulated(tokenIndex);\n\n            if (claimQty != 0) {\n\n                totalClaimQty = totalClaimQty + claimQty;\n\n                _lastClaim[tokenIndex] = block.timestamp;\n\n            }\n\n        }\n\n\n        require(totalClaimQty != 0, \"No accumulated CARE\");\n\n        _mint(msg.sender, totalClaimQty);\n\n        return totalClaimQty;\n\n    }","after":"function claim(uint256[] calldata tokenIndices) public returns (uint256) {\n\n        require(_emissionStart != 0 && _emissionEnd != 0, \"Emission has not started yet\");\n\n\n        uint256 totalClaimQty = 0;\n\n        for (uint i = 0; i < tokenIndices.length; i++) {\n\n            // Sanity check for non-minted index\n\n            require(tokenIndices[i] < SOPV0Contract.totalSupply(), \"NFT at index has not been minted yet\");\n\n            // Duplicate token index check\n\n            for (uint j = i + 1; j < tokenIndices.length; j++) {\n\n                require(tokenIndices[i] != tokenIndices[j], \"Duplicate token index\");\n\n            }\n\n\n            uint tokenIndex = tokenIndices[i];\n\n            require(SOPV0Contract.ownerOf(tokenIndex) == msg.sender, \"Sender is not the owner\");\n\n\n            uint256 claimQty = accumulated(tokenIndex);\n\n            if (claimQty != 0) {\n\n                totalClaimQty = totalClaimQty + claimQty;\n\n                _lastClaim[tokenIndex] = block.timestamp;\n\n            }\n\n        }\n\n\n        require(totalClaimQty != 0, \"No accumulated CARE\");\n\n        _mint(msg.sender, totalClaimQty);\n\n        return totalClaimQty;\n\n    }","contract":"CareToken","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public INITIAL_ALLOTMENT = 100 * (10 ** 18);","after":"uint256 public constant INITIAL_ALLOTMENT = 100 * (10 ** 18);","contract":"CareToken","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public _emissionPerDay = 10 * (10 ** 18);","after":"uint256 public constant _emissionPerDay = 10 * (10 ** 18);","contract":"CareToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"CareToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"CareToken","time":0}]}