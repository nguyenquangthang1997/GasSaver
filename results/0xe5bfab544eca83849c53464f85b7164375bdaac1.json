{"time":228,"results":[{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping(address => EnumerableSet.UintSet) private _holderTokens;\nEnumerableMap.UintToAddressMap private _tokenOwners;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nstring private _name;\nstring private _symbol;\nmapping(uint256 => string) internal _tokenURIs;\nstring internal _baseURI;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\nbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;","after":"mapping(address => EnumerableSet.UintSet) private _holderTokens;\nEnumerableMap.UintToAddressMap private _tokenOwners;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nstring private _name;\nstring private _symbol;\nmapping(uint256 => string) internal _tokenURIs;\nstring internal _baseURI;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\nbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n","contract":"ERC721","time":0},{"type":"external-function ","before":"function setBidShares(uint256 tokenId, BidShares memory bidShares)\n    public\n    override\n    onlyMediaCaller\n    {\n        require(\n            isValidBidShares(bidShares),\n            \"Market: Invalid bid shares, must sum to 100\"\n        );\n        _bidShares[tokenId] = bidShares;\n        emit BidShareUpdated(tokenId, bidShares);\n    }","after":"function setBidShares(uint256 tokenId, BidShares calldata bidShares)\n    public\n    override\n    onlyMediaCaller\n    {\n        require(\n            isValidBidShares(bidShares),\n            \"Market: Invalid bid shares, must sum to 100\"\n        );\n        _bidShares[tokenId] = bidShares;\n        emit BidShareUpdated(tokenId, bidShares);\n    }","contract":"Market","time":0},{"type":"external-function ","before":"function setAsk(uint256 tokenId, Ask memory ask)\n    public\n    override\n    onlyMediaCaller\n    {\n        require(\n            isValidBid(tokenId, ask.amount),\n            \"Market: Ask invalid for share splitting\"\n        );\n\n        _tokenAsks[tokenId] = ask;\n        emit AskCreated(tokenId, ask);\n    }","after":"function setAsk(uint256 tokenId, Ask calldata ask)\n    public\n    override\n    onlyMediaCaller\n    {\n        require(\n            isValidBid(tokenId, ask.amount),\n            \"Market: Ask invalid for share splitting\"\n        );\n\n        _tokenAsks[tokenId] = ask;\n        emit AskCreated(tokenId, ask);\n    }","contract":"Market","time":0},{"type":"external-function ","before":"function setBid(\n        uint256 tokenId,\n        Bid memory bid,\n        address spender\n    ) public override onlyMediaCaller {\n        BidShares memory bidShares = _bidShares[tokenId];\n        require(\n            bidShares.creator.value.add(bid.sellOnShare.value) <=\n            uint256(100).mul(Decimal.BASE),\n            \"Market: Sell on fee invalid for share splitting\"\n        );\n        require(bid.bidder != address(0), \"Market: bidder cannot be 0 address\");\n        require(bid.amount != 0, \"Market: cannot bid amount of 0\");\n        require(\n            bid.currency != address(0),\n            \"Market: bid currency cannot be 0 address\"\n        );\n        require(\n            bid.recipient != address(0),\n            \"Market: bid recipient cannot be 0 address\"\n        );\n\n        Bid storage existingBid = _tokenBidders[tokenId][bid.bidder];\n\n        // If there is an existing bid, refund it before continuing\n        if (existingBid.amount > 0) {\n            removeBid(tokenId, bid.bidder);\n        }\n\n        IERC20 token = IERC20(bid.currency);\n\n        // We must check the balance that was actually transferred to the market,\n        // as some tokens impose a transfer fee and would not actually transfer the\n        // full amount to the market, resulting in locked funds for refunds & bid acceptance\n        uint256 beforeBalance = token.balanceOf(address(this));\n        token.safeTransferFrom(spender, address(this), bid.amount);\n        uint256 afterBalance = token.balanceOf(address(this));\n        _tokenBidders[tokenId][bid.bidder] = Bid(\n            afterBalance.sub(beforeBalance),\n            bid.currency,\n            bid.bidder,\n            bid.recipient,\n            bid.sellOnShare\n        );\n        emit BidCreated(tokenId, bid);\n\n        // If a bid meets the criteria for an ask, automatically accept the bid.\n        // If no ask is set or the bid does not meet the requirements, ignore.\n        if (\n            _tokenAsks[tokenId].currency != address(0) &&\n            bid.currency == _tokenAsks[tokenId].currency &&\n            bid.amount >= _tokenAsks[tokenId].amount\n        ) {\n            // Finalize exchange\n            _finalizeNFTTransfer(tokenId, bid.bidder);\n        }\n    }","after":"function setBid(\n        uint256 tokenId,\n        Bid calldata bid,\n        address spender\n    ) public override onlyMediaCaller {\n        BidShares memory bidShares = _bidShares[tokenId];\n        require(\n            bidShares.creator.value.add(bid.sellOnShare.value) <=\n            uint256(100).mul(Decimal.BASE),\n            \"Market: Sell on fee invalid for share splitting\"\n        );\n        require(bid.bidder != address(0), \"Market: bidder cannot be 0 address\");\n        require(bid.amount != 0, \"Market: cannot bid amount of 0\");\n        require(\n            bid.currency != address(0),\n            \"Market: bid currency cannot be 0 address\"\n        );\n        require(\n            bid.recipient != address(0),\n            \"Market: bid recipient cannot be 0 address\"\n        );\n\n        Bid storage existingBid = _tokenBidders[tokenId][bid.bidder];\n\n        // If there is an existing bid, refund it before continuing\n        if (existingBid.amount > 0) {\n            removeBid(tokenId, bid.bidder);\n        }\n\n        IERC20 token = IERC20(bid.currency);\n\n        // We must check the balance that was actually transferred to the market,\n        // as some tokens impose a transfer fee and would not actually transfer the\n        // full amount to the market, resulting in locked funds for refunds & bid acceptance\n        uint256 beforeBalance = token.balanceOf(address(this));\n        token.safeTransferFrom(spender, address(this), bid.amount);\n        uint256 afterBalance = token.balanceOf(address(this));\n        _tokenBidders[tokenId][bid.bidder] = Bid(\n            afterBalance.sub(beforeBalance),\n            bid.currency,\n            bid.bidder,\n            bid.recipient,\n            bid.sellOnShare\n        );\n        emit BidCreated(tokenId, bid);\n\n        // If a bid meets the criteria for an ask, automatically accept the bid.\n        // If no ask is set or the bid does not meet the requirements, ignore.\n        if (\n            _tokenAsks[tokenId].currency != address(0) &&\n            bid.currency == _tokenAsks[tokenId].currency &&\n            bid.amount >= _tokenAsks[tokenId].amount\n        ) {\n            // Finalize exchange\n            _finalizeNFTTransfer(tokenId, bid.bidder);\n        }\n    }","contract":"Market","time":0},{"type":"immutable-restrict-modification ","before":"address private _owner;","after":"address private immutable _owner;","contract":"Market","time":0},{"type":"state-data-arrangement ","before":"\naddress public marketContract;\nmapping(uint256 => address) public previousTokenOwners;\nmapping(uint256 => address) public tokenCreators;\nmapping(address => EnumerableSet.UintSet) private _creatorTokens;\nmapping(uint256 => bytes32) public tokenContentHashes;\nmapping(uint256 => bytes32) public tokenMetadataHashes;\nmapping(uint256 => string) private _tokenMetadataURIs;\nmapping(bytes32 => bool) private _contentHashes;\nbytes32 public constant PERMIT_TYPEHASH =\n    0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\nbytes32 public constant MINT_WITH_SIG_TYPEHASH =\n    0x2952e482b8e2b192305f87374d7af45dc2eafafe4f50d26a0c02e90f2fdbe14b;\nmapping(address => mapping(uint256 => uint256)) public permitNonces;\nmapping(address => uint256) public mintWithSigNonces;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x4e222e66;\nCounters.Counter private _tokenIdTracker;","after":"mapping(uint256 => address) public previousTokenOwners;\nmapping(uint256 => address) public tokenCreators;\nmapping(address => EnumerableSet.UintSet) private _creatorTokens;\nmapping(uint256 => bytes32) public tokenContentHashes;\nmapping(uint256 => bytes32) public tokenMetadataHashes;\nmapping(uint256 => string) private _tokenMetadataURIs;\nmapping(bytes32 => bool) private _contentHashes;\nbytes32 public constant PERMIT_TYPEHASH =\n    0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\nbytes32 public constant MINT_WITH_SIG_TYPEHASH =\n    0x2952e482b8e2b192305f87374d7af45dc2eafafe4f50d26a0c02e90f2fdbe14b;\nmapping(address => mapping(uint256 => uint256)) public permitNonces;\nmapping(address => uint256) public mintWithSigNonces;\nCounters.Counter private _tokenIdTracker;\naddress public marketContract;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x4e222e66;\n","contract":"Media","time":0},{"type":"external-function ","before":"function mint(MediaData memory data, IMarket.BidShares memory bidShares)\n    public\n    override\n    nonReentrant\n    {\n        _mintForCreator(msg.sender, data, bidShares);\n    }","after":"function mint(MediaData calldata data, IMarket.BidShares calldata bidShares)\n    public\n    override\n    nonReentrant\n    {\n        _mintForCreator(msg.sender, data, bidShares);\n    }","contract":"Media","time":0},{"type":"external-function ","before":"function mintWithSig(\n        address creator,\n        MediaData memory data,\n        IMarket.BidShares memory bidShares,\n        EIP712Signature memory sig\n    ) public override nonReentrant {\n        require(\n            sig.deadline == 0 || sig.deadline >= block.timestamp,\n            \"Media: mintWithSig expired\"\n        );\n\n        bytes32 domainSeparator = _calculateDomainSeparator();\n\n        bytes32 digest =\n        keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                keccak256(\n                    abi.encode(\n                        MINT_WITH_SIG_TYPEHASH,\n                        data.contentHash,\n                        data.metadataHash,\n                        bidShares.creator.value,\n                        mintWithSigNonces[creator]++,\n                        sig.deadline\n                    )\n                )\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, sig.v, sig.r, sig.s);\n\n        require(\n            recoveredAddress != address(0) && creator == recoveredAddress,\n            \"Media: Signature invalid\"\n        );\n\n        _mintForCreator(recoveredAddress, data, bidShares);\n    }","after":"function mintWithSig(\n        address creator,\n        MediaData calldata data,\n        IMarket.BidShares calldata bidShares,\n        EIP712Signature calldata sig\n    ) public override nonReentrant {\n        require(\n            sig.deadline == 0 || sig.deadline >= block.timestamp,\n            \"Media: mintWithSig expired\"\n        );\n\n        bytes32 domainSeparator = _calculateDomainSeparator();\n\n        bytes32 digest =\n        keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                keccak256(\n                    abi.encode(\n                        MINT_WITH_SIG_TYPEHASH,\n                        data.contentHash,\n                        data.metadataHash,\n                        bidShares.creator.value,\n                        mintWithSigNonces[creator]++,\n                        sig.deadline\n                    )\n                )\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, sig.v, sig.r, sig.s);\n\n        require(\n            recoveredAddress != address(0) && creator == recoveredAddress,\n            \"Media: Signature invalid\"\n        );\n\n        _mintForCreator(recoveredAddress, data, bidShares);\n    }","contract":"Media","time":0},{"type":"external-function ","before":"function setAsk(uint256 tokenId, IMarket.Ask memory ask)\n    public\n    override\n    nonReentrant\n    onlyApprovedOrOwner(msg.sender, tokenId)\n    {\n        IMarket(marketContract).setAsk(tokenId, ask);\n    }","after":"function setAsk(uint256 tokenId, IMarket.Ask calldata ask)\n    public\n    override\n    nonReentrant\n    onlyApprovedOrOwner(msg.sender, tokenId)\n    {\n        IMarket(marketContract).setAsk(tokenId, ask);\n    }","contract":"Media","time":0},{"type":"external-function ","before":"function setBid(uint256 tokenId, IMarket.Bid memory bid)\n    public\n    override\n    nonReentrant\n    onlyExistingToken(tokenId)\n    {\n        require(msg.sender == bid.bidder, \"Market: Bidder must be msg sender\");\n        IMarket(marketContract).setBid(tokenId, bid, msg.sender);\n    }","after":"function setBid(uint256 tokenId, IMarket.Bid calldata bid)\n    public\n    override\n    nonReentrant\n    onlyExistingToken(tokenId)\n    {\n        require(msg.sender == bid.bidder, \"Market: Bidder must be msg sender\");\n        IMarket(marketContract).setBid(tokenId, bid, msg.sender);\n    }","contract":"Media","time":0},{"type":"external-function ","before":"function acceptBid(uint256 tokenId, IMarket.Bid memory bid)\n    public\n    override\n    nonReentrant\n    onlyApprovedOrOwner(msg.sender, tokenId)\n    {\n        IMarket(marketContract).acceptBid(tokenId, bid);\n    }","after":"function acceptBid(uint256 tokenId, IMarket.Bid calldata bid)\n    public\n    override\n    nonReentrant\n    onlyApprovedOrOwner(msg.sender, tokenId)\n    {\n        IMarket(marketContract).acceptBid(tokenId, bid);\n    }","contract":"Media","time":0},{"type":"external-function ","before":"function permit(\n        address spender,\n        uint256 tokenId,\n        EIP712Signature memory sig\n    ) public override nonReentrant onlyExistingToken(tokenId) {\n        require(\n            sig.deadline == 0 || sig.deadline >= block.timestamp,\n            \"Media: Permit expired\"\n        );\n        require(spender != address(0), \"Media: spender cannot be 0x0\");\n        bytes32 domainSeparator = _calculateDomainSeparator();\n\n        bytes32 digest =\n        keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        spender,\n                        tokenId,\n                        permitNonces[ownerOf(tokenId)][tokenId]++,\n                        sig.deadline\n                    )\n                )\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, sig.v, sig.r, sig.s);\n\n        require(\n            recoveredAddress != address(0) &&\n            ownerOf(tokenId) == recoveredAddress,\n            \"Media: Signature invalid\"\n        );\n\n        _approve(spender, tokenId);\n    }","after":"function permit(\n        address spender,\n        uint256 tokenId,\n        EIP712Signature calldata sig\n    ) public override nonReentrant onlyExistingToken(tokenId) {\n        require(\n            sig.deadline == 0 || sig.deadline >= block.timestamp,\n            \"Media: Permit expired\"\n        );\n        require(spender != address(0), \"Media: spender cannot be 0x0\");\n        bytes32 domainSeparator = _calculateDomainSeparator();\n\n        bytes32 digest =\n        keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                domainSeparator,\n                keccak256(\n                    abi.encode(\n                        PERMIT_TYPEHASH,\n                        spender,\n                        tokenId,\n                        permitNonces[ownerOf(tokenId)][tokenId]++,\n                        sig.deadline\n                    )\n                )\n            )\n        );\n\n        address recoveredAddress = ecrecover(digest, sig.v, sig.r, sig.s);\n\n        require(\n            recoveredAddress != address(0) &&\n            ownerOf(tokenId) == recoveredAddress,\n            \"Media: Signature invalid\"\n        );\n\n        _approve(spender, tokenId);\n    }","contract":"Media","time":0},{"type":"immutable-restrict-modification ","before":"address public marketContract;","after":"address public immutable marketContract;","contract":"Media","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"Media","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"Media","time":1}]}