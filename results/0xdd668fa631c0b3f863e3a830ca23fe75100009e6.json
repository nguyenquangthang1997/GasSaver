{"time":296,"results":[{"type":"struct-data-arrangement ","before":"\naddress component\naddress module\nint256 unit\nuint8 positionState\nbytes data","after":"int256 unit\nbytes data\naddress component\naddress module\nuint8 positionState\n","contract":"ISetToken","time":0},{"type":"loop-calculation","before":"ICErc20 cToken = underlyingToCToken[newBorrowAsset];","after":"// move outside for loop\nICErc20 cToken = underlyingToCToken[newBorrowAsset];","loc":{"start":{"line":6688,"column":12},"end":{"line":6688,"column":63}},"contract":"CompoundLeverageModule","time":0},{"type":"external-function ","before":"function lever(\n\n        ISetToken _setToken,\n\n        IERC20 _borrowAsset,\n\n        IERC20 _collateralAsset,\n\n        uint256 _borrowQuantity,\n\n        uint256 _minReceiveQuantity,\n\n        string memory _tradeAdapterName,\n\n        bytes memory _tradeData\n\n    )\n\n    external\n\n    nonReentrant\n\n    onlyManagerAndValidSet(_setToken)\n\n    {\n\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from \n\n        // collateral asset\n\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n\n            _setToken,\n\n            _borrowAsset,\n\n            _collateralAsset,\n\n            _borrowQuantity,\n\n            _minReceiveQuantity,\n\n            _tradeAdapterName,\n\n            true\n\n        );\n\n\n        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);\n\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n\n        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);\n\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n\n        emit LeverageIncreased(\n\n            _setToken,\n\n            _borrowAsset,\n\n            _collateralAsset,\n\n            leverInfo.exchangeAdapter,\n\n            leverInfo.notionalSendQuantity,\n\n            postTradeCollateralQuantity,\n\n            protocolFee\n\n        );\n\n    }","after":"function lever(\n\n        ISetToken _setToken,\n\n        IERC20 _borrowAsset,\n\n        IERC20 _collateralAsset,\n\n        uint256 _borrowQuantity,\n\n        uint256 _minReceiveQuantity,\n\n        string calldata _tradeAdapterName,\n\n        bytes calldata _tradeData\n\n    )\n\n    external\n\n    nonReentrant\n\n    onlyManagerAndValidSet(_setToken)\n\n    {\n\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from \n\n        // collateral asset\n\n        ActionInfo memory leverInfo = _createAndValidateActionInfo(\n\n            _setToken,\n\n            _borrowAsset,\n\n            _collateralAsset,\n\n            _borrowQuantity,\n\n            _minReceiveQuantity,\n\n            _tradeAdapterName,\n\n            true\n\n        );\n\n\n        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);\n\n\n        uint256 postTradeReceiveQuantity = _executeTrade(leverInfo, _borrowAsset, _collateralAsset, _tradeData);\n\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _collateralAsset, postTradeReceiveQuantity);\n\n\n        uint256 postTradeCollateralQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n\n        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);\n\n\n        _updateLeverPositions(leverInfo, _borrowAsset);\n\n\n        emit LeverageIncreased(\n\n            _setToken,\n\n            _borrowAsset,\n\n            _collateralAsset,\n\n            leverInfo.exchangeAdapter,\n\n            leverInfo.notionalSendQuantity,\n\n            postTradeCollateralQuantity,\n\n            protocolFee\n\n        );\n\n    }","contract":"CompoundLeverageModule","time":0},{"type":"external-function ","before":"function delever(\n\n        ISetToken _setToken,\n\n        IERC20 _collateralAsset,\n\n        IERC20 _repayAsset,\n\n        uint256 _redeemQuantity,\n\n        uint256 _minRepayQuantity,\n\n        string memory _tradeAdapterName,\n\n        bytes memory _tradeData\n\n    )\n\n    external\n\n    nonReentrant\n\n    onlyManagerAndValidSet(_setToken)\n\n    {\n\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from \n\n        // repay asset\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _repayAsset,\n\n            _redeemQuantity,\n\n            _minRepayQuantity,\n\n            _tradeAdapterName,\n\n            false\n\n        );\n\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);\n\n\n        _updateLeverPositions(deleverInfo, _repayAsset);\n\n\n        emit LeverageDecreased(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _repayAsset,\n\n            deleverInfo.exchangeAdapter,\n\n            deleverInfo.notionalSendQuantity,\n\n            repayQuantity,\n\n            protocolFee\n\n        );\n\n    }","after":"function delever(\n\n        ISetToken _setToken,\n\n        IERC20 _collateralAsset,\n\n        IERC20 _repayAsset,\n\n        uint256 _redeemQuantity,\n\n        uint256 _minRepayQuantity,\n\n        string calldata _tradeAdapterName,\n\n        bytes calldata _tradeData\n\n    )\n\n    external\n\n    nonReentrant\n\n    onlyManagerAndValidSet(_setToken)\n\n    {\n\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from \n\n        // repay asset\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfo(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _repayAsset,\n\n            _redeemQuantity,\n\n            _minRepayQuantity,\n\n            _tradeAdapterName,\n\n            false\n\n        );\n\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n\n        uint256 protocolFee = _accrueProtocolFee(_setToken, _repayAsset, postTradeReceiveQuantity);\n\n\n        uint256 repayQuantity = postTradeReceiveQuantity.sub(protocolFee);\n\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, repayQuantity);\n\n\n        _updateLeverPositions(deleverInfo, _repayAsset);\n\n\n        emit LeverageDecreased(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _repayAsset,\n\n            deleverInfo.exchangeAdapter,\n\n            deleverInfo.notionalSendQuantity,\n\n            repayQuantity,\n\n            protocolFee\n\n        );\n\n    }","contract":"CompoundLeverageModule","time":0},{"type":"external-function ","before":"function deleverToZeroBorrowBalance(\n\n        ISetToken _setToken,\n\n        IERC20 _collateralAsset,\n\n        IERC20 _repayAsset,\n\n        uint256 _redeemQuantity,\n\n        string memory _tradeAdapterName,\n\n        bytes memory _tradeData\n\n    )\n\n    external\n\n    nonReentrant\n\n    onlyManagerAndValidSet(_setToken)\n\n    {\n\n        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());\n\n\n        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], \"Borrow not enabled\");\n\n        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));\n\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _repayAsset,\n\n            notionalRedeemQuantity,\n\n            notionalRepayQuantity,\n\n            _tradeAdapterName,\n\n            false\n\n        );\n\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n\n        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);\n\n\n        // Update default position first to save gas on editing borrow position\n\n        _setToken.calculateAndEditDefaultPosition(\n\n            address(_repayAsset),\n\n            deleverInfo.setTotalSupply,\n\n            deleverInfo.preTradeReceiveTokenBalance\n\n        );\n\n\n        _updateLeverPositions(deleverInfo, _repayAsset);\n\n\n        emit LeverageDecreased(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _repayAsset,\n\n            deleverInfo.exchangeAdapter,\n\n            deleverInfo.notionalSendQuantity,\n\n            notionalRepayQuantity,\n\n            0 // No protocol fee\n\n        );\n\n    }","after":"function deleverToZeroBorrowBalance(\n\n        ISetToken _setToken,\n\n        IERC20 _collateralAsset,\n\n        IERC20 _repayAsset,\n\n        uint256 _redeemQuantity,\n\n        string calldata _tradeAdapterName,\n\n        bytes calldata _tradeData\n\n    )\n\n    external\n\n    nonReentrant\n\n    onlyManagerAndValidSet(_setToken)\n\n    {\n\n        uint256 notionalRedeemQuantity = _redeemQuantity.preciseMul(_setToken.totalSupply());\n\n\n        require(borrowCTokenEnabled[_setToken][underlyingToCToken[_repayAsset]], \"Borrow not enabled\");\n\n        uint256 notionalRepayQuantity = underlyingToCToken[_repayAsset].borrowBalanceCurrent(address(_setToken));\n\n\n        ActionInfo memory deleverInfo = _createAndValidateActionInfoNotional(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _repayAsset,\n\n            notionalRedeemQuantity,\n\n            notionalRepayQuantity,\n\n            _tradeAdapterName,\n\n            false\n\n        );\n\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n\n        uint256 postTradeReceiveQuantity = _executeTrade(deleverInfo, _collateralAsset, _repayAsset, _tradeData);\n\n\n        // We use notionalRepayQuantity vs. Compound's max value uint256(-1) to handle WETH properly\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, notionalRepayQuantity);\n\n\n        // Update default position first to save gas on editing borrow position\n\n        _setToken.calculateAndEditDefaultPosition(\n\n            address(_repayAsset),\n\n            deleverInfo.setTotalSupply,\n\n            deleverInfo.preTradeReceiveTokenBalance\n\n        );\n\n\n        _updateLeverPositions(deleverInfo, _repayAsset);\n\n\n        emit LeverageDecreased(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _repayAsset,\n\n            deleverInfo.exchangeAdapter,\n\n            deleverInfo.notionalSendQuantity,\n\n            notionalRepayQuantity,\n\n            0 // No protocol fee\n\n        );\n\n    }","contract":"CompoundLeverageModule","time":0},{"type":"external-function ","before":"function initialize(\n\n        ISetToken _setToken,\n\n        IERC20[] memory _collateralAssets,\n\n        IERC20[] memory _borrowAssets\n\n    )\n\n    external\n\n    onlySetManager(_setToken, msg.sender)\n\n    onlyValidAndPendingSet(_setToken)\n\n    {\n\n        if (!anySetAllowed) {\n\n            require(allowedSetTokens[_setToken], \"Not allowed SetToken\");\n\n        }\n\n\n        // Initialize module before trying register\n\n        _setToken.initializeModule();\n\n\n        // Get debt issuance module registered to this module and require that it is initialized\n\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), \"Issuance not initialized\");\n\n\n        // Try if register exists on any of the modules including the debt issuance module\n\n        address[] memory modules = _setToken.getModules();\n\n        for (uint256 i = 0; i < modules.length; i++) {\n\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n\n        }\n\n\n        // Enable collateral and borrow assets on Compound\n\n        addCollateralAssets(_setToken, _collateralAssets);\n\n\n        addBorrowAssets(_setToken, _borrowAssets);\n\n    }","after":"function initialize(\n\n        ISetToken _setToken,\n\n        IERC20[] calldata _collateralAssets,\n\n        IERC20[] calldata _borrowAssets\n\n    )\n\n    external\n\n    onlySetManager(_setToken, msg.sender)\n\n    onlyValidAndPendingSet(_setToken)\n\n    {\n\n        if (!anySetAllowed) {\n\n            require(allowedSetTokens[_setToken], \"Not allowed SetToken\");\n\n        }\n\n\n        // Initialize module before trying register\n\n        _setToken.initializeModule();\n\n\n        // Get debt issuance module registered to this module and require that it is initialized\n\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), \"Issuance not initialized\");\n\n\n        // Try if register exists on any of the modules including the debt issuance module\n\n        address[] memory modules = _setToken.getModules();\n\n        for (uint256 i = 0; i < modules.length; i++) {\n\n            try IDebtIssuanceModule(modules[i]).registerToIssuanceModule(_setToken) {} catch {}\n\n        }\n\n\n        // Enable collateral and borrow assets on Compound\n\n        addCollateralAssets(_setToken, _collateralAssets);\n\n\n        addBorrowAssets(_setToken, _borrowAssets);\n\n    }","contract":"CompoundLeverageModule","time":0},{"type":"external-function ","before":"function removeCollateralAssets(ISetToken _setToken, IERC20[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n\n        // Sync Compound and SetToken positions prior to any removal action\n\n        sync(_setToken, true);\n\n\n        for (uint256 i = 0; i < _collateralAssets.length; i++) {\n\n            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];\n\n            require(collateralCTokenEnabled[_setToken][cToken], \"Collateral not enabled\");\n\n\n            // Note: Will only exit market if cToken is not enabled as a borrow asset as well\n\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n\n                _setToken.invokeExitMarket(cToken, comptroller);\n\n            }\n\n\n            delete collateralCTokenEnabled[_setToken][cToken];\n\n            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));\n\n        }\n\n\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n\n    }","after":"function removeCollateralAssets(ISetToken _setToken, IERC20[] calldata _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n\n        // Sync Compound and SetToken positions prior to any removal action\n\n        sync(_setToken, true);\n\n\n        for (uint256 i = 0; i < _collateralAssets.length; i++) {\n\n            ICErc20 cToken = underlyingToCToken[_collateralAssets[i]];\n\n            require(collateralCTokenEnabled[_setToken][cToken], \"Collateral not enabled\");\n\n\n            // Note: Will only exit market if cToken is not enabled as a borrow asset as well\n\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n\n            if (!borrowCTokenEnabled[_setToken][cToken]) {\n\n                _setToken.invokeExitMarket(cToken, comptroller);\n\n            }\n\n\n            delete collateralCTokenEnabled[_setToken][cToken];\n\n            enabledAssets[_setToken].collateralCTokens.removeStorage(address(cToken));\n\n        }\n\n\n        emit CollateralAssetsUpdated(_setToken, false, _collateralAssets);\n\n    }","contract":"CompoundLeverageModule","time":0},{"type":"external-function ","before":"function removeBorrowAssets(ISetToken _setToken, IERC20[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n\n        // Sync Compound and SetToken positions prior to any removal action\n\n        sync(_setToken, true);\n\n\n        for (uint256 i = 0; i < _borrowAssets.length; i++) {\n\n            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];\n\n            require(borrowCTokenEnabled[_setToken][cToken], \"Borrow not enabled\");\n\n\n            // Note: Will only exit market if cToken is not enabled as a collateral asset as well\n\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n\n                _setToken.invokeExitMarket(cToken, comptroller);\n\n            }\n\n\n            delete borrowCTokenEnabled[_setToken][cToken];\n\n            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));\n\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));\n\n        }\n\n\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n\n    }","after":"function removeBorrowAssets(ISetToken _setToken, IERC20[] calldata _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n\n        // Sync Compound and SetToken positions prior to any removal action\n\n        sync(_setToken, true);\n\n\n        for (uint256 i = 0; i < _borrowAssets.length; i++) {\n\n            ICErc20 cToken = underlyingToCToken[_borrowAssets[i]];\n\n            require(borrowCTokenEnabled[_setToken][cToken], \"Borrow not enabled\");\n\n\n            // Note: Will only exit market if cToken is not enabled as a collateral asset as well\n\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n\n            if (!collateralCTokenEnabled[_setToken][cToken]) {\n\n                _setToken.invokeExitMarket(cToken, comptroller);\n\n            }\n\n\n            delete borrowCTokenEnabled[_setToken][cToken];\n\n            enabledAssets[_setToken].borrowCTokens.removeStorage(address(cToken));\n\n            enabledAssets[_setToken].borrowAssets.removeStorage(address(_borrowAssets[i]));\n\n        }\n\n\n        emit BorrowAssetsUpdated(_setToken, false, _borrowAssets);\n\n    }","contract":"CompoundLeverageModule","time":0}]}