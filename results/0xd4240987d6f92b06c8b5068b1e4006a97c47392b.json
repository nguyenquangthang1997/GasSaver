{"time":163,"results":[{"type":"external-function ","before":" function issueRebalancingSetWithEther(\n\n        address _rebalancingSetAddress,\n\n        uint256 _rebalancingSetQuantity,\n\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\n\n        bytes memory _orderData,\n\n        bool _keepChangeInVault\n\n    )\n\n    public\n\n    payable\n\n    nonReentrant\n\n    {\n\n        // Wrap all Ether; Wrapped Ether could be a component of the Set being issued.\n\n        wethInstance.deposit.value(msg.value)();\n\n\n        // Perform exchange transactions, mint the base SetToken, and issue the Rebalancing Set to the sender\n\n        issueRebalancingSetInternal(\n\n            _rebalancingSetAddress,\n\n            _rebalancingSetQuantity,\n\n            address(wethInstance),\n\n            msg.value,\n\n            _exchangeIssuanceParams,\n\n            _orderData,\n\n            _keepChangeInVault\n\n        );\n\n\n        // unwrap any leftover WETH and transfer to sender\n\n        uint256 leftoverWeth = ERC20Wrapper.balanceOf(address(wethInstance), address(this));\n\n        if (leftoverWeth > 0) {\n\n            // Withdraw wrapped Ether\n\n            wethInstance.withdraw(leftoverWeth);\n\n\n            // Transfer ether to user\n\n            msg.sender.transfer(leftoverWeth);\n\n        }\n\n\n        emit LogPayableExchangeIssue(\n\n            _rebalancingSetAddress,\n\n            msg.sender,\n\n            address(wethInstance),\n\n            _rebalancingSetQuantity,\n\n            leftoverWeth\n\n        );\n\n    ","after":" function issueRebalancingSetWithEther(\n\n        address _rebalancingSetAddress,\n\n        uint256 _rebalancingSetQuantity,\n\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams calldata _exchangeIssuanceParams,\n\n        bytes calldata _orderData,\n\n        bool _keepChangeInVault\n\n    )\n\n    public\n\n    payable\n\n    nonReentrant\n\n    {\n\n        // Wrap all Ether; Wrapped Ether could be a component of the Set being issued.\n\n        wethInstance.deposit.value(msg.value)();\n\n\n        // Perform exchange transactions, mint the base SetToken, and issue the Rebalancing Set to the sender\n\n        issueRebalancingSetInternal(\n\n            _rebalancingSetAddress,\n\n            _rebalancingSetQuantity,\n\n            address(wethInstance),\n\n            msg.value,\n\n            _exchangeIssuanceParams,\n\n            _orderData,\n\n            _keepChangeInVault\n\n        );\n\n\n        // unwrap any leftover WETH and transfer to sender\n\n        uint256 leftoverWeth = ERC20Wrapper.balanceOf(address(wethInstance), address(this));\n\n        if (leftoverWeth > 0) {\n\n            // Withdraw wrapped Ether\n\n            wethInstance.withdraw(leftoverWeth);\n\n\n            // Transfer ether to user\n\n            msg.sender.transfer(leftoverWeth);\n\n        }\n\n\n        emit LogPayableExchangeIssue(\n\n            _rebalancingSetAddress,\n\n            msg.sender,\n\n            address(wethInstance),\n\n            _rebalancingSetQuantity,\n\n            leftoverWeth\n\n        );\n\n    ","contract":"RebalancingSetExchangeIssuanceModule","time":0},{"type":"external-function ","before":" function issueRebalancingSetWithERC20(\n\n        address _rebalancingSetAddress,\n\n        uint256 _rebalancingSetQuantity,\n\n        address _paymentTokenAddress,\n\n        uint256 _paymentTokenQuantity,\n\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\n\n        bytes memory _orderData,\n\n        bool _keepChangeInVault\n\n    )\n\n    public\n\n    nonReentrant\n\n    {\n\n        // Deposit the erc20 to this contract. The token must be approved the caller to the transferProxy\n\n        coreInstance.transferModule(\n\n            _paymentTokenAddress,\n\n            _paymentTokenQuantity,\n\n            msg.sender,\n\n            address(this)\n\n        );\n\n\n        // Perform exchange transactions, mint the base SetToken, and issue the Rebalancing Set to the sender\n\n        issueRebalancingSetInternal(\n\n            _rebalancingSetAddress,\n\n            _rebalancingSetQuantity,\n\n            _paymentTokenAddress,\n\n            _paymentTokenQuantity,\n\n            _exchangeIssuanceParams,\n\n            _orderData,\n\n            _keepChangeInVault\n\n        );\n\n\n        // Send back any unused payment token\n\n        uint256 leftoverPaymentTokenQuantity = ERC20Wrapper.balanceOf(_paymentTokenAddress, address(this));\n\n        if (leftoverPaymentTokenQuantity > 0) {\n\n            ERC20Wrapper.transfer(\n\n                _paymentTokenAddress,\n\n                msg.sender,\n\n                leftoverPaymentTokenQuantity\n\n            );\n\n        }\n\n\n        emit LogPayableExchangeIssue(\n\n            _rebalancingSetAddress,\n\n            msg.sender,\n\n            _paymentTokenAddress,\n\n            _rebalancingSetQuantity,\n\n            leftoverPaymentTokenQuantity\n\n        );\n\n    ","after":" function issueRebalancingSetWithERC20(\n\n        address _rebalancingSetAddress,\n\n        uint256 _rebalancingSetQuantity,\n\n        address _paymentTokenAddress,\n\n        uint256 _paymentTokenQuantity,\n\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams calldata _exchangeIssuanceParams,\n\n        bytes calldata _orderData,\n\n        bool _keepChangeInVault\n\n    )\n\n    public\n\n    nonReentrant\n\n    {\n\n        // Deposit the erc20 to this contract. The token must be approved the caller to the transferProxy\n\n        coreInstance.transferModule(\n\n            _paymentTokenAddress,\n\n            _paymentTokenQuantity,\n\n            msg.sender,\n\n            address(this)\n\n        );\n\n\n        // Perform exchange transactions, mint the base SetToken, and issue the Rebalancing Set to the sender\n\n        issueRebalancingSetInternal(\n\n            _rebalancingSetAddress,\n\n            _rebalancingSetQuantity,\n\n            _paymentTokenAddress,\n\n            _paymentTokenQuantity,\n\n            _exchangeIssuanceParams,\n\n            _orderData,\n\n            _keepChangeInVault\n\n        );\n\n\n        // Send back any unused payment token\n\n        uint256 leftoverPaymentTokenQuantity = ERC20Wrapper.balanceOf(_paymentTokenAddress, address(this));\n\n        if (leftoverPaymentTokenQuantity > 0) {\n\n            ERC20Wrapper.transfer(\n\n                _paymentTokenAddress,\n\n                msg.sender,\n\n                leftoverPaymentTokenQuantity\n\n            );\n\n        }\n\n\n        emit LogPayableExchangeIssue(\n\n            _rebalancingSetAddress,\n\n            msg.sender,\n\n            _paymentTokenAddress,\n\n            _rebalancingSetQuantity,\n\n            leftoverPaymentTokenQuantity\n\n        );\n\n    ","contract":"RebalancingSetExchangeIssuanceModule","time":0},{"type":"external-function ","before":" function redeemRebalancingSetIntoEther(\n\n        address _rebalancingSetAddress,\n\n        uint256 _rebalancingSetQuantity,\n\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\n\n        bytes memory _orderData,\n\n        bool _keepChangeInVault\n\n    )\n\n    public\n\n    nonReentrant\n\n    {\n\n        // Redeems the rebalancing Set into the base SetToken, redeems the base SetToken into its components,\n\n        // and exchanges the components into wrapped ether to this contract.\n\n        redeemRebalancingSetIntoComponentsInternal(\n\n            _rebalancingSetAddress,\n\n            _rebalancingSetQuantity,\n\n            address(wethInstance),\n\n            _exchangeIssuanceParams,\n\n            _orderData\n\n        );\n\n\n        // In the event that exchangeIssue returns more receiveTokens or wrappedEth than\n\n        // specified in receiveToken quantity, those tokens are also retrieved into this contract.\n\n        // We also call this ahead of returnRedemptionChange to allow the unwrapping of the wrappedEther\n\n        uint256 wethQuantityInVault = vaultInstance.getOwnerBalance(address(wethInstance), address(this));\n\n        if (wethQuantityInVault > 0) {\n\n            coreInstance.withdrawModule(\n\n                address(this),\n\n                address(this),\n\n                address(wethInstance),\n\n                wethQuantityInVault\n\n            );\n\n        }\n\n\n        // Unwrap wrapped Ether and transfer Eth to user\n\n        uint256 wethBalance = ERC20Wrapper.balanceOf(address(wethInstance), address(this));\n\n        if (wethBalance > 0) {\n\n            wethInstance.withdraw(wethBalance);\n\n            msg.sender.transfer(wethBalance);\n\n        }\n\n\n        address baseSetAddress = _exchangeIssuanceParams.setAddress;\n\n\n        // Send excess base Set to the user\n\n        returnExcessBaseSetFromContract(\n\n            baseSetAddress,\n\n            msg.sender,\n\n            _keepChangeInVault\n\n        );\n\n\n        // Return non-exchanged components to the user\n\n        returnExcessComponentsFromContract(ISetToken(baseSetAddress), msg.sender);\n\n\n        emit LogPayableExchangeRedeem(\n\n            _rebalancingSetAddress,\n\n            msg.sender,\n\n            address(wethInstance),\n\n            _rebalancingSetQuantity,\n\n            wethBalance\n\n        );\n\n    ","after":" function redeemRebalancingSetIntoEther(\n\n        address _rebalancingSetAddress,\n\n        uint256 _rebalancingSetQuantity,\n\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams calldata _exchangeIssuanceParams,\n\n        bytes calldata _orderData,\n\n        bool _keepChangeInVault\n\n    )\n\n    public\n\n    nonReentrant\n\n    {\n\n        // Redeems the rebalancing Set into the base SetToken, redeems the base SetToken into its components,\n\n        // and exchanges the components into wrapped ether to this contract.\n\n        redeemRebalancingSetIntoComponentsInternal(\n\n            _rebalancingSetAddress,\n\n            _rebalancingSetQuantity,\n\n            address(wethInstance),\n\n            _exchangeIssuanceParams,\n\n            _orderData\n\n        );\n\n\n        // In the event that exchangeIssue returns more receiveTokens or wrappedEth than\n\n        // specified in receiveToken quantity, those tokens are also retrieved into this contract.\n\n        // We also call this ahead of returnRedemptionChange to allow the unwrapping of the wrappedEther\n\n        uint256 wethQuantityInVault = vaultInstance.getOwnerBalance(address(wethInstance), address(this));\n\n        if (wethQuantityInVault > 0) {\n\n            coreInstance.withdrawModule(\n\n                address(this),\n\n                address(this),\n\n                address(wethInstance),\n\n                wethQuantityInVault\n\n            );\n\n        }\n\n\n        // Unwrap wrapped Ether and transfer Eth to user\n\n        uint256 wethBalance = ERC20Wrapper.balanceOf(address(wethInstance), address(this));\n\n        if (wethBalance > 0) {\n\n            wethInstance.withdraw(wethBalance);\n\n            msg.sender.transfer(wethBalance);\n\n        }\n\n\n        address baseSetAddress = _exchangeIssuanceParams.setAddress;\n\n\n        // Send excess base Set to the user\n\n        returnExcessBaseSetFromContract(\n\n            baseSetAddress,\n\n            msg.sender,\n\n            _keepChangeInVault\n\n        );\n\n\n        // Return non-exchanged components to the user\n\n        returnExcessComponentsFromContract(ISetToken(baseSetAddress), msg.sender);\n\n\n        emit LogPayableExchangeRedeem(\n\n            _rebalancingSetAddress,\n\n            msg.sender,\n\n            address(wethInstance),\n\n            _rebalancingSetQuantity,\n\n            wethBalance\n\n        );\n\n    ","contract":"RebalancingSetExchangeIssuanceModule","time":0},{"type":"external-function ","before":" function redeemRebalancingSetIntoERC20(\n\n        address _rebalancingSetAddress,\n\n        uint256 _rebalancingSetQuantity,\n\n        address _outputTokenAddress,\n\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\n\n        bytes memory _orderData,\n\n        bool _keepChangeInVault\n\n    )\n\n    public\n\n    nonReentrant\n\n    {\n\n        // Redeems the rebalancing Set into the base SetToken, redeems the base SetToken into its components,\n\n        // and exchanges the components into the receiveToken to this contract.\n\n        redeemRebalancingSetIntoComponentsInternal(\n\n            _rebalancingSetAddress,\n\n            _rebalancingSetQuantity,\n\n            _outputTokenAddress,\n\n            _exchangeIssuanceParams,\n\n            _orderData\n\n        );\n\n\n        // In the event that exchangeIssue returns more outputTokens than\n\n        // specified in receiveToken quantity, those tokens are also retrieved into this contract.\n\n        uint256 outputTokenInVault = vaultInstance.getOwnerBalance(_outputTokenAddress, address(this));\n\n        if (outputTokenInVault > 0) {\n\n            coreInstance.withdrawModule(\n\n                address(this),\n\n                address(this),\n\n                _outputTokenAddress,\n\n                outputTokenInVault\n\n            );\n\n        }\n\n\n        // Transfer outputToken to the caller\n\n        uint256 outputTokenBalance = ERC20Wrapper.balanceOf(_outputTokenAddress, address(this));\n\n        ERC20Wrapper.transfer(\n\n            _outputTokenAddress,\n\n            msg.sender,\n\n            outputTokenBalance\n\n        );\n\n\n        address baseSetAddress = _exchangeIssuanceParams.setAddress;\n\n\n        // Send excess base SetToken to the user\n\n        returnExcessBaseSetFromContract(\n\n            baseSetAddress,\n\n            msg.sender,\n\n            _keepChangeInVault\n\n        );\n\n\n        // Non-exchanged base SetToken components are returned to the user\n\n        returnExcessComponentsFromContract(ISetToken(baseSetAddress), msg.sender);\n\n\n        emit LogPayableExchangeRedeem(\n\n            _rebalancingSetAddress,\n\n            msg.sender,\n\n            _outputTokenAddress,\n\n            _rebalancingSetQuantity,\n\n            outputTokenBalance\n\n        );\n\n    ","after":" function redeemRebalancingSetIntoERC20(\n\n        address _rebalancingSetAddress,\n\n        uint256 _rebalancingSetQuantity,\n\n        address _outputTokenAddress,\n\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams calldata _exchangeIssuanceParams,\n\n        bytes calldata _orderData,\n\n        bool _keepChangeInVault\n\n    )\n\n    public\n\n    nonReentrant\n\n    {\n\n        // Redeems the rebalancing Set into the base SetToken, redeems the base SetToken into its components,\n\n        // and exchanges the components into the receiveToken to this contract.\n\n        redeemRebalancingSetIntoComponentsInternal(\n\n            _rebalancingSetAddress,\n\n            _rebalancingSetQuantity,\n\n            _outputTokenAddress,\n\n            _exchangeIssuanceParams,\n\n            _orderData\n\n        );\n\n\n        // In the event that exchangeIssue returns more outputTokens than\n\n        // specified in receiveToken quantity, those tokens are also retrieved into this contract.\n\n        uint256 outputTokenInVault = vaultInstance.getOwnerBalance(_outputTokenAddress, address(this));\n\n        if (outputTokenInVault > 0) {\n\n            coreInstance.withdrawModule(\n\n                address(this),\n\n                address(this),\n\n                _outputTokenAddress,\n\n                outputTokenInVault\n\n            );\n\n        }\n\n\n        // Transfer outputToken to the caller\n\n        uint256 outputTokenBalance = ERC20Wrapper.balanceOf(_outputTokenAddress, address(this));\n\n        ERC20Wrapper.transfer(\n\n            _outputTokenAddress,\n\n            msg.sender,\n\n            outputTokenBalance\n\n        );\n\n\n        address baseSetAddress = _exchangeIssuanceParams.setAddress;\n\n\n        // Send excess base SetToken to the user\n\n        returnExcessBaseSetFromContract(\n\n            baseSetAddress,\n\n            msg.sender,\n\n            _keepChangeInVault\n\n        );\n\n\n        // Non-exchanged base SetToken components are returned to the user\n\n        returnExcessComponentsFromContract(ISetToken(baseSetAddress), msg.sender);\n\n\n        emit LogPayableExchangeRedeem(\n\n            _rebalancingSetAddress,\n\n            msg.sender,\n\n            _outputTokenAddress,\n\n            _rebalancingSetQuantity,\n\n            outputTokenBalance\n\n        );\n\n    ","contract":"RebalancingSetExchangeIssuanceModule","time":0}]}