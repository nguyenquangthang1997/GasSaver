{"time":690,"results":[{"type":"external-function ","before":"=> uint256) _operatorToGrant;\n    }\n\n    /// @notice Tries to capture delegation data if the pending delegation has\n    /// been created from a grant. There are only two possibilities and they\n    /// need to be handled differently: delegation comes from the TokenGrant\n    /// contract or delegation comes from TokenStakingEscrow. In those two cases\n    /// grant ID has to be captured in a different way.\n    /// @dev In case of a delegation from the escrow, it is expected that grant\n    /// ID is passed in extraData bytes array. When the delegation comes from\n    /// the TokenGrant contract, dele","after":"=> uint256) _operatorToGrant;\n    }\n\n    /// @notice Tries to capture delegation data if the pending delegation has\n    /// been created from a grant. There are only two possibilities and they\n    /// need to be handled differently: delegation comes from the TokenGrant\n    /// contract or delegation comes from TokenStakingEscrow. In those two cases\n    /// grant ID has to be captured in a different way.\n    /// @dev In case of a delegation from the escrow, it is expected that grant\n    /// ID is passed in extraData bytes array. When the delegation comes from\n    /// the TokenGrant contract, dele","contract":"GrantStaking","time":0},{"type":"external-function ","before":"eceiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external;}\n\n/// @title KEEP Token\n/// @dev Standard ERC20Burnable token\ncontract KeepToken is ERC20Burnable, ERC20Detailed {\n    string public constant NAME = \"KEEP Token\";\n    string public constant SYMBOL = \"KEEP\";\n    uint8 public constant DECIMAL","after":"eceiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external;}\n\n/// @title KEEP Token\n/// @dev Standard ERC20Burnable token\ncontract KeepToken is ERC20Burnable, ERC20Detailed {\n    string public constant NAME = \"KEEP Token\";\n    string public constant SYMBOL = \"KEEP\";\n    uint8 public constant DECIMAL","contract":"KeepToken","time":0},{"type":"immutable-restrict-modification ","before":"\n     */\n    function","after":"\n     */\n    function","contract":"KeepToken","time":0},{"type":"immutable-restrict-modification ","before":"nFrom(address account, ","after":"nFrom(address account, ","contract":"KeepToken","time":0},{"type":"immutable-restrict-modification ","before":"56 amount) internal {\n  ","after":"56 amount) internal {\n  ","contract":"KeepToken","time":0},{"type":"external-function ","before":"antee == _newGrantee,\n            \"Reassignment address mismatch\"\n        );\n        grantee = requestedNewGrantee;\n        requestedNewGrantee = address(0);\n        emit GranteeReassignmentConfirmed(oldGrantee, _","after":"antee == _newGrantee,\n            \"Reassignment address mismatch\"\n        );\n        grantee = requestedNewGrantee;\n        requestedNewGrantee = address(0);\n        emit GranteeReassignmentConfirmed(oldGrantee, _","contract":"ManagedGrant","time":0},{"type":"immutable-restrict-modification ","before":" uint256[] memory expiration","after":" uint256[] memory expiration","contract":"ManagedGrant","time":0},{"type":"immutable-restrict-modification ","before":"        uint256 lockCou","after":"        uint256 lockCou","contract":"ManagedGrant","time":0},{"type":"struct-data-arrangement ","before":"\nt();\n    }\n\n    /// \nhe specified op\nf(address _operat\nowner;\n    }\n\n    ///\nress.\n    /// @return Be\npublic view re\ntor].beneficia\nr for the specif\ness _operator\norizer;\n    }\ncts/token/ERC20/E\ncts/token/ERC2\nracts/math/SafeMath.sol\";\nimport","after":"f(address _operat\nowner;\n    }\n\n    ///\nress.\n    /// @return Be\ntor].beneficia\nr for the specif\ness _operator\norizer;\n    }\ncts/token/ERC20/E\ncts/token/ERC2\nracts/math/SafeMath.sol\";\nimport\nt();\n    }\n\n    /// \nhe specified op\npublic view re\n","contract":"TokenGrant","time":0},{"type":"external-function ","before":"antManager The address to query.\n    /// @return An uint256 array of grant IDs.\n    function getGrants(address _granteeOrGrantManager) public view returns (uint256[] memory) {\n        return grantIndices[_granteeOrGrantManager];\n    }\n\n    /// @notice Gets operator addresses of the specified grantee address.\n    /// @param grantee The grantee address.\n    /// @return An array of all operators for a given grantee.\n    function getGranteeOperators(address grantee) public view returns (address[] memory) {\n        return granteesToOperators[grantee];\n    }\n\n    /// @notice Gets grant stake details of the given operator.\n    /// @param operator The operator address.\n    /// @return grantId ID of the token grant.\n    /// @return amount The amount of tokens the given operator delegated.\n    /// @return stakingContract The address of staking contract.\n    function getGrantStakeDetails(address operator) public view returns (uint256 grantId, uint256 amount, address stakingContract) {\n        return grantStakes[operator].getDetails();\n    }\n\n\n    /// @notice Receives approval of token transfer and creates a token grant with a unlocking\n    /// schedule where balance withdrawn to the grantee gradually in a linear fashion until\n    /// start + duration. By then all of the balance will have unlocked.\n    /// @param _from The owner of the tokens who approved them to transfer.\n    /// @param _amount Approved amount for the transfer to create token grant.\n    /// @param _token Token contract address.\n    /// @param _extraData This byte array must have the following values ABI encoded:\n    /// grantManager (address) Address of the grant manager.\n    /// grantee (address) Address of the grantee.\n    /// duration (uint256) D","after":"antManager The address to query.\n    /// @return An uint256 array of grant IDs.\n    function getGrants(address _granteeOrGrantManager) public view returns (uint256[] memory) {\n        return grantIndices[_granteeOrGrantManager];\n    }\n\n    /// @notice Gets operator addresses of the specified grantee address.\n    /// @param grantee The grantee address.\n    /// @return An array of all operators for a given grantee.\n    function getGranteeOperators(address grantee) public view returns (address[] memory) {\n        return granteesToOperators[grantee];\n    }\n\n    /// @notice Gets grant stake details of the given operator.\n    /// @param operator The operator address.\n    /// @return grantId ID of the token grant.\n    /// @return amount The amount of tokens the given operator delegated.\n    /// @return stakingContract The address of staking contract.\n    function getGrantStakeDetails(address operator) public view returns (uint256 grantId, uint256 amount, address stakingContract) {\n        return grantStakes[operator].getDetails();\n    }\n\n\n    /// @notice Receives approval of token transfer and creates a token grant with a unlocking\n    /// schedule where balance withdrawn to the grantee gradually in a linear fashion until\n    /// start + duration. By then all of the balance will have unlocked.\n    /// @param _from The owner of the tokens who approved them to transfer.\n    /// @param _amount Approved amount for the transfer to create token grant.\n    /// @param _token Token contract address.\n    /// @param _extraData This byte array must have the following values ABI encoded:\n    /// grantManager (address) Address of the grant manager.\n    /// grantee (address) Address of the grantee.\n    /// duration (uint256) D","contract":"TokenGrant","time":0},{"type":"external-function ","before":".grantee] = balances[grants[_id].grantee].sub(revokedAmount);\n        emit TokenGrantRevoked(_id);\n    }\n\n    /// @notice Allows the grant manager to withdraw revoked tokens.\n    /// @dev Will withdraw as many of the revoked tokens as possible\n    /// without pushing the grant contract into a token deficit.\n    /// If the grantee has staked more tokens than the unlocked amount,\n    /// those tokens will remain in the grant until undelegated and returned,\n    /// after which they can be withdrawn by calling `withdrawRevoked` again.\n    /// @param _id Grant ID.\n    function withdrawRevoked(uint256 _id) public {\n        Grant storage grant = grants[_id];\n        require(\n            grant.grantManager == msg.sender,\n            \"Only grant manager can withdraw revoked tokens.\"\n        );\n        uint256 revoked = grant.revokedAmount;\n        uint256 revokedWithdrawn = grant.revokedWithdrawn;\n        require(revokedWithdrawn < revoked, \"All revoked tokens withdrawn.\");\n\n        uint256 revokedRemaining = revoked.sub(revokedWithdrawn);\n\n        uint256 totalAmount = grant.amount;\n        uint256 staked = grant.staked;\n        uint256 granteeWithdrawn = grant.withdrawn;\n        uint256 remainingPresentInGrant =\n        totalAmount.sub(staked).sub(revokedWithdrawn).sub(granteeWithdrawn);\n\n        require(remainingPresentInGrant > 0, \"No revoked tokens withdrawable.\");\n\n        uint256 amountToWithdraw = remainingPresentInGrant < revokedRemaining\n        ? remainingPresentInG","after":".grantee] = balances[grants[_id].grantee].sub(revokedAmount);\n        emit TokenGrantRevoked(_id);\n    }\n\n    /// @notice Allows the grant manager to withdraw revoked tokens.\n    /// @dev Will withdraw as many of the revoked tokens as possible\n    /// without pushing the grant contract into a token deficit.\n    /// If the grantee has staked more tokens than the unlocked amount,\n    /// those tokens will remain in the grant until undelegated and returned,\n    /// after which they can be withdrawn by calling `withdrawRevoked` again.\n    /// @param _id Grant ID.\n    function withdrawRevoked(uint256 _id) public {\n        Grant storage grant = grants[_id];\n        require(\n            grant.grantManager == msg.sender,\n            \"Only grant manager can withdraw revoked tokens.\"\n        );\n        uint256 revoked = grant.revokedAmount;\n        uint256 revokedWithdrawn = grant.revokedWithdrawn;\n        require(revokedWithdrawn < revoked, \"All revoked tokens withdrawn.\");\n\n        uint256 revokedRemaining = revoked.sub(revokedWithdrawn);\n\n        uint256 totalAmount = grant.amount;\n        uint256 staked = grant.staked;\n        uint256 granteeWithdrawn = grant.withdrawn;\n        uint256 remainingPresentInGrant =\n        totalAmount.sub(staked).sub(revokedWithdrawn).sub(granteeWithdrawn);\n\n        require(remainingPresentInGrant > 0, \"No revoked tokens withdrawable.\");\n\n        uint256 amountToWithdraw = remainingPresentInGrant < revokedRemaining\n        ? remainingPresentInG","contract":"TokenGrant","time":0},{"type":"external-function ","before":"require(\n            msg.sender == grants[grantId].grantManager,\n            \"Only grant manager can force undelegation of revoked grant stake\"\n        );\n\n        grantStake.undelegate();\n    }\n\n    /// @notice Recover stake of the token grant.\n    /// Recovers the tokens correctly\n    /// even if they were earlie","after":"require(\n            msg.sender == grants[grantId].grantManager,\n            \"Only grant manager can force undelegation of revoked grant stake\"\n        );\n\n        grantStake.undelegate();\n    }\n\n    /// @notice Recover stake of the token grant.\n    /// Recovers the tokens correctly\n    /// even if they were earlie","contract":"TokenGrantStake","time":0},{"type":"immutable-restrict-modification ","before":"       );\n\n        ","after":"       );\n\n        ","contract":"TokenGrantStake","time":0},{"type":"immutable-restrict-modification ","before":"      grants[gra","after":"      grants[gra","contract":"TokenGrantStake","time":0},{"type":"external-function ","before":"@param _tokenGrant KEEP token grant contract.\n    /// @param _escrow Escrow dedicated for this staking contract.\n    /// @param _registry Keep contract registry contract.\n    /// @param _initializationPeriod To avoid certain attacks on work selection, recently created\n    /// operators must wait for a specific period of time before being eligible for work selection.\n    constructor(\n        ERC20Burnable _token,\n        TokenGrant _tokenGrant,\n        TokenStakingEscrow _escrow,\n        KeepRegistry _registry,\n        uint256 _initializationPeriod\n    ) Authorizations(_registry) public {\n        token = _token;\n        tokenGrant = _tokenGrant;\n        escrow = _escrow;\n        registry = _registry;\n        initializationPeriod = _initializationPeriod;\n        deployedAt = block.timestamp;\n    }\n\n    /// @notice Returns minimum amount of KEEP that allows sMPC cluster client to\n    /// participate in the Keep network. Expressed as numb","after":"@param _tokenGrant KEEP token grant contract.\n    /// @param _escrow Escrow dedicated for this staking contract.\n    /// @param _registry Keep contract registry contract.\n    /// @param _initializationPeriod To avoid certain attacks on work selection, recently created\n    /// operators must wait for a specific period of time before being eligible for work selection.\n    constructor(\n        ERC20Burnable _token,\n        TokenGrant _tokenGrant,\n        TokenStakingEscrow _escrow,\n        KeepRegistry _registry,\n        uint256 _initializationPeriod\n    ) Authorizations(_registry) public {\n        token = _token;\n        tokenGrant = _tokenGrant;\n        escrow = _escrow;\n        registry = _registry;\n        initializationPeriod = _initializationPeriod;\n        deployedAt = block.timestamp;\n    }\n\n    /// @notice Returns minimum amount of KEEP that allows sMPC cluster client to\n    /// participate in the Keep network. Expressed as numb","contract":"TokenStaking","time":0},{"type":"external-function ","before":" /// Only previously authorized operator contract can lock the stake.\n    /// @param operator Operator address.\n    /// @param duration Lock duration in seconds.\n    function lockStake(\n        address operator,\n        uint256 duration\n    ) public onlyApprovedOperatorContract(msg.sender) {\n        require(\n            isAuthorizedForOperator(operator, msg.sender),\n            \"Not authorized\"\n        );\n\n        uint256 operatorParams = operators[operator].packedParams;\n\n        require(\n            _isInitialized(operatorParams),\n            \"Inactive stake\"\n        );\n        require(\n            !_isUndelegating(operatorParams),\n            \"Undelegating stake\"\n        );\n\n        locks.lockStake(operator, duration);\n    }\n\n    /// @notice Removes a lock the caller had previously placed on the operator.\n    /// @dev Only for operator contracts.\n    /// To remove expired or disabled locks, use `releaseExpiredLocks`.\n    /// The authorization check ensures that the caller must have been able\n    /// to place a lock on the operator sometime in the past.\n    /// We don't need to check for current approval status of the caller\n    /// because unlocking stake cannot harm the operator\n    /// nor interfere with other operator contracts.\n    /// Therefore even disabled operator contracts may freely unlock stake.\n    /// @param operator Operator address.\n    function unlockStake(\n        address operator\n    ) public {\n        require(\n            isAuthor","after":" /// Only previously authorized operator contract can lock the stake.\n    /// @param operator Operator address.\n    /// @param duration Lock duration in seconds.\n    function lockStake(\n        address operator,\n        uint256 duration\n    ) public onlyApprovedOperatorContract(msg.sender) {\n        require(\n            isAuthorizedForOperator(operator, msg.sender),\n            \"Not authorized\"\n        );\n\n        uint256 operatorParams = operators[operator].packedParams;\n\n        require(\n            _isInitialized(operatorParams),\n            \"Inactive stake\"\n        );\n        require(\n            !_isUndelegating(operatorParams),\n            \"Undelegating stake\"\n        );\n\n        locks.lockStake(operator, duration);\n    }\n\n    /// @notice Removes a lock the caller had previously placed on the operator.\n    /// @dev Only for operator contracts.\n    /// To remove expired or disabled locks, use `releaseExpiredLocks`.\n    /// The authorization check ensures that the caller must have been able\n    /// to place a lock on the operator sometime in the past.\n    /// We don't need to check for current approval status of the caller\n    /// because unlocking stake cannot harm the operator\n    /// nor interfere with other operator contracts.\n    /// Therefore even disabled operator contracts may freely unlock stake.\n    /// @param operator Operator address.\n    function unlockStake(\n        address operator\n    ) public {\n        require(\n            isAuthor","contract":"TokenStaking","time":0},{"type":"external-function ","before":"ddress operator,\n        address operatorContract\n    ) public {\n        locks.releaseExpiredLock(operator, operatorContract, address(this));\n    }\n\n    /// @notice Check whether the operator has any active locks\n    /// that haven't expired yet\n    /// and whose creators aren't disabled by the panic button.\n    function isStakeLocked(address operator) public view returns (bool) {\n        return locks.isStakeLocked(operator, address(this));\n    }\n\n    /// @notice Get the locks placed on the operator.\n    /// @return creators The addresses of operator contracts\n    /// that have placed a lock on the operator.\n    /// @return expirations The expiration times\n    /// of the locks placed on the operator.\n    function getLocks(address operator)\n    public\n    view\n    returns (address[] memory creators, uint256[] memory expirations) {\n        return locks.getLocks(operator);\n    }\n\n    /// @notice Slash provided token amount from every member in the misbehaved\n    /// operators array and burn 100% of all the tokens.\n    /// @param amountToSlash Token amount to slash from every misbehaved operator.\n    /// @param misbehavedOperators Array of addresses to seize the tokens from.\n    function slash(uint256 amountToSlash, address[] memory misbehavedOperators)\n    public\n    onlyApprovedOperatorContract(msg.sender) {\n\n        uint256 totalAmountToBurn;\n        address authoritySource = getAuthoritySource(msg.sender);\n        for (uint i = 0; i < misbehavedOperators.length; i++) {\n            address operator = misbehavedOperators[i];\n            require(authorizations[authoritySource][operator], \"Not authorized\");\n\n            uint256 operatorParams = operators[operator].packedParams;\n            require(","after":"ddress operator,\n        address operatorContract\n    ) public {\n        locks.releaseExpiredLock(operator, operatorContract, address(this));\n    }\n\n    /// @notice Check whether the operator has any active locks\n    /// that haven't expired yet\n    /// and whose creators aren't disabled by the panic button.\n    function isStakeLocked(address operator) public view returns (bool) {\n        return locks.isStakeLocked(operator, address(this));\n    }\n\n    /// @notice Get the locks placed on the operator.\n    /// @return creators The addresses of operator contracts\n    /// that have placed a lock on the operator.\n    /// @return expirations The expiration times\n    /// of the locks placed on the operator.\n    function getLocks(address operator)\n    public\n    view\n    returns (address[] memory creators, uint256[] memory expirations) {\n        return locks.getLocks(operator);\n    }\n\n    /// @notice Slash provided token amount from every member in the misbehaved\n    /// operators array and burn 100% of all the tokens.\n    /// @param amountToSlash Token amount to slash from every misbehaved operator.\n    /// @param misbehavedOperators Array of addresses to seize the tokens from.\n    function slash(uint256 amountToSlash, address[] memory misbehavedOperators)\n    public\n    onlyApprovedOperatorContract(msg.sender) {\n\n        uint256 totalAmountToBurn;\n        address authoritySource = getAuthoritySource(msg.sender);\n        for (uint i = 0; i < misbehavedOperators.length; i++) {\n            address operator = misbehavedOperators[i];\n            require(authorizations[authoritySource][operator], \"Not authorized\");\n\n            uint256 operatorParams = operators[operator].packedParams;\n            require(","contract":"TokenStaking","time":0},{"type":"immutable-restrict-modification ","before":"       ▐▓▓▓▓▓�","after":"       ▐▓▓▓▓▓�","contract":"TokenStaking","time":0},{"type":"immutable-restrict-modification ","before":"▐▓▓▓▓▓▓\n  ▓▓▓▓","after":"▐▓▓▓▓▓▓\n  ▓▓▓▓","contract":"TokenStaking","time":0},{"type":"external-function ","before":"�▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓�","after":"�▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓���▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓�","contract":"TokenStakingEscrow","time":0},{"type":"external-function ","before":"th.sol\";\n\nimport \"./libraries/grant/UnlockingSchedule.sol\";\nimport \"./utils/BytesLib.sol\";\nimport \"./KeepToken.sol\";\nimport \"./utils/BytesLib.sol\";\nimport \"./TokenGrant.sol\";\nimport \"./ManagedGrant.sol\";\nimport \"./TokenSender.sol\";\n\n/// @title TokenStakingEscrow\n/// @notice Escrow lets the staking contract to deposit undelegated, granted\n/// tokens and either withdraw them based on the grant unlocking schedule or\n/// re-delegate them to another operator.\n/// @dev The owner of TokenStakingEscrow is TokenStaking contract and only owner\n/// can deposit. This contract works with an assumption that operator is unique\n/// in the scope of `TokenStaking`, that is, no more than one delegation in the\n/// `TokenStaking` can be done do the given operator ever. Even if the previous\n/// delegation ended, operator address cannot be reused.\ncontract TokenStakingEscrow is Ownable {\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using BytesLib for bytes;\n    using UnlockingSchedule for uint256;\n\n    event Deposited(\n        address indexed operator,\n        uint256 indexed grantId,\n        uint256 amount\n    );\n    event DepositRedelegated(\n        address inde","after":"th.sol\";\n\nimport \"./libraries/grant/UnlockingSchedule.sol\";\nimport \"./utils/BytesLib.sol\";\nimport \"./KeepToken.sol\";\nimport \"./utils/BytesLib.sol\";\nimport \"./TokenGrant.sol\";\nimport \"./ManagedGrant.sol\";\nimport \"./TokenSender.sol\";\n\n/// @title TokenStakingEscrow\n/// @notice Escrow lets the staking contract to deposit undelegated, granted\n/// tokens and either withdraw them based on the grant unlocking schedule or\n/// re-delegate them to another operator.\n/// @dev The owner of TokenStakingEscrow is TokenStaking contract and only owner\n/// can deposit. This contract works with an assumption that operator is unique\n/// in the scope of `TokenStaking`, that is, no more than one delegation in the\n/// `TokenStaking` can be done do the given operator ever. Even if the previous\n/// delegation ended, operator address cannot be reused.\ncontract TokenStakingEscrow is Ownable {\n\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using BytesLib for bytes;\n    using UnlockingSchedule for uint256;\n\n    event Deposited(\n        address indexed operator,\n        uint256 indexed grantId,\n        uint256 amount\n    );\n    event DepositRedelegated(\n        address inde","contract":"TokenStakingEscrow","time":0}]}