{"time":173,"results":[{"type":"external-function ","before":"function mintAndSell721(\n\n        uint256 vaultId,\n\n        uint256[] memory ids,\n\n        uint256 minWethOut,\n\n        address[] calldata path,\n\n        address to\n\n    ) public nonReentrant {\n\n        require(to != address(0));\n\n        require(ids.length != 0);\n\n        (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n\n        uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);\n\n        emit Sell(ids.length, amounts[1], to);\n\n    }","after":"function mintAndSell721(\n\n        uint256 vaultId,\n\n        uint256[] calldata ids,\n\n        uint256 minWethOut,\n\n        address[] calldata path,\n\n        address to\n\n    ) public nonReentrant {\n\n        require(to != address(0));\n\n        require(ids.length != 0);\n\n        (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n\n        uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);\n\n        emit Sell(ids.length, amounts[1], to);\n\n    }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function mintAndSell721WETH(\n\n        uint256 vaultId,\n\n        uint256[] memory ids,\n\n        uint256 minWethOut,\n\n        address[] calldata path,\n\n        address to\n\n    ) public nonReentrant {\n\n        require(to != address(0));\n\n        require(ids.length != 0);\n\n        (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n\n        uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);\n\n        emit Sell(ids.length, amounts[1], to);\n\n    }","after":"function mintAndSell721WETH(\n\n        uint256 vaultId,\n\n        uint256[] calldata ids,\n\n        uint256 minWethOut,\n\n        address[] calldata path,\n\n        address to\n\n    ) public nonReentrant {\n\n        require(to != address(0));\n\n        require(ids.length != 0);\n\n        (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\n\n        uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);\n\n        emit Sell(ids.length, amounts[1], to);\n\n    }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function buyAndSwap721(\n\n        uint256 vaultId,\n\n        uint256[] memory idsIn,\n\n        uint256[] memory specificIds,\n\n        address[] calldata path,\n\n        address to\n\n    ) public payable nonReentrant {\n\n        require(to != address(0));\n\n        require(idsIn.length != 0);\n\n        WETH.deposit{value : msg.value}();\n\n        INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n\n        uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n\n        );\n\n        uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n\n        _swap721(vaultId, idsIn, specificIds, to);\n\n\n        emit Swap(idsIn.length, amounts[0], to);\n\n\n        // Return extras.\n\n        uint256 remaining = WETH.balanceOf(address(this));\n\n        WETH.withdraw(remaining);\n\n        (bool success,) = payable(to).call{value : remaining}(\"\");\n\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n\n    }","after":"function buyAndSwap721(\n\n        uint256 vaultId,\n\n        uint256[] calldata idsIn,\n\n        uint256[] calldata specificIds,\n\n        address[] calldata path,\n\n        address to\n\n    ) public payable nonReentrant {\n\n        require(to != address(0));\n\n        require(idsIn.length != 0);\n\n        WETH.deposit{value : msg.value}();\n\n        INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n\n        uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n\n        );\n\n        uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n\n        _swap721(vaultId, idsIn, specificIds, to);\n\n\n        emit Swap(idsIn.length, amounts[0], to);\n\n\n        // Return extras.\n\n        uint256 remaining = WETH.balanceOf(address(this));\n\n        WETH.withdraw(remaining);\n\n        (bool success,) = payable(to).call{value : remaining}(\"\");\n\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n\n    }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function buyAndSwap721WETH(\n\n        uint256 vaultId,\n\n        uint256[] memory idsIn,\n\n        uint256[] memory specificIds,\n\n        uint256 maxWethIn,\n\n        address[] calldata path,\n\n        address to\n\n    ) public nonReentrant {\n\n        require(to != address(0));\n\n        require(idsIn.length != 0);\n\n        IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n\n        INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n\n        uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n\n        );\n\n        uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n\n        _swap721(vaultId, idsIn, specificIds, to);\n\n\n        emit Swap(idsIn.length, amounts[0], to);\n\n\n        // Return extras.\n\n        uint256 remaining = WETH.balanceOf(address(this));\n\n        WETH.transfer(to, remaining);\n\n    }","after":"function buyAndSwap721WETH(\n\n        uint256 vaultId,\n\n        uint256[] calldata idsIn,\n\n        uint256[] calldata specificIds,\n\n        uint256 maxWethIn,\n\n        address[] calldata path,\n\n        address to\n\n    ) public nonReentrant {\n\n        require(to != address(0));\n\n        require(idsIn.length != 0);\n\n        IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n\n        INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n\n        uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\n\n        );\n\n        uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\n\n        _swap721(vaultId, idsIn, specificIds, to);\n\n\n        emit Swap(idsIn.length, amounts[0], to);\n\n\n        // Return extras.\n\n        uint256 remaining = WETH.balanceOf(address(this));\n\n        WETH.transfer(to, remaining);\n\n    }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function buyAndSwap1155(\n\n        uint256 vaultId,\n\n        uint256[] memory idsIn,\n\n        uint256[] memory amounts,\n\n        uint256[] memory specificIds,\n\n        address[] calldata path,\n\n        address to\n\n    ) public payable nonReentrant {\n\n        require(to != address(0));\n\n        require(idsIn.length != 0);\n\n        WETH.deposit{value : msg.value}();\n\n        uint256 count;\n\n        for (uint256 i = 0; i < idsIn.length; i++) {\n\n            uint256 amount = amounts[i];\n\n            require(amount > 0, \"Transferring < 1\");\n\n            count += amount;\n\n        }\n\n        INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n\n        uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n\n        vault.randomSwapFee() * (count - specificIds.length)\n\n        );\n\n        uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n\n        _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n\n        emit Swap(count, swapAmounts[0], to);\n\n\n        // Return extras.\n\n        uint256 remaining = WETH.balanceOf(address(this));\n\n        WETH.withdraw(remaining);\n\n        (bool success,) = payable(to).call{value : remaining}(\"\");\n\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n\n    }","after":"function buyAndSwap1155(\n\n        uint256 vaultId,\n\n        uint256[] calldata idsIn,\n\n        uint256[] calldata amounts,\n\n        uint256[] calldata specificIds,\n\n        address[] calldata path,\n\n        address to\n\n    ) public payable nonReentrant {\n\n        require(to != address(0));\n\n        require(idsIn.length != 0);\n\n        WETH.deposit{value : msg.value}();\n\n        uint256 count;\n\n        for (uint256 i = 0; i < idsIn.length; i++) {\n\n            uint256 amount = amounts[i];\n\n            require(amount > 0, \"Transferring < 1\");\n\n            count += amount;\n\n        }\n\n        INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n\n        uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n\n        vault.randomSwapFee() * (count - specificIds.length)\n\n        );\n\n        uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n\n        _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n\n        emit Swap(count, swapAmounts[0], to);\n\n\n        // Return extras.\n\n        uint256 remaining = WETH.balanceOf(address(this));\n\n        WETH.withdraw(remaining);\n\n        (bool success,) = payable(to).call{value : remaining}(\"\");\n\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n\n    }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function buyAndSwap1155WETH(\n\n        uint256 vaultId,\n\n        uint256[] memory idsIn,\n\n        uint256[] memory amounts,\n\n        uint256[] memory specificIds,\n\n        uint256 maxWethIn,\n\n        address[] calldata path,\n\n        address to\n\n    ) public payable nonReentrant {\n\n        require(to != address(0));\n\n        require(idsIn.length != 0);\n\n        IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n\n        uint256 count;\n\n        for (uint256 i = 0; i < idsIn.length; i++) {\n\n            uint256 amount = amounts[i];\n\n            require(amount > 0, \"Transferring < 1\");\n\n            count += amount;\n\n        }\n\n        INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n\n        uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n\n        vault.randomSwapFee() * (count - specificIds.length)\n\n        );\n\n        uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n\n        _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n\n        emit Swap(count, swapAmounts[0], to);\n\n\n        // Return extras.\n\n        uint256 remaining = WETH.balanceOf(address(this));\n\n        WETH.transfer(to, remaining);\n\n    }","after":"function buyAndSwap1155WETH(\n\n        uint256 vaultId,\n\n        uint256[] calldata idsIn,\n\n        uint256[] calldata amounts,\n\n        uint256[] calldata specificIds,\n\n        uint256 maxWethIn,\n\n        address[] calldata path,\n\n        address to\n\n    ) public payable nonReentrant {\n\n        require(to != address(0));\n\n        require(idsIn.length != 0);\n\n        IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n\n        uint256 count;\n\n        for (uint256 i = 0; i < idsIn.length; i++) {\n\n            uint256 amount = amounts[i];\n\n            require(amount > 0, \"Transferring < 1\");\n\n            count += amount;\n\n        }\n\n        INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n\n        uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\n\n        vault.randomSwapFee() * (count - specificIds.length)\n\n        );\n\n        uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\n\n        _swap1155(vaultId, idsIn, amounts, specificIds, to);\n\n\n        emit Swap(count, swapAmounts[0], to);\n\n\n        // Return extras.\n\n        uint256 remaining = WETH.balanceOf(address(this));\n\n        WETH.transfer(to, remaining);\n\n    }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function buyAndRedeem(\n\n        uint256 vaultId,\n\n        uint256 amount,\n\n        uint256[] memory specificIds,\n\n        address[] calldata path,\n\n        address to\n\n    ) public payable nonReentrant {\n\n        require(to != address(0));\n\n        require(amount != 0);\n\n        WETH.deposit{value : msg.value}();\n\n        INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n\n        uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n\n        vault.randomRedeemFee() * (amount - specificIds.length)\n\n        );\n\n        uint256[] memory amounts = _buyVaultToken(address(vault), (amount * BASE) + totalFee, msg.value, path);\n\n        _redeem(vaultId, amount, specificIds, to);\n\n\n        emit Buy(amount, amounts[0], to);\n\n\n        uint256 remaining = WETH.balanceOf(address(this));\n\n        WETH.withdraw(remaining);\n\n        (bool success,) = payable(to).call{value : remaining}(\"\");\n\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n\n    }","after":"function buyAndRedeem(\n\n        uint256 vaultId,\n\n        uint256 amount,\n\n        uint256[] calldata specificIds,\n\n        address[] calldata path,\n\n        address to\n\n    ) public payable nonReentrant {\n\n        require(to != address(0));\n\n        require(amount != 0);\n\n        WETH.deposit{value : msg.value}();\n\n        INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n\n        uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n\n        vault.randomRedeemFee() * (amount - specificIds.length)\n\n        );\n\n        uint256[] memory amounts = _buyVaultToken(address(vault), (amount * BASE) + totalFee, msg.value, path);\n\n        _redeem(vaultId, amount, specificIds, to);\n\n\n        emit Buy(amount, amounts[0], to);\n\n\n        uint256 remaining = WETH.balanceOf(address(this));\n\n        WETH.withdraw(remaining);\n\n        (bool success,) = payable(to).call{value : remaining}(\"\");\n\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n\n    }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function buyAndRedeemWETH(\n\n        uint256 vaultId,\n\n        uint256 amount,\n\n        uint256[] memory specificIds,\n\n        uint256 maxWethIn,\n\n        address[] calldata path,\n\n        address to\n\n    ) public nonReentrant {\n\n        require(to != address(0));\n\n        require(amount != 0);\n\n        IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n\n        INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n\n        uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n\n        vault.randomRedeemFee() * (amount - specificIds.length)\n\n        );\n\n        uint256[] memory amounts = _buyVaultToken(address(vault), (amount * BASE) + totalFee, maxWethIn, path);\n\n        _redeem(vaultId, amount, specificIds, to);\n\n\n        emit Buy(amount, amounts[0], to);\n\n\n        uint256 remaining = WETH.balanceOf(address(this));\n\n        WETH.transfer(to, remaining);\n\n    }","after":"function buyAndRedeemWETH(\n\n        uint256 vaultId,\n\n        uint256 amount,\n\n        uint256[] calldata specificIds,\n\n        uint256 maxWethIn,\n\n        address[] calldata path,\n\n        address to\n\n    ) public nonReentrant {\n\n        require(to != address(0));\n\n        require(amount != 0);\n\n        IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\n\n        INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\n\n        uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\n\n        vault.randomRedeemFee() * (amount - specificIds.length)\n\n        );\n\n        uint256[] memory amounts = _buyVaultToken(address(vault), (amount * BASE) + totalFee, maxWethIn, path);\n\n        _redeem(vaultId, amount, specificIds, to);\n\n\n        emit Buy(amount, amounts[0], to);\n\n\n        uint256 remaining = WETH.balanceOf(address(this));\n\n        WETH.transfer(to, remaining);\n\n    }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function mintAndSell1155(\n\n        uint256 vaultId,\n\n        uint256[] memory ids,\n\n        uint256[] memory amounts,\n\n        uint256 minWethOut,\n\n        address[] calldata path,\n\n        address to\n\n    ) public nonReentrant {\n\n        require(to != address(0));\n\n        require(ids.length != 0);\n\n        (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n\n        uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n\n        uint256 count;\n\n        for (uint256 i = 0; i < ids.length; i++) {\n\n            count += amounts[i];\n\n        }\n\n        emit Sell(count, amounts[1], to);\n\n    }","after":"function mintAndSell1155(\n\n        uint256 vaultId,\n\n        uint256[] calldata ids,\n\n        uint256[] memory amounts,\n\n        uint256 minWethOut,\n\n        address[] calldata path,\n\n        address to\n\n    ) public nonReentrant {\n\n        require(to != address(0));\n\n        require(ids.length != 0);\n\n        (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n\n        uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n\n        uint256 count;\n\n        for (uint256 i = 0; i < ids.length; i++) {\n\n            count += amounts[i];\n\n        }\n\n        emit Sell(count, amounts[1], to);\n\n    }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function mintAndSell1155WETH(\n\n        uint256 vaultId,\n\n        uint256[] memory ids,\n\n        uint256[] memory amounts,\n\n        uint256 minWethOut,\n\n        address[] calldata path,\n\n        address to\n\n    ) public nonReentrant {\n\n        require(to != address(0));\n\n        require(ids.length != 0);\n\n        (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n\n        _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n\n        uint256 count;\n\n        for (uint256 i = 0; i < ids.length; i++) {\n\n            count += amounts[i];\n\n        }\n\n        emit Sell(count, amounts[1], to);\n\n    }","after":"function mintAndSell1155WETH(\n\n        uint256 vaultId,\n\n        uint256[] calldata ids,\n\n        uint256[] calldata amounts,\n\n        uint256 minWethOut,\n\n        address[] calldata path,\n\n        address to\n\n    ) public nonReentrant {\n\n        require(to != address(0));\n\n        require(ids.length != 0);\n\n        (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\n\n        _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);\n\n\n        uint256 count;\n\n        for (uint256 i = 0; i < ids.length; i++) {\n\n            count += amounts[i];\n\n        }\n\n        emit Sell(count, amounts[1], to);\n\n    }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function onERC721Received(\n\n        address,\n\n        address,\n\n        uint256,\n\n        bytes memory\n\n    ) public virtual override returns (bytes4) {\n\n        return this.onERC721Received.selector;\n\n    }","after":"function onERC721Received(\n\n        address,\n\n        address,\n\n        uint256,\n\n        bytes calldata\n\n    ) public virtual override returns (bytes4) {\n\n        return this.onERC721Received.selector;\n\n    }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n\n        return this.onERC1155Received.selector;\n\n    }","after":"function onERC1155Received(address, address, uint256, uint256, bytes calldata) public virtual override returns (bytes4) {\n\n        return this.onERC1155Received.selector;\n\n    }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n\n        return this.onERC1155BatchReceived.selector;\n\n    }","after":"function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) public virtual override returns (bytes4) {\n\n        return this.onERC1155BatchReceived.selector;\n\n    }","contract":"NFTXMarketplaceZap","time":0}]}