{"time":613,"results":[{"type":"struct-data-arrangement ","before":"\naddress collateralAsset\naddress borrowAsset\nuint64 collateralID\nuint64 borrowID","after":"address collateralAsset\naddress borrowAsset\nuint64 collateralID\nuint64 borrowID\n","contract":"IVaultExt","time":0},{"type":"external-function ","before":"function initiateFlashloan(FlashLoan.Info memory info, uint8 _flashnum) public isAuthorized {\n        if (_flashnum == 0) {\n            _initiateAaveFlashLoan(info);\n        } else if (_flashnum == 1) {\n            _initiateDyDxFlashLoan(info);\n        } else if (_flashnum == 2) {\n            _initiateCreamFlashLoan(info);\n        }\n    }","after":"function initiateFlashloan(FlashLoan.Info calldata info, uint8 _flashnum) public isAuthorized {\n        if (_flashnum == 0) {\n            _initiateAaveFlashLoan(info);\n        } else if (_flashnum == 1) {\n            _initiateDyDxFlashLoan(info);\n        } else if (_flashnum == 2) {\n            _initiateCreamFlashLoan(info);\n        }\n    }","contract":"Flasher","time":0},{"type":"external-function ","before":"function callFunction(\n        address sender,\n        Account.Info memory account,\n        bytes memory data\n    ) external override isAuthorizedExternal {\n        sender;\n        account;\n\n        FlashLoan.Info memory info = abi.decode(data, (FlashLoan.Info));\n\n        //Estimate flashloan payback + premium fee of 2 wei,\n        uint256 amountOwing = info.amount.add(2);\n\n        // Transfer to Vault the flashloan Amount\n        IERC20(info.asset).uniTransfer(payable(info.vault), info.amount);\n\n        if (info.callType == FlashLoan.CallType.Switch) {\n            IVault(info.vault).executeSwitch(info.newProvider, info.amount, 2);\n        } else if (info.callType == FlashLoan.CallType.Close) {\n            IFliquidator(info.fliquidator).executeFlashClose(info.user, info.vault, info.amount, 2);\n        } else {\n            IFliquidator(info.fliquidator).executeFlashLiquidation(\n                info.user,\n                info.userliquidator,\n                info.vault,\n                info.amount,\n                2\n            );\n        }\n\n        //Approve DYDXSolo to spend to repay flashloan\n        IERC20(info.asset).approve(_dydxSoloMargin, amountOwing);\n    }","after":"function callFunction(\n        address sender,\n        Account.Info calldata account,\n        bytes calldata data\n    ) external override isAuthorizedExternal {\n        sender;\n        account;\n\n        FlashLoan.Info memory info = abi.decode(data, (FlashLoan.Info));\n\n        //Estimate flashloan payback + premium fee of 2 wei,\n        uint256 amountOwing = info.amount.add(2);\n\n        // Transfer to Vault the flashloan Amount\n        IERC20(info.asset).uniTransfer(payable(info.vault), info.amount);\n\n        if (info.callType == FlashLoan.CallType.Switch) {\n            IVault(info.vault).executeSwitch(info.newProvider, info.amount, 2);\n        } else if (info.callType == FlashLoan.CallType.Close) {\n            IFliquidator(info.fliquidator).executeFlashClose(info.user, info.vault, info.amount, 2);\n        } else {\n            IFliquidator(info.fliquidator).executeFlashLiquidation(\n                info.user,\n                info.userliquidator,\n                info.vault,\n                info.amount,\n                2\n            );\n        }\n\n        //Approve DYDXSolo to spend to repay flashloan\n        IERC20(info.asset).approve(_dydxSoloMargin, amountOwing);\n    }","contract":"Flasher","time":0},{"type":"constant-restrict-modification  ","before":"address private immutable _aaveLendingPool = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;","after":"address private immutable constant _aaveLendingPool = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;","contract":"Flasher","time":0},{"type":"constant-restrict-modification  ","before":"address private immutable _dydxSoloMargin = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;","after":"address private immutable constant _dydxSoloMargin = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;","contract":"Flasher","time":0},{"type":"struct-data-arrangement ","before":"\naddress collateralAsset\naddress borrowAsset\nuint64 collateralID\nuint64 borrowID","after":"address collateralAsset\naddress borrowAsset\nuint64 collateralID\nuint64 borrowID\n","contract":"IVaultExt","time":0},{"type":"external-function ","before":"function mint(\n        address _account,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) external override onlyPermit {\n        require(_account != address(0), Errors.VL_ZERO_ADDR_1155);\n\n        address operator = _msgSender();\n\n        uint256 accountBalance = _balances[_id][_account];\n        uint256 assetTotalBalance = _totalSupply[_id];\n        uint256 amountScaled = _amount.rayDiv(indexes[_id]);\n\n        require(amountScaled != 0, Errors.VL_INVALID_MINT_AMOUNT);\n\n        _balances[_id][_account] = accountBalance.add(amountScaled);\n        _totalSupply[_id] = assetTotalBalance.add(amountScaled);\n\n        emit TransferSingle(operator, address(0), _account, _id, _amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), _account, _id, _amount, _data);\n    }","after":"function mint(\n        address _account,\n        uint256 _id,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override onlyPermit {\n        require(_account != address(0), Errors.VL_ZERO_ADDR_1155);\n\n        address operator = _msgSender();\n\n        uint256 accountBalance = _balances[_id][_account];\n        uint256 assetTotalBalance = _totalSupply[_id];\n        uint256 amountScaled = _amount.rayDiv(indexes[_id]);\n\n        require(amountScaled != 0, Errors.VL_INVALID_MINT_AMOUNT);\n\n        _balances[_id][_account] = accountBalance.add(amountScaled);\n        _totalSupply[_id] = assetTotalBalance.add(amountScaled);\n\n        emit TransferSingle(operator, address(0), _account, _id, _amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), _account, _id, _amount, _data);\n    }","contract":"FujiERC1155","time":0},{"type":"external-function ","before":"function mintBatch(\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        bytes memory _data\n    ) external onlyPermit {\n        require(_to != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(_ids.length == _amounts.length, Errors.VL_INPUT_ERROR);\n\n        address operator = _msgSender();\n\n        uint256 accountBalance;\n        uint256 assetTotalBalance;\n        uint256 amountScaled;\n\n        for (uint256 i = 0; i < _ids.length; i++) {\n            accountBalance = _balances[_ids[i]][_to];\n            assetTotalBalance = _totalSupply[_ids[i]];\n\n            amountScaled = _amounts[i].rayDiv(indexes[_ids[i]]);\n\n            require(amountScaled != 0, Errors.VL_INVALID_MINT_AMOUNT);\n\n            _balances[_ids[i]][_to] = accountBalance.add(amountScaled);\n            _totalSupply[_ids[i]] = assetTotalBalance.add(amountScaled);\n        }\n\n        emit TransferBatch(operator, address(0), _to, _ids, _amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), _to, _ids, _amounts, _data);\n    }","after":"function mintBatch(\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external onlyPermit {\n        require(_to != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(_ids.length == _amounts.length, Errors.VL_INPUT_ERROR);\n\n        address operator = _msgSender();\n\n        uint256 accountBalance;\n        uint256 assetTotalBalance;\n        uint256 amountScaled;\n\n        for (uint256 i = 0; i < _ids.length; i++) {\n            accountBalance = _balances[_ids[i]][_to];\n            assetTotalBalance = _totalSupply[_ids[i]];\n\n            amountScaled = _amounts[i].rayDiv(indexes[_ids[i]]);\n\n            require(amountScaled != 0, Errors.VL_INVALID_MINT_AMOUNT);\n\n            _balances[_ids[i]][_to] = accountBalance.add(amountScaled);\n            _totalSupply[_ids[i]] = assetTotalBalance.add(amountScaled);\n        }\n\n        emit TransferBatch(operator, address(0), _to, _ids, _amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), _to, _ids, _amounts, _data);\n    }","contract":"FujiERC1155","time":0},{"type":"external-function ","before":"function burnBatch(\n        address _account,\n        uint256[] memory _ids,\n        uint256[] memory _amounts\n    ) external onlyPermit {\n        require(_account != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(_ids.length == _amounts.length, Errors.VL_INPUT_ERROR);\n\n        address operator = _msgSender();\n\n        uint256 accountBalance;\n        uint256 assetTotalBalance;\n        uint256 amountScaled;\n\n        for (uint256 i = 0; i < _ids.length; i++) {\n            uint256 amount = _amounts[i];\n\n            accountBalance = _balances[_ids[i]][_account];\n            assetTotalBalance = _totalSupply[_ids[i]];\n\n            amountScaled = _amounts[i].rayDiv(indexes[_ids[i]]);\n\n            require(amountScaled != 0 && accountBalance >= amountScaled, Errors.VL_INVALID_BURN_AMOUNT);\n\n            _balances[_ids[i]][_account] = accountBalance.sub(amount);\n            _totalSupply[_ids[i]] = assetTotalBalance.sub(amount);\n        }\n\n        emit TransferBatch(operator, _account, address(0), _ids, _amounts);\n    }","after":"function burnBatch(\n        address _account,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts\n    ) external onlyPermit {\n        require(_account != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(_ids.length == _amounts.length, Errors.VL_INPUT_ERROR);\n\n        address operator = _msgSender();\n\n        uint256 accountBalance;\n        uint256 assetTotalBalance;\n        uint256 amountScaled;\n\n        for (uint256 i = 0; i < _ids.length; i++) {\n            uint256 amount = _amounts[i];\n\n            accountBalance = _balances[_ids[i]][_account];\n            assetTotalBalance = _totalSupply[_ids[i]];\n\n            amountScaled = _amounts[i].rayDiv(indexes[_ids[i]]);\n\n            require(amountScaled != 0 && accountBalance >= amountScaled, Errors.VL_INVALID_BURN_AMOUNT);\n\n            _balances[_ids[i]][_account] = accountBalance.sub(amount);\n            _totalSupply[_ids[i]] = assetTotalBalance.sub(amount);\n        }\n\n        emit TransferBatch(operator, _account, address(0), _ids, _amounts);\n    }","contract":"FujiERC1155","time":0},{"type":"external-function ","before":"function setURI(string memory _newUri) public onlyOwner {\n        _uri = _newUri;\n    }","after":"function setURI(string calldata _newUri) public onlyOwner {\n        _uri = _newUri;\n    }","contract":"FujiERC1155","time":0},{"type":"external-function ","before":"function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n    public\n    view\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, Errors.VL_INPUT_ERROR);\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","after":"function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    public\n    view\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, Errors.VL_INPUT_ERROR);\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","contract":"FujiERC1155","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override isTransferActive {\n        require(to != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            Errors.VL_MISSING_ERC1155_APPROVAL\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            from,\n            to,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, Errors.VL_NO_ERC1155_BALANCE);\n\n        _balances[id][from] = fromBalance.sub(amount);\n        _balances[id][to] = uint256(_balances[id][to]).add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override isTransferActive {\n        require(to != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            Errors.VL_MISSING_ERC1155_APPROVAL\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            from,\n            to,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, Errors.VL_NO_ERC1155_BALANCE);\n\n        _balances[id][from] = fromBalance.sub(amount);\n        _balances[id][to] = uint256(_balances[id][to]).add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"FujiERC1155","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override isTransferActive {\n        require(ids.length == amounts.length, Errors.VL_INPUT_ERROR);\n        require(to != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            Errors.VL_MISSING_ERC1155_APPROVAL\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, Errors.VL_NO_ERC1155_BALANCE);\n            _balances[id][from] = fromBalance.sub(amount);\n            _balances[id][to] = uint256(_balances[id][to]).add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override isTransferActive {\n        require(ids.length == amounts.length, Errors.VL_INPUT_ERROR);\n        require(to != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            Errors.VL_MISSING_ERC1155_APPROVAL\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, Errors.VL_NO_ERC1155_BALANCE);\n            _balances[id][from] = fromBalance.sub(amount);\n            _balances[id][to] = uint256(_balances[id][to]).add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"FujiERC1155","time":0},{"type":"constant-restrict-modification  ","before":"bool public transfersActive;","after":"bool public constant transfersActive;","contract":"FujiERC1155","time":1},{"type":"constant-restrict-modification  ","before":"bool public donothing = true;","after":"bool public constant donothing = true;","contract":"ProviderDYDX","time":0},{"type":"struct-data-arrangement ","before":"\naddress collateralAsset\naddress borrowAsset\nuint64 collateralID\nuint64 borrowID","after":"address collateralAsset\naddress borrowAsset\nuint64 collateralID\nuint64 borrowID\n","contract":"VaultControl","time":0},{"type":"loop-duplication","before":"\nstart line 4911 column 8, end line 4913 column 8\nfor (uint256 i = 0; i < length; i++) {\n            borrowBals = borrowBals.add(IProvider(providers[i]).getBorrowBalance(vAssets.borrowAsset));\n        }\nstart line 4914 column 8, end line 4918 column 8\nfor (uint256 i = 0; i < length; i++) {\n            depositBals = depositBals.add(\n                IProvider(providers[i]).getDepositBalance(vAssets.collateralAsset)\n            );\n        }","after":"// merge loop\n\nstart line 4911 column 8, end line 4913 column 8\nfor (uint256 i = 0; i < length; i++) {\n            borrowBals = borrowBals.add(IProvider(providers[i]).getBorrowBalance(vAssets.borrowAsset));\n        }\nstart line 4914 column 8, end line 4918 column 8\nfor (uint256 i = 0; i < length; i++) {\n            depositBals = depositBals.add(\n                IProvider(providers[i]).getDepositBalance(vAssets.collateralAsset)\n            );\n        }","contract":"VaultETHDAI","time":0},{"type":"loop-duplication","before":"\nstart line 5388 column 8, end line 5390 column 8\nfor (uint256 i = 0; i < length; i++) {\n            borrowBals = borrowBals.add(IProvider(providers[i]).getBorrowBalance(vAssets.borrowAsset));\n        }\nstart line 5391 column 8, end line 5395 column 8\nfor (uint256 i = 0; i < length; i++) {\n            depositBals = depositBals.add(\n                IProvider(providers[i]).getDepositBalance(vAssets.collateralAsset)\n            );\n        }","after":"// merge loop\n\nstart line 5388 column 8, end line 5390 column 8\nfor (uint256 i = 0; i < length; i++) {\n            borrowBals = borrowBals.add(IProvider(providers[i]).getBorrowBalance(vAssets.borrowAsset));\n        }\nstart line 5391 column 8, end line 5395 column 8\nfor (uint256 i = 0; i < length; i++) {\n            depositBals = depositBals.add(\n                IProvider(providers[i]).getDepositBalance(vAssets.collateralAsset)\n            );\n        }","contract":"VaultETHUSDC","time":1},{"type":"loop-duplication","before":"\nstart line 5865 column 8, end line 5867 column 8\nfor (uint256 i = 0; i < length; i++) {\n            borrowBals = borrowBals.add(IProvider(providers[i]).getBorrowBalance(vAssets.borrowAsset));\n        }\nstart line 5868 column 8, end line 5872 column 8\nfor (uint256 i = 0; i < length; i++) {\n            depositBals = depositBals.add(\n                IProvider(providers[i]).getDepositBalance(vAssets.collateralAsset)\n            );\n        }","after":"// merge loop\n\nstart line 5865 column 8, end line 5867 column 8\nfor (uint256 i = 0; i < length; i++) {\n            borrowBals = borrowBals.add(IProvider(providers[i]).getBorrowBalance(vAssets.borrowAsset));\n        }\nstart line 5868 column 8, end line 5872 column 8\nfor (uint256 i = 0; i < length; i++) {\n            depositBals = depositBals.add(\n                IProvider(providers[i]).getDepositBalance(vAssets.collateralAsset)\n            );\n        }","contract":"VaultETHUSDT","time":0}]}