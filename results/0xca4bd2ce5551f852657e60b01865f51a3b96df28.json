{"time":231,"results":[{"type":"external-function ","before":"function swapToETHAndSend(address[] memory tokens, address payable _to) external onlyOwner {\n        for (uint256 index = 0; index < tokens.length; index++) {\n            address token = tokens[index];\n            uint256 balance = IERC20(token).balanceOf(address(this));\n\n            // USDT approve doesn’t comply with the ERC20 standard\n            IERC20(token).safeApprove(uniswapRouterAddress, balance);\n\n            // can not use swapExactTokensForETH if token is WETH\n            if (token == IUniswapV2Router02(uniswapRouterAddress).WETH()) {\n                // unwrap WETH\n                IWETH9(token).withdraw(IERC20(token).balanceOf(address(this)));\n                // transfer ETH to Fee Storage\n                IERC20(token).transfer(\n                    address(this),\n                    IERC20(token).balanceOf(address(this))\n                );\n\n                continue;\n            }\n\n            address[] memory path = new address[](2);\n            path[0] = token;\n            path[1] = IUniswapV2Router02(uniswapRouterAddress).WETH();\n\n            uint256[] memory amounts =\n            IUniswapV2Router02(uniswapRouterAddress).getAmountsOut(balance, path);\n\n            uint256 amountOutMin = amounts[1];\n            IUniswapV2Router02(uniswapRouterAddress).swapExactTokensForETH(\n                balance,\n                amountOutMin,\n                path,\n                address(this),\n                block.timestamp\n            );\n        }\n\n        sendFeeETH(_to);\n   ","after":"function swapToETHAndSend(address[] calldata tokens, address payable _to) external onlyOwner {\n        for (uint256 index = 0; index < tokens.length; index++) {\n            address token = tokens[index];\n            uint256 balance = IERC20(token).balanceOf(address(this));\n\n            // USDT approve doesn’t comply with the ERC20 standard\n            IERC20(token).safeApprove(uniswapRouterAddress, balance);\n\n            // can not use swapExactTokensForETH if token is WETH\n            if (token == IUniswapV2Router02(uniswapRouterAddress).WETH()) {\n                // unwrap WETH\n                IWETH9(token).withdraw(IERC20(token).balanceOf(address(this)));\n                // transfer ETH to Fee Storage\n                IERC20(token).transfer(\n                    address(this),\n                    IERC20(token).balanceOf(address(this))\n                );\n\n                continue;\n            }\n\n            address[] memory path = new address[](2);\n            path[0] = token;\n            path[1] = IUniswapV2Router02(uniswapRouterAddress).WETH();\n\n            uint256[] memory amounts =\n            IUniswapV2Router02(uniswapRouterAddress).getAmountsOut(balance, path);\n\n            uint256 amountOutMin = amounts[1];\n            IUniswapV2Router02(uniswapRouterAddress).swapExactTokensForETH(\n                balance,\n                amountOutMin,\n                path,\n                address(this),\n                block.timestamp\n            );\n        }\n\n        sendFeeETH(_to);\n   ","contract":"FeeStorage","time":0}]}