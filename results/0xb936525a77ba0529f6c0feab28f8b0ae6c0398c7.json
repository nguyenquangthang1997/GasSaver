{"time":266,"results":[{"type":"loop-duplication","before":"\nstart line 1634 column 8, end line 1640 column 8\nfor (uint i = 0; i < pools.length; i++) {\n\n            bestInputAmounts[i] = swapAmount.mul(pools[i].effectiveLiquidity).div(sumEffectiveLiquidity);\n\n            totalInputAmount = totalInputAmount.add(bestInputAmounts[i]);\n\n        }\nstart line 1657 column 8, end line 1675 column 8\nfor (uint i = 0; i < pools.length; i++) {\n\n            swaps[i] = Swap({\n\n            pool : pools[i].pool,\n\n            tokenIn : tokenIn,\n\n            tokenOut : tokenOut,\n\n            swapAmount : bestInputAmounts[i],\n\n            limitReturnAmount : 0,\n\n            maxPrice : uint(- 1)\n\n            });\n\n        }","after":"// merge loop\n\nstart line 1634 column 8, end line 1640 column 8\nfor (uint i = 0; i < pools.length; i++) {\n\n            bestInputAmounts[i] = swapAmount.mul(pools[i].effectiveLiquidity).div(sumEffectiveLiquidity);\n\n            totalInputAmount = totalInputAmount.add(bestInputAmounts[i]);\n\n        }\nstart line 1657 column 8, end line 1675 column 8\nfor (uint i = 0; i < pools.length; i++) {\n\n            swaps[i] = Swap({\n\n            pool : pools[i].pool,\n\n            tokenIn : tokenIn,\n\n            tokenOut : tokenOut,\n\n            swapAmount : bestInputAmounts[i],\n\n            limitReturnAmount : 0,\n\n            maxPrice : uint(- 1)\n\n            });\n\n        }","contract":"ExchangeProxy","time":1},{"type":"loop-duplication","before":"\nstart line 1724 column 8, end line 1730 column 8\nfor (uint i = 0; i < pools.length; i++) {\n\n            bestInputAmounts[i] = swapAmount.mul(pools[i].effectiveLiquidity).div(sumEffectiveLiquidity);\n\n            totalInputAmount = totalInputAmount.add(bestInputAmounts[i]);\n\n        }\nstart line 1747 column 8, end line 1765 column 8\nfor (uint i = 0; i < pools.length; i++) {\n\n            swaps[i] = Swap({\n\n            pool : pools[i].pool,\n\n            tokenIn : tokenIn,\n\n            tokenOut : tokenOut,\n\n            swapAmount : bestInputAmounts[i],\n\n            limitReturnAmount : uint(- 1),\n\n            maxPrice : uint(- 1)\n\n            });\n\n        }","after":"// merge loop\n\nstart line 1724 column 8, end line 1730 column 8\nfor (uint i = 0; i < pools.length; i++) {\n\n            bestInputAmounts[i] = swapAmount.mul(pools[i].effectiveLiquidity).div(sumEffectiveLiquidity);\n\n            totalInputAmount = totalInputAmount.add(bestInputAmounts[i]);\n\n        }\nstart line 1747 column 8, end line 1765 column 8\nfor (uint i = 0; i < pools.length; i++) {\n\n            swaps[i] = Swap({\n\n            pool : pools[i].pool,\n\n            tokenIn : tokenIn,\n\n            tokenOut : tokenOut,\n\n            swapAmount : bestInputAmounts[i],\n\n            limitReturnAmount : uint(- 1),\n\n            maxPrice : uint(- 1)\n\n            });\n\n        }","contract":"ExchangeProxy","time":0},{"type":"loop-duplication","before":"\nstart line 2137 column 8, end line 2145 column 8\nfor (uint i = 0; i < tokens.length; i++) {\n\n            if (transferFromAllAndApprove(tokens[i], maxAmountsIn[i], address(pool))) {\n\n                containsETH = true;\n\n            }\n\n        }\nstart line 2159 column 8, end line 2163 column 8\nfor (uint i = 0; i < tokens.length; i++) {\n\n            transferAll(IERC20(tokens[i]), getBalance(IERC20(tokens[i])));\n\n        }","after":"// merge loop\n\nstart line 2137 column 8, end line 2145 column 8\nfor (uint i = 0; i < tokens.length; i++) {\n\n            if (transferFromAllAndApprove(tokens[i], maxAmountsIn[i], address(pool))) {\n\n                containsETH = true;\n\n            }\n\n        }\nstart line 2159 column 8, end line 2163 column 8\nfor (uint i = 0; i < tokens.length; i++) {\n\n            transferAll(IERC20(tokens[i]), getBalance(IERC20(tokens[i])));\n\n        }","contract":"ExchangeProxy","time":0},{"type":"external-function ","before":"function multihopBatchSwapExactIn(\n\n        Swap[][] memory swapSequences,\n\n        IERC20 tokenIn,\n\n        IERC20 tokenOut,\n\n        uint totalAmountIn,\n\n        uint minTotalAmountOut,\n\n        uint8 flag\n\n    )\n\n    public payable discountCHI(flag)\n\n    returns (uint totalAmountOut)\n\n    {\n\n\n        transferFromAll(tokenIn, totalAmountIn);\n\n\n        for (uint i = 0; i < swapSequences.length; i++) {\n\n            uint tokenAmountOut;\n\n            for (uint k = 0; k < swapSequences[i].length; k++) {\n\n                Swap memory swap = swapSequences[i][k];\n\n                IERC20 SwapTokenIn = IERC20(swap.tokenIn);\n\n                if (k == 1) {\n\n                    // Makes sure that on the second swap the output of the first was used\n\n                    // so there is not intermediate token leftover\n\n                    swap.swapAmount = tokenAmountOut;\n\n                }\n\n\n                IBPool pool = IBPool(swap.pool);\n\n                if (SwapTokenIn.allowance(address(this), swap.pool) > 0) {\n\n                    SwapTokenIn.safeApprove(swap.pool, 0);\n\n                }\n\n                SwapTokenIn.safeApprove(swap.pool, swap.swapAmount);\n\n                (tokenAmountOut,) = pool.swapExactAmountIn(\n\n                    swap.tokenIn,\n\n                    swap.swapAmount,\n\n                    swap.tokenOut,\n\n                    swap.limitReturnAmount,\n\n                    swap.maxPrice\n\n                );\n\n            }\n\n            // This takes the amountOut of the last swap\n\n            totalAmountOut = tokenAmountOut.add(totalAmountOut);\n\n        }\n\n\n        require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\n\n\n        transferAll(tokenOut, totalAmountOut);\n\n        transferAll(tokenIn, getBalance(tokenIn));\n\n\n    }","after":"function multihopBatchSwapExactIn(\n\n        Swap[][] calldata swapSequences,\n\n        IERC20 tokenIn,\n\n        IERC20 tokenOut,\n\n        uint totalAmountIn,\n\n        uint minTotalAmountOut,\n\n        uint8 flag\n\n    )\n\n    public payable discountCHI(flag)\n\n    returns (uint totalAmountOut)\n\n    {\n\n\n        transferFromAll(tokenIn, totalAmountIn);\n\n\n        for (uint i = 0; i < swapSequences.length; i++) {\n\n            uint tokenAmountOut;\n\n            for (uint k = 0; k < swapSequences[i].length; k++) {\n\n                Swap memory swap = swapSequences[i][k];\n\n                IERC20 SwapTokenIn = IERC20(swap.tokenIn);\n\n                if (k == 1) {\n\n                    // Makes sure that on the second swap the output of the first was used\n\n                    // so there is not intermediate token leftover\n\n                    swap.swapAmount = tokenAmountOut;\n\n                }\n\n\n                IBPool pool = IBPool(swap.pool);\n\n                if (SwapTokenIn.allowance(address(this), swap.pool) > 0) {\n\n                    SwapTokenIn.safeApprove(swap.pool, 0);\n\n                }\n\n                SwapTokenIn.safeApprove(swap.pool, swap.swapAmount);\n\n                (tokenAmountOut,) = pool.swapExactAmountIn(\n\n                    swap.tokenIn,\n\n                    swap.swapAmount,\n\n                    swap.tokenOut,\n\n                    swap.limitReturnAmount,\n\n                    swap.maxPrice\n\n                );\n\n            }\n\n            // This takes the amountOut of the last swap\n\n            totalAmountOut = tokenAmountOut.add(totalAmountOut);\n\n        }\n\n\n        require(totalAmountOut >= minTotalAmountOut, \"ERR_LIMIT_OUT\");\n\n\n        transferAll(tokenOut, totalAmountOut);\n\n        transferAll(tokenIn, getBalance(tokenIn));\n\n\n    }","contract":"ExchangeProxy","time":0},{"type":"external-function ","before":"function multihopBatchSwapExactOut(\n\n        Swap[][] memory swapSequences,\n\n        IERC20 tokenIn,\n\n        IERC20 tokenOut,\n\n        uint maxTotalAmountIn,\n\n        uint8 flag\n\n    )\n\n    public payable discountCHI(flag)\n\n    returns (uint totalAmountIn)\n\n    {\n\n\n        transferFromAll(tokenIn, maxTotalAmountIn);\n\n\n        for (uint i = 0; i < swapSequences.length; i++) {\n\n            uint tokenAmountInFirstSwap;\n\n            // Specific code for a simple swap and a multihop (2 swaps in sequence)\n\n            if (swapSequences[i].length == 1) {\n\n                Swap memory swap = swapSequences[i][0];\n\n                IERC20 SwapTokenIn = IERC20(swap.tokenIn);\n\n\n                IBPool pool = IBPool(swap.pool);\n\n                if (SwapTokenIn.allowance(address(this), swap.pool) > 0) {\n\n                    SwapTokenIn.safeApprove(swap.pool, 0);\n\n                }\n\n                SwapTokenIn.safeApprove(swap.pool, swap.limitReturnAmount);\n\n\n                (tokenAmountInFirstSwap,) = pool.swapExactAmountOut(\n\n                    swap.tokenIn,\n\n                    swap.limitReturnAmount,\n\n                    swap.tokenOut,\n\n                    swap.swapAmount,\n\n                    swap.maxPrice\n\n                );\n\n            } else {\n\n                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\n\n                // of token C. But first we need to buy B with A so we can then buy C with B\n\n                // To get the exact amount of C we then first need to calculate how much B we'll need:\n\n                uint intermediateTokenAmount;\n\n                // This would be token B as described above\n\n                Swap memory secondSwap = swapSequences[i][1];\n\n                IBPool poolSecondSwap = IBPool(secondSwap.pool);\n\n                intermediateTokenAmount = poolSecondSwap.calcInGivenOut(\n\n                    poolSecondSwap.getBalance(secondSwap.tokenIn),\n\n                    poolSecondSwap.getDenormalizedWeight(secondSwap.tokenIn),\n\n                    poolSecondSwap.getBalance(secondSwap.tokenOut),\n\n                    poolSecondSwap.getDenormalizedWeight(secondSwap.tokenOut),\n\n                    secondSwap.swapAmount,\n\n                    poolSecondSwap.swapFee()\n\n                );\n\n\n                //// Buy intermediateTokenAmount of token B with A in the first pool\n\n                Swap memory firstSwap = swapSequences[i][0];\n\n                IERC20 FirstSwapTokenIn = IERC20(firstSwap.tokenIn);\n\n                IBPool poolFirstSwap = IBPool(firstSwap.pool);\n\n                if (FirstSwapTokenIn.allowance(address(this), firstSwap.pool) < uint(- 1)) {\n\n                    FirstSwapTokenIn.safeApprove(firstSwap.pool, uint(- 1));\n\n                }\n\n\n                (tokenAmountInFirstSwap,) = poolFirstSwap.swapExactAmountOut(\n\n                    firstSwap.tokenIn,\n\n                    firstSwap.limitReturnAmount,\n\n                    firstSwap.tokenOut,\n\n                    intermediateTokenAmount, // This is the amount of token B we need\n\n                    firstSwap.maxPrice\n\n                );\n\n\n                //// Buy the final amount of token C desired\n\n                IERC20 SecondSwapTokenIn = IERC20(secondSwap.tokenIn);\n\n                if (SecondSwapTokenIn.allowance(address(this), secondSwap.pool) < uint(- 1)) {\n\n                    SecondSwapTokenIn.safeApprove(secondSwap.pool, uint(- 1));\n\n                }\n\n\n                poolSecondSwap.swapExactAmountOut(\n\n                    secondSwap.tokenIn,\n\n                    secondSwap.limitReturnAmount,\n\n                    secondSwap.tokenOut,\n\n                    secondSwap.swapAmount,\n\n                    secondSwap.maxPrice\n\n                );\n\n            }\n\n            totalAmountIn = tokenAmountInFirstSwap.add(totalAmountIn);\n\n        }\n\n\n        require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\n\n\n        transferAll(tokenOut, getBalance(tokenOut));\n\n        transferAll(tokenIn, getBalance(tokenIn));\n\n\n    }","after":"function multihopBatchSwapExactOut(\n\n        Swap[][] calldata swapSequences,\n\n        IERC20 tokenIn,\n\n        IERC20 tokenOut,\n\n        uint maxTotalAmountIn,\n\n        uint8 flag\n\n    )\n\n    public payable discountCHI(flag)\n\n    returns (uint totalAmountIn)\n\n    {\n\n\n        transferFromAll(tokenIn, maxTotalAmountIn);\n\n\n        for (uint i = 0; i < swapSequences.length; i++) {\n\n            uint tokenAmountInFirstSwap;\n\n            // Specific code for a simple swap and a multihop (2 swaps in sequence)\n\n            if (swapSequences[i].length == 1) {\n\n                Swap memory swap = swapSequences[i][0];\n\n                IERC20 SwapTokenIn = IERC20(swap.tokenIn);\n\n\n                IBPool pool = IBPool(swap.pool);\n\n                if (SwapTokenIn.allowance(address(this), swap.pool) > 0) {\n\n                    SwapTokenIn.safeApprove(swap.pool, 0);\n\n                }\n\n                SwapTokenIn.safeApprove(swap.pool, swap.limitReturnAmount);\n\n\n                (tokenAmountInFirstSwap,) = pool.swapExactAmountOut(\n\n                    swap.tokenIn,\n\n                    swap.limitReturnAmount,\n\n                    swap.tokenOut,\n\n                    swap.swapAmount,\n\n                    swap.maxPrice\n\n                );\n\n            } else {\n\n                // Consider we are swapping A -> B and B -> C. The goal is to buy a given amount\n\n                // of token C. But first we need to buy B with A so we can then buy C with B\n\n                // To get the exact amount of C we then first need to calculate how much B we'll need:\n\n                uint intermediateTokenAmount;\n\n                // This would be token B as described above\n\n                Swap memory secondSwap = swapSequences[i][1];\n\n                IBPool poolSecondSwap = IBPool(secondSwap.pool);\n\n                intermediateTokenAmount = poolSecondSwap.calcInGivenOut(\n\n                    poolSecondSwap.getBalance(secondSwap.tokenIn),\n\n                    poolSecondSwap.getDenormalizedWeight(secondSwap.tokenIn),\n\n                    poolSecondSwap.getBalance(secondSwap.tokenOut),\n\n                    poolSecondSwap.getDenormalizedWeight(secondSwap.tokenOut),\n\n                    secondSwap.swapAmount,\n\n                    poolSecondSwap.swapFee()\n\n                );\n\n\n                //// Buy intermediateTokenAmount of token B with A in the first pool\n\n                Swap memory firstSwap = swapSequences[i][0];\n\n                IERC20 FirstSwapTokenIn = IERC20(firstSwap.tokenIn);\n\n                IBPool poolFirstSwap = IBPool(firstSwap.pool);\n\n                if (FirstSwapTokenIn.allowance(address(this), firstSwap.pool) < uint(- 1)) {\n\n                    FirstSwapTokenIn.safeApprove(firstSwap.pool, uint(- 1));\n\n                }\n\n\n                (tokenAmountInFirstSwap,) = poolFirstSwap.swapExactAmountOut(\n\n                    firstSwap.tokenIn,\n\n                    firstSwap.limitReturnAmount,\n\n                    firstSwap.tokenOut,\n\n                    intermediateTokenAmount, // This is the amount of token B we need\n\n                    firstSwap.maxPrice\n\n                );\n\n\n                //// Buy the final amount of token C desired\n\n                IERC20 SecondSwapTokenIn = IERC20(secondSwap.tokenIn);\n\n                if (SecondSwapTokenIn.allowance(address(this), secondSwap.pool) < uint(- 1)) {\n\n                    SecondSwapTokenIn.safeApprove(secondSwap.pool, uint(- 1));\n\n                }\n\n\n                poolSecondSwap.swapExactAmountOut(\n\n                    secondSwap.tokenIn,\n\n                    secondSwap.limitReturnAmount,\n\n                    secondSwap.tokenOut,\n\n                    secondSwap.swapAmount,\n\n                    secondSwap.maxPrice\n\n                );\n\n            }\n\n            totalAmountIn = tokenAmountInFirstSwap.add(totalAmountIn);\n\n        }\n\n\n        require(totalAmountIn <= maxTotalAmountIn, \"ERR_LIMIT_IN\");\n\n\n        transferAll(tokenOut, getBalance(tokenOut));\n\n        transferAll(tokenIn, getBalance(tokenIn));\n\n\n    }","contract":"ExchangeProxy","time":0}]}