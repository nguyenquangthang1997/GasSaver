{"time":264,"results":[{"type":"external-function ","before":"    function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public {\n        require(ERC20Burnable(_token) == token, \"Token contract must be the same one linked to this contract.\");\n        require(_value >= minimumStake(), \"Tokens amount must be greater than the minimum stake\");\n        require(_extraData.length == 60, \"Stake delegation data must be provided.\");\n\n        address payable beneficiary = address(uint160(_extraData.toAddress(0)));\n        address operator = _extraData.toAddress(20);\n        require(operators[operator].owner == address(0), \"Operator address is already in use.\");\n        address authorizer = _extraData.toAddress(40);\n\n        // Transfer tokens to this contract.\n        token.safeTransferFrom(_from, address(this), _value);\n\n        operators[operator] = Operator(\n            OperatorParams.pack(_value, block.timestamp, 0),\n            _from,\n            beneficiary,\n            authorizer\n        );\n        ownerOperators[_from].push(operator);\n\n        emit Staked(operator, _value);\n ","after":"    function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) public {\n        require(ERC20Burnable(_token) == token, \"Token contract must be the same one linked to this contract.\");\n        require(_value >= minimumStake(), \"Tokens amount must be greater than the minimum stake\");\n        require(_extraData.length == 60, \"Stake delegation data must be provided.\");\n\n        address payable beneficiary = address(uint160(_extraData.toAddress(0)));\n        address operator = _extraData.toAddress(20);\n        require(operators[operator].owner == address(0), \"Operator address is already in use.\");\n        address authorizer = _extraData.toAddress(40);\n\n        // Transfer tokens to this contract.\n        token.safeTransferFrom(_from, address(this), _value);\n\n        operators[operator] = Operator(\n            OperatorParams.pack(_value, block.timestamp, 0),\n            _from,\n            beneficiary,\n            authorizer\n        );\n        ownerOperators[_from].push(operator);\n\n        emit Staked(operator, _value);\n ","contract":"TokenStaking","time":0},{"type":"external-function ","before":"    function slash(uint256 amountToSlash, address[] memory misbehavedOperators)\n    public\n    onlyApprovedOperatorContract(msg.sender) {\n\n        uint256 totalAmountToBurn = 0;\n        address authoritySource = getAuthoritySource(msg.sender);\n        for (uint i = 0; i < misbehavedOperators.length; i++) {\n            address operator = misbehavedOperators[i];\n            require(authorizations[authoritySource][operator], \"Not authorized\");\n\n            uint256 operatorParams = operators[operator].packedParams;\n            require(\n                _isInitialized(operatorParams),\n                \"Operator stake must be active\"\n            );\n\n            require(\n                !_isStakeReleased(operator, operatorParams, msg.sender),\n                \"Stake is released\"\n            );\n\n            uint256 currentAmount = operatorParams.getAmount();\n\n            if (currentAmount < amountToSlash) {\n                totalAmountToBurn = totalAmountToBurn.add(currentAmount);\n\n                uint256 newAmount = 0;\n                operators[operator].packedParams = operatorParams.setAmount(newAmount);\n                emit TokensSlashed(operator, currentAmount);\n            } else {\n                totalAmountToBurn = totalAmountToBurn.add(amountToSlash);\n\n                uint256 newAmount = currentAmount.sub(amountToSlash);\n                operators[operator].packedParams = operatorParams.setAmount(newAmount);\n                emit TokensSlashed(operator, amountToSlash);\n            }\n        }\n\n        token.burn(totalAmountToBurn);\n ","after":"    function slash(uint256 amountToSlash, address[] calldata misbehavedOperators)\n    public\n    onlyApprovedOperatorContract(msg.sender) {\n\n        uint256 totalAmountToBurn = 0;\n        address authoritySource = getAuthoritySource(msg.sender);\n        for (uint i = 0; i < misbehavedOperators.length; i++) {\n            address operator = misbehavedOperators[i];\n            require(authorizations[authoritySource][operator], \"Not authorized\");\n\n            uint256 operatorParams = operators[operator].packedParams;\n            require(\n                _isInitialized(operatorParams),\n                \"Operator stake must be active\"\n            );\n\n            require(\n                !_isStakeReleased(operator, operatorParams, msg.sender),\n                \"Stake is released\"\n            );\n\n            uint256 currentAmount = operatorParams.getAmount();\n\n            if (currentAmount < amountToSlash) {\n                totalAmountToBurn = totalAmountToBurn.add(currentAmount);\n\n                uint256 newAmount = 0;\n                operators[operator].packedParams = operatorParams.setAmount(newAmount);\n                emit TokensSlashed(operator, currentAmount);\n            } else {\n                totalAmountToBurn = totalAmountToBurn.add(amountToSlash);\n\n                uint256 newAmount = currentAmount.sub(amountToSlash);\n                operators[operator].packedParams = operatorParams.setAmount(newAmount);\n                emit TokensSlashed(operator, amountToSlash);\n            }\n        }\n\n        token.burn(totalAmountToBurn);\n ","contract":"TokenStaking","time":0},{"type":"external-function ","before":"    function seize(\n        uint256 amountToSeize,\n        uint256 rewardMultiplier,\n        address tattletale,\n        address[] memory misbehavedOperators\n    ) public onlyApprovedOperatorContract(msg.sender) {\n        uint256 totalAmountToBurn = 0;\n        address authoritySource = getAuthoritySource(msg.sender);\n        for (uint i = 0; i < misbehavedOperators.length; i++) {\n            address operator = misbehavedOperators[i];\n            require(authorizations[authoritySource][operator], \"Not authorized\");\n\n            uint256 operatorParams = operators[operator].packedParams;\n            require(\n                _isInitialized(operatorParams),\n                \"Operator stake must be active\"\n            );\n\n            require(\n                !_isStakeReleased(operator, operatorParams, msg.sender),\n                \"Stake is released\"\n            );\n\n            uint256 currentAmount = operatorParams.getAmount();\n\n            if (currentAmount < amountToSeize) {\n                totalAmountToBurn = totalAmountToBurn.add(currentAmount);\n\n                uint256 newAmount = 0;\n                operators[operator].packedParams = operatorParams.setAmount(newAmount);\n                emit TokensSeized(operator, currentAmount);\n            } else {\n                totalAmountToBurn = totalAmountToBurn.add(amountToSeize);\n\n                uint256 newAmount = currentAmount.sub(amountToSeize);\n                operators[operator].packedParams = operatorParams.setAmount(newAmount);\n                emit TokensSeized(operator, amountToSeize);\n            }\n        }\n\n        uint256 tattletaleReward = (totalAmountToBurn.percent(5)).percent(rewardMultiplier);\n\n        token.safeTransfer(tattletale, tattletaleReward);\n        token.burn(totalAmountToBurn.sub(tattletaleReward));\n ","after":"    function seize(\n        uint256 amountToSeize,\n        uint256 rewardMultiplier,\n        address tattletale,\n        address[] calldata misbehavedOperators\n    ) public onlyApprovedOperatorContract(msg.sender) {\n        uint256 totalAmountToBurn = 0;\n        address authoritySource = getAuthoritySource(msg.sender);\n        for (uint i = 0; i < misbehavedOperators.length; i++) {\n            address operator = misbehavedOperators[i];\n            require(authorizations[authoritySource][operator], \"Not authorized\");\n\n            uint256 operatorParams = operators[operator].packedParams;\n            require(\n                _isInitialized(operatorParams),\n                \"Operator stake must be active\"\n            );\n\n            require(\n                !_isStakeReleased(operator, operatorParams, msg.sender),\n                \"Stake is released\"\n            );\n\n            uint256 currentAmount = operatorParams.getAmount();\n\n            if (currentAmount < amountToSeize) {\n                totalAmountToBurn = totalAmountToBurn.add(currentAmount);\n\n                uint256 newAmount = 0;\n                operators[operator].packedParams = operatorParams.setAmount(newAmount);\n                emit TokensSeized(operator, currentAmount);\n            } else {\n                totalAmountToBurn = totalAmountToBurn.add(amountToSeize);\n\n                uint256 newAmount = currentAmount.sub(amountToSeize);\n                operators[operator].packedParams = operatorParams.setAmount(newAmount);\n                emit TokensSeized(operator, amountToSeize);\n            }\n        }\n\n        uint256 tattletaleReward = (totalAmountToBurn.percent(5)).percent(rewardMultiplier);\n\n        token.safeTransfer(tattletale, tattletaleReward);\n        token.burn(totalAmountToBurn.sub(tattletaleReward));\n ","contract":"TokenStaking","time":0},{"type":"immutable-restrict-modification ","before":"  uint256 public minimumStakeScheduleStar","after":"  uint256 public minimumStakeScheduleStar","contract":"TokenStaking","time":0},{"type":"immutable-restrict-modification ","before":"  uint256 public initializationPerio","after":"  uint256 public initializationPerio","contract":"TokenStaking","time":0},{"type":"immutable-restrict-modification ","before":"  uint256 public undelegationPerio","after":"  uint256 public undelegationPerio","contract":"TokenStaking","time":0}]}