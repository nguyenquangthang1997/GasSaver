{"time":491,"results":[{"type":"external-function ","before":"   function verify(\n        ForwardRequest memory req,\n        bytes32 domainSeparator,\n        bytes32 requestTypeHash,\n        bytes calldata suffixData,\n        bytes calldata sig)\n    external override view {\n\n        _verifyNonce(req);\n        _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);\n  ","after":"   function verify(\n        ForwardRequest calldata req,\n        bytes32 domainSeparator,\n        bytes32 requestTypeHash,\n        bytes calldata suffixData,\n        bytes calldata sig)\n    external override view {\n\n        _verifyNonce(req);\n        _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);\n  ","contract":"BatchForwarder","time":0},{"type":"external-function ","before":"   function execute(\n        ForwardRequest memory req,\n        bytes32 domainSeparator,\n        bytes32 requestTypeHash,\n        bytes calldata suffixData,\n        bytes calldata sig\n    )\n    external payable\n    override\n    returns (bool success, bytes memory ret) {\n        _verifyNonce(req);\n        _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);\n        _updateNonce(req);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, ret) = req.to.call{gas : req.gas, value : req.value}(abi.encodePacked(req.data, req.from));\n        if (address(this).balance > 0) {\n            //can't fail: req.from signed (off-chain) the request, so it must be an EOA...\n            payable(req.from).transfer(address(this).balance);\n        }\n        return (success, ret);\n  ","after":"   function execute(\n        ForwardRequest calldata req,\n        bytes32 domainSeparator,\n        bytes32 requestTypeHash,\n        bytes calldata suffixData,\n        bytes calldata sig\n    )\n    external payable\n    override\n    returns (bool success, bytes memory ret) {\n        _verifyNonce(req);\n        _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);\n        _updateNonce(req);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (success, ret) = req.to.call{gas : req.gas, value : req.value}(abi.encodePacked(req.data, req.from));\n        if (address(this).balance > 0) {\n            //can't fail: req.from signed (off-chain) the request, so it must be an EOA...\n            payable(req.from).transfer(address(this).balance);\n        }\n        return (success, ret);\n  ","contract":"BatchForwarder","time":0},{"type":"constant-restrict-modification  ","before":"string public override versionRecipient = \"2.0.0-alpha.3+opengsn.batched.irelayrecipient\";","after":"string public override constant versionRecipient = \"2.0.0-alpha.3+opengsn.batched.irelayrecipient\";","contract":"BatchForwarder","time":0},{"type":"immutable-restrict-modification ","before":"address internal trustedForwarder;","after":"address internal immutable trustedForwarder;","contract":"BatchForwarder","time":0},{"type":"immutable-restrict-modification ","before":"   address public own","after":"   address public own","contract":"Migrations","time":0},{"type":"constant-restrict-modification  ","before":"   string public override versionRecipient = \"2.0.0-alpha.3+opengsn.payablewithemit.irelayrecipien","after":"   string public override constant versionRecipient = \"2.0.0-alpha.3+opengsn.payablewithemit.irelayrecipien","contract":"PayableWithEmit","time":0},{"type":"constant-restrict-modification  ","before":"address internal trustedForwarder;","after":"address internal constant trustedForwarder;","contract":"PayableWithEmit","time":0},{"type":"external-function ","before":"   function penalizeRepeatedNonce(\n        bytes memory unsignedTx1,\n        bytes memory signature1,\n        bytes memory unsignedTx2,\n        bytes memory signature2,\n        IRelayHub hub\n    )\n    public\n    override\n    {\n        // Can be called by anyone.\n        // If a relay attacked the system by signing multiple transactions with the same nonce\n        // (so only one is accepted), anyone can grab both transactions from the blockchain and submit them here.\n        // Check whether unsignedTx1 != unsignedTx2, that both are signed by the same address,\n        // and that unsignedTx1.nonce == unsignedTx2.nonce.\n        // If all conditions are met, relay is considered an \"offending relay\".\n        // The offending relay will be unregistered immediately, its stake will be forfeited and given\n        // to the address who reported it (msg.sender), thus incentivizing anyone to report offending relays.\n        // If reported via a relay, the forfeited stake is split between\n        // msg.sender (the relay used for reporting) and the address that reported it.\n\n        address addr1 = keccak256(abi.encodePacked(unsignedTx1)).recover(signature1);\n        address addr2 = keccak256(abi.encodePacked(unsignedTx2)).recover(signature2);\n\n        require(addr1 == addr2, \"Different signer\");\n        require(addr1 != address(0), \"ecrecover failed\");\n\n        Transaction memory decodedTx1 = decodeTransaction(unsignedTx1);\n        Transaction memory decodedTx2 = decodeTransaction(unsignedTx2);\n\n        // checking that the same nonce is used in both transaction, with both signed by the same address\n        // and the actual data is different\n        // note: we compare the hash of the tx to save gas over iterating both byte arrays\n        require(decodedTx1.nonce == decodedTx2.nonce, \"Different nonce\");\n\n        bytes memory dataToCheck1 =\n        abi.encodePacked(decodedTx1.data, decodedTx1.gasLimit, decodedTx1.to, decodedTx1.value);\n\n        bytes memory dataToCheck2 =\n        abi.encodePacked(decodedTx2.data, decodedTx2.gasLimit, decodedTx2.to, decodedTx2.value);\n\n        require(keccak256(dataToCheck1) != keccak256(dataToCheck2), \"tx is equal\");\n\n        penalize(addr1, hub);\n  ","after":"   function penalizeRepeatedNonce(\n        bytes calldata unsignedTx1,\n        bytes calldata signature1,\n        bytes calldata unsignedTx2,\n        bytes calldata signature2,\n        IRelayHub hub\n    )\n    public\n    override\n    {\n        // Can be called by anyone.\n        // If a relay attacked the system by signing multiple transactions with the same nonce\n        // (so only one is accepted), anyone can grab both transactions from the blockchain and submit them here.\n        // Check whether unsignedTx1 != unsignedTx2, that both are signed by the same address,\n        // and that unsignedTx1.nonce == unsignedTx2.nonce.\n        // If all conditions are met, relay is considered an \"offending relay\".\n        // The offending relay will be unregistered immediately, its stake will be forfeited and given\n        // to the address who reported it (msg.sender), thus incentivizing anyone to report offending relays.\n        // If reported via a relay, the forfeited stake is split between\n        // msg.sender (the relay used for reporting) and the address that reported it.\n\n        address addr1 = keccak256(abi.encodePacked(unsignedTx1)).recover(signature1);\n        address addr2 = keccak256(abi.encodePacked(unsignedTx2)).recover(signature2);\n\n        require(addr1 == addr2, \"Different signer\");\n        require(addr1 != address(0), \"ecrecover failed\");\n\n        Transaction memory decodedTx1 = decodeTransaction(unsignedTx1);\n        Transaction memory decodedTx2 = decodeTransaction(unsignedTx2);\n\n        // checking that the same nonce is used in both transaction, with both signed by the same address\n        // and the actual data is different\n        // note: we compare the hash of the tx to save gas over iterating both byte arrays\n        require(decodedTx1.nonce == decodedTx2.nonce, \"Different nonce\");\n\n        bytes memory dataToCheck1 =\n        abi.encodePacked(decodedTx1.data, decodedTx1.gasLimit, decodedTx1.to, decodedTx1.value);\n\n        bytes memory dataToCheck2 =\n        abi.encodePacked(decodedTx2.data, decodedTx2.gasLimit, decodedTx2.to, decodedTx2.value);\n\n        require(keccak256(dataToCheck1) != keccak256(dataToCheck2), \"tx is equal\");\n\n        penalize(addr1, hub);\n  ","contract":"Penalizer","time":0},{"type":"external-function ","before":"   function penalizeIllegalTransaction(\n        bytes memory unsignedTx,\n        bytes memory signature,\n        IRelayHub hub\n    )\n    public\n    override\n    {\n        Transaction memory decodedTx = decodeTransaction(unsignedTx);\n        if (decodedTx.to == address(hub)) {\n            bytes4 selector = GsnUtils.getMethodSig(decodedTx.data);\n            bool isWrongMethodCall = selector != IRelayHub.relayCall.selector;\n            bool isGasLimitWrong = GsnUtils.getParam(decodedTx.data, 3) != decodedTx.gasLimit;\n            require(\n                isWrongMethodCall || isGasLimitWrong,\n                \"Legal relay transaction\");\n        }\n        address relay = keccak256(abi.encodePacked(unsignedTx)).recover(signature);\n        require(relay != address(0), \"ecrecover failed\");\n\n        penalize(relay, hub);\n  ","after":"   function penalizeIllegalTransaction(\n        bytes calldata unsignedTx,\n        bytes calldata signature,\n        IRelayHub hub\n    )\n    public\n    override\n    {\n        Transaction memory decodedTx = decodeTransaction(unsignedTx);\n        if (decodedTx.to == address(hub)) {\n            bytes4 selector = GsnUtils.getMethodSig(decodedTx.data);\n            bool isWrongMethodCall = selector != IRelayHub.relayCall.selector;\n            bool isGasLimitWrong = GsnUtils.getParam(decodedTx.data, 3) != decodedTx.gasLimit;\n            require(\n                isWrongMethodCall || isGasLimitWrong,\n                \"Legal relay transaction\");\n        }\n        address relay = keccak256(abi.encodePacked(unsignedTx)).recover(signature);\n        require(relay != address(0), \"ecrecover failed\");\n\n        penalize(relay, hub);\n  ","contract":"Penalizer","time":0},{"type":"constant-restrict-modification  ","before":"   string public override versionPenalizer = \"2.0.0-alpha.3+opengsn.penalizer.ipenalize","after":"   string public override constant versionPenalizer = \"2.0.0-alpha.3+opengsn.penalizer.ipenalize","contract":"Penalizer","time":0},{"type":"constant-restrict-modification  ","before":"   string public override versionHub = \"2.0.0-alpha.3+opengsn.hub.irelayhu","after":"   string public override constant versionHub = \"2.0.0-alpha.3+opengsn.hub.irelayhu","contract":"RelayHub","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public override minimumSta","after":"   uint256 public override minimumSta","contract":"RelayHub","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public override minimumUnstakeDel","after":"   uint256 public override minimumUnstakeDel","contract":"RelayHub","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public override maximumRecipientDepos","after":"   uint256 public override maximumRecipientDepos","contract":"RelayHub","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public override gasOverhe","after":"   uint256 public override gasOverhe","contract":"RelayHub","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public override postOverhe","after":"   uint256 public override postOverhe","contract":"RelayHub","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public override gasReser","after":"   uint256 public override gasReser","contract":"RelayHub","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public override maxWorkerCou","after":"   uint256 public override maxWorkerCou","contract":"RelayHub","time":0},{"type":"immutable-restrict-modification ","before":"r;\naddress override public penaliz","after":"r;\naddress override public penaliz","contract":"RelayHub","time":0},{"type":"constant-restrict-modification  ","before":"   string public override versionSM = \"2.0.0-alpha.3+opengsn.stakemanager.istakemanage","after":"   string public override constant versionSM = \"2.0.0-alpha.3+opengsn.stakemanager.istakemanage","contract":"StakeManager","time":0},{"type":"external-function ","before":"   function callExecute(Forwarder forwarder, Forwarder.ForwardRequest memory req,\n        bytes32 domainSeparator, bytes32 requestTypeHash, bytes memory suffixData, bytes memory sig) public payable {\n        (bool success, bytes memory error) = forwarder.execute{value : msg.value}(req, domainSeparator, requestTypeHash, suffixData, sig);\n        emit Result(success, success ? \"\" : this.decodeErrorMessage(error));\n  ","after":"   function callExecute(Forwarder forwarder, Forwarder.ForwardRequest calldata req,\n        bytes32 domainSeparator, bytes32 requestTypeHash, bytes calldata suffixData, bytes calldata sig) public payable {\n        (bool success, bytes memory error) = forwarder.execute{value : msg.value}(req, domainSeparator, requestTypeHash, suffixData, sig);\n        emit Result(success, success ? \"\" : this.decodeErrorMessage(error));\n  ","contract":"TestForwarder","time":0},{"type":"external-function ","before":"   function emitMessage(string memory message) public {\n\n        // solhint-disable-next-line avoid-tx-origin\n        emit TestForwarderMessage(message, _msgSender(), msg.sender, tx.origin);\n  ","after":"   function emitMessage(string calldata message) public {\n\n        // solhint-disable-next-line avoid-tx-origin\n        emit TestForwarderMessage(message, _msgSender(), msg.sender, tx.origin);\n  ","contract":"TestForwarderTarget","time":0},{"type":"constant-restrict-modification  ","before":"   string public override versionRecipient = \"2.0.0-alpha.3+opengsn.test.recipien","after":"   string public override constant versionRecipient = \"2.0.0-alpha.3+opengsn.test.recipien","contract":"TestForwarderTarget","time":0},{"type":"immutable-restrict-modification ","before":"address internal trustedForwarder;","after":"address internal immutable trustedForwarder;","contract":"TestForwarderTarget","time":0},{"type":"external-function ","before":"   function setExpectedApprovalData(bytes memory val) public {\n        expectedApprovalData = val;\n  ","after":"   function setExpectedApprovalData(bytes calldata val) public {\n        expectedApprovalData = val;\n  ","contract":"TestPaymasterPreconfiguredApproval","time":0},{"type":"constant-restrict-modification  ","before":"   string public override versionPaymaster = \"2.0.0-alpha.3+opengsn.test-vgl.ipaymaste","after":"   string public override constant versionPaymaster = \"2.0.0-alpha.3+opengsn.test-vgl.ipaymaste","contract":"TestPaymasterVariableGasLimits","time":0},{"type":"external-function ","before":"   function emitMessage(string memory message) public payable returns (string memory) {\n        if (paymaster != address(0)) {\n            withdrawAllBalance();\n        }\n\n        emit SampleRecipientEmitted(message, _msgSender(), msg.sender, tx.origin, msg.value, address(this).balance);\n        return \"emitMessage return value\";\n  ","after":"   function emitMessage(string calldata message) public payable returns (string memory) {\n        if (paymaster != address(0)) {\n            withdrawAllBalance();\n        }\n\n        emit SampleRecipientEmitted(message, _msgSender(), msg.sender, tx.origin, msg.value, address(this).balance);\n        return \"emitMessage return value\";\n  ","contract":"TestRecipient","time":0},{"type":"constant-restrict-modification  ","before":"   string public override versionRecipient = \"2.0.0-alpha.3+opengsn.test.irelayrecipien","after":"   string public override constant versionRecipient = \"2.0.0-alpha.3+opengsn.test.irelayrecipien","contract":"TestRecipient","time":1},{"type":"external-function ","before":"   function relayCall(\n        IRelayHub hub,\n        GsnTypes.RelayRequest memory relayRequest,\n        bytes memory signature,\n        uint externalGasLimit)\n    public\n    {\n        hub.relayCall{gas : externalGasLimit}(relayRequest, signature, \"\", externalGasLimit);\n  ","after":"   function relayCall(\n        IRelayHub hub,\n        GsnTypes.RelayRequest calldata relayRequest,\n        bytes calldata signature,\n        uint externalGasLimit)\n    public\n    {\n        hub.relayCall{gas : externalGasLimit}(relayRequest, signature, \"\", externalGasLimit);\n  ","contract":"TestRelayWorkerContract","time":0}]}