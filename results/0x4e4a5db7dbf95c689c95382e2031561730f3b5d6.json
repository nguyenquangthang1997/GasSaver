{"time":561,"results":[{"type":"constant-restrict-modification  ","before":"bytes32 public baseNode;","after":"bytes32 public constant baseNode;","contract":"BaseRegistrar","time":0},{"type":"loop-calculation","before":"uint a;","after":"// move outside for loop\nuint a;","loc":{"start":{"line":1085,"column":12},"end":{"line":1085,"column":18}},"contract":"BytesUtils","time":0},{"type":"loop-calculation","before":"uint b;","after":"// move outside for loop\nuint b;","loc":{"start":{"line":1086,"column":12},"end":{"line":1086,"column":18}},"contract":"BytesUtils","time":0},{"type":"external-function ","before":"function register(string memory label) external override {\n        bytes32 labelHash = keccak256(bytes(label));\n\n        require(\n            address(ENS_LABLEL_BOOKER) == address(0) ||\n            ENS_LABLEL_BOOKER.getBooking(label) == address(0),\n            'ENS_DAO_REGISTRAR: LABEL_BOOKED'\n        );\n\n        if (block.timestamp - DAO_BIRTH_DATE <= RESERVATION_DURATION) {\n            address dotEthSubdomainOwner = ENS_REGISTRY.owner(\n                keccak256(abi.encodePacked(ETH_NODE, labelHash))\n            );\n            require(\n                dotEthSubdomainOwner == address(0x0) ||\n                dotEthSubdomainOwner == _msgSender(),\n                'ENS_DAO_REGISTRAR: SUBDOMAIN_RESERVED'\n            );\n        }\n\n        _register(_msgSender(), label, labelHash);\n    }","after":"function register(string calldata label) external override {\n        bytes32 labelHash = keccak256(bytes(label));\n\n        require(\n            address(ENS_LABLEL_BOOKER) == address(0) ||\n            ENS_LABLEL_BOOKER.getBooking(label) == address(0),\n            'ENS_DAO_REGISTRAR: LABEL_BOOKED'\n        );\n\n        if (block.timestamp - DAO_BIRTH_DATE <= RESERVATION_DURATION) {\n            address dotEthSubdomainOwner = ENS_REGISTRY.owner(\n                keccak256(abi.encodePacked(ETH_NODE, labelHash))\n            );\n            require(\n                dotEthSubdomainOwner == address(0x0) ||\n                dotEthSubdomainOwner == _msgSender(),\n                'ENS_DAO_REGISTRAR: SUBDOMAIN_RESERVED'\n            );\n        }\n\n        _register(_msgSender(), label, labelHash);\n    }","contract":"ENSDaoRegistrar","time":0},{"type":"external-function ","before":"function claim(string memory label, address account) external override {\n        bytes32 labelHash = keccak256(bytes(label));\n        address bookedAddress = ENS_LABLEL_BOOKER.getBooking(label);\n        require(bookedAddress != address(0), 'ENS_DAO_REGISTRAR: LABEL_NOT_BOOKED');\n        require(\n            bookedAddress == _msgSender() || owner() == _msgSender(),\n            'ENS_DAO_REGISTRAR: SENDER_NOT_ALLOWED'\n        );\n\n        _register(account, label, labelHash);\n\n        ENS_LABLEL_BOOKER.deleteBooking(label);\n    }","after":"function claim(string calldata label, address account) external override {\n        bytes32 labelHash = keccak256(bytes(label));\n        address bookedAddress = ENS_LABLEL_BOOKER.getBooking(label);\n        require(bookedAddress != address(0), 'ENS_DAO_REGISTRAR: LABEL_NOT_BOOKED');\n        require(\n            bookedAddress == _msgSender() || owner() == _msgSender(),\n            'ENS_DAO_REGISTRAR: SENDER_NOT_ALLOWED'\n        );\n\n        _register(account, label, labelHash);\n\n        ENS_LABLEL_BOOKER.deleteBooking(label);\n    }","contract":"ENSDaoRegistrar","time":0},{"type":"external-function ","before":"function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","after":"function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","contract":"ENSDaoRegistrar","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","after":"function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","contract":"ENSDaoRegistrar","time":0},{"type":"immutable-restrict-modification ","before":"string NAME;","after":"string immutable NAME;","contract":"ENSDaoRegistrar","time":0},{"type":"immutable-restrict-modification ","before":"string private _baseTokenURI;","after":"string private immutable _baseTokenURI;","contract":"ENSDaoToken","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ENSDaoToken","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ENSDaoToken","time":1},{"type":"external-function ","before":"function getBooking(string memory label)\n    external\n    view\n    override\n    returns (address)\n    {\n        bytes32 labelHash = keccak256(bytes(label));\n        return _getBooking(labelHash);\n    }","after":"function getBooking(string calldata label)\n    external\n    view\n    override\n    returns (address)\n    {\n        bytes32 labelHash = keccak256(bytes(label));\n        return _getBooking(labelHash);\n    }","contract":"ENSLabelBooker","time":0},{"type":"external-function ","before":"function book(string memory label, address bookingAddress)\n    external\n    override\n    onlyOwnerOrRegistrar\n    {\n        bytes32 labelHash = keccak256(bytes(label));\n        _book(labelHash, bookingAddress);\n    }","after":"function book(string calldata label, address bookingAddress)\n    external\n    override\n    onlyOwnerOrRegistrar\n    {\n        bytes32 labelHash = keccak256(bytes(label));\n        _book(labelHash, bookingAddress);\n    }","contract":"ENSLabelBooker","time":0},{"type":"external-function ","before":"function batchBook(string[] memory labels, address[] memory bookingAddresses)\n    external\n    override\n    onlyOwnerOrRegistrar\n    {\n        require(\n            labels.length == bookingAddresses.length,\n            'ENS_LABEL_BOOKER: INVALID_PARAMS'\n        );\n        for (uint256 i; i < labels.length; i++) {\n            bytes32 labelHash = keccak256(bytes(labels[i]));\n            _book(labelHash, bookingAddresses[i]);\n        }\n    }","after":"function batchBook(string[] calldata labels, address[] calldata bookingAddresses)\n    external\n    override\n    onlyOwnerOrRegistrar\n    {\n        require(\n            labels.length == bookingAddresses.length,\n            'ENS_LABEL_BOOKER: INVALID_PARAMS'\n        );\n        for (uint256 i; i < labels.length; i++) {\n            bytes32 labelHash = keccak256(bytes(labels[i]));\n            _book(labelHash, bookingAddresses[i]);\n        }\n    }","contract":"ENSLabelBooker","time":0},{"type":"external-function ","before":"function updateBooking(string memory label, address bookingAddress)\n    external\n    override\n    onlyOwnerOrRegistrar\n    {\n        bytes32 labelHash = keccak256(bytes(label));\n        _updateBooking(labelHash, bookingAddress);\n    }","after":"function updateBooking(string calldata label, address bookingAddress)\n    external\n    override\n    onlyOwnerOrRegistrar\n    {\n        bytes32 labelHash = keccak256(bytes(label));\n        _updateBooking(labelHash, bookingAddress);\n    }","contract":"ENSLabelBooker","time":1},{"type":"external-function ","before":"function batchUpdateBooking(\n        string[] memory labels,\n        address[] memory bookingAddresses\n    ) external override onlyOwner {\n        require(\n            labels.length == bookingAddresses.length,\n            'ENS_LABEL_BOOKER: INVALID_PARAMS'\n        );\n        for (uint256 i; i < labels.length; i++) {\n            bytes32 labelHash = keccak256(bytes(labels[i]));\n            _updateBooking(labelHash, bookingAddresses[i]);\n        }\n    }","after":"function batchUpdateBooking(\n        string[] calldata labels,\n        address[] calldata bookingAddresses\n    ) external override onlyOwner {\n        require(\n            labels.length == bookingAddresses.length,\n            'ENS_LABEL_BOOKER: INVALID_PARAMS'\n        );\n        for (uint256 i; i < labels.length; i++) {\n            bytes32 labelHash = keccak256(bytes(labels[i]));\n            _updateBooking(labelHash, bookingAddresses[i]);\n        }\n    }","contract":"ENSLabelBooker","time":0},{"type":"external-function ","before":"function deleteBooking(string memory label)\n    external\n    override\n    onlyOwnerOrRegistrar\n    {\n        bytes32 labelHash = keccak256(bytes(label));\n        _deleteBooking(labelHash);\n    }","after":"function deleteBooking(string calldata label)\n    external\n    override\n    onlyOwnerOrRegistrar\n    {\n        bytes32 labelHash = keccak256(bytes(label));\n        _deleteBooking(labelHash);\n    }","contract":"ENSLabelBooker","time":0},{"type":"external-function ","before":"function batchDeleteBooking(string[] memory labels)\n    external\n    override\n    onlyOwnerOrRegistrar\n    {\n        for (uint256 i; i < labels.length; i++) {\n            bytes32 labelHash = keccak256(bytes(labels[i]));\n            _deleteBooking(labelHash);\n        }\n    }","after":"function batchDeleteBooking(string[] calldata labels)\n    external\n    override\n    onlyOwnerOrRegistrar\n    {\n        for (uint256 i; i < labels.length; i++) {\n            bytes32 labelHash = keccak256(bytes(labels[i]));\n            _deleteBooking(labelHash);\n        }\n    }","contract":"ENSLabelBooker","time":0},{"type":"external-function ","before":"function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n    public\n    view\n    virtual\n    override\n    returns (uint256[] memory)\n    {\n        require(\n            accounts.length == ids.length,\n            'ERC1155: accounts and ids length mismatch'\n        );\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","after":"function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    public\n    view\n    virtual\n    override\n    returns (uint256[] memory)\n    {\n        require(\n            accounts.length == ids.length,\n            'ERC1155: accounts and ids length mismatch'\n        );\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","contract":"NameWrapper","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(to != address(0), 'ERC1155: transfer to the zero address');\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            'ERC1155: caller is not owner nor approved'\n        );\n\n        (address oldOwner, uint96 fuses) = getData(id);\n        require(\n            _canTransfer(fuses),\n            'NameWrapper: Fuse already burned for transferring owner'\n        );\n        require(\n            amount == 1 && oldOwner == from,\n            'ERC1155: insufficient balance for transfer'\n        );\n        _setData(id, to, fuses);\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(to != address(0), 'ERC1155: transfer to the zero address');\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            'ERC1155: caller is not owner nor approved'\n        );\n\n        (address oldOwner, uint96 fuses) = getData(id);\n        require(\n            _canTransfer(fuses),\n            'NameWrapper: Fuse already burned for transferring owner'\n        );\n        require(\n            amount == 1 && oldOwner == from,\n            'ERC1155: insufficient balance for transfer'\n        );\n        _setData(id, to, fuses);\n\n        emit TransferSingle(msg.sender, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(msg.sender, from, to, id, amount, data);\n    }","contract":"NameWrapper","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            ids.length == amounts.length,\n            'ERC1155: ids and amounts length mismatch'\n        );\n        require(to != address(0), 'ERC1155: transfer to the zero address');\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            'ERC1155: transfer caller is not owner nor approved'\n        );\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            (address oldOwner, uint96 fuses) = getData(id);\n\n            require(\n                _canTransfer(fuses),\n                'NameWrapper: Fuse already burned for transferring owner'\n            );\n            require(\n                amount == 1 && oldOwner == from,\n                'ERC1155: insufficient balance for transfer'\n            );\n            _setData(id, to, fuses);\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            msg.sender,\n            from,\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            ids.length == amounts.length,\n            'ERC1155: ids and amounts length mismatch'\n        );\n        require(to != address(0), 'ERC1155: transfer to the zero address');\n        require(\n            from == msg.sender || isApprovedForAll(from, msg.sender),\n            'ERC1155: transfer caller is not owner nor approved'\n        );\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            (address oldOwner, uint96 fuses) = getData(id);\n\n            require(\n                _canTransfer(fuses),\n                'NameWrapper: Fuse already burned for transferring owner'\n            );\n            require(\n                amount == 1 && oldOwner == from,\n                'ERC1155: insufficient balance for transfer'\n            );\n            _setData(id, to, fuses);\n        }\n\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(\n            msg.sender,\n            from,\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }","contract":"NameWrapper","time":0}]}