{"time":907,"results":[{"type":"external-function ","before":"function requestFunderAbort(bytes memory _abortOutputScript) public {// not external to allow bytes memory parameters\n        require(\n            self.depositOwner() == msg.sender,\n            \"Only TDT holder can request funder abort\"\n        );\n\n        self.requestFunderAbort(_abortOutputScript);\n    }","after":"function requestFunderAbort(bytes calldata _abortOutputScript) public {// not external to allow bytes memory parameters\n        require(\n            self.depositOwner() == msg.sender,\n            \"Only TDT holder can request funder abort\"\n        );\n\n        self.requestFunderAbort(_abortOutputScript);\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function provideFundingECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public {// not external to allow bytes memory parameters\n        self.provideFundingECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n    }","after":"function provideFundingECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public {// not external to allow bytes memory parameters\n        self.provideFundingECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function provideBTCFundingProof(\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n        self.provideBTCFundingProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n    }","after":"function provideBTCFundingProof(\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n        self.provideBTCFundingProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function provideECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public {// not external to allow bytes memory parameters\n        self.provideECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n    }","after":"function provideECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public {// not external to allow bytes memory parameters\n        self.provideECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function requestRedemption(\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript\n    ) public {// not external to allow bytes memory parameters\n        self.requestRedemption(_outputValueBytes, _redeemerOutputScript);\n    }","after":"function requestRedemption(\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript\n    ) public {// not external to allow bytes memory parameters\n        self.requestRedemption(_outputValueBytes, _redeemerOutputScript);\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function provideRedemptionProof(\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n        self.provideRedemptionProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n    }","after":"function provideRedemptionProof(\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n        self.provideRedemptionProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function transferAndRequestRedemption(\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public {// not external to allow bytes memory parameters\n        require(\n            msg.sender == self.vendingMachineAddress,\n            \"Only the vending machine can call transferAndRequestRedemption\"\n        );\n        self.transferAndRequestRedemption(\n            _outputValueBytes,\n            _redeemerOutputScript,\n            _finalRecipient\n        );\n    }","after":"function transferAndRequestRedemption(\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public {// not external to allow bytes memory parameters\n        require(\n            msg.sender == self.vendingMachineAddress,\n            \"Only the vending machine can call transferAndRequestRedemption\"\n        );\n        self.transferAndRequestRedemption(\n            _outputValueBytes,\n            _redeemerOutputScript,\n            _finalRecipient\n        );\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function requestFunderAbort(\n        DepositUtils.Deposit storage _d,\n        bytes memory _abortOutputScript\n    ) public {// not external to allow bytes memory parameters\n        require(\n            _d.inFailedSetup(),\n            \"The deposit has not failed funding\"\n        );\n\n        _d.logFunderRequestedAbort(_abortOutputScript);\n    }","after":"function requestFunderAbort(\n        DepositUtils.Deposit storage _d,\n        bytes calldata _abortOutputScript\n    ) public {// not external to allow bytes memory parameters\n        require(\n            _d.inFailedSetup(),\n            \"The deposit has not failed funding\"\n        );\n\n        _d.logFunderRequestedAbort(_abortOutputScript);\n    }","contract":"DepositFunding","time":0},{"type":"external-function ","before":"function provideFundingECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public {// not external to allow bytes memory parameters\n        require(\n            _d.inAwaitingBTCFundingProof(),\n            \"Signer fraud during funding flow only available while awaiting funding\"\n        );\n\n        _d.submitSignatureFraud(_v, _r, _s, _signedDigest, _preimage);\n        _d.logFraudDuringSetup();\n\n        // Allow deposit owner to withdraw seized bonds after contract termination.\n        uint256 _seized = _d.seizeSignerBonds();\n        _d.enableWithdrawal(_d.depositOwner(), _seized);\n\n        fundingFraudTeardown(_d);\n        _d.setFailedSetup();\n        _d.logSetupFailed();\n    }","after":"function provideFundingECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public {// not external to allow bytes memory parameters\n        require(\n            _d.inAwaitingBTCFundingProof(),\n            \"Signer fraud during funding flow only available while awaiting funding\"\n        );\n\n        _d.submitSignatureFraud(_v, _r, _s, _signedDigest, _preimage);\n        _d.logFraudDuringSetup();\n\n        // Allow deposit owner to withdraw seized bonds after contract termination.\n        uint256 _seized = _d.seizeSignerBonds();\n        _d.enableWithdrawal(_d.depositOwner(), _seized);\n\n        fundingFraudTeardown(_d);\n        _d.setFailedSetup();\n        _d.logSetupFailed();\n    }","contract":"DepositFunding","time":0},{"type":"external-function ","before":"function provideBTCFundingProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n\n        require(_d.inAwaitingBTCFundingProof(), \"Not awaiting funding\");\n\n        bytes8 _valueBytes;\n        bytes memory _utxoOutpoint;\n\n        (_valueBytes, _utxoOutpoint) = _d.validateAndParseFundingSPVProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n\n        // Write down the UTXO info and set to active. Congratulations :)\n        _d.utxoValueBytes = _valueBytes;\n        _d.utxoOutpoint = _utxoOutpoint;\n        _d.fundedAt = block.timestamp;\n\n        bytes32 _txid = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n\n        fundingTeardown(_d);\n        _d.setActive();\n        _d.logFunded(_txid);\n    }","after":"function provideBTCFundingProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n\n        require(_d.inAwaitingBTCFundingProof(), \"Not awaiting funding\");\n\n        bytes8 _valueBytes;\n        bytes memory _utxoOutpoint;\n\n        (_valueBytes, _utxoOutpoint) = _d.validateAndParseFundingSPVProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n\n        // Write down the UTXO info and set to active. Congratulations :)\n        _d.utxoValueBytes = _valueBytes;\n        _d.utxoOutpoint = _utxoOutpoint;\n        _d.fundedAt = block.timestamp;\n\n        bytes32 _txid = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n\n        fundingTeardown(_d);\n        _d.setActive();\n        _d.logFunded(_txid);\n    }","contract":"DepositFunding","time":1},{"type":"external-function ","before":"function provideECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public {// not external to allow bytes memory parameters\n        require(\n            !_d.inFunding(),\n            \"Use provideFundingECDSAFraudProof instead\"\n        );\n        require(\n            !_d.inSignerLiquidation(),\n            \"Signer liquidation already in progress\"\n        );\n        require(!_d.inEndState(), \"Contract has halted\");\n        submitSignatureFraud(_d, _v, _r, _s, _signedDigest, _preimage);\n\n        startLiquidation(_d, true);\n    }","after":"function provideECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public {// not external to allow bytes memory parameters\n        require(\n            !_d.inFunding(),\n            \"Use provideFundingECDSAFraudProof instead\"\n        );\n        require(\n            !_d.inSignerLiquidation(),\n            \"Signer liquidation already in progress\"\n        );\n        require(!_d.inEndState(), \"Contract has halted\");\n        submitSignatureFraud(_d, _v, _r, _s, _signedDigest, _preimage);\n\n        startLiquidation(_d, true);\n    }","contract":"DepositLiquidation","time":0},{"type":"external-function ","before":"function logRedemptionRequested(\n        address _requester,\n        bytes32 _digest,\n        uint256 _utxoValue,\n        bytes memory _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes memory _outpoint\n    ) public {\n        // not external to allow bytes memory parameters\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit RedemptionRequested(\n            msg.sender,\n            _requester,\n            _digest,\n            _utxoValue,\n            _redeemerOutputScript,\n            _requestedFee,\n            _outpoint\n        );\n    }","after":"function logRedemptionRequested(\n        address _requester,\n        bytes32 _digest,\n        uint256 _utxoValue,\n        bytes calldata _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes calldata _outpoint\n    ) public {\n        // not external to allow bytes memory parameters\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit RedemptionRequested(\n            msg.sender,\n            _requester,\n            _digest,\n            _utxoValue,\n            _redeemerOutputScript,\n            _requestedFee,\n            _outpoint\n        );\n    }","contract":"DepositLog","time":0},{"type":"external-function ","before":"function logFunderRequestedAbort(bytes memory _abortOutputScript) public {\n        // not external to allow bytes memory parameters\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit FunderAbortRequested(msg.sender, _abortOutputScript);\n    }","after":"function logFunderRequestedAbort(bytes calldata _abortOutputScript) public {\n        // not external to allow bytes memory parameters\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit FunderAbortRequested(msg.sender, _abortOutputScript);\n    }","contract":"DepositLog","time":0},{"type":"external-function ","before":"function transferAndRequestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public {// not external to allow bytes memory parameters\n        _d.tbtcDepositToken.transferFrom(msg.sender, _finalRecipient, uint256(address(this)));\n\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, _finalRecipient);\n    }","after":"function transferAndRequestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public {// not external to allow bytes memory parameters\n        _d.tbtcDepositToken.transferFrom(msg.sender, _finalRecipient, uint256(address(this)));\n\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, _finalRecipient);\n    }","contract":"DepositRedemption","time":0},{"type":"external-function ","before":"function requestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript\n    ) public {// not external to allow bytes memory parameters\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, msg.sender);\n    }","after":"function requestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript\n    ) public {// not external to allow bytes memory parameters\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, msg.sender);\n    }","contract":"DepositRedemption","time":0},{"type":"external-function ","before":"function provideRedemptionProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n        bytes32 _txid;\n        uint256 _fundingOutputValue;\n\n        require(_d.inRedemption(), \"Redemption proof only allowed from redemption flow\");\n\n        _fundingOutputValue = redemptionTransactionChecks(_d, _txInputVector, _txOutputVector);\n\n        _txid = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n        _d.checkProofFromTxId(_txid, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        require((_d.utxoValue().sub(_fundingOutputValue)) <= _d.latestRedemptionFee, \"Incorrect fee amount\");\n\n        // Transfer TBTC to signers and close the keep.\n        distributeSignerFee(_d);\n        _d.closeKeep();\n\n        _d.distributeFeeRebate();\n\n        // We're done yey!\n        _d.setRedeemed();\n        _d.redemptionTeardown();\n        _d.logRedeemed(_txid);\n    }","after":"function provideRedemptionProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n        bytes32 _txid;\n        uint256 _fundingOutputValue;\n\n        require(_d.inRedemption(), \"Redemption proof only allowed from redemption flow\");\n\n        _fundingOutputValue = redemptionTransactionChecks(_d, _txInputVector, _txOutputVector);\n\n        _txid = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n        _d.checkProofFromTxId(_txid, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        require((_d.utxoValue().sub(_fundingOutputValue)) <= _d.latestRedemptionFee, \"Incorrect fee amount\");\n\n        // Transfer TBTC to signers and close the keep.\n        distributeSignerFee(_d);\n        _d.closeKeep();\n\n        _d.distributeFeeRebate();\n\n        // We're done yey!\n        _d.setRedeemed();\n        _d.redemptionTeardown();\n        _d.logRedeemed(_txid);\n    }","contract":"DepositRedemption","time":0},{"type":"struct-data-arrangement ","before":"\nITBTCSystem tbtcSystem\nTBTCToken tbtcToken\nIERC721 tbtcDepositToken\nFeeRebateToken feeRebateToken\naddress vendingMachineAddress\nuint64 lotSizeSatoshis\nuint8 currentState\nuint16 signerFeeDivisor\nuint16 initialCollateralizedPercent\nuint16 undercollateralizedThresholdPercent\nuint16 severelyUndercollateralizedThresholdPercent\nuint256 keepSetupFee\nuint256 liquidationInitiated\nuint256 courtesyCallInitiated\naddress payable liquidationInitiator\naddress keepAddress\nuint256 signingGroupRequestedAt\nuint256 fundingProofTimerStart\nbytes32 signingGroupPubkeyX\nbytes32 signingGroupPubkeyY\naddress payable redeemerAddress\nbytes redeemerOutputScript\nuint256 initialRedemptionFee\nuint256 latestRedemptionFee\nuint256 withdrawalRequestTime\nbytes32 lastRequestedDigest\nbytes8 utxoValueBytes\nuint256 fundedAt\nbytes utxoOutpoint\nmapping(address => uint256) withdrawableAmounts\nmapping(bytes32 => uint256) approvedDigests","after":"ITBTCSystem tbtcSystem\nTBTCToken tbtcToken\nIERC721 tbtcDepositToken\nFeeRebateToken feeRebateToken\nuint256 keepSetupFee\nuint256 liquidationInitiated\nuint256 courtesyCallInitiated\nuint256 signingGroupRequestedAt\nuint256 fundingProofTimerStart\nbytes32 signingGroupPubkeyX\nbytes32 signingGroupPubkeyY\nbytes redeemerOutputScript\nuint256 initialRedemptionFee\nuint256 latestRedemptionFee\nuint256 withdrawalRequestTime\nbytes32 lastRequestedDigest\nuint256 fundedAt\nbytes utxoOutpoint\nmapping(address => uint256) withdrawableAmounts\nmapping(bytes32 => uint256) approvedDigests\naddress vendingMachineAddress\naddress payable liquidationInitiator\naddress keepAddress\naddress payable redeemerAddress\nuint64 lotSizeSatoshis\nbytes8 utxoValueBytes\nuint16 signerFeeDivisor\nuint16 initialCollateralizedPercent\nuint16 undercollateralizedThresholdPercent\nuint16 severelyUndercollateralizedThresholdPercent\nuint8 currentState\n","contract":"DepositUtils","time":386},{"type":"external-function ","before":"function validateAndParseFundingSPVProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public view returns (bytes8 _valueBytes, bytes memory _utxoOutpoint){// not external to allow bytes memory parameters\n        require(_txInputVector.validateVin(), \"invalid input vector provided\");\n        require(_txOutputVector.validateVout(), \"invalid output vector provided\");\n\n        bytes32 txID = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n\n        _valueBytes = findAndParseFundingOutput(_d, _txOutputVector, _fundingOutputIndex);\n\n        require(bytes8LEToUint(_valueBytes) >= _d.lotSizeSatoshis, \"Deposit too small\");\n\n        checkProofFromTxId(_d, txID, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        // The utxoOutpoint is the LE txID plus the index of the output as a 4-byte LE int\n        // _fundingOutputIndex is a uint8, so we know it is only 1 byte\n        // Therefore, pad with 3 more bytes\n        _utxoOutpoint = abi.encodePacked(txID, _fundingOutputIndex, hex\"000000\");\n    }","after":"function validateAndParseFundingSPVProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public view returns (bytes8 _valueBytes, bytes memory _utxoOutpoint){// not external to allow bytes memory parameters\n        require(_txInputVector.validateVin(), \"invalid input vector provided\");\n        require(_txOutputVector.validateVout(), \"invalid output vector provided\");\n\n        bytes32 txID = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n\n        _valueBytes = findAndParseFundingOutput(_d, _txOutputVector, _fundingOutputIndex);\n\n        require(bytes8LEToUint(_valueBytes) >= _d.lotSizeSatoshis, \"Deposit too small\");\n\n        checkProofFromTxId(_d, txID, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        // The utxoOutpoint is the LE txID plus the index of the output as a 4-byte LE int\n        // _fundingOutputIndex is a uint8, so we know it is only 1 byte\n        // Therefore, pad with 3 more bytes\n        _utxoOutpoint = abi.encodePacked(txID, _fundingOutputIndex, hex\"000000\");\n    }","contract":"DepositUtils","time":0},{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping(uint256 => address) private _tokenOwner;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => Counters.Counter) private _ownedTokensCount;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;","after":"mapping(uint256 => address) private _tokenOwner;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => Counters.Counter) private _ownedTokensCount;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n","contract":"ERC721","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"FeeRebateToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"FeeRebateToken","time":0},{"type":"immutable-restrict-modification ","before":"eBytes,\n        bytes memory _re","after":"eBytes,\n        bytes memory _re","contract":"FeeRebateToken","time":0},{"type":"external-function ","before":"reated event with\n    ///                       _keepAddress, msg.sender and block.timestamp.\n    ///                       msg.sender will be the calling Deposit's address.\n    /// @param  _keepAddress  The address of the associated keep.\n    function logCreated(DepositUtils.Deposit storage _d, address _keepAddress) external {\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logCreated(_keepAddress);\n    }\n\n    /// @notice                 Fires a RedemptionRequested event.\n    /// @dev                    This is the only event without an explicit timestamp.","after":"reated event with\n    ///                       _keepAddress, msg.sender and block.timestamp.\n    ///                       msg.sender will be the calling Deposit's address.\n    /// @param  _keepAddress  The address of the associated keep.\n    function logCreated(DepositUtils.Deposit storage _d, address _keepAddress) external {\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logCreated(_keepAddress);\n    }\n\n    /// @notice                 Fires a RedemptionRequested event.\n    /// @dev                    This is the only event without an explicit timestamp.","contract":"OutsourceDepositLogging","time":0},{"type":"external-function ","before":"st,\n            _r,\n            _s\n        );\n    }\n\n    /// @notice     Fires a RegisteredPubkey event.\n    /// @dev        The logger is on a system contract, so all logs from all deposits are from the same address.\n    function logRegisteredPubkey(\n        DepositUtils.Deposit storage _d,\n        bytes32 ","after":"st,\n            _r,\n            _s\n        );\n    }\n\n    /// @notice     Fires a RegisteredPubkey event.\n    /// @dev        The logger is on a system contract, so all logs from all deposits are from the same address.\n    function logRegisteredPubkey(\n        DepositUtils.Deposit storage _d,\n        bytes32 ","contract":"OutsourceDepositLogging","time":0},{"type":"external-function ","before":"tokenId) external onlyFactory {\n        _mint(_to, _tokenId);\n    }\n\n    /// @dev Returns whether the specified token exists.\n    /// @param _tokenId uint256 ID of the token to query the existence of.\n    /// @return bool whether the token exists.\n    function exists(uint256 _tokenId) external view returns (bool) {\n        return _exists(_tok","after":"tokenId) external onlyFactory {\n        _mint(_to, _tokenId);\n    }\n\n    /// @dev Returns whether the specified token exists.\n    /// @param _tokenId uint256 ID of the token to query the existence of.\n    /// @return bool whether the token exists.\n    function exists(uint256 _tokenId) external view returns (bool) {\n        return _exists(_tok","contract":"TBTCDepositToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"TBTCDepositToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"TBTCDepositToken","time":0},{"type":"external-function ","before":"_account, uint256 _amount) public {\n        _burnFrom(_account, _amount);\n    }\n\n    /// @dev Destroys `amount` tokens from `msg.sender`, reducing the\n    /// total supply.\n    /// @param _amount   The amount of tokens that will be burnt.\n    function burn(uint256 _amount) public {\n        _burn(msg.sender, _am","after":"_account, uint256 _amount) public {\n        _burnFrom(_account, _amount);\n    }\n\n    /// @dev Destroys `amount` tokens from `msg.sender`, reducing the\n    /// total supply.\n    /// @param _amount   The amount of tokens that will be burnt.\n    function burn(uint256 _amount) public {\n        _burn(msg.sender, _am","contract":"TBTCToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"TBTCToken","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"TBTCToken","time":1},{"type":"immutable-restrict-modification ","before":"uint8 private _decimals;","after":"uint8 private immutable _decimals;","contract":"TBTCToken","time":1},{"type":"immutable-restrict-modification ","before":"eBytes,\n        bytes memory _re","after":"eBytes,\n        bytes memory _re","contract":"TBTCToken","time":1},{"type":"external-function ","before":" supply in weitoshis (BTC * 10 ** 18).\n    function getMaxSupply() public view returns (uint256) {\n        uint256 age = block.timestamp - createdAt;\n\n        if (age < 2 days) {\n            return 2 * 10 ** 18;\n        }\n\n        if (age < 7 days) {\n            return 100 * 10 ** 18;\n        }\n\n        if (age < 14 days) {\n            return 250 * 10 ** 18;\n        }\n\n        if (age < 21 days) {\n            return 500 * 10 ** 18;\n        }\n\n        if (age < 28 days) {\n            return 750 * 10 ** 18;\n        }\n\n        if (age < 35 days) {\n            return 1000 * 10 ** 18;\n        }\n\n        if (age < 42 days) {\n            return 1500 * 10 ** 18;\n        }\n\n        if (age < 49 days) {\n            return 2000 * 10 ** 18;\n        }\n\n        if (age < 56 days","after":" supply in weitoshis (BTC * 10 ** 18).\n    function getMaxSupply() public view returns (uint256) {\n        uint256 age = block.timestamp - createdAt;\n\n        if (age < 2 days) {\n            return 2 * 10 ** 18;\n        }\n\n        if (age < 7 days) {\n            return 100 * 10 ** 18;\n        }\n\n        if (age < 14 days) {\n            return 250 * 10 ** 18;\n        }\n\n        if (age < 21 days) {\n            return 500 * 10 ** 18;\n        }\n\n        if (age < 28 days) {\n            return 750 * 10 ** 18;\n        }\n\n        if (age < 35 days) {\n            return 1000 * 10 ** 18;\n        }\n\n        if (age < 42 days) {\n            return 1500 * 10 ** 18;\n        }\n\n        if (age < 49 days) {\n            return 2000 * 10 ** 18;\n        }\n\n        if (age < 56 days","contract":"VendingMachine","time":0},{"type":"external-function ","before":"      uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n        Deposit _d = Deposit(_depositAddress);\n        _d.provideBTCFundingProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n\n        tdtToTbtc(uint256(_depositAddress));\n    }\n\n    /// @notice Redeems a Deposit by purchasing a TDT with TBTC for _finalRecipient,\n    ///         and using the TDT to redeem corresponding Deposit as _finalRecipient.\n    ///         This function will revert if the Deposit is not in ACTIVE state.\n    /// @dev Vending Machine transfers TBTC allowance to Deposit.\n    /// @param  _depos","after":"      uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n        Deposit _d = Deposit(_depositAddress);\n        _d.provideBTCFundingProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n\n        tdtToTbtc(uint256(_depositAddress));\n    }\n\n    /// @notice Redeems a Deposit by purchasing a TDT with TBTC for _finalRecipient,\n    ///         and using the TDT to redeem corresponding Deposit as _finalRecipient.\n    ///         This function will revert if the Deposit is not in ACTIVE state.\n    /// @dev Vending Machine transfers TBTC allowance to Deposit.\n    /// @param  _depos","contract":"VendingMachine","time":0},{"type":"immutable-restrict-modification ","before":"h of current heade","after":"h of current heade","contract":"VendingMachine","time":0},{"type":"immutable-restrict-modification ","before":"       on your behalf and then ping","after":"       on your behalf and then ping","contract":"VendingMachine","time":0}]}