{"time":162,"results":[{"type":"external-function ","before":"function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        require(\n            _data.length <= MAX_ROLLUP_TX_SIZE,\n            'Transaction data size exceeds maximum for rollup transaction.'\n        );\n\n        require(\n            _gasLimit <= maxTransactionGasLimit,\n            'Transaction gas limit exceeds maximum for rollup transaction.'\n        );\n\n        require(\n            _gasLimit >= MIN_ROLLUP_TX_GAS,\n            'Transaction gas limit too low to enqueue.'\n        );\n\n        // Transactions submitted to the queue lack a method for paying gas fees to the Sequencer.\n        // So we need to prevent spam attacks by ensuring that the cost of enqueueing a transaction\n        // from L1 to L2 is not underpriced. For transaction with a high L2 gas limit, we do this by\n        // burning some extra gas on L1. Of course there is also some intrinsic cost to enqueueing a\n        // transaction, so we want to make sure not to over-charge (by burning too much L1 gas).\n        // Therefore, we define 'enqueueL2GasPrepaid' as the L2 gas limit above which we must burn\n        // additional gas on L1. This threshold is the product of two inputs:\n        // 1. enqueueGasCost: the base cost of calling this function.\n        // 2. l2GasDiscountDivisor: the ratio between the cost of gas on L1 and L2. This is a\n        //    positive integer, meaning we assume L2 gas is always less costly.\n        // The calculation below for gasToConsume can be seen as converting the difference (between\n        // the specified L2 gas limit and the prepaid L2 gas limit) to an L1 gas amount.\n        if (_gasLimit > enqueueL2GasPrepaid) {\n            uint256 gasToConsume = (_gasLimit - enqueueL2GasPrepaid) /\n            l2GasDiscountDivisor;\n            uint256 startingGas = gasleft();\n\n            // Although this check is not necessary (burn below will run out of gas if not true), it\n            // gives the user an explicit reason as to why the enqueue attempt failed.\n            require(\n                startingGas > gasToConsume,\n                'Insufficient gas for L2 rate limiting burn.'\n            );\n\n            uint256 i;\n            while (startingGas - gasleft() < gasToConsume) {\n                i++;\n            }\n        }\n\n        // Apply an aliasing unless msg.sender == tx.origin. This prevents an attack in which a\n        // contract on L1 has the same address as a contract on L2 but doesn't have the same code.\n        // We can safely ignore this for EOAs because they're guaranteed to have the same \"code\"\n        // (i.e. no code at all). This also makes it possible for users to interact with contracts\n        // on L2 even when the Sequencer is down.\n        address sender;\n        if (msg.sender == tx.origin) {\n            sender = msg.sender;\n        } else {\n            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        bytes32 transactionHash = keccak256(\n            abi.encode(sender, _target, _gasLimit, _data)\n        );\n\n        queueElements.push(\n            Lib_OVMCodec.QueueElement({\n        transactionHash : transactionHash,\n        timestamp : uint40(block.timestamp),\n        blockNumber : uint40(block.number)\n        })\n        );\n        uint256 queueIndex = queueElements.length - 1;\n        emit TransactionEnqueued(\n            sender,\n            _target,\n            _gasLimit,\n            _data,\n            queueIndex,\n            block.timestamp\n        );\n    }","after":"function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) external {\n        require(\n            _data.length <= MAX_ROLLUP_TX_SIZE,\n            'Transaction data size exceeds maximum for rollup transaction.'\n        );\n\n        require(\n            _gasLimit <= maxTransactionGasLimit,\n            'Transaction gas limit exceeds maximum for rollup transaction.'\n        );\n\n        require(\n            _gasLimit >= MIN_ROLLUP_TX_GAS,\n            'Transaction gas limit too low to enqueue.'\n        );\n\n        // Transactions submitted to the queue lack a method for paying gas fees to the Sequencer.\n        // So we need to prevent spam attacks by ensuring that the cost of enqueueing a transaction\n        // from L1 to L2 is not underpriced. For transaction with a high L2 gas limit, we do this by\n        // burning some extra gas on L1. Of course there is also some intrinsic cost to enqueueing a\n        // transaction, so we want to make sure not to over-charge (by burning too much L1 gas).\n        // Therefore, we define 'enqueueL2GasPrepaid' as the L2 gas limit above which we must burn\n        // additional gas on L1. This threshold is the product of two inputs:\n        // 1. enqueueGasCost: the base cost of calling this function.\n        // 2. l2GasDiscountDivisor: the ratio between the cost of gas on L1 and L2. This is a\n        //    positive integer, meaning we assume L2 gas is always less costly.\n        // The calculation below for gasToConsume can be seen as converting the difference (between\n        // the specified L2 gas limit and the prepaid L2 gas limit) to an L1 gas amount.\n        if (_gasLimit > enqueueL2GasPrepaid) {\n            uint256 gasToConsume = (_gasLimit - enqueueL2GasPrepaid) /\n            l2GasDiscountDivisor;\n            uint256 startingGas = gasleft();\n\n            // Although this check is not necessary (burn below will run out of gas if not true), it\n            // gives the user an explicit reason as to why the enqueue attempt failed.\n            require(\n                startingGas > gasToConsume,\n                'Insufficient gas for L2 rate limiting burn.'\n            );\n\n            uint256 i;\n            while (startingGas - gasleft() < gasToConsume) {\n                i++;\n            }\n        }\n\n        // Apply an aliasing unless msg.sender == tx.origin. This prevents an attack in which a\n        // contract on L1 has the same address as a contract on L2 but doesn't have the same code.\n        // We can safely ignore this for EOAs because they're guaranteed to have the same \"code\"\n        // (i.e. no code at all). This also makes it possible for users to interact with contracts\n        // on L2 even when the Sequencer is down.\n        address sender;\n        if (msg.sender == tx.origin) {\n            sender = msg.sender;\n        } else {\n            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        bytes32 transactionHash = keccak256(\n            abi.encode(sender, _target, _gasLimit, _data)\n        );\n\n        queueElements.push(\n            Lib_OVMCodec.QueueElement({\n        transactionHash : transactionHash,\n        timestamp : uint40(block.timestamp),\n        blockNumber : uint40(block.number)\n        })\n        );\n        uint256 queueIndex = queueElements.length - 1;\n        emit TransactionEnqueued(\n            sender,\n            _target,\n            _gasLimit,\n            _data,\n            queueIndex,\n            block.timestamp\n        );\n    }","contract":"CanonicalTransactionChain","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public maxTransactionGasLimit;","after":"uint256 public immutable maxTransactionGasLimit;","contract":"CanonicalTransactionChain","time":0},{"type":"external-function ","before":"function setAddress(string memory _name, address _address)\n    external\n    onlyOwner\n    {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(_name, _address, oldAddress);\n    }","after":"function setAddress(string calldata _name, address _address)\n    external\n    onlyOwner\n    {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(_name, _address, oldAddress);\n    }","contract":"Lib_AddressManager","time":0},{"type":"external-function ","before":"function getAddress(string memory _name) external view returns (address) {\n        return addresses[_getNameHash(_name)];\n    }","after":"function getAddress(string calldata _name) external view returns (address) {\n        return addresses[_getNameHash(_name)];\n    }","contract":"Lib_AddressManager","time":0},{"type":"loop-calculation","before":"uint256 listPtr;","after":"// move outside for loop\nuint256 listPtr;","loc":{"start":{"line":1955,"column":12},"end":{"line":1955,"column":27}},"contract":"Lib_RLPWriter","time":0}]}