{"time":17883,"results":[{"type":"state-data-arrangement ","before":"\n int128 internal constant PRECISION_64x64 = 0x3b9aca000000000000000000\n uint256 internal constant MAX64 = 0x7FFFFFFFFFFFFFFF\n int64 internal constant LN_1E18 = 0x09a667e259\n bool internal constant CHECK_FC = true\n bool internal constant DEFER_CHECK = false\n mapping(uint32 => Market) public markets\n uint8 public CASH_GROUP\n uint32 internal constant INSTRUMENT_PRECISION = 1e9\n uint32 public G_MATURITY_LENGTH\n uint32 public G_NUM_MATURITIES\n uint128 public G_MAX_TRADE_SIZE\n uint32 public G_RATE_ANCHOR\n uint16 public G_RATE_SCALAR\n uint32 public G_LIQUIDITY_FEE\n uint128 public G_TRANSACTION_FEE","after":" uint256 internal constant MAX64 = 0x7FFFFFFFFFFFFFFF\n mapping(uint32 => Market) public markets\n int128 internal constant PRECISION_64x64 = 0x3b9aca000000000000000000\n uint128 public G_MAX_TRADE_SIZE\n uint128 public G_TRANSACTION_FEE\n int64 internal constant LN_1E18 = 0x09a667e259\n uint32 internal constant INSTRUMENT_PRECISION = 1e9\n uint32 public G_MATURITY_LENGTH\n uint32 public G_NUM_MATURITIES\n uint32 public G_RATE_ANCHOR\n uint32 public G_LIQUIDITY_FEE\n uint16 public G_RATE_SCALAR\n bool internal constant CHECK_FC = true\n bool internal constant DEFER_CHECK = false\n uint8 public CASH_GROUP\n","contract":"CashMarket","time":16828},{"type":"state-data-arrangement ","before":"\n bytes1 internal constant MASK_POOL = 0x01\n bytes1 internal constant MASK_NET = 0x02\n bytes1 internal constant MASK_ORDER = 0x04\n bytes1 internal constant MASK_CASH = 0x08\n bytes1 internal constant MASK_PAYER = 0x10\n bytes1 internal constant MASK_RECEIVER = 0x20\n bytes1 internal constant MASK_PERIODIC = 0x80\n int256 internal constant RATE_DECIMALS = 1e9\n uint128 internal constant DECIMALS = 1e18\n uint128 internal constant MAX_UINT_128 = (2 ** 128) - 1\n uint32 internal constant MAX_UINT_32 = (2 ** 32) - 1\n uint32 internal constant SECONDS_IN_YEAR = 31536000","after":" int256 internal constant RATE_DECIMALS = 1e9\n uint128 internal constant DECIMALS = 1e18\n uint128 internal constant MAX_UINT_128 = (2 ** 128) - 1\n uint32 internal constant MAX_UINT_32 = (2 ** 32) - 1\n uint32 internal constant SECONDS_IN_YEAR = 31536000\n bytes1 internal constant MASK_POOL = 0x01\n bytes1 internal constant MASK_NET = 0x02\n bytes1 internal constant MASK_ORDER = 0x04\n bytes1 internal constant MASK_CASH = 0x08\n bytes1 internal constant MASK_PAYER = 0x10\n bytes1 internal constant MASK_RECEIVER = 0x20\n bytes1 internal constant MASK_PERIODIC = 0x80\n","contract":"Common","time":13},{"type":"external-function ","before":" function deployMinimal(address _logic, bytes memory _data) public returns (address proxy) {\n        // Adapted from https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\n        bytes20 targetBytes = bytes20(_logic);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            proxy := create(0, clone, 0x37)\n        }\n\n        emit ProxyCreated(address(proxy));\n\n        if (_data.length > 0) {\n            (bool success,) = proxy.call(_data);\n            require(success);\n        }\n    ","after":" function deployMinimal(address _logic, bytes calldata _data) public returns (address proxy) {\n        // Adapted from https://github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\n        bytes20 targetBytes = bytes20(_logic);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            proxy := create(0, clone, 0x37)\n        }\n\n        emit ProxyCreated(address(proxy));\n\n        if (_data.length > 0) {\n            (bool success,) = proxy.call(_data);\n            require(success);\n        }\n    ","contract":"CreateProxyFactory","time":0},{"type":"external-function ","before":" function deploy(uint256 _salt, address _logic, address _admin, bytes memory _data) public returns (address) {\n        return _deployProxy(_salt, _logic, _admin, _data, msg.sender);\n    ","after":" function deploy(uint256 _salt, address _logic, address _admin, bytes calldata _data) public returns (address) {\n        return _deployProxy(_salt, _logic, _admin, _data, msg.sender);\n    ","contract":"CreateProxyFactory","time":0},{"type":"external-function ","before":" function deploySigned(uint256 _salt, address _logic, address _admin, bytes memory _data, bytes memory _signature) public returns (address) {\n        address signer = getSigner(_salt, _logic, _admin, _data, _signature);\n        require(signer != address(0), \"Invalid signature\");\n        return _deployProxy(_salt, _logic, _admin, _data, signer);\n    ","after":" function deploySigned(uint256 _salt, address _logic, address _admin, bytes calldata _data, bytes calldata _signature) public returns (address) {\n        address signer = getSigner(_salt, _logic, _admin, _data, _signature);\n        require(signer != address(0), \"Invalid signature\");\n        return _deployProxy(_salt, _logic, _admin, _data, signer);\n    ","contract":"CreateProxyFactory","time":0},{"type":"immutable-restrict-modification ","before":" bytes32 private contractCodeHash","after":" bytes32 private immutable contractCodeHash","contract":"CreateProxyFactory","time":0},{"type":"struct-data-arrangement ","before":"\n    uint16 curren\n    Common.TradeType trade\n    uint128 ","after":"    Common.TradeType trade\n    uint128 \n    uint16 curren\n","contract":"ERC1155Trade","time":1},{"type":"external-function ","before":"    function batchOperation(\n        address account,\n        uint32 maxTime,\n        Common.Deposit[] memory deposits,\n        Common.Trade[] memory trades\n    ) public payable {\n        uint32 blockTime = uint32(block.timestamp);\n        require(blockTime <= maxTime, \"18\");\n        require(msg.sender == account || isApprovedForAll(account, msg.sender), \"20\");\n        Portfolios().settleMaturedAssets(account);\n\n        if (deposits.length > 0 || msg.value != 0) Escrow().depositsOnBehalf{value : msg.value}(account, deposits);\n        if (trades.length > 0) _batchTrade(account, trades);\n\n        // If there are only deposits then free collateral will only increase and we do not want to run a check against\n        // it in case an account deposits collateral but is still undercollateralized\n        if (trades.length > 0) {\n            int256 fc = Portfolios().freeCollateralViewAggregateOnly(account);\n            require(fc >= 0, \"5\");\n        }\n\n        emit BatchOperation(account, msg.sender);\n ","after":"    function batchOperation(\n        address account,\n        uint32 maxTime,\n        Common.Deposit[] calldata deposits,\n        Common.Trade[] calldata trades\n    ) public payable {\n        uint32 blockTime = uint32(block.timestamp);\n        require(blockTime <= maxTime, \"18\");\n        require(msg.sender == account || isApprovedForAll(account, msg.sender), \"20\");\n        Portfolios().settleMaturedAssets(account);\n\n        if (deposits.length > 0 || msg.value != 0) Escrow().depositsOnBehalf{value : msg.value}(account, deposits);\n        if (trades.length > 0) _batchTrade(account, trades);\n\n        // If there are only deposits then free collateral will only increase and we do not want to run a check against\n        // it in case an account deposits collateral but is still undercollateralized\n        if (trades.length > 0) {\n            int256 fc = Portfolios().freeCollateralViewAggregateOnly(account);\n            require(fc >= 0, \"5\");\n        }\n\n        emit BatchOperation(account, msg.sender);\n ","contract":"ERC1155Trade","time":0},{"type":"external-function ","before":"    function batchOperationWithdraw(\n        address account,\n        uint32 maxTime,\n        Common.Deposit[] memory deposits,\n        Common.Trade[] memory trades,\n        Common.Withdraw[] memory withdraws\n    ) public payable {\n        uint32 blockTime = uint32(block.timestamp);\n        require(blockTime <= maxTime, \"18\");\n        require(msg.sender == account || isApprovedForAll(account, msg.sender), \"20\");\n        Portfolios().settleMaturedAssets(account);\n\n        TradeRecord[] memory tradeRecord;\n        if (deposits.length > 0 || msg.value != 0) Escrow().depositsOnBehalf{value : msg.value}(account, deposits);\n        if (trades.length > 0) tradeRecord = _batchTrade(account, trades);\n        if (withdraws.length > 0) {\n            if (tradeRecord.length > 0) {\n                _updateWithdrawsWithTradeRecord(tradeRecord, deposits, withdraws);\n            }\n\n            Escrow().withdrawsOnBehalf(account, withdraws);\n        }\n\n        int256 fc = Portfolios().freeCollateralViewAggregateOnly(account);\n        require(fc >= 0, \"5\");\n\n        emit BatchOperation(account, msg.sender);\n ","after":"    function batchOperationWithdraw(\n        address account,\n        uint32 maxTime,\n        Common.Deposit[] calldata deposits,\n        Common.Trade[] calldata trades,\n        Common.Withdraw[] calldata withdraws\n    ) public payable {\n        uint32 blockTime = uint32(block.timestamp);\n        require(blockTime <= maxTime, \"18\");\n        require(msg.sender == account || isApprovedForAll(account, msg.sender), \"20\");\n        Portfolios().settleMaturedAssets(account);\n\n        TradeRecord[] memory tradeRecord;\n        if (deposits.length > 0 || msg.value != 0) Escrow().depositsOnBehalf{value : msg.value}(account, deposits);\n        if (trades.length > 0) tradeRecord = _batchTrade(account, trades);\n        if (withdraws.length > 0) {\n            if (tradeRecord.length > 0) {\n                _updateWithdrawsWithTradeRecord(tradeRecord, deposits, withdraws);\n            }\n\n            Escrow().withdrawsOnBehalf(account, withdraws);\n        }\n\n        int256 fc = Portfolios().freeCollateralViewAggregateOnly(account);\n        require(fc >= 0, \"5\");\n\n        emit BatchOperation(account, msg.sender);\n ","contract":"ERC1155Trade","time":0},{"type":"loop-calculation","before":"    uint128 lo","after":"// move outside for loop\n    uint128 lo","loc":{"start":{"line":3612,"column":12},"end":{"line":3612,"column":25}},"contract":"Escrow","time":0},{"type":"loop-calculation","before":"    uint128 collate","after":"// move outside for loop\n    uint128 collate","loc":{"start":{"line":3613,"column":12},"end":{"line":3613,"column":30}},"contract":"Escrow","time":0},{"type":"loop-calculation","before":"    int256 lo","after":"// move outside for loop\n    int256 lo","loc":{"start":{"line":3738,"column":12},"end":{"line":3738,"column":24}},"contract":"Escrow","time":0},{"type":"loop-calculation","before":"    uint128 collate","after":"// move outside for loop\n    uint128 collate","loc":{"start":{"line":3739,"column":12},"end":{"line":3739,"column":30}},"contract":"Escrow","time":0},{"type":"external-function ","before":"    function listCurrency(address token, TokenOptions memory options) public onlyOwner {\n        require(addressToCurrencyId[token] == 0 && token != WETH, \"19\");\n\n        maxCurrencyId++;\n        // We don't do a lot of checking here but since this is purely an administrative\n        // activity we just rely on governance not to set this improperly.\n        currencyIdToAddress[maxCurrencyId] = token;\n        addressToCurrencyId[token] = maxCurrencyId;\n        tokenOptions[token] = options;\n        uint256 decimals = IERC20(token).decimals();\n        currencyIdToDecimals[maxCurrencyId] = 10 ** (decimals);\n        // We need to set this number so that the free collateral check can provision\n        // the right number of currencies.\n        Portfolios().setNumCurrencies(maxCurrencyId);\n\n        emit NewCurrency(token);\n ","after":"    function listCurrency(address token, TokenOptions calldata options) public onlyOwner {\n        require(addressToCurrencyId[token] == 0 && token != WETH, \"19\");\n\n        maxCurrencyId++;\n        // We don't do a lot of checking here but since this is purely an administrative\n        // activity we just rely on governance not to set this improperly.\n        currencyIdToAddress[maxCurrencyId] = token;\n        addressToCurrencyId[token] = maxCurrencyId;\n        tokenOptions[token] = options;\n        uint256 decimals = IERC20(token).decimals();\n        currencyIdToDecimals[maxCurrencyId] = 10 ** (decimals);\n        // We need to set this number so that the free collateral check can provision\n        // the right number of currencies.\n        Portfolios().setNumCurrencies(maxCurrencyId);\n\n        emit NewCurrency(token);\n ","contract":"Escrow","time":0},{"type":"external-function ","before":"    function convertBalancesToETH(int256[] memory amounts) public override view returns (int256[] memory) {\n        // We expect values for all currencies to be supplied here, we will not do any work on 0 balances.\n        require(amounts.length == maxCurrencyId + 1, \"19\");\n        int256[] memory results = new int256[](amounts.length);\n\n        // Currency ID = 0 is already ETH so we don't need to convert it, unless it is negative. Then we will\n        // haircut it.\n        if (amounts[0] < 0) {\n            // We store the ETH buffer on the exchange rate back to itself.\n            uint128 buffer = exchangeRateOracles[0][0].buffer;\n            results[0] = amounts[0].mul(buffer).div(Common.DECIMALS);\n        } else {\n            results[0] = amounts[0];\n        }\n\n        for (uint256 i = 1; i < amounts.length; i++) {\n            if (amounts[i] == 0) continue;\n\n            ExchangeRate.Rate memory er = exchangeRateOracles[uint16(i)][0];\n            uint256 baseDecimals = currencyIdToDecimals[uint16(i)];\n\n            if (amounts[i] < 0) {\n                // We buffer negative amounts to enforce collateralization ratios\n                results[i] = ExchangeRate._convertToETH(er, baseDecimals, amounts[i], true);\n            } else {\n                // We do not buffer positive amounts so that they can be used to collateralize\n                // other debts.\n                results[i] = ExchangeRate._convertToETH(er, baseDecimals, amounts[i], false);\n            }\n        }\n\n        return results;\n ","after":"    function convertBalancesToETH(int256[] calldata amounts) public override view returns (int256[] memory) {\n        // We expect values for all currencies to be supplied here, we will not do any work on 0 balances.\n        require(amounts.length == maxCurrencyId + 1, \"19\");\n        int256[] memory results = new int256[](amounts.length);\n\n        // Currency ID = 0 is already ETH so we don't need to convert it, unless it is negative. Then we will\n        // haircut it.\n        if (amounts[0] < 0) {\n            // We store the ETH buffer on the exchange rate back to itself.\n            uint128 buffer = exchangeRateOracles[0][0].buffer;\n            results[0] = amounts[0].mul(buffer).div(Common.DECIMALS);\n        } else {\n            results[0] = amounts[0];\n        }\n\n        for (uint256 i = 1; i < amounts.length; i++) {\n            if (amounts[i] == 0) continue;\n\n            ExchangeRate.Rate memory er = exchangeRateOracles[uint16(i)][0];\n            uint256 baseDecimals = currencyIdToDecimals[uint16(i)];\n\n            if (amounts[i] < 0) {\n                // We buffer negative amounts to enforce collateralization ratios\n                results[i] = ExchangeRate._convertToETH(er, baseDecimals, amounts[i], true);\n            } else {\n                // We do not buffer positive amounts so that they can be used to collateralize\n                // other debts.\n                results[i] = ExchangeRate._convertToETH(er, baseDecimals, amounts[i], false);\n            }\n        }\n\n        return results;\n ","contract":"Escrow","time":0},{"type":"external-function ","before":"    function depositsOnBehalf(address account, Common.Deposit[] memory deposits) public payable override {\n        require(calledByERC1155Trade(), \"20\");\n\n        if (msg.value != 0) {\n            _depositEth(account);\n        }\n\n        for (uint256 i; i < deposits.length; i++) {\n            address tokenAddress = currencyIdToAddress[deposits[i].currencyId];\n            _deposit(account, tokenAddress, deposits[i].amount);\n        }\n ","after":"    function depositsOnBehalf(address account, Common.Deposit[] calldata deposits) public payable override {\n        require(calledByERC1155Trade(), \"20\");\n\n        if (msg.value != 0) {\n            _depositEth(account);\n        }\n\n        for (uint256 i; i < deposits.length; i++) {\n            address tokenAddress = currencyIdToAddress[deposits[i].currencyId];\n            _deposit(account, tokenAddress, deposits[i].amount);\n        }\n ","contract":"Escrow","time":0},{"type":"external-function ","before":"    function withdrawsOnBehalf(address account, Common.Withdraw[] memory withdraws) public override {\n        require(calledByERC1155Trade(), \"20\");\n\n        for (uint256 i; i < withdraws.length; i++) {\n            address tokenAddress = currencyIdToAddress[withdraws[i].currencyId];\n            uint128 amount;\n\n            if (withdraws[i].amount == 0) {\n                // If the amount is zero then we skip.\n                continue;\n            } else {\n                amount = withdraws[i].amount;\n            }\n\n            // We skip the free collateral check here because ERC1155.batchOperation will do the check\n            // before it exits.\n            _withdraw(account, withdraws[i].to, tokenAddress, amount, false);\n        }\n ","after":"    function withdrawsOnBehalf(address account, Common.Withdraw[] calldata withdraws) public override {\n        require(calledByERC1155Trade(), \"20\");\n\n        for (uint256 i; i < withdraws.length; i++) {\n            address tokenAddress = currencyIdToAddress[withdraws[i].currencyId];\n            uint128 amount;\n\n            if (withdraws[i].amount == 0) {\n                // If the amount is zero then we skip.\n                continue;\n            } else {\n                amount = withdraws[i].amount;\n            }\n\n            // We skip the free collateral check here because ERC1155.batchOperation will do the check\n            // before it exits.\n            _withdraw(account, withdraws[i].to, tokenAddress, amount, false);\n        }\n ","contract":"Escrow","time":0},{"type":"struct-data-arrangement ","before":"\n    address rateOr\n    uint128 rateDeci\n    bool mustIn\n    uint128 bu","after":"    address rateOr\n    uint128 rateDeci\n    uint128 bu\n    bool mustIn\n","contract":"ExchangeRate","time":0},{"type":"external-function ","before":"    function initialize(address _logic, address _admin, bytes memory _data) public payable {\n        require(_implementation() == address(0));\n        InitializableUpgradeabilityProxy.initialize(_logic, _data);\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n        _setAdmin(_admin);\n ","after":"    function initialize(address _logic, address _admin, bytes calldata _data) public payable {\n        require(_implementation() == address(0));\n        InitializableUpgradeabilityProxy.initialize(_logic, _data);\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n        _setAdmin(_admin);\n ","contract":"InitializableAdminUpgradeabilityProxy","time":0},{"type":"external-function ","before":"    function initialize(address _logic, bytes memory _data) public payable {\n        require(_implementation() == address(0));\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success,) = _logic.delegatecall(_data);\n            require(success);\n        }\n ","after":"    function initialize(address _logic, bytes calldata _data) public payable {\n        require(_implementation() == address(0));\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success,) = _logic.delegatecall(_data);\n            require(success);\n        }\n ","contract":"InitializableAdminUpgradeabilityProxy","time":0},{"type":"struct-data-arrangement ","before":"\n    uint128 localCurrencyRequ\n    int256 localCurrencyAvail\n    uint16 collateralCurr\n    int256 collateralCurrencyCashC\n    int256 collateralCurrencyAvail\n    uint128 discountFa\n    uint128 liquidityHai\n    IPortfoliosCallable Portfo","after":"    int256 localCurrencyAvail\n    int256 collateralCurrencyCashC\n    int256 collateralCurrencyAvail\n    IPortfoliosCallable Portfo\n    uint128 localCurrencyRequ\n    uint128 discountFa\n    uint128 liquidityHai\n    uint16 collateralCurr\n","contract":"Liquidation","time":0},{"type":"external-function ","before":"    function liquidate(\n        address payer,\n        int256 payerCollateralBalance,\n        Common.FreeCollateralFactors memory fc,\n        RateParameters memory rateParam,\n        address Portfolios,\n        uint128 maxLiquidateAmount\n    ) public returns (TransferAmounts memory) {\n        uint128 localCurrencyRequired = _fcAggregateToLocal(fc.aggregate, rateParam);\n\n        TransferAmounts memory transfer = TransferAmounts(0, 0, 0, payerCollateralBalance);\n        uint128 liquidityHaircut = EscrowStorageSlot._liquidityHaircut();\n        if (fc.localCashClaim > 0) {\n            // Account has a local currency cash claim denominated in liquidity tokens. We first extract that here.\n            (\n            transfer.netLocalCurrencyLiquidator,\n            transfer.netLocalCurrencyPayer,\n            fc.localNetAvailable,\n            localCurrencyRequired\n            ) = _liquidateLocalLiquidityTokens(\n                payer,\n                rateParam.localCurrency,\n                localCurrencyRequired,\n                liquidityHaircut,\n                fc.localNetAvailable,\n                IPortfoliosCallable(Portfolios)\n            );\n        }\n\n\n        // If we still require more local currency and we have debts in the local currency then we will trade\n        // collateral currency for local currency here.\n        if (localCurrencyRequired > 0 && fc.localNetAvailable < 0) {\n            _liquidateCollateralCurrency(\n                payer,\n                localCurrencyRequired,\n                liquidityHaircut,\n                transfer,\n                fc,\n                rateParam,\n                Portfolios,\n                maxLiquidateAmount\n            );\n        }\n\n        return transfer;\n ","after":"    function liquidate(\n        address payer,\n        int256 payerCollateralBalance,\n        Common.FreeCollateralFactors calldata fc,\n        RateParameters calldata rateParam,\n        address Portfolios,\n        uint128 maxLiquidateAmount\n    ) public returns (TransferAmounts memory) {\n        uint128 localCurrencyRequired = _fcAggregateToLocal(fc.aggregate, rateParam);\n\n        TransferAmounts memory transfer = TransferAmounts(0, 0, 0, payerCollateralBalance);\n        uint128 liquidityHaircut = EscrowStorageSlot._liquidityHaircut();\n        if (fc.localCashClaim > 0) {\n            // Account has a local currency cash claim denominated in liquidity tokens. We first extract that here.\n            (\n            transfer.netLocalCurrencyLiquidator,\n            transfer.netLocalCurrencyPayer,\n            fc.localNetAvailable,\n            localCurrencyRequired\n            ) = _liquidateLocalLiquidityTokens(\n                payer,\n                rateParam.localCurrency,\n                localCurrencyRequired,\n                liquidityHaircut,\n                fc.localNetAvailable,\n                IPortfoliosCallable(Portfolios)\n            );\n        }\n\n\n        // If we still require more local currency and we have debts in the local currency then we will trade\n        // collateral currency for local currency here.\n        if (localCurrencyRequired > 0 && fc.localNetAvailable < 0) {\n            _liquidateCollateralCurrency(\n                payer,\n                localCurrencyRequired,\n                liquidityHaircut,\n                transfer,\n                fc,\n                rateParam,\n                Portfolios,\n                maxLiquidateAmount\n            );\n        }\n\n        return transfer;\n ","contract":"Liquidation","time":0},{"type":"external-function ","before":"    function settle(\n        address payer,\n        int256 payerCollateralBalance,\n        uint128 valueToSettle,\n        Common.FreeCollateralFactors memory fc,\n        RateParameters memory rateParam,\n        address Portfolios\n    ) public returns (TransferAmounts memory) {\n        TransferAmounts memory transfer = TransferAmounts(0, 0, 0, payerCollateralBalance);\n        if (fc.localCashClaim > 0) {\n            uint128 remainder = IPortfoliosCallable(Portfolios).raiseCurrentCashViaLiquidityToken(\n                payer,\n                rateParam.localCurrency,\n                valueToSettle\n            );\n\n            transfer.netLocalCurrencyPayer = valueToSettle.sub(remainder);\n\n            if (transfer.netLocalCurrencyPayer > fc.localCashClaim) {\n                // If this is the case then we've raised cash that sits inside the haircut of the liquidity token\n                // and it will add collateral to the account. We calculate these factors here before moving on.\n                uint128 haircutAmount = transfer.netLocalCurrencyPayer.sub(uint128(fc.localCashClaim));\n\n                int256 netFC = ExchangeRate._convertToETH(\n                    rateParam.localToETH,\n                    rateParam.localDecimals,\n                    haircutAmount,\n                    fc.localNetAvailable < 0\n                );\n\n                // This net fc calculation is not completely accurate because the haircut amount can move the FC from\n                // negative to positive but that is irrelevant here. We just want to determine that the account has positive\n                // free collateral, the exact amount is not required.\n                fc.aggregate = fc.aggregate.add(netFC);\n            }\n        }\n\n        if (valueToSettle > transfer.netLocalCurrencyPayer && fc.aggregate >= 0) {\n            uint128 liquidityHaircut = EscrowStorageSlot._liquidityHaircut();\n            uint128 settlementDiscount = EscrowStorageSlot._settlementDiscount();\n            uint128 localCurrencyRequired = valueToSettle.sub(transfer.netLocalCurrencyPayer);\n\n            _tradeCollateralCurrency(\n                payer,\n                localCurrencyRequired,\n                liquidityHaircut,\n                settlementDiscount,\n                transfer,\n                fc,\n                rateParam,\n                Portfolios\n            );\n        }\n\n        return transfer;\n ","after":"    function settle(\n        address payer,\n        int256 payerCollateralBalance,\n        uint128 valueToSettle,\n        Common.FreeCollateralFactors calldata fc,\n        RateParameters memory rateParam,\n        address Portfolios\n    ) public returns (TransferAmounts memory) {\n        TransferAmounts memory transfer = TransferAmounts(0, 0, 0, payerCollateralBalance);\n        if (fc.localCashClaim > 0) {\n            uint128 remainder = IPortfoliosCallable(Portfolios).raiseCurrentCashViaLiquidityToken(\n                payer,\n                rateParam.localCurrency,\n                valueToSettle\n            );\n\n            transfer.netLocalCurrencyPayer = valueToSettle.sub(remainder);\n\n            if (transfer.netLocalCurrencyPayer > fc.localCashClaim) {\n                // If this is the case then we've raised cash that sits inside the haircut of the liquidity token\n                // and it will add collateral to the account. We calculate these factors here before moving on.\n                uint128 haircutAmount = transfer.netLocalCurrencyPayer.sub(uint128(fc.localCashClaim));\n\n                int256 netFC = ExchangeRate._convertToETH(\n                    rateParam.localToETH,\n                    rateParam.localDecimals,\n                    haircutAmount,\n                    fc.localNetAvailable < 0\n                );\n\n                // This net fc calculation is not completely accurate because the haircut amount can move the FC from\n                // negative to positive but that is irrelevant here. We just want to determine that the account has positive\n                // free collateral, the exact amount is not required.\n                fc.aggregate = fc.aggregate.add(netFC);\n            }\n        }\n\n        if (valueToSettle > transfer.netLocalCurrencyPayer && fc.aggregate >= 0) {\n            uint128 liquidityHaircut = EscrowStorageSlot._liquidityHaircut();\n            uint128 settlementDiscount = EscrowStorageSlot._settlementDiscount();\n            uint128 localCurrencyRequired = valueToSettle.sub(transfer.netLocalCurrencyPayer);\n\n            _tradeCollateralCurrency(\n                payer,\n                localCurrencyRequired,\n                liquidityHaircut,\n                settlementDiscount,\n                transfer,\n                fc,\n                rateParam,\n                Portfolios\n            );\n        }\n\n        return transfer;\n ","contract":"Liquidation","time":1},{"type":"external-function ","before":"    function settlefCash(\n        address payer,\n        address liquidator,\n        uint128 valueToSettle,\n        int256 collateralNetAvailable,\n        RateParameters memory rateParam,\n        address Portfolios\n    ) public returns (int256, uint128) {\n        uint128 discountFactor = EscrowStorageSlot._settlementDiscount();\n\n        return _tradefCash(\n            payer,\n            liquidator,\n            valueToSettle,\n            collateralNetAvailable,\n            discountFactor,\n            rateParam,\n            Portfolios\n        );\n ","after":"    function settlefCash(\n        address payer,\n        address liquidator,\n        uint128 valueToSettle,\n        int256 collateralNetAvailable,\n        RateParameters calldata rateParam,\n        address Portfolios\n    ) public returns (int256, uint128) {\n        uint128 discountFactor = EscrowStorageSlot._settlementDiscount();\n\n        return _tradefCash(\n            payer,\n            liquidator,\n            valueToSettle,\n            collateralNetAvailable,\n            discountFactor,\n            rateParam,\n            Portfolios\n        );\n ","contract":"Liquidation","time":0},{"type":"external-function ","before":"    function liquidatefCash(\n        address payer,\n        address liquidator,\n        int256 fcAggregate,\n        int256 localNetAvailable,\n        int256 collateralNetAvailable,\n        RateParameters memory rateParam,\n        address Portfolios\n    ) public returns (int256, uint128) {\n        uint128 localCurrencyRequired = _fcAggregateToLocal(fcAggregate, rateParam);\n        uint128 discountFactor = EscrowStorageSlot._liquidationDiscount();\n        require(localNetAvailable < 0, \"47\");\n\n        localCurrencyRequired = _calculateLocalCurrencyToTrade(\n            localCurrencyRequired,\n            discountFactor,\n            rateParam.localToETH.buffer,\n            uint128(localNetAvailable.neg())\n        );\n\n        return _tradefCash(\n            payer,\n            liquidator,\n            localCurrencyRequired,\n            collateralNetAvailable,\n            discountFactor,\n            rateParam,\n            Portfolios\n        );\n ","after":"    function liquidatefCash(\n        address payer,\n        address liquidator,\n        int256 fcAggregate,\n        int256 localNetAvailable,\n        int256 collateralNetAvailable,\n        RateParameters calldata rateParam,\n        address Portfolios\n    ) public returns (int256, uint128) {\n        uint128 localCurrencyRequired = _fcAggregateToLocal(fcAggregate, rateParam);\n        uint128 discountFactor = EscrowStorageSlot._liquidationDiscount();\n        require(localNetAvailable < 0, \"47\");\n\n        localCurrencyRequired = _calculateLocalCurrencyToTrade(\n            localCurrencyRequired,\n            discountFactor,\n            rateParam.localToETH.buffer,\n            uint128(localNetAvailable.neg())\n        );\n\n        return _tradefCash(\n            payer,\n            liquidator,\n            localCurrencyRequired,\n            collateralNetAvailable,\n            discountFactor,\n            rateParam,\n            Portfolios\n        );\n ","contract":"Liquidation","time":0},{"type":"external-function ","before":"    function liquidateCollateralCurrency(\n        address payer,\n        uint128 localCurrencyRequired,\n        uint128 liquidityHaircut,\n        Liquidation.TransferAmounts memory transfer,\n        Common.FreeCollateralFactors memory fc,\n        Liquidation.RateParameters memory rateParam,\n        address Portfolios\n    ) public {\n        Liquidation._liquidateCollateralCurrency(payer, localCurrencyRequired, liquidityHaircut, transfer, fc, rateParam, Portfolios, 0);\n\n        emit TradeCollateralCurrency(\n            transfer.netLocalCurrencyPayer,\n            transfer.netLocalCurrencyLiquidator,\n            transfer.collateralTransfer,\n            transfer.payerCollateralBalance\n        );\n ","after":"    function liquidateCollateralCurrency(\n        address payer,\n        uint128 localCurrencyRequired,\n        uint128 liquidityHaircut,\n        Liquidation.TransferAmounts calldata transfer,\n        Common.FreeCollateralFactors calldata fc,\n        Liquidation.RateParameters calldata rateParam,\n        address Portfolios\n    ) public {\n        Liquidation._liquidateCollateralCurrency(payer, localCurrencyRequired, liquidityHaircut, transfer, fc, rateParam, Portfolios, 0);\n\n        emit TradeCollateralCurrency(\n            transfer.netLocalCurrencyPayer,\n            transfer.netLocalCurrencyLiquidator,\n            transfer.collateralTransfer,\n            transfer.payerCollateralBalance\n        );\n ","contract":"MockLiquidation","time":0},{"type":"external-function ","before":"    function tradeCollateralCurrency(\n        address payer,\n        uint128 localCurrencyRequired,\n        uint128 liquidityHaircut,\n        uint128 discountFactor,\n        Liquidation.TransferAmounts memory transfer,\n        Common.FreeCollateralFactors memory fc,\n        Liquidation.RateParameters memory rateParam,\n        address Portfolios\n    ) public returns (uint128, uint128, int256) {\n        Liquidation._tradeCollateralCurrency(payer, localCurrencyRequired, liquidityHaircut, discountFactor, transfer, fc, rateParam, Portfolios);\n\n        emit TradeCollateralCurrency(\n            transfer.netLocalCurrencyPayer,\n            transfer.netLocalCurrencyLiquidator,\n            transfer.collateralTransfer,\n            transfer.payerCollateralBalance\n        );\n ","after":"    function tradeCollateralCurrency(\n        address payer,\n        uint128 localCurrencyRequired,\n        uint128 liquidityHaircut,\n        uint128 discountFactor,\n        Liquidation.TransferAmounts calldata transfer,\n        Common.FreeCollateralFactors calldata fc,\n        Liquidation.RateParameters calldata rateParam,\n        address Portfolios\n    ) public returns (uint128, uint128, int256) {\n        Liquidation._tradeCollateralCurrency(payer, localCurrencyRequired, liquidityHaircut, discountFactor, transfer, fc, rateParam, Portfolios);\n\n        emit TradeCollateralCurrency(\n            transfer.netLocalCurrencyPayer,\n            transfer.netLocalCurrencyLiquidator,\n            transfer.collateralTransfer,\n            transfer.payerCollateralBalance\n        );\n ","contract":"MockLiquidation","time":0},{"type":"external-function ","before":"    function calculateCollateralToSell(\n        uint128 discountFactor,\n        uint128 localCurrencyRequired,\n        Liquidation.RateParameters memory rateParam\n    ) public pure returns (uint128) {\n        return Liquidation._calculateCollateralToSell(discountFactor, localCurrencyRequired, rateParam);\n ","after":"    function calculateCollateralToSell(\n        uint128 discountFactor,\n        uint128 localCurrencyRequired,\n        Liquidation.RateParameters calldata rateParam\n    ) public pure returns (uint128) {\n        return Liquidation._calculateCollateralToSell(discountFactor, localCurrencyRequired, rateParam);\n ","contract":"MockLiquidation","time":0},{"type":"constant-restrict-modification  ","before":"    address public W","after":"    address public W","contract":"MockLiquidation","time":3},{"type":"constant-restrict-modification  ","before":"    uint16 public maxCurrenc","after":"    uint16 public maxCurrenc","contract":"MockLiquidation","time":3},{"type":"constant-restrict-modification  ","before":"    address public G_RESERVE_ACCO","after":"    address public G_RESERVE_ACCO","contract":"MockLiquidation","time":3},{"type":"external-function ","before":"    function getCashGroups(uint8[] memory groupIds) public override view returns (Common.CashGroup[] memory) {\n        Common.CashGroup[] memory results = new Common.CashGroup[](groupIds.length);\n\n        for (uint256 i; i < groupIds.length; i++) {\n            results[i] = cashGroups[groupIds[i]];\n        }\n\n        return results;\n ","after":"    function getCashGroups(uint8[] calldata groupIds) public override view returns (Common.CashGroup[] memory) {\n        Common.CashGroup[] memory results = new Common.CashGroup[](groupIds.length);\n\n        for (uint256 i; i < groupIds.length; i++) {\n            results[i] = cashGroups[groupIds[i]];\n        }\n\n        return results;\n ","contract":"Portfolios","time":0},{"type":"state-data-arrangement ","before":"\n    uint8 internal constant MAX_CASH_GROUPS = 0\n    Common.Asset internal NULL_AS\n    mapping(address => Common.Asset[]) internal _accountAss\n    mapping(uint8 => Common.CashGroup) public cashGro\n    uint8 public currentCashGrou\n    uint16 public G_NUM_CURRENC\n    uint256 public G_MAX_ASS","after":"    Common.Asset internal NULL_AS\n    mapping(address => Common.Asset[]) internal _accountAss\n    mapping(uint8 => Common.CashGroup) public cashGro\n    uint256 public G_MAX_ASS\n    uint16 public G_NUM_CURRENC\n    uint8 internal constant MAX_CASH_GROUPS = 0\n    uint8 public currentCashGrou\n","contract":"PortfoliosStorage","time":0},{"type":"external-function ","before":"    function upgradeAndCall(AdminUpgradeabilityProxy proxy, address implementation, bytes memory data) payable public onlyOwner {\n        proxy.upgradeToAndCall.value(msg.value)(implementation, data);\n ","after":"    function upgradeAndCall(AdminUpgradeabilityProxy proxy, address implementation, bytes calldata data) payable public onlyOwner {\n        proxy.upgradeToAndCall.value(msg.value)(implementation, data);\n ","contract":"ProxyAdmin","time":0},{"type":"external-function ","before":"    function getRequirement(\n        Common.Asset[] memory portfolio,\n        address Portfolios\n    ) public view returns (Common.Requirement[] memory) {\n        Common._sortPortfolio(portfolio);\n\n        // Each position in this array will hold the value of the portfolio in each maturity.\n        (Common.CashGroup[] memory cashGroups, CashLadder[] memory ladders) = _fetchCashGroups(\n            portfolio,\n            IPortfoliosCallable(Portfolios)\n        );\n\n        uint128 fCashHaircut = PortfoliosStorageSlot._fCashHaircut();\n        uint128 fCashMaxHaircut = PortfoliosStorageSlot._fCashMaxHaircut();\n        uint32 blockTime = uint32(block.timestamp);\n\n        int256[] memory cashClaims = _getCashLadders(\n            portfolio,\n            cashGroups,\n            ladders,\n            PortfoliosStorageSlot._liquidityHaircut(),\n            blockTime\n        );\n\n        // We now take the per cash group cash ladder and summarize it into a single requirement. The future\n        // cash group requirements will be aggregated into a single currency requirement in the free collateral function\n        Common.Requirement[] memory requirements = new Common.Requirement[](ladders.length);\n\n        for (uint256 i; i < ladders.length; i++) {\n            requirements[i].currency = ladders[i].currency;\n            requirements[i].cashClaim = cashClaims[i];\n            uint32 initialMaturity;\n            if (blockTime % cashGroups[i].maturityLength == 0) {\n                // If this is true then blockTime = maturity at index 0 and we do not add an offset.\n                initialMaturity = blockTime;\n            } else {\n                initialMaturity = blockTime - (blockTime % cashGroups[i].maturityLength) + cashGroups[i].maturityLength;\n            }\n\n            for (uint256 j; j < ladders[i].cashLadder.length; j++) {\n                int256 netfCash = ladders[i].cashLadder[j];\n                if (netfCash > 0) {\n                    uint32 maturity = initialMaturity + cashGroups[i].maturityLength * uint32(j);\n                    // If netfCash value is positive here then we have to haircut it.\n                    netfCash = _calculateReceiverValue(netfCash, maturity, blockTime, fCashHaircut, fCashMaxHaircut);\n                }\n\n                requirements[i].netfCashValue = requirements[i].netfCashValue.add(netfCash);\n            }\n        }\n\n        return requirements;\n ","after":"    function getRequirement(\n        Common.Asset[] calldata portfolio,\n        address Portfolios\n    ) public view returns (Common.Requirement[] memory) {\n        Common._sortPortfolio(portfolio);\n\n        // Each position in this array will hold the value of the portfolio in each maturity.\n        (Common.CashGroup[] memory cashGroups, CashLadder[] memory ladders) = _fetchCashGroups(\n            portfolio,\n            IPortfoliosCallable(Portfolios)\n        );\n\n        uint128 fCashHaircut = PortfoliosStorageSlot._fCashHaircut();\n        uint128 fCashMaxHaircut = PortfoliosStorageSlot._fCashMaxHaircut();\n        uint32 blockTime = uint32(block.timestamp);\n\n        int256[] memory cashClaims = _getCashLadders(\n            portfolio,\n            cashGroups,\n            ladders,\n            PortfoliosStorageSlot._liquidityHaircut(),\n            blockTime\n        );\n\n        // We now take the per cash group cash ladder and summarize it into a single requirement. The future\n        // cash group requirements will be aggregated into a single currency requirement in the free collateral function\n        Common.Requirement[] memory requirements = new Common.Requirement[](ladders.length);\n\n        for (uint256 i; i < ladders.length; i++) {\n            requirements[i].currency = ladders[i].currency;\n            requirements[i].cashClaim = cashClaims[i];\n            uint32 initialMaturity;\n            if (blockTime % cashGroups[i].maturityLength == 0) {\n                // If this is true then blockTime = maturity at index 0 and we do not add an offset.\n                initialMaturity = blockTime;\n            } else {\n                initialMaturity = blockTime - (blockTime % cashGroups[i].maturityLength) + cashGroups[i].maturityLength;\n            }\n\n            for (uint256 j; j < ladders[i].cashLadder.length; j++) {\n                int256 netfCash = ladders[i].cashLadder[j];\n                if (netfCash > 0) {\n                    uint32 maturity = initialMaturity + cashGroups[i].maturityLength * uint32(j);\n                    // If netfCash value is positive here then we have to haircut it.\n                    netfCash = _calculateReceiverValue(netfCash, maturity, blockTime, fCashHaircut, fCashMaxHaircut);\n                }\n\n                requirements[i].netfCashValue = requirements[i].netfCashValue.add(netfCash);\n            }\n        }\n\n        return requirements;\n ","contract":"RiskFramework","time":0}]}