{"time":593,"results":[{"type":"loop-calculation","before":"uint256 upperMargin = 10001e14;","after":"// move outside for loop\nuint256 upperMargin = 10001e14;","loc":{"start":{"line":3441,"column":12},"end":{"line":3441,"column":42}},"contract":"Manager","time":0},{"type":"loop-calculation","before":"uint256 lowerMargin = 9999e14;","after":"// move outside for loop\nuint256 lowerMargin = 9999e14;","loc":{"start":{"line":3443,"column":12},"end":{"line":3443,"column":41}},"contract":"Manager","time":0},{"type":"external-function ","before":"function collectPlatformInterest(\n\n        MassetStructs.BassetPersonal[] memory _bAssetPersonal,\n\n        MassetStructs.BassetData[] storage _bAssetData,\n\n        IInvariantValidator _forgeValidator,\n\n        MassetStructs.InvariantConfig memory _config\n\n    ) external returns (uint256 mintAmount, uint256[] memory rawGains) {\n\n        // Get basket details\n\n        MassetStructs.BassetData[] memory bAssetData_ = _bAssetData;\n\n        uint256 count = bAssetData_.length;\n\n        uint8[] memory indices = new uint8[](count);\n\n        rawGains = new uint256[](count);\n\n        // 1. Calculate rawGains in each bAsset, in comparison to current vault balance\n\n        for (uint256 i = 0; i < count; i++) {\n\n            indices[i] = uint8(i);\n\n            MassetStructs.BassetPersonal memory bPersonal = _bAssetPersonal[i];\n\n            MassetStructs.BassetData memory bData = bAssetData_[i];\n\n            // If there is no integration, then nothing can have accrued\n\n            if (bPersonal.integrator == address(0)) continue;\n\n            uint256 lending =\n\n            IPlatformIntegration(bPersonal.integrator).checkBalance(bPersonal.addr);\n\n            uint256 cache = 0;\n\n            if (!bPersonal.hasTxFee) {\n\n                cache = IERC20(bPersonal.addr).balanceOf(bPersonal.integrator);\n\n            }\n\n            uint256 balance = lending + cache;\n\n            uint256 oldVaultBalance = bData.vaultBalance;\n\n            if (\n\n                balance > oldVaultBalance && bPersonal.status == MassetStructs.BassetStatus.Normal\n\n            ) {\n\n                _bAssetData[i].vaultBalance = SafeCast.toUint128(balance);\n\n                uint256 interestDelta = balance - oldVaultBalance;\n\n                rawGains[i] = interestDelta;\n\n            } else {\n\n                rawGains[i] = 0;\n\n            }\n\n        }\n\n        mintAmount = _forgeValidator.computeMintMulti(bAssetData_, indices, rawGains, _config);\n\n    }","after":"function collectPlatformInterest(\n\n        MassetStructs.BassetPersonal[] calldata _bAssetPersonal,\n\n        MassetStructs.BassetData[] storage _bAssetData,\n\n        IInvariantValidator _forgeValidator,\n\n        MassetStructs.InvariantConfig calldata _config\n\n    ) external returns (uint256 mintAmount, uint256[] memory rawGains) {\n\n        // Get basket details\n\n        MassetStructs.BassetData[] memory bAssetData_ = _bAssetData;\n\n        uint256 count = bAssetData_.length;\n\n        uint8[] memory indices = new uint8[](count);\n\n        rawGains = new uint256[](count);\n\n        // 1. Calculate rawGains in each bAsset, in comparison to current vault balance\n\n        for (uint256 i = 0; i < count; i++) {\n\n            indices[i] = uint8(i);\n\n            MassetStructs.BassetPersonal memory bPersonal = _bAssetPersonal[i];\n\n            MassetStructs.BassetData memory bData = bAssetData_[i];\n\n            // If there is no integration, then nothing can have accrued\n\n            if (bPersonal.integrator == address(0)) continue;\n\n            uint256 lending =\n\n            IPlatformIntegration(bPersonal.integrator).checkBalance(bPersonal.addr);\n\n            uint256 cache = 0;\n\n            if (!bPersonal.hasTxFee) {\n\n                cache = IERC20(bPersonal.addr).balanceOf(bPersonal.integrator);\n\n            }\n\n            uint256 balance = lending + cache;\n\n            uint256 oldVaultBalance = bData.vaultBalance;\n\n            if (\n\n                balance > oldVaultBalance && bPersonal.status == MassetStructs.BassetStatus.Normal\n\n            ) {\n\n                _bAssetData[i].vaultBalance = SafeCast.toUint128(balance);\n\n                uint256 interestDelta = balance - oldVaultBalance;\n\n                rawGains[i] = interestDelta;\n\n            } else {\n\n                rawGains[i] = 0;\n\n            }\n\n        }\n\n        mintAmount = _forgeValidator.computeMintMulti(bAssetData_, indices, rawGains, _config);\n\n    }","contract":"Manager","time":0},{"type":"external-function ","before":"function depositTokens(\n\n        MassetStructs.BassetPersonal memory _bAsset,\n\n        uint256 _bAssetRatio,\n\n        uint256 _quantity,\n\n        uint256 _maxCache\n\n    ) external returns (uint256 quantityDeposited) {\n\n        // 0. If integration is 0, short circuit\n\n        if (_bAsset.integrator == address(0)) {\n\n            (uint256 received,) =\n\n            MassetHelpers.transferReturnBalance(\n\n                msg.sender,\n\n                address(this),\n\n                _bAsset.addr,\n\n                _quantity\n\n            );\n\n            return received;\n\n        }\n\n\n        // 1 - Send all to PI, using the opportunity to get the cache balance and net amount transferred\n\n        uint256 cacheBal;\n\n        (quantityDeposited, cacheBal) = MassetHelpers.transferReturnBalance(\n\n            msg.sender,\n\n            _bAsset.integrator,\n\n            _bAsset.addr,\n\n            _quantity\n\n        );\n\n\n        // 2 - Deposit X if necessary\n\n        // 2.1 - Deposit if xfer fees\n\n        if (_bAsset.hasTxFee) {\n\n            uint256 deposited =\n\n            IPlatformIntegration(_bAsset.integrator).deposit(\n\n                _bAsset.addr,\n\n                quantityDeposited,\n\n                true\n\n            );\n\n\n            return StableMath.min(deposited, quantityDeposited);\n\n        }\n\n        // 2.2 - Else Deposit X if Cache > %\n\n        // This check is in place to ensure that any token with a txFee is rejected\n\n        require(quantityDeposited == _quantity, \"Asset not fully transferred\");\n\n\n        uint256 relativeMaxCache = _maxCache.divRatioPrecisely(_bAssetRatio);\n\n\n        if (cacheBal > relativeMaxCache) {\n\n            uint256 delta = cacheBal - (relativeMaxCache / 2);\n\n            IPlatformIntegration(_bAsset.integrator).deposit(_bAsset.addr, delta, false);\n\n        }\n\n    }","after":"function depositTokens(\n\n        MassetStructs.BassetPersonal calldata _bAsset,\n\n        uint256 _bAssetRatio,\n\n        uint256 _quantity,\n\n        uint256 _maxCache\n\n    ) external returns (uint256 quantityDeposited) {\n\n        // 0. If integration is 0, short circuit\n\n        if (_bAsset.integrator == address(0)) {\n\n            (uint256 received,) =\n\n            MassetHelpers.transferReturnBalance(\n\n                msg.sender,\n\n                address(this),\n\n                _bAsset.addr,\n\n                _quantity\n\n            );\n\n            return received;\n\n        }\n\n\n        // 1 - Send all to PI, using the opportunity to get the cache balance and net amount transferred\n\n        uint256 cacheBal;\n\n        (quantityDeposited, cacheBal) = MassetHelpers.transferReturnBalance(\n\n            msg.sender,\n\n            _bAsset.integrator,\n\n            _bAsset.addr,\n\n            _quantity\n\n        );\n\n\n        // 2 - Deposit X if necessary\n\n        // 2.1 - Deposit if xfer fees\n\n        if (_bAsset.hasTxFee) {\n\n            uint256 deposited =\n\n            IPlatformIntegration(_bAsset.integrator).deposit(\n\n                _bAsset.addr,\n\n                quantityDeposited,\n\n                true\n\n            );\n\n\n            return StableMath.min(deposited, quantityDeposited);\n\n        }\n\n        // 2.2 - Else Deposit X if Cache > %\n\n        // This check is in place to ensure that any token with a txFee is rejected\n\n        require(quantityDeposited == _quantity, \"Asset not fully transferred\");\n\n\n        uint256 relativeMaxCache = _maxCache.divRatioPrecisely(_bAssetRatio);\n\n\n        if (cacheBal > relativeMaxCache) {\n\n            uint256 delta = cacheBal - (relativeMaxCache / 2);\n\n            IPlatformIntegration(_bAsset.integrator).deposit(_bAsset.addr, delta, false);\n\n        }\n\n    }","contract":"Manager","time":0},{"type":"external-function ","before":"function withdrawTokens(\n\n        uint256 _quantity,\n\n        MassetStructs.BassetPersonal memory _personal,\n\n        MassetStructs.BassetData memory _data,\n\n        address _recipient,\n\n        uint256 _maxCache\n\n    ) external {\n\n        if (_quantity == 0) return;\n\n\n        // 1.0 If there is no integrator, send from here\n\n        if (_personal.integrator == address(0)) {\n\n            IERC20(_personal.addr).safeTransfer(_recipient, _quantity);\n\n        }\n\n        // 1.1 If txFee then short circuit - there is no cache\n\n        else if (_personal.hasTxFee) {\n\n            IPlatformIntegration(_personal.integrator).withdraw(\n\n                _recipient,\n\n                _personal.addr,\n\n                _quantity,\n\n                _quantity,\n\n                true\n\n            );\n\n        }\n\n        // 1.2. Else, withdraw from either cache or main vault\n\n        else {\n\n            uint256 cacheBal = IERC20(_personal.addr).balanceOf(_personal.integrator);\n\n            // 2.1 - If balance b in cache, simply withdraw\n\n            if (cacheBal >= _quantity) {\n\n                IPlatformIntegration(_personal.integrator).withdrawRaw(\n\n                    _recipient,\n\n                    _personal.addr,\n\n                    _quantity\n\n                );\n\n            }\n\n            // 2.2 - Else reset the cache to X, or as far as possible\n\n            //       - Withdraw X+b from platform\n\n            //       - Send b to user\n\n            else {\n\n                uint256 relativeMidCache = _maxCache.divRatioPrecisely(_data.ratio) / 2;\n\n                uint256 totalWithdrawal =\n\n                StableMath.min(\n\n                    relativeMidCache + _quantity - cacheBal,\n\n                    _data.vaultBalance - SafeCast.toUint128(cacheBal)\n\n                );\n\n\n                IPlatformIntegration(_personal.integrator).withdraw(\n\n                    _recipient,\n\n                    _personal.addr,\n\n                    _quantity,\n\n                    totalWithdrawal,\n\n                    false\n\n                );\n\n            }\n\n        }\n\n    }","after":"function withdrawTokens(\n\n        uint256 _quantity,\n\n        MassetStructs.BassetPersonal calldata _personal,\n\n        MassetStructs.BassetData calldata _data,\n\n        address _recipient,\n\n        uint256 _maxCache\n\n    ) external {\n\n        if (_quantity == 0) return;\n\n\n        // 1.0 If there is no integrator, send from here\n\n        if (_personal.integrator == address(0)) {\n\n            IERC20(_personal.addr).safeTransfer(_recipient, _quantity);\n\n        }\n\n        // 1.1 If txFee then short circuit - there is no cache\n\n        else if (_personal.hasTxFee) {\n\n            IPlatformIntegration(_personal.integrator).withdraw(\n\n                _recipient,\n\n                _personal.addr,\n\n                _quantity,\n\n                _quantity,\n\n                true\n\n            );\n\n        }\n\n        // 1.2. Else, withdraw from either cache or main vault\n\n        else {\n\n            uint256 cacheBal = IERC20(_personal.addr).balanceOf(_personal.integrator);\n\n            // 2.1 - If balance b in cache, simply withdraw\n\n            if (cacheBal >= _quantity) {\n\n                IPlatformIntegration(_personal.integrator).withdrawRaw(\n\n                    _recipient,\n\n                    _personal.addr,\n\n                    _quantity\n\n                );\n\n            }\n\n            // 2.2 - Else reset the cache to X, or as far as possible\n\n            //       - Withdraw X+b from platform\n\n            //       - Send b to user\n\n            else {\n\n                uint256 relativeMidCache = _maxCache.divRatioPrecisely(_data.ratio) / 2;\n\n                uint256 totalWithdrawal =\n\n                StableMath.min(\n\n                    relativeMidCache + _quantity - cacheBal,\n\n                    _data.vaultBalance - SafeCast.toUint128(cacheBal)\n\n                );\n\n\n                IPlatformIntegration(_personal.integrator).withdraw(\n\n                    _recipient,\n\n                    _personal.addr,\n\n                    _quantity,\n\n                    totalWithdrawal,\n\n                    false\n\n                );\n\n            }\n\n        }\n\n    }","contract":"Manager","time":0},{"type":"loop-duplication","before":"\nstart line 4028 column 8, end line 4075 column 8\nfor (uint8 i = 0; i < len; i++) {\n\n            Basset memory bAsset = importedBasket.bassets[i];\n\n            address bAssetAddress = bAsset.addr;\n\n            bAssetIndexes[bAssetAddress] = i;\n\n\n            address integratorAddress = basketManager.getBassetIntegrator(bAssetAddress);\n\n            bAssetPersonal.push(\n\n                MassetStructs.BassetPersonal({\n\n            addr : bAssetAddress,\n\n            integrator : integratorAddress,\n\n            hasTxFee : false,\n\n            status : MassetStructs.BassetStatus.Normal\n\n            })\n\n            );\n\n\n            uint128 ratio = SafeCast.toUint128(bAsset.ratio);\n\n            uint128 vaultBalance = SafeCast.toUint128(bAsset.vaultBalance);\n\n            bAssetData.push(\n\n                MassetStructs.BassetData({ratio : ratio, vaultBalance : vaultBalance})\n\n            );\n\n\n            // caclulate scaled vault bAsset balance and totoal vault balance\n\n            uint128 scaledVaultBalance = (vaultBalance * ratio) / 1e8;\n\n            scaledVaultBalances[i] = scaledVaultBalance;\n\n            maxScaledVaultBalance += scaledVaultBalance;\n\n        }\nstart line 4094 column 8, end line 4098 column 8\nfor (uint8 i = 0; i < len; i++) {\n\n            require(scaledVaultBalances[i] < maxScaledVaultBalance, \"imbalanced\");\n\n        }","after":"// merge loop\n\nstart line 4028 column 8, end line 4075 column 8\nfor (uint8 i = 0; i < len; i++) {\n\n            Basset memory bAsset = importedBasket.bassets[i];\n\n            address bAssetAddress = bAsset.addr;\n\n            bAssetIndexes[bAssetAddress] = i;\n\n\n            address integratorAddress = basketManager.getBassetIntegrator(bAssetAddress);\n\n            bAssetPersonal.push(\n\n                MassetStructs.BassetPersonal({\n\n            addr : bAssetAddress,\n\n            integrator : integratorAddress,\n\n            hasTxFee : false,\n\n            status : MassetStructs.BassetStatus.Normal\n\n            })\n\n            );\n\n\n            uint128 ratio = SafeCast.toUint128(bAsset.ratio);\n\n            uint128 vaultBalance = SafeCast.toUint128(bAsset.vaultBalance);\n\n            bAssetData.push(\n\n                MassetStructs.BassetData({ratio : ratio, vaultBalance : vaultBalance})\n\n            );\n\n\n            // caclulate scaled vault bAsset balance and totoal vault balance\n\n            uint128 scaledVaultBalance = (vaultBalance * ratio) / 1e8;\n\n            scaledVaultBalances[i] = scaledVaultBalance;\n\n            maxScaledVaultBalance += scaledVaultBalance;\n\n        }\nstart line 4094 column 8, end line 4098 column 8\nfor (uint8 i = 0; i < len; i++) {\n\n            require(scaledVaultBalances[i] < maxScaledVaultBalance, \"imbalanced\");\n\n        }","contract":"Migrator","time":0},{"type":"de-morgan-condition ","before":"!basket_.undergoingRecol && !basket_.failed","after":"!(basket_.undergoingRecol && basket_.failed)","loc":{"start":{"line":4512,"column":16},"end":{"line":4512,"column":53}},"contract":"MusdV3","time":0},{"type":"state-data-arrangement ","before":"\nIInvariantValidator public forgeValidator;\nbool private forgeValidatorLocked;\naddress private deprecated_basketManager;\nuint256 public swapFee;\nuint256 private MAX_FEE;\nuint256 public redemptionFee;\nuint256 public cacheSize;\nuint256 public surplus;\nBassetPersonal[] public bAssetPersonal;\nBassetData[] public bAssetData;\nmapping(address => uint8) public override bAssetIndexes;\nuint8 public maxBassets;\nBasketState public basket;\nuint256 private constant A_PRECISION = 100;\nAmpData public ampData;\nWeightLimits public weightLimits;","after":"IInvariantValidator public forgeValidator;\nuint256 public swapFee;\nuint256 private MAX_FEE;\nuint256 public redemptionFee;\nuint256 public cacheSize;\nuint256 public surplus;\nBassetPersonal[] public bAssetPersonal;\nBassetData[] public bAssetData;\nmapping(address => uint8) public override bAssetIndexes;\nBasketState public basket;\nuint256 private constant A_PRECISION = 100;\nAmpData public ampData;\nWeightLimits public weightLimits;\naddress private deprecated_basketManager;\nbool private forgeValidatorLocked;\nuint8 public maxBassets;\n","contract":"MusdV3","time":0},{"type":"external-function ","before":"function upgrade(\n\n        address _forgeValidator,\n\n        InvariantConfig memory _config\n\n    ) public {\n\n        // prevent upgrade being run again by checking the old basket manager\n\n        require(deprecated_basketManager != address(0), \"already upgraded\");\n\n        // Read the Basket Manager details from the mUSD proxy's storage into memory\n\n        IBasketManager basketManager = IBasketManager(deprecated_basketManager);\n\n        // Update the storage of the Basket Manager in the mUSD Proxy\n\n        deprecated_basketManager = address(0);\n\n        // Set the state to be undergoingRecol in order to pause after upgrade\n\n        basket.undergoingRecol = true;\n\n\n        forgeValidator = IInvariantValidator(_forgeValidator);\n\n\n        Migrator.upgrade(basketManager, bAssetPersonal, bAssetData, bAssetIndexes);\n\n\n        // Set new V3.0 storage variables\n\n        maxBassets = 10;\n\n        uint64 startA = SafeCast.toUint64(_config.a * A_PRECISION);\n\n        ampData = AmpData(startA, startA, 0, 0);\n\n        weightLimits = _config.limits;\n\n    }","after":"function upgrade(\n\n        address _forgeValidator,\n\n        InvariantConfig calldata _config\n\n    ) public {\n\n        // prevent upgrade being run again by checking the old basket manager\n\n        require(deprecated_basketManager != address(0), \"already upgraded\");\n\n        // Read the Basket Manager details from the mUSD proxy's storage into memory\n\n        IBasketManager basketManager = IBasketManager(deprecated_basketManager);\n\n        // Update the storage of the Basket Manager in the mUSD Proxy\n\n        deprecated_basketManager = address(0);\n\n        // Set the state to be undergoingRecol in order to pause after upgrade\n\n        basket.undergoingRecol = true;\n\n\n        forgeValidator = IInvariantValidator(_forgeValidator);\n\n\n        Migrator.upgrade(basketManager, bAssetPersonal, bAssetData, bAssetIndexes);\n\n\n        // Set new V3.0 storage variables\n\n        maxBassets = 10;\n\n        uint64 startA = SafeCast.toUint64(_config.a * A_PRECISION);\n\n        ampData = AmpData(startA, startA, 0, 0);\n\n        weightLimits = _config.limits;\n\n    }","contract":"MusdV3","time":0},{"type":"constant-restrict-modification  ","before":"bool private forgeValidatorLocked;","after":"bool private constant forgeValidatorLocked;","contract":"MusdV3","time":1},{"type":"constant-restrict-modification  ","before":"uint256 private MAX_FEE;","after":"uint256 private constant MAX_FEE;","contract":"MusdV3","time":1},{"type":"constant-restrict-modification  ","before":"address private nexus_depricated;","after":"address private constant nexus_depricated;","contract":"MusdV3","time":1},{"type":"constant-restrict-modification  ","before":"bytes32 private KEY_GOVERNANCE_DEPRICATED;","after":"bytes32 private constant KEY_GOVERNANCE_DEPRICATED;","contract":"MusdV3","time":1},{"type":"constant-restrict-modification  ","before":"bytes32 private KEY_STAKING_DEPRICATED;","after":"bytes32 private constant KEY_STAKING_DEPRICATED;","contract":"MusdV3","time":1},{"type":"constant-restrict-modification  ","before":"bytes32 private KEY_PROXY_ADMIN_DEPRICATED;","after":"bytes32 private constant KEY_PROXY_ADMIN_DEPRICATED;","contract":"MusdV3","time":1},{"type":"constant-restrict-modification  ","before":"bytes32 private KEY_ORACLE_HUB_DEPRICATED;","after":"bytes32 private constant KEY_ORACLE_HUB_DEPRICATED;","contract":"MusdV3","time":1},{"type":"constant-restrict-modification  ","before":"bytes32 private KEY_MANAGER_DEPRICATED;","after":"bytes32 private constant KEY_MANAGER_DEPRICATED;","contract":"MusdV3","time":1},{"type":"constant-restrict-modification  ","before":"bytes32 private KEY_RECOLLATERALISER_DEPRICATED;","after":"bytes32 private constant KEY_RECOLLATERALISER_DEPRICATED;","contract":"MusdV3","time":1},{"type":"constant-restrict-modification  ","before":"bytes32 private KEY_META_TOKEN_DEPRICATED;","after":"bytes32 private constant KEY_META_TOKEN_DEPRICATED;","contract":"MusdV3","time":1},{"type":"constant-restrict-modification  ","before":"bytes32 private KEY_SAVINGS_MANAGER_DEPRICATED;","after":"bytes32 private constant KEY_SAVINGS_MANAGER_DEPRICATED;","contract":"MusdV3","time":1}]}