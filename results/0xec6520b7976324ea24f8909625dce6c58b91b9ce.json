{"time":148,"results":[{"type":"state-data-arrangement ","before":"\nstring public _FILTER_NAME_;\naddress public _NFT_COLLECTION_;\nuint256 public _NFT_ID_START_;\nuint256 public _NFT_ID_END_ = uint256(- 1);\nmapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\nmapping(uint256 => uint256) public _NFT_RESERVE_;\nuint256[] public _NFT_IDS_;\nmapping(uint256 => uint256) public _TOKENID_IDX_;\nuint256 public _TOTAL_NFT_AMOUNT_;\nuint256 public _MAX_NFT_AMOUNT_;\nuint256 public _MIN_NFT_AMOUNT_;\nuint256 public _GS_START_IN_;\nuint256 public _CR_IN_;\nbool public _NFT_IN_TOGGLE_ = false;\nuint256 public _GS_START_RANDOM_OUT_;\nuint256 public _CR_RANDOM_OUT_;\nbool public _NFT_RANDOM_OUT_TOGGLE_ = false;\nuint256 public _GS_START_TARGET_OUT_;\nuint256 public _CR_TARGET_OUT_;\nbool public _NFT_TARGET_OUT_TOGGLE_ = false;","after":"string public _FILTER_NAME_;\nuint256 public _NFT_ID_START_;\nuint256 public _NFT_ID_END_ = uint256(- 1);\nmapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\nmapping(uint256 => uint256) public _NFT_RESERVE_;\nuint256[] public _NFT_IDS_;\nmapping(uint256 => uint256) public _TOKENID_IDX_;\nuint256 public _TOTAL_NFT_AMOUNT_;\nuint256 public _MAX_NFT_AMOUNT_;\nuint256 public _MIN_NFT_AMOUNT_;\nuint256 public _GS_START_IN_;\nuint256 public _CR_IN_;\nuint256 public _GS_START_RANDOM_OUT_;\nuint256 public _CR_RANDOM_OUT_;\nuint256 public _GS_START_TARGET_OUT_;\nuint256 public _CR_TARGET_OUT_;\naddress public _NFT_COLLECTION_;\nbool public _NFT_IN_TOGGLE_ = false;\nbool public _NFT_RANDOM_OUT_TOGGLE_ = false;\nbool public _NFT_TARGET_OUT_TOGGLE_ = false;\n","contract":"BaseFilterV1","time":0},{"type":"loop-calculation","before":"uint256 randomNum = _getRandomNum() % _TOTAL_NFT_AMOUNT_;","after":"// move outside for loop\nuint256 randomNum = _getRandomNum() % _TOTAL_NFT_AMOUNT_;","loc":{"start":{"line":1709,"column":12},"end":{"line":1709,"column":68}},"contract":"FilterERC1155V1","time":0},{"type":"external-function ","before":"function init(\n\n        address filterAdmin,\n\n        address nftCollection,\n\n        bool[] memory toggles,\n\n        string memory filterName,\n\n        uint256[] memory numParams, //0 - startId, 1 - endId, 2 - maxAmount, 3 - minAmount\n\n        uint256[] memory priceRules,\n\n        uint256[] memory spreadIds\n\n    ) external {\n\n        initOwner(filterAdmin);\n\n\n        _changeFilterName(filterName);\n\n        _NFT_COLLECTION_ = nftCollection;\n\n\n        _changeNFTInPrice(priceRules[0], priceRules[1], toggles[0]);\n\n        _changeNFTRandomOutPrice(priceRules[2], priceRules[3], toggles[1]);\n\n        _changeNFTTargetOutPrice(priceRules[4], priceRules[5], toggles[2]);\n\n\n        _changeNFTAmountRange(numParams[2], numParams[3]);\n\n\n        _changeTokenIdRange(numParams[0], numParams[1]);\n\n        for (uint256 i = 0; i < spreadIds.length; i++) {\n\n            _SPREAD_IDS_REGISTRY_[spreadIds[i]] = true;\n\n            emit ChangeTokenIdMap(spreadIds[i], true);\n\n        }\n\n\n        emit FilterInit(filterAdmin, nftCollection, filterName);\n\n    }","after":"function init(\n\n        address filterAdmin,\n\n        address nftCollection,\n\n        bool[] calldata toggles,\n\n        string calldata filterName,\n\n        uint256[] calldata numParams, //0 - startId, 1 - endId, 2 - maxAmount, 3 - minAmount\n\n        uint256[] calldata priceRules,\n\n        uint256[] calldata spreadIds\n\n    ) external {\n\n        initOwner(filterAdmin);\n\n\n        _changeFilterName(filterName);\n\n        _NFT_COLLECTION_ = nftCollection;\n\n\n        _changeNFTInPrice(priceRules[0], priceRules[1], toggles[0]);\n\n        _changeNFTRandomOutPrice(priceRules[2], priceRules[3], toggles[1]);\n\n        _changeNFTTargetOutPrice(priceRules[4], priceRules[5], toggles[2]);\n\n\n        _changeNFTAmountRange(numParams[2], numParams[3]);\n\n\n        _changeTokenIdRange(numParams[0], numParams[1]);\n\n        for (uint256 i = 0; i < spreadIds.length; i++) {\n\n            _SPREAD_IDS_REGISTRY_[spreadIds[i]] = true;\n\n            emit ChangeTokenIdMap(spreadIds[i], true);\n\n        }\n\n\n        emit FilterInit(filterAdmin, nftCollection, filterName);\n\n    }","contract":"FilterERC1155V1","time":0},{"type":"external-function ","before":"function ERC1155In(uint256[] memory tokenIds, address to)\n\n    external\n\n    preventReentrant\n\n    returns (uint256 received)\n\n    {\n\n        uint256 avaliableNFTInAmount = getAvaliableNFTInAmount();\n\n        uint256 originTotalNftAmount = _TOTAL_NFT_AMOUNT_;\n\n\n        uint256 totalAmount = 0;\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n\n            uint256 tokenId = tokenIds[i];\n\n            require(isNFTIDValid(tokenId), \"NFT_ID_NOT_SUPPORT\");\n\n            uint256 inAmount = _maintainERC1155In(tokenId);\n\n            totalAmount = totalAmount.add(inAmount);\n\n            emit NftIn(tokenId, inAmount);\n\n        }\n\n        require(totalAmount <= avaliableNFTInAmount, \"EXCEDD_IN_AMOUNT\");\n\n        (uint256 rawReceive,) = _queryNFTIn(originTotalNftAmount, originTotalNftAmount + totalAmount);\n\n        received = IFilterAdmin(_OWNER_).mintFragTo(to, rawReceive);\n\n\n        emit NftInOrder(to, received);\n\n    }","after":"function ERC1155In(uint256[] calldata tokenIds, address to)\n\n    external\n\n    preventReentrant\n\n    returns (uint256 received)\n\n    {\n\n        uint256 avaliableNFTInAmount = getAvaliableNFTInAmount();\n\n        uint256 originTotalNftAmount = _TOTAL_NFT_AMOUNT_;\n\n\n        uint256 totalAmount = 0;\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n\n            uint256 tokenId = tokenIds[i];\n\n            require(isNFTIDValid(tokenId), \"NFT_ID_NOT_SUPPORT\");\n\n            uint256 inAmount = _maintainERC1155In(tokenId);\n\n            totalAmount = totalAmount.add(inAmount);\n\n            emit NftIn(tokenId, inAmount);\n\n        }\n\n        require(totalAmount <= avaliableNFTInAmount, \"EXCEDD_IN_AMOUNT\");\n\n        (uint256 rawReceive,) = _queryNFTIn(originTotalNftAmount, originTotalNftAmount + totalAmount);\n\n        received = IFilterAdmin(_OWNER_).mintFragTo(to, rawReceive);\n\n\n        emit NftInOrder(to, received);\n\n    }","contract":"FilterERC1155V1","time":0},{"type":"external-function ","before":"function ERC1155TargetOut(\n\n        uint256[] memory tokenIds,\n\n        uint256[] memory amounts,\n\n        address to,\n\n        uint256 maxBurnAmount\n\n    ) external preventReentrant returns (uint256 paid) {\n\n        require(tokenIds.length == amounts.length, \"PARAM_INVALID\");\n\n        uint256 avaliableNFTOutAmount = getAvaliableNFTOutAmount();\n\n        uint256 originTotalNftAmount = _TOTAL_NFT_AMOUNT_;\n\n\n        uint256 totalAmount = 0;\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n\n            totalAmount = totalAmount.add(amounts[i]);\n\n            _transferOutERC1155(to, tokenIds[i], amounts[i]);\n\n            emit TargetOut(tokenIds[i], amounts[i]);\n\n        }\n\n        require(totalAmount <= avaliableNFTOutAmount, \"EXCEED_OUT_AMOUNT\");\n\n        (uint256 rawPay,) = _queryNFTTargetOut(originTotalNftAmount - totalAmount, originTotalNftAmount);\n\n        paid = IFilterAdmin(_OWNER_).burnFragFrom(msg.sender, rawPay);\n\n        require(paid <= maxBurnAmount, \"BURN_AMOUNT_EXCEED\");\n\n\n        emit TargetOutOrder(msg.sender, paid);\n\n    }","after":"function ERC1155TargetOut(\n\n        uint256[] calldata tokenIds,\n\n        uint256[] calldata amounts,\n\n        address to,\n\n        uint256 maxBurnAmount\n\n    ) external preventReentrant returns (uint256 paid) {\n\n        require(tokenIds.length == amounts.length, \"PARAM_INVALID\");\n\n        uint256 avaliableNFTOutAmount = getAvaliableNFTOutAmount();\n\n        uint256 originTotalNftAmount = _TOTAL_NFT_AMOUNT_;\n\n\n        uint256 totalAmount = 0;\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n\n            totalAmount = totalAmount.add(amounts[i]);\n\n            _transferOutERC1155(to, tokenIds[i], amounts[i]);\n\n            emit TargetOut(tokenIds[i], amounts[i]);\n\n        }\n\n        require(totalAmount <= avaliableNFTOutAmount, \"EXCEED_OUT_AMOUNT\");\n\n        (uint256 rawPay,) = _queryNFTTargetOut(originTotalNftAmount - totalAmount, originTotalNftAmount);\n\n        paid = IFilterAdmin(_OWNER_).burnFragFrom(msg.sender, rawPay);\n\n        require(paid <= maxBurnAmount, \"BURN_AMOUNT_EXCEED\");\n\n\n        emit TargetOutOrder(msg.sender, paid);\n\n    }","contract":"FilterERC1155V1","time":0},{"type":"external-function ","before":"function emergencyWithdraw(\n\n        address[] memory nftContract,\n\n        uint256[] memory tokenIds,\n\n        uint256[] memory amounts,\n\n        address to\n\n    ) external onlySuperOwner {\n\n        require(\n\n            nftContract.length == tokenIds.length && nftContract.length == amounts.length,\n\n            \"PARAM_INVALID\"\n\n        );\n\n        address controller = IFilterAdmin(_OWNER_)._CONTROLLER_();\n\n        require(\n\n            IController(controller).isEmergencyWithdrawOpen(address(this)),\n\n            \"EMERGENCY_WITHDRAW_NOT_OPEN\"\n\n        );\n\n\n        for (uint256 i = 0; i < nftContract.length; i++) {\n\n            uint256 tokenId = tokenIds[i];\n\n            IERC1155(nftContract[i]).safeTransferFrom(address(this), to, tokenId, amounts[i], \"\");\n\n            if (_NFT_RESERVE_[tokenId] > 0 && nftContract[i] == _NFT_COLLECTION_) {\n\n                _maintainERC1155Out(tokenId);\n\n            }\n\n            emit EmergencyWithdraw(nftContract[i], tokenIds[i], amounts[i], to);\n\n        }\n\n    }","after":"function emergencyWithdraw(\n\n        address[] calldata nftContract,\n\n        uint256[] calldata tokenIds,\n\n        uint256[] calldata amounts,\n\n        address to\n\n    ) external onlySuperOwner {\n\n        require(\n\n            nftContract.length == tokenIds.length && nftContract.length == amounts.length,\n\n            \"PARAM_INVALID\"\n\n        );\n\n        address controller = IFilterAdmin(_OWNER_)._CONTROLLER_();\n\n        require(\n\n            IController(controller).isEmergencyWithdrawOpen(address(this)),\n\n            \"EMERGENCY_WITHDRAW_NOT_OPEN\"\n\n        );\n\n\n        for (uint256 i = 0; i < nftContract.length; i++) {\n\n            uint256 tokenId = tokenIds[i];\n\n            IERC1155(nftContract[i]).safeTransferFrom(address(this), to, tokenId, amounts[i], \"\");\n\n            if (_NFT_RESERVE_[tokenId] > 0 && nftContract[i] == _NFT_COLLECTION_) {\n\n                _maintainERC1155Out(tokenId);\n\n            }\n\n            emit EmergencyWithdraw(nftContract[i], tokenIds[i], amounts[i], to);\n\n        }\n\n    }","contract":"FilterERC1155V1","time":0},{"type":"external-function ","before":"function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n\n    external\n\n    onlySuperOwner\n\n    {\n\n        _changeTokenIdMap(tokenIds, isRegistered);\n\n    }","after":"function changeTokenIdMap(uint256[] calldata tokenIds, bool[] calldata isRegistered)\n\n    external\n\n    onlySuperOwner\n\n    {\n\n        _changeTokenIdMap(tokenIds, isRegistered);\n\n    }","contract":"FilterERC1155V1","time":0},{"type":"external-function ","before":"function changeFilterName(string memory newFilterName)\n\n    external\n\n    onlySuperOwner\n\n    {\n\n        _changeFilterName(newFilterName);\n\n    }","after":"function changeFilterName(string calldata newFilterName)\n\n    external\n\n    onlySuperOwner\n\n    {\n\n        _changeFilterName(newFilterName);\n\n    }","contract":"FilterERC1155V1","time":0},{"type":"external-function ","before":"function resetFilter(\n\n        string memory filterName,\n\n        bool[] memory toggles,\n\n        uint256[] memory numParams, //0 - startId, 1 - endId, 2 - maxAmount, 3 - minAmount\n\n        uint256[] memory priceRules,\n\n        uint256[] memory spreadIds,\n\n        bool[] memory isRegistered\n\n    ) external onlySuperOwner {\n\n        _changeFilterName(filterName);\n\n        _changeNFTInPrice(priceRules[0], priceRules[1], toggles[0]);\n\n        _changeNFTRandomOutPrice(priceRules[2], priceRules[3], toggles[1]);\n\n        _changeNFTTargetOutPrice(priceRules[4], priceRules[5], toggles[2]);\n\n\n        _changeNFTAmountRange(numParams[2], numParams[3]);\n\n        _changeTokenIdRange(numParams[0], numParams[1]);\n\n\n        _changeTokenIdMap(spreadIds, isRegistered);\n\n    }","after":"function resetFilter(\n\n        string calldata filterName,\n\n        bool[] calldata toggles,\n\n        uint256[] calldata numParams, //0 - startId, 1 - endId, 2 - maxAmount, 3 - minAmount\n\n        uint256[] calldata priceRules,\n\n        uint256[] calldata spreadIds,\n\n        bool[] calldata isRegistered\n\n    ) external onlySuperOwner {\n\n        _changeFilterName(filterName);\n\n        _changeNFTInPrice(priceRules[0], priceRules[1], toggles[0]);\n\n        _changeNFTRandomOutPrice(priceRules[2], priceRules[3], toggles[1]);\n\n        _changeNFTTargetOutPrice(priceRules[4], priceRules[5], toggles[2]);\n\n\n        _changeNFTAmountRange(numParams[2], numParams[3]);\n\n        _changeTokenIdRange(numParams[0], numParams[1]);\n\n\n        _changeTokenIdMap(spreadIds, isRegistered);\n\n    }","contract":"FilterERC1155V1","time":0}]}