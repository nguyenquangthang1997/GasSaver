{"time":104,"results":[{"type":"external-function ","before":"function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n\n        // Reject proposals before initiating as Governor\n\n        require(initialProposalId != 0, \"GovernorBravo::propose: Governor Bravo not active\");\n\n        require(rgt.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold, \"GovernorBravo::propose: proposer votes below proposal threshold\");\n\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorBravo::propose: proposal function information arity mismatch\");\n\n        require(targets.length != 0, \"GovernorBravo::propose: must provide actions\");\n\n        require(targets.length <= proposalMaxOperations, \"GovernorBravo::propose: too many actions\");\n\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n\n        if (latestProposalId != 0) {\n\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorBravo::propose: one live proposal per proposer, found an already active proposal\");\n\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorBravo::propose: one live proposal per proposer, found an already pending proposal\");\n\n        }\n\n\n        uint startBlock = add256(block.number, votingDelay);\n\n        uint endBlock = add256(startBlock, votingPeriod);\n\n\n        proposalCount++;\n\n        Proposal memory newProposal = Proposal({\n\n        id : proposalCount,\n\n        proposer : msg.sender,\n\n        eta : 0,\n\n        targets : targets,\n\n        values : values,\n\n        signatures : signatures,\n\n        calldatas : calldatas,\n\n        startBlock : startBlock,\n\n        endBlock : endBlock,\n\n        forVotes : 0,\n\n        againstVotes : 0,\n\n        abstainVotes : 0,\n\n        canceled : false,\n\n        executed : false\n\n        });\n\n\n        proposals[newProposal.id] = newProposal;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n\n        return newProposal.id;\n\n    }","after":"function propose(address[] calldata targets, uint[] calldata values, string[] calldata signatures, bytes[] calldata calldatas, string calldata description) public returns (uint) {\n\n        // Reject proposals before initiating as Governor\n\n        require(initialProposalId != 0, \"GovernorBravo::propose: Governor Bravo not active\");\n\n        require(rgt.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold, \"GovernorBravo::propose: proposer votes below proposal threshold\");\n\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorBravo::propose: proposal function information arity mismatch\");\n\n        require(targets.length != 0, \"GovernorBravo::propose: must provide actions\");\n\n        require(targets.length <= proposalMaxOperations, \"GovernorBravo::propose: too many actions\");\n\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n\n        if (latestProposalId != 0) {\n\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorBravo::propose: one live proposal per proposer, found an already active proposal\");\n\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorBravo::propose: one live proposal per proposer, found an already pending proposal\");\n\n        }\n\n\n        uint startBlock = add256(block.number, votingDelay);\n\n        uint endBlock = add256(startBlock, votingPeriod);\n\n\n        proposalCount++;\n\n        Proposal memory newProposal = Proposal({\n\n        id : proposalCount,\n\n        proposer : msg.sender,\n\n        eta : 0,\n\n        targets : targets,\n\n        values : values,\n\n        signatures : signatures,\n\n        calldatas : calldatas,\n\n        startBlock : startBlock,\n\n        endBlock : endBlock,\n\n        forVotes : 0,\n\n        againstVotes : 0,\n\n        abstainVotes : 0,\n\n        canceled : false,\n\n        executed : false\n\n        });\n\n\n        proposals[newProposal.id] = newProposal;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n\n        return newProposal.id;\n\n    }","contract":"GovernorBravoDelegate","time":0},{"type":"constant-restrict-modification  ","before":"  uint public initialProposalI","after":"  uint public initialProposalI","contract":"GovernorBravoDelegate","time":1},{"type":"constant-restrict-modification  ","before":"  address public implementatio","after":"  address public implementatio","contract":"GovernorBravoDelegate","time":1},{"type":"struct-data-arrangement ","before":"\n  uint \n  address propos\n  uint e\n  address[] targe\n  uint[] valu\n  string[] signatur\n  bytes[] calldat\n  uint startBlo\n  uint endBlo\n  uint forVot\n  uint againstVot\n  uint abstainVot\n  bool cancel\n  bool execut\n  mapping(address => Receipt) receip","after":"  uint \n  uint e\n  address[] targe\n  uint[] valu\n  string[] signatur\n  bytes[] calldat\n  uint startBlo\n  uint endBlo\n  uint forVot\n  uint againstVot\n  uint abstainVot\n  mapping(address => Receipt) receip\n  address propos\n  bool cancel\n  bool execut\n","contract":"GovernorBravoDelegateStorageV1","time":0}]}