{"time":551,"results":[{"type":"external-function ","before":"\n    function getDerivativeHash(Derivative memory _derivative) public pure returns (bytes32 derivativeHash) {\n\n        derivativeHash = keccak256(abi.encodePacked(\n\n                _derivative.margin,\n\n                _derivative.endTime,\n\n                _derivative.params,\n\n                _derivative.oracleId,\n\n                _derivative.token,\n\n                _derivative.syntheticId\n\n            ));\n\n","after":"\n    function getDerivativeHash(Derivative calldata _derivative) public pure returns (bytes32 derivativeHash) {\n\n        derivativeHash = keccak256(abi.encodePacked(\n\n                _derivative.margin,\n\n                _derivative.endTime,\n\n                _derivative.params,\n\n                _derivative.oracleId,\n\n                _derivative.token,\n\n                _derivative.syntheticId\n\n            ));\n\n","contract":"IDerivativeLogic","time":0},{"type":"immutable-restrict-modification ","before":"\n    address public initial","after":"\n    address public initial","contract":"Registry","time":0},{"type":"loop-duplication","before":"\nstart line 1632 column 8, end line 1644 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            uint256 e = A[i];\n\n            if (!contains(B, e)) {\n\n                includeMap[i] = true;\n\n                count++;\n\n            }\n\n    \nstart line 1652 column 8, end line 1664 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            if (includeMap[i]) {\n\n                newUints[j] = A[i];\n\n                newUintsIdxs[j] = i;\n\n                j++;\n\n            }\n\n    ","after":"// merge loop\n\nstart line 1632 column 8, end line 1644 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            uint256 e = A[i];\n\n            if (!contains(B, e)) {\n\n                includeMap[i] = true;\n\n                count++;\n\n            }\n\n    \nstart line 1652 column 8, end line 1664 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            if (includeMap[i]) {\n\n                newUints[j] = A[i];\n\n                newUintsIdxs[j] = i;\n\n                j++;\n\n            }\n\n    ","contract":"UintArray","time":0},{"type":"loop-duplication","before":"\nstart line 1679 column 8, end line 1689 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            if (contains(B, A[i])) {\n\n                includeMap[i] = true;\n\n                newLength++;\n\n            }\n\n    \nstart line 1699 column 8, end line 1713 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            if (includeMap[i]) {\n\n                newUints[j] = A[i];\n\n                newUintsAIdxs[j] = i;\n\n                (newUintsBIdxs[j],) = indexOf(B, A[i]);\n\n                j++;\n\n            }\n\n    ","after":"// merge loop\n\nstart line 1679 column 8, end line 1689 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            if (contains(B, A[i])) {\n\n                includeMap[i] = true;\n\n                newLength++;\n\n            }\n\n    \nstart line 1699 column 8, end line 1713 column 8\n     for (uint256 i = 0; i < length; i++) {\n\n            if (includeMap[i]) {\n\n                newUints[j] = A[i];\n\n                newUintsAIdxs[j] = i;\n\n                (newUintsBIdxs[j],) = indexOf(B, A[i]);\n\n                j++;\n\n            }\n\n    ","contract":"UintArray","time":0},{"type":"external-function ","before":"\n    function compose(uint256[] memory _tokenIds, uint256[] memory _tokenRatio, uint256 _quantity) public {\n\n        require(_tokenIds.length == _tokenRatio.length, \"TOKEN_MINTER:TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n\n            _burn(msg.sender, _tokenIds[i], _tokenRatio[i] * _quantity);\n\n        }\n\n\n        uint256 portfolioId = uint256(keccak256(abi.encodePacked(\n\n                _tokenIds,\n\n                _tokenRatio\n\n            )));\n\n\n        _registerPortfolio(portfolioId, _tokenIds, _tokenRatio);\n\n        _mint(portfolioId, msg.sender, _quantity);\n\n","after":"\n    function compose(uint256[] calldata _tokenIds, uint256[] calldata _tokenRatio, uint256 _quantity) public {\n\n        require(_tokenIds.length == _tokenRatio.length, \"TOKEN_MINTER:TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n\n            _burn(msg.sender, _tokenIds[i], _tokenRatio[i] * _quantity);\n\n        }\n\n\n        uint256 portfolioId = uint256(keccak256(abi.encodePacked(\n\n                _tokenIds,\n\n                _tokenRatio\n\n            )));\n\n\n        _registerPortfolio(portfolioId, _tokenIds, _tokenRatio);\n\n        _mint(portfolioId, msg.sender, _quantity);\n\n","contract":"TokenMinter","time":0},{"type":"external-function ","before":"\n    function decompose(uint256 _portfolioId, uint256[] memory _tokenIds, uint256[] memory _tokenRatio, uint256 _quantity) public {\n\n        require(_tokenIds.length == _tokenRatio.length, \"TOKEN_MINTER:TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n\n        uint256 portfolioId = uint256(keccak256(abi.encodePacked(\n\n                _tokenIds,\n\n                _tokenRatio\n\n            )));\n\n\n        require(portfolioId == _portfolioId, \"TOKEN_MINTER:WRONG_PORTFOLIO_ID\");\n\n        _burn(msg.sender, _portfolioId, _quantity);\n\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n\n            _mint(_tokenIds[i], msg.sender, _tokenRatio[i] * _quantity);\n\n        }\n\n","after":"\n    function decompose(uint256 _portfolioId, uint256[] calldata _tokenIds, uint256[] calldata _tokenRatio, uint256 _quantity) public {\n\n        require(_tokenIds.length == _tokenRatio.length, \"TOKEN_MINTER:TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_tokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n\n        uint256 portfolioId = uint256(keccak256(abi.encodePacked(\n\n                _tokenIds,\n\n                _tokenRatio\n\n            )));\n\n\n        require(portfolioId == _portfolioId, \"TOKEN_MINTER:WRONG_PORTFOLIO_ID\");\n\n        _burn(msg.sender, _portfolioId, _quantity);\n\n\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n\n            _mint(_tokenIds[i], msg.sender, _tokenRatio[i] * _quantity);\n\n        }\n\n","contract":"TokenMinter","time":0},{"type":"external-function ","before":"\n    function recompose(\n\n        uint256 _portfolioId,\n\n        uint256[] memory _initialTokenIds,\n\n        uint256[] memory _initialTokenRatio,\n\n        uint256[] memory _finalTokenIds,\n\n        uint256[] memory _finalTokenRatio,\n\n        uint256 _quantity\n\n    ) public {\n\n        require(_initialTokenIds.length == _initialTokenRatio.length, \"TOKEN_MINTER:INITIAL_TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_finalTokenIds.length == _finalTokenRatio.length, \"TOKEN_MINTER:FINAL_TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_initialTokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_finalTokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_initialTokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n        require(_finalTokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n\n        uint256 oldPortfolioId = uint256(keccak256(abi.encodePacked(\n\n                _initialTokenIds,\n\n                _initialTokenRatio\n\n            )));\n\n\n        require(oldPortfolioId == _portfolioId, \"TOKEN_MINTER:WRONG_PORTFOLIO_ID\");\n\n        _burn(msg.sender, _portfolioId, _quantity);\n\n\n        _removedIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n\n        _addedIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n\n        _keptIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n\n\n        uint256 newPortfolioId = uint256(keccak256(abi.encodePacked(\n\n                _finalTokenIds,\n\n                _finalTokenRatio\n\n            )));\n\n\n        _registerPortfolio(newPortfolioId, _finalTokenIds, _finalTokenRatio);\n\n        _mint(newPortfolioId, msg.sender, _quantity);\n\n","after":"\n    function recompose(\n\n        uint256 _portfolioId,\n\n        uint256[] calldata _initialTokenIds,\n\n        uint256[] calldata _initialTokenRatio,\n\n        uint256[] calldata _finalTokenIds,\n\n        uint256[] calldata _finalTokenRatio,\n\n        uint256 _quantity\n\n    ) public {\n\n        require(_initialTokenIds.length == _initialTokenRatio.length, \"TOKEN_MINTER:INITIAL_TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_finalTokenIds.length == _finalTokenRatio.length, \"TOKEN_MINTER:FINAL_TOKEN_IDS_AND_RATIO_LENGTH_DOES_NOT_MATCH\");\n\n        require(_quantity > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_initialTokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_finalTokenIds.length > 0, \"TOKEN_MINTER:WRONG_QUANTITY\");\n\n        require(_initialTokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n        require(_finalTokenIds.isUnique(), \"TOKEN_MINTER:TOKEN_IDS_NOT_UNIQUE\");\n\n\n        uint256 oldPortfolioId = uint256(keccak256(abi.encodePacked(\n\n                _initialTokenIds,\n\n                _initialTokenRatio\n\n            )));\n\n\n        require(oldPortfolioId == _portfolioId, \"TOKEN_MINTER:WRONG_PORTFOLIO_ID\");\n\n        _burn(msg.sender, _portfolioId, _quantity);\n\n\n        _removedIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n\n        _addedIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n\n        _keptIds(_initialTokenIds, _initialTokenRatio, _finalTokenIds, _finalTokenRatio, _quantity);\n\n\n        uint256 newPortfolioId = uint256(keccak256(abi.encodePacked(\n\n                _finalTokenIds,\n\n                _finalTokenRatio\n\n            )));\n\n\n        _registerPortfolio(newPortfolioId, _finalTokenIds, _finalTokenRatio);\n\n        _mint(newPortfolioId, msg.sender, _quantity);\n\n","contract":"TokenMinter","time":0},{"type":"external-function ","before":"\n    function batchTransferFrom(address _from, address _to, uint256[] memory _tokenIds, uint256[] memory _amounts) public {\n\n        // Batch Transfering\n\n        _batchTransferFrom(_from, _to, _tokenIds, _amounts);\n\n","after":"\n    function batchTransferFrom(address _from, address _to, uint256[] calldata _tokenIds, uint256[] calldata _amounts) public {\n\n        // Batch Transfering\n\n        _batchTransferFrom(_from, _to, _tokenIds, _amounts);\n\n","contract":"TokenMinter","time":0},{"type":"immutable-restrict-modification ","before":"\n    string internal baseToke","after":"\n    string internal baseToke","contract":"TokenMinter","time":1},{"type":"immutable-restrict-modification ","before":"\n    bytes32 public DOMAIN_SEPAR","after":"\n    bytes32 public DOMAIN_SEPAR","contract":"TokenMinter","time":1},{"type":"immutable-restrict-modification ","before":"\n    bytes32 public PERMIT_TYPE","after":"\n    bytes32 public PERMIT_TYPE","contract":"TokenMinter","time":1},{"type":"de-morgan-condition ","before":"uire(!dataRequested[oracleId][timestamp] && !dataExist[oracleId][times","after":"!(uire(dataRequested[oracleId][timestamp] && dataExist[oracleId][times)","loc":{"start":{"line":4217,"column":16},"end":{"line":4217,"column":85}},"contract":"OracleAggregator","time":0},{"type":"external-function ","before":"\n    function getAuthorCommission(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (uint256 commission) {\n\n        // Initialize derivative if wasn't initialized before\n\n        _initDerivative(_derivativeHash, _derivative);\n\n        commission = commissionByHash[_derivativeHash];\n\n","after":"\n    function getAuthorCommission(bytes32 _derivativeHash, Derivative calldata _derivative) public nonReentrant returns (uint256 commission) {\n\n        // Initialize derivative if wasn't initialized before\n\n        _initDerivative(_derivativeHash, _derivative);\n\n        commission = commissionByHash[_derivativeHash];\n\n","contract":"SyntheticAggregator","time":0},{"type":"external-function ","before":"\n    function getAuthorAddress(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (address authorAddress) {\n\n        // Initialize derivative if wasn't initialized before\n\n        _initDerivative(_derivativeHash, _derivative);\n\n        authorAddress = authorAddressByHash[_derivativeHash];\n\n","after":"\n    function getAuthorAddress(bytes32 _derivativeHash, Derivative calldata _derivative) public nonReentrant returns (address authorAddress) {\n\n        // Initialize derivative if wasn't initialized before\n\n        _initDerivative(_derivativeHash, _derivative);\n\n        authorAddress = authorAddressByHash[_derivativeHash];\n\n","contract":"SyntheticAggregator","time":0},{"type":"external-function ","before":"\n    function getMargin(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (uint256 buyerMargin, uint256 sellerMargin) {\n\n        // If it's a pool, just return margin from syntheticId contract\n\n        if (_isPool(_derivativeHash, _derivative)) {\n\n            return IDerivativeLogic(_derivative.syntheticId).getMargin(_derivative);\n\n        }\n\n\n        // Initialize derivative if wasn't initialized before\n\n        _initDerivative(_derivativeHash, _derivative);\n\n\n        // Check if margins for _derivativeHash were already cached\n\n        buyerMargin = buyerMarginByHash[_derivativeHash];\n\n        sellerMargin = sellerMarginByHash[_derivativeHash];\n\n","after":"\n    function getMargin(bytes32 _derivativeHash, Derivative calldata _derivative) public nonReentrant returns (uint256 buyerMargin, uint256 sellerMargin) {\n\n        // If it's a pool, just return margin from syntheticId contract\n\n        if (_isPool(_derivativeHash, _derivative)) {\n\n            return IDerivativeLogic(_derivative.syntheticId).getMargin(_derivative);\n\n        }\n\n\n        // Initialize derivative if wasn't initialized before\n\n        _initDerivative(_derivativeHash, _derivative);\n\n\n        // Check if margins for _derivativeHash were already cached\n\n        buyerMargin = buyerMarginByHash[_derivativeHash];\n\n        sellerMargin = sellerMarginByHash[_derivativeHash];\n\n","contract":"SyntheticAggregator","time":0},{"type":"external-function ","before":"\n    function isPool(bytes32 _derivativeHash, Derivative memory _derivative) public nonReentrant returns (bool result) {\n\n        result = _isPool(_derivativeHash, _derivative);\n\n","after":"\n    function isPool(bytes32 _derivativeHash, Derivative calldata _derivative) public nonReentrant returns (bool result) {\n\n        result = _isPool(_derivativeHash, _derivative);\n\n","contract":"SyntheticAggregator","time":0},{"type":"external-function ","before":"\n    function proposeWhitelist(address[] memory _whitelist) public onlyGovernor {\n\n        // Restrict empty proposals\n\n        require(_whitelist.length != 0, \"Can't be empty\");\n\n\n        // Consider empty whitelist as not initialized, as proposing of empty whitelists is not allowed\n\n        // If whitelist has never been initialized, we set whitelist right away without proposal\n\n        if (whitelist.length == 0) {\n\n            whitelist = _whitelist;\n\n            emit Committed(_whitelist);\n\n\n            // Otherwise save current time as timestamp of proposal, save proposed whitelist and emit event\n\n        } else {\n\n            proposalTime = now;\n\n            proposedWhitelist = _whitelist;\n\n            emit Proposed(_whitelist);\n\n        }\n\n","after":"\n    function proposeWhitelist(address[] calldata _whitelist) public onlyGovernor {\n\n        // Restrict empty proposals\n\n        require(_whitelist.length != 0, \"Can't be empty\");\n\n\n        // Consider empty whitelist as not initialized, as proposing of empty whitelists is not allowed\n\n        // If whitelist has never been initialized, we set whitelist right away without proposal\n\n        if (whitelist.length == 0) {\n\n            whitelist = _whitelist;\n\n            emit Committed(_whitelist);\n\n\n            // Otherwise save current time as timestamp of proposal, save proposed whitelist and emit event\n\n        } else {\n\n            proposalTime = now;\n\n            proposedWhitelist = _whitelist;\n\n            emit Proposed(_whitelist);\n\n        }\n\n","contract":"TokenSpender","time":0},{"type":"external-function ","before":"\n    function create(Derivative memory _derivative, uint256 _quantity, address[2] memory _addresses) public nonReentrant {\n\n        if (_addresses[1] == address(0)) {\n\n            _createPooled(_derivative, _quantity, _addresses[0]);\n\n        } else {\n\n            _create(_derivative, _quantity, _addresses);\n\n        }\n\n","after":"\n    function create(Derivative calldata _derivative, uint256 _quantity, address[2] calldata _addresses) public nonReentrant {\n\n        if (_addresses[1] == address(0)) {\n\n            _createPooled(_derivative, _quantity, _addresses[0]);\n\n        } else {\n\n            _create(_derivative, _quantity, _addresses);\n\n        }\n\n","contract":"Core","time":0},{"type":"external-function ","before":"\n    function execute(uint256 _tokenId, uint256 _quantity, Derivative memory _derivative) public nonReentrant {\n\n        uint256[] memory tokenIds = new uint256[](1);\n\n        uint256[] memory quantities = new uint256[](1);\n\n        Derivative[] memory derivatives = new Derivative[](1);\n\n\n        tokenIds[0] = _tokenId;\n\n        quantities[0] = _quantity;\n\n        derivatives[0] = _derivative;\n\n\n        _execute(msg.sender, tokenIds, quantities, derivatives);\n\n","after":"\n    function execute(uint256 _tokenId, uint256 _quantity, Derivative calldata _derivative) public nonReentrant {\n\n        uint256[] memory tokenIds = new uint256[](1);\n\n        uint256[] memory quantities = new uint256[](1);\n\n        Derivative[] memory derivatives = new Derivative[](1);\n\n\n        tokenIds[0] = _tokenId;\n\n        quantities[0] = _quantity;\n\n        derivatives[0] = _derivative;\n\n\n        _execute(msg.sender, tokenIds, quantities, derivatives);\n\n","contract":"Core","time":0},{"type":"external-function ","before":"\n    function execute(address _tokenOwner, uint256 _tokenId, uint256 _quantity, Derivative memory _derivative) public nonReentrant {\n\n        uint256[] memory tokenIds = new uint256[](1);\n\n        uint256[] memory quantities = new uint256[](1);\n\n        Derivative[] memory derivatives = new Derivative[](1);\n\n\n        tokenIds[0] = _tokenId;\n\n        quantities[0] = _quantity;\n\n        derivatives[0] = _derivative;\n\n\n        _execute(_tokenOwner, tokenIds, quantities, derivatives);\n\n","after":"\n    function execute(address _tokenOwner, uint256 _tokenId, uint256 _quantity, Derivative calldata _derivative) public nonReentrant {\n\n        uint256[] memory tokenIds = new uint256[](1);\n\n        uint256[] memory quantities = new uint256[](1);\n\n        Derivative[] memory derivatives = new Derivative[](1);\n\n\n        tokenIds[0] = _tokenId;\n\n        quantities[0] = _quantity;\n\n        derivatives[0] = _derivative;\n\n\n        _execute(_tokenOwner, tokenIds, quantities, derivatives);\n\n","contract":"Core","time":0},{"type":"external-function ","before":"\n    function execute(uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) public nonReentrant {\n\n        _execute(msg.sender, _tokenIds, _quantities, _derivatives);\n\n","after":"\n    function execute(uint256[] calldata _tokenIds, uint256[] calldata _quantities, Derivative[] calldata _derivatives) public nonReentrant {\n\n        _execute(msg.sender, _tokenIds, _quantities, _derivatives);\n\n","contract":"Core","time":0},{"type":"external-function ","before":"\n    function execute(address _tokenOwner, uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) public nonReentrant {\n\n        _execute(_tokenOwner, _tokenIds, _quantities, _derivatives);\n\n","after":"\n    function execute(address _tokenOwner, uint256[] calldata _tokenIds, uint256[] calldata _quantities, Derivative[] calldata _derivatives) public nonReentrant {\n\n        _execute(_tokenOwner, _tokenIds, _quantities, _derivatives);\n\n","contract":"Core","time":0},{"type":"external-function ","before":"\n    function cancel(uint256 _tokenId, uint256 _quantity, Derivative memory _derivative) public nonReentrant {\n\n        uint256[] memory tokenIds = new uint256[](1);\n\n        uint256[] memory quantities = new uint256[](1);\n\n        Derivative[] memory derivatives = new Derivative[](1);\n\n\n        tokenIds[0] = _tokenId;\n\n        quantities[0] = _quantity;\n\n        derivatives[0] = _derivative;\n\n\n        _cancel(tokenIds, quantities, derivatives);\n\n","after":"\n    function cancel(uint256 _tokenId, uint256 _quantity, Derivative calldata _derivative) public nonReentrant {\n\n        uint256[] memory tokenIds = new uint256[](1);\n\n        uint256[] memory quantities = new uint256[](1);\n\n        Derivative[] memory derivatives = new Derivative[](1);\n\n\n        tokenIds[0] = _tokenId;\n\n        quantities[0] = _quantity;\n\n        derivatives[0] = _derivative;\n\n\n        _cancel(tokenIds, quantities, derivatives);\n\n","contract":"Core","time":0},{"type":"external-function ","before":"\n    function cancel(uint256[] memory _tokenIds, uint256[] memory _quantities, Derivative[] memory _derivatives) public nonReentrant {\n\n        _cancel(_tokenIds, _quantities, _derivatives);\n\n","after":"\n    function cancel(uint256[] calldata _tokenIds, uint256[] calldata _quantities, Derivative[] calldata _derivatives) public nonReentrant {\n\n        _cancel(_tokenIds, _quantities, _derivatives);\n\n","contract":"Core","time":0}]}