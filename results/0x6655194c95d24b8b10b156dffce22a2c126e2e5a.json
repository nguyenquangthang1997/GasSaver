{"time":39,"results":[{"type":"external-function ","before":"function batchAddIntegration(\n\n        address[] memory _modules,\n\n        string[] memory _names,\n\n        address[] memory _adapters\n\n    )\n\n    external\n\n    onlyOwner\n\n    {\n\n        // Storing modules count to local variable to save on invocation\n\n        uint256 modulesCount = _modules.length;\n\n\n        require(modulesCount > 0, \"Modules must not be empty\");\n\n        require(modulesCount == _names.length, \"Module and name lengths mismatch\");\n\n        require(modulesCount == _adapters.length, \"Module and adapter lengths mismatch\");\n\n\n        for (uint256 i = 0; i < modulesCount; i++) {\n\n            // Add integrations to the specified module. Will revert if module and name combination exists\n\n            addIntegration(\n\n                _modules[i],\n\n                _names[i],\n\n                _adapters[i]\n\n            );\n\n        }\n\n    }","after":"function batchAddIntegration(\n\n        address[] calldata _modules,\n\n        string[] calldata _names,\n\n        address[] calldata _adapters\n\n    )\n\n    external\n\n    onlyOwner\n\n    {\n\n        // Storing modules count to local variable to save on invocation\n\n        uint256 modulesCount = _modules.length;\n\n\n        require(modulesCount > 0, \"Modules must not be empty\");\n\n        require(modulesCount == _names.length, \"Module and name lengths mismatch\");\n\n        require(modulesCount == _adapters.length, \"Module and adapter lengths mismatch\");\n\n\n        for (uint256 i = 0; i < modulesCount; i++) {\n\n            // Add integrations to the specified module. Will revert if module and name combination exists\n\n            addIntegration(\n\n                _modules[i],\n\n                _names[i],\n\n                _adapters[i]\n\n            );\n\n        }\n\n    }","contract":"IntegrationRegistry","time":0},{"type":"external-function ","before":"function batchEditIntegration(\n\n        address[] memory _modules,\n\n        string[] memory _names,\n\n        address[] memory _adapters\n\n    )\n\n    external\n\n    onlyOwner\n\n    {\n\n        // Storing name count to local variable to save on invocation\n\n        uint256 modulesCount = _modules.length;\n\n\n        require(modulesCount > 0, \"Modules must not be empty\");\n\n        require(modulesCount == _names.length, \"Module and name lengths mismatch\");\n\n        require(modulesCount == _adapters.length, \"Module and adapter lengths mismatch\");\n\n\n        for (uint256 i = 0; i < modulesCount; i++) {\n\n            // Edits integrations to the specified module. Will revert if module and name combination does not exist\n\n            editIntegration(\n\n                _modules[i],\n\n                _names[i],\n\n                _adapters[i]\n\n            );\n\n        }\n\n    }","after":"function batchEditIntegration(\n\n        address[] calldata _modules,\n\n        string[] calldata _names,\n\n        address[] calldata _adapters\n\n    )\n\n    external\n\n    onlyOwner\n\n    {\n\n        // Storing name count to local variable to save on invocation\n\n        uint256 modulesCount = _modules.length;\n\n\n        require(modulesCount > 0, \"Modules must not be empty\");\n\n        require(modulesCount == _names.length, \"Module and name lengths mismatch\");\n\n        require(modulesCount == _adapters.length, \"Module and adapter lengths mismatch\");\n\n\n        for (uint256 i = 0; i < modulesCount; i++) {\n\n            // Edits integrations to the specified module. Will revert if module and name combination does not exist\n\n            editIntegration(\n\n                _modules[i],\n\n                _names[i],\n\n                _adapters[i]\n\n            );\n\n        }\n\n    }","contract":"IntegrationRegistry","time":0},{"type":"external-function ","before":"function removeIntegration(address _module, string memory _name) external onlyOwner {\n\n        bytes32 hashedName = _nameHash(_name);\n\n        require(integrations[_module][hashedName] != address(0), \"Integration does not exist.\");\n\n\n        address oldAdapter = integrations[_module][hashedName];\n\n        delete integrations[_module][hashedName];\n\n\n        emit IntegrationRemoved(_module, oldAdapter, _name);\n\n    }","after":"function removeIntegration(address _module, string calldata _name) external onlyOwner {\n\n        bytes32 hashedName = _nameHash(_name);\n\n        require(integrations[_module][hashedName] != address(0), \"Integration does not exist.\");\n\n\n        address oldAdapter = integrations[_module][hashedName];\n\n        delete integrations[_module][hashedName];\n\n\n        emit IntegrationRemoved(_module, oldAdapter, _name);\n\n    }","contract":"IntegrationRegistry","time":0},{"type":"external-function ","before":"function getIntegrationAdapter(address _module, string memory _name) external view returns (address) {\n\n        return integrations[_module][_nameHash(_name)];\n\n    }","after":"function getIntegrationAdapter(address _module, string calldata _name) external view returns (address) {\n\n        return integrations[_module][_nameHash(_name)];\n\n    }","contract":"IntegrationRegistry","time":0},{"type":"external-function ","before":"function isValidIntegration(address _module, string memory _name) external view returns (bool) {\n\n        return integrations[_module][_nameHash(_name)] != address(0);\n\n    }","after":"function isValidIntegration(address _module, string calldata _name) external view returns (bool) {\n\n        return integrations[_module][_nameHash(_name)] != address(0);\n\n    }","contract":"IntegrationRegistry","time":0}]}