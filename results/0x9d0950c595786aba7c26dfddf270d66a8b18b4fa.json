{"time":654,"results":[{"type":"immutable-restrict-modification ","before":" string public name","after":" string public immutable name","contract":"Curve","time":0},{"type":"immutable-restrict-modification ","before":" string public symbol","after":" string public immutable symbol","contract":"Curve","time":0},{"type":"constant-restrict-modification  ","before":" bytes32 public immutable merkleRoot = bytes32(0xf4dbd0fb1957570029a847490cb3d731a45962072953ba7da80ff132ccd97d51)","after":" bytes32 public immutable constant merkleRoot = bytes32(0xf4dbd0fb1957570029a847490cb3d731a45962072953ba7da80ff132ccd97d51)","contract":"Curve","time":0},{"type":"external-function ","before":" function newCurve(\n        string memory _name,\n        string memory _symbol,\n        address _baseCurrency,\n        address _quoteCurrency,\n        uint256 _baseWeight,\n        uint256 _quoteWeight,\n        address _baseAssimilator,\n        address _quoteAssimilator\n    ) public onlyOwner returns (Curve) {\n        bytes32 curveId = keccak256(abi.encode(_baseCurrency, _quoteCurrency));\n        if (curves[curveId] != address(0)) revert(\"CurveFactory/currency-pair-already-exists\");\n\n        address[] memory _assets = new address[](10);\n        uint256[] memory _assetWeights = new uint256[](2);\n\n        // Base Currency\n        _assets[0] = _baseCurrency;\n        _assets[1] = _baseAssimilator;\n        _assets[2] = _baseCurrency;\n        _assets[3] = _baseAssimilator;\n        _assets[4] = _baseCurrency;\n\n        // Quote Currency (typically USDC)\n        _assets[5] = _quoteCurrency;\n        _assets[6] = _quoteAssimilator;\n        _assets[7] = _quoteCurrency;\n        _assets[8] = _quoteAssimilator;\n        _assets[9] = _quoteCurrency;\n\n        // Weights\n        _assetWeights[0] = _baseWeight;\n        _assetWeights[1] = _quoteWeight;\n\n        // New curve\n        Curve curve = new Curve(_name, _symbol, _assets, _assetWeights);\n        curve.transferOwnership(msg.sender);\n        curves[curveId] = address(curve);\n\n        emit NewCurve(msg.sender, curveId, address(curve));\n\n        return curve;\n    ","after":" function newCurve(\n        string calldata _name,\n        string calldata _symbol,\n        address _baseCurrency,\n        address _quoteCurrency,\n        uint256 _baseWeight,\n        uint256 _quoteWeight,\n        address _baseAssimilator,\n        address _quoteAssimilator\n    ) public onlyOwner returns (Curve) {\n        bytes32 curveId = keccak256(abi.encode(_baseCurrency, _quoteCurrency));\n        if (curves[curveId] != address(0)) revert(\"CurveFactory/currency-pair-already-exists\");\n\n        address[] memory _assets = new address[](10);\n        uint256[] memory _assetWeights = new uint256[](2);\n\n        // Base Currency\n        _assets[0] = _baseCurrency;\n        _assets[1] = _baseAssimilator;\n        _assets[2] = _baseCurrency;\n        _assets[3] = _baseAssimilator;\n        _assets[4] = _baseCurrency;\n\n        // Quote Currency (typically USDC)\n        _assets[5] = _quoteCurrency;\n        _assets[6] = _quoteAssimilator;\n        _assets[7] = _quoteCurrency;\n        _assets[8] = _quoteAssimilator;\n        _assets[9] = _quoteCurrency;\n\n        // Weights\n        _assetWeights[0] = _baseWeight;\n        _assetWeights[1] = _quoteWeight;\n\n        // New curve\n        Curve curve = new Curve(_name, _symbol, _assets, _assetWeights);\n        curve.transferOwnership(msg.sender);\n        curves[curveId] = address(curve);\n\n        emit NewCurve(msg.sender, curveId, address(curve));\n\n        return curve;\n    ","contract":"CurveFactory","time":0},{"type":"immutable-restrict-modification ","before":" string private _name","after":" string private immutable _name","contract":"ERC20","time":0},{"type":"immutable-restrict-modification ","before":" string private _symbol","after":" string private immutable _symbol","contract":"ERC20","time":0},{"type":"immutable-restrict-modification ","before":" address public factory","after":" address public immutable factory","contract":"Router","time":0},{"type":"state-data-arrangement ","before":"\n Curve public curve\n address public owner\n string public name\n string public symbol\n uint8 public constant decimals = 18\n address[] public derivatives\n address[] public numeraires\n address[] public reserves\n bool public frozen = false\n bool public emergency = false\n bool public whitelistingStage = true\n bool internal notEntered = true\n mapping(address => uint256) public whitelistedDeposited","after":" Curve public curve\n string public name\n string public symbol\n address[] public derivatives\n address[] public numeraires\n address[] public reserves\n mapping(address => uint256) public whitelistedDeposited\n address public owner\n uint8 public constant decimals = 18\n bool public frozen = false\n bool public emergency = false\n bool public whitelistingStage = true\n bool internal notEntered = true\n","contract":"Storage","time":0}]}