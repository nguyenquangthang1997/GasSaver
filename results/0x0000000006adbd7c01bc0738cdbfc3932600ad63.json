{"time":82,"results":[{"type":"external-function ","before":"function aggregate(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint tokensAmount,\n        address[] memory callAddresses,\n        bytes memory callDataConcat,\n        uint[] memory starts,\n        uint[] memory values,\n        uint mintGasPrice,\n        uint minTokensAmount,\n        address payable referrer\n    )\n    public\n    payable\n    returns (uint returnAmount)\n    {\n        returnAmount = gasleft();\n        uint gasTokenBalance = gasToken.balanceOf(address(this));\n\n        require(callAddresses.length + 1 == starts.length);\n\n        if (address(fromToken) != ETH_ADDRESS) {\n\n            spender.claimTokens(fromToken, msg.sender, address(this), tokensAmount);\n        }\n\n        for (uint i = 0; i < starts.length - 1; i++) {\n\n            if (starts[i + 1] - starts[i] > 0) {\n\n                require(\n                    callDataConcat[starts[i] + 0] != spender.claimTokens.selector[0] ||\n                    callDataConcat[starts[i] + 1] != spender.claimTokens.selector[1] ||\n                    callDataConcat[starts[i] + 2] != spender.claimTokens.selector[2] ||\n                    callDataConcat[starts[i] + 3] != spender.claimTokens.selector[3]\n                );\n                require(callAddresses[i].externalCall(values[i], callDataConcat, starts[i], starts[i + 1] - starts[i]));\n            }\n        }\n\n        if (address(toToken) == ETH_ADDRESS) {\n            require(address(this).balance >= minTokensAmount);\n        } else {\n            require(toToken.balanceOf(address(this)) >= minTokensAmount);\n        }\n\n        //\n\n        require(gasTokenBalance == gasToken.balanceOf(address(this)));\n        if (mintGasPrice > 0) {\n            audoRefundGas(returnAmount, mintGasPrice);\n        }\n\n        //\n\n        returnAmount = _balanceOf(toToken, address(this)) * fee / 10000;\n        if (referrer != address(0)) {\n            returnAmount /= 2;\n            if (!_transfer(toToken, referrer, returnAmount, true)) {\n                returnAmount *= 2;\n                emit OneInchFeePaid(toToken, address(0), returnAmount);\n            } else {\n                emit OneInchFeePaid(toToken, referrer, returnAmount / 2);\n            }\n        }\n\n        _transfer(toToken, owner, returnAmount, false);\n\n        returnAmount = _balanceOf(toToken, address(this));\n        _transfer(toToken, msg.sender, returnAmount, false);\n    }","after":"function aggregate(\n        IERC20 fromToken,\n        IERC20 toToken,\n        uint tokensAmount,\n        address[] calldata callAddresses,\n        bytes calldata callDataConcat,\n        uint[] calldata starts,\n        uint[] calldata values,\n        uint mintGasPrice,\n        uint minTokensAmount,\n        address payable referrer\n    )\n    public\n    payable\n    returns (uint returnAmount)\n    {\n        returnAmount = gasleft();\n        uint gasTokenBalance = gasToken.balanceOf(address(this));\n\n        require(callAddresses.length + 1 == starts.length);\n\n        if (address(fromToken) != ETH_ADDRESS) {\n\n            spender.claimTokens(fromToken, msg.sender, address(this), tokensAmount);\n        }\n\n        for (uint i = 0; i < starts.length - 1; i++) {\n\n            if (starts[i + 1] - starts[i] > 0) {\n\n                require(\n                    callDataConcat[starts[i] + 0] != spender.claimTokens.selector[0] ||\n                    callDataConcat[starts[i] + 1] != spender.claimTokens.selector[1] ||\n                    callDataConcat[starts[i] + 2] != spender.claimTokens.selector[2] ||\n                    callDataConcat[starts[i] + 3] != spender.claimTokens.selector[3]\n                );\n                require(callAddresses[i].externalCall(values[i], callDataConcat, starts[i], starts[i + 1] - starts[i]));\n            }\n        }\n\n        if (address(toToken) == ETH_ADDRESS) {\n            require(address(this).balance >= minTokensAmount);\n        } else {\n            require(toToken.balanceOf(address(this)) >= minTokensAmount);\n        }\n\n        //\n\n        require(gasTokenBalance == gasToken.balanceOf(address(this)));\n        if (mintGasPrice > 0) {\n            audoRefundGas(returnAmount, mintGasPrice);\n        }\n\n        //\n\n        returnAmount = _balanceOf(toToken, address(this)) * fee / 10000;\n        if (referrer != address(0)) {\n            returnAmount /= 2;\n            if (!_transfer(toToken, referrer, returnAmount, true)) {\n                returnAmount *= 2;\n                emit OneInchFeePaid(toToken, address(0), returnAmount);\n            } else {\n                emit OneInchFeePaid(toToken, referrer, returnAmount / 2);\n            }\n        }\n\n        _transfer(toToken, owner, returnAmount, false);\n\n        returnAmount = _balanceOf(toToken, address(this));\n        _transfer(toToken, msg.sender, returnAmount, false);\n    }","contract":"AggregatedTokenSwap","time":0},{"type":"immutable-restrict-modification ","before":"address payable owner;","after":"address payable immutable owner;","contract":"AggregatedTokenSwap","time":0}]}