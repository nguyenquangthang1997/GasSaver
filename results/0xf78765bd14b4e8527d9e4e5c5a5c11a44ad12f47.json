{"time":171,"results":[{"type":"external-function ","before":"function sendFundsToUser(address tokenAddress, uint256 amount, address payable receiver, bytes memory depositHash, uint256 tokenGasPrice) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {\n\n        uint256 initialGas = gasleft();\n\n        require(tokensInfo[tokenAddress].minCap <= amount && tokensInfo[tokenAddress].maxCap >= amount, \"Withdraw amount should be within allowed Cap limits\");\n\n        require(receiver != address(0), \"Bad receiver address\");\n\n\n        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);\n\n\n        require(!status, \"Already Processed\");\n\n        processedHash[hashSendTransaction] = true;\n\n\n        uint256 calculateAdminFee = amount.mul(adminFee).div(10000);\n\n\n        adminFeeAccumulatedByToken[tokenAddress] = adminFeeAccumulatedByToken[tokenAddress].add(calculateAdminFee);\n\n\n        uint256 totalGasUsed = (initialGas.sub(gasleft()));\n\n        totalGasUsed = totalGasUsed.add(tokensInfo[tokenAddress].transferOverhead);\n\n        totalGasUsed = totalGasUsed.add(baseGas);\n\n\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress].add(totalGasUsed.mul(tokenGasPrice));\n\n        uint256 amountToTransfer = amount.sub(calculateAdminFee.add(totalGasUsed.mul(tokenGasPrice)));\n\n\n        if (tokenAddress == NATIVE) {\n\n            require(address(this).balance >= amountToTransfer, \"Not Enough Balance\");\n\n            bool success = receiver.send(amountToTransfer);\n\n            require(success, \"Native Transfer Failed\");\n\n        } else {\n\n            require(IERC20(tokenAddress).balanceOf(address(this)) >= amountToTransfer, \"Not Enough Balance\");\n\n            SafeERC20.safeTransfer(IERC20(tokenAddress), receiver, amountToTransfer);\n\n        }\n\n\n        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash);\n\n    }","after":"function sendFundsToUser(address tokenAddress, uint256 amount, address payable receiver, bytes calldata depositHash, uint256 tokenGasPrice) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {\n\n        uint256 initialGas = gasleft();\n\n        require(tokensInfo[tokenAddress].minCap <= amount && tokensInfo[tokenAddress].maxCap >= amount, \"Withdraw amount should be within allowed Cap limits\");\n\n        require(receiver != address(0), \"Bad receiver address\");\n\n\n        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);\n\n\n        require(!status, \"Already Processed\");\n\n        processedHash[hashSendTransaction] = true;\n\n\n        uint256 calculateAdminFee = amount.mul(adminFee).div(10000);\n\n\n        adminFeeAccumulatedByToken[tokenAddress] = adminFeeAccumulatedByToken[tokenAddress].add(calculateAdminFee);\n\n\n        uint256 totalGasUsed = (initialGas.sub(gasleft()));\n\n        totalGasUsed = totalGasUsed.add(tokensInfo[tokenAddress].transferOverhead);\n\n        totalGasUsed = totalGasUsed.add(baseGas);\n\n\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress].add(totalGasUsed.mul(tokenGasPrice));\n\n        uint256 amountToTransfer = amount.sub(calculateAdminFee.add(totalGasUsed.mul(tokenGasPrice)));\n\n\n        if (tokenAddress == NATIVE) {\n\n            require(address(this).balance >= amountToTransfer, \"Not Enough Balance\");\n\n            bool success = receiver.send(amountToTransfer);\n\n            require(success, \"Native Transfer Failed\");\n\n        } else {\n\n            require(IERC20(tokenAddress).balanceOf(address(this)) >= amountToTransfer, \"Not Enough Balance\");\n\n            SafeERC20.safeTransfer(IERC20(tokenAddress), receiver, amountToTransfer);\n\n        }\n\n\n        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash);\n\n    }","contract":"LiquidityPoolManager","time":0}]}