{"time":295,"results":[{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping(uint256 => address) private _tokenOwner;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => Counters.Counter) private _ownedTokensCount;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;","after":"mapping(uint256 => address) private _tokenOwner;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => Counters.Counter) private _ownedTokensCount;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n","contract":"ERC721","time":0},{"type":"state-data-arrangement ","before":"\nuint16 private constant MAX_UINT16 = 2 ** 16 - 1;\nuint16[] internal cardProtos;\nuint8[] internal cardQualities;\nuint16[] public protoToSeason;\naddress public propertyManager;\nProto[] public protos;\nSeason[] public seasons;\nmapping(uint256 => bool) public seasonTradable;\nmapping(address => mapping(uint256 => bool)) public factoryApproved;\nmapping(uint16 => mapping(address => bool)) public mythicApproved;\nmapping(uint16 => bool) public mythicTradable;\nmapping(uint16 => bool) public mythicCreated;\nuint16 public constant MYTHIC_THRESHOLD = 65000;\nstring public baseURI = \"https://api.immutable.com/asset/\";","after":"uint16[] internal cardProtos;\nuint8[] internal cardQualities;\nuint16[] public protoToSeason;\nProto[] public protos;\nSeason[] public seasons;\nmapping(uint256 => bool) public seasonTradable;\nmapping(address => mapping(uint256 => bool)) public factoryApproved;\nmapping(uint16 => mapping(address => bool)) public mythicApproved;\nmapping(uint16 => bool) public mythicTradable;\nmapping(uint16 => bool) public mythicCreated;\nstring public baseURI = \"https://api.immutable.com/asset/\";\naddress public propertyManager;\nuint16 private constant MAX_UINT16 = 2 ** 16 - 1;\nuint16 public constant MYTHIC_THRESHOLD = 65000;\n","contract":"NewCards","time":0},{"type":"state-data-arrangement ","before":"\nuint16 private constant MAX_UINT16 = 2 ** 16 - 1;\nuint16[] public cardProtos;\nuint8[] public cardQualities;\nuint16[] public protoToSeason;\naddress public propertyManager;\nProto[] public protos;\nSeason[] public seasons;\nmapping(uint256 => bool) public seasonTradable;\nmapping(address => mapping(uint256 => bool)) public factoryApproved;\nmapping(uint16 => mapping(address => bool)) public mythicApproved;\nmapping(uint16 => bool) public mythicTradable;\nmapping(uint16 => bool) public mythicCreated;\nuint16 public constant MYTHIC_THRESHOLD = 65000;","after":"uint16[] public cardProtos;\nuint8[] public cardQualities;\nuint16[] public protoToSeason;\nProto[] public protos;\nSeason[] public seasons;\nmapping(uint256 => bool) public seasonTradable;\nmapping(address => mapping(uint256 => bool)) public factoryApproved;\nmapping(uint16 => mapping(address => bool)) public mythicApproved;\nmapping(uint16 => bool) public mythicTradable;\nmapping(uint16 => bool) public mythicCreated;\naddress public propertyManager;\nuint16 private constant MAX_UINT16 = 2 ** 16 - 1;\nuint16 public constant MYTHIC_THRESHOLD = 65000;\n","contract":"Cards","time":0},{"type":"external-function ","before":"function burnAll(uint256[] memory tokenIDs) public {\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\n            burn(tokenIDs[i]);\n        }\n    }","after":"function burnAll(uint256[] calldata tokenIDs) public {\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\n            burn(tokenIDs[i]);\n        }\n    }","contract":"Cards","time":0},{"type":"external-function ","before":"function startSeason(\n        string memory name,\n        uint16 low,\n        uint16 high\n    )\n    public\n    onlyOwner\n    returns (uint)\n    {\n        require(\n            low > 0,\n            \"Core: must not be zero proto\"\n        );\n\n        require(\n            high > low,\n            \"Core: must be a valid range\"\n        );\n\n        require(\n            seasons.length == 0 || low > seasons[seasons.length - 1].high,\n            \"Core: seasons cannot overlap\"\n        );\n\n        require(\n            MYTHIC_THRESHOLD > high,\n            \"Core: cannot go into mythic territory\"\n        );\n\n        // seasons start at 1\n        uint16 id = uint16(seasons.push(Season({high : high, low : low})));\n\n        uint256 cp;\n        assembly {cp := protoToSeason_slot}\n        StorageWrite.repeatUint16(cp, low, (high - low) + 1, id);\n\n        emit SeasonStarted(id, name, low, high);\n\n        return id;\n    }","after":"function startSeason(\n        string calldata name,\n        uint16 low,\n        uint16 high\n    )\n    public\n    onlyOwner\n    returns (uint)\n    {\n        require(\n            low > 0,\n            \"Core: must not be zero proto\"\n        );\n\n        require(\n            high > low,\n            \"Core: must be a valid range\"\n        );\n\n        require(\n            seasons.length == 0 || low > seasons[seasons.length - 1].high,\n            \"Core: seasons cannot overlap\"\n        );\n\n        require(\n            MYTHIC_THRESHOLD > high,\n            \"Core: cannot go into mythic territory\"\n        );\n\n        // seasons start at 1\n        uint16 id = uint16(seasons.push(Season({high : high, low : low})));\n\n        uint256 cp;\n        assembly {cp := protoToSeason_slot}\n        StorageWrite.repeatUint16(cp, low, (high - low) + 1, id);\n\n        emit SeasonStarted(id, name, low, high);\n\n        return id;\n    }","contract":"Cards","time":0},{"type":"external-function ","before":"function updateProtos(\n        uint16[] memory _ids,\n        uint8[] memory _gods,\n        uint8[] memory _cardTypes,\n        uint8[] memory _rarities,\n        uint8[] memory _manas,\n        uint8[] memory _attacks,\n        uint8[] memory _healths,\n        uint8[] memory _tribes\n    ) public onlyOwner {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            uint16 id = _ids[i];\n\n            require(\n                id > 0,\n                \"Core: proto must not be zero\"\n            );\n\n            Proto memory proto = protos[id];\n            require(\n                !proto.locked,\n                \"Core: proto is locked\"\n            );\n\n            protos[id] = Proto({\n            locked : false,\n            exists : true,\n            god : _gods[i],\n            cardType : _cardTypes[i],\n            rarity : _rarities[i],\n            mana : _manas[i],\n            attack : _attacks[i],\n            health : _healths[i],\n            tribe : _tribes[i]\n            });\n            emit ProtoUpdated(id);\n        }\n    }","after":"function updateProtos(\n        uint16[] calldata _ids,\n        uint8[] calldata _gods,\n        uint8[] calldata _cardTypes,\n        uint8[] calldata _rarities,\n        uint8[] calldata _manas,\n        uint8[] calldata _attacks,\n        uint8[] calldata _healths,\n        uint8[] calldata _tribes\n    ) public onlyOwner {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            uint16 id = _ids[i];\n\n            require(\n                id > 0,\n                \"Core: proto must not be zero\"\n            );\n\n            Proto memory proto = protos[id];\n            require(\n                !proto.locked,\n                \"Core: proto is locked\"\n            );\n\n            protos[id] = Proto({\n            locked : false,\n            exists : true,\n            god : _gods[i],\n            cardType : _cardTypes[i],\n            rarity : _rarities[i],\n            mana : _manas[i],\n            attack : _attacks[i],\n            health : _healths[i],\n            tribe : _tribes[i]\n            });\n            emit ProtoUpdated(id);\n        }\n    }","contract":"Cards","time":0},{"type":"external-function ","before":"function lockProtos(uint16[] memory _ids) public onlyOwner {\n        require(\n            _ids.length > 0,\n            \"must lock some\"\n        );\n\n        for (uint256 i = 0; i < _ids.length; i++) {\n            uint16 id = _ids[i];\n            require(\n                id > 0,\n                \"proto must not be zero\"\n            );\n\n            Proto storage proto = protos[id];\n\n            require(\n                !proto.locked,\n                \"proto is locked\"\n            );\n\n            require(\n                proto.exists,\n                \"proto must exist\"\n            );\n\n            proto.locked = true;\n            emit ProtoUpdated(id);\n        }\n    }","after":"function lockProtos(uint16[] calldata _ids) public onlyOwner {\n        require(\n            _ids.length > 0,\n            \"must lock some\"\n        );\n\n        for (uint256 i = 0; i < _ids.length; i++) {\n            uint16 id = _ids[i];\n            require(\n                id > 0,\n                \"proto must not be zero\"\n            );\n\n            Proto storage proto = protos[id];\n\n            require(\n                !proto.locked,\n                \"proto is locked\"\n            );\n\n            require(\n                proto.exists,\n                \"proto must exist\"\n            );\n\n            proto.locked = true;\n            emit ProtoUpdated(id);\n        }\n    }","contract":"Cards","time":0},{"type":"external-function ","before":"function transferAllFrom(\n        address from,\n        address to,\n        uint256[] memory tokenIDs\n    )\n    public\n    {\n        for (uint i = 0; i < tokenIDs.length; i++) {\n            transferFrom(from, to, tokenIDs[i]);\n        }\n    }","after":"function transferAllFrom(\n        address from,\n        address to,\n        uint256[] calldata tokenIDs\n    )\n    public\n    {\n        for (uint i = 0; i < tokenIDs.length; i++) {\n            transferFrom(from, to, tokenIDs[i]);\n        }\n    }","contract":"Cards","time":0},{"type":"external-function ","before":"function safeTransferAllFrom(\n        address from,\n        address to,\n        uint256[] memory tokenIDs\n    )\n    public\n    {\n        for (uint i = 0; i < tokenIDs.length; i++) {\n            safeTransferFrom(from, to, tokenIDs[i]);\n        }\n    }","after":"function safeTransferAllFrom(\n        address from,\n        address to,\n        uint256[] calldata tokenIDs\n    )\n    public\n    {\n        for (uint i = 0; i < tokenIDs.length; i++) {\n            safeTransferFrom(from, to, tokenIDs[i]);\n        }\n    }","contract":"Cards","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public batchSize;","after":"uint256 public immutable batchSize;","contract":"Cards","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"Cards","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"Cards","time":1},{"type":"state-data-arrangement ","before":"\nuint16 private constant MAX_UINT16 = 2 ** 16 - 1;\nCards public old;\nbool public migrating;","after":"Cards public old;\nuint16 private constant MAX_UINT16 = 2 ** 16 - 1;\nbool public migrating;\n","contract":"BatchWrapper","time":0},{"type":"external-function ","before":"function mintCards(address _to, uint16[] memory _protos, uint8[] memory _qualities) public returns (uint id) {\n        require(!migrating, \"must not be migrating\");\n        super.mintCards(_to, _protos, _qualities);\n    }","after":"function mintCards(address _to, uint16[] calldata _protos, uint8[] calldata _qualities) public returns (uint id) {\n        require(!migrating, \"must not be migrating\");\n        super.mintCards(_to, _protos, _qualities);\n    }","contract":"BatchWrapper","time":0},{"type":"external-function ","before":"function mintCards(\n        address to,\n        uint16[] memory _protos,\n        uint8[] memory _qualities\n    )\n    public\n    returns (uint)\n    {\n        require(\n            _protos.length > 0,\n            \"Core: must be some protos\"\n        );\n\n        require(\n            _protos.length == _qualities.length,\n            \"Core: must be the same number of protos/qualities\"\n        );\n\n        uint256 start = _batchMint(to, uint16(_protos.length));\n        _validateAndSaveDetails(start, _protos, _qualities);\n\n        emit CardsMinted(start, to, _protos, _qualities);\n\n        return start;\n    }","after":"function mintCards(\n        address to,\n        uint16[] calldata _protos,\n        uint8[] calldata _qualities\n    )\n    public\n    returns (uint)\n    {\n        require(\n            _protos.length > 0,\n            \"Core: must be some protos\"\n        );\n\n        require(\n            _protos.length == _qualities.length,\n            \"Core: must be the same number of protos/qualities\"\n        );\n\n        uint256 start = _batchMint(to, uint16(_protos.length));\n        _validateAndSaveDetails(start, _protos, _qualities);\n\n        emit CardsMinted(start, to, _protos, _qualities);\n\n        return start;\n    }","contract":"BatchWrapper","time":0},{"type":"external-function ","before":"function burnAll(uint256[] memory tokenIDs) public {\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\n            burn(tokenIDs[i]);\n        }\n    }","after":"function burnAll(uint256[] calldata tokenIDs) public {\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\n            burn(tokenIDs[i]);\n        }\n    }","contract":"BatchWrapper","time":0},{"type":"external-function ","before":"function startSeason(\n        string memory name,\n        uint16 low,\n        uint16 high\n    )\n    public\n    onlyOwner\n    returns (uint)\n    {\n        require(\n            low > 0,\n            \"Core: must not be zero proto\"\n        );\n\n        require(\n            high > low,\n            \"Core: must be a valid range\"\n        );\n\n        require(\n            seasons.length == 0 || low > seasons[seasons.length - 1].high,\n            \"Core: seasons cannot overlap\"\n        );\n\n        require(\n            MYTHIC_THRESHOLD > high,\n            \"Core: cannot go into mythic territory\"\n        );\n\n        // seasons start at 1\n        uint16 id = uint16(seasons.push(Season({high : high, low : low})));\n\n        uint256 cp;\n        assembly {cp := protoToSeason_slot}\n        StorageWrite.repeatUint16(cp, low, (high - low) + 1, id);\n\n        emit SeasonStarted(id, name, low, high);\n\n        return id;\n    }","after":"function startSeason(\n        string calldata name,\n        uint16 low,\n        uint16 high\n    )\n    public\n    onlyOwner\n    returns (uint)\n    {\n        require(\n            low > 0,\n            \"Core: must not be zero proto\"\n        );\n\n        require(\n            high > low,\n            \"Core: must be a valid range\"\n        );\n\n        require(\n            seasons.length == 0 || low > seasons[seasons.length - 1].high,\n            \"Core: seasons cannot overlap\"\n        );\n\n        require(\n            MYTHIC_THRESHOLD > high,\n            \"Core: cannot go into mythic territory\"\n        );\n\n        // seasons start at 1\n        uint16 id = uint16(seasons.push(Season({high : high, low : low})));\n\n        uint256 cp;\n        assembly {cp := protoToSeason_slot}\n        StorageWrite.repeatUint16(cp, low, (high - low) + 1, id);\n\n        emit SeasonStarted(id, name, low, high);\n\n        return id;\n    }","contract":"BatchWrapper","time":0},{"type":"external-function ","before":"function updateProtos(\n        uint16[] memory _ids,\n        uint8[] memory _gods,\n        uint8[] memory _cardTypes,\n        uint8[] memory _rarities,\n        uint8[] memory _manas,\n        uint8[] memory _attacks,\n        uint8[] memory _healths,\n        uint8[] memory _tribes\n    ) public onlyOwner {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            uint16 id = _ids[i];\n\n            require(\n                id > 0,\n                \"Core: proto must not be zero\"\n            );\n\n            Proto memory proto = protos[id];\n            require(\n                !proto.locked,\n                \"Core: proto is locked\"\n            );\n\n            protos[id] = Proto({\n            locked : false,\n            exists : true,\n            god : _gods[i],\n            cardType : _cardTypes[i],\n            rarity : _rarities[i],\n            mana : _manas[i],\n            attack : _attacks[i],\n            health : _healths[i],\n            tribe : _tribes[i]\n            });\n            emit ProtoUpdated(id);\n        }\n    }","after":"function updateProtos(\n        uint16[] calldata _ids,\n        uint8[] calldata _gods,\n        uint8[] calldata _cardTypes,\n        uint8[] calldata _rarities,\n        uint8[] calldata _manas,\n        uint8[] calldata _attacks,\n        uint8[] calldata _healths,\n        uint8[] calldata _tribes\n    ) public onlyOwner {\n        for (uint256 i = 0; i < _ids.length; i++) {\n            uint16 id = _ids[i];\n\n            require(\n                id > 0,\n                \"Core: proto must not be zero\"\n            );\n\n            Proto memory proto = protos[id];\n            require(\n                !proto.locked,\n                \"Core: proto is locked\"\n            );\n\n            protos[id] = Proto({\n            locked : false,\n            exists : true,\n            god : _gods[i],\n            cardType : _cardTypes[i],\n            rarity : _rarities[i],\n            mana : _manas[i],\n            attack : _attacks[i],\n            health : _healths[i],\n            tribe : _tribes[i]\n            });\n            emit ProtoUpdated(id);\n        }\n    }","contract":"BatchWrapper","time":0},{"type":"external-function ","before":"function lockProtos(uint16[] memory _ids) public onlyOwner {\n        require(\n            _ids.length > 0,\n            \"must lock some\"\n        );\n\n        for (uint256 i = 0; i < _ids.length; i++) {\n            uint16 id = _ids[i];\n            require(\n                id > 0,\n                \"proto must not be zero\"\n            );\n\n            Proto storage proto = protos[id];\n\n            require(\n                !proto.locked,\n                \"proto is locked\"\n            );\n\n            require(\n                proto.exists,\n                \"proto must exist\"\n            );\n\n            proto.locked = true;\n            emit ProtoUpdated(id);\n        }\n    }","after":"function lockProtos(uint16[] calldata _ids) public onlyOwner {\n        require(\n            _ids.length > 0,\n            \"must lock some\"\n        );\n\n        for (uint256 i = 0; i < _ids.length; i++) {\n            uint16 id = _ids[i];\n            require(\n                id > 0,\n                \"proto must not be zero\"\n            );\n\n            Proto storage proto = protos[id];\n\n            require(\n                !proto.locked,\n                \"proto is locked\"\n            );\n\n            require(\n                proto.exists,\n                \"proto must exist\"\n            );\n\n            proto.locked = true;\n            emit ProtoUpdated(id);\n        }\n    }","contract":"BatchWrapper","time":0},{"type":"external-function ","before":"function setBaseURI(string memory uri) public onlyOwner {\n        baseURI = uri;\n    }","after":"function setBaseURI(string calldata uri) public onlyOwner {\n        baseURI = uri;\n    }","contract":"BatchWrapper","time":0},{"type":"external-function ","before":"function transferAllFrom(\n        address from,\n        address to,\n        uint256[] memory tokenIDs\n    )\n    public\n    {\n        for (uint i = 0; i < tokenIDs.length; i++) {\n            transferFrom(from, to, tokenIDs[i]);\n        }\n    }","after":"function transferAllFrom(\n        address from,\n        address to,\n        uint256[] calldata tokenIDs\n    )\n    public\n    {\n        for (uint i = 0; i < tokenIDs.length; i++) {\n            transferFrom(from, to, tokenIDs[i]);\n        }\n    }","contract":"BatchWrapper","time":0},{"type":"external-function ","before":"function safeTransferAllFrom(\n        address from,\n        address to,\n        uint256[] memory tokenIDs\n    )\n    public\n    {\n        for (uint i = 0; i < tokenIDs.length; i++) {\n            safeTransferFrom(from, to, tokenIDs[i]);\n        }\n    }","after":"function safeTransferAllFrom(\n        address from,\n        address to,\n        uint256[] calldata tokenIDs\n    )\n    public\n    {\n        for (uint i = 0; i < tokenIDs.length; i++) {\n            safeTransferFrom(from, to, tokenIDs[i]);\n        }\n    }","contract":"BatchWrapper","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public batchSize;","after":"uint256 public immutable batchSize;","contract":"BatchWrapper","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"BatchWrapper","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"BatchWrapper","time":1}]}