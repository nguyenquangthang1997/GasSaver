{"time":226,"results":[{"type":"de-morgan-condition ","before":"!proposal.flags[4] && !proposal.flags[5]","after":"!(proposal.flags[4] && proposal.flags[5])","loc":{"start":{"line":887,"column":16},"end":{"line":887,"column":55}},"contract":"Moloch","time":0},{"type":"struct-data-arrangement ","before":"\naddress delegateKey\nuint256 shares\nuint256 loot\nbool exists\nuint256 highestIndexYesVote\nuint256 jailed","after":"uint256 shares\nuint256 loot\nuint256 highestIndexYesVote\nuint256 jailed\naddress delegateKey\nbool exists\n","contract":"Moloch","time":0},{"type":"external-function ","before":"function submitProposal(\n\n        address applicant,\n\n        uint256 sharesRequested,\n\n        uint256 lootRequested,\n\n        uint256 tributeOffered,\n\n        address tributeToken,\n\n        uint256 paymentRequested,\n\n        address paymentToken,\n\n        string memory details\n\n    ) public nonReentrant returns (uint256 proposalId) {\n\n        require(sharesRequested.add(lootRequested) <= MAX_NUMBER_OF_SHARES_AND_LOOT, \"too many shares requested\");\n\n        require(tokenWhitelist[tributeToken], \"tributeToken is not whitelisted\");\n\n        require(tokenWhitelist[paymentToken], \"payment is not whitelisted\");\n\n        require(applicant != address(0), \"applicant cannot be 0\");\n\n        require(applicant != GUILD && applicant != ESCROW && applicant != TOTAL, \"applicant address cannot be reserved\");\n\n        require(members[applicant].jailed == 0, \"proposal applicant must not be jailed\");\n\n\n        if (tributeOffered > 0 && userTokenBalances[GUILD][tributeToken] == 0) {\n\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, 'cannot submit more tribute proposals for new tokens - guildbank is full');\n\n        }\n\n\n        // collect tribute from proposer and store it in the Moloch until the proposal is processed\n\n        require(IERC20(tributeToken).transferFrom(msg.sender, address(this), tributeOffered), \"tribute token transfer failed\");\n\n        unsafeAddToBalance(ESCROW, tributeToken, tributeOffered);\n\n\n        bool[6] memory flags;\n        // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n\n\n\n        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags);\n\n        return proposalCount - 1;\n        // return proposalId - contracts calling submit might want it\n\n    }","after":"function submitProposal(\n\n        address applicant,\n\n        uint256 sharesRequested,\n\n        uint256 lootRequested,\n\n        uint256 tributeOffered,\n\n        address tributeToken,\n\n        uint256 paymentRequested,\n\n        address paymentToken,\n\n        string calldata details\n\n    ) public nonReentrant returns (uint256 proposalId) {\n\n        require(sharesRequested.add(lootRequested) <= MAX_NUMBER_OF_SHARES_AND_LOOT, \"too many shares requested\");\n\n        require(tokenWhitelist[tributeToken], \"tributeToken is not whitelisted\");\n\n        require(tokenWhitelist[paymentToken], \"payment is not whitelisted\");\n\n        require(applicant != address(0), \"applicant cannot be 0\");\n\n        require(applicant != GUILD && applicant != ESCROW && applicant != TOTAL, \"applicant address cannot be reserved\");\n\n        require(members[applicant].jailed == 0, \"proposal applicant must not be jailed\");\n\n\n        if (tributeOffered > 0 && userTokenBalances[GUILD][tributeToken] == 0) {\n\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, 'cannot submit more tribute proposals for new tokens - guildbank is full');\n\n        }\n\n\n        // collect tribute from proposer and store it in the Moloch until the proposal is processed\n\n        require(IERC20(tributeToken).transferFrom(msg.sender, address(this), tributeOffered), \"tribute token transfer failed\");\n\n        unsafeAddToBalance(ESCROW, tributeToken, tributeOffered);\n\n\n        bool[6] memory flags;\n        // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n\n\n\n        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags);\n\n        return proposalCount - 1;\n        // return proposalId - contracts calling submit might want it\n\n    }","contract":"Moloch","time":0},{"type":"external-function ","before":"function submitWhitelistProposal(address tokenToWhitelist, string memory details) public nonReentrant returns (uint256 proposalId) {\n\n        require(tokenToWhitelist != address(0), \"must provide token address\");\n\n        require(!tokenWhitelist[tokenToWhitelist], \"cannot already have whitelisted the token\");\n\n        require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"cannot submit more whitelist proposals\");\n\n\n        bool[6] memory flags;\n        // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n\n        flags[4] = true;\n        // whitelist\n\n\n\n        _submitProposal(address(0), 0, 0, 0, tokenToWhitelist, 0, address(0), details, flags);\n\n        return proposalCount - 1;\n\n    }","after":"function submitWhitelistProposal(address tokenToWhitelist, string calldata details) public nonReentrant returns (uint256 proposalId) {\n\n        require(tokenToWhitelist != address(0), \"must provide token address\");\n\n        require(!tokenWhitelist[tokenToWhitelist], \"cannot already have whitelisted the token\");\n\n        require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"cannot submit more whitelist proposals\");\n\n\n        bool[6] memory flags;\n        // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n\n        flags[4] = true;\n        // whitelist\n\n\n\n        _submitProposal(address(0), 0, 0, 0, tokenToWhitelist, 0, address(0), details, flags);\n\n        return proposalCount - 1;\n\n    }","contract":"Moloch","time":0},{"type":"external-function ","before":"function submitGuildKickProposal(address memberToKick, string memory details) public nonReentrant returns (uint256 proposalId) {\n\n        Member memory member = members[memberToKick];\n\n\n        require(member.shares > 0 || member.loot > 0, \"member must have at least one share or one loot\");\n\n        require(members[memberToKick].jailed == 0, \"member must not already be jailed\");\n\n\n        bool[6] memory flags;\n        // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n\n        flags[5] = true;\n        // guild kick\n\n\n\n        _submitProposal(memberToKick, 0, 0, 0, address(0), 0, address(0), details, flags);\n\n        return proposalCount - 1;\n\n    }","after":"function submitGuildKickProposal(address memberToKick, string calldata details) public nonReentrant returns (uint256 proposalId) {\n\n        Member memory member = members[memberToKick];\n\n\n        require(member.shares > 0 || member.loot > 0, \"member must have at least one share or one loot\");\n\n        require(members[memberToKick].jailed == 0, \"member must not already be jailed\");\n\n\n        bool[6] memory flags;\n        // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n\n        flags[5] = true;\n        // guild kick\n\n\n\n        _submitProposal(memberToKick, 0, 0, 0, address(0), 0, address(0), details, flags);\n\n        return proposalCount - 1;\n\n    }","contract":"Moloch","time":0},{"type":"external-function ","before":"function withdrawBalances(address[] memory tokens, uint256[] memory amounts, bool max) public nonReentrant {\n\n        require(tokens.length == amounts.length, \"tokens and amounts arrays must be matching lengths\");\n\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n\n            uint256 withdrawAmount = amounts[i];\n\n            if (max) {// withdraw the maximum balance\n\n                withdrawAmount = userTokenBalances[msg.sender][tokens[i]];\n\n            }\n\n\n            _withdrawBalance(tokens[i], withdrawAmount);\n\n        }\n\n    }","after":"function withdrawBalances(address[] calldata tokens, uint256[] calldata amounts, bool max) public nonReentrant {\n\n        require(tokens.length == amounts.length, \"tokens and amounts arrays must be matching lengths\");\n\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n\n            uint256 withdrawAmount = amounts[i];\n\n            if (max) {// withdraw the maximum balance\n\n                withdrawAmount = userTokenBalances[msg.sender][tokens[i]];\n\n            }\n\n\n            _withdrawBalance(tokens[i], withdrawAmount);\n\n        }\n\n    }","contract":"Moloch","time":0},{"type":"external-function ","before":"function summonMoloch(\n\n        address[] memory _summoner,\n\n        address[] memory _approvedTokens,\n\n        uint256 _periodDuration,\n\n        uint256 _votingPeriodLength,\n\n        uint256 _gracePeriodLength,\n\n        uint256 _proposalDeposit,\n\n        uint256 _dilutionBound,\n\n        uint256 _processingReward,\n\n        uint256[] memory _summonerShares\n\n    ) public returns (address) {\n\n        Moloch moloch = Moloch(createClone(template));\n\n\n        moloch.init(\n\n            _summoner,\n\n            _approvedTokens,\n\n            _periodDuration,\n\n            _votingPeriodLength,\n\n            _gracePeriodLength,\n\n            _proposalDeposit,\n\n            _dilutionBound,\n\n            _processingReward,\n\n            _summonerShares\n\n        );\n\n\n        emit SummonComplete(address(moloch), _summoner, _approvedTokens, now, _periodDuration, _votingPeriodLength, _gracePeriodLength, _proposalDeposit, _dilutionBound, _processingReward, _summonerShares);\n\n\n        return address(moloch);\n\n    }","after":"function summonMoloch(\n\n        address[] calldata _summoner,\n\n        address[] calldata _approvedTokens,\n\n        uint256 _periodDuration,\n\n        uint256 _votingPeriodLength,\n\n        uint256 _gracePeriodLength,\n\n        uint256 _proposalDeposit,\n\n        uint256 _dilutionBound,\n\n        uint256 _processingReward,\n\n        uint256[] calldata _summonerShares\n\n    ) public returns (address) {\n\n        Moloch moloch = Moloch(createClone(template));\n\n\n        moloch.init(\n\n            _summoner,\n\n            _approvedTokens,\n\n            _periodDuration,\n\n            _votingPeriodLength,\n\n            _gracePeriodLength,\n\n            _proposalDeposit,\n\n            _dilutionBound,\n\n            _processingReward,\n\n            _summonerShares\n\n        );\n\n\n        emit SummonComplete(address(moloch), _summoner, _approvedTokens, now, _periodDuration, _votingPeriodLength, _gracePeriodLength, _proposalDeposit, _dilutionBound, _processingReward, _summonerShares);\n\n\n        return address(moloch);\n\n    }","contract":"MolochSummoner","time":0},{"type":"external-function ","before":"function registerDao(\n\n        address _daoAdress,\n\n        string memory _daoTitle,\n\n        string memory _http,\n\n        uint _version\n\n    ) public returns (bool) {\n\n\n        moloch = Moloch(_daoAdress);\n\n        (,,,bool exists,,) = moloch.members(msg.sender);\n\n\n        require(exists == true, \"must be a member\");\n\n        require(daos[_daoAdress] == false, \"dao metadata already registered\");\n\n\n        daos[_daoAdress] = true;\n\n\n        daoIdx = daoIdx + 1;\n\n        emit Register(daoIdx, _daoAdress, _daoTitle, _http, _version);\n\n        return true;\n\n\n    }","after":"function registerDao(\n\n        address _daoAdress,\n\n        string calldata _daoTitle,\n\n        string calldata _http,\n\n        uint _version\n\n    ) public returns (bool) {\n\n\n        moloch = Moloch(_daoAdress);\n\n        (,,,bool exists,,) = moloch.members(msg.sender);\n\n\n        require(exists == true, \"must be a member\");\n\n        require(daos[_daoAdress] == false, \"dao metadata already registered\");\n\n\n        daos[_daoAdress] = true;\n\n\n        daoIdx = daoIdx + 1;\n\n        emit Register(daoIdx, _daoAdress, _daoTitle, _http, _version);\n\n        return true;\n\n\n    }","contract":"MolochSummoner","time":0},{"type":"immutable-restrict-modification ","before":"address public template;","after":"address public immutable template;","contract":"MolochSummoner","time":0}]}