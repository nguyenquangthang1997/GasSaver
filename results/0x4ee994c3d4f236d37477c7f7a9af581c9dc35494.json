{"time":1553,"results":[{"type":"immutable-restrict-modification ","before":"address public NATIVE_ASSET;","after":"address public immutable NATIVE_ASSET;","contract":"Accounting","time":1},{"type":"immutable-restrict-modification ","before":"address public DENOMINATION_ASSET;","after":"address public immutable DENOMINATION_ASSET;","contract":"Accounting","time":1},{"type":"immutable-restrict-modification ","before":"uint public DENOMINATION_ASSET_DECIMALS;","after":"uint public immutable DENOMINATION_ASSET_DECIMALS;","contract":"Accounting","time":1},{"type":"immutable-restrict-modification ","before":"uint public DEFAULT_SHARE_PRICE;","after":"uint public immutable DEFAULT_SHARE_PRICE;","contract":"Accounting","time":1},{"type":"immutable-restrict-modification ","before":"bool allowed;","after":"bool immutable allowed;","contract":"TruePolicy","time":0},{"type":"immutable-restrict-modification ","before":"bool allowed;","after":"bool immutable allowed;","contract":"FalsePolicy","time":1},{"type":"immutable-restrict-modification ","before":"string public symbol;","after":"string public immutable symbol;","contract":"BurnableToken","time":0},{"type":"immutable-restrict-modification ","before":"string public  name;","after":"string public  immutable name;","contract":"BurnableToken","time":0},{"type":"immutable-restrict-modification ","before":"uint8 public decimals;","after":"uint8 public immutable decimals;","contract":"BurnableToken","time":1},{"type":"immutable-restrict-modification ","before":"uint public thawingDelay;","after":"uint public immutable thawingDelay;","contract":"Engine","time":0},{"type":"external-function ","before":"function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override onlyManager notShutDown {\n        Hub hub = getHub();\n\n        address wethAddress = orderAddresses[2];\n        address mlnAddress = orderAddresses[3];\n        uint minEthToReceive = orderValues[0];\n        uint mlnQuantity = orderValues[1];\n\n        require(\n            wethAddress == Registry(hub.registry()).nativeAsset(),\n            \"maker asset doesnt match nativeAsset on registry\"\n        );\n        require(\n            orderValues[1] == orderValues[6],\n            \"fillTakerQuantity must equal takerAssetQuantity\"\n        );\n\n        approveAsset(mlnAddress, targetExchange, mlnQuantity, \"takerAsset\");\n\n        uint ethToReceive = Engine(targetExchange).ethPayoutForMlnAmount(mlnQuantity);\n\n        require(\n            ethToReceive >= minEthToReceive,\n            \"Expected ETH to receive is less than takerQuantity (minEthToReceive)\"\n        );\n\n        Engine(targetExchange).sellAndBurnMln(mlnQuantity);\n        WETH(payable(wethAddress)).deposit.value(ethToReceive)();\n        safeTransfer(wethAddress, address(Vault(hub.vault())), ethToReceive);\n\n        getAccounting().addAssetToOwnedAssets(wethAddress);\n        getAccounting().updateOwnedAssets();\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(0),\n            Trading.UpdateType.take,\n            [payable(wethAddress), payable(mlnAddress)],\n            [ethToReceive, mlnQuantity, mlnQuantity]\n        );\n    }","after":"function takeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public override onlyManager notShutDown {\n        Hub hub = getHub();\n\n        address wethAddress = orderAddresses[2];\n        address mlnAddress = orderAddresses[3];\n        uint minEthToReceive = orderValues[0];\n        uint mlnQuantity = orderValues[1];\n\n        require(\n            wethAddress == Registry(hub.registry()).nativeAsset(),\n            \"maker asset doesnt match nativeAsset on registry\"\n        );\n        require(\n            orderValues[1] == orderValues[6],\n            \"fillTakerQuantity must equal takerAssetQuantity\"\n        );\n\n        approveAsset(mlnAddress, targetExchange, mlnQuantity, \"takerAsset\");\n\n        uint ethToReceive = Engine(targetExchange).ethPayoutForMlnAmount(mlnQuantity);\n\n        require(\n            ethToReceive >= minEthToReceive,\n            \"Expected ETH to receive is less than takerQuantity (minEthToReceive)\"\n        );\n\n        Engine(targetExchange).sellAndBurnMln(mlnQuantity);\n        WETH(payable(wethAddress)).deposit.value(ethToReceive)();\n        safeTransfer(wethAddress, address(Vault(hub.vault())), ethToReceive);\n\n        getAccounting().addAssetToOwnedAssets(wethAddress);\n        getAccounting().updateOwnedAssets();\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(0),\n            Trading.UpdateType.take,\n            [payable(wethAddress), payable(mlnAddress)],\n            [ethToReceive, mlnQuantity, mlnQuantity]\n        );\n    }","contract":"EngineAdapter","time":0},{"type":"external-function ","before":"function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function makeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"EngineAdapter","time":0},{"type":"external-function ","before":"function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function takeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"EngineAdapter","time":0},{"type":"external-function ","before":"function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function cancelOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"EngineAdapter","time":0},{"type":"external-function ","before":"function makeOrder(\n        address _targetExchange,\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData,\n        bytes32 _identifier,\n        bytes memory _signature\n    )\n    public\n    override\n    onlyManager\n    notShutDown\n    orderAddressesMatchOrderData(_orderAddresses, _orderData)\n    {\n        ensureCanMakeOrder(_orderAddresses[2]);\n\n        IZeroExV2.Order memory order = constructOrderStruct(_orderAddresses, _orderValues, _orderData);\n        bytes memory wrappedMakerAssetData = _orderData[0];\n        bytes memory takerAssetData = _orderData[1];\n        address makerAsset = _orderAddresses[2];\n        address takerAsset = getAssetAddress(takerAssetData);\n\n        // Order parameter checks\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\n        ensureNotInOpenMakeOrder(makerAsset);\n\n        wrapMakerAsset(_targetExchange, makerAsset, wrappedMakerAssetData, order.makerAssetAmount, order.expirationTimeSeconds);\n\n        IZeroExV2.OrderInfo memory orderInfo = IZeroExV2(_targetExchange).getOrderInfo(order);\n        IZeroExV2(_targetExchange).preSign(orderInfo.orderHash, address(this), _signature);\n\n        require(\n            IZeroExV2(_targetExchange).isValidSignature(\n                orderInfo.orderHash,\n                address(this),\n                _signature\n            ),\n            \"INVALID_ORDER_SIGNATURE\"\n        );\n\n        updateStateMakeOrder(_targetExchange, order);\n    }","after":"function makeOrder(\n        address _targetExchange,\n        address[8] calldata _orderAddresses,\n        uint[8] calldata _orderValues,\n        bytes[4] calldata _orderData,\n        bytes32 _identifier,\n        bytes calldata _signature\n    )\n    public\n    override\n    onlyManager\n    notShutDown\n    orderAddressesMatchOrderData(_orderAddresses, _orderData)\n    {\n        ensureCanMakeOrder(_orderAddresses[2]);\n\n        IZeroExV2.Order memory order = constructOrderStruct(_orderAddresses, _orderValues, _orderData);\n        bytes memory wrappedMakerAssetData = _orderData[0];\n        bytes memory takerAssetData = _orderData[1];\n        address makerAsset = _orderAddresses[2];\n        address takerAsset = getAssetAddress(takerAssetData);\n\n        // Order parameter checks\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\n        ensureNotInOpenMakeOrder(makerAsset);\n\n        wrapMakerAsset(_targetExchange, makerAsset, wrappedMakerAssetData, order.makerAssetAmount, order.expirationTimeSeconds);\n\n        IZeroExV2.OrderInfo memory orderInfo = IZeroExV2(_targetExchange).getOrderInfo(order);\n        IZeroExV2(_targetExchange).preSign(orderInfo.orderHash, address(this), _signature);\n\n        require(\n            IZeroExV2(_targetExchange).isValidSignature(\n                orderInfo.orderHash,\n                address(this),\n                _signature\n            ),\n            \"INVALID_ORDER_SIGNATURE\"\n        );\n\n        updateStateMakeOrder(_targetExchange, order);\n    }","contract":"EthfinexAdapter","time":0},{"type":"external-function ","before":"function cancelOrder(\n        address _targetExchange,\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData,\n        bytes32 _identifier,\n        bytes memory _signature\n    )\n    public\n    override\n    orderAddressesMatchOrderData(_orderAddresses, _orderData)\n    {\n        IZeroExV2.Order memory order = getTrading().getZeroExV2OrderDetails(_identifier);\n        ensureCancelPermitted(_targetExchange, _orderAddresses[2], _identifier);\n        IZeroExV2(_targetExchange).cancelOrder(order);\n\n        updateStateCancelOrder(_targetExchange, order);\n    }","after":"function cancelOrder(\n        address _targetExchange,\n        address[8] calldata _orderAddresses,\n        uint[8] calldata _orderValues,\n        bytes[4] calldata _orderData,\n        bytes32 _identifier,\n        bytes calldata _signature\n    )\n    public\n    override\n    orderAddressesMatchOrderData(_orderAddresses, _orderData)\n    {\n        IZeroExV2.Order memory order = getTrading().getZeroExV2OrderDetails(_identifier);\n        ensureCancelPermitted(_targetExchange, _orderAddresses[2], _identifier);\n        IZeroExV2(_targetExchange).cancelOrder(order);\n\n        updateStateCancelOrder(_targetExchange, order);\n    }","contract":"EthfinexAdapter","time":0},{"type":"external-function ","before":"function withdrawTokens(\n        address _targetExchange,\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData,\n        bytes32 _identifier,\n        bytes memory _signature\n    )\n    public\n    {\n        Hub hub = getHub();\n        address nativeAsset = Accounting(hub.accounting()).NATIVE_ASSET();\n\n        for (uint i = 0; i < _orderAddresses.length; i++) {\n            if (_orderAddresses[i] == address(0)) continue;\n            address wrappedToken = getWrapperToken(_orderAddresses[i]);\n            uint balance = IWrapperLock(wrappedToken).balanceOf(address(this));\n            require(balance > 0, \"Insufficient balance\");\n            IWrapperLock(wrappedToken).withdraw(balance, 0, bytes32(0), bytes32(0), 0);\n            if (_orderAddresses[i] == nativeAsset) {\n                WETH(payable(nativeAsset)).deposit.value(balance)();\n            }\n            getTrading().removeOpenMakeOrder(_targetExchange, _orderAddresses[i]);\n            getTrading().returnAssetToVault(_orderAddresses[i]);\n        }\n    }","after":"function withdrawTokens(\n        address _targetExchange,\n        address[8] calldata _orderAddresses,\n        uint[8] calldata _orderValues,\n        bytes[4] calldata _orderData,\n        bytes32 _identifier,\n        bytes calldata _signature\n    )\n    public\n    {\n        Hub hub = getHub();\n        address nativeAsset = Accounting(hub.accounting()).NATIVE_ASSET();\n\n        for (uint i = 0; i < _orderAddresses.length; i++) {\n            if (_orderAddresses[i] == address(0)) continue;\n            address wrappedToken = getWrapperToken(_orderAddresses[i]);\n            uint balance = IWrapperLock(wrappedToken).balanceOf(address(this));\n            require(balance > 0, \"Insufficient balance\");\n            IWrapperLock(wrappedToken).withdraw(balance, 0, bytes32(0), bytes32(0), 0);\n            if (_orderAddresses[i] == nativeAsset) {\n                WETH(payable(nativeAsset)).deposit.value(balance)();\n            }\n            getTrading().removeOpenMakeOrder(_targetExchange, _orderAddresses[i]);\n            getTrading().returnAssetToVault(_orderAddresses[i]);\n        }\n    }","contract":"EthfinexAdapter","time":0},{"type":"external-function ","before":"function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function makeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"EthfinexAdapter","time":0},{"type":"external-function ","before":"function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function takeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"EthfinexAdapter","time":0},{"type":"external-function ","before":"function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function cancelOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"EthfinexAdapter","time":0},{"type":"external-function ","before":"function createInstance(\n        address _hub,\n        address _denominationAsset,\n        address[] memory _fees,\n        uint[] memory _feeRates,\n        uint[] memory _feePeriods,\n        address _registry\n    ) public returns (address) {\n        address feeManager = address(\n            new FeeManager(_hub, _denominationAsset, _fees, _feeRates, _feePeriods, _registry)\n        );\n        childExists[feeManager] = true;\n        emit NewInstance(_hub, feeManager);\n        return feeManager;\n    }","after":"function createInstance(\n        address _hub,\n        address _denominationAsset,\n        address[] calldata _fees,\n        uint[] calldata _feeRates,\n        uint[] calldata _feePeriods,\n        address _registry\n    ) public returns (address) {\n        address feeManager = address(\n            new FeeManager(_hub, _denominationAsset, _fees, _feeRates, _feePeriods, _registry)\n        );\n        childExists[feeManager] = true;\n        emit NewInstance(_hub, feeManager);\n        return feeManager;\n    }","contract":"FeeManagerFactory","time":0},{"type":"state-data-arrangement ","before":"\nRoutes public routes;\naddress public manager;\naddress public creator;\nstring public name;\nbool public isShutDown;\nbool public fundInitialized;\nuint public creationTime;\nmapping(address => bool) public isSpoke;","after":"Routes public routes;\nstring public name;\nuint public creationTime;\nmapping(address => bool) public isSpoke;\naddress public manager;\naddress public creator;\nbool public isShutDown;\nbool public fundInitialized;\n","contract":"Hub","time":1},{"type":"immutable-restrict-modification ","before":"address public manager;","after":"address public immutable manager;","contract":"Hub","time":1},{"type":"immutable-restrict-modification ","before":"address public creator;","after":"address public immutable creator;","contract":"Hub","time":1},{"type":"immutable-restrict-modification ","before":"string public name;","after":"string public immutable name;","contract":"Hub","time":1},{"type":"immutable-restrict-modification ","before":"uint public creationTime;","after":"uint public immutable creationTime;","contract":"Hub","time":1},{"type":"constant-restrict-modification  ","before":"string public symbol;","after":"string public constant symbol;","contract":"ERC20WithFields","time":0},{"type":"constant-restrict-modification  ","before":"string public name;","after":"string public constant name;","contract":"ERC20WithFields","time":0},{"type":"constant-restrict-modification  ","before":"uint8 public decimals;","after":"uint8 public constant decimals;","contract":"ERC20WithFields","time":0},{"type":"external-function ","before":"function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override onlyManager notShutDown {\n        Hub hub = getHub();\n\n        require(\n            orderValues[1] == orderValues[6],\n            \"fillTakerQuantity must equal takerAssetQuantity\"\n        );\n\n        address makerAsset = orderAddresses[2];\n        address takerAsset = orderAddresses[3];\n        uint makerAssetAmount = orderValues[0];\n        uint takerAssetAmount = orderValues[1];\n\n        uint minRate = calcMinRate(\n            takerAsset,\n            makerAsset,\n            takerAssetAmount,\n            makerAssetAmount\n        );\n\n        uint actualReceiveAmount = dispatchSwap(\n            targetExchange, takerAsset, takerAssetAmount, makerAsset, minRate\n        );\n        require(\n            actualReceiveAmount >= makerAssetAmount,\n            \"Received less than expected from Kyber swap\"\n        );\n\n        getAccounting().addAssetToOwnedAssets(makerAsset);\n        getAccounting().updateOwnedAssets();\n        uint256 timesMakerAssetUsedAsFee = getTrading().openMakeOrdersUsingAssetAsFee(makerAsset);\n        if (\n            !getTrading().isInOpenMakeOrder(makerAsset) &&\n        timesMakerAssetUsedAsFee == 0\n        ) {\n            getTrading().returnAssetToVault(makerAsset);\n        }\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(0),\n            Trading.UpdateType.take,\n            [payable(makerAsset), payable(takerAsset)],\n            [actualReceiveAmount, takerAssetAmount, takerAssetAmount]\n        );\n    }","after":"function takeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public override onlyManager notShutDown {\n        Hub hub = getHub();\n\n        require(\n            orderValues[1] == orderValues[6],\n            \"fillTakerQuantity must equal takerAssetQuantity\"\n        );\n\n        address makerAsset = orderAddresses[2];\n        address takerAsset = orderAddresses[3];\n        uint makerAssetAmount = orderValues[0];\n        uint takerAssetAmount = orderValues[1];\n\n        uint minRate = calcMinRate(\n            takerAsset,\n            makerAsset,\n            takerAssetAmount,\n            makerAssetAmount\n        );\n\n        uint actualReceiveAmount = dispatchSwap(\n            targetExchange, takerAsset, takerAssetAmount, makerAsset, minRate\n        );\n        require(\n            actualReceiveAmount >= makerAssetAmount,\n            \"Received less than expected from Kyber swap\"\n        );\n\n        getAccounting().addAssetToOwnedAssets(makerAsset);\n        getAccounting().updateOwnedAssets();\n        uint256 timesMakerAssetUsedAsFee = getTrading().openMakeOrdersUsingAssetAsFee(makerAsset);\n        if (\n            !getTrading().isInOpenMakeOrder(makerAsset) &&\n        timesMakerAssetUsedAsFee == 0\n        ) {\n            getTrading().returnAssetToVault(makerAsset);\n        }\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(0),\n            Trading.UpdateType.take,\n            [payable(makerAsset), payable(takerAsset)],\n            [actualReceiveAmount, takerAssetAmount, takerAssetAmount]\n        );\n    }","contract":"KyberAdapter","time":0},{"type":"external-function ","before":"function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function makeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"KyberAdapter","time":0},{"type":"external-function ","before":"function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function takeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"KyberAdapter","time":0},{"type":"external-function ","before":"function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function cancelOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"KyberAdapter","time":0},{"type":"external-function ","before":"function getPrices(address[] memory _assets)\n    public\n    view\n    returns (uint256[] memory, uint256[] memory)\n    {\n        uint[] memory newPrices = new uint[](_assets.length);\n        uint[] memory timestamps = new uint[](_assets.length);\n        for (uint i; i < _assets.length; i++) {\n            (newPrices[i], timestamps[i]) = getPrice(_assets[i]);\n        }\n        return (newPrices, timestamps);\n    }","after":"function getPrices(address[] calldata _assets)\n    public\n    view\n    returns (uint256[] memory, uint256[] memory)\n    {\n        uint[] memory newPrices = new uint[](_assets.length);\n        uint[] memory timestamps = new uint[](_assets.length);\n        for (uint i; i < _assets.length; i++) {\n            (newPrices[i], timestamps[i]) = getPrice(_assets[i]);\n        }\n        return (newPrices, timestamps);\n    }","contract":"KyberPriceFeed","time":0},{"type":"external-function ","before":"function hasValidPrices(address[] memory _assets)\n    public\n    view\n    returns (bool)\n    {\n        for (uint i; i < _assets.length; i++) {\n            if (!hasValidPrice(_assets[i])) {\n                return false;\n            }\n        }\n        return true;\n    }","after":"function hasValidPrices(address[] calldata _assets)\n    public\n    view\n    returns (bool)\n    {\n        for (uint i; i < _assets.length; i++) {\n            if (!hasValidPrice(_assets[i])) {\n                return false;\n            }\n        }\n        return true;\n    }","contract":"KyberPriceFeed","time":0},{"type":"immutable-restrict-modification ","before":"address public KYBER_NETWORK_PROXY;","after":"address public immutable KYBER_NETWORK_PROXY;","contract":"KyberPriceFeed","time":0},{"type":"immutable-restrict-modification ","before":"address public QUOTE_ASSET;","after":"address public immutable QUOTE_ASSET;","contract":"KyberPriceFeed","time":0},{"type":"immutable-restrict-modification ","before":"string public symbol;","after":"string public immutable symbol;","contract":"MaliciousToken","time":0},{"type":"immutable-restrict-modification ","before":"string public  name;","after":"string public  immutable name;","contract":"MaliciousToken","time":0},{"type":"immutable-restrict-modification ","before":"uint8 public decimals;","after":"uint8 public immutable decimals;","contract":"MaliciousToken","time":0},{"type":"constant-restrict-modification  ","before":"uint public DIVISOR = 10 ** 18;","after":"uint public constant DIVISOR = 10 ** 18;","contract":"ManagementFee","time":1},{"type":"immutable-restrict-modification ","before":"uint public maxConcentration;","after":"uint public immutable maxConcentration;","contract":"MaxConcentration","time":3},{"type":"immutable-restrict-modification ","before":"uint public maxPositions;","after":"uint public immutable maxPositions;","contract":"MaxPositions","time":1},{"type":"loop-calculation","before":"uint quantityHeld = held[ofAsset];","after":"// move outside for loop\nuint quantityHeld = held[ofAsset];","loc":{"start":{"line":3311,"column":12},"end":{"line":3311,"column":45}},"contract":"MockAccounting","time":0},{"type":"external-function ","before":"function setOwnedAssets(address[] memory _assets) public {ownedAssets = _assets;}","after":"function setOwnedAssets(address[] calldata _assets) public {ownedAssets = _assets;}","contract":"MockAccounting","time":0},{"type":"external-function ","before":"function setFundHoldings(uint[] memory _amounts, address[] memory _assets) public {\n        for (uint i = 0; i < _assets.length; i++) {\n            held[_assets[i]] = _amounts[i];\n        }\n    }","after":"function setFundHoldings(uint[] calldata _amounts, address[] calldata _assets) public {\n        for (uint i = 0; i < _assets.length; i++) {\n            held[_assets[i]] = _amounts[i];\n        }\n    }","contract":"MockAccounting","time":0},{"type":"constant-restrict-modification  ","before":"uint public unclaimedFees;","after":"uint public constant unclaimedFees;","contract":"MockAccounting","time":1},{"type":"constant-restrict-modification  ","before":"uint public mockValuePerShare;","after":"uint public constant mockValuePerShare;","contract":"MockAccounting","time":1},{"type":"immutable-restrict-modification ","before":"address public DENOMINATION_ASSET;","after":"address public immutable DENOMINATION_ASSET;","contract":"MockAccounting","time":1},{"type":"immutable-restrict-modification ","before":"address public NATIVE_ASSET;","after":"address public immutable NATIVE_ASSET;","contract":"MockAccounting","time":1},{"type":"immutable-restrict-modification ","before":"uint public DEFAULT_SHARE_PRICE;","after":"uint public immutable DEFAULT_SHARE_PRICE;","contract":"MockAccounting","time":3},{"type":"immutable-restrict-modification ","before":"uint public SHARES_DECIMALS;","after":"uint public immutable SHARES_DECIMALS;","contract":"MockAccounting","time":3},{"type":"external-function ","before":"function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override {\n        address makerAsset = orderAddresses[2];\n        address takerAsset = orderAddresses[3];\n        uint makerQuantity = orderValues[0];\n        uint takerQuantity = orderValues[1];\n\n        approveAsset(makerAsset, targetExchange, makerQuantity, \"makerAsset\");\n\n        getTrading().orderUpdateHook(\n            targetExchange,\n            identifier,\n            Trading.UpdateType.make,\n            [payable(makerAsset), payable(takerAsset)],\n            [makerQuantity, takerQuantity, uint(0)]\n        );\n        getTrading().addOpenMakeOrder(targetExchange, makerAsset, takerAsset, address(0), uint(identifier), 0);\n    }","after":"function makeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public override {\n        address makerAsset = orderAddresses[2];\n        address takerAsset = orderAddresses[3];\n        uint makerQuantity = orderValues[0];\n        uint takerQuantity = orderValues[1];\n\n        approveAsset(makerAsset, targetExchange, makerQuantity, \"makerAsset\");\n\n        getTrading().orderUpdateHook(\n            targetExchange,\n            identifier,\n            Trading.UpdateType.make,\n            [payable(makerAsset), payable(takerAsset)],\n            [makerQuantity, takerQuantity, uint(0)]\n        );\n        getTrading().addOpenMakeOrder(targetExchange, makerAsset, takerAsset, address(0), uint(identifier), 0);\n    }","contract":"MockAdapter","time":0},{"type":"external-function ","before":"function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override {\n        address makerAsset = orderAddresses[2];\n        address takerAsset = orderAddresses[3];\n        uint makerQuantity = orderValues[0];\n        uint takerQuantity = orderValues[1];\n        uint fillTakerQuantity = orderValues[6];\n\n        approveAsset(takerAsset, targetExchange, fillTakerQuantity, \"takerAsset\");\n\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(identifier),\n            Trading.UpdateType.take,\n            [payable(makerAsset), payable(takerAsset)],\n            [makerQuantity, takerQuantity, fillTakerQuantity]\n        );\n    }","after":"function takeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public override {\n        address makerAsset = orderAddresses[2];\n        address takerAsset = orderAddresses[3];\n        uint makerQuantity = orderValues[0];\n        uint takerQuantity = orderValues[1];\n        uint fillTakerQuantity = orderValues[6];\n\n        approveAsset(takerAsset, targetExchange, fillTakerQuantity, \"takerAsset\");\n\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(identifier),\n            Trading.UpdateType.take,\n            [payable(makerAsset), payable(takerAsset)],\n            [makerQuantity, takerQuantity, fillTakerQuantity]\n        );\n    }","contract":"MockAdapter","time":0},{"type":"external-function ","before":"function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override {\n        address makerAsset = orderAddresses[2];\n        uint makerQuantity = orderValues[0];\n\n        revokeApproveAsset(makerAsset, targetExchange, makerQuantity, \"makerAsset\");\n\n        getTrading().removeOpenMakeOrder(targetExchange, makerAsset);\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(identifier),\n            Trading.UpdateType.cancel,\n            [address(0), address(0)],\n            [uint(0), uint(0), uint(0)]\n        );\n    }","after":"function cancelOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public override {\n        address makerAsset = orderAddresses[2];\n        uint makerQuantity = orderValues[0];\n\n        revokeApproveAsset(makerAsset, targetExchange, makerQuantity, \"makerAsset\");\n\n        getTrading().removeOpenMakeOrder(targetExchange, makerAsset);\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(identifier),\n            Trading.UpdateType.cancel,\n            [address(0), address(0)],\n            [uint(0), uint(0), uint(0)]\n        );\n    }","contract":"MockAdapter","time":0},{"type":"external-function ","before":"function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function makeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"MockAdapter","time":0},{"type":"external-function ","before":"function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function takeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"MockAdapter","time":0},{"type":"external-function ","before":"function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function cancelOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"MockAdapter","time":0},{"type":"immutable-restrict-modification ","before":"uint public feeNumber;","after":"uint public immutable feeNumber;","contract":"MockFee","time":0},{"type":"state-data-arrangement ","before":"\nRoutes public routes;\naddress public manager;\nstring public name;\nbool public isShutDown;","after":"Routes public routes;\nstring public name;\naddress public manager;\nbool public isShutDown;\n","contract":"MockHub","time":0},{"type":"external-function ","before":"function setName(string memory _name) public {name = _name;}","after":"function setName(string calldata _name) public {name = _name;}","contract":"MockHub","time":0},{"type":"external-function ","before":"function setSpokes(address[11] memory _spokes) public {\n        routes.accounting = _spokes[0];\n        routes.feeManager = _spokes[1];\n        routes.participation = _spokes[2];\n        routes.policyManager = _spokes[3];\n        routes.shares = _spokes[4];\n        routes.trading = _spokes[5];\n        routes.vault = _spokes[6];\n        routes.registry = _spokes[7];\n        routes.version = _spokes[8];\n        routes.engine = _spokes[9];\n        routes.mlnAddress = _spokes[10];\n    }","after":"function setSpokes(address[11] calldata _spokes) public {\n        routes.accounting = _spokes[0];\n        routes.feeManager = _spokes[1];\n        routes.participation = _spokes[2];\n        routes.policyManager = _spokes[3];\n        routes.shares = _spokes[4];\n        routes.trading = _spokes[5];\n        routes.vault = _spokes[6];\n        routes.registry = _spokes[7];\n        routes.version = _spokes[8];\n        routes.engine = _spokes[9];\n        routes.mlnAddress = _spokes[10];\n    }","contract":"MockHub","time":1},{"type":"constant-restrict-modification  ","before":"bool public alwaysRegistered = true;","after":"bool public constant alwaysRegistered = true;","contract":"MockRegistry","time":0},{"type":"constant-restrict-modification  ","before":"bool public methodAllowed = true;","after":"bool public constant methodAllowed = true;","contract":"MockRegistry","time":0},{"type":"constant-restrict-modification  ","before":"uint public incentive;","after":"uint public constant incentive;","contract":"MockRegistry","time":0},{"type":"immutable-restrict-modification ","before":"string public symbol;","after":"string public immutable symbol;","contract":"MockShares","time":0},{"type":"immutable-restrict-modification ","before":"string public name;","after":"string public immutable name;","contract":"MockShares","time":0},{"type":"immutable-restrict-modification ","before":"uint8 public decimals;","after":"uint8 public immutable decimals;","contract":"MockShares","time":0},{"type":"loop-calculation","before":"uint buyQty;","after":"// move outside for loop\nuint buyQty;","loc":{"start":{"line":3883,"column":12},"end":{"line":3883,"column":23}},"contract":"OasisDexAccessor","time":0},{"type":"external-function ","before":"function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override onlyManager notShutDown {\n        ensureCanMakeOrder(orderAddresses[2]);\n        address makerAsset = orderAddresses[2];\n        address takerAsset = orderAddresses[3];\n        uint256 makerQuantity = orderValues[0];\n        uint256 takerQuantity = orderValues[1];\n\n        // Order parameter checks\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\n        ensureNotInOpenMakeOrder(makerAsset);\n\n        approveAsset(makerAsset, targetExchange, makerQuantity, \"makerAsset\");\n\n        uint256 orderId = IOasisDex(targetExchange).offer(makerQuantity, makerAsset, takerQuantity, takerAsset);\n\n        // defines success in MatchingMarket\n        require(orderId != 0, \"Order ID should not be zero\");\n\n        getAccounting().addAssetToOwnedAssets(takerAsset);\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(orderId),\n            Trading.UpdateType.make,\n            [payable(makerAsset), payable(takerAsset)],\n            [makerQuantity, takerQuantity, uint256(0)]\n        );\n        getTrading().addOpenMakeOrder(\n            targetExchange,\n            makerAsset,\n            takerAsset,\n            address(0),\n            orderId,\n            orderValues[4]\n        );\n        emit OrderCreated(orderId);\n    }","after":"function makeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public override onlyManager notShutDown {\n        ensureCanMakeOrder(orderAddresses[2]);\n        address makerAsset = orderAddresses[2];\n        address takerAsset = orderAddresses[3];\n        uint256 makerQuantity = orderValues[0];\n        uint256 takerQuantity = orderValues[1];\n\n        // Order parameter checks\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\n        ensureNotInOpenMakeOrder(makerAsset);\n\n        approveAsset(makerAsset, targetExchange, makerQuantity, \"makerAsset\");\n\n        uint256 orderId = IOasisDex(targetExchange).offer(makerQuantity, makerAsset, takerQuantity, takerAsset);\n\n        // defines success in MatchingMarket\n        require(orderId != 0, \"Order ID should not be zero\");\n\n        getAccounting().addAssetToOwnedAssets(takerAsset);\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(orderId),\n            Trading.UpdateType.make,\n            [payable(makerAsset), payable(takerAsset)],\n            [makerQuantity, takerQuantity, uint256(0)]\n        );\n        getTrading().addOpenMakeOrder(\n            targetExchange,\n            makerAsset,\n            takerAsset,\n            address(0),\n            orderId,\n            orderValues[4]\n        );\n        emit OrderCreated(orderId);\n    }","contract":"OasisDexAdapter","time":0},{"type":"external-function ","before":"function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override onlyManager notShutDown {\n        Hub hub = getHub();\n        uint256 fillTakerQuantity = orderValues[6];\n        uint256 maxMakerQuantity;\n        address makerAsset;\n        uint256 maxTakerQuantity;\n        address takerAsset;\n        (\n        maxMakerQuantity,\n        makerAsset,\n        maxTakerQuantity,\n        takerAsset\n        ) = IOasisDex(targetExchange).getOffer(uint256(identifier));\n        uint256 fillMakerQuantity = mul(fillTakerQuantity, maxMakerQuantity) / maxTakerQuantity;\n\n        require(\n            makerAsset == orderAddresses[2] && takerAsset == orderAddresses[3],\n            \"Maker and taker assets do not match the order addresses\"\n        );\n        require(\n            makerAsset != takerAsset,\n            \"Maker and taker assets cannot be the same\"\n        );\n        require(fillMakerQuantity <= maxMakerQuantity, \"Maker amount to fill above max\");\n        require(fillTakerQuantity <= maxTakerQuantity, \"Taker amount to fill above max\");\n\n        approveAsset(takerAsset, targetExchange, fillTakerQuantity, \"takerAsset\");\n\n        require(\n            IOasisDex(targetExchange).buy(uint256(identifier), fillMakerQuantity),\n            \"Buy on matching market failed\"\n        );\n\n        getAccounting().addAssetToOwnedAssets(makerAsset);\n        getAccounting().updateOwnedAssets();\n        uint256 timesMakerAssetUsedAsFee = getTrading().openMakeOrdersUsingAssetAsFee(makerAsset);\n        if (\n            !getTrading().isInOpenMakeOrder(makerAsset) &&\n        timesMakerAssetUsedAsFee == 0\n        ) {\n            getTrading().returnAssetToVault(makerAsset);\n        }\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(identifier),\n            Trading.UpdateType.take,\n            [payable(makerAsset), payable(takerAsset)],\n            [maxMakerQuantity, maxTakerQuantity, fillTakerQuantity]\n        );\n    }","after":"function takeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public override onlyManager notShutDown {\n        Hub hub = getHub();\n        uint256 fillTakerQuantity = orderValues[6];\n        uint256 maxMakerQuantity;\n        address makerAsset;\n        uint256 maxTakerQuantity;\n        address takerAsset;\n        (\n        maxMakerQuantity,\n        makerAsset,\n        maxTakerQuantity,\n        takerAsset\n        ) = IOasisDex(targetExchange).getOffer(uint256(identifier));\n        uint256 fillMakerQuantity = mul(fillTakerQuantity, maxMakerQuantity) / maxTakerQuantity;\n\n        require(\n            makerAsset == orderAddresses[2] && takerAsset == orderAddresses[3],\n            \"Maker and taker assets do not match the order addresses\"\n        );\n        require(\n            makerAsset != takerAsset,\n            \"Maker and taker assets cannot be the same\"\n        );\n        require(fillMakerQuantity <= maxMakerQuantity, \"Maker amount to fill above max\");\n        require(fillTakerQuantity <= maxTakerQuantity, \"Taker amount to fill above max\");\n\n        approveAsset(takerAsset, targetExchange, fillTakerQuantity, \"takerAsset\");\n\n        require(\n            IOasisDex(targetExchange).buy(uint256(identifier), fillMakerQuantity),\n            \"Buy on matching market failed\"\n        );\n\n        getAccounting().addAssetToOwnedAssets(makerAsset);\n        getAccounting().updateOwnedAssets();\n        uint256 timesMakerAssetUsedAsFee = getTrading().openMakeOrdersUsingAssetAsFee(makerAsset);\n        if (\n            !getTrading().isInOpenMakeOrder(makerAsset) &&\n        timesMakerAssetUsedAsFee == 0\n        ) {\n            getTrading().returnAssetToVault(makerAsset);\n        }\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(identifier),\n            Trading.UpdateType.take,\n            [payable(makerAsset), payable(takerAsset)],\n            [maxMakerQuantity, maxTakerQuantity, fillTakerQuantity]\n        );\n    }","contract":"OasisDexAdapter","time":1},{"type":"external-function ","before":"function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public override {\n        require(uint256(identifier) != 0, \"ID cannot be zero\");\n        address makerAsset;\n        (, makerAsset,,) = IOasisDex(targetExchange).getOffer(uint256(identifier));\n        ensureCancelPermitted(targetExchange, makerAsset, identifier);\n\n        require(\n            address(makerAsset) == orderAddresses[2],\n            \"Retrieved and passed assets do not match\"\n        );\n\n        getTrading().removeOpenMakeOrder(targetExchange, makerAsset);\n        IOasisDex(targetExchange).cancel(uint256(identifier));\n        uint256 timesMakerAssetUsedAsFee = getTrading().openMakeOrdersUsingAssetAsFee(makerAsset);\n        if (timesMakerAssetUsedAsFee == 0) {\n            getTrading().returnAssetToVault(makerAsset);\n        }\n        getAccounting().updateOwnedAssets();\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(identifier),\n            Trading.UpdateType.cancel,\n            [address(0), address(0)],\n            [uint256(0), uint256(0), uint256(0)]\n        );\n    }","after":"function cancelOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public override {\n        require(uint256(identifier) != 0, \"ID cannot be zero\");\n        address makerAsset;\n        (, makerAsset,,) = IOasisDex(targetExchange).getOffer(uint256(identifier));\n        ensureCancelPermitted(targetExchange, makerAsset, identifier);\n\n        require(\n            address(makerAsset) == orderAddresses[2],\n            \"Retrieved and passed assets do not match\"\n        );\n\n        getTrading().removeOpenMakeOrder(targetExchange, makerAsset);\n        IOasisDex(targetExchange).cancel(uint256(identifier));\n        uint256 timesMakerAssetUsedAsFee = getTrading().openMakeOrdersUsingAssetAsFee(makerAsset);\n        if (timesMakerAssetUsedAsFee == 0) {\n            getTrading().returnAssetToVault(makerAsset);\n        }\n        getAccounting().updateOwnedAssets();\n        getTrading().orderUpdateHook(\n            targetExchange,\n            bytes32(identifier),\n            Trading.UpdateType.cancel,\n            [address(0), address(0)],\n            [uint256(0), uint256(0), uint256(0)]\n        );\n    }","contract":"OasisDexAdapter","time":0},{"type":"external-function ","before":"function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function makeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"OasisDexAdapter","time":0},{"type":"external-function ","before":"function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function takeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"OasisDexAdapter","time":0},{"type":"external-function ","before":"function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function cancelOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"OasisDexAdapter","time":0},{"type":"external-function ","before":"function batchRegister(bytes4[] memory sig, address[] memory _policies) public auth {\n        require(sig.length == _policies.length, \"Arrays lengths unequal\");\n        for (uint i = 0; i < sig.length; i++) {\n            register(sig[i], _policies[i]);\n        }\n    }","after":"function batchRegister(bytes4[] calldata sig, address[] calldata _policies) public auth {\n        require(sig.length == _policies.length, \"Arrays lengths unequal\");\n        for (uint i = 0; i < sig.length; i++) {\n            register(sig[i], _policies[i]);\n        }\n    }","contract":"PolicyManager","time":0},{"type":"external-function ","before":"function preValidate(bytes4 sig, address[5] memory addresses, uint[3] memory values, bytes32 identifier) public {\n        validate(policies[sig].pre, sig, addresses, values, identifier);\n    }","after":"function preValidate(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier) public {\n        validate(policies[sig].pre, sig, addresses, values, identifier);\n    }","contract":"PolicyManager","time":0},{"type":"external-function ","before":"function postValidate(bytes4 sig, address[5] memory addresses, uint[3] memory values, bytes32 identifier) public {\n        validate(policies[sig].post, sig, addresses, values, identifier);\n    }","after":"function postValidate(bytes4 sig, address[5] calldata addresses, uint[3] calldata values, bytes32 identifier) public {\n        validate(policies[sig].post, sig, addresses, values, identifier);\n    }","contract":"PolicyManager","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public tolerance;","after":"uint256 public immutable tolerance;","contract":"PriceTolerance","time":1},{"type":"de-morgan-condition ","before":"!(char >= 0x30 && char <= 0x39) && // 9-0\n            !(char >= 0x41 && char <= 0x5A)","after":"!((char >= 0x30 && char <= 0x39) && // 9-0\n            (char >= 0x41 && char <= 0x5A))","loc":{"start":{"line":4986,"column":16},"end":{"line":4987,"column":42}},"contract":"Registry","time":0},{"type":"immutable-restrict-modification ","before":"string public symbol;","after":"string public immutable symbol;","contract":"Shares","time":0},{"type":"immutable-restrict-modification ","before":"string public name;","after":"string public immutable name;","contract":"Shares","time":0},{"type":"immutable-restrict-modification ","before":"uint8 public decimals;","after":"uint8 public immutable decimals;","contract":"Shares","time":0},{"type":"loop-calculation","before":"uint timestamp;","after":"// move outside for loop\nuint timestamp;","loc":{"start":{"line":5839,"column":12},"end":{"line":5839,"column":26}},"contract":"TestingPriceFeed","time":0},{"type":"state-data-arrangement ","before":"\naddress public QUOTE_ASSET;\nuint public updateId;\nuint public lastUpdate;\nmapping(address => Data) public assetsToPrices;\nmapping(address => uint) public assetsToDecimals;\nbool mockIsRecent = true;\nbool neverValid = false;","after":"uint public updateId;\nuint public lastUpdate;\nmapping(address => Data) public assetsToPrices;\nmapping(address => uint) public assetsToDecimals;\naddress public QUOTE_ASSET;\nbool mockIsRecent = true;\nbool neverValid = false;\n","contract":"TestingPriceFeed","time":0},{"type":"external-function ","before":"function getPrices(address[] memory ofAssets)\n    public\n    view\n    returns (uint[] memory, uint[] memory)\n    {\n        uint[] memory prices = new uint[](ofAssets.length);\n        uint[] memory timestamps = new uint[](ofAssets.length);\n        for (uint i; i < ofAssets.length; i++) {\n            uint price;\n            uint timestamp;\n            (price, timestamp) = getPrice(ofAssets[i]);\n            prices[i] = price;\n            timestamps[i] = timestamp;\n        }\n        return (prices, timestamps);\n    }","after":"function getPrices(address[] calldata ofAssets)\n    public\n    view\n    returns (uint[] memory, uint[] memory)\n    {\n        uint[] memory prices = new uint[](ofAssets.length);\n        uint[] memory timestamps = new uint[](ofAssets.length);\n        for (uint i; i < ofAssets.length; i++) {\n            uint price;\n            uint timestamp;\n            (price, timestamp) = getPrice(ofAssets[i]);\n            prices[i] = price;\n            timestamps[i] = timestamp;\n        }\n        return (prices, timestamps);\n    }","contract":"TestingPriceFeed","time":0},{"type":"external-function ","before":"function batchSetDecimals(address[] memory _assets, uint[] memory _decimals) public {\n        require(_assets.length == _decimals.length, \"Array lengths unequal\");\n        for (uint i = 0; i < _assets.length; i++) {\n            setDecimals(_assets[i], _decimals[i]);\n        }\n    }","after":"function batchSetDecimals(address[] calldata _assets, uint[] calldata _decimals) public {\n        require(_assets.length == _decimals.length, \"Array lengths unequal\");\n        for (uint i = 0; i < _assets.length; i++) {\n            setDecimals(_assets[i], _decimals[i]);\n        }\n    }","contract":"TestingPriceFeed","time":0},{"type":"external-function ","before":"function hasValidPrices(address[] memory _assets)\n    public\n    view\n    returns (bool)\n    {\n        for (uint i; i < _assets.length; i++) {\n            if (!hasValidPrice(_assets[i])) {\n                return false;\n            }\n        }\n        return true;\n    }","after":"function hasValidPrices(address[] calldata _assets)\n    public\n    view\n    returns (bool)\n    {\n        for (uint i; i < _assets.length; i++) {\n            if (!hasValidPrice(_assets[i])) {\n                return false;\n            }\n        }\n        return true;\n    }","contract":"TestingPriceFeed","time":0},{"type":"immutable-restrict-modification ","before":"address public QUOTE_ASSET;","after":"address public immutable QUOTE_ASSET;","contract":"TestingPriceFeed","time":0},{"type":"loop-calculation","before":"uint remainingSellQuantity;","after":"// move outside for loop\nuint remainingSellQuantity;","loc":{"start":{"line":6356,"column":12},"end":{"line":6356,"column":38}},"contract":"Trading","time":0},{"type":"external-function ","before":"function callOnExchange(\n        uint exchangeIndex,\n        string memory methodSignature,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    )\n    public\n    onlyInitialized\n    {\n        bytes4 methodSelector = bytes4(keccak256(bytes(methodSignature)));\n        require(\n            Registry(routes.registry).adapterMethodIsAllowed(\n                exchanges[exchangeIndex].adapter,\n                methodSelector\n            ),\n            \"Adapter method not allowed\"\n        );\n        PolicyManager(routes.policyManager).preValidate(methodSelector, [orderAddresses[0], orderAddresses[1], orderAddresses[2], orderAddresses[3], exchanges[exchangeIndex].exchange], [orderValues[0], orderValues[1], orderValues[6]], identifier);\n        if (\n            methodSelector == MAKE_ORDER ||\n            methodSelector == TAKE_ORDER\n        ) {\n            require(Registry(routes.registry).assetIsRegistered(\n                    orderAddresses[2]), 'Maker asset not registered'\n            );\n            require(Registry(routes.registry).assetIsRegistered(\n                    orderAddresses[3]), 'Taker asset not registered'\n            );\n            if (orderAddresses[6] != address(0) && methodSelector == MAKE_ORDER) {\n                require(\n                    Registry(routes.registry).assetIsRegistered(orderAddresses[6]),\n                    'Maker fee asset not registered'\n                );\n            }\n            if (orderAddresses[7] != address(0) && methodSelector == TAKE_ORDER) {\n                require(\n                    Registry(routes.registry).assetIsRegistered(orderAddresses[7]),\n                    'Taker fee asset not registered'\n                );\n            }\n        }\n        (bool success, bytes memory returnData) = exchanges[exchangeIndex].adapter.delegatecall(\n            abi.encodeWithSignature(\n                methodSignature,\n                exchanges[exchangeIndex].exchange,\n                orderAddresses,\n                orderValues,\n                orderData,\n                identifier,\n                signature\n            )\n        );\n        require(success, string(returnData));\n        PolicyManager(routes.policyManager).postValidate(methodSelector, [orderAddresses[0], orderAddresses[1], orderAddresses[2], orderAddresses[3], exchanges[exchangeIndex].exchange], [orderValues[0], orderValues[1], orderValues[6]], identifier);\n        emit ExchangeMethodCall(\n            exchanges[exchangeIndex].exchange,\n            methodSignature,\n            orderAddresses,\n            orderValues,\n            orderData,\n            identifier,\n            signature\n        );\n    }","after":"function callOnExchange(\n        uint exchangeIndex,\n        string calldata methodSignature,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    )\n    public\n    onlyInitialized\n    {\n        bytes4 methodSelector = bytes4(keccak256(bytes(methodSignature)));\n        require(\n            Registry(routes.registry).adapterMethodIsAllowed(\n                exchanges[exchangeIndex].adapter,\n                methodSelector\n            ),\n            \"Adapter method not allowed\"\n        );\n        PolicyManager(routes.policyManager).preValidate(methodSelector, [orderAddresses[0], orderAddresses[1], orderAddresses[2], orderAddresses[3], exchanges[exchangeIndex].exchange], [orderValues[0], orderValues[1], orderValues[6]], identifier);\n        if (\n            methodSelector == MAKE_ORDER ||\n            methodSelector == TAKE_ORDER\n        ) {\n            require(Registry(routes.registry).assetIsRegistered(\n                    orderAddresses[2]), 'Maker asset not registered'\n            );\n            require(Registry(routes.registry).assetIsRegistered(\n                    orderAddresses[3]), 'Taker asset not registered'\n            );\n            if (orderAddresses[6] != address(0) && methodSelector == MAKE_ORDER) {\n                require(\n                    Registry(routes.registry).assetIsRegistered(orderAddresses[6]),\n                    'Maker fee asset not registered'\n                );\n            }\n            if (orderAddresses[7] != address(0) && methodSelector == TAKE_ORDER) {\n                require(\n                    Registry(routes.registry).assetIsRegistered(orderAddresses[7]),\n                    'Taker fee asset not registered'\n                );\n            }\n        }\n        (bool success, bytes memory returnData) = exchanges[exchangeIndex].adapter.delegatecall(\n            abi.encodeWithSignature(\n                methodSignature,\n                exchanges[exchangeIndex].exchange,\n                orderAddresses,\n                orderValues,\n                orderData,\n                identifier,\n                signature\n            )\n        );\n        require(success, string(returnData));\n        PolicyManager(routes.policyManager).postValidate(methodSelector, [orderAddresses[0], orderAddresses[1], orderAddresses[2], orderAddresses[3], exchanges[exchangeIndex].exchange], [orderValues[0], orderValues[1], orderValues[6]], identifier);\n        emit ExchangeMethodCall(\n            exchanges[exchangeIndex].exchange,\n            methodSignature,\n            orderAddresses,\n            orderValues,\n            orderData,\n            identifier,\n            signature\n        );\n    }","contract":"Trading","time":0},{"type":"external-function ","before":"function addZeroExV2OrderData(\n        bytes32 orderId,\n        IZeroExV2.Order memory zeroExOrderData\n    ) public delegateInternal {\n        orderIdToZeroExV2Order[orderId] = zeroExOrderData;\n    }","after":"function addZeroExV2OrderData(\n        bytes32 orderId,\n        IZeroExV2.Order calldata zeroExOrderData\n    ) public delegateInternal {\n        orderIdToZeroExV2Order[orderId] = zeroExOrderData;\n    }","contract":"Trading","time":0},{"type":"external-function ","before":"function addZeroExV3OrderData(\n        bytes32 orderId,\n        IZeroExV3.Order memory zeroExOrderData\n    ) public delegateInternal {\n        orderIdToZeroExV3Order[orderId] = zeroExOrderData;\n    }","after":"function addZeroExV3OrderData(\n        bytes32 orderId,\n        IZeroExV3.Order calldata zeroExOrderData\n    ) public delegateInternal {\n        orderIdToZeroExV3Order[orderId] = zeroExOrderData;\n    }","contract":"Trading","time":0},{"type":"external-function ","before":"function orderUpdateHook(\n        address ofExchange,\n        bytes32 orderId,\n        UpdateType updateType,\n        address payable[2] memory orderAddresses,\n        uint[3] memory orderValues\n    ) public delegateInternal {\n        // only save make/take\n        if (updateType == UpdateType.make || updateType == UpdateType.take) {\n            orders.push(Order({\n            exchangeAddress : ofExchange,\n            orderId : orderId,\n            updateType : updateType,\n            makerAsset : orderAddresses[0],\n            takerAsset : orderAddresses[1],\n            makerQuantity : orderValues[0],\n            takerQuantity : orderValues[1],\n            timestamp : block.timestamp,\n            fillTakerQuantity : orderValues[2]\n            }));\n        }\n    }","after":"function orderUpdateHook(\n        address ofExchange,\n        bytes32 orderId,\n        UpdateType updateType,\n        address payable[2] calldata orderAddresses,\n        uint[3] calldata orderValues\n    ) public delegateInternal {\n        // only save make/take\n        if (updateType == UpdateType.make || updateType == UpdateType.take) {\n            orders.push(Order({\n            exchangeAddress : ofExchange,\n            orderId : orderId,\n            updateType : updateType,\n            makerAsset : orderAddresses[0],\n            takerAsset : orderAddresses[1],\n            makerQuantity : orderValues[0],\n            takerQuantity : orderValues[1],\n            timestamp : block.timestamp,\n            fillTakerQuantity : orderValues[2]\n            }));\n        }\n    }","contract":"Trading","time":1},{"type":"external-function ","before":"function createInstance(\n        address _hub,\n        address[] memory _exchanges,\n        address[] memory _adapters,\n        address _registry\n    ) public returns (address) {\n        address trading = address(new Trading(_hub, _exchanges, _adapters, _registry));\n        childExists[trading] = true;\n        emit NewInstance(\n            _hub,\n            trading,\n            _exchanges,\n            _adapters,\n            _registry\n        );\n        return trading;\n    }","after":"function createInstance(\n        address _hub,\n        address[] calldata _exchanges,\n        address[] calldata _adapters,\n        address _registry\n    ) public returns (address) {\n        address trading = address(new Trading(_hub, _exchanges, _adapters, _registry));\n        childExists[trading] = true;\n        emit NewInstance(\n            _hub,\n            trading,\n            _exchanges,\n            _adapters,\n            _registry\n        );\n        return trading;\n    }","contract":"TradingFactory","time":0},{"type":"external-function ","before":"function takeOrder(\n        address _targetExchange,\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData,\n        bytes32 _identifier,\n        bytes memory _signature\n    )\n    public\n    override\n    onlyManager\n    notShutDown\n    {\n        Hub hub = getHub();\n\n        require(\n            _orderValues[1] == _orderValues[6],\n            \"Taker asset amount must equal taker asset fill amount\"\n        );\n\n        address makerAsset = _orderAddresses[2];\n        address takerAsset = _orderAddresses[3];\n        uint makerAssetAmount = _orderValues[0];\n        uint takerAssetAmount = _orderValues[1];\n\n        uint actualReceiveAmount = dispatchSwap(\n            _targetExchange, takerAsset, takerAssetAmount, makerAsset, makerAssetAmount\n        );\n        require(\n            actualReceiveAmount >= makerAssetAmount,\n            \"Received less than expected from Uniswap exchange\"\n        );\n\n        updateStateTakeOrder(\n            _targetExchange,\n            makerAsset,\n            takerAsset,\n            takerAssetAmount,\n            actualReceiveAmount\n        );\n    }","after":"function takeOrder(\n        address _targetExchange,\n        address[8] calldata _orderAddresses,\n        uint[8] calldata _orderValues,\n        bytes[4] calldata _orderData,\n        bytes32 _identifier,\n        bytes calldata _signature\n    )\n    public\n    override\n    onlyManager\n    notShutDown\n    {\n        Hub hub = getHub();\n\n        require(\n            _orderValues[1] == _orderValues[6],\n            \"Taker asset amount must equal taker asset fill amount\"\n        );\n\n        address makerAsset = _orderAddresses[2];\n        address takerAsset = _orderAddresses[3];\n        uint makerAssetAmount = _orderValues[0];\n        uint takerAssetAmount = _orderValues[1];\n\n        uint actualReceiveAmount = dispatchSwap(\n            _targetExchange, takerAsset, takerAssetAmount, makerAsset, makerAssetAmount\n        );\n        require(\n            actualReceiveAmount >= makerAssetAmount,\n            \"Received less than expected from Uniswap exchange\"\n        );\n\n        updateStateTakeOrder(\n            _targetExchange,\n            makerAsset,\n            takerAsset,\n            takerAssetAmount,\n            actualReceiveAmount\n        );\n    }","contract":"UniswapAdapter","time":0},{"type":"external-function ","before":"function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function makeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"UniswapAdapter","time":0},{"type":"external-function ","before":"function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function takeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"UniswapAdapter","time":0},{"type":"external-function ","before":"function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function cancelOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"UniswapAdapter","time":0},{"type":"external-function ","before":"function batchRemoveFromWhitelist(address[] memory _members) public auth {\n        for (uint i = 0; i < _members.length; i++) {\n            removeFromWhitelist(_members[i]);\n        }\n    }","after":"function batchRemoveFromWhitelist(address[] calldata _members) public auth {\n        for (uint i = 0; i < _members.length; i++) {\n            removeFromWhitelist(_members[i]);\n        }\n    }","contract":"UserWhitelist","time":0},{"type":"external-function ","before":"function beginSetup(\n        string memory _name,\n        address[] memory _fees,\n        uint[] memory _feeRates,\n        uint[] memory _feePeriods,\n        address[] memory _exchanges,\n        address[] memory _adapters,\n        address _denominationAsset,\n        address[] memory _defaultInvestmentAssets\n    )\n    public\n    {\n        ensureComponentNotSet(managersToHubs[msg.sender]);\n        associatedRegistry.reserveFundName(\n            msg.sender,\n            _name\n        );\n        require(\n            associatedRegistry.assetIsRegistered(_denominationAsset),\n            \"Denomination asset must be registered\"\n        );\n\n        managersToHubs[msg.sender] = address(new Hub(msg.sender, _name));\n        managersToSettings[msg.sender] = Settings(\n            _name,\n            _exchanges,\n            _adapters,\n            _denominationAsset,\n            _defaultInvestmentAssets,\n            _fees,\n            _feeRates,\n            _feePeriods\n        );\n        managersToRoutes[msg.sender].registry = address(associatedRegistry);\n        managersToRoutes[msg.sender].version = address(version);\n        managersToRoutes[msg.sender].engine = engine();\n        managersToRoutes[msg.sender].mlnToken = mlnToken();\n    }","after":"function beginSetup(\n        string calldata _name,\n        address[] calldata _fees,\n        uint[] calldata _feeRates,\n        uint[] calldata _feePeriods,\n        address[] calldata _exchanges,\n        address[] calldata _adapters,\n        address _denominationAsset,\n        address[] calldata _defaultInvestmentAssets\n    )\n    public\n    {\n        ensureComponentNotSet(managersToHubs[msg.sender]);\n        associatedRegistry.reserveFundName(\n            msg.sender,\n            _name\n        );\n        require(\n            associatedRegistry.assetIsRegistered(_denominationAsset),\n            \"Denomination asset must be registered\"\n        );\n\n        managersToHubs[msg.sender] = address(new Hub(msg.sender, _name));\n        managersToSettings[msg.sender] = Settings(\n            _name,\n            _exchanges,\n            _adapters,\n            _denominationAsset,\n            _defaultInvestmentAssets,\n            _fees,\n            _feeRates,\n            _feePeriods\n        );\n        managersToRoutes[msg.sender].registry = address(associatedRegistry);\n        managersToRoutes[msg.sender].version = address(version);\n        managersToRoutes[msg.sender].engine = engine();\n        managersToRoutes[msg.sender].mlnToken = mlnToken();\n    }","contract":"Version","time":0},{"type":"constant-restrict-modification  ","before":"string public name = \"Wrapped Ether\";","after":"string public constant name = \"Wrapped Ether\";","contract":"WETH","time":0},{"type":"constant-restrict-modification  ","before":"string public symbol = \"WETH\";","after":"string public constant symbol = \"WETH\";","contract":"WETH","time":0},{"type":"constant-restrict-modification  ","before":"uint8  public decimals = 18;","after":"uint8  public constant decimals = 18;","contract":"WETH","time":0},{"type":"external-function ","before":"function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    )\n    public\n    override\n    onlyManager\n    notShutDown\n    orderAddressesMatchOrderData(orderAddresses, orderData)\n    {\n        ensureCanMakeOrder(orderAddresses[2]);\n\n        IZeroExV2.Order memory order = constructOrderStruct(orderAddresses, orderValues, orderData);\n        address makerAsset = getAssetAddress(orderData[0]);\n        address takerAsset = getAssetAddress(orderData[1]);\n\n        // Order parameter checks\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\n        ensureNotInOpenMakeOrder(makerAsset);\n\n        approveAssetsMakeOrder(targetExchange, order);\n\n        IZeroExV2.OrderInfo memory orderInfo = IZeroExV2(targetExchange).getOrderInfo(order);\n        IZeroExV2(targetExchange).preSign(orderInfo.orderHash, address(this), signature);\n\n        require(\n            IZeroExV2(targetExchange).isValidSignature(\n                orderInfo.orderHash,\n                address(this),\n                signature\n            ),\n            \"INVALID_ORDER_SIGNATURE\"\n        );\n\n        updateStateMakeOrder(targetExchange, order);\n    }","after":"function makeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    )\n    public\n    override\n    onlyManager\n    notShutDown\n    orderAddressesMatchOrderData(orderAddresses, orderData)\n    {\n        ensureCanMakeOrder(orderAddresses[2]);\n\n        IZeroExV2.Order memory order = constructOrderStruct(orderAddresses, orderValues, orderData);\n        address makerAsset = getAssetAddress(orderData[0]);\n        address takerAsset = getAssetAddress(orderData[1]);\n\n        // Order parameter checks\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\n        ensureNotInOpenMakeOrder(makerAsset);\n\n        approveAssetsMakeOrder(targetExchange, order);\n\n        IZeroExV2.OrderInfo memory orderInfo = IZeroExV2(targetExchange).getOrderInfo(order);\n        IZeroExV2(targetExchange).preSign(orderInfo.orderHash, address(this), signature);\n\n        require(\n            IZeroExV2(targetExchange).isValidSignature(\n                orderInfo.orderHash,\n                address(this),\n                signature\n            ),\n            \"INVALID_ORDER_SIGNATURE\"\n        );\n\n        updateStateMakeOrder(targetExchange, order);\n    }","contract":"ZeroExV2Adapter","time":0},{"type":"external-function ","before":"function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    )\n    public\n    override\n    onlyManager\n    notShutDown\n    orderAddressesMatchOrderData(orderAddresses, orderData)\n    {\n        IZeroExV2.Order memory order = constructOrderStruct(orderAddresses, orderValues, orderData);\n\n        uint fillTakerQuantity = orderValues[6];\n\n        approveAssetsTakeOrder(targetExchange, order);\n\n        uint takerAssetFilledAmount = executeFill(targetExchange, order, fillTakerQuantity, signature);\n        require(\n            takerAssetFilledAmount == fillTakerQuantity,\n            \"Filled amount does not match desired fill amount\"\n        );\n\n        updateStateTakeOrder(targetExchange, order, fillTakerQuantity);\n    }","after":"function takeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    )\n    public\n    override\n    onlyManager\n    notShutDown\n    orderAddressesMatchOrderData(orderAddresses, orderData)\n    {\n        IZeroExV2.Order memory order = constructOrderStruct(orderAddresses, orderValues, orderData);\n\n        uint fillTakerQuantity = orderValues[6];\n\n        approveAssetsTakeOrder(targetExchange, order);\n\n        uint takerAssetFilledAmount = executeFill(targetExchange, order, fillTakerQuantity, signature);\n        require(\n            takerAssetFilledAmount == fillTakerQuantity,\n            \"Filled amount does not match desired fill amount\"\n        );\n\n        updateStateTakeOrder(targetExchange, order, fillTakerQuantity);\n    }","contract":"ZeroExV2Adapter","time":0},{"type":"external-function ","before":"function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    )\n    public\n    override\n    orderAddressesMatchOrderData(orderAddresses, orderData)\n    {\n        IZeroExV2.Order memory order = getTrading().getZeroExV2OrderDetails(identifier);\n        ensureCancelPermitted(targetExchange, orderAddresses[2], identifier);\n\n        if (order.expirationTimeSeconds > block.timestamp) {\n            IZeroExV2(targetExchange).cancelOrder(order);\n        }\n\n        revokeApproveAssetsCancelOrder(targetExchange, order);\n\n        updateStateCancelOrder(targetExchange, order);\n    }","after":"function cancelOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    )\n    public\n    override\n    orderAddressesMatchOrderData(orderAddresses, orderData)\n    {\n        IZeroExV2.Order memory order = getTrading().getZeroExV2OrderDetails(identifier);\n        ensureCancelPermitted(targetExchange, orderAddresses[2], identifier);\n\n        if (order.expirationTimeSeconds > block.timestamp) {\n            IZeroExV2(targetExchange).cancelOrder(order);\n        }\n\n        revokeApproveAssetsCancelOrder(targetExchange, order);\n\n        updateStateCancelOrder(targetExchange, order);\n    }","contract":"ZeroExV2Adapter","time":0},{"type":"external-function ","before":"function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function makeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"ZeroExV2Adapter","time":0},{"type":"external-function ","before":"function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function takeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"ZeroExV2Adapter","time":0},{"type":"external-function ","before":"function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function cancelOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"ZeroExV2Adapter","time":0},{"type":"external-function ","before":"function makeOrder(\n        address _targetExchange,\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData,\n        bytes32 _identifier,\n        bytes memory _signature\n    )\n    public\n    override\n    onlyManager\n    notShutDown\n    orderAddressesMatchOrderData(_orderAddresses, _orderValues, _orderData)\n    {\n        ensureCanMakeOrder(_orderAddresses[2]);\n\n        IZeroExV3.Order memory order = constructOrderStruct(_orderAddresses, _orderValues, _orderData);\n        address makerAsset = getAssetAddress(_orderData[0]);\n        address takerAsset = getAssetAddress(_orderData[1]);\n\n        // Order parameter checks\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\n        ensureNotInOpenMakeOrder(makerAsset);\n\n        approveAssetsMakeOrder(_targetExchange, order);\n\n        IZeroExV3.OrderInfo memory orderInfo = IZeroExV3(_targetExchange).getOrderInfo(order);\n        IZeroExV3(_targetExchange).preSign(orderInfo.orderHash);\n\n        require(\n            IZeroExV3(_targetExchange).isValidOrderSignature(order, _signature),\n            \"INVALID_ORDER_SIGNATURE\"\n        );\n\n        updateStateMakeOrder(_targetExchange, order);\n    }","after":"function makeOrder(\n        address _targetExchange,\n        address[8] calldata _orderAddresses,\n        uint[8] calldata _orderValues,\n        bytes[4] calldata _orderData,\n        bytes32 _identifier,\n        bytes calldata _signature\n    )\n    public\n    override\n    onlyManager\n    notShutDown\n    orderAddressesMatchOrderData(_orderAddresses, _orderValues, _orderData)\n    {\n        ensureCanMakeOrder(_orderAddresses[2]);\n\n        IZeroExV3.Order memory order = constructOrderStruct(_orderAddresses, _orderValues, _orderData);\n        address makerAsset = getAssetAddress(_orderData[0]);\n        address takerAsset = getAssetAddress(_orderData[1]);\n\n        // Order parameter checks\n        getTrading().updateAndGetQuantityBeingTraded(makerAsset);\n        ensureNotInOpenMakeOrder(makerAsset);\n\n        approveAssetsMakeOrder(_targetExchange, order);\n\n        IZeroExV3.OrderInfo memory orderInfo = IZeroExV3(_targetExchange).getOrderInfo(order);\n        IZeroExV3(_targetExchange).preSign(orderInfo.orderHash);\n\n        require(\n            IZeroExV3(_targetExchange).isValidOrderSignature(order, _signature),\n            \"INVALID_ORDER_SIGNATURE\"\n        );\n\n        updateStateMakeOrder(_targetExchange, order);\n    }","contract":"ZeroExV3Adapter","time":0},{"type":"external-function ","before":"function takeOrder(\n        address _targetExchange,\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData,\n        bytes32 _identifier,\n        bytes memory _signature\n    )\n    public\n    override\n    onlyManager\n    notShutDown\n    orderAddressesMatchOrderData(_orderAddresses, _orderValues, _orderData)\n    {\n        IZeroExV3.Order memory order = constructOrderStruct(_orderAddresses, _orderValues, _orderData);\n        require(IZeroExV3(_targetExchange).isValidOrderSignature(order, _signature), \"Order _signature is invalid\");\n\n        uint256 fillTakerQuantity = _orderValues[6];\n\n        approveAssetsTakeOrder(_targetExchange, order);\n\n        uint256 takerAssetFilledAmount = executeFill(_targetExchange, order, fillTakerQuantity, _signature);\n        require(\n            takerAssetFilledAmount == fillTakerQuantity,\n            \"Filled amount does not match desired fill amount\"\n        );\n\n        updateStateTakeOrder(_targetExchange, order, fillTakerQuantity);\n    }","after":"function takeOrder(\n        address _targetExchange,\n        address[8] calldata _orderAddresses,\n        uint[8] calldata _orderValues,\n        bytes[4] calldata _orderData,\n        bytes32 _identifier,\n        bytes calldata _signature\n    )\n    public\n    override\n    onlyManager\n    notShutDown\n    orderAddressesMatchOrderData(_orderAddresses, _orderValues, _orderData)\n    {\n        IZeroExV3.Order memory order = constructOrderStruct(_orderAddresses, _orderValues, _orderData);\n        require(IZeroExV3(_targetExchange).isValidOrderSignature(order, _signature), \"Order _signature is invalid\");\n\n        uint256 fillTakerQuantity = _orderValues[6];\n\n        approveAssetsTakeOrder(_targetExchange, order);\n\n        uint256 takerAssetFilledAmount = executeFill(_targetExchange, order, fillTakerQuantity, _signature);\n        require(\n            takerAssetFilledAmount == fillTakerQuantity,\n            \"Filled amount does not match desired fill amount\"\n        );\n\n        updateStateTakeOrder(_targetExchange, order, fillTakerQuantity);\n    }","contract":"ZeroExV3Adapter","time":0},{"type":"external-function ","before":"function cancelOrder(\n        address _targetExchange,\n        address[8] memory _orderAddresses,\n        uint[8] memory _orderValues,\n        bytes[4] memory _orderData,\n        bytes32 _identifier,\n        bytes memory _signature\n    )\n    public\n    override\n    orderAddressesMatchOrderData(_orderAddresses, _orderValues, _orderData)\n    {\n        IZeroExV3.Order memory order = getTrading().getZeroExV3OrderDetails(_identifier);\n        ensureCancelPermitted(_targetExchange, getAssetAddress(order.makerAssetData), _identifier);\n        if (order.expirationTimeSeconds > block.timestamp) {\n            IZeroExV3(_targetExchange).cancelOrder(order);\n        }\n\n        revokeApproveAssetsCancelOrder(_targetExchange, order);\n\n        updateStateCancelOrder(_targetExchange, order);\n    }","after":"function cancelOrder(\n        address _targetExchange,\n        address[8] calldata _orderAddresses,\n        uint[8] calldata _orderValues,\n        bytes[4] calldata _orderData,\n        bytes32 _identifier,\n        bytes calldata _signature\n    )\n    public\n    override\n    orderAddressesMatchOrderData(_orderAddresses, _orderValues, _orderData)\n    {\n        IZeroExV3.Order memory order = getTrading().getZeroExV3OrderDetails(_identifier);\n        ensureCancelPermitted(_targetExchange, getAssetAddress(order.makerAssetData), _identifier);\n        if (order.expirationTimeSeconds > block.timestamp) {\n            IZeroExV3(_targetExchange).cancelOrder(order);\n        }\n\n        revokeApproveAssetsCancelOrder(_targetExchange, order);\n\n        updateStateCancelOrder(_targetExchange, order);\n    }","contract":"ZeroExV3Adapter","time":0},{"type":"external-function ","before":"function makeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function makeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"ZeroExV3Adapter","time":0},{"type":"external-function ","before":"function takeOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function takeOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"ZeroExV3Adapter","time":0},{"type":"external-function ","before":"function cancelOrder(\n        address targetExchange,\n        address[8] memory orderAddresses,\n        uint[8] memory orderValues,\n        bytes[4] memory orderData,\n        bytes32 identifier,\n        bytes memory signature\n    ) public virtual {revert(\"Unimplemented\");}","after":"function cancelOrder(\n        address targetExchange,\n        address[8] calldata orderAddresses,\n        uint[8] calldata orderValues,\n        bytes[4] calldata orderData,\n        bytes32 identifier,\n        bytes calldata signature\n    ) public virtual {revert(\"Unimplemented\");}","contract":"ZeroExV3Adapter","time":0}]}