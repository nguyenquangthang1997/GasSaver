{"time":420,"results":[{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"SyntheticToken","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"SyntheticToken","time":1},{"type":"external-function ","before":"function deposit(FixedPoint.Unsigned memory collateralAmount) public {\n\n        // This is just a thin wrapper over depositTo that specified the sender as the sponsor.\n\n        depositTo(msg.sender, collateralAmount);\n\n    }","after":"function deposit(FixedPoint.Unsigned calldata collateralAmount) public {\n\n        // This is just a thin wrapper over depositTo that specified the sender as the sponsor.\n\n        depositTo(msg.sender, collateralAmount);\n\n    }","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"function withdraw(FixedPoint.Unsigned memory collateralAmount)\n\n    public\n\n    onlyPreExpiration()\n\n    noPendingWithdrawal(msg.sender)\n\n    fees()\n\n    nonReentrant()\n\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n\n    {\n\n        PositionData storage positionData = _getPositionData(msg.sender);\n\n        require(collateralAmount.isGreaterThan(0), \"Invalid collateral amount\");\n\n\n        // Decrement the sponsor's collateral and global collateral amounts. Check the GCR between decrement to ensure\n\n        // position remains above the GCR within the witdrawl. If this is not the case the caller must submit a request.\n\n        amountWithdrawn = _decrementCollateralBalancesCheckGCR(positionData, collateralAmount);\n\n\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n\n\n        // Move collateral currency from contract to sender.\n\n        // Note: that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n\n        // instead of the user requested amount. This eliminates precision loss that could occur\n\n        // where the user withdraws more collateral than rawCollateral is decremented by.\n\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n\n    }","after":"function withdraw(FixedPoint.Unsigned calldata collateralAmount)\n\n    public\n\n    onlyPreExpiration()\n\n    noPendingWithdrawal(msg.sender)\n\n    fees()\n\n    nonReentrant()\n\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n\n    {\n\n        PositionData storage positionData = _getPositionData(msg.sender);\n\n        require(collateralAmount.isGreaterThan(0), \"Invalid collateral amount\");\n\n\n        // Decrement the sponsor's collateral and global collateral amounts. Check the GCR between decrement to ensure\n\n        // position remains above the GCR within the witdrawl. If this is not the case the caller must submit a request.\n\n        amountWithdrawn = _decrementCollateralBalancesCheckGCR(positionData, collateralAmount);\n\n\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n\n\n        // Move collateral currency from contract to sender.\n\n        // Note: that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n\n        // instead of the user requested amount. This eliminates precision loss that could occur\n\n        // where the user withdraws more collateral than rawCollateral is decremented by.\n\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n\n    }","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\n\n    public\n\n    onlyPreExpiration()\n\n    noPendingWithdrawal(msg.sender)\n\n    nonReentrant()\n\n    {\n\n        PositionData storage positionData = _getPositionData(msg.sender);\n\n        require(\n\n            collateralAmount.isGreaterThan(0) &&\n\n            collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral)),\n\n            \"Invalid collateral amount\"\n\n        );\n\n\n        // Make sure the proposed expiration of this request is not post-expiry.\n\n        uint256 requestPassTime = getCurrentTime().add(withdrawalLiveness);\n\n        require(requestPassTime < expirationTimestamp, \"Request expires post-expiry\");\n\n\n        // Update the position object for the user.\n\n        positionData.withdrawalRequestPassTimestamp = requestPassTime;\n\n        positionData.withdrawalRequestAmount = collateralAmount;\n\n\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n\n    }","after":"function requestWithdrawal(FixedPoint.Unsigned calldata collateralAmount)\n\n    public\n\n    onlyPreExpiration()\n\n    noPendingWithdrawal(msg.sender)\n\n    nonReentrant()\n\n    {\n\n        PositionData storage positionData = _getPositionData(msg.sender);\n\n        require(\n\n            collateralAmount.isGreaterThan(0) &&\n\n            collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral)),\n\n            \"Invalid collateral amount\"\n\n        );\n\n\n        // Make sure the proposed expiration of this request is not post-expiry.\n\n        uint256 requestPassTime = getCurrentTime().add(withdrawalLiveness);\n\n        require(requestPassTime < expirationTimestamp, \"Request expires post-expiry\");\n\n\n        // Update the position object for the user.\n\n        positionData.withdrawalRequestPassTimestamp = requestPassTime;\n\n        positionData.withdrawalRequestAmount = collateralAmount;\n\n\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n\n    }","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"function create(FixedPoint.Unsigned memory collateralAmount, FixedPoint.Unsigned memory numTokens)\n\n    public\n\n    onlyPreExpiration()\n\n    fees()\n\n    nonReentrant()\n\n    {\n\n        PositionData storage positionData = positions[msg.sender];\n\n\n        // Either the new create ratio or the resultant position CR must be above the current GCR.\n\n        require(\n\n            (_checkCollateralization(\n\n            _getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),\n\n            positionData.tokensOutstanding.add(numTokens)\n\n        ) || _checkCollateralization(collateralAmount, numTokens)),\n\n            \"Insufficient collateral\"\n\n        );\n\n\n        require(positionData.withdrawalRequestPassTimestamp == 0, \"Pending withdrawal\");\n\n        if (positionData.tokensOutstanding.isEqual(0)) {\n\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\n\n            emit NewSponsor(msg.sender);\n\n        }\n\n\n        // Increase the position and global collateral balance by collateral amount.\n\n        _incrementCollateralBalances(positionData, collateralAmount);\n\n\n        // Add the number of tokens created to the position's outstanding tokens.\n\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n\n\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n\n\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n\n\n        // Transfer tokens into the contract from caller and mint corresponding synthetic tokens to the caller's address.\n\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue), \"Minting synthetic tokens failed\");\n\n    }","after":"function create(FixedPoint.Unsigned calldata collateralAmount, FixedPoint.Unsigned calldata numTokens)\n\n    public\n\n    onlyPreExpiration()\n\n    fees()\n\n    nonReentrant()\n\n    {\n\n        PositionData storage positionData = positions[msg.sender];\n\n\n        // Either the new create ratio or the resultant position CR must be above the current GCR.\n\n        require(\n\n            (_checkCollateralization(\n\n            _getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),\n\n            positionData.tokensOutstanding.add(numTokens)\n\n        ) || _checkCollateralization(collateralAmount, numTokens)),\n\n            \"Insufficient collateral\"\n\n        );\n\n\n        require(positionData.withdrawalRequestPassTimestamp == 0, \"Pending withdrawal\");\n\n        if (positionData.tokensOutstanding.isEqual(0)) {\n\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\n\n            emit NewSponsor(msg.sender);\n\n        }\n\n\n        // Increase the position and global collateral balance by collateral amount.\n\n        _incrementCollateralBalances(positionData, collateralAmount);\n\n\n        // Add the number of tokens created to the position's outstanding tokens.\n\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n\n\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n\n\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n\n\n        // Transfer tokens into the contract from caller and mint corresponding synthetic tokens to the caller's address.\n\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue), \"Minting synthetic tokens failed\");\n\n    }","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"function redeem(FixedPoint.Unsigned memory numTokens)\n\n    public\n\n    noPendingWithdrawal(msg.sender)\n\n    fees()\n\n    nonReentrant()\n\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n\n    {\n\n        PositionData storage positionData = _getPositionData(msg.sender);\n\n        require(!numTokens.isGreaterThan(positionData.tokensOutstanding), \"Invalid token amount\");\n\n\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n\n        FixedPoint.Unsigned memory collateralRedeemed = fractionRedeemed.mul(\n\n            _getFeeAdjustedCollateral(positionData.rawCollateral)\n\n        );\n\n\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n\n        } else {\n\n            // Decrement the sponsor's collateral and global collateral amounts.\n\n            amountWithdrawn = _decrementCollateralBalances(positionData, collateralRedeemed);\n\n\n            // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\n\n            positionData.tokensOutstanding = newTokenCount;\n\n\n            // Update the totalTokensOutstanding after redemption.\n\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n\n        }\n\n\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n\n\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n\n        tokenCurrency.burn(numTokens.rawValue);\n\n    }","after":"function redeem(FixedPoint.Unsigned calldata numTokens)\n\n    public\n\n    noPendingWithdrawal(msg.sender)\n\n    fees()\n\n    nonReentrant()\n\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n\n    {\n\n        PositionData storage positionData = _getPositionData(msg.sender);\n\n        require(!numTokens.isGreaterThan(positionData.tokensOutstanding), \"Invalid token amount\");\n\n\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n\n        FixedPoint.Unsigned memory collateralRedeemed = fractionRedeemed.mul(\n\n            _getFeeAdjustedCollateral(positionData.rawCollateral)\n\n        );\n\n\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n\n        } else {\n\n            // Decrement the sponsor's collateral and global collateral amounts.\n\n            amountWithdrawn = _decrementCollateralBalances(positionData, collateralRedeemed);\n\n\n            // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\n\n            positionData.tokensOutstanding = newTokenCount;\n\n\n            // Update the totalTokensOutstanding after redemption.\n\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n\n        }\n\n\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n\n\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n\n        tokenCurrency.burn(numTokens.rawValue);\n\n    }","contract":"ExpiringMultiParty","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public liquidationLiveness;","after":"uint256 public immutable liquidationLiveness;","contract":"ExpiringMultiParty","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 public priceIdentifier;","after":"bytes32 public immutable priceIdentifier;","contract":"ExpiringMultiParty","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public withdrawalLiveness;","after":"uint256 public immutable withdrawalLiveness;","contract":"ExpiringMultiParty","time":1},{"type":"immutable-restrict-modification ","before":"address public excessTokenBeneficiary;","after":"address public immutable excessTokenBeneficiary;","contract":"ExpiringMultiParty","time":1},{"type":"immutable-restrict-modification ","before":"address public timerAddress;","after":"address public immutable timerAddress;","contract":"ExpiringMultiParty","time":1}]}