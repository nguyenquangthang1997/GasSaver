{"time":663,"results":[{"type":"external-function ","before":"function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\n\n        _name = name;\n\n        _symbol = symbol;\n\n        _decimals = decimals;\n\n    }","after":"function initialize(string calldata name, string calldata symbol, uint8 decimals) public initializer {\n\n        _name = name;\n\n        _symbol = symbol;\n\n        _decimals = decimals;\n\n    }","contract":"RariFundToken","time":0},{"type":"struct-data-arrangement ","before":"\n  address ad\n  BassetStatus stat\n  bool isTransferFeeCharg\n  uint256 rat\n  uint256 maxWeig\n  uint256 vaultBalan","after":"  BassetStatus stat\n  uint256 rat\n  uint256 maxWeig\n  uint256 vaultBalan\n  address ad\n  bool isTransferFeeCharg\n","contract":"MassetStructs","time":0},{"type":"loop-duplication","before":"\nstart line 4871 column 8, end line 4871 column 129\n    for (uint256 i = 0; i < _supportedCurrencies.length; i++) if (_acceptedCurrencies[_supportedCurrencies[i]]) arrayLengt\nstart line 4878 column 8, end line 4884 column 8\n    for (uint256 i = 0; i < _supportedCurrencies.length; i++) if (_acceptedCurrencies[_supportedCurrencies[i]]) {\n\n            acceptedCurrencies[index] = _supportedCurrencies[i];\n\n            index++;\n\n     ","after":"// merge loop\n\nstart line 4871 column 8, end line 4871 column 129\n    for (uint256 i = 0; i < _supportedCurrencies.length; i++) if (_acceptedCurrencies[_supportedCurrencies[i]]) arrayLengt\nstart line 4878 column 8, end line 4884 column 8\n    for (uint256 i = 0; i < _supportedCurrencies.length; i++) if (_acceptedCurrencies[_supportedCurrencies[i]]) {\n\n            acceptedCurrencies[index] = _supportedCurrencies[i];\n\n            index++;\n\n     ","contract":"RariFundManager","time":0},{"type":"constant-restrict-modification  ","before":"{\n\n    uint256 public exchan","after":"{\n\n    uint256 public exchan","contract":"ISavingsContract","time":0},{"type":"external-function ","before":"  */\n\n    function marketSellOrdersFillOrKill(LibOrder.Order[] memory orders, bytes[] memory signatures, uint256 takerAssetFillAmount, uint256 protocolFee) public returns (uint256[2] memory) {\n\n        require(orders.length > 0, \"At least one order and matching signature is required.\");\n\n        require(orders.length == signatures.length, \"Mismatch between number of orders and signatures.\");\n\n        require(takerAssetFillAmount > 0, \"Taker asset fill amount must be greater than 0.\");\n\n        LibFillResults.FillResults memory fillResults = _exchange.marketSellOrdersFillOrKill.value(protocolFee)(orders, takerAssetFillAmount, signatures);\n\n        return [fillResults.takerAssetFilledAmount, fillResults.makerAssetFilledAmoun","after":"  */\n\n    function marketSellOrdersFillOrKill(LibOrder.Order[] calldata orders, bytes[] calldata signatures, uint256 takerAssetFillAmount, uint256 protocolFee) public returns (uint256[2] memory) {\n\n        require(orders.length > 0, \"At least one order and matching signature is required.\");\n\n        require(orders.length == signatures.length, \"Mismatch between number of orders and signatures.\");\n\n        require(takerAssetFillAmount > 0, \"Taker asset fill amount must be greater than 0.\");\n\n        LibFillResults.FillResults memory fillResults = _exchange.marketSellOrdersFillOrKill.value(protocolFee)(orders, takerAssetFillAmount, signatures);\n\n        return [fillResults.takerAssetFilledAmount, fillResults.makerAssetFilledAmoun","contract":"ZeroExExchangeController","time":0},{"type":"external-function ","before":"  */\n\n    function marketBuyOrdersFillOrKill(LibOrder.Order[] memory orders, bytes[] memory signatures, uint256 makerAssetFillAmount, uint256 protocolFee) public returns (uint256[2] memory) {\n\n        require(orders.length > 0, \"At least one order and matching signature is required.\");\n\n        require(orders.length == signatures.length, \"Mismatch between number of orders and signatures.\");\n\n        require(makerAssetFillAmount > 0, \"Maker asset fill amount must be greater than 0.\");\n\n        LibFillResults.FillResults memory fillResults = _exchange.marketBuyOrdersFillOrKill.value(protocolFee)(orders, makerAssetFillAmount, signatures);\n\n        return [fillResults.takerAssetFilledAmount, fillResults.makerAssetFilledAmoun","after":"  */\n\n    function marketBuyOrdersFillOrKill(LibOrder.Order[] calldata orders, bytes[] calldata signatures, uint256 makerAssetFillAmount, uint256 protocolFee) public returns (uint256[2] memory) {\n\n        require(orders.length > 0, \"At least one order and matching signature is required.\");\n\n        require(orders.length == signatures.length, \"Mismatch between number of orders and signatures.\");\n\n        require(makerAssetFillAmount > 0, \"Maker asset fill amount must be greater than 0.\");\n\n        LibFillResults.FillResults memory fillResults = _exchange.marketBuyOrdersFillOrKill.value(protocolFee)(orders, makerAssetFillAmount, signatures);\n\n        return [fillResults.takerAssetFilledAmount, fillResults.makerAssetFilledAmoun","contract":"ZeroExExchangeController","time":0},{"type":"state-data-arrangement ","before":"\n    */\n\n    bool public constant IS_RARI_FUND_CONTRO\n    */\n\n    bool public f\n    */\n\n    address private _rariFundMana\n    */\n\n    RariFundManager public rari\n    */\n\n    address private _rariFundRebala\n    */\n\n    string[] private _supporte\n    */\n\n    mapping(string => uint8) private _curr\n    */\n\n    mapping(string => uint256) private _curre\n    */\n\n    mapping(string => address) private _erc\n    */\n\n    mapping(string => LiquidityPool[]) private _pool\n    */\n\n    mapping(string => mapping(uint8 => bool)) _poo\n    */\n\n    uint16 _aaveR\n    */\n\n    uint256 private _dailyLo\n    */\n\n    CurrencyExchangeLoss[] private _loss","after":"    */\n\n    RariFundManager public rari\n    */\n\n    string[] private _supporte\n    */\n\n    mapping(string => uint8) private _curr\n    */\n\n    mapping(string => uint256) private _curre\n    */\n\n    mapping(string => address) private _erc\n    */\n\n    mapping(string => LiquidityPool[]) private _pool\n    */\n\n    mapping(string => mapping(uint8 => bool)) _poo\n    */\n\n    uint256 private _dailyLo\n    */\n\n    CurrencyExchangeLoss[] private _loss\n    */\n\n    address private _rariFundMana\n    */\n\n    address private _rariFundRebala\n    */\n\n    uint16 _aaveR\n    */\n\n    bool public constant IS_RARI_FUND_CONTRO\n    */\n\n    bool public f\n","contract":"RariFundController","time":0},{"type":"external-function ","before":"    */\n\n    function getPoolBalance(LiquidityPool pool, string memory currencyCode) public returns (uint256) {\n\n        if (!_poolsWithFunds[currencyCode][uint8(pool)]) return 0;\n\n        return _getPoolBalance(pool, currencyC","after":"    */\n\n    function getPoolBalance(LiquidityPool pool, string calldata currencyCode) public returns (uint256) {\n\n        if (!_poolsWithFunds[currencyCode][uint8(pool)]) return 0;\n\n        return _getPoolBalance(pool, currencyC","contract":"RariFundController","time":0},{"type":"external-function ","before":"    */\n\n    function marketSell0xOrdersFillOrKill(string memory inputCurrencyCode, string memory outputCurrencyCode, LibOrder.Order[] memory orders, bytes[] memory signatures, uint256 takerAssetFillAmount) public payable fundEnabled onlyRebalancer {\n\n        // Check if input is a supported stablecoin and make sure output is a supported stablecoin\n\n        address inputErc20Contract = _erc20Contracts[inputCurrencyCode];\n\n        address outputErc20Contract = _erc20Contracts[outputCurrencyCode];\n\n        require(outputErc20Contract != address(0), \"Invalid output currency code.\");\n\n\n        // Check orders (if inputting a supported stablecoin)\n\n        if (inputErc20Contract != address(0)) for (uint256 i = 0; i < orders.length; i++) {\n\n            address takerAssetAddress = ZeroExExchangeController.decodeTokenAddress(orders[i].takerAssetData);\n\n            require(inputErc20Contract == takerAssetAddress, \"Not all input assets correspond to input currency code.\");\n\n            address makerAssetAddress = ZeroExExchangeController.decodeTokenAddress(orders[i].makerAssetData);\n\n            require(outputErc20Contract == makerAssetAddress, \"Not all output assets correspond to output currency code.\");\n\n            if (orders[i].takerFee > 0) require(orders[i].takerFeeAssetData.length == 0, \"Taker fees are not supported.\");\n            // TODO: Support orders with taker fees (need to include taker fees in loss calculation)\n\n        }\n\n\n        // Get prices and raw fund balance before exchange\n\n        uint256[] memory pricesInUsd;\n\n        uint256 rawFundBalanceBeforeExchange;\n\n\n        if (inputErc20Contract != address(0)) {\n\n            pricesInUsd = rariFundManager.rariFundPriceConsumer().getCurrencyPricesInUsd();\n\n            rawFundBalanceBeforeExchange = rariFundManager.getRawFundBalance(pricesInUsd);\n\n        }\n\n\n        // Market sell\n\n        uint256[2] memory filledAmounts = ZeroExExchangeController.marketSellOrdersFillOrKill(orders, signatures, takerAssetFillAmount, msg.value);\n\n\n        // Check 24-hour loss rate limit (if inputting a supported stablecoin)\n\n        uint256 inputFilledAmountUsd = 0;\n\n        uint256 outputFilledAmountUsd = 0;\n\n\n        if (inputErc20Contract != address(0)) {\n\n            inputFilledAmountUsd = toUsd(inputCurrencyCode, filledAmounts[0], pricesInUsd);\n\n            outputFilledAmountUsd = toUsd(inputCurrencyCode, filledAmounts[1], pricesInUsd);\n\n            handleExchangeLoss(inputFilledAmountUsd, outputFilledAmountUsd, rawFundBalanceBeforeExchange);\n\n        }\n\n\n        // Emit event\n\n        emit CurrencyTrade(inputCurrencyCode, outputCurrencyCode, filledAmounts[0], inputFilledAmountUsd, filledAmounts[1], outputFilledAmountUsd, CurrencyExchange.ZeroEx);\n\n\n        // Refund unused ETH\n\n        uint256 ethBalance = address(this).balance;\n\n\n        if (ethBalance > 0) {\n\n            (bool success,) = msg.sender.call.value(ethBalance)(\"\");\n\n            require(success, \"Failed to transfer ETH to msg.sender after exchange.\");\n\n    ","after":"    */\n\n    function marketSell0xOrdersFillOrKill(string calldata inputCurrencyCode, string calldata outputCurrencyCode, LibOrder.Order[] calldata orders, bytes[] calldata signatures, uint256 takerAssetFillAmount) public payable fundEnabled onlyRebalancer {\n\n        // Check if input is a supported stablecoin and make sure output is a supported stablecoin\n\n        address inputErc20Contract = _erc20Contracts[inputCurrencyCode];\n\n        address outputErc20Contract = _erc20Contracts[outputCurrencyCode];\n\n        require(outputErc20Contract != address(0), \"Invalid output currency code.\");\n\n\n        // Check orders (if inputting a supported stablecoin)\n\n        if (inputErc20Contract != address(0)) for (uint256 i = 0; i < orders.length; i++) {\n\n            address takerAssetAddress = ZeroExExchangeController.decodeTokenAddress(orders[i].takerAssetData);\n\n            require(inputErc20Contract == takerAssetAddress, \"Not all input assets correspond to input currency code.\");\n\n            address makerAssetAddress = ZeroExExchangeController.decodeTokenAddress(orders[i].makerAssetData);\n\n            require(outputErc20Contract == makerAssetAddress, \"Not all output assets correspond to output currency code.\");\n\n            if (orders[i].takerFee > 0) require(orders[i].takerFeeAssetData.length == 0, \"Taker fees are not supported.\");\n            // TODO: Support orders with taker fees (need to include taker fees in loss calculation)\n\n        }\n\n\n        // Get prices and raw fund balance before exchange\n\n        uint256[] memory pricesInUsd;\n\n        uint256 rawFundBalanceBeforeExchange;\n\n\n        if (inputErc20Contract != address(0)) {\n\n            pricesInUsd = rariFundManager.rariFundPriceConsumer().getCurrencyPricesInUsd();\n\n            rawFundBalanceBeforeExchange = rariFundManager.getRawFundBalance(pricesInUsd);\n\n        }\n\n\n        // Market sell\n\n        uint256[2] memory filledAmounts = ZeroExExchangeController.marketSellOrdersFillOrKill(orders, signatures, takerAssetFillAmount, msg.value);\n\n\n        // Check 24-hour loss rate limit (if inputting a supported stablecoin)\n\n        uint256 inputFilledAmountUsd = 0;\n\n        uint256 outputFilledAmountUsd = 0;\n\n\n        if (inputErc20Contract != address(0)) {\n\n            inputFilledAmountUsd = toUsd(inputCurrencyCode, filledAmounts[0], pricesInUsd);\n\n            outputFilledAmountUsd = toUsd(inputCurrencyCode, filledAmounts[1], pricesInUsd);\n\n            handleExchangeLoss(inputFilledAmountUsd, outputFilledAmountUsd, rawFundBalanceBeforeExchange);\n\n        }\n\n\n        // Emit event\n\n        emit CurrencyTrade(inputCurrencyCode, outputCurrencyCode, filledAmounts[0], inputFilledAmountUsd, filledAmounts[1], outputFilledAmountUsd, CurrencyExchange.ZeroEx);\n\n\n        // Refund unused ETH\n\n        uint256 ethBalance = address(this).balance;\n\n\n        if (ethBalance > 0) {\n\n            (bool success,) = msg.sender.call.value(ethBalance)(\"\");\n\n            require(success, \"Failed to transfer ETH to msg.sender after exchange.\");\n\n    ","contract":"RariFundController","time":0}]}