{"time":505,"results":[{"type":"external-function ","before":"function transferController(address currencyCt, string memory standard)\npublic\nview\nreturns (TransferController)\n{\nif (bytes(standard).length > 0) {\nbytes32 standardHash = keccak256(abi.encodePacked(standard));\n\nrequire(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\nreturn TransferController(registeredTransferControllers[standardHash]);\n}\n\nrequire(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\nrequire(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\naddress controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\nrequire(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\nreturn TransferController(controllerAddress);\n}","after":"function transferController(address currencyCt, string calldata standard)\npublic\nview\nreturns (TransferController)\n{\nif (bytes(standard).length > 0) {\nbytes32 standardHash = keccak256(abi.encodePacked(standard));\n\nrequire(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\nreturn TransferController(registeredTransferControllers[standardHash]);\n}\n\nrequire(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\nrequire(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\naddress controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\nrequire(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\nreturn TransferController(controllerAddress);\n}","contract":"TransferControllerManager","time":0},{"type":"immutable-restrict-modification ","before":"address public origin;","after":"address public immutable origin;","contract":"TokenUpgradeAgent","time":0},{"type":"external-function ","before":"function upgradeBalanceRecords(address account, BalanceRecord[] memory _balanceRecords)\npublic\nonlyMinter\n{\n\nif (0 < _balanceRecords.length) {\n\nrequire(!mintingDisabled, \"Minting disabled [RevenueToken.sol:280]\");\n\n\nuint256 startIndex = balanceRecords[account].length;\nuint256 endIndex = startIndex.add(_balanceRecords.length).sub(1);\n\n\nuint256 previousBlockNumber = startIndex > 0 ? balanceRecords[account][startIndex - 1].blockNumber : 0;\n\n\nfor (uint256 i = 0; i < _balanceRecords.length; i++) {\n\nrequire(previousBlockNumber <= _balanceRecords[i].blockNumber, \"Invalid balance record block number [RevenueToken.sol:292]\");\n\n\nbalanceRecords[account].push(_balanceRecords[i]);\n\n\npreviousBlockNumber = _balanceRecords[i].blockNumber;\n}\n\n\nemit UpgradeBalanceRecords(account, startIndex, endIndex);\n}\n}","after":"function upgradeBalanceRecords(address account, BalanceRecord[] calldata _balanceRecords)\npublic\nonlyMinter\n{\n\nif (0 < _balanceRecords.length) {\n\nrequire(!mintingDisabled, \"Minting disabled [RevenueToken.sol:280]\");\n\n\nuint256 startIndex = balanceRecords[account].length;\nuint256 endIndex = startIndex.add(_balanceRecords.length).sub(1);\n\n\nuint256 previousBlockNumber = startIndex > 0 ? balanceRecords[account][startIndex - 1].blockNumber : 0;\n\n\nfor (uint256 i = 0; i < _balanceRecords.length; i++) {\n\nrequire(previousBlockNumber <= _balanceRecords[i].blockNumber, \"Invalid balance record block number [RevenueToken.sol:292]\");\n\n\nbalanceRecords[account].push(_balanceRecords[i]);\n\n\npreviousBlockNumber = _balanceRecords[i].blockNumber;\n}\n\n\nemit UpgradeBalanceRecords(account, startIndex, endIndex);\n}\n}","contract":"RevenueToken","time":0},{"type":"external-function ","before":"function defineReleases(Release[] memory _releases)\nonlyOperator\npublic\n{\n\nrequire(address(token) != address(0), \"Token not initialized [TokenMultiTimelock.sol:109]\");\n\n\nfor (uint256 i = 0; i < _releases.length; i++) {\n\ntotalLockedAmount += _releases[i].amount;\n\n\n\nrequire(token.balanceOf(address(this)) >= totalLockedAmount, \"Total locked amount overrun [TokenMultiTimelock.sol:118]\");\n\n\nreleases.push(_releases[i]);\n\n\nemit DefineReleaseEvent(_releases[i].blockNumber, _releases[i].earliestReleaseTime, _releases[i].amount,\ntotalLockedAmount, _releases[i].done);\n}\n}","after":"function defineReleases(Release[] calldata _releases)\nonlyOperator\npublic\n{\n\nrequire(address(token) != address(0), \"Token not initialized [TokenMultiTimelock.sol:109]\");\n\n\nfor (uint256 i = 0; i < _releases.length; i++) {\n\ntotalLockedAmount += _releases[i].amount;\n\n\n\nrequire(token.balanceOf(address(this)) >= totalLockedAmount, \"Total locked amount overrun [TokenMultiTimelock.sol:118]\");\n\n\nreleases.push(_releases[i]);\n\n\nemit DefineReleaseEvent(_releases[i].blockNumber, _releases[i].earliestReleaseTime, _releases[i].amount,\ntotalLockedAmount, _releases[i].done);\n}\n}","contract":"RevenueTokenManager","time":0},{"type":"loop-calculation","before":"uint256 startBlock = (\n0 == closedAccrualsByCurrency[currency.ct][currency.id].length ?\n0 :\nclosedAccrualsByCurrency[currency.ct][currency.id][closedAccrualsByCurrency[currency.ct][currency.id].length - 1].endBlock + 1\n);","after":"// move outside for loop\nuint256 startBlock = (\n0 == closedAccrualsByCurrency[currency.ct][currency.id].length ?\n0 :\nclosedAccrualsByCurrency[currency.ct][currency.id][closedAccrualsByCurrency[currency.ct][currency.id].length - 1].endBlock + 1\n);","loc":{"start":{"line":2642,"column":0},"end":{"line":2646,"column":1}},"contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function receiveTokens(string memory, int256 amount, address currencyCt, uint256 currencyId,\nstring memory standard)\npublic\n{\nreceiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n}","after":"function receiveTokens(string calldata, int256 amount, address currencyCt, uint256 currencyId,\nstring calldata standard)\npublic\n{\nreceiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n}","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\npublic\nonlyEnabledServiceAction(CLOSE_ACCRUAL_PERIOD_ACTION)\n{\n\nfor (uint256 i = 0; i < currencies.length; i = i.add(1)) {\nMonetaryTypesLib.Currency memory currency = currencies[i];\n\n\nint256 periodAmount = periodAccrual.get(currency.ct, currency.id);\n\n\nuint256 startBlock = (\n0 == closedAccrualsByCurrency[currency.ct][currency.id].length ?\n0 :\nclosedAccrualsByCurrency[currency.ct][currency.id][closedAccrualsByCurrency[currency.ct][currency.id].length - 1].endBlock + 1\n);\n\n\nclosedAccrualsByCurrency[currency.ct][currency.id].push(Accrual(startBlock, block.number, periodAmount));\n\n\naggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number] = aggregateAccrualBalance(\ncurrency.ct, currency.id\n);\n\nif (periodAmount > 0) {\n\nperiodAccrual.set(0, currency.ct, currency.id);\n\n\nperiodCurrencies.removeByCurrency(currency.ct, currency.id);\n}\n\n\nemit CloseAccrualPeriodEvent(\nperiodAmount,\naggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number],\ncurrency.ct, currency.id\n);\n}\n}","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata currencies)\npublic\nonlyEnabledServiceAction(CLOSE_ACCRUAL_PERIOD_ACTION)\n{\n\nfor (uint256 i = 0; i < currencies.length; i = i.add(1)) {\nMonetaryTypesLib.Currency memory currency = currencies[i];\n\n\nint256 periodAmount = periodAccrual.get(currency.ct, currency.id);\n\n\nuint256 startBlock = (\n0 == closedAccrualsByCurrency[currency.ct][currency.id].length ?\n0 :\nclosedAccrualsByCurrency[currency.ct][currency.id][closedAccrualsByCurrency[currency.ct][currency.id].length - 1].endBlock + 1\n);\n\n\nclosedAccrualsByCurrency[currency.ct][currency.id].push(Accrual(startBlock, block.number, periodAmount));\n\n\naggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number] = aggregateAccrualBalance(\ncurrency.ct, currency.id\n);\n\nif (periodAmount > 0) {\n\nperiodAccrual.set(0, currency.ct, currency.id);\n\n\nperiodCurrencies.removeByCurrency(currency.ct, currency.id);\n}\n\n\nemit CloseAccrualPeriodEvent(\nperiodAmount,\naggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number],\ncurrency.ct, currency.id\n);\n}\n}","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function claimAndTransferToBeneficiary(Beneficiary beneficiary, address destWallet, string memory balanceType,\naddress currencyCt, uint256 currencyId, string memory standard)\npublic\n{\n\n\nuint256 accrualIndex = (\n0 == claimedAccrualIndicesByWalletCurrency[msg.sender][currencyCt][currencyId].length ?\n0 :\nclaimedAccrualIndicesByWalletCurrency[msg.sender][currencyCt][currencyId][\nclaimedAccrualIndicesByWalletCurrency[msg.sender][currencyCt][currencyId].length - 1\n] + 1\n);\n\n\nif (0 == claimBlockNumberBatchSize) {\n\n_updateClaimedAccruals(msg.sender, currencyCt, currencyId, accrualIndex);\n\n\nclaimAndTransferToBeneficiaryByAccruals(\nbeneficiary, destWallet, balanceType, currencyCt, currencyId,\naccrualIndex, accrualIndex, standard\n);\n}\n\n\nelse {\n\nAccrual storage accrual = closedAccrualsByCurrency[currencyCt][currencyId][accrualIndex];\n\n\nuint256 startBlock = (\n0 == maxClaimedBlockNumberByWalletCurrencyAccrual[msg.sender][currencyCt][currencyId][accrualIndex] ?\naccrual.startBlock :\nmaxClaimedBlockNumberByWalletCurrencyAccrual[msg.sender][currencyCt][currencyId][accrualIndex] + 1\n).clampMax(accrual.endBlock);\nuint256 endBlock = (startBlock + claimBlockNumberBatchSize - 1).clampMax(accrual.endBlock);\n\n\nif (endBlock == accrual.endBlock)\n_updateClaimedAccruals(msg.sender, currencyCt, currencyId, accrualIndex);\n\n\nmaxClaimedBlockNumberByWalletCurrencyAccrual[msg.sender][currencyCt][currencyId][accrualIndex] = endBlock;\n\n\nclaimAndTransferToBeneficiaryByBlockNumbers(\nbeneficiary, destWallet, balanceType, currencyCt, currencyId,\nstartBlock, endBlock, standard\n);\n}\n}","after":"function claimAndTransferToBeneficiary(Beneficiary beneficiary, address destWallet, string calldata balanceType,\naddress currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\n\n\nuint256 accrualIndex = (\n0 == claimedAccrualIndicesByWalletCurrency[msg.sender][currencyCt][currencyId].length ?\n0 :\nclaimedAccrualIndicesByWalletCurrency[msg.sender][currencyCt][currencyId][\nclaimedAccrualIndicesByWalletCurrency[msg.sender][currencyCt][currencyId].length - 1\n] + 1\n);\n\n\nif (0 == claimBlockNumberBatchSize) {\n\n_updateClaimedAccruals(msg.sender, currencyCt, currencyId, accrualIndex);\n\n\nclaimAndTransferToBeneficiaryByAccruals(\nbeneficiary, destWallet, balanceType, currencyCt, currencyId,\naccrualIndex, accrualIndex, standard\n);\n}\n\n\nelse {\n\nAccrual storage accrual = closedAccrualsByCurrency[currencyCt][currencyId][accrualIndex];\n\n\nuint256 startBlock = (\n0 == maxClaimedBlockNumberByWalletCurrencyAccrual[msg.sender][currencyCt][currencyId][accrualIndex] ?\naccrual.startBlock :\nmaxClaimedBlockNumberByWalletCurrencyAccrual[msg.sender][currencyCt][currencyId][accrualIndex] + 1\n).clampMax(accrual.endBlock);\nuint256 endBlock = (startBlock + claimBlockNumberBatchSize - 1).clampMax(accrual.endBlock);\n\n\nif (endBlock == accrual.endBlock)\n_updateClaimedAccruals(msg.sender, currencyCt, currencyId, accrualIndex);\n\n\nmaxClaimedBlockNumberByWalletCurrencyAccrual[msg.sender][currencyCt][currencyId][accrualIndex] = endBlock;\n\n\nclaimAndTransferToBeneficiaryByBlockNumbers(\nbeneficiary, destWallet, balanceType, currencyCt, currencyId,\nstartBlock, endBlock, standard\n);\n}\n}","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\n\nrequire(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [TokenHolderRevenueFund.sol:823]\");\n\n\namount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n\nstagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Dispatch by controller failed [TokenHolderRevenueFund.sol:842]\");\n}\n\n\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n}","after":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\n\nrequire(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [TokenHolderRevenueFund.sol:823]\");\n\n\namount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n\nstagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Dispatch by controller failed [TokenHolderRevenueFund.sol:842]\");\n}\n\n\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n}","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"TokenHolderRevenueFund","time":0}]}