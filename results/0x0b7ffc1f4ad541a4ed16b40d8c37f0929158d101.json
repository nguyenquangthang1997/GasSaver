{"time":227,"results":[{"type":"external-function ","before":"function depositAndPlaceOrder(\n        uint256 auctionId,\n        uint96[] memory _minBuyAmounts,\n        bytes32[] memory _prevSellOrders,\n        bytes calldata allowListCallData\n    ) external payable returns (uint64 userId) {\n        uint96[] memory sellAmounts = new uint96[](1);\n        require(msg.value < 2 ** 96, \"too much value sent\");\n        nativeTokenWrapper.deposit{value : msg.value}();\n        sellAmounts[0] = uint96(msg.value);\n        return\n        easyAuction.placeSellOrdersOnBehalf(\n            auctionId,\n            _minBuyAmounts,\n            sellAmounts,\n            _prevSellOrders,\n            allowListCallData,\n            msg.sender\n        );\n    }","after":"function depositAndPlaceOrder(\n        uint256 auctionId,\n        uint96[] calldata _minBuyAmounts,\n        bytes32[] calldata _prevSellOrders,\n        bytes calldata allowListCallData\n    ) external payable returns (uint64 userId) {\n        uint96[] memory sellAmounts = new uint96[](1);\n        require(msg.value < 2 ** 96, \"too much value sent\");\n        nativeTokenWrapper.deposit{value : msg.value}();\n        sellAmounts[0] = uint96(msg.value);\n        return\n        easyAuction.placeSellOrdersOnBehalf(\n            auctionId,\n            _minBuyAmounts,\n            sellAmounts,\n            _prevSellOrders,\n            allowListCallData,\n            msg.sender\n        );\n    }","contract":"DepositAndPlaceOrder","time":0},{"type":"loop-duplication","before":"\nstart line 921 column 8, end line 928 column 8\nfor (uint256 i = 0; i < orders.length; i++) {\n            // Note: we don't need to keep any information about the node since\n            // no new elements need to be inserted.\n            require(\n                sellOrders[auctionId].remove(orders[i]),\n                \"order is no longer claimable\"\n            );\n        }\nstart line 935 column 8, end line 973 column 8\nfor (uint256 i = 0; i < orders.length; i++) {\n            (uint64 userIdOrder, uint96 buyAmount, uint96 sellAmount) =\n            orders[i].decodeOrder();\n            require(\n                userIdOrder == userId,\n                \"only allowed to claim for same user\"\n            );\n            if (minFundingThresholdNotReached) {\n                //[10]\n                sumBiddingTokenAmount = sumBiddingTokenAmount.add(sellAmount);\n            } else {\n                //[23]\n                if (orders[i] == auction.clearingPriceOrder) {\n                    //[25]\n                    sumAuctioningTokenAmount = sumAuctioningTokenAmount.add(\n                        auction\n                        .volumeClearingPriceOrder\n                        .mul(priceNumerator)\n                        .div(priceDenominator)\n                    );\n                    sumBiddingTokenAmount = sumBiddingTokenAmount.add(\n                        sellAmount.sub(auction.volumeClearingPriceOrder)\n                    );\n                } else {\n                    if (orders[i].smallerThan(auction.clearingPriceOrder)) {\n                        //[17]\n                        sumAuctioningTokenAmount = sumAuctioningTokenAmount.add(\n                            sellAmount.mul(priceNumerator).div(priceDenominator)\n                        );\n                    } else {\n                        //[24]\n                        sumBiddingTokenAmount = sumBiddingTokenAmount.add(\n                            sellAmount\n                        );\n                    }\n                }\n            }\n            emit ClaimedFromOrder(auctionId, userId, buyAmount, sellAmount);\n        }","after":"// merge loop\n\nstart line 921 column 8, end line 928 column 8\nfor (uint256 i = 0; i < orders.length; i++) {\n            // Note: we don't need to keep any information about the node since\n            // no new elements need to be inserted.\n            require(\n                sellOrders[auctionId].remove(orders[i]),\n                \"order is no longer claimable\"\n            );\n        }\nstart line 935 column 8, end line 973 column 8\nfor (uint256 i = 0; i < orders.length; i++) {\n            (uint64 userIdOrder, uint96 buyAmount, uint96 sellAmount) =\n            orders[i].decodeOrder();\n            require(\n                userIdOrder == userId,\n                \"only allowed to claim for same user\"\n            );\n            if (minFundingThresholdNotReached) {\n                //[10]\n                sumBiddingTokenAmount = sumBiddingTokenAmount.add(sellAmount);\n            } else {\n                //[23]\n                if (orders[i] == auction.clearingPriceOrder) {\n                    //[25]\n                    sumAuctioningTokenAmount = sumAuctioningTokenAmount.add(\n                        auction\n                        .volumeClearingPriceOrder\n                        .mul(priceNumerator)\n                        .div(priceDenominator)\n                    );\n                    sumBiddingTokenAmount = sumBiddingTokenAmount.add(\n                        sellAmount.sub(auction.volumeClearingPriceOrder)\n                    );\n                } else {\n                    if (orders[i].smallerThan(auction.clearingPriceOrder)) {\n                        //[17]\n                        sumAuctioningTokenAmount = sumAuctioningTokenAmount.add(\n                            sellAmount.mul(priceNumerator).div(priceDenominator)\n                        );\n                    } else {\n                        //[24]\n                        sumBiddingTokenAmount = sumBiddingTokenAmount.add(\n                            sellAmount\n                        );\n                    }\n                }\n            }\n            emit ClaimedFromOrder(auctionId, userId, buyAmount, sellAmount);\n        }","contract":"EasyAuction","time":0},{"type":"state-data-arrangement ","before":"\nmapping(uint256 => IterableOrderedOrderSet.Data) internal sellOrders;\nmapping(uint256 => AuctionData) public auctionData;\nmapping(uint256 => address) public auctionAccessManager;\nmapping(uint256 => bytes) public auctionAccessData;\nIdToAddressBiMap.Data private registeredUsers;\nuint64 public numUsers;\nuint256 public auctionCounter;\nuint256 public feeNumerator = 0;\nuint256 public constant FEE_DENOMINATOR = 1000;\nuint64 public feeReceiverUserId = 1;","after":"mapping(uint256 => IterableOrderedOrderSet.Data) internal sellOrders;\nmapping(uint256 => AuctionData) public auctionData;\nmapping(uint256 => address) public auctionAccessManager;\nmapping(uint256 => bytes) public auctionAccessData;\nIdToAddressBiMap.Data private registeredUsers;\nuint256 public auctionCounter;\nuint256 public feeNumerator = 0;\nuint256 public constant FEE_DENOMINATOR = 1000;\nuint64 public numUsers;\nuint64 public feeReceiverUserId = 1;\n","contract":"EasyAuction","time":0},{"type":"external-function ","before":"function initiateAuction(\n        IERC20 _auctioningToken,\n        IERC20 _biddingToken,\n        uint256 orderCancellationEndDate,\n        uint256 auctionEndDate,\n        uint96 _auctionedSellAmount,\n        uint96 _minBuyAmount,\n        uint256 minimumBiddingAmountPerOrder,\n        uint256 minFundingThreshold,\n        bool isAtomicClosureAllowed,\n        address accessManagerContract,\n        bytes memory accessManagerContractData\n    ) public returns (uint256) {\n        // withdraws sellAmount + fees\n        _auctioningToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _auctionedSellAmount.mul(FEE_DENOMINATOR.add(feeNumerator)).div(\n                FEE_DENOMINATOR\n            ) //[0]\n        );\n        require(_auctionedSellAmount > 0, \"cannot auction zero tokens\");\n        require(_minBuyAmount > 0, \"tokens cannot be auctioned for free\");\n        require(\n            minimumBiddingAmountPerOrder > 0,\n            \"minimumBiddingAmountPerOrder is not allowed to be zero\"\n        );\n        require(\n            orderCancellationEndDate <= auctionEndDate,\n            \"time periods are not configured correctly\"\n        );\n        require(\n            auctionEndDate > block.timestamp,\n            \"auction end date must be in the future\"\n        );\n        auctionCounter = auctionCounter.add(1);\n        sellOrders[auctionCounter].initializeEmptyList();\n        uint64 userId = getUserId(msg.sender);\n        auctionData[auctionCounter] = AuctionData(\n            _auctioningToken,\n            _biddingToken,\n            orderCancellationEndDate,\n            auctionEndDate,\n            IterableOrderedOrderSet.encodeOrder(\n                userId,\n                _minBuyAmount,\n                _auctionedSellAmount\n            ),\n            minimumBiddingAmountPerOrder,\n            0,\n            IterableOrderedOrderSet.QUEUE_START,\n            bytes32(0),\n            0,\n            false,\n            isAtomicClosureAllowed,\n            feeNumerator,\n            minFundingThreshold\n        );\n        auctionAccessManager[auctionCounter] = accessManagerContract;\n        auctionAccessData[auctionCounter] = accessManagerContractData;\n        emit NewAuction(\n            auctionCounter,\n            _auctioningToken,\n            _biddingToken,\n            orderCancellationEndDate,\n            auctionEndDate,\n            userId,\n            _auctionedSellAmount,\n            _minBuyAmount,\n            minimumBiddingAmountPerOrder,\n            minFundingThreshold,\n            accessManagerContract,\n            accessManagerContractData\n        );\n        return auctionCounter;\n    }","after":"function initiateAuction(\n        IERC20 _auctioningToken,\n        IERC20 _biddingToken,\n        uint256 orderCancellationEndDate,\n        uint256 auctionEndDate,\n        uint96 _auctionedSellAmount,\n        uint96 _minBuyAmount,\n        uint256 minimumBiddingAmountPerOrder,\n        uint256 minFundingThreshold,\n        bool isAtomicClosureAllowed,\n        address accessManagerContract,\n        bytes calldata accessManagerContractData\n    ) public returns (uint256) {\n        // withdraws sellAmount + fees\n        _auctioningToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            _auctionedSellAmount.mul(FEE_DENOMINATOR.add(feeNumerator)).div(\n                FEE_DENOMINATOR\n            ) //[0]\n        );\n        require(_auctionedSellAmount > 0, \"cannot auction zero tokens\");\n        require(_minBuyAmount > 0, \"tokens cannot be auctioned for free\");\n        require(\n            minimumBiddingAmountPerOrder > 0,\n            \"minimumBiddingAmountPerOrder is not allowed to be zero\"\n        );\n        require(\n            orderCancellationEndDate <= auctionEndDate,\n            \"time periods are not configured correctly\"\n        );\n        require(\n            auctionEndDate > block.timestamp,\n            \"auction end date must be in the future\"\n        );\n        auctionCounter = auctionCounter.add(1);\n        sellOrders[auctionCounter].initializeEmptyList();\n        uint64 userId = getUserId(msg.sender);\n        auctionData[auctionCounter] = AuctionData(\n            _auctioningToken,\n            _biddingToken,\n            orderCancellationEndDate,\n            auctionEndDate,\n            IterableOrderedOrderSet.encodeOrder(\n                userId,\n                _minBuyAmount,\n                _auctionedSellAmount\n            ),\n            minimumBiddingAmountPerOrder,\n            0,\n            IterableOrderedOrderSet.QUEUE_START,\n            bytes32(0),\n            0,\n            false,\n            isAtomicClosureAllowed,\n            feeNumerator,\n            minFundingThreshold\n        );\n        auctionAccessManager[auctionCounter] = accessManagerContract;\n        auctionAccessData[auctionCounter] = accessManagerContractData;\n        emit NewAuction(\n            auctionCounter,\n            _auctioningToken,\n            _biddingToken,\n            orderCancellationEndDate,\n            auctionEndDate,\n            userId,\n            _auctionedSellAmount,\n            _minBuyAmount,\n            minimumBiddingAmountPerOrder,\n            minFundingThreshold,\n            accessManagerContract,\n            accessManagerContractData\n        );\n        return auctionCounter;\n    }","contract":"EasyAuction","time":0},{"type":"external-function ","before":"function placeSellOrders(\n        uint256 auctionId,\n        uint96[] memory _minBuyAmounts,\n        uint96[] memory _sellAmounts,\n        bytes32[] memory _prevSellOrders,\n        bytes calldata allowListCallData\n    ) external atStageOrderPlacement(auctionId) returns (uint64 userId) {\n        return\n        _placeSellOrders(\n            auctionId,\n            _minBuyAmounts,\n            _sellAmounts,\n            _prevSellOrders,\n            allowListCallData,\n            msg.sender\n        );\n    }","after":"function placeSellOrders(\n        uint256 auctionId,\n        uint96[] calldata _minBuyAmounts,\n        uint96[] calldata _sellAmounts,\n        bytes32[] calldata _prevSellOrders,\n        bytes calldata allowListCallData\n    ) external atStageOrderPlacement(auctionId) returns (uint64 userId) {\n        return\n        _placeSellOrders(\n            auctionId,\n            _minBuyAmounts,\n            _sellAmounts,\n            _prevSellOrders,\n            allowListCallData,\n            msg.sender\n        );\n    }","contract":"EasyAuction","time":0},{"type":"external-function ","before":"function placeSellOrdersOnBehalf(\n        uint256 auctionId,\n        uint96[] memory _minBuyAmounts,\n        uint96[] memory _sellAmounts,\n        bytes32[] memory _prevSellOrders,\n        bytes calldata allowListCallData,\n        address orderSubmitter\n    ) external atStageOrderPlacement(auctionId) returns (uint64 userId) {\n        return\n        _placeSellOrders(\n            auctionId,\n            _minBuyAmounts,\n            _sellAmounts,\n            _prevSellOrders,\n            allowListCallData,\n            orderSubmitter\n        );\n    }","after":"function placeSellOrdersOnBehalf(\n        uint256 auctionId,\n        uint96[] calldata _minBuyAmounts,\n        uint96[] calldata _sellAmounts,\n        bytes32[] calldata _prevSellOrders,\n        bytes calldata allowListCallData,\n        address orderSubmitter\n    ) external atStageOrderPlacement(auctionId) returns (uint64 userId) {\n        return\n        _placeSellOrders(\n            auctionId,\n            _minBuyAmounts,\n            _sellAmounts,\n            _prevSellOrders,\n            allowListCallData,\n            orderSubmitter\n        );\n    }","contract":"EasyAuction","time":0},{"type":"external-function ","before":"function cancelSellOrders(uint256 auctionId, bytes32[] memory _sellOrders)\n    public\n    atStageOrderPlacementAndCancelation(auctionId)\n    {\n        uint64 userId = getUserId(msg.sender);\n        uint256 claimableAmount = 0;\n        for (uint256 i = 0; i < _sellOrders.length; i++) {\n            // Note: we keep the back pointer of the deleted element so that\n            // it can be used as a reference point to insert a new node.\n            bool success =\n            sellOrders[auctionId].removeKeepHistory(_sellOrders[i]);\n            if (success) {\n                (\n                uint64 userIdOfIter,\n                uint96 buyAmountOfIter,\n                uint96 sellAmountOfIter\n                ) = _sellOrders[i].decodeOrder();\n                require(\n                    userIdOfIter == userId,\n                    \"Only the user can cancel his orders\"\n                );\n                claimableAmount = claimableAmount.add(sellAmountOfIter);\n                emit CancellationSellOrder(\n                    auctionId,\n                    userId,\n                    buyAmountOfIter,\n                    sellAmountOfIter\n                );\n            }\n        }\n        auctionData[auctionId].biddingToken.safeTransfer(\n            msg.sender,\n            claimableAmount\n        );\n        //[2]\n    }","after":"function cancelSellOrders(uint256 auctionId, bytes32[] calldata _sellOrders)\n    public\n    atStageOrderPlacementAndCancelation(auctionId)\n    {\n        uint64 userId = getUserId(msg.sender);\n        uint256 claimableAmount = 0;\n        for (uint256 i = 0; i < _sellOrders.length; i++) {\n            // Note: we keep the back pointer of the deleted element so that\n            // it can be used as a reference point to insert a new node.\n            bool success =\n            sellOrders[auctionId].removeKeepHistory(_sellOrders[i]);\n            if (success) {\n                (\n                uint64 userIdOfIter,\n                uint96 buyAmountOfIter,\n                uint96 sellAmountOfIter\n                ) = _sellOrders[i].decodeOrder();\n                require(\n                    userIdOfIter == userId,\n                    \"Only the user can cancel his orders\"\n                );\n                claimableAmount = claimableAmount.add(sellAmountOfIter);\n                emit CancellationSellOrder(\n                    auctionId,\n                    userId,\n                    buyAmountOfIter,\n                    sellAmountOfIter\n                );\n            }\n        }\n        auctionData[auctionId].biddingToken.safeTransfer(\n            msg.sender,\n            claimableAmount\n        );\n        //[2]\n    }","contract":"EasyAuction","time":0},{"type":"external-function ","before":"function settleAuctionAtomically(\n        uint256 auctionId,\n        uint96[] memory _minBuyAmount,\n        uint96[] memory _sellAmount,\n        bytes32[] memory _prevSellOrder,\n        bytes calldata allowListCallData\n    ) public atStageSolutionSubmission(auctionId) {\n        require(\n            auctionData[auctionId].isAtomicClosureAllowed,\n            \"not allowed to settle auction atomically\"\n        );\n        require(\n            _minBuyAmount.length == 1 && _sellAmount.length == 1,\n            \"Only one order can be placed atomically\"\n        );\n        uint64 userId = getUserId(msg.sender);\n        require(\n            auctionData[auctionId].interimOrder.smallerThan(\n                IterableOrderedOrderSet.encodeOrder(\n                    userId,\n                    _minBuyAmount[0],\n                    _sellAmount[0]\n                )\n            ),\n            \"precalculateSellAmountSum is already too advanced\"\n        );\n        _placeSellOrders(\n            auctionId,\n            _minBuyAmount,\n            _sellAmount,\n            _prevSellOrder,\n            allowListCallData,\n            msg.sender\n        );\n        settleAuction(auctionId);\n    }","after":"function settleAuctionAtomically(\n        uint256 auctionId,\n        uint96[] calldata _minBuyAmount,\n        uint96[] calldata _sellAmount,\n        bytes32[] calldata _prevSellOrder,\n        bytes calldata allowListCallData\n    ) public atStageSolutionSubmission(auctionId) {\n        require(\n            auctionData[auctionId].isAtomicClosureAllowed,\n            \"not allowed to settle auction atomically\"\n        );\n        require(\n            _minBuyAmount.length == 1 && _sellAmount.length == 1,\n            \"Only one order can be placed atomically\"\n        );\n        uint64 userId = getUserId(msg.sender);\n        require(\n            auctionData[auctionId].interimOrder.smallerThan(\n                IterableOrderedOrderSet.encodeOrder(\n                    userId,\n                    _minBuyAmount[0],\n                    _sellAmount[0]\n                )\n            ),\n            \"precalculateSellAmountSum is already too advanced\"\n        );\n        _placeSellOrders(\n            auctionId,\n            _minBuyAmount,\n            _sellAmount,\n            _prevSellOrder,\n            allowListCallData,\n            msg.sender\n        );\n        settleAuction(auctionId);\n    }","contract":"EasyAuction","time":0},{"type":"external-function ","before":"function claimFromParticipantOrder(\n        uint256 auctionId,\n        bytes32[] memory orders\n    )\n    public\n    atStageFinished(auctionId)\n    returns (\n        uint256 sumAuctioningTokenAmount,\n        uint256 sumBiddingTokenAmount\n    )\n    {\n        for (uint256 i = 0; i < orders.length; i++) {\n            // Note: we don't need to keep any information about the node since\n            // no new elements need to be inserted.\n            require(\n                sellOrders[auctionId].remove(orders[i]),\n                \"order is no longer claimable\"\n            );\n        }\n        AuctionData memory auction = auctionData[auctionId];\n        (, uint96 priceNumerator, uint96 priceDenominator) =\n        auction.clearingPriceOrder.decodeOrder();\n        (uint64 userId, ,) = orders[0].decodeOrder();\n        bool minFundingThresholdNotReached =\n        auctionData[auctionId].minFundingThresholdNotReached;\n        for (uint256 i = 0; i < orders.length; i++) {\n            (uint64 userIdOrder, uint96 buyAmount, uint96 sellAmount) =\n            orders[i].decodeOrder();\n            require(\n                userIdOrder == userId,\n                \"only allowed to claim for same user\"\n            );\n            if (minFundingThresholdNotReached) {\n                //[10]\n                sumBiddingTokenAmount = sumBiddingTokenAmount.add(sellAmount);\n            } else {\n                //[23]\n                if (orders[i] == auction.clearingPriceOrder) {\n                    //[25]\n                    sumAuctioningTokenAmount = sumAuctioningTokenAmount.add(\n                        auction\n                        .volumeClearingPriceOrder\n                        .mul(priceNumerator)\n                        .div(priceDenominator)\n                    );\n                    sumBiddingTokenAmount = sumBiddingTokenAmount.add(\n                        sellAmount.sub(auction.volumeClearingPriceOrder)\n                    );\n                } else {\n                    if (orders[i].smallerThan(auction.clearingPriceOrder)) {\n                        //[17]\n                        sumAuctioningTokenAmount = sumAuctioningTokenAmount.add(\n                            sellAmount.mul(priceNumerator).div(priceDenominator)\n                        );\n                    } else {\n                        //[24]\n                        sumBiddingTokenAmount = sumBiddingTokenAmount.add(\n                            sellAmount\n                        );\n                    }\n                }\n            }\n            emit ClaimedFromOrder(auctionId, userId, buyAmount, sellAmount);\n        }\n        sendOutTokens(\n            auctionId,\n            sumAuctioningTokenAmount,\n            sumBiddingTokenAmount,\n            userId\n        );\n        //[3]\n    }","after":"function claimFromParticipantOrder(\n        uint256 auctionId,\n        bytes32[] calldata orders\n    )\n    public\n    atStageFinished(auctionId)\n    returns (\n        uint256 sumAuctioningTokenAmount,\n        uint256 sumBiddingTokenAmount\n    )\n    {\n        for (uint256 i = 0; i < orders.length; i++) {\n            // Note: we don't need to keep any information about the node since\n            // no new elements need to be inserted.\n            require(\n                sellOrders[auctionId].remove(orders[i]),\n                \"order is no longer claimable\"\n            );\n        }\n        AuctionData memory auction = auctionData[auctionId];\n        (, uint96 priceNumerator, uint96 priceDenominator) =\n        auction.clearingPriceOrder.decodeOrder();\n        (uint64 userId, ,) = orders[0].decodeOrder();\n        bool minFundingThresholdNotReached =\n        auctionData[auctionId].minFundingThresholdNotReached;\n        for (uint256 i = 0; i < orders.length; i++) {\n            (uint64 userIdOrder, uint96 buyAmount, uint96 sellAmount) =\n            orders[i].decodeOrder();\n            require(\n                userIdOrder == userId,\n                \"only allowed to claim for same user\"\n            );\n            if (minFundingThresholdNotReached) {\n                //[10]\n                sumBiddingTokenAmount = sumBiddingTokenAmount.add(sellAmount);\n            } else {\n                //[23]\n                if (orders[i] == auction.clearingPriceOrder) {\n                    //[25]\n                    sumAuctioningTokenAmount = sumAuctioningTokenAmount.add(\n                        auction\n                        .volumeClearingPriceOrder\n                        .mul(priceNumerator)\n                        .div(priceDenominator)\n                    );\n                    sumBiddingTokenAmount = sumBiddingTokenAmount.add(\n                        sellAmount.sub(auction.volumeClearingPriceOrder)\n                    );\n                } else {\n                    if (orders[i].smallerThan(auction.clearingPriceOrder)) {\n                        //[17]\n                        sumAuctioningTokenAmount = sumAuctioningTokenAmount.add(\n                            sellAmount.mul(priceNumerator).div(priceDenominator)\n                        );\n                    } else {\n                        //[24]\n                        sumBiddingTokenAmount = sumBiddingTokenAmount.add(\n                            sellAmount\n                        );\n                    }\n                }\n            }\n            emit ClaimedFromOrder(auctionId, userId, buyAmount, sellAmount);\n        }\n        sendOutTokens(\n            auctionId,\n            sumAuctioningTokenAmount,\n            sumBiddingTokenAmount,\n            userId\n        );\n        //[3]\n    }","contract":"EasyAuction","time":0}]}