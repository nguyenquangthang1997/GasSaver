{"time":370,"results":[{"type":"de-morgan-condition ","before":"!reserves[_token].isSet || !isActive()","after":"!(reserves[_token].isSet || isActive())","loc":{"start":{"line":1689,"column":16},"end":{"line":1689,"column":53}},"contract":"ConverterBase","time":0},{"type":"state-data-arrangement ","before":"\nuint32 internal constant PPM_RESOLUTION = 1000000;\nIERC20Token internal constant ETH_RESERVE_ADDRESS = IERC20Token(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\nuint16 public constant version = 39;\nIConverterAnchor public override anchor;\nIWhitelist public override conversionWhitelist;\nIERC20Token[] public reserveTokens;\nmapping(IERC20Token => Reserve) public reserves;\nuint32 public reserveRatio = 0;\nuint32 public override maxConversionFee = 0;\nuint32 public override conversionFee = 0;\nbool public constant conversionsEnabled = true;","after":"IERC20Token internal constant ETH_RESERVE_ADDRESS = IERC20Token(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\nIConverterAnchor public override anchor;\nIWhitelist public override conversionWhitelist;\nIERC20Token[] public reserveTokens;\nmapping(IERC20Token => Reserve) public reserves;\nuint32 internal constant PPM_RESOLUTION = 1000000;\nuint32 public reserveRatio = 0;\nuint32 public override maxConversionFee = 0;\nuint32 public override conversionFee = 0;\nuint16 public constant version = 39;\nbool public constant conversionsEnabled = true;\n","contract":"ConverterBase","time":0},{"type":"external-function ","before":"function addLiquidity(IERC20Token[] memory _reserveTokens, uint256[] memory _reserveAmounts, uint256 _minReturn)\n\n    public\n\n    payable\n\n    protected\n\n    active\n\n    returns (uint256)\n\n    {\n\n        // verify the user input\n\n        verifyLiquidityInput(_reserveTokens, _reserveAmounts, _minReturn);\n\n\n        // if one of the reserves is ETH, then verify that the input amount of ETH is equal to the input value of ETH\n\n        for (uint256 i = 0; i < _reserveTokens.length; i++)\n\n            if (_reserveTokens[i] == ETH_RESERVE_ADDRESS)\n\n                require(_reserveAmounts[i] == msg.value, \"ERR_ETH_AMOUNT_MISMATCH\");\n\n\n        // if the input value of ETH is larger than zero, then verify that one of the reserves is ETH\n\n        if (msg.value > 0) {\n\n            require(reserves[ETH_RESERVE_ADDRESS].isSet, \"ERR_NO_ETH_RESERVE\");\n\n        }\n\n\n        // get the total supply\n\n        uint256 totalSupply = ISmartToken(address(anchor)).totalSupply();\n\n\n        // transfer from the user an equally-worth amount of each one of the reserve tokens\n\n        uint256 amount = addLiquidityToPool(_reserveTokens, _reserveAmounts, totalSupply);\n\n\n        // verify that the equivalent amount of tokens is equal to or larger than the user's expectation\n\n        require(amount >= _minReturn, \"ERR_RETURN_TOO_LOW\");\n\n\n        // issue the tokens to the user\n\n        ISmartToken(address(anchor)).issue(msg.sender, amount);\n\n\n        // return the amount of pool tokens issued\n\n        return amount;\n\n    }","after":"function addLiquidity(IERC20Token[] calldata _reserveTokens, uint256[] calldata _reserveAmounts, uint256 _minReturn)\n\n    public\n\n    payable\n\n    protected\n\n    active\n\n    returns (uint256)\n\n    {\n\n        // verify the user input\n\n        verifyLiquidityInput(_reserveTokens, _reserveAmounts, _minReturn);\n\n\n        // if one of the reserves is ETH, then verify that the input amount of ETH is equal to the input value of ETH\n\n        for (uint256 i = 0; i < _reserveTokens.length; i++)\n\n            if (_reserveTokens[i] == ETH_RESERVE_ADDRESS)\n\n                require(_reserveAmounts[i] == msg.value, \"ERR_ETH_AMOUNT_MISMATCH\");\n\n\n        // if the input value of ETH is larger than zero, then verify that one of the reserves is ETH\n\n        if (msg.value > 0) {\n\n            require(reserves[ETH_RESERVE_ADDRESS].isSet, \"ERR_NO_ETH_RESERVE\");\n\n        }\n\n\n        // get the total supply\n\n        uint256 totalSupply = ISmartToken(address(anchor)).totalSupply();\n\n\n        // transfer from the user an equally-worth amount of each one of the reserve tokens\n\n        uint256 amount = addLiquidityToPool(_reserveTokens, _reserveAmounts, totalSupply);\n\n\n        // verify that the equivalent amount of tokens is equal to or larger than the user's expectation\n\n        require(amount >= _minReturn, \"ERR_RETURN_TOO_LOW\");\n\n\n        // issue the tokens to the user\n\n        ISmartToken(address(anchor)).issue(msg.sender, amount);\n\n\n        // return the amount of pool tokens issued\n\n        return amount;\n\n    }","contract":"LiquidityPoolV1Converter","time":0},{"type":"external-function ","before":"function removeLiquidity(uint256 _amount, IERC20Token[] memory _reserveTokens, uint256[] memory _reserveMinReturnAmounts)\n\n    public\n\n    protected\n\n    active\n\n    returns (uint256[] memory)\n\n    {\n\n        // verify the user input\n\n        verifyLiquidityInput(_reserveTokens, _reserveMinReturnAmounts, _amount);\n\n\n        // get the total supply BEFORE destroying the user tokens\n\n        uint256 totalSupply = ISmartToken(address(anchor)).totalSupply();\n\n\n        // destroy the user tokens\n\n        ISmartToken(address(anchor)).destroy(msg.sender, _amount);\n\n\n        // transfer to the user an equivalent amount of each one of the reserve tokens\n\n        return removeLiquidityFromPool(_reserveTokens, _reserveMinReturnAmounts, totalSupply, _amount);\n\n    }","after":"function removeLiquidity(uint256 _amount, IERC20Token[] calldata _reserveTokens, uint256[] calldata _reserveMinReturnAmounts)\n\n    public\n\n    protected\n\n    active\n\n    returns (uint256[] memory)\n\n    {\n\n        // verify the user input\n\n        verifyLiquidityInput(_reserveTokens, _reserveMinReturnAmounts, _amount);\n\n\n        // get the total supply BEFORE destroying the user tokens\n\n        uint256 totalSupply = ISmartToken(address(anchor)).totalSupply();\n\n\n        // destroy the user tokens\n\n        ISmartToken(address(anchor)).destroy(msg.sender, _amount);\n\n\n        // transfer to the user an equivalent amount of each one of the reserve tokens\n\n        return removeLiquidityFromPool(_reserveTokens, _reserveMinReturnAmounts, totalSupply, _amount);\n\n    }","contract":"LiquidityPoolV1Converter","time":0},{"type":"external-function ","before":"function addLiquidityCost(IERC20Token[] memory _reserveTokens, uint256 _reserveTokenIndex, uint256 _reserveAmount)\n\n    public\n\n    view\n\n    returns (uint256[] memory)\n\n    {\n\n        uint256[] memory reserveAmounts = new uint256[](_reserveTokens.length);\n\n\n        uint256 totalSupply = ISmartToken(address(anchor)).totalSupply();\n\n        IBancorFormula formula = IBancorFormula(addressOf(BANCOR_FORMULA));\n\n        uint256 amount = formula.fundSupplyAmount(totalSupply, reserves[_reserveTokens[_reserveTokenIndex]].balance, reserveRatio, _reserveAmount);\n\n\n        for (uint256 i = 0; i < reserveAmounts.length; i++)\n\n            reserveAmounts[i] = formula.fundCost(totalSupply, reserves[_reserveTokens[i]].balance, reserveRatio, amount);\n\n\n        return reserveAmounts;\n\n    }","after":"function addLiquidityCost(IERC20Token[] calldata _reserveTokens, uint256 _reserveTokenIndex, uint256 _reserveAmount)\n\n    public\n\n    view\n\n    returns (uint256[] memory)\n\n    {\n\n        uint256[] memory reserveAmounts = new uint256[](_reserveTokens.length);\n\n\n        uint256 totalSupply = ISmartToken(address(anchor)).totalSupply();\n\n        IBancorFormula formula = IBancorFormula(addressOf(BANCOR_FORMULA));\n\n        uint256 amount = formula.fundSupplyAmount(totalSupply, reserves[_reserveTokens[_reserveTokenIndex]].balance, reserveRatio, _reserveAmount);\n\n\n        for (uint256 i = 0; i < reserveAmounts.length; i++)\n\n            reserveAmounts[i] = formula.fundCost(totalSupply, reserves[_reserveTokens[i]].balance, reserveRatio, amount);\n\n\n        return reserveAmounts;\n\n    }","contract":"LiquidityPoolV1Converter","time":0},{"type":"external-function ","before":"function removeLiquidityReturn(uint256 _amount, IERC20Token[] memory _reserveTokens)\n\n    public\n\n    view\n\n    returns (uint256[] memory)\n\n    {\n\n        uint256 totalSupply = ISmartToken(address(anchor)).totalSupply();\n\n        IBancorFormula formula = IBancorFormula(addressOf(BANCOR_FORMULA));\n\n        return removeLiquidityReserveAmounts(_amount, _reserveTokens, totalSupply, formula);\n\n    }","after":"function removeLiquidityReturn(uint256 _amount, IERC20Token[] calldata _reserveTokens)\n\n    public\n\n    view\n\n    returns (uint256[] memory)\n\n    {\n\n        uint256 totalSupply = ISmartToken(address(anchor)).totalSupply();\n\n        IBancorFormula formula = IBancorFormula(addressOf(BANCOR_FORMULA));\n\n        return removeLiquidityReserveAmounts(_amount, _reserveTokens, totalSupply, formula);\n\n    }","contract":"LiquidityPoolV1Converter","time":0},{"type":"immutable-restrict-modification ","before":"uint32 public override maxConversionFee = 0;","after":"uint32 public override immutable maxConversionFee = 0;","contract":"LiquidityPoolV1Converter","time":2}]}