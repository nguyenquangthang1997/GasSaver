{"time":181,"results":[{"type":"external-function ","before":"function setBaseMetadataURI(string memory newBaseMetadataURI) public onlyOwner() {\n        baseMetadataURI = newBaseMetadataURI;\n    }","after":"function setBaseMetadataURI(string calldata newBaseMetadataURI) public onlyOwner() {\n        baseMetadataURI = newBaseMetadataURI;\n    }","contract":"ERC1155Mintable","time":0},{"type":"de-morgan-condition ","before":"!(char >= 0x30 && char <= 0x39) && //9-0\n            !(char >= 0x41 && char <= 0x5A)","after":"!((char >= 0x30 && char <= 0x39) && //9-0\n            (char >= 0x41 && char <= 0x5A))","loc":{"start":{"line":1451,"column":16},"end":{"line":1452,"column":42}},"contract":"ProofOfCultureMinter","time":0},{"type":"loop-calculation","before":"_HashtagContainer memory container = tokenIdToHashtagContainer[id];","after":"// move outside for loop\n_HashtagContainer memory container = tokenIdToHashtagContainer[id];","loc":{"start":{"line":1545,"column":12},"end":{"line":1545,"column":78}},"contract":"ProofOfCultureMinter","time":0},{"type":"loop-calculation","before":"uint256 index = mintableErc1155.maxIndex(hashtagTokenType) + 1;","after":"// move outside for loop\nuint256 index = mintableErc1155.maxIndex(hashtagTokenType) + 1;","loc":{"start":{"line":1581,"column":12},"end":{"line":1581,"column":74}},"contract":"ProofOfCultureMinter","time":0},{"type":"loop-calculation","before":"uint256 index = mintableErc1155.maxIndex(hashtagTokenType) + 1;","after":"// move outside for loop\nuint256 index = mintableErc1155.maxIndex(hashtagTokenType) + 1;","loc":{"start":{"line":1641,"column":12},"end":{"line":1641,"column":74}},"contract":"ProofOfCultureMinter","time":0},{"type":"state-data-arrangement ","before":"\nuint256 public hashtagTokenType;\nuint256 public batchOrderLimit;\nERC1155Mintable public mintableErc1155;\nuint256 public constant MAX_NFT_SUPPLY = 9999;\naddress payable public treasury;\nstring[] public claimedHashtags;\nmapping(uint256 => _HashtagContainer) public tokenIdToHashtagContainer;\nmapping(string => uint256) public normalizedHashtagToTokenId;\nmapping(string => string) public normalizedHashtagToImageURI;\nmapping(uint256 => string) public tokenIdToImageURI;\nuint256 public constant supporterTokenCap = 15;\nuint256 public currentSupporterTokenCount;\nmapping(uint256 => uint256) public tokenIdToImageChangeCount;\nbool public saleStarted;","after":"uint256 public hashtagTokenType;\nuint256 public batchOrderLimit;\nERC1155Mintable public mintableErc1155;\nuint256 public constant MAX_NFT_SUPPLY = 9999;\nstring[] public claimedHashtags;\nmapping(uint256 => _HashtagContainer) public tokenIdToHashtagContainer;\nmapping(string => uint256) public normalizedHashtagToTokenId;\nmapping(string => string) public normalizedHashtagToImageURI;\nmapping(uint256 => string) public tokenIdToImageURI;\nuint256 public constant supporterTokenCap = 15;\nuint256 public currentSupporterTokenCount;\nmapping(uint256 => uint256) public tokenIdToImageChangeCount;\naddress payable public treasury;\nbool public saleStarted;\n","contract":"ProofOfCultureMinter","time":0},{"type":"external-function ","before":"function mintSignatureTokens(string[] memory _hashtags) external onlyOwner() {\n        require(currentSupporterTokenCount.safeAdd(_hashtags.length) <= supporterTokenCap, \"Exceeds supporterTokenCap\");\n        for (uint i = 0; i < _hashtags.length; i++) {\n            string memory hashtag = _hashtags[i];\n\n            if (!validateHashtag(hashtag)) {\n                continue;\n                // skip if this is not a valid hashtag\n            }\n\n            string memory normalizedHashtag = normalizeHashtag(hashtag);\n            if (normalizedHashtagToTokenId[normalizedHashtag] != 0) {\n                continue;\n                // skip if this hashtag already exists\n            }\n\n            // mint the NFT\n            address[] memory dsts = new address[](1);\n            dsts[0] = msg.sender;\n            uint256 index = mintableErc1155.maxIndex(hashtagTokenType) + 1;\n            uint256 tokenId = hashtagTokenType | index;\n            mintableErc1155.mintNonFungible(hashtagTokenType, dsts);\n\n            // bookkeeping\n            _HashtagContainer memory hc;\n            hc.normalizedHashtag = normalizedHashtag;\n            hc.originalHashtag = hashtag;\n            hc.timestamp = block.timestamp;\n            tokenIdToHashtagContainer[tokenId] = hc;\n            normalizedHashtagToTokenId[normalizedHashtag] = tokenId;\n\n            claimedHashtags.push(hashtag);\n\n            emit UpdatedRegistry(tokenId, hashtag);\n\n            currentSupporterTokenCount += 1;\n        }\n    }","after":"function mintSignatureTokens(string[] calldata _hashtags) external onlyOwner() {\n        require(currentSupporterTokenCount.safeAdd(_hashtags.length) <= supporterTokenCap, \"Exceeds supporterTokenCap\");\n        for (uint i = 0; i < _hashtags.length; i++) {\n            string memory hashtag = _hashtags[i];\n\n            if (!validateHashtag(hashtag)) {\n                continue;\n                // skip if this is not a valid hashtag\n            }\n\n            string memory normalizedHashtag = normalizeHashtag(hashtag);\n            if (normalizedHashtagToTokenId[normalizedHashtag] != 0) {\n                continue;\n                // skip if this hashtag already exists\n            }\n\n            // mint the NFT\n            address[] memory dsts = new address[](1);\n            dsts[0] = msg.sender;\n            uint256 index = mintableErc1155.maxIndex(hashtagTokenType) + 1;\n            uint256 tokenId = hashtagTokenType | index;\n            mintableErc1155.mintNonFungible(hashtagTokenType, dsts);\n\n            // bookkeeping\n            _HashtagContainer memory hc;\n            hc.normalizedHashtag = normalizedHashtag;\n            hc.originalHashtag = hashtag;\n            hc.timestamp = block.timestamp;\n            tokenIdToHashtagContainer[tokenId] = hc;\n            normalizedHashtagToTokenId[normalizedHashtag] = tokenId;\n\n            claimedHashtags.push(hashtag);\n\n            emit UpdatedRegistry(tokenId, hashtag);\n\n            currentSupporterTokenCount += 1;\n        }\n    }","contract":"ProofOfCultureMinter","time":0},{"type":"external-function ","before":"function mint(address _dst, string[] memory _hashtags) public payable {\n        require(saleStarted, \"Sale has not started yet\");\n        require(totalSupply() < MAX_NFT_SUPPLY, \"Sale has already ended\");\n\n        uint numberOfNfts = _hashtags.length;\n        require(numberOfNfts > 0, \"numberOfNfts cannot be 0\");\n        require(numberOfNfts <= batchOrderLimit, \"You may not buy more than the batch limit at once\");\n        require(totalSupply().safeAdd(numberOfNfts) <= MAX_NFT_SUPPLY, \"Exceeds MAX_NFT_SUPPLY\");\n        require(getPrice().safeMul(numberOfNfts) <= msg.value, \"Ether value sent is not correct\");\n\n        // set price upfront before minting - we will need to use this to calculate refunds\n        uint256 pricePerHashtag = getPrice();\n\n        // Keep track of which hashtags we were able to mint\n        uint mintedCount = 0;\n        for (uint i = 0; i < numberOfNfts; i++) {\n            string memory hashtag = _hashtags[i];\n\n            if (!validateHashtag(hashtag)) {\n                continue;\n                // skip if this is not a valid hashtag\n            }\n\n            string memory normalizedHashtag = normalizeHashtag(hashtag);\n            if (normalizedHashtagToTokenId[normalizedHashtag] != 0) {\n                continue;\n                // skip if this hashtag already exists\n            }\n\n            // mint the NFT\n            address[] memory dsts = new address[](1);\n            dsts[0] = _dst;\n            uint256 index = mintableErc1155.maxIndex(hashtagTokenType) + 1;\n            uint256 tokenId = hashtagTokenType | index;\n            mintableErc1155.mintNonFungible(hashtagTokenType, dsts);\n\n            // bookkeeping\n            _HashtagContainer memory hc;\n            hc.normalizedHashtag = normalizedHashtag;\n            hc.originalHashtag = hashtag;\n            hc.timestamp = block.timestamp;\n            tokenIdToHashtagContainer[tokenId] = hc;\n            normalizedHashtagToTokenId[normalizedHashtag] = tokenId;\n            mintedCount++;\n\n            claimedHashtags.push(hashtag);\n\n            emit UpdatedRegistry(tokenId, hashtag);\n        }\n\n        // Only charge for the hashtags that we were able to mint, and refund the rest\n        uint256 actualTotalPrice = pricePerHashtag.safeMul(mintedCount);\n        treasury.transfer(actualTotalPrice);\n        msg.sender.transfer(msg.value - actualTotalPrice);\n    }","after":"function mint(address _dst, string[] calldata _hashtags) public payable {\n        require(saleStarted, \"Sale has not started yet\");\n        require(totalSupply() < MAX_NFT_SUPPLY, \"Sale has already ended\");\n\n        uint numberOfNfts = _hashtags.length;\n        require(numberOfNfts > 0, \"numberOfNfts cannot be 0\");\n        require(numberOfNfts <= batchOrderLimit, \"You may not buy more than the batch limit at once\");\n        require(totalSupply().safeAdd(numberOfNfts) <= MAX_NFT_SUPPLY, \"Exceeds MAX_NFT_SUPPLY\");\n        require(getPrice().safeMul(numberOfNfts) <= msg.value, \"Ether value sent is not correct\");\n\n        // set price upfront before minting - we will need to use this to calculate refunds\n        uint256 pricePerHashtag = getPrice();\n\n        // Keep track of which hashtags we were able to mint\n        uint mintedCount = 0;\n        for (uint i = 0; i < numberOfNfts; i++) {\n            string memory hashtag = _hashtags[i];\n\n            if (!validateHashtag(hashtag)) {\n                continue;\n                // skip if this is not a valid hashtag\n            }\n\n            string memory normalizedHashtag = normalizeHashtag(hashtag);\n            if (normalizedHashtagToTokenId[normalizedHashtag] != 0) {\n                continue;\n                // skip if this hashtag already exists\n            }\n\n            // mint the NFT\n            address[] memory dsts = new address[](1);\n            dsts[0] = _dst;\n            uint256 index = mintableErc1155.maxIndex(hashtagTokenType) + 1;\n            uint256 tokenId = hashtagTokenType | index;\n            mintableErc1155.mintNonFungible(hashtagTokenType, dsts);\n\n            // bookkeeping\n            _HashtagContainer memory hc;\n            hc.normalizedHashtag = normalizedHashtag;\n            hc.originalHashtag = hashtag;\n            hc.timestamp = block.timestamp;\n            tokenIdToHashtagContainer[tokenId] = hc;\n            normalizedHashtagToTokenId[normalizedHashtag] = tokenId;\n            mintedCount++;\n\n            claimedHashtags.push(hashtag);\n\n            emit UpdatedRegistry(tokenId, hashtag);\n        }\n\n        // Only charge for the hashtags that we were able to mint, and refund the rest\n        uint256 actualTotalPrice = pricePerHashtag.safeMul(mintedCount);\n        treasury.transfer(actualTotalPrice);\n        msg.sender.transfer(msg.value - actualTotalPrice);\n    }","contract":"ProofOfCultureMinter","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public hashtagTokenType;","after":"uint256 public immutable hashtagTokenType;","contract":"ProofOfCultureMinter","time":1}]}