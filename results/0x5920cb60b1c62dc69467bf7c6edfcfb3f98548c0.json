{"time":336,"results":[{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC20","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC20","time":0},{"type":"struct-data-arrangement ","before":"\naddress token\nuint256 amount\nuint256 strikePrice\nuint256 expiration\nbool isCall","after":"uint256 amount\nuint256 strikePrice\nuint256 expiration\naddress token\nbool isCall\n","contract":"PremiaOption","time":0},{"type":"struct-data-arrangement ","before":"\naddress token\nuint256 strikePrice\nuint256 expiration\nbool isCall\nuint256 claimsPreExp\nuint256 claimsPostExp\nuint256 exercised\nuint256 supply\nuint8 decimals","after":"uint256 strikePrice\nuint256 expiration\nuint256 claimsPreExp\nuint256 claimsPostExp\nuint256 exercised\nuint256 supply\naddress token\nbool isCall\nuint8 decimals\n","contract":"PremiaOption","time":0},{"type":"struct-data-arrangement ","before":"\naddress collateralToken\nuint256 collateral\nuint8 collateralDecimals\nuint256 fee\nuint256 feeReferrer","after":"uint256 collateral\nuint256 fee\nuint256 feeReferrer\naddress collateralToken\nuint8 collateralDecimals\n","contract":"PremiaOption","time":0},{"type":"struct-data-arrangement ","before":"\naddress inputToken\nuint256 input\nuint8 inputDecimals\naddress outputToken\nuint256 output\nuint8 outputDecimals\nuint256 fee\nuint256 feeReferrer","after":"uint256 input\nuint256 output\nuint256 fee\nuint256 feeReferrer\naddress inputToken\naddress outputToken\nuint8 inputDecimals\nuint8 outputDecimals\n","contract":"PremiaOption","time":0},{"type":"external-function ","before":"function setURI(string memory _newUri) external onlyOwner {\n\n        _setURI(_newUri);\n\n    }","after":"function setURI(string calldata _newUri) external onlyOwner {\n\n        _setURI(_newUri);\n\n    }","contract":"PremiaOption","time":0},{"type":"external-function ","before":"function setTokens(address[] memory _tokens, uint256[] memory _strikePriceIncrement) external onlyOwner {\n\n        require(_tokens.length == _strikePriceIncrement.length);\n\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n\n            if (!_isInArray(_tokens[i], tokens)) {\n\n                tokens.push(_tokens[i]);\n\n            }\n\n\n            require(_tokens[i] != address(denominator), \"Cant add denominator\");\n\n            tokenStrikeIncrement[_tokens[i]] = _strikePriceIncrement[i];\n\n\n            emit SetToken(_tokens[i], _strikePriceIncrement[i]);\n\n        }\n\n    }","after":"function setTokens(address[] calldata _tokens, uint256[] calldata _strikePriceIncrement) external onlyOwner {\n\n        require(_tokens.length == _strikePriceIncrement.length);\n\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n\n            if (!_isInArray(_tokens[i], tokens)) {\n\n                tokens.push(_tokens[i]);\n\n            }\n\n\n            require(_tokens[i] != address(denominator), \"Cant add denominator\");\n\n            tokenStrikeIncrement[_tokens[i]] = _strikePriceIncrement[i];\n\n\n            emit SetToken(_tokens[i], _strikePriceIncrement[i]);\n\n        }\n\n    }","contract":"PremiaOption","time":0},{"type":"external-function ","before":"function setWhitelistedUniswapRouters(address[] memory _addrList) external onlyOwner {\n\n        delete whitelistedUniswapRouters;\n\n\n        for (uint256 i = 0; i < _addrList.length; i++) {\n\n            whitelistedUniswapRouters.push(_addrList[i]);\n\n        }\n\n    }","after":"function setWhitelistedUniswapRouters(address[] calldata _addrList) external onlyOwner {\n\n        delete whitelistedUniswapRouters;\n\n\n        for (uint256 i = 0; i < _addrList.length; i++) {\n\n            whitelistedUniswapRouters.push(_addrList[i]);\n\n        }\n\n    }","contract":"PremiaOption","time":0},{"type":"external-function ","before":"function writeOptionFrom(address _from, OptionWriteArgs memory _option, address _referrer) external returns (uint256) {\n\n        require(isApprovedForAll(_from, msg.sender), \"Not approved\");\n\n        return _writeOption(_from, _option, _referrer);\n\n    }","after":"function writeOptionFrom(address _from, OptionWriteArgs calldata _option, address _referrer) external returns (uint256) {\n\n        require(isApprovedForAll(_from, msg.sender), \"Not approved\");\n\n        return _writeOption(_from, _option, _referrer);\n\n    }","contract":"PremiaOption","time":0},{"type":"external-function ","before":"function writeOption(OptionWriteArgs memory _option, address _referrer) public returns (uint256) {\n\n        return _writeOption(msg.sender, _option, _referrer);\n\n    }","after":"function writeOption(OptionWriteArgs calldata _option, address _referrer) public returns (uint256) {\n\n        return _writeOption(msg.sender, _option, _referrer);\n\n    }","contract":"PremiaOption","time":0},{"type":"external-function ","before":"function flashExerciseOptionFrom(address _from, uint256 _optionId, uint256 _amount, address _referrer, IUniswapV2Router02 _router, uint256 _amountInMax, address[] memory _path) external {\n\n        require(isApprovedForAll(_from, msg.sender), \"Not approved\");\n\n        _flashExerciseOption(_from, _optionId, _amount, _referrer, _router, _amountInMax, _path);\n\n    }","after":"function flashExerciseOptionFrom(address _from, uint256 _optionId, uint256 _amount, address _referrer, IUniswapV2Router02 _router, uint256 _amountInMax, address[] calldata _path) external {\n\n        require(isApprovedForAll(_from, msg.sender), \"Not approved\");\n\n        _flashExerciseOption(_from, _optionId, _amount, _referrer, _router, _amountInMax, _path);\n\n    }","contract":"PremiaOption","time":0},{"type":"external-function ","before":"function flashExerciseOption(uint256 _optionId, uint256 _amount, address _referrer, IUniswapV2Router02 _router, uint256 _amountInMax, address[] memory _path) external {\n\n        _flashExerciseOption(msg.sender, _optionId, _amount, _referrer, _router, _amountInMax, _path);\n\n    }","after":"function flashExerciseOption(uint256 _optionId, uint256 _amount, address _referrer, IUniswapV2Router02 _router, uint256 _amountInMax, address[] calldata _path) external {\n\n        _flashExerciseOption(msg.sender, _optionId, _amount, _referrer, _router, _amountInMax, _path);\n\n    }","contract":"PremiaOption","time":0},{"type":"external-function ","before":"function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n    public\n    view\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }","after":"function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    )\n    public\n    view\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            require(accounts[i] != address(0), \"ERC1155: batch balance query for the zero address\");\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }","contract":"PremiaOption","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n    public\n    virtual\n    override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n    public\n    virtual\n    override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"PremiaOption","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n    public\n    virtual\n    override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n    public\n    virtual\n    override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"PremiaOption","time":0},{"type":"immutable-restrict-modification ","before":"uint8 public denominatorDecimals;","after":"uint8 public immutable denominatorDecimals;","contract":"PremiaOption","time":1}]}