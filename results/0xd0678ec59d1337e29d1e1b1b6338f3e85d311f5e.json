{"time":111,"results":[{"type":"external-function ","before":"function dodoSwapV1(\n\n        address fromToken,\n\n        address toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] memory dodoPairs,\n\n        uint8[] memory directions,\n\n        uint256 deadLine\n\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n\n        require(dodoPairs.length == directions.length, \"DODOV1Proxy01: PARAMS_LENGTH_NOT_MATCH\");\n\n        uint256 originGas = gasleft();\n\n\n        if (fromToken != _ETH_ADDRESS_) {\n\n            IDODOApprove(_DODO_APPROVE_).claimTokens(\n\n                fromToken,\n\n                msg.sender,\n\n                address(this),\n\n                fromTokenAmount\n\n            );\n\n        } else {\n\n            require(msg.value == fromTokenAmount, \"DODOV1Proxy01: ETH_AMOUNT_NOT_MATCH\");\n\n            IWETH(_WETH_).deposit{value : fromTokenAmount}();\n\n        }\n\n\n        for (uint8 i = 0; i < dodoPairs.length; i++) {\n\n            address curDodoPair = dodoPairs[i];\n\n            if (directions[i] == 0) {\n\n                address curDodoBase = IDODOV1(curDodoPair)._BASE_TOKEN_();\n\n                uint256 curAmountIn = IERC20(curDodoBase).balanceOf(address(this));\n\n                IERC20(curDodoBase).universalApproveMax(curDodoPair, curAmountIn);\n\n                IDODOV1(curDodoPair).sellBaseToken(curAmountIn, 0, \"\");\n\n            } else {\n\n                address curDodoQuote = IDODOV1(curDodoPair)._QUOTE_TOKEN_();\n\n                uint256 curAmountIn = IERC20(curDodoQuote).balanceOf(address(this));\n\n                IERC20(curDodoQuote).universalApproveMax(curDodoPair, curAmountIn);\n\n                uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n\n                    curDodoPair,\n\n                    curAmountIn\n\n                );\n\n                IDODOV1(curDodoPair).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\n\n            }\n\n        }\n\n\n        if (toToken == _ETH_ADDRESS_) {\n\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n\n            IWETH(_WETH_).withdraw(returnAmount);\n\n        } else {\n\n            returnAmount = IERC20(toToken).tokenBalanceOf(address(this));\n\n        }\n\n\n        require(returnAmount >= minReturnAmount, \"DODOV1Proxy01: Return amount is not enough\");\n\n        IERC20(toToken).universalTransfer(msg.sender, returnAmount);\n\n\n        emit OrderHistory(fromToken, toToken, msg.sender, fromTokenAmount, returnAmount);\n\n\n        uint8 _gasDodoMaxReturn = _GAS_DODO_MAX_RETURN_;\n\n        if (_gasDodoMaxReturn > 0) {\n\n            uint256 calcGasTokenBurn = originGas.sub(gasleft()) / 65000;\n\n            uint256 gasTokenBurn = calcGasTokenBurn > _gasDodoMaxReturn ? _gasDodoMaxReturn : calcGasTokenBurn;\n\n            if (gasleft() > 27710 + gasTokenBurn * 6080)\n\n                IChi(_CHI_TOKEN_).freeUpTo(gasTokenBurn);\n\n        }\n\n    }","after":"function dodoSwapV1(\n\n        address fromToken,\n\n        address toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] calldata dodoPairs,\n\n        uint8[] calldata directions,\n\n        uint256 deadLine\n\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n\n        require(dodoPairs.length == directions.length, \"DODOV1Proxy01: PARAMS_LENGTH_NOT_MATCH\");\n\n        uint256 originGas = gasleft();\n\n\n        if (fromToken != _ETH_ADDRESS_) {\n\n            IDODOApprove(_DODO_APPROVE_).claimTokens(\n\n                fromToken,\n\n                msg.sender,\n\n                address(this),\n\n                fromTokenAmount\n\n            );\n\n        } else {\n\n            require(msg.value == fromTokenAmount, \"DODOV1Proxy01: ETH_AMOUNT_NOT_MATCH\");\n\n            IWETH(_WETH_).deposit{value : fromTokenAmount}();\n\n        }\n\n\n        for (uint8 i = 0; i < dodoPairs.length; i++) {\n\n            address curDodoPair = dodoPairs[i];\n\n            if (directions[i] == 0) {\n\n                address curDodoBase = IDODOV1(curDodoPair)._BASE_TOKEN_();\n\n                uint256 curAmountIn = IERC20(curDodoBase).balanceOf(address(this));\n\n                IERC20(curDodoBase).universalApproveMax(curDodoPair, curAmountIn);\n\n                IDODOV1(curDodoPair).sellBaseToken(curAmountIn, 0, \"\");\n\n            } else {\n\n                address curDodoQuote = IDODOV1(curDodoPair)._QUOTE_TOKEN_();\n\n                uint256 curAmountIn = IERC20(curDodoQuote).balanceOf(address(this));\n\n                IERC20(curDodoQuote).universalApproveMax(curDodoPair, curAmountIn);\n\n                uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n\n                    curDodoPair,\n\n                    curAmountIn\n\n                );\n\n                IDODOV1(curDodoPair).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\n\n            }\n\n        }\n\n\n        if (toToken == _ETH_ADDRESS_) {\n\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n\n            IWETH(_WETH_).withdraw(returnAmount);\n\n        } else {\n\n            returnAmount = IERC20(toToken).tokenBalanceOf(address(this));\n\n        }\n\n\n        require(returnAmount >= minReturnAmount, \"DODOV1Proxy01: Return amount is not enough\");\n\n        IERC20(toToken).universalTransfer(msg.sender, returnAmount);\n\n\n        emit OrderHistory(fromToken, toToken, msg.sender, fromTokenAmount, returnAmount);\n\n\n        uint8 _gasDodoMaxReturn = _GAS_DODO_MAX_RETURN_;\n\n        if (_gasDodoMaxReturn > 0) {\n\n            uint256 calcGasTokenBurn = originGas.sub(gasleft()) / 65000;\n\n            uint256 gasTokenBurn = calcGasTokenBurn > _gasDodoMaxReturn ? _gasDodoMaxReturn : calcGasTokenBurn;\n\n            if (gasleft() > 27710 + gasTokenBurn * 6080)\n\n                IChi(_CHI_TOKEN_).freeUpTo(gasTokenBurn);\n\n        }\n\n    }","contract":"DODOV1Proxy01","time":0},{"type":"external-function ","before":"function externalSwap(\n\n        address fromToken,\n\n        address toToken,\n\n        address approveTarget,\n\n        address swapTarget,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        bytes memory callDataConcat,\n\n        uint256 deadLine\n\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n\n        address _fromToken = fromToken;\n\n        address _toToken = toToken;\n\n\n        uint256 toTokenOriginBalance = IERC20(_toToken).universalBalanceOf(msg.sender);\n\n\n        if (_fromToken != _ETH_ADDRESS_) {\n\n            IDODOApprove(_DODO_APPROVE_).claimTokens(\n\n                _fromToken,\n\n                msg.sender,\n\n                address(this),\n\n                fromTokenAmount\n\n            );\n\n            IERC20(_fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n\n        }\n\n\n        require(isWhiteListed[swapTarget], \"DODOV1Proxy01: Not Whitelist Contract\");\n\n        (bool success,) = swapTarget.call{value : _fromToken == _ETH_ADDRESS_ ? msg.value : 0}(callDataConcat);\n\n\n        require(success, \"DODOV1Proxy01: External Swap execution Failed\");\n\n\n        IERC20(_fromToken).universalTransfer(\n\n            msg.sender,\n\n            IERC20(_fromToken).universalBalanceOf(address(this))\n\n        );\n\n\n        IERC20(_toToken).universalTransfer(\n\n            msg.sender,\n\n            IERC20(_toToken).universalBalanceOf(address(this))\n\n        );\n\n        returnAmount = IERC20(_toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\n\n        require(returnAmount >= minReturnAmount, \"DODOV1Proxy01: Return amount is not enough\");\n\n\n        emit OrderHistory(_fromToken, _toToken, msg.sender, fromTokenAmount, returnAmount);\n\n\n        uint8 _gasExternalReturn = _GAS_EXTERNAL_RETURN_;\n\n        if (_gasExternalReturn > 0) {\n\n            if (gasleft() > 27710 + _gasExternalReturn * 6080)\n\n                IChi(_CHI_TOKEN_).freeUpTo(_gasExternalReturn);\n\n        }\n\n    }","after":"function externalSwap(\n\n        address fromToken,\n\n        address toToken,\n\n        address approveTarget,\n\n        address swapTarget,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        bytes calldata callDataConcat,\n\n        uint256 deadLine\n\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n\n        address _fromToken = fromToken;\n\n        address _toToken = toToken;\n\n\n        uint256 toTokenOriginBalance = IERC20(_toToken).universalBalanceOf(msg.sender);\n\n\n        if (_fromToken != _ETH_ADDRESS_) {\n\n            IDODOApprove(_DODO_APPROVE_).claimTokens(\n\n                _fromToken,\n\n                msg.sender,\n\n                address(this),\n\n                fromTokenAmount\n\n            );\n\n            IERC20(_fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n\n        }\n\n\n        require(isWhiteListed[swapTarget], \"DODOV1Proxy01: Not Whitelist Contract\");\n\n        (bool success,) = swapTarget.call{value : _fromToken == _ETH_ADDRESS_ ? msg.value : 0}(callDataConcat);\n\n\n        require(success, \"DODOV1Proxy01: External Swap execution Failed\");\n\n\n        IERC20(_fromToken).universalTransfer(\n\n            msg.sender,\n\n            IERC20(_fromToken).universalBalanceOf(address(this))\n\n        );\n\n\n        IERC20(_toToken).universalTransfer(\n\n            msg.sender,\n\n            IERC20(_toToken).universalBalanceOf(address(this))\n\n        );\n\n        returnAmount = IERC20(_toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\n\n        require(returnAmount >= minReturnAmount, \"DODOV1Proxy01: Return amount is not enough\");\n\n\n        emit OrderHistory(_fromToken, _toToken, msg.sender, fromTokenAmount, returnAmount);\n\n\n        uint8 _gasExternalReturn = _GAS_EXTERNAL_RETURN_;\n\n        if (_gasExternalReturn > 0) {\n\n            if (gasleft() > 27710 + _gasExternalReturn * 6080)\n\n                IChi(_CHI_TOKEN_).freeUpTo(_gasExternalReturn);\n\n        }\n\n    }","contract":"DODOV1Proxy01","time":0},{"type":"external-function ","before":"function mixSwapV1(\n\n        address fromToken,\n\n        address toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] memory mixPairs,\n\n        uint8[] memory directions,\n\n        address[] memory portionPath,\n\n        uint256 deadLine\n\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n\n        require(mixPairs.length == directions.length, \"DODOV1Proxy01: PARAMS_LENGTH_NOT_MATCH\");\n\n        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);\n\n\n        if (fromToken != _ETH_ADDRESS_) {\n\n            IDODOApprove(_DODO_APPROVE_).claimTokens(\n\n                fromToken,\n\n                msg.sender,\n\n                address(this),\n\n                fromTokenAmount\n\n            );\n\n        } else {\n\n            require(msg.value == fromTokenAmount, \"DODOV1Proxy01: ETH_AMOUNT_NOT_MATCH\");\n\n            IWETH(_WETH_).deposit{value : fromTokenAmount}();\n\n        }\n\n\n        for (uint8 i = 0; i < mixPairs.length; i++) {\n\n            address curPair = mixPairs[i];\n\n            if (directions[i] == 0) {\n\n                address curDodoBase = IDODOV1(curPair)._BASE_TOKEN_();\n\n                uint256 curAmountIn = IERC20(curDodoBase).balanceOf(address(this));\n\n                IERC20(curDodoBase).universalApproveMax(curPair, curAmountIn);\n\n                IDODOV1(curPair).sellBaseToken(curAmountIn, 0, \"\");\n\n            } else if (directions[i] == 1) {\n\n                address curDodoQuote = IDODOV1(curPair)._QUOTE_TOKEN_();\n\n                uint256 curAmountIn = IERC20(curDodoQuote).balanceOf(address(this));\n\n                IERC20(curDodoQuote).universalApproveMax(curPair, curAmountIn);\n\n                uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n\n                    curPair,\n\n                    curAmountIn\n\n                );\n\n                IDODOV1(curPair).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\n\n            } else {\n\n                uint256 curAmountIn = IERC20(portionPath[0]).balanceOf(address(this));\n\n                IERC20(portionPath[0]).universalApproveMax(curPair, curAmountIn);\n\n                IUni(curPair).swapExactTokensForTokens(curAmountIn, 0, portionPath, address(this), deadLine);\n\n            }\n\n        }\n\n\n        IERC20(fromToken).universalTransfer(\n\n            msg.sender,\n\n            IERC20(fromToken).universalBalanceOf(address(this))\n\n        );\n\n\n        IERC20(toToken).universalTransfer(\n\n            msg.sender,\n\n            IERC20(toToken).universalBalanceOf(address(this))\n\n        );\n\n\n        returnAmount = IERC20(toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\n\n        require(returnAmount >= minReturnAmount, \"DODOV1Proxy01: Return amount is not enough\");\n\n\n        emit OrderHistory(fromToken, toToken, msg.sender, fromTokenAmount, returnAmount);\n\n\n        uint8 _gasExternalReturn = _GAS_EXTERNAL_RETURN_;\n\n        if (_gasExternalReturn > 0) {\n\n            if (gasleft() > 27710 + _gasExternalReturn * 6080)\n\n                IChi(_CHI_TOKEN_).freeUpTo(_gasExternalReturn);\n\n        }\n\n    }","after":"function mixSwapV1(\n\n        address fromToken,\n\n        address toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] calldata mixPairs,\n\n        uint8[] calldata directions,\n\n        address[] calldata portionPath,\n\n        uint256 deadLine\n\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n\n        require(mixPairs.length == directions.length, \"DODOV1Proxy01: PARAMS_LENGTH_NOT_MATCH\");\n\n        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);\n\n\n        if (fromToken != _ETH_ADDRESS_) {\n\n            IDODOApprove(_DODO_APPROVE_).claimTokens(\n\n                fromToken,\n\n                msg.sender,\n\n                address(this),\n\n                fromTokenAmount\n\n            );\n\n        } else {\n\n            require(msg.value == fromTokenAmount, \"DODOV1Proxy01: ETH_AMOUNT_NOT_MATCH\");\n\n            IWETH(_WETH_).deposit{value : fromTokenAmount}();\n\n        }\n\n\n        for (uint8 i = 0; i < mixPairs.length; i++) {\n\n            address curPair = mixPairs[i];\n\n            if (directions[i] == 0) {\n\n                address curDodoBase = IDODOV1(curPair)._BASE_TOKEN_();\n\n                uint256 curAmountIn = IERC20(curDodoBase).balanceOf(address(this));\n\n                IERC20(curDodoBase).universalApproveMax(curPair, curAmountIn);\n\n                IDODOV1(curPair).sellBaseToken(curAmountIn, 0, \"\");\n\n            } else if (directions[i] == 1) {\n\n                address curDodoQuote = IDODOV1(curPair)._QUOTE_TOKEN_();\n\n                uint256 curAmountIn = IERC20(curDodoQuote).balanceOf(address(this));\n\n                IERC20(curDodoQuote).universalApproveMax(curPair, curAmountIn);\n\n                uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n\n                    curPair,\n\n                    curAmountIn\n\n                );\n\n                IDODOV1(curPair).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\n\n            } else {\n\n                uint256 curAmountIn = IERC20(portionPath[0]).balanceOf(address(this));\n\n                IERC20(portionPath[0]).universalApproveMax(curPair, curAmountIn);\n\n                IUni(curPair).swapExactTokensForTokens(curAmountIn, 0, portionPath, address(this), deadLine);\n\n            }\n\n        }\n\n\n        IERC20(fromToken).universalTransfer(\n\n            msg.sender,\n\n            IERC20(fromToken).universalBalanceOf(address(this))\n\n        );\n\n\n        IERC20(toToken).universalTransfer(\n\n            msg.sender,\n\n            IERC20(toToken).universalBalanceOf(address(this))\n\n        );\n\n\n        returnAmount = IERC20(toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\n\n        require(returnAmount >= minReturnAmount, \"DODOV1Proxy01: Return amount is not enough\");\n\n\n        emit OrderHistory(fromToken, toToken, msg.sender, fromTokenAmount, returnAmount);\n\n\n        uint8 _gasExternalReturn = _GAS_EXTERNAL_RETURN_;\n\n        if (_gasExternalReturn > 0) {\n\n            if (gasleft() > 27710 + _gasExternalReturn * 6080)\n\n                IChi(_CHI_TOKEN_).freeUpTo(_gasExternalReturn);\n\n        }\n\n    }","contract":"DODOV1Proxy01","time":0}]}