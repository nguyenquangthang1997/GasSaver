{"time":400,"results":[{"type":"constant-restrict-modification  ","before":"bytes32 public name;","after":"bytes32 public constant name;","contract":"UniswapExchangeInterface","time":0},{"type":"constant-restrict-modification  ","before":"bytes32 public symbol;","after":"bytes32 public constant symbol;","contract":"UniswapExchangeInterface","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public decimals;","after":"uint256 public constant decimals;","contract":"UniswapExchangeInterface","time":0},{"type":"constant-restrict-modification  ","before":"address public exchangeTemplate;","after":"address public constant exchangeTemplate;","contract":"UniswapFactoryInterface","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public tokenCount;","after":"uint256 public constant tokenCount;","contract":"UniswapFactoryInterface","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC20Detailed","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC20Detailed","time":1},{"type":"immutable-restrict-modification ","before":"uint8 private _decimals;","after":"uint8 private immutable _decimals;","contract":"ERC20Detailed","time":1},{"type":"loop-calculation","before":"Vault storage vault = vaults[vaultOwner];","after":"// move outside for loop\nVault storage vault = vaults[vaultOwner];","loc":{"start":{"line":2927,"column":12},"end":{"line":2927,"column":52}},"contract":"OptionsContract","time":0},{"type":"state-data-arrangement ","before":"\nOptionsExchange public optionsExchange;\nmapping(address => Vault) internal vaults;\naddress payable[] internal vaultOwners;\nNumber public liquidationIncentive = Number(10, - 3);\nNumber public transactionFee = Number(0, - 3);\nNumber public liquidationFactor = Number(500, - 3);\nNumber public minCollateralizationRatio = Number(16, - 1);\nNumber public strikePrice;\nNumber public oTokenExchangeRate;\nuint256 internal windowSize;\nuint256 internal totalFee;\nuint256 public expiry;\nint32 public collateralExp = - 18;\nint32 public underlyingExp = - 18;\nIERC20 public collateral;\nIERC20 public underlying;\nIERC20 public strike;\nCompoundOracleInterface public COMPOUND_ORACLE;\nstring public name;\nstring public symbol;\nuint8 public decimals;","after":"OptionsExchange public optionsExchange;\nmapping(address => Vault) internal vaults;\naddress payable[] internal vaultOwners;\nNumber public liquidationIncentive = Number(10, - 3);\nNumber public transactionFee = Number(0, - 3);\nNumber public liquidationFactor = Number(500, - 3);\nNumber public minCollateralizationRatio = Number(16, - 1);\nNumber public strikePrice;\nNumber public oTokenExchangeRate;\nuint256 internal windowSize;\nuint256 internal totalFee;\nuint256 public expiry;\nIERC20 public collateral;\nIERC20 public underlying;\nIERC20 public strike;\nCompoundOracleInterface public COMPOUND_ORACLE;\nstring public name;\nstring public symbol;\nint32 public collateralExp = - 18;\nint32 public underlyingExp = - 18;\nuint8 public decimals;\n","contract":"OptionsContract","time":0},{"type":"external-function ","before":"function setDetails(string memory _name, string memory _symbol)\n\n    public\n\n    onlyOwner\n\n    {\n\n        name = _name;\n\n        symbol = _symbol;\n\n        decimals = uint8(- 1 * oTokenExchangeRate.exponent);\n\n        require(\n\n            decimals >= 0,\n\n            \"1 oToken cannot protect less than the smallest unit of the asset\"\n\n        );\n\n    }","after":"function setDetails(string calldata _name, string calldata _symbol)\n\n    public\n\n    onlyOwner\n\n    {\n\n        name = _name;\n\n        symbol = _symbol;\n\n        decimals = uint8(- 1 * oTokenExchangeRate.exponent);\n\n        require(\n\n            decimals >= 0,\n\n            \"1 oToken cannot protect less than the smallest unit of the asset\"\n\n        );\n\n    }","contract":"oToken","time":0},{"type":"external-function ","before":"function exercise(\n\n        uint256 oTokensToExercise,\n\n        address payable[] memory vaultsToExerciseFrom\n\n    ) public payable {\n\n        for (uint256 i = 0; i < vaultsToExerciseFrom.length; i++) {\n\n            address payable vaultOwner = vaultsToExerciseFrom[i];\n\n            require(\n\n                hasVault(vaultOwner),\n\n                \"Cannot exercise from a vault that doesn't exist\"\n\n            );\n\n            Vault storage vault = vaults[vaultOwner];\n\n            if (oTokensToExercise == 0) {\n\n                return;\n\n            } else if (vault.oTokensIssued >= oTokensToExercise) {\n\n                _exercise(oTokensToExercise, vaultOwner);\n\n                return;\n\n            } else {\n\n                oTokensToExercise = oTokensToExercise.sub(vault.oTokensIssued);\n\n                _exercise(vault.oTokensIssued, vaultOwner);\n\n            }\n\n        }\n\n        require(\n\n            oTokensToExercise == 0,\n\n            \"Specified vaults have insufficient collateral\"\n\n        );\n\n    }","after":"function exercise(\n\n        uint256 oTokensToExercise,\n\n        address payable[] calldata vaultsToExerciseFrom\n\n    ) public payable {\n\n        for (uint256 i = 0; i < vaultsToExerciseFrom.length; i++) {\n\n            address payable vaultOwner = vaultsToExerciseFrom[i];\n\n            require(\n\n                hasVault(vaultOwner),\n\n                \"Cannot exercise from a vault that doesn't exist\"\n\n            );\n\n            Vault storage vault = vaults[vaultOwner];\n\n            if (oTokensToExercise == 0) {\n\n                return;\n\n            } else if (vault.oTokensIssued >= oTokensToExercise) {\n\n                _exercise(oTokensToExercise, vaultOwner);\n\n                return;\n\n            } else {\n\n                oTokensToExercise = oTokensToExercise.sub(vault.oTokensIssued);\n\n                _exercise(vault.oTokensIssued, vaultOwner);\n\n            }\n\n        }\n\n        require(\n\n            oTokensToExercise == 0,\n\n            \"Specified vaults have insufficient collateral\"\n\n        );\n\n    }","contract":"oToken","time":0},{"type":"immutable-restrict-modification ","before":"uint256 internal windowSize;","after":"uint256 internal immutable windowSize;","contract":"oToken","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public expiry;","after":"uint256 public immutable expiry;","contract":"oToken","time":1},{"type":"immutable-restrict-modification ","before":"int32 public collateralExp = - 18;","after":"int32 public immutable collateralExp = - 18;","contract":"oToken","time":1},{"type":"immutable-restrict-modification ","before":"int32 public underlyingExp = - 18;","after":"int32 public immutable underlyingExp = - 18;","contract":"oToken","time":1},{"type":"external-function ","before":"function compareStrings(string memory a, string memory b) public pure\n\n    returns (bool) {\n\n        return keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b)));\n\n    }","after":"function compareStrings(string calldata a, string calldata b) public pure\n\n    returns (bool) {\n\n        return keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b)));\n\n    }","contract":"StringComparator","time":0},{"type":"external-function ","before":"function createOptionsContract(\n\n        string memory _collateralType,\n\n        int32 _collateralExp,\n\n        string memory _underlyingType,\n\n        int32 _underlyingExp,\n\n        int32 _oTokenExchangeExp,\n\n        uint256 _strikePrice,\n\n        int32 _strikeExp,\n\n        string memory _strikeAsset,\n\n        uint256 _expiry,\n\n        uint256 _windowSize\n\n    ) public returns (address) {\n\n        require(_expiry > block.timestamp, \"Cannot create an expired option\");\n\n        require(_windowSize <= _expiry, \"Invalid _windowSize\");\n\n        require(\n\n            supportsAsset(_collateralType),\n\n            \"Collateral type not supported\"\n\n        );\n\n        require(\n\n            supportsAsset(_underlyingType),\n\n            \"Underlying type not supported\"\n\n        );\n\n        require(supportsAsset(_strikeAsset), \"Strike asset type not supported\");\n\n\n        OptionsContract optionsContract = new oToken(\n\n            tokens[_collateralType],\n\n            _collateralExp,\n\n            tokens[_underlyingType],\n\n            _underlyingExp,\n\n            _oTokenExchangeExp,\n\n            _strikePrice,\n\n            _strikeExp,\n\n            tokens[_strikeAsset],\n\n            _expiry,\n\n            optionsExchange,\n\n            oracleAddress,\n\n            _windowSize\n\n        );\n\n\n        optionsContracts.push(address(optionsContract));\n\n        emit OptionsContractCreated(address(optionsContract));\n\n\n        // Set the owner for the options contract.\n\n        optionsContract.transferOwnership(owner());\n\n\n        return address(optionsContract);\n\n    }","after":"function createOptionsContract(\n\n        string calldata _collateralType,\n\n        int32 _collateralExp,\n\n        string calldata _underlyingType,\n\n        int32 _underlyingExp,\n\n        int32 _oTokenExchangeExp,\n\n        uint256 _strikePrice,\n\n        int32 _strikeExp,\n\n        string calldata _strikeAsset,\n\n        uint256 _expiry,\n\n        uint256 _windowSize\n\n    ) public returns (address) {\n\n        require(_expiry > block.timestamp, \"Cannot create an expired option\");\n\n        require(_windowSize <= _expiry, \"Invalid _windowSize\");\n\n        require(\n\n            supportsAsset(_collateralType),\n\n            \"Collateral type not supported\"\n\n        );\n\n        require(\n\n            supportsAsset(_underlyingType),\n\n            \"Underlying type not supported\"\n\n        );\n\n        require(supportsAsset(_strikeAsset), \"Strike asset type not supported\");\n\n\n        OptionsContract optionsContract = new oToken(\n\n            tokens[_collateralType],\n\n            _collateralExp,\n\n            tokens[_underlyingType],\n\n            _underlyingExp,\n\n            _oTokenExchangeExp,\n\n            _strikePrice,\n\n            _strikeExp,\n\n            tokens[_strikeAsset],\n\n            _expiry,\n\n            optionsExchange,\n\n            oracleAddress,\n\n            _windowSize\n\n        );\n\n\n        optionsContracts.push(address(optionsContract));\n\n        emit OptionsContractCreated(address(optionsContract));\n\n\n        // Set the owner for the options contract.\n\n        optionsContract.transferOwnership(owner());\n\n\n        return address(optionsContract);\n\n    }","contract":"OptionsFactory","time":0},{"type":"external-function ","before":"function addAsset(string memory _asset, address _addr) public onlyOwner {\n\n        require(!supportsAsset(_asset), \"Asset already added\");\n\n        require(_addr != address(0), \"Cannot set to address(0)\");\n\n\n        tokens[_asset] = IERC20(_addr);\n\n        emit AssetAdded(_asset, _addr);\n\n    }","after":"function addAsset(string calldata _asset, address _addr) public onlyOwner {\n\n        require(!supportsAsset(_asset), \"Asset already added\");\n\n        require(_addr != address(0), \"Cannot set to address(0)\");\n\n\n        tokens[_asset] = IERC20(_addr);\n\n        emit AssetAdded(_asset, _addr);\n\n    }","contract":"OptionsFactory","time":0},{"type":"external-function ","before":"function changeAsset(string memory _asset, address _addr) public onlyOwner {\n\n        require(\n\n            tokens[_asset] != IERC20(0),\n\n            \"Trying to replace a non-existent asset\"\n\n        );\n\n        require(_addr != address(0), \"Cannot set to address(0)\");\n\n\n        tokens[_asset] = IERC20(_addr);\n\n        emit AssetChanged(_asset, _addr);\n\n    }","after":"function changeAsset(string calldata _asset, address _addr) public onlyOwner {\n\n        require(\n\n            tokens[_asset] != IERC20(0),\n\n            \"Trying to replace a non-existent asset\"\n\n        );\n\n        require(_addr != address(0), \"Cannot set to address(0)\");\n\n\n        tokens[_asset] = IERC20(_addr);\n\n        emit AssetChanged(_asset, _addr);\n\n    }","contract":"OptionsFactory","time":0},{"type":"external-function ","before":"function deleteAsset(string memory _asset) public onlyOwner {\n\n        require(\n\n            tokens[_asset] != IERC20(0),\n\n            \"Trying to delete a non-existent asset\"\n\n        );\n\n\n        tokens[_asset] = IERC20(0);\n\n        emit AssetDeleted(_asset);\n\n    }","after":"function deleteAsset(string calldata _asset) public onlyOwner {\n\n        require(\n\n            tokens[_asset] != IERC20(0),\n\n            \"Trying to delete a non-existent asset\"\n\n        );\n\n\n        tokens[_asset] = IERC20(0);\n\n        emit AssetDeleted(_asset);\n\n    }","contract":"OptionsFactory","time":0},{"type":"immutable-restrict-modification ","before":"address public oracleAddress;","after":"address public immutable oracleAddress;","contract":"OptionsFactory","time":0}]}