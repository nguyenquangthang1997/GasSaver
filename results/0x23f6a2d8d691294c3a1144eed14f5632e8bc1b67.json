{"time":216,"results":[{"type":"external-function ","before":"function addUsdFeed(string memory symbol, address feed) external onlyOwner {\n        require(_latestPrice(feed) > 0, \"Price should be > 0\");\n        bytes32 currencyKey = stringToBytes32(symbol);\n        usdFeeds[currencyKey] = feed;\n        emit AddFeed(currencyKey, symbol, \"USD\", feed);\n    }","after":"function addUsdFeed(string calldata symbol, address feed) external onlyOwner {\n        require(_latestPrice(feed) > 0, \"Price should be > 0\");\n        bytes32 currencyKey = stringToBytes32(symbol);\n        usdFeeds[currencyKey] = feed;\n        emit AddFeed(currencyKey, symbol, \"USD\", feed);\n    }","contract":"ChainlinkFeedsRegistry","time":0},{"type":"external-function ","before":"function addEthFeed(string memory symbol, address feed) external onlyOwner {\n        require(_latestPrice(feed) > 0, \"Price should be > 0\");\n        bytes32 currencyKey = stringToBytes32(symbol);\n        ethFeeds[currencyKey] = feed;\n        emit AddFeed(currencyKey, symbol, \"ETH\", feed);\n    }","after":"function addEthFeed(string calldata symbol, address feed) external onlyOwner {\n        require(_latestPrice(feed) > 0, \"Price should be > 0\");\n        bytes32 currencyKey = stringToBytes32(symbol);\n        ethFeeds[currencyKey] = feed;\n        emit AddFeed(currencyKey, symbol, \"ETH\", feed);\n    }","contract":"ChainlinkFeedsRegistry","time":0},{"type":"external-function ","before":"function getPriceFromSymbol(string memory symbol) external view returns (uint256) {\n        return getPrice(stringToBytes32(symbol));\n    }","after":"function getPriceFromSymbol(string calldata symbol) external view returns (uint256) {\n        return getPrice(stringToBytes32(symbol));\n    }","contract":"ChainlinkFeedsRegistry","time":0},{"type":"state-data-arrangement ","before":"\naddress public cubePool;\nstring public spotSymbol;\nbool public inverse;","after":"string public spotSymbol;\naddress public cubePool;\nbool public inverse;\n","contract":"CubeToken","time":0},{"type":"external-function ","before":"function initialize(\n        address _cubePool,\n        string memory _spotSymbol,\n        bool _inverse\n    ) external initializer {\n        // Example name: 3X Long BTC\n        // Example symbol: cubeBTC\n        string memory name = string(abi.encodePacked(\"3X \", _inverse ? \"Short \" : \"Long \", _spotSymbol));\n        string memory symbol = string(abi.encodePacked(_inverse ? \"inv\" : \"cube\", _spotSymbol));\n        __ERC20_init(name, symbol);\n\n        cubePool = _cubePool;\n        spotSymbol = _spotSymbol;\n        inverse = _inverse;\n    }","after":"function initialize(\n        address _cubePool,\n        string calldata _spotSymbol,\n        bool _inverse\n    ) external initializer {\n        // Example name: 3X Long BTC\n        // Example symbol: cubeBTC\n        string memory name = string(abi.encodePacked(\"3X \", _inverse ? \"Short \" : \"Long \", _spotSymbol));\n        string memory symbol = string(abi.encodePacked(_inverse ? \"inv\" : \"cube\", _spotSymbol));\n        __ERC20_init(name, symbol);\n\n        cubePool = _cubePool;\n        spotSymbol = _spotSymbol;\n        inverse = _inverse;\n    }","contract":"CubeToken","time":0},{"type":"state-data-arrangement ","before":"\nuint256 public constant MIN_TOTAL_EQUITY = 1000;\nChainlinkFeedsRegistry public immutable feedsRegistry;\nCubeToken public immutable cubeTokenImpl;\nmapping(CubeToken => CubeTokenParams) public params;\nmapping(string => mapping(bool => CubeToken)) public cubeTokensMap;\nCubeToken[] public cubeTokens;\naddress public governance;\naddress public pendingGovernance;\naddress public guardian;\nuint256 public protocolFee;\nuint256 public maxPoolBalance;\nbool public finalized;\nuint256 public totalEquity;\nuint256 public accruedProtocolFees;","after":"uint256 public constant MIN_TOTAL_EQUITY = 1000;\nChainlinkFeedsRegistry public immutable feedsRegistry;\nCubeToken public immutable cubeTokenImpl;\nmapping(CubeToken => CubeTokenParams) public params;\nmapping(string => mapping(bool => CubeToken)) public cubeTokensMap;\nCubeToken[] public cubeTokens;\nuint256 public protocolFee;\nuint256 public maxPoolBalance;\nuint256 public totalEquity;\nuint256 public accruedProtocolFees;\naddress public governance;\naddress public pendingGovernance;\naddress public guardian;\nbool public finalized;\n","contract":"CubePool","time":0},{"type":"external-function ","before":"function addCubeToken(\n        string memory spotSymbol,\n        bool inverse,\n        uint256 depositWithdrawFee,\n        uint256 maxPoolShare\n    ) external onlyGovernance returns (address) {\n        require(address(cubeTokensMap[spotSymbol][inverse]) == address(0), \"Already added\");\n\n        bytes32 salt = keccak256(abi.encodePacked(spotSymbol, inverse));\n        CubeToken cubeToken = CubeToken(Clones.cloneDeterministic(address(cubeTokenImpl), salt));\n        cubeToken.initialize(address(this), spotSymbol, inverse);\n\n        bytes32 currencyKey = feedsRegistry.stringToBytes32(spotSymbol);\n        uint256 spot = feedsRegistry.getPrice(currencyKey);\n        require(spot > 0, \"Spot price should be > 0\");\n\n        params[cubeToken] = CubeTokenParams({\n        currencyKey : currencyKey,\n        inverse : inverse,\n        depositPaused : false,\n        withdrawPaused : false,\n        updatePaused : false,\n        added : true,\n        depositWithdrawFee : depositWithdrawFee,\n        maxPoolShare : maxPoolShare,\n        initialSpotPrice : spot,\n        lastPrice : 0,\n        lastUpdated : 0\n        });\n        cubeTokensMap[spotSymbol][inverse] = cubeToken;\n        cubeTokens.push(cubeToken);\n\n        // Set `lastPrice` and `lastUpdated`\n        update(cubeToken);\n        assert(params[cubeToken].lastPrice > 0);\n        assert(params[cubeToken].lastUpdated > 0);\n\n        emit AddCubeToken(cubeToken, spotSymbol, inverse, currencyKey, spot);\n        return address(cubeToken);\n    }","after":"function addCubeToken(\n        string calldata spotSymbol,\n        bool inverse,\n        uint256 depositWithdrawFee,\n        uint256 maxPoolShare\n    ) external onlyGovernance returns (address) {\n        require(address(cubeTokensMap[spotSymbol][inverse]) == address(0), \"Already added\");\n\n        bytes32 salt = keccak256(abi.encodePacked(spotSymbol, inverse));\n        CubeToken cubeToken = CubeToken(Clones.cloneDeterministic(address(cubeTokenImpl), salt));\n        cubeToken.initialize(address(this), spotSymbol, inverse);\n\n        bytes32 currencyKey = feedsRegistry.stringToBytes32(spotSymbol);\n        uint256 spot = feedsRegistry.getPrice(currencyKey);\n        require(spot > 0, \"Spot price should be > 0\");\n\n        params[cubeToken] = CubeTokenParams({\n        currencyKey : currencyKey,\n        inverse : inverse,\n        depositPaused : false,\n        withdrawPaused : false,\n        updatePaused : false,\n        added : true,\n        depositWithdrawFee : depositWithdrawFee,\n        maxPoolShare : maxPoolShare,\n        initialSpotPrice : spot,\n        lastPrice : 0,\n        lastUpdated : 0\n        });\n        cubeTokensMap[spotSymbol][inverse] = cubeToken;\n        cubeTokens.push(cubeToken);\n\n        // Set `lastPrice` and `lastUpdated`\n        update(cubeToken);\n        assert(params[cubeToken].lastPrice > 0);\n        assert(params[cubeToken].lastUpdated > 0);\n\n        emit AddCubeToken(cubeToken, spotSymbol, inverse, currencyKey, spot);\n        return address(cubeToken);\n    }","contract":"CubePool","time":0}]}