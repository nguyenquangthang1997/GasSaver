{"time":247,"results":[{"type":"state-data-arrangement ","before":"\n\n    int256 private constant _WAD = 10 *\n\n    int256 private constant _INT256_MIN = - 2 **\n\n    uint8 private constant FIXED_DIGITS \n\n    int256 private constant FIXED_1 = 10 *\n\n    int256 private constant FIXED_E = 271828182845904\n\n    uint8 private constant LONGER_DIGITS \n\n    int256 private constant LONGER_FIXED_LOG_E_1_5 = 40546510810816438197801311546434\n\n    int256 private constant LONGER_FIXED_1 = 10 *\n\n    int256 private constant LONGER_FIXED_LOG_E_10 = 230258509299404568401799145468436","after":"\n    int256 private constant _WAD = 10 *\n\n    int256 private constant _INT256_MIN = - 2 **\n\n    int256 private constant FIXED_1 = 10 *\n\n    int256 private constant FIXED_E = 271828182845904\n\n    int256 private constant LONGER_FIXED_LOG_E_1_5 = 40546510810816438197801311546434\n\n    int256 private constant LONGER_FIXED_1 = 10 *\n\n    int256 private constant LONGER_FIXED_LOG_E_10 = 230258509299404568401799145468436\n\n    uint8 private constant FIXED_DIGITS \n\n    uint8 private constant LONGER_DIGITS \n","contract":"LibMathSigned","time":0},{"type":"external-function ","before":", LibOrder.OrderParam takerOrderParam, uint256 amount);\n\n    event Cancel(bytes32 indexed orderHash);\n\n\n\n    constructor(address _globalConfig) public {\n\n        globalConfig = IGlobalConfig(_globalConfig);\n\n    }\n\n\n\n    /**\n\n     * Match orders from one taker and multiple makers.\n\n     *\n\n     * @param takerOrderParam   Taker's order to match.\n\n     * @param makerOrderParams  Array of maker's order to match with.\n\n     * @param _perpetual        Address of perpetual contract.\n\n     * @param amounts           Array of matching amounts of each taker/maker pair.\n\n     */\n\n    function matchOrders(\n\n        LibOrder.OrderParam memory takerOrderParam,\n\n        LibOrder.OrderParam[] memory makerOrderParams,\n\n        address _perpetual,\n\n        uint256[] memory amounts\n\n    ) public {\n\n        require(globalConfig.brokers(msg.sender), \"unauthorized broker\");\n\n        require(amounts.length > 0 && makerOrderParams.length == amounts.length, \"no makers to match\");\n\n        require(!takerOrderParam.isMakerOnly(), \"taker order is maker only\");\n\n\n        IPerpetual perpetual = IPerpetual(_perpetual);\n\n        require(perpetual.status() == LibTypes.Status.NORMAL, \"wrong perpetual status\");\n\n\n        uint256 tradingLotSize = perpetual.getGovernance().tradingLotSize;\n\n        bytes32 takerOrderHash = validateOrderParam(perpetual, takerOrderParam);\n\n        uint256 takerFilledAmount = filled[takerOrderHash];\n\n        uint256 takerOpened;\n\n\n        for (uint256 i = 0; i < makerOrderParams.length; i++) {\n\n            if (amounts[i] == 0) {\n\n                continue;\n\n            }\n\n\n            require(takerOrderParam.trader != makerOrderParams[i].trader, \"self trade\");\n\n            require(takerOrderParam.isInversed() == makerOrderParams[i].isInversed(), \"invalid inversed pair\");\n\n            require(takerOrderParam.isSell() != makerOrderParams[i].isSell(), \"side must be long or short\");\n\n            require(!makerOrderParams[i].isMarketOrder(), \"market order cannot be maker\");\n\n\n            validatePrice(takerOrderParam, makerOrderParams[i]);\n\n\n            bytes32 makerOrderHash = validateOrderParam(perpetual, makerOrderParams[i]);\n\n            uint256 makerFilledAmount = filled[makerOrderHash];\n\n\n            require(amounts[i] <= takerOrderParam.amount.sub(takerFilledAmount), \"taker overfilled\");\n\n            require(amounts[i] <= makerOrderParams[i].amount.sub(makerFilledAmount), \"maker overfilled\");\n\n            require(amounts[i].mod(tradingLotSize) == 0, \"amount must be divisible by tradingLotSize\");\n\n\n            uint256 opened = fillOrder(perpetual, takerOrderParam, makerOrderParams[i], amounts[i]);\n\n\n            takerOpened = takerOp","after":", LibOrder.OrderParam takerOrderParam, uint256 amount);\n\n    event Cancel(bytes32 indexed orderHash);\n\n\n\n    constructor(address _globalConfig) public {\n\n        globalConfig = IGlobalConfig(_globalConfig);\n\n    }\n\n\n\n    /**\n\n     * Match orders from one taker and multiple makers.\n\n     *\n\n     * @param takerOrderParam   Taker's order to match.\n\n     * @param makerOrderParams  Array of maker's order to match with.\n\n     * @param _perpetual        Address of perpetual contract.\n\n     * @param amounts           Array of matching amounts of each taker/maker pair.\n\n     */\n\n    function matchOrders(\n\n        LibOrder.OrderParam memory takerOrderParam,\n\n        LibOrder.OrderParam[] memory makerOrderParams,\n\n        address _perpetual,\n\n        uint256[] memory amounts\n\n    ) public {\n\n        require(globalConfig.brokers(msg.sender), \"unauthorized broker\");\n\n        require(amounts.length > 0 && makerOrderParams.length == amounts.length, \"no makers to match\");\n\n        require(!takerOrderParam.isMakerOnly(), \"taker order is maker only\");\n\n\n        IPerpetual perpetual = IPerpetual(_perpetual);\n\n        require(perpetual.status() == LibTypes.Status.NORMAL, \"wrong perpetual status\");\n\n\n        uint256 tradingLotSize = perpetual.getGovernance().tradingLotSize;\n\n        bytes32 takerOrderHash = validateOrderParam(perpetual, takerOrderParam);\n\n        uint256 takerFilledAmount = filled[takerOrderHash];\n\n        uint256 takerOpened;\n\n\n        for (uint256 i = 0; i < makerOrderParams.length; i++) {\n\n            if (amounts[i] == 0) {\n\n                continue;\n\n            }\n\n\n            require(takerOrderParam.trader != makerOrderParams[i].trader, \"self trade\");\n\n            require(takerOrderParam.isInversed() == makerOrderParams[i].isInversed(), \"invalid inversed pair\");\n\n            require(takerOrderParam.isSell() != makerOrderParams[i].isSell(), \"side must be long or short\");\n\n            require(!makerOrderParams[i].isMarketOrder(), \"market order cannot be maker\");\n\n\n            validatePrice(takerOrderParam, makerOrderParams[i]);\n\n\n            bytes32 makerOrderHash = validateOrderParam(perpetual, makerOrderParams[i]);\n\n            uint256 makerFilledAmount = filled[makerOrderHash];\n\n\n            require(amounts[i] <= takerOrderParam.amount.sub(takerFilledAmount), \"taker overfilled\");\n\n            require(amounts[i] <= makerOrderParams[i].amount.sub(makerFilledAmount), \"maker overfilled\");\n\n            require(amounts[i].mod(tradingLotSize) == 0, \"amount must be divisible by tradingLotSize\");\n\n\n            uint256 opened = fillOrder(perpetual, takerOrderParam, makerOrderParams[i], amounts[i]);\n\n\n            takerOpened = takerOp","contract":"Exchange","time":1},{"type":"external-function ","before":"       } else {\n\n            require(perpetual.isSafe(takerOrderParam.trader), \"maker unsafe\");\n\n        }\n\n        require(perpetual.isSafe(msg.sender), \"broker unsafe\");\n\n\n        filled[takerOrderHash] = takerFilledAmount;\n\n    }\n\n\n\n    /**\n\n     * @dev Match orders from taker with amm. It is exactly same with directly trading from amm.\n\n     *\n\n     * @param takerOrderParam  Taker's order to match.\n\n     * @param _perpetual        Address of perpetual contract.\n\n     * @param amount           Amount to fiil.\n\n     * @return Opened position amount of taker.\n\n     */\n\n    function matchOrderWithAMM(\n\n        LibOrder.OrderParam memory takerOrderParam,\n\n        address _perpetual,\n\n        uint256 amount\n\n    ) public {\n\n        require(globalConfig.brokers(msg.sender), \"unauthorized broker\");\n\n        require(amount > 0, \"amount must be greater than 0\");\n\n        require(!takerOrderParam.isMakerOnly(), \"taker order is maker only\");\n\n\n        IPerpetual perpetual = IPerpetual(_perpetual);\n\n        IAMM amm = IAMM(perpetual.amm());\n\n\n        bytes32 takerOrderHash = validateOrderParam(perpetual, takerOrderParam);\n\n        uint256 takerFilledAmount = filled[takerOrderHash];\n\n        require(amount <= takerOrderParam.amount.sub(takerFilledAmount), \"taker overfilled\");\n\n\n        // trading with pool\n\n        uint256 takerOpened;\n\n        uint256 price","after":"       } else {\n\n            require(perpetual.isSafe(takerOrderParam.trader), \"maker unsafe\");\n\n        }\n\n        require(perpetual.isSafe(msg.sender), \"broker unsafe\");\n\n\n        filled[takerOrderHash] = takerFilledAmount;\n\n    }\n\n\n\n    /**\n\n     * @dev Match orders from taker with amm. It is exactly same with directly trading from amm.\n\n     *\n\n     * @param takerOrderParam  Taker's order to match.\n\n     * @param _perpetual        Address of perpetual contract.\n\n     * @param amount           Amount to fiil.\n\n     * @return Opened position amount of taker.\n\n     */\n\n    function matchOrderWithAMM(\n\n        LibOrder.OrderParam memory takerOrderParam,\n\n        address _perpetual,\n\n        uint256 amount\n\n    ) public {\n\n        require(globalConfig.brokers(msg.sender), \"unauthorized broker\");\n\n        require(amount > 0, \"amount must be greater than 0\");\n\n        require(!takerOrderParam.isMakerOnly(), \"taker order is maker only\");\n\n\n        IPerpetual perpetual = IPerpetual(_perpetual);\n\n        IAMM amm = IAMM(perpetual.amm());\n\n\n        bytes32 takerOrderHash = validateOrderParam(perpetual, takerOrderParam);\n\n        uint256 takerFilledAmount = filled[takerOrderHash];\n\n        require(amount <= takerOrderParam.amount.sub(takerFilledAmount), \"taker overfilled\");\n\n\n        // trading with pool\n\n        uint256 takerOpened;\n\n        uint256 price","contract":"Exchange","time":0},{"type":"external-function ","before":"(takerOrderParam.isSell()) {\n\n            takerOpened = amm.sellFromWhitelisted(\n\n                takerOrderParam.trader,\n\n                amount,\n\n                price,\n\n                expired\n\n            );\n\n        } else {\n\n            takerOpened = amm.buyFromWhitelisted(tak","after":"(takerOrderParam.isSell()) {\n\n            takerOpened = amm.sellFromWhitelisted(\n\n                takerOrderParam.trader,\n\n                amount,\n\n                price,\n\n                expired\n\n            );\n\n        } else {\n\n            takerOpened = amm.buyFromWhitelisted(tak","contract":"Exchange","time":0}]}