{"time":248,"results":[{"type":"loop-duplication","before":"\nstart line 1609 column 8, end line 1613 column 8\nfor (uint256 i = 0; i < 2; i++) {\n            if (_reserveTokens[i] == ETH_RESERVE_ADDRESS) {\n                require(_reserveAmounts[i] == msg.value, \"ERR_ETH_AMOUNT_MISMATCH\");\n            }\n        }\nstart line 1652 column 8, end line 1674 column 8\nfor (uint256 i = 0; i < 2; i++) {\n            IERC20Token reserveToken = _reserveTokens[i];\n            uint256 reserveAmount = reserveAmounts[i];\n            require(reserveAmount > 0, \"ERR_ZERO_TARGET_AMOUNT\");\n            assert(reserveAmount <= _reserveAmounts[i]);\n\n            // transfer each one of the reserve amounts from the user to the pool\n            if (reserveToken != ETH_RESERVE_ADDRESS) {\n                // ETH has already been transferred as part of the transaction\n                safeTransferFrom(reserveToken, msg.sender, address(this), reserveAmount);\n            } else if (_reserveAmounts[i] > reserveAmount) {\n                // transfer the extra amount of ETH back to the user\n                msg.sender.transfer(_reserveAmounts[i] - reserveAmount);\n            }\n\n            // save the new reserve balance\n            newReserveBalances[i] = oldReserveBalances[i].add(reserveAmount);\n\n            emit LiquidityAdded(msg.sender, reserveToken, reserveAmount, newReserveBalances[i], newPoolTokenSupply);\n\n            // dispatch the `TokenRateUpdate` event for the pool token\n            emit TokenRateUpdate(poolToken, reserveToken, newReserveBalances[i], newPoolTokenSupply);\n        }","after":"// merge loop\n\nstart line 1609 column 8, end line 1613 column 8\nfor (uint256 i = 0; i < 2; i++) {\n            if (_reserveTokens[i] == ETH_RESERVE_ADDRESS) {\n                require(_reserveAmounts[i] == msg.value, \"ERR_ETH_AMOUNT_MISMATCH\");\n            }\n        }\nstart line 1652 column 8, end line 1674 column 8\nfor (uint256 i = 0; i < 2; i++) {\n            IERC20Token reserveToken = _reserveTokens[i];\n            uint256 reserveAmount = reserveAmounts[i];\n            require(reserveAmount > 0, \"ERR_ZERO_TARGET_AMOUNT\");\n            assert(reserveAmount <= _reserveAmounts[i]);\n\n            // transfer each one of the reserve amounts from the user to the pool\n            if (reserveToken != ETH_RESERVE_ADDRESS) {\n                // ETH has already been transferred as part of the transaction\n                safeTransferFrom(reserveToken, msg.sender, address(this), reserveAmount);\n            } else if (_reserveAmounts[i] > reserveAmount) {\n                // transfer the extra amount of ETH back to the user\n                msg.sender.transfer(_reserveAmounts[i] - reserveAmount);\n            }\n\n            // save the new reserve balance\n            newReserveBalances[i] = oldReserveBalances[i].add(reserveAmount);\n\n            emit LiquidityAdded(msg.sender, reserveToken, reserveAmount, newReserveBalances[i], newPoolTokenSupply);\n\n            // dispatch the `TokenRateUpdate` event for the pool token\n            emit TokenRateUpdate(poolToken, reserveToken, newReserveBalances[i], newPoolTokenSupply);\n        }","contract":"StandardPoolConverter","time":0},{"type":"state-data-arrangement ","before":"\nIERC20Token private constant ETH_RESERVE_ADDRESS = IERC20Token(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\nuint256 private constant MAX_UINT128 = 2 ** 128 - 1;\nuint256 private constant MAX_UINT112 = 2 ** 112 - 1;\nuint256 private constant MAX_UINT32 = 2 ** 32 - 1;\nuint256 private constant AVERAGE_RATE_PERIOD = 10 minutes;\nuint32 private constant PPM_RESOLUTION = 1000000;\nuint256 private __reserveBalances;\nIERC20Token[] private __reserveTokens;\nmapping(IERC20Token => uint256) private __reserveIds;\nIConverterAnchor public override anchor;\nuint32 public override maxConversionFee;\nuint32 public override conversionFee;\nuint256 public averageRateInfo;","after":"IERC20Token private constant ETH_RESERVE_ADDRESS = IERC20Token(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\nuint256 private constant MAX_UINT128 = 2 ** 128 - 1;\nuint256 private constant MAX_UINT112 = 2 ** 112 - 1;\nuint256 private constant MAX_UINT32 = 2 ** 32 - 1;\nuint256 private constant AVERAGE_RATE_PERIOD = 10 minutes;\nuint256 private __reserveBalances;\nIERC20Token[] private __reserveTokens;\nmapping(IERC20Token => uint256) private __reserveIds;\nIConverterAnchor public override anchor;\nuint256 public averageRateInfo;\nuint32 private constant PPM_RESOLUTION = 1000000;\nuint32 public override maxConversionFee;\nuint32 public override conversionFee;\n","contract":"StandardPoolConverter","time":0},{"type":"external-function ","before":"function addLiquidityCost(\n        IERC20Token[] memory _reserveTokens,\n        uint256 _reserveTokenIndex,\n        uint256 _reserveAmount\n    ) public view returns (uint256[] memory) {\n        uint256[] memory _reserveAmounts = new uint256[](2);\n        uint256[] memory _reserveBalances = new uint256[](2);\n\n        uint256 reserve0Id = __reserveIds[_reserveTokens[0]];\n        uint256 reserve1Id = __reserveIds[_reserveTokens[1]];\n        (_reserveBalances[0], _reserveBalances[1]) = reserveBalances(reserve0Id, reserve1Id);\n\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\n        uint256 amount = fundSupplyAmount(totalSupply, _reserveBalances[_reserveTokenIndex], _reserveAmount);\n\n        for (uint256 i = 0; i < 2; i++) _reserveAmounts[i] = fundCost(totalSupply, _reserveBalances[i], amount);\n\n        return _reserveAmounts;\n    }","after":"function addLiquidityCost(\n        IERC20Token[] calldata _reserveTokens,\n        uint256 _reserveTokenIndex,\n        uint256 _reserveAmount\n    ) public view returns (uint256[] memory) {\n        uint256[] memory _reserveAmounts = new uint256[](2);\n        uint256[] memory _reserveBalances = new uint256[](2);\n\n        uint256 reserve0Id = __reserveIds[_reserveTokens[0]];\n        uint256 reserve1Id = __reserveIds[_reserveTokens[1]];\n        (_reserveBalances[0], _reserveBalances[1]) = reserveBalances(reserve0Id, reserve1Id);\n\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\n        uint256 amount = fundSupplyAmount(totalSupply, _reserveBalances[_reserveTokenIndex], _reserveAmount);\n\n        for (uint256 i = 0; i < 2; i++) _reserveAmounts[i] = fundCost(totalSupply, _reserveBalances[i], amount);\n\n        return _reserveAmounts;\n    }","contract":"StandardPoolConverter","time":0},{"type":"external-function ","before":"function removeLiquidityReturn(uint256 _amount, IERC20Token[] memory _reserveTokens)\n    public\n    view\n    returns (uint256[] memory)\n    {\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\n        return removeLiquidityReserveAmounts(_amount, _reserveTokens, totalSupply);\n    }","after":"function removeLiquidityReturn(uint256 _amount, IERC20Token[] calldata _reserveTokens)\n    public\n    view\n    returns (uint256[] memory)\n    {\n        uint256 totalSupply = IDSToken(address(anchor)).totalSupply();\n        return removeLiquidityReserveAmounts(_amount, _reserveTokens, totalSupply);\n    }","contract":"StandardPoolConverter","time":0},{"type":"immutable-restrict-modification ","before":"uint32 public override maxConversionFee;","after":"uint32 public override immutable maxConversionFee;","contract":"StandardPoolConverter","time":2}]}