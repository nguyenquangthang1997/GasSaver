{"time":1843,"results":[{"type":"struct-data-arrangement ","before":"\naddress voter\nuint tokens\nuint claimId\nint8 verdict\nbool rewardClaimed","after":"uint tokens\nuint claimId\naddress voter\nint8 verdict\nbool rewardClaimed\n","contract":"ClaimsData","time":0},{"type":"loop-duplication","before":"\nstart line 2139 column 8, end line 2160 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n            voteid = cd.getVoteAddressCA(msg.sender, i);\n            (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n                lastClaimed = i;\n            }\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n            if (perc > 0 && !claimed) {\n                counter++;\n                cd.setRewardClaimed(voteid, true);\n            } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\n                (perc,,) = cd.getClaimRewardDetail(claimId);\n                if (perc == 0) {\n                    counter++;\n                }\n                cd.setRewardClaimed(voteid, true);\n            }\n            if (tokenForVoteId > 0) {\n                total = tokenForVoteId.add(total);\n            }\n        }\nstart line 2176 column 8, end line 2190 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n            voteid = cd.getVoteAddressMember(msg.sender, i);\n            (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n                lastClaimed = i;\n            }\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n            if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\n                cd.setRewardClaimed(voteid, true);\n                counter++;\n            }\n            if (tokenForVoteId > 0) {\n                total = tokenForVoteId.add(total);\n            }\n        }","after":"// merge loop\n\nstart line 2139 column 8, end line 2160 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n            voteid = cd.getVoteAddressCA(msg.sender, i);\n            (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n                lastClaimed = i;\n            }\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n            if (perc > 0 && !claimed) {\n                counter++;\n                cd.setRewardClaimed(voteid, true);\n            } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\n                (perc,,) = cd.getClaimRewardDetail(claimId);\n                if (perc == 0) {\n                    counter++;\n                }\n                cd.setRewardClaimed(voteid, true);\n            }\n            if (tokenForVoteId > 0) {\n                total = tokenForVoteId.add(total);\n            }\n        }\nstart line 2176 column 8, end line 2190 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n            voteid = cd.getVoteAddressMember(msg.sender, i);\n            (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n                lastClaimed = i;\n            }\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n            if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\n                cd.setRewardClaimed(voteid, true);\n                counter++;\n            }\n            if (tokenForVoteId > 0) {\n                total = tokenForVoteId.add(total);\n            }\n        }","contract":"ClaimsReward","time":0},{"type":"immutable-restrict-modification ","before":"address public DAI;","after":"address public immutable DAI;","contract":"ClaimsReward","time":0},{"type":"state-data-arrangement ","before":"\nProposalVote[] internal allVotes;\nDelegateVote[] public allDelegation;\nmapping(uint => ProposalData) internal allProposalData;\nmapping(uint => bytes[]) internal allProposalSolutions;\nmapping(address => uint[]) internal allVotesByMember;\nmapping(uint => mapping(address => bool)) public rewardClaimed;\nmapping(address => mapping(uint => uint)) public memberProposalVote;\nmapping(address => uint) public followerDelegation;\nmapping(address => uint) internal followerCount;\nmapping(address => uint[]) internal leaderDelegation;\nmapping(uint => VoteTally) public proposalVoteTally;\nmapping(address => bool) public isOpenForDelegation;\nmapping(address => uint) public lastRewardClaimed;\nbool internal constructorCheck;\nuint public tokenHoldingTime;\nuint internal roleIdAllowedToCatgorize;\nuint internal maxVoteWeigthPer;\nuint internal specialResolutionMajPerc;\nuint internal maxFollowers;\nuint internal totalProposals;\nuint internal maxDraftTime;\nMemberRoles internal memberRole;\nProposalCategory internal proposalCategory;\nTokenController internal tokenInstance;\nmapping(uint => uint) public proposalActionStatus;\nmapping(uint => uint) internal proposalExecutionTime;\nmapping(uint => mapping(address => bool)) public proposalRejectedByAB;\nmapping(uint => uint) internal actionRejectedCount;\nbool internal actionParamsInitialised;\nuint internal actionWaitingTime;\nuint constant internal AB_MAJ_TO_REJECT_ACTION = 3;","after":"ProposalVote[] internal allVotes;\nDelegateVote[] public allDelegation;\nmapping(uint => ProposalData) internal allProposalData;\nmapping(uint => bytes[]) internal allProposalSolutions;\nmapping(address => uint[]) internal allVotesByMember;\nmapping(uint => mapping(address => bool)) public rewardClaimed;\nmapping(address => mapping(uint => uint)) public memberProposalVote;\nmapping(address => uint) public followerDelegation;\nmapping(address => uint) internal followerCount;\nmapping(address => uint[]) internal leaderDelegation;\nmapping(uint => VoteTally) public proposalVoteTally;\nmapping(address => bool) public isOpenForDelegation;\nmapping(address => uint) public lastRewardClaimed;\nuint public tokenHoldingTime;\nuint internal roleIdAllowedToCatgorize;\nuint internal maxVoteWeigthPer;\nuint internal specialResolutionMajPerc;\nuint internal maxFollowers;\nuint internal totalProposals;\nuint internal maxDraftTime;\nMemberRoles internal memberRole;\nProposalCategory internal proposalCategory;\nTokenController internal tokenInstance;\nmapping(uint => uint) public proposalActionStatus;\nmapping(uint => uint) internal proposalExecutionTime;\nmapping(uint => mapping(address => bool)) public proposalRejectedByAB;\nmapping(uint => uint) internal actionRejectedCount;\nuint internal actionWaitingTime;\nuint constant internal AB_MAJ_TO_REJECT_ACTION = 3;\nbool internal constructorCheck;\nbool internal actionParamsInitialised;\n","contract":"Governance","time":0},{"type":"constant-restrict-modification  ","before":"bool internal constructorCheck;","after":"bool internal constant constructorCheck;","contract":"Governance","time":0},{"type":"constant-restrict-modification  ","before":"uint internal roleIdAllowedToCatgorize;","after":"uint internal constant roleIdAllowedToCatgorize;","contract":"Governance","time":0},{"type":"constant-restrict-modification  ","before":"uint internal maxVoteWeigthPer;","after":"uint internal constant maxVoteWeigthPer;","contract":"Governance","time":0},{"type":"constant-restrict-modification  ","before":"uint internal specialResolutionMajPerc;","after":"uint internal constant specialResolutionMajPerc;","contract":"Governance","time":0},{"type":"constant-restrict-modification  ","before":"address public tokenAddress;","after":"address public constant tokenAddress;","contract":"INXMMaster","time":0},{"type":"constant-restrict-modification  ","before":"address public owner;","after":"address public constant owner;","contract":"INXMMaster","time":0},{"type":"constant-restrict-modification  ","before":"uint public pauseTime;","after":"uint public constant pauseTime;","contract":"INXMMaster","time":0},{"type":"constant-restrict-modification  ","before":"uint96 _unused;","after":"uint96 constant _unused;","contract":"MCR","time":0},{"type":"state-data-arrangement ","before":"\nTokenController public tc;\nTokenData internal td;\nQuotationData internal qd;\nClaimsReward internal cr;\nGovernance internal gv;\nTokenFunctions internal tf;\nNXMToken public tk;\nMemberRoleDetails[] internal memberRoleData;\nbool internal constructorCheck;\nuint public maxABCount;\nbool public launched;\nuint public launchedOn;\nmapping(address => address payable) internal claimPayoutAddress;","after":"TokenController public tc;\nTokenData internal td;\nQuotationData internal qd;\nClaimsReward internal cr;\nGovernance internal gv;\nTokenFunctions internal tf;\nNXMToken public tk;\nMemberRoleDetails[] internal memberRoleData;\nuint public maxABCount;\nuint public launchedOn;\nmapping(address => address payable) internal claimPayoutAddress;\nbool internal constructorCheck;\nbool public launched;\n","contract":"MemberRoles","time":0},{"type":"external-function ","before":"function addRole(//solhint-disable-line\n        bytes32 _roleName,\n        string memory _roleDescription,\n        address _authorized\n    )\n    public\n    onlyAuthorizedToGovern {\n        _addRole(_roleName, _roleDescription, _authorized);\n    }","after":"function addRole(//solhint-disable-line\n        bytes32 _roleName,\n        string calldata _roleDescription,\n        address _authorized\n    )\n    public\n    onlyAuthorizedToGovern {\n        _addRole(_roleName, _roleDescription, _authorized);\n    }","contract":"MemberRoles","time":0},{"type":"external-function ","before":"function addMembersBeforeLaunch(address[] memory userArray, uint[] memory tokens) public onlyOwner {\n        require(!launched);\n\n        for (uint i = 0; i < userArray.length; i++) {\n            require(!ms.isMember(userArray[i]));\n            tc.addToWhitelist(userArray[i]);\n            _updateRole(userArray[i], uint(Role.Member), true);\n            tc.mint(userArray[i], tokens[i]);\n        }\n        launched = true;\n        launchedOn = now;\n\n    }","after":"function addMembersBeforeLaunch(address[] calldata userArray, uint[] calldata tokens) public onlyOwner {\n        require(!launched);\n\n        for (uint i = 0; i < userArray.length; i++) {\n            require(!ms.isMember(userArray[i]));\n            tc.addToWhitelist(userArray[i]);\n            _updateRole(userArray[i], uint(Role.Member), true);\n            tc.mint(userArray[i], tokens[i]);\n        }\n        launched = true;\n        launchedOn = now;\n\n    }","contract":"MemberRoles","time":0},{"type":"constant-restrict-modification  ","before":"string public name = \"NXM\";","after":"string public constant name = \"NXM\";","contract":"NXMToken","time":1},{"type":"constant-restrict-modification  ","before":"string public symbol = \"NXM\";","after":"string public constant symbol = \"NXM\";","contract":"NXMToken","time":1},{"type":"constant-restrict-modification  ","before":"uint8 public decimals = 18;","after":"uint8 public constant decimals = 18;","contract":"NXMToken","time":1},{"type":"external-function ","before":"function makeCoverBegin(\n        address smartCAdd,\n        bytes4 coverCurr,\n        uint[] memory coverDetails,\n        uint16 coverPeriod,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public payable onlyMember whenNotPaused {\n\n        require(coverCurr == \"ETH\", \"Pool: Unexpected asset type\");\n        require(msg.value == coverDetails[1], \"Pool: ETH amount does not match premium\");\n\n        quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n    }","after":"function makeCoverBegin(\n        address smartCAdd,\n        bytes4 coverCurr,\n        uint[] calldata coverDetails,\n        uint16 coverPeriod,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public payable onlyMember whenNotPaused {\n\n        require(coverCurr == \"ETH\", \"Pool: Unexpected asset type\");\n        require(msg.value == coverDetails[1], \"Pool: ETH amount does not match premium\");\n\n        quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n    }","contract":"Pool","time":0},{"type":"external-function ","before":"function makeCoverUsingCA(\n        address smartCAdd,\n        bytes4 coverCurr,\n        uint[] memory coverDetails,\n        uint16 coverPeriod,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public onlyMember whenNotPaused {\n        require(coverCurr != \"ETH\", \"Pool: Unexpected asset type\");\n        quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n    }","after":"function makeCoverUsingCA(\n        address smartCAdd,\n        bytes4 coverCurr,\n        uint[] calldata coverDetails,\n        uint16 coverPeriod,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public onlyMember whenNotPaused {\n        require(coverCurr != \"ETH\", \"Pool: Unexpected asset type\");\n        quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n    }","contract":"Pool","time":0},{"type":"constant-restrict-modification  ","before":"address public swapController;","after":"address public constant swapController;","contract":"Pool","time":1},{"type":"immutable-restrict-modification ","before":"tors;\n    address public d","after":"tors;\n    address public d","contract":"PriceFeedOracle","time":0},{"type":"immutable-restrict-modification ","before":"ress;\n    address pub","after":"ress;\n    address pub","contract":"PriceFeedOracle","time":0},{"type":"state-data-arrangement ","before":"\nle {\n\n    bool public constru\nheck;\n    MemberRoles in\n   }\n\n    CategoryStruct[] internal al\ngory;\n    mapping(uint => CategoryAction) internal categoryA\nData;\n    mapping(uint => uint) public cate\nBReq;\n    mapping(uint => uint) public isSpecialR\ntion;\n    mapping(uint => bytes) public categoryAct\nhes;\n\n    bool public categoryActionHa","after":"heck;\n    MemberRoles in\n   }\n\n    CategoryStruct[] internal al\ngory;\n    mapping(uint => CategoryAction) internal categoryA\nData;\n    mapping(uint => uint) public cate\nBReq;\n    mapping(uint => uint) public isSpecialR\ntion;\n    mapping(uint => bytes) public categoryAct\nle {\n\n    bool public constru\nhes;\n\n    bool public categoryActionHa\n","contract":"ProposalCategory","time":0},{"type":"external-function ","before":"\n  */\n    function newCategory(\n        string memory _name,\n        uint _memberRoleToVote,\n        uint _majorityVotePerc,\n        uint _quorumPerc,\n        uint[] memory _allowedToCreateProposal,\n        uint _closingTime,\n        string memory _actionHash,\n        address _contractAddress,\n        bytes2 _contractName,\n        uint[] memory _incentives,\n        string memory _functionHash\n    )\n    public\n    onlyAuthorizedToGovern\n    {\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n        //If category is special resolution role authorized should be member\n        if (_incentives[3] == 1) {\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n            _majorityVotePerc = 0;\n            _quorumPerc = 0;\n        }\n\n        _addCategory(\n            _name,\n            _memberRoleToVote,\n            _majorityVotePerc,\n            _quorumPerc,\n            _allowedToCreateProposal,\n            _closingTime,\n            _actionHash,\n            _contractAddress,\n            _contractName,\n            _incentives\n        );\n\n\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n            categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);\n     ","after":"\n  */\n    function newCategory(\n        string calldata _name,\n        uint _memberRoleToVote,\n        uint _majorityVotePerc,\n        uint _quorumPerc,\n        uint[] calldata _allowedToCreateProposal,\n        uint _closingTime,\n        string calldata _actionHash,\n        address _contractAddress,\n        bytes2 _contractName,\n        uint[] calldata _incentives,\n        string calldata _functionHash\n    )\n    public\n    onlyAuthorizedToGovern\n    {\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n        //If category is special resolution role authorized should be member\n        if (_incentives[3] == 1) {\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n            _majorityVotePerc = 0;\n            _quorumPerc = 0;\n        }\n\n        _addCategory(\n            _name,\n            _memberRoleToVote,\n            _majorityVotePerc,\n            _quorumPerc,\n            _allowedToCreateProposal,\n            _closingTime,\n            _actionHash,\n            _contractAddress,\n            _contractName,\n            _incentives\n        );\n\n\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n            categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);\n     ","contract":"ProposalCategory","time":0},{"type":"external-function ","before":"\n  */\n    function editCategory(\n        uint _categoryId,\n        string memory _name,\n        uint _memberRoleToVote,\n        uint _majorityVotePerc,\n        uint _quorumPerc,\n        uint[] memory _allowedToCreateProposal,\n        uint _closingTime,\n        string memory _actionHash,\n        address _contractAddress,\n        bytes2 _contractName,\n        uint[] memory _incentives,\n        string memory _functionHash\n    )\n    public\n    onlyAuthorizedToGovern\n    {\n        require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n        //If category is special resolution role authorized should be member\n        if (_incentives[3] == 1) {\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n            _majorityVotePerc = 0;\n            _quorumPerc = 0;\n        }\n\n        delete categoryActionHashes[_categoryId];\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n            categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\n        }\n        allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\n        allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\n        allCategory[_categoryId].closingTime = _closingTime;\n        allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\n        allCategory[_categoryId].minStake = _incentives[0];\n        allCategory[_categoryId].quorumPerc = _quorumPerc;\n        categoryActionData[_categoryId].defaultIncentive = _incentives[1];\n        categoryActionData[_categoryId].contractName = _contractName;\n        categoryActionData[_categoryId].contractAddress = _contractAddress;\n        categoryABReq[_categoryId] = _incentives[2];\n        isSpecialResolution[_categoryId] = _incentives[3];\n        emit Category(_categoryId, _name, _actionHa","after":"\n  */\n    function editCategory(\n        uint _categoryId,\n        string calldata _name,\n        uint _memberRoleToVote,\n        uint _majorityVotePerc,\n        uint _quorumPerc,\n        uint[] calldata _allowedToCreateProposal,\n        uint _closingTime,\n        string calldata _actionHash,\n        address _contractAddress,\n        bytes2 _contractName,\n        uint[] calldata _incentives,\n        string calldata _functionHash\n    )\n    public\n    onlyAuthorizedToGovern\n    {\n        require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n        //If category is special resolution role authorized should be member\n        if (_incentives[3] == 1) {\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n            _majorityVotePerc = 0;\n            _quorumPerc = 0;\n        }\n\n        delete categoryActionHashes[_categoryId];\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n            categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\n        }\n        allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\n        allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\n        allCategory[_categoryId].closingTime = _closingTime;\n        allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\n        allCategory[_categoryId].minStake = _incentives[0];\n        allCategory[_categoryId].quorumPerc = _quorumPerc;\n        categoryActionData[_categoryId].defaultIncentive = _incentives[1];\n        categoryActionData[_categoryId].contractName = _contractName;\n        categoryActionData[_categoryId].contractAddress = _contractAddress;\n        categoryABReq[_categoryId] = _incentives[2];\n        isSpecialResolution[_categoryId] = _incentives[3];\n        emit Category(_categoryId, _name, _actionHa","contract":"ProposalCategory","time":0},{"type":"constant-restrict-modification  ","before":"le {\n\n    bool public constru","after":"le {\n\n    bool public constru","contract":"ProposalCategory","time":0},{"type":"external-function ","before":"   */\n    function verifyCoverDetails(\n        address payable from,\n        address scAddress,\n        bytes4 coverCurr,\n        uint[] memory coverDetails,\n        uint16 coverPeriod,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public onlyInternal {\n        _verifyCoverDetails(\n            from,\n            scAddress,\n            coverCurr,\n            coverDetails,\n            coverPeriod,\n            _v,\n            _r,\n            _s,\n            false\n      ","after":"   */\n    function verifyCoverDetails(\n        address payable from,\n        address scAddress,\n        bytes4 coverCurr,\n        uint[] calldata coverDetails,\n        uint16 coverPeriod,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public onlyInternal {\n        _verifyCoverDetails(\n            from,\n            scAddress,\n            coverCurr,\n            coverDetails,\n            coverPeriod,\n            _v,\n            _r,\n            _s,\n            false\n      ","contract":"Quotation","time":0},{"type":"struct-data-arrangement ","before":"\n{\n        address payable mem\n;\n        bytes4 cu\n;\n        uint \n;\n        uint16 c\n;\n        uint \n;\n        address\n;\n        uint ","after":";\n        uint \n;\n        uint \n;\n        uint \n{\n        address payable mem\n;\n        address\n;\n        bytes4 cu\n;\n        uint16 c\n","contract":"QuotationData","time":0},{"type":"struct-data-arrangement ","before":"\n{\n        uint h\n;\n        address payable u\n;\n        address\n;\n        bytes4\n;\n        uint[] co\n;\n        uint16 c","after":"{\n        uint h\n;\n        uint[] co\n;\n        address payable u\n;\n        address\n;\n        bytes4\n;\n        uint16 c\n","contract":"QuotationData","time":0}]}