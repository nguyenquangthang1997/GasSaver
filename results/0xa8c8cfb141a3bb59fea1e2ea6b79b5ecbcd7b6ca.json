{"time":105,"results":[{"type":"state-data-arrangement ","before":"\n   string public constant name = \"NOIA Toke\n   string public constant symbol = \"NOI\n   uint8 public constant decimals = uint8(1\n   uint256 public tokensToMint = 1000000000e\n   address public burnAddre\n   mapping(address => bool) public noti\n   mapping(bytes32 => bool) private hashedT\n   bool public etherlessTransferEnabled = tr","after":"   string public constant name = \"NOIA Toke\n   string public constant symbol = \"NOI\n   uint256 public tokensToMint = 1000000000e\n   mapping(address => bool) public noti\n   mapping(bytes32 => bool) private hashedT\n   address public burnAddre\n   uint8 public constant decimals = uint8(1\n   bool public etherlessTransferEnabled = tr\n","contract":"NOIAToken","time":0},{"type":"external-function ","before":"   function transferPreSigned(\n\n        bytes memory _signature,\n\n        address _to,\n\n        uint256 _value,\n\n        uint256 _fee,\n\n        uint256 _nonce\n\n    )\n\n    public\n\n    onlyEtherlessTransferEnabled\n\n    returns (bool)\n\n    {\n\n        require(_to != address(0), \"Transfer to the zero address\");\n\n\n        bytes32 hashedParams = hashForSign(msg.sig, address(this), _to, _value, _fee, _nonce);\n\n        address from = hashedParams.toEthSignedMessageHash().recover(_signature);\n\n        require(from != address(0), \"Invalid signature\");\n\n\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\n\n        require(hashedTxs[hashedTx] == false, \"Nonce already used\");\n\n        hashedTxs[hashedTx] = true;\n\n\n        if (msg.sender == _to) {\n\n            _transfer(from, _to, _value.add(_fee));\n\n            _postTransfer(from, _to, _value.add(_fee));\n\n        } else {\n\n            _transfer(from, _to, _value);\n\n            _postTransfer(from, _to, _value);\n\n            _transfer(from, msg.sender, _fee);\n\n            _postTransfer(from, msg.sender, _fee);\n\n        }\n\n\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\n\n        return true;\n\n  ","after":"   function transferPreSigned(\n\n        bytes calldata _signature,\n\n        address _to,\n\n        uint256 _value,\n\n        uint256 _fee,\n\n        uint256 _nonce\n\n    )\n\n    public\n\n    onlyEtherlessTransferEnabled\n\n    returns (bool)\n\n    {\n\n        require(_to != address(0), \"Transfer to the zero address\");\n\n\n        bytes32 hashedParams = hashForSign(msg.sig, address(this), _to, _value, _fee, _nonce);\n\n        address from = hashedParams.toEthSignedMessageHash().recover(_signature);\n\n        require(from != address(0), \"Invalid signature\");\n\n\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\n\n        require(hashedTxs[hashedTx] == false, \"Nonce already used\");\n\n        hashedTxs[hashedTx] = true;\n\n\n        if (msg.sender == _to) {\n\n            _transfer(from, _to, _value.add(_fee));\n\n            _postTransfer(from, _to, _value.add(_fee));\n\n        } else {\n\n            _transfer(from, _to, _value);\n\n            _postTransfer(from, _to, _value);\n\n            _transfer(from, msg.sender, _fee);\n\n            _postTransfer(from, msg.sender, _fee);\n\n        }\n\n\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\n\n        return true;\n\n  ","contract":"NOIAToken","time":0}]}