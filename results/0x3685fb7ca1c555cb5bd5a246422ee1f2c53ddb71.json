{"time":341,"results":[{"type":"state-data-arrangement ","before":"\nIERC20 public token;\nIYearn public earn;\nIYvault public vault;\nuint256 private constant MAX_UNIT = 2 ** 256 - 2;\nmapping(address => uint256) private earnDepositBalance;\nmapping(address => uint256) private vaultDepositBalance;\nuint256 public pool;\naddress public treasuryWallet = 0x59E83877bD248cBFe392dbB5A8a29959bcb48592;\naddress public communityWallet = 0xdd6c35aFF646B2fB7d8A8955Ccbe0994409348d0;\nuint256[] public networkFeeTier2 = [50000e18 + 1, 100000e18];\nuint256 public customNetworkFeeTier = 1000000e18;\nuint256 public constant DENOMINATOR = 10000;\nuint256[] public networkFeePercentage = [100, 75, 50];\nuint256 public customNetworkFeePercentage = 25;\nuint256 public profileSharingFeePercentage = 1000;\nuint256 public constant treasuryFee = 5000;\nuint256 public constant communityFee = 5000;\nbool public isVesting;\nIDaoVault public daoVault;","after":"IERC20 public token;\nIYearn public earn;\nIYvault public vault;\nuint256 private constant MAX_UNIT = 2 ** 256 - 2;\nmapping(address => uint256) private earnDepositBalance;\nmapping(address => uint256) private vaultDepositBalance;\nuint256 public pool;\nuint256[] public networkFeeTier2 = [50000e18 + 1, 100000e18];\nuint256 public customNetworkFeeTier = 1000000e18;\nuint256 public constant DENOMINATOR = 10000;\nuint256[] public networkFeePercentage = [100, 75, 50];\nuint256 public customNetworkFeePercentage = 25;\nuint256 public profileSharingFeePercentage = 1000;\nuint256 public constant treasuryFee = 5000;\nuint256 public constant communityFee = 5000;\nIDaoVault public daoVault;\naddress public treasuryWallet = 0x59E83877bD248cBFe392dbB5A8a29959bcb48592;\naddress public communityWallet = 0xdd6c35aFF646B2fB7d8A8955Ccbe0994409348d0;\nbool public isVesting;\n","contract":"YearnFarmerDAIv2","time":0},{"type":"external-function ","before":"function deposit(uint256[] memory _amounts) public {\n        require(!isVesting, \"Contract in vesting state\");\n        require(msg.sender == address(daoVault), \"Only can call from Vault\");\n        require(_amounts[0] > 0 || _amounts[1] > 0, \"Amount must > 0\");\n\n        uint256 _earnAmount = _amounts[0];\n        uint256 _vaultAmount = _amounts[1];\n        uint256 _depositAmount = _earnAmount.add(_vaultAmount);\n        token.safeTransferFrom(tx.origin, address(this), _depositAmount);\n\n        uint256 _earnNetworkFee;\n        uint256 _vaultNetworkFee;\n        uint256 _networkFeePercentage;\n        /**\n         * Network fees\n         * networkFeeTier2 is used to set each tier minimun and maximun\n         * For example networkFeeTier2 is [50000, 100000],\n         * Tier 1 = _depositAmount < 50001\n         * Tier 2 = 50001 <= _depositAmount <= 100000\n         * Tier 3 = _depositAmount > 100000\n         *\n         * networkFeePercentage is used to set each tier network fee percentage\n         * For example networkFeePercentage is [100, 75, 50]\n         * which mean network fee for Tier 1 = 1%, Tier 2 = 0.75%, Tier 3 = 0.5%\n         *\n         * customNetworkFeeTier is set before network fee tier 3\n         * customNetworkFeepercentage will be used if _depositAmount over customNetworkFeeTier before network fee tier 3\n         */\n        if (_depositAmount < networkFeeTier2[0]) {\n            // Tier 1\n            _networkFeePercentage = networkFeePercentage[0];\n        } else if (_depositAmount >= networkFeeTier2[0] && _depositAmount <= networkFeeTier2[1]) {\n            // Tier 2\n            _networkFeePercentage = networkFeePercentage[1];\n        } else if (_depositAmount >= customNetworkFeeTier) {\n            // Custom tier\n            _networkFeePercentage = customNetworkFeePercentage;\n        } else {\n            // Tier 3\n            _networkFeePercentage = networkFeePercentage[2];\n        }\n\n        // Deposit to Yearn Earn after fee\n        if (_earnAmount > 0) {\n            _earnNetworkFee = _earnAmount.mul(_networkFeePercentage).div(DENOMINATOR);\n            _earnAmount = _earnAmount.sub(_earnNetworkFee);\n            earn.deposit(_earnAmount);\n            earnDepositBalance[tx.origin] = earnDepositBalance[tx.origin].add(_earnAmount);\n        }\n\n        // Deposit to Yearn Vault after fee\n        if (_vaultAmount > 0) {\n            _vaultNetworkFee = _vaultAmount.mul(_networkFeePercentage).div(DENOMINATOR);\n            _vaultAmount = _vaultAmount.sub(_vaultNetworkFee);\n            vault.deposit(_vaultAmount);\n            vaultDepositBalance[tx.origin] = vaultDepositBalance[tx.origin].add(_vaultAmount);\n        }\n\n        // Transfer network fee to treasury and community wallet\n        uint _totalNetworkFee = _earnNetworkFee.add(_vaultNetworkFee);\n        token.safeTransfer(treasuryWallet, _totalNetworkFee.mul(treasuryFee).div(DENOMINATOR));\n        token.safeTransfer(communityWallet, _totalNetworkFee.mul(treasuryFee).div(DENOMINATOR));\n\n        uint256 _totalAmount = _earnAmount.add(_vaultAmount);\n        uint256 _shares;\n        _shares = totalSupply() == 0 ? _totalAmount : _totalAmount.mul(totalSupply()).div(pool);\n        _mint(address(daoVault), _shares);\n        pool = pool.add(_totalAmount);\n    }","after":"function deposit(uint256[] calldata _amounts) public {\n        require(!isVesting, \"Contract in vesting state\");\n        require(msg.sender == address(daoVault), \"Only can call from Vault\");\n        require(_amounts[0] > 0 || _amounts[1] > 0, \"Amount must > 0\");\n\n        uint256 _earnAmount = _amounts[0];\n        uint256 _vaultAmount = _amounts[1];\n        uint256 _depositAmount = _earnAmount.add(_vaultAmount);\n        token.safeTransferFrom(tx.origin, address(this), _depositAmount);\n\n        uint256 _earnNetworkFee;\n        uint256 _vaultNetworkFee;\n        uint256 _networkFeePercentage;\n        /**\n         * Network fees\n         * networkFeeTier2 is used to set each tier minimun and maximun\n         * For example networkFeeTier2 is [50000, 100000],\n         * Tier 1 = _depositAmount < 50001\n         * Tier 2 = 50001 <= _depositAmount <= 100000\n         * Tier 3 = _depositAmount > 100000\n         *\n         * networkFeePercentage is used to set each tier network fee percentage\n         * For example networkFeePercentage is [100, 75, 50]\n         * which mean network fee for Tier 1 = 1%, Tier 2 = 0.75%, Tier 3 = 0.5%\n         *\n         * customNetworkFeeTier is set before network fee tier 3\n         * customNetworkFeepercentage will be used if _depositAmount over customNetworkFeeTier before network fee tier 3\n         */\n        if (_depositAmount < networkFeeTier2[0]) {\n            // Tier 1\n            _networkFeePercentage = networkFeePercentage[0];\n        } else if (_depositAmount >= networkFeeTier2[0] && _depositAmount <= networkFeeTier2[1]) {\n            // Tier 2\n            _networkFeePercentage = networkFeePercentage[1];\n        } else if (_depositAmount >= customNetworkFeeTier) {\n            // Custom tier\n            _networkFeePercentage = customNetworkFeePercentage;\n        } else {\n            // Tier 3\n            _networkFeePercentage = networkFeePercentage[2];\n        }\n\n        // Deposit to Yearn Earn after fee\n        if (_earnAmount > 0) {\n            _earnNetworkFee = _earnAmount.mul(_networkFeePercentage).div(DENOMINATOR);\n            _earnAmount = _earnAmount.sub(_earnNetworkFee);\n            earn.deposit(_earnAmount);\n            earnDepositBalance[tx.origin] = earnDepositBalance[tx.origin].add(_earnAmount);\n        }\n\n        // Deposit to Yearn Vault after fee\n        if (_vaultAmount > 0) {\n            _vaultNetworkFee = _vaultAmount.mul(_networkFeePercentage).div(DENOMINATOR);\n            _vaultAmount = _vaultAmount.sub(_vaultNetworkFee);\n            vault.deposit(_vaultAmount);\n            vaultDepositBalance[tx.origin] = vaultDepositBalance[tx.origin].add(_vaultAmount);\n        }\n\n        // Transfer network fee to treasury and community wallet\n        uint _totalNetworkFee = _earnNetworkFee.add(_vaultNetworkFee);\n        token.safeTransfer(treasuryWallet, _totalNetworkFee.mul(treasuryFee).div(DENOMINATOR));\n        token.safeTransfer(communityWallet, _totalNetworkFee.mul(treasuryFee).div(DENOMINATOR));\n\n        uint256 _totalAmount = _earnAmount.add(_vaultAmount);\n        uint256 _shares;\n        _shares = totalSupply() == 0 ? _totalAmount : _totalAmount.mul(totalSupply()).div(pool);\n        _mint(address(daoVault), _shares);\n        pool = pool.add(_totalAmount);\n    }","contract":"YearnFarmerDAIv2","time":0},{"type":"external-function ","before":"function withdraw(uint256[] memory _shares) external {\n        require(!isVesting, \"Contract in vesting state\");\n        require(msg.sender == address(daoVault), \"Only can call from Vault\");\n\n        if (_shares[0] > 0) {\n            _withdrawEarn(_shares[0]);\n        }\n\n        if (_shares[1] > 0) {\n            _withdrawVault(_shares[1]);\n        }\n    }","after":"function withdraw(uint256[] calldata _shares) external {\n        require(!isVesting, \"Contract in vesting state\");\n        require(msg.sender == address(daoVault), \"Only can call from Vault\");\n\n        if (_shares[0] > 0) {\n            _withdrawEarn(_shares[0]);\n        }\n\n        if (_shares[1] > 0) {\n            _withdrawVault(_shares[1]);\n        }\n    }","contract":"YearnFarmerDAIv2","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"YearnFarmerDAIv2","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"YearnFarmerDAIv2","time":0}]}