{"time":124,"results":[{"type":"state-data-arrangement ","before":"\nbool internal initialized_;\nbool internal preparedForMigration_;\nmapping(address => bool) public isPeer;\nuint public peersCount;\nmapping(bytes32 => bool) public used;\nmapping(address => bool) public _uniqueAddresses;\nmapping(address => bool) public acceptedEthTokens;\nmapping(bytes32 => address) public _sidechainTokens;\nmapping(address => bytes32) public _sidechainTokensByAddress;\naddress[] public _sidechainTokenAddressArray;\naddress public _addressVAL;\naddress public _addressXOR;\nbytes32 public _networkId;","after":"mapping(address => bool) public isPeer;\nuint public peersCount;\nmapping(bytes32 => bool) public used;\nmapping(address => bool) public _uniqueAddresses;\nmapping(address => bool) public acceptedEthTokens;\nmapping(bytes32 => address) public _sidechainTokens;\nmapping(address => bytes32) public _sidechainTokensByAddress;\naddress[] public _sidechainTokenAddressArray;\nbytes32 public _networkId;\naddress public _addressVAL;\naddress public _addressXOR;\nbool internal initialized_;\nbool internal preparedForMigration_;\n","contract":"Bridge","time":0},{"type":"external-function ","before":"function addEthNativeToken(\n        address newToken,\n        string memory ticker,\n        string memory name,\n        uint8 decimals,\n        bytes32 txHash,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    )\n    public shouldBeInitialized {\n        require(used[txHash] == false);\n        require(acceptedEthTokens[newToken] == false);\n        require(checkSignatures(keccak256(abi.encodePacked(newToken, ticker, name, decimals, txHash, _networkId)),\n            v,\n            r,\n            s), \"Peer signatures are invalid\"\n        );\n        acceptedEthTokens[newToken] = true;\n        used[txHash] = true;\n    }","after":"function addEthNativeToken(\n        address newToken,\n        string calldata ticker,\n        string calldata name,\n        uint8 decimals,\n        bytes32 txHash,\n        uint8[] calldata v,\n        bytes32[] calldata r,\n        bytes32[] calldata s\n    )\n    public shouldBeInitialized {\n        require(used[txHash] == false);\n        require(acceptedEthTokens[newToken] == false);\n        require(checkSignatures(keccak256(abi.encodePacked(newToken, ticker, name, decimals, txHash, _networkId)),\n            v,\n            r,\n            s), \"Peer signatures are invalid\"\n        );\n        acceptedEthTokens[newToken] = true;\n        used[txHash] = true;\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function prepareForMigration(\n        address thisContractAddress,\n        bytes32 salt,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    )\n    public\n    shouldBeInitialized shouldNotBePreparedForMigration {\n        require(preparedForMigration_ == false);\n        require(address(this) == thisContractAddress);\n        require(checkSignatures(keccak256(abi.encodePacked(thisContractAddress, salt, _networkId)),\n            v,\n            r,\n            s), \"Peer signatures are invalid\"\n        );\n        preparedForMigration_ = true;\n        emit PreparedForMigration();\n    }","after":"function prepareForMigration(\n        address thisContractAddress,\n        bytes32 salt,\n        uint8[] calldata v,\n        bytes32[] calldata r,\n        bytes32[] calldata s\n    )\n    public\n    shouldBeInitialized shouldNotBePreparedForMigration {\n        require(preparedForMigration_ == false);\n        require(address(this) == thisContractAddress);\n        require(checkSignatures(keccak256(abi.encodePacked(thisContractAddress, salt, _networkId)),\n            v,\n            r,\n            s), \"Peer signatures are invalid\"\n        );\n        preparedForMigration_ = true;\n        emit PreparedForMigration();\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function shutDownAndMigrate(\n        address thisContractAddress,\n        bytes32 salt,\n        address payable newContractAddress,\n        address[] calldata erc20nativeTokens,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    )\n    public\n    shouldBeInitialized shouldBePreparedForMigration {\n        require(address(this) == thisContractAddress);\n        require(checkSignatures(keccak256(abi.encodePacked(thisContractAddress, newContractAddress, salt, erc20nativeTokens, _networkId)),\n            v,\n            r,\n            s), \"Peer signatures are invalid\"\n        );\n        for (uint i = 0; i < _sidechainTokenAddressArray.length; i++) {\n            Ownable token = Ownable(_sidechainTokenAddressArray[i]);\n            token.transferOwnership(newContractAddress);\n        }\n        for (uint i = 0; i < erc20nativeTokens.length; i++) {\n            IERC20 token = IERC20(erc20nativeTokens[i]);\n            token.transfer(newContractAddress, token.balanceOf(address(this)));\n        }\n        Bridge(newContractAddress).receivePayment{value : address(this).balance}();\n        initialized_ = false;\n        emit Migrated(newContractAddress);\n    }","after":"function shutDownAndMigrate(\n        address thisContractAddress,\n        bytes32 salt,\n        address payable newContractAddress,\n        address[] calldata erc20nativeTokens,\n        uint8[] calldata v,\n        bytes32[] calldata r,\n        bytes32[] calldata s\n    )\n    public\n    shouldBeInitialized shouldBePreparedForMigration {\n        require(address(this) == thisContractAddress);\n        require(checkSignatures(keccak256(abi.encodePacked(thisContractAddress, newContractAddress, salt, erc20nativeTokens, _networkId)),\n            v,\n            r,\n            s), \"Peer signatures are invalid\"\n        );\n        for (uint i = 0; i < _sidechainTokenAddressArray.length; i++) {\n            Ownable token = Ownable(_sidechainTokenAddressArray[i]);\n            token.transferOwnership(newContractAddress);\n        }\n        for (uint i = 0; i < erc20nativeTokens.length; i++) {\n            IERC20 token = IERC20(erc20nativeTokens[i]);\n            token.transfer(newContractAddress, token.balanceOf(address(this)));\n        }\n        Bridge(newContractAddress).receivePayment{value : address(this).balance}();\n        initialized_ = false;\n        emit Migrated(newContractAddress);\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function addNewSidechainToken(\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        bytes32 sidechainAssetId,\n        bytes32 txHash,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s)\n    public shouldBeInitialized {\n        require(used[txHash] == false);\n        require(checkSignatures(keccak256(abi.encodePacked(\n                name,\n                symbol,\n                decimals,\n                sidechainAssetId,\n                txHash,\n                _networkId\n            )),\n            v,\n            r,\n            s), \"Peer signatures are invalid\"\n        );\n        // Create new instance of the token\n        MasterToken tokenInstance = new MasterToken(name, symbol, decimals, address(this), 0, sidechainAssetId);\n        address tokenAddress = address(tokenInstance);\n        _sidechainTokens[sidechainAssetId] = tokenAddress;\n        _sidechainTokensByAddress[tokenAddress] = sidechainAssetId;\n        _sidechainTokenAddressArray.push(tokenAddress);\n        used[txHash] = true;\n    }","after":"function addNewSidechainToken(\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals,\n        bytes32 sidechainAssetId,\n        bytes32 txHash,\n        uint8[] calldata v,\n        bytes32[] calldata r,\n        bytes32[] calldata s)\n    public shouldBeInitialized {\n        require(used[txHash] == false);\n        require(checkSignatures(keccak256(abi.encodePacked(\n                name,\n                symbol,\n                decimals,\n                sidechainAssetId,\n                txHash,\n                _networkId\n            )),\n            v,\n            r,\n            s), \"Peer signatures are invalid\"\n        );\n        // Create new instance of the token\n        MasterToken tokenInstance = new MasterToken(name, symbol, decimals, address(this), 0, sidechainAssetId);\n        address tokenAddress = address(tokenInstance);\n        _sidechainTokens[sidechainAssetId] = tokenAddress;\n        _sidechainTokensByAddress[tokenAddress] = sidechainAssetId;\n        _sidechainTokenAddressArray.push(tokenAddress);\n        used[txHash] = true;\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function addPeerByPeer(\n        address newPeerAddress,\n        bytes32 txHash,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    )\n    public\n    shouldBeInitialized\n    returns (bool)\n    {\n        require(used[txHash] == false);\n        require(checkSignatures(keccak256(abi.encodePacked(newPeerAddress, txHash, _networkId)),\n            v,\n            r,\n            s), \"Peer signatures are invalid\"\n        );\n\n        addPeer(newPeerAddress);\n        used[txHash] = true;\n        emit ChangePeers(newPeerAddress, false);\n        return true;\n    }","after":"function addPeerByPeer(\n        address newPeerAddress,\n        bytes32 txHash,\n        uint8[] calldata v,\n        bytes32[] calldata r,\n        bytes32[] calldata s\n    )\n    public\n    shouldBeInitialized\n    returns (bool)\n    {\n        require(used[txHash] == false);\n        require(checkSignatures(keccak256(abi.encodePacked(newPeerAddress, txHash, _networkId)),\n            v,\n            r,\n            s), \"Peer signatures are invalid\"\n        );\n\n        addPeer(newPeerAddress);\n        used[txHash] = true;\n        emit ChangePeers(newPeerAddress, false);\n        return true;\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function removePeerByPeer(\n        address peerAddress,\n        bytes32 txHash,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    )\n    public\n    shouldBeInitialized\n    returns (bool)\n    {\n        require(used[txHash] == false);\n        require(checkSignatures(\n                keccak256(abi.encodePacked(peerAddress, txHash, _networkId)),\n                v,\n                r,\n                s), \"Peer signatures are invalid\"\n        );\n\n        removePeer(peerAddress);\n        used[txHash] = true;\n        emit ChangePeers(peerAddress, true);\n        return true;\n    }","after":"function removePeerByPeer(\n        address peerAddress,\n        bytes32 txHash,\n        uint8[] calldata v,\n        bytes32[] calldata r,\n        bytes32[] calldata s\n    )\n    public\n    shouldBeInitialized\n    returns (bool)\n    {\n        require(used[txHash] == false);\n        require(checkSignatures(\n                keccak256(abi.encodePacked(peerAddress, txHash, _networkId)),\n                v,\n                r,\n                s), \"Peer signatures are invalid\"\n        );\n\n        removePeer(peerAddress);\n        used[txHash] = true;\n        emit ChangePeers(peerAddress, true);\n        return true;\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function receiveByEthereumAssetAddress(\n        address tokenAddress,\n        uint256 amount,\n        address payable to,\n        address from,\n        bytes32 txHash,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    )\n    public shouldBeInitialized\n    {\n        require(used[txHash] == false);\n        require(checkSignatures(\n                keccak256(abi.encodePacked(tokenAddress, amount, to, from, txHash, _networkId)),\n                v,\n                r,\n                s), \"Peer signatures are invalid\"\n        );\n\n        if (tokenAddress == address(0)) {\n            used[txHash] = true;\n            // untrusted transfer, relies on provided cryptographic proof\n            to.transfer(amount);\n        } else {\n            IERC20 coin = IERC20(tokenAddress);\n            used[txHash] = true;\n            // untrusted call, relies on provided cryptographic proof\n            coin.transfer(to, amount);\n        }\n        emit Withdrawal(txHash);\n    }","after":"function receiveByEthereumAssetAddress(\n        address tokenAddress,\n        uint256 amount,\n        address payable to,\n        address from,\n        bytes32 txHash,\n        uint8[] calldata v,\n        bytes32[] calldata r,\n        bytes32[] calldata s\n    )\n    public shouldBeInitialized\n    {\n        require(used[txHash] == false);\n        require(checkSignatures(\n                keccak256(abi.encodePacked(tokenAddress, amount, to, from, txHash, _networkId)),\n                v,\n                r,\n                s), \"Peer signatures are invalid\"\n        );\n\n        if (tokenAddress == address(0)) {\n            used[txHash] = true;\n            // untrusted transfer, relies on provided cryptographic proof\n            to.transfer(amount);\n        } else {\n            IERC20 coin = IERC20(tokenAddress);\n            used[txHash] = true;\n            // untrusted call, relies on provided cryptographic proof\n            coin.transfer(to, amount);\n        }\n        emit Withdrawal(txHash);\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function receiveBySidechainAssetId(\n        bytes32 sidechainAssetId,\n        uint256 amount,\n        address to,\n        address from,\n        bytes32 txHash,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    )\n    public shouldBeInitialized\n    {\n        require(_sidechainTokens[sidechainAssetId] != address(0x0), \"Sidechain asset is not registered\");\n        require(used[txHash] == false);\n        require(checkSignatures(\n                keccak256(abi.encodePacked(sidechainAssetId, amount, to, from, txHash, _networkId)),\n                v,\n                r,\n                s), \"Peer signatures are invalid\"\n        );\n\n        MasterToken tokenInstance = MasterToken(_sidechainTokens[sidechainAssetId]);\n        tokenInstance.mintTokens(to, amount);\n        used[txHash] = true;\n        emit Withdrawal(txHash);\n    }","after":"function receiveBySidechainAssetId(\n        bytes32 sidechainAssetId,\n        uint256 amount,\n        address to,\n        address from,\n        bytes32 txHash,\n        uint8[] calldata v,\n        bytes32[] calldata r,\n        bytes32[] calldata s\n    )\n    public shouldBeInitialized\n    {\n        require(_sidechainTokens[sidechainAssetId] != address(0x0), \"Sidechain asset is not registered\");\n        require(used[txHash] == false);\n        require(checkSignatures(\n                keccak256(abi.encodePacked(sidechainAssetId, amount, to, from, txHash, _networkId)),\n                v,\n                r,\n                s), \"Peer signatures are invalid\"\n        );\n\n        MasterToken tokenInstance = MasterToken(_sidechainTokens[sidechainAssetId]);\n        tokenInstance.mintTokens(to, amount);\n        used[txHash] = true;\n        emit Withdrawal(txHash);\n    }","contract":"Bridge","time":0},{"type":"immutable-restrict-modification ","before":"address public _addressVAL;","after":"address public immutable _addressVAL;","contract":"Bridge","time":1},{"type":"immutable-restrict-modification ","before":"address public _addressXOR;","after":"address public immutable _addressXOR;","contract":"Bridge","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 public _networkId;","after":"bytes32 public immutable _networkId;","contract":"Bridge","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 public _sidechainAssetId;","after":"bytes32 public immutable _sidechainAssetId;","contract":"MasterToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"MasterToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"MasterToken","time":0},{"type":"immutable-restrict-modification ","before":"uint8 private _decimals;","after":"uint8 private immutable _decimals;","contract":"MasterToken","time":0}]}