{"time":27,"results":[{"type":"external-function ","before":"function validateAuctionPriceParameters(\n\n        RebalancingLibrary.AuctionPriceParameters memory _auctionPriceParameters\n\n    )\n\n    public\n\n    view\n\n    {\n\n        // Require that auction pivot price is greater than auction start price\n\n        require(\n\n            _auctionPriceParameters.auctionPivotPrice > _auctionPriceParameters.auctionStartPrice,\n\n            \"LinearAuctionPriceCurve.validateAuctionPriceParameters: Start price greater than pivot price\"\n\n        );\n\n\n        // Require pivot price to be greater than 0.5 * price denominator\n\n        // Equivalent to oldSet/newSet = 0.5\n\n        require(\n\n            _auctionPriceParameters.auctionPivotPrice > priceDivisor.div(MIN_PIVOT_PRICE_DIVISOR),\n\n            \"LinearAuctionPriceCurve.validateAuctionPriceParameters: Pivot price too low\"\n\n        );\n\n        // Require pivot price to be less than 5 * price denominator\n\n        // Equivalent to oldSet/newSet = 5\n\n        require(\n\n            _auctionPriceParameters.auctionPivotPrice < priceDivisor.mul(MAX_PIVOT_PRICE_NUMERATOR),\n\n            \"LinearAuctionPriceCurve.validateAuctionPriceParameters: Pivot price too high\"\n\n        );\n\n    }","after":"function validateAuctionPriceParameters(\n\n        RebalancingLibrary.AuctionPriceParameters calldata _auctionPriceParameters\n\n    )\n\n    public\n\n    view\n\n    {\n\n        // Require that auction pivot price is greater than auction start price\n\n        require(\n\n            _auctionPriceParameters.auctionPivotPrice > _auctionPriceParameters.auctionStartPrice,\n\n            \"LinearAuctionPriceCurve.validateAuctionPriceParameters: Start price greater than pivot price\"\n\n        );\n\n\n        // Require pivot price to be greater than 0.5 * price denominator\n\n        // Equivalent to oldSet/newSet = 0.5\n\n        require(\n\n            _auctionPriceParameters.auctionPivotPrice > priceDivisor.div(MIN_PIVOT_PRICE_DIVISOR),\n\n            \"LinearAuctionPriceCurve.validateAuctionPriceParameters: Pivot price too low\"\n\n        );\n\n        // Require pivot price to be less than 5 * price denominator\n\n        // Equivalent to oldSet/newSet = 5\n\n        require(\n\n            _auctionPriceParameters.auctionPivotPrice < priceDivisor.mul(MAX_PIVOT_PRICE_NUMERATOR),\n\n            \"LinearAuctionPriceCurve.validateAuctionPriceParameters: Pivot price too high\"\n\n        );\n\n    }","contract":"LinearAuctionPriceCurve","time":0},{"type":"external-function ","before":"function getCurrentPrice(\n\n        RebalancingLibrary.AuctionPriceParameters memory _auctionPriceParameters\n\n    )\n\n    public\n\n    view\n\n    returns (uint256, uint256)\n\n    {\n\n        // Calculate how much time has elapsed since start of auction\n\n        uint256 elapsed = block.timestamp.sub(_auctionPriceParameters.auctionStartTime);\n\n\n        // Initialize numerator and denominator\n\n        uint256 priceNumerator = _auctionPriceParameters.auctionPivotPrice;\n\n        uint256 currentPriceDivisor = priceDivisor;\n\n\n        // Determine the auctionStartPrice based on if it should be self-defined\n\n        uint256 auctionStartPrice = 0;\n\n        if (usesStartPrice) {\n\n            auctionStartPrice = _auctionPriceParameters.auctionStartPrice;\n\n        }\n\n\n        /*\n\n         * This price curve can be broken down into three stages, 1) set up to allow a portion where managers\n\n         * have control over the cadence of the auction, and then two more stages that are used to enforce finality\n\n         * to the auction. The auction price, p(x), is defined by:\n\n         *\n\n         * p(x) = (priceNumerator/priceDivisor\n\n         *\n\n         * In each stage either the priceNumerator or priceDivisor is manipulated to change p(x).The curve shape\n\n         * in each stage is defined below.\n\n         *\n\n         * 1) Managers have the greatest control over stage 1. Here they define a linear curve that starts at zero\n\n         * and terminates at the passed pivot price. The length of time it takes for the auction to reach the pivot\n\n         * price is defined by the manager too, thus resulting in the following equation for the slope of the line:\n\n         *\n\n         * PriceNumerator(x) = auctionStartPrice + (auctionPivotPrice-auctionStartPrice)*(x/auctionTimeToPivot),\n\n         * where x is amount of time from auction start\n\n         *\n\n         * 2) Stage 2 the protocol takes over to attempt to hasten/guarantee finality, this unfortunately decreases\n\n         * the granularity of the auction price changes. In this stage the PriceNumerator remains fixed at the\n\n         * auctionPivotPrice. However, the priceDivisor decays at a rate equivalent to 0.1% of the ORIGINAL\n\n         * priceDivisor every 30 secs. This leads to the following function relative to time:\n\n         *\n\n         * PriceDenominator(x) = priceDivisor-(0.01*priceDivisor*((x-auctionTimeToPivot)/30)), where x is amount\n\n         * of time from auction start.\n\n         *\n\n         * Since we are decaying the denominator the price curve takes on the shape of e^x. Because of the limitations\n\n         * of integer math the denominator can only be decayed to 1. Hence in order to maintain simplicity in calculations\n\n         * there is a third segment defined below.\n\n         *\n\n         * 3) The third segment is a simple linear calculation that changes the priceNumerator at the rate of the pivot\n\n         * price every 30 seconds and fixes the priceDivisor at 1:\n\n         *\n\n         * PriceNumerator(x) = auctionPivotPrice + auctionPivotPrice*(x-auctionTimeToPivot-30000), where x is amount of\n\n         * time from auction start and 30000 represents the amount of time spent in Stage 2\n\n         */\n\n\n\n        // If time hasn't passed to pivot use the user-defined curve\n\n        if (elapsed <= _auctionPriceParameters.auctionTimeToPivot) {\n\n            // Calculate the priceNumerator as a linear function of time between _auctionStartPrice and\n\n            // _auctionPivotPrice\n\n            uint256 linearPriceDifference = _auctionPriceParameters.auctionPivotPrice.sub(auctionStartPrice);\n\n            priceNumerator = auctionStartPrice.add(\n\n                elapsed.mul(linearPriceDifference).div(_auctionPriceParameters.auctionTimeToPivot)\n\n            );\n\n        } else {\n\n            // Calculate how many 30 second increments have passed since pivot was reached\n\n            uint256 thirtySecondPeriods = elapsed\n\n            .sub(_auctionPriceParameters.auctionTimeToPivot)\n\n            .div(THIRTY_SECONDS);\n\n\n            // Because after 1000 thirtySecondPeriods the priceDivisor would be 0 (causes revert)\n\n            if (thirtySecondPeriods < MAX_30_SECOND_PERIODS) {\n\n                // Calculate new denominator where the denominator decays at a rate of 0.1% of the ORIGINAL\n\n                // priceDivisor per time increment (hence divide by 1000)\n\n                currentPriceDivisor = priceDivisor\n\n                .sub(thirtySecondPeriods\n\n                .mul(priceDivisor)\n\n                .div(MAX_30_SECOND_PERIODS)\n\n                );\n\n            } else {\n\n                // Once denominator has fully decayed, fix it at 1\n\n                currentPriceDivisor = 1;\n\n\n                // Now priceNumerator just changes linearly, but with slope equal to the pivot price\n\n                priceNumerator = _auctionPriceParameters.auctionPivotPrice.add(\n\n                    _auctionPriceParameters.auctionPivotPrice.mul(thirtySecondPeriods.sub(MAX_30_SECOND_PERIODS))\n\n                );\n\n            }\n\n        }\n\n\n        return (priceNumerator, currentPriceDivisor);\n\n    }","after":"function getCurrentPrice(\n\n        RebalancingLibrary.AuctionPriceParameters calldata _auctionPriceParameters\n\n    )\n\n    public\n\n    view\n\n    returns (uint256, uint256)\n\n    {\n\n        // Calculate how much time has elapsed since start of auction\n\n        uint256 elapsed = block.timestamp.sub(_auctionPriceParameters.auctionStartTime);\n\n\n        // Initialize numerator and denominator\n\n        uint256 priceNumerator = _auctionPriceParameters.auctionPivotPrice;\n\n        uint256 currentPriceDivisor = priceDivisor;\n\n\n        // Determine the auctionStartPrice based on if it should be self-defined\n\n        uint256 auctionStartPrice = 0;\n\n        if (usesStartPrice) {\n\n            auctionStartPrice = _auctionPriceParameters.auctionStartPrice;\n\n        }\n\n\n        /*\n\n         * This price curve can be broken down into three stages, 1) set up to allow a portion where managers\n\n         * have control over the cadence of the auction, and then two more stages that are used to enforce finality\n\n         * to the auction. The auction price, p(x), is defined by:\n\n         *\n\n         * p(x) = (priceNumerator/priceDivisor\n\n         *\n\n         * In each stage either the priceNumerator or priceDivisor is manipulated to change p(x).The curve shape\n\n         * in each stage is defined below.\n\n         *\n\n         * 1) Managers have the greatest control over stage 1. Here they define a linear curve that starts at zero\n\n         * and terminates at the passed pivot price. The length of time it takes for the auction to reach the pivot\n\n         * price is defined by the manager too, thus resulting in the following equation for the slope of the line:\n\n         *\n\n         * PriceNumerator(x) = auctionStartPrice + (auctionPivotPrice-auctionStartPrice)*(x/auctionTimeToPivot),\n\n         * where x is amount of time from auction start\n\n         *\n\n         * 2) Stage 2 the protocol takes over to attempt to hasten/guarantee finality, this unfortunately decreases\n\n         * the granularity of the auction price changes. In this stage the PriceNumerator remains fixed at the\n\n         * auctionPivotPrice. However, the priceDivisor decays at a rate equivalent to 0.1% of the ORIGINAL\n\n         * priceDivisor every 30 secs. This leads to the following function relative to time:\n\n         *\n\n         * PriceDenominator(x) = priceDivisor-(0.01*priceDivisor*((x-auctionTimeToPivot)/30)), where x is amount\n\n         * of time from auction start.\n\n         *\n\n         * Since we are decaying the denominator the price curve takes on the shape of e^x. Because of the limitations\n\n         * of integer math the denominator can only be decayed to 1. Hence in order to maintain simplicity in calculations\n\n         * there is a third segment defined below.\n\n         *\n\n         * 3) The third segment is a simple linear calculation that changes the priceNumerator at the rate of the pivot\n\n         * price every 30 seconds and fixes the priceDivisor at 1:\n\n         *\n\n         * PriceNumerator(x) = auctionPivotPrice + auctionPivotPrice*(x-auctionTimeToPivot-30000), where x is amount of\n\n         * time from auction start and 30000 represents the amount of time spent in Stage 2\n\n         */\n\n\n\n        // If time hasn't passed to pivot use the user-defined curve\n\n        if (elapsed <= _auctionPriceParameters.auctionTimeToPivot) {\n\n            // Calculate the priceNumerator as a linear function of time between _auctionStartPrice and\n\n            // _auctionPivotPrice\n\n            uint256 linearPriceDifference = _auctionPriceParameters.auctionPivotPrice.sub(auctionStartPrice);\n\n            priceNumerator = auctionStartPrice.add(\n\n                elapsed.mul(linearPriceDifference).div(_auctionPriceParameters.auctionTimeToPivot)\n\n            );\n\n        } else {\n\n            // Calculate how many 30 second increments have passed since pivot was reached\n\n            uint256 thirtySecondPeriods = elapsed\n\n            .sub(_auctionPriceParameters.auctionTimeToPivot)\n\n            .div(THIRTY_SECONDS);\n\n\n            // Because after 1000 thirtySecondPeriods the priceDivisor would be 0 (causes revert)\n\n            if (thirtySecondPeriods < MAX_30_SECOND_PERIODS) {\n\n                // Calculate new denominator where the denominator decays at a rate of 0.1% of the ORIGINAL\n\n                // priceDivisor per time increment (hence divide by 1000)\n\n                currentPriceDivisor = priceDivisor\n\n                .sub(thirtySecondPeriods\n\n                .mul(priceDivisor)\n\n                .div(MAX_30_SECOND_PERIODS)\n\n                );\n\n            } else {\n\n                // Once denominator has fully decayed, fix it at 1\n\n                currentPriceDivisor = 1;\n\n\n                // Now priceNumerator just changes linearly, but with slope equal to the pivot price\n\n                priceNumerator = _auctionPriceParameters.auctionPivotPrice.add(\n\n                    _auctionPriceParameters.auctionPivotPrice.mul(thirtySecondPeriods.sub(MAX_30_SECOND_PERIODS))\n\n                );\n\n            }\n\n        }\n\n\n        return (priceNumerator, currentPriceDivisor);\n\n    }","contract":"LinearAuctionPriceCurve","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public priceDivisor;","after":"uint256 public immutable priceDivisor;","contract":"LinearAuctionPriceCurve","time":0},{"type":"immutable-restrict-modification ","before":"bool public usesStartPrice;","after":"bool public immutable usesStartPrice;","contract":"LinearAuctionPriceCurve","time":0}]}