{"time":1201,"results":[{"type":"external-function ","before":"function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }","after":"function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function transferController(address currencyCt, string memory standard)\npublic\nview\nreturns (TransferController)\n{\nif (bytes(standard).length > 0) {\nbytes32 standardHash = keccak256(abi.encodePacked(standard));\n\nrequire(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\nreturn TransferController(registeredTransferControllers[standardHash]);\n}\n\nrequire(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\nrequire(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\naddress controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\nrequire(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\nreturn TransferController(controllerAddress);\n}","after":"function transferController(address currencyCt, string calldata standard)\npublic\nview\nreturns (TransferController)\n{\nif (bytes(standard).length > 0) {\nbytes32 standardHash = keccak256(abi.encodePacked(standard));\n\nrequire(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\nreturn TransferController(registeredTransferControllers[standardHash]);\n}\n\nrequire(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\nrequire(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\naddress controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\nrequire(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\nreturn TransferController(controllerAddress);\n}","contract":"TransferControllerManager","time":0},{"type":"loop-duplication","before":"\nstart line 3322 column 0, end line 3323 column 91\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\nself.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\nstart line 3327 column 0, end line 3328 column 95\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\nself.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = i + 1;","after":"// merge loop\n\nstart line 3322 column 0, end line 3323 column 91\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\nself.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\nstart line 3327 column 0, end line 3328 column 95\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\nself.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = i + 1;","contract":"NonFungibleBalanceLib","time":0},{"type":"external-function ","before":"function setIds(address wallet, bytes32 _type, int256[] memory ids, address currencyCt, uint256 currencyId)\npublic\nonlyActiveService\n{\n// Update the balance\nwalletMap[wallet].nonFungibleBalanceByType[_type].set(\nids, currencyCt, currencyId\n);\n\n// Update balance type hashes\n_updateTrackedBalanceTypes(_type);\n\n// Update tracked wallets\n_updateTrackedWallets(wallet);\n}","after":"function setIds(address wallet, bytes32 _type, int256[] calldata ids, address currencyCt, uint256 currencyId)\npublic\nonlyActiveService\n{\n// Update the balance\nwalletMap[wallet].nonFungibleBalanceByType[_type].set(\nids, currencyCt, currencyId\n);\n\n// Update balance type hashes\n_updateTrackedBalanceTypes(_type);\n\n// Update tracked wallets\n_updateTrackedWallets(wallet);\n}","contract":"BalanceTracker","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"BalanceTracker","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"BalanceTracker","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"BalanceTracker","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public depositedBalanceType;","after":"bytes32 public immutable depositedBalanceType;","contract":"BalanceTracker","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 public settledBalanceType;","after":"bytes32 public immutable settledBalanceType;","contract":"BalanceTracker","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 public stagedBalanceType;","after":"bytes32 public immutable stagedBalanceType;","contract":"BalanceTracker","time":1},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"TransactionTracker","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"TransactionTracker","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"TransactionTracker","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public depositTransactionType;","after":"bytes32 public immutable depositTransactionType;","contract":"TransactionTracker","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 public withdrawalTransactionType;","after":"bytes32 public immutable withdrawalTransactionType;","contract":"TransactionTracker","time":1},{"type":"external-function ","before":"function lockNonFungibleByProxy(address lockedWallet, address lockerWallet, int256[] memory ids,\naddress currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\npublic\nonlyAuthorizedService(lockedWallet)\n{\n// Require that locked and locker wallets are not identical\nrequire(lockedWallet != lockerWallet);\n\n// Get index of lock\nuint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n// Require that there is no existing conflicting lock\nrequire(\n(0 == lockIndex) ||\n(block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n);\n\n// Add lock object for this triplet of locked wallet, currency and locker wallet if it does not exist\nif (0 == lockIndex) {\nlockIndex = ++(walletNonFungibleLocks[lockedWallet].length);\nlockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\nwalletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n}\n\n// Update lock parameters\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].ids = ids;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\nblock.timestamp.add(visibleTimeoutInSeconds);\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\nblock.timestamp.add(configuration.walletLockTimeout());\n\n// Emit event\nemit LockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId, visibleTimeoutInSeconds);\n}","after":"function lockNonFungibleByProxy(address lockedWallet, address lockerWallet, int256[] calldata ids,\naddress currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\npublic\nonlyAuthorizedService(lockedWallet)\n{\n// Require that locked and locker wallets are not identical\nrequire(lockedWallet != lockerWallet);\n\n// Get index of lock\nuint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n// Require that there is no existing conflicting lock\nrequire(\n(0 == lockIndex) ||\n(block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n);\n\n// Add lock object for this triplet of locked wallet, currency and locker wallet if it does not exist\nif (0 == lockIndex) {\nlockIndex = ++(walletNonFungibleLocks[lockedWallet].length);\nlockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\nwalletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n}\n\n// Update lock parameters\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].ids = ids;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\nblock.timestamp.add(visibleTimeoutInSeconds);\nwalletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\nblock.timestamp.add(configuration.walletLockTimeout());\n\n// Emit event\nemit LockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId, visibleTimeoutInSeconds);\n}","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function authorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        // Ensure service action is registered\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        // Ensure service is not initial\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Enable service action for given wallet\n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n        // Emit event\n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","after":"function authorizeRegisteredServiceAction(address service, string calldata action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        // Ensure service action is registered\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        // Ensure service is not initial\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Enable service action for given wallet\n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n        // Emit event\n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function unauthorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        // Ensure service is registered and action enabled\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        // Ensure service is not initial as it can not be unauthorized per action\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Disable service action for given wallet\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n        // Emit event\n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","after":"function unauthorizeRegisteredServiceAction(address service, string calldata action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        // Ensure service is registered and action enabled\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        // Ensure service is not initial as it can not be unauthorized per action\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Disable service action for given wallet\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n        // Emit event\n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function isAuthorizedRegisteredServiceAction(address service, string memory action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }","after":"function isAuthorizedRegisteredServiceAction(address service, string calldata action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function defineReleases(uint256[] memory earliestReleaseTimes, uint256[] memory amounts, uint256[] memory releaseBlockNumbers)\nonlyOperator\npublic\n{\nrequire(\nearliestReleaseTimes.length == amounts.length,\n\"Earliest release times and amounts lengths mismatch [TokenMultiTimelock.sol:105]\"\n);\nrequire(\nearliestReleaseTimes.length >= releaseBlockNumbers.length,\n\"Earliest release times and release block numbers lengths mismatch [TokenMultiTimelock.sol:109]\"\n);\n\n// Require that token address has been set\nrequire(address(token) != address(0), \"Token not initialized [TokenMultiTimelock.sol:115]\");\n\nfor (uint256 i = 0; i < earliestReleaseTimes.length; i++) {\n// Update the total amount locked by this contract\ntotalLockedAmount += amounts[i];\n\n// Require that total amount locked is less than or equal to the token balance of\n// this contract\nrequire(token.balanceOf(address(this)) >= totalLockedAmount, \"Total locked amount overrun [TokenMultiTimelock.sol:123]\");\n\n// Retrieve early block number where available\nuint256 blockNumber = i < releaseBlockNumbers.length ? releaseBlockNumbers[i] : 0;\n\n// Add release\nreleases.push(Release(earliestReleaseTimes[i], amounts[i], blockNumber, false));\n\n// Emit event\nemit DefineReleaseEvent(earliestReleaseTimes[i], amounts[i], blockNumber);\n}\n}","after":"function defineReleases(uint256[] calldata earliestReleaseTimes, uint256[] calldata amounts, uint256[] calldata releaseBlockNumbers)\nonlyOperator\npublic\n{\nrequire(\nearliestReleaseTimes.length == amounts.length,\n\"Earliest release times and amounts lengths mismatch [TokenMultiTimelock.sol:105]\"\n);\nrequire(\nearliestReleaseTimes.length >= releaseBlockNumbers.length,\n\"Earliest release times and release block numbers lengths mismatch [TokenMultiTimelock.sol:109]\"\n);\n\n// Require that token address has been set\nrequire(address(token) != address(0), \"Token not initialized [TokenMultiTimelock.sol:115]\");\n\nfor (uint256 i = 0; i < earliestReleaseTimes.length; i++) {\n// Update the total amount locked by this contract\ntotalLockedAmount += amounts[i];\n\n// Require that total amount locked is less than or equal to the token balance of\n// this contract\nrequire(token.balanceOf(address(this)) >= totalLockedAmount, \"Total locked amount overrun [TokenMultiTimelock.sol:123]\");\n\n// Retrieve early block number where available\nuint256 blockNumber = i < releaseBlockNumbers.length ? releaseBlockNumbers[i] : 0;\n\n// Add release\nreleases.push(Release(earliestReleaseTimes[i], amounts[i], blockNumber, false));\n\n// Emit event\nemit DefineReleaseEvent(earliestReleaseTimes[i], amounts[i], blockNumber);\n}\n}","contract":"RevenueTokenManager","time":0},{"type":"external-function ","before":"function receiveTokens(string memory, int256 amount, address currencyCt, uint256 currencyId,\nstring memory standard)\npublic\n{\nreceiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n}","after":"function receiveTokens(string calldata, int256 amount, address currencyCt, uint256 currencyId,\nstring calldata standard)\npublic\n{\nreceiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n}","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\npublic\nonlyEnabledServiceAction(CLOSE_ACCRUAL_PERIOD_ACTION)\n{\n// Clear period accrual stats\nfor (uint256 i = 0; i < currencies.length; i++) {\nMonetaryTypesLib.Currency memory currency = currencies[i];\n\n// Get the amount of the accrual period\nint256 periodAmount = periodAccrual.get(currency.ct, currency.id);\n\n// Register this block number as accrual block number of currency\naccrualBlockNumbersByCurrency[currency.ct][currency.id].push(block.number);\n\n// Store the aggregate accrual balance of currency at this block number\naggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number] = aggregateAccrualBalance(\ncurrency.ct, currency.id\n);\n\nif (periodAmount > 0) {\n// Reset period accrual of currency\nperiodAccrual.set(0, currency.ct, currency.id);\n\n// Remove currency from period in-use list\nperiodCurrencies.removeByCurrency(currency.ct, currency.id);\n}\n\n// Emit event\nemit CloseAccrualPeriodEvent(\nperiodAmount,\naggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number],\ncurrency.ct, currency.id\n);\n}\n}","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata currencies)\npublic\nonlyEnabledServiceAction(CLOSE_ACCRUAL_PERIOD_ACTION)\n{\n// Clear period accrual stats\nfor (uint256 i = 0; i < currencies.length; i++) {\nMonetaryTypesLib.Currency memory currency = currencies[i];\n\n// Get the amount of the accrual period\nint256 periodAmount = periodAccrual.get(currency.ct, currency.id);\n\n// Register this block number as accrual block number of currency\naccrualBlockNumbersByCurrency[currency.ct][currency.id].push(block.number);\n\n// Store the aggregate accrual balance of currency at this block number\naggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number] = aggregateAccrualBalance(\ncurrency.ct, currency.id\n);\n\nif (periodAmount > 0) {\n// Reset period accrual of currency\nperiodAccrual.set(0, currency.ct, currency.id);\n\n// Remove currency from period in-use list\nperiodCurrencies.removeByCurrency(currency.ct, currency.id);\n}\n\n// Emit event\nemit CloseAccrualPeriodEvent(\nperiodAmount,\naggregateAccrualAmountByCurrencyBlockNumber[currency.ct][currency.id][block.number],\ncurrency.ct, currency.id\n);\n}\n}","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function claimAndTransferToBeneficiary(Beneficiary beneficiary, address destWallet, string memory balanceType,\naddress currencyCt, uint256 currencyId, string memory standard)\npublic\n{\n// Claim accrual and obtain the claimed amount\nint256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n// Transfer ETH to the beneficiary\nif (address(0) == currencyCt && 0 == currencyId)\nbeneficiary.receiveEthersTo.value(uint256(claimedAmount))(destWallet, balanceType);\n\nelse {\n// Approve of beneficiary\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\n)\n);\nrequire(success, \"Approval by controller failed [TokenHolderRevenueFund.sol:349]\");\n\n// Transfer tokens to the beneficiary\nbeneficiary.receiveTokensTo(destWallet, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}\n\n// Emit event\nemit ClaimAndTransferToBeneficiaryEvent(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}","after":"function claimAndTransferToBeneficiary(Beneficiary beneficiary, address destWallet, string calldata balanceType,\naddress currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\n// Claim accrual and obtain the claimed amount\nint256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n// Transfer ETH to the beneficiary\nif (address(0) == currencyCt && 0 == currencyId)\nbeneficiary.receiveEthersTo.value(uint256(claimedAmount))(destWallet, balanceType);\n\nelse {\n// Approve of beneficiary\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\n)\n);\nrequire(success, \"Approval by controller failed [TokenHolderRevenueFund.sol:349]\");\n\n// Transfer tokens to the beneficiary\nbeneficiary.receiveTokensTo(destWallet, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}\n\n// Emit event\nemit ClaimAndTransferToBeneficiaryEvent(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\n// Require that amount is strictly positive\nrequire(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [TokenHolderRevenueFund.sol:384]\");\n\n// Clamp amount to the max given by staged balance\namount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n// Subtract to per-wallet staged balance\nstagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n// Execute transfer\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Dispatch by controller failed [TokenHolderRevenueFund.sol:403]\");\n}\n\n// Emit event\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n}","after":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\n// Require that amount is strictly positive\nrequire(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [TokenHolderRevenueFund.sol:384]\");\n\n// Clamp amount to the max given by staged balance\namount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n// Subtract to per-wallet staged balance\nstagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n// Execute transfer\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Dispatch by controller failed [TokenHolderRevenueFund.sol:403]\");\n}\n\n// Emit event\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n}","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\npublic\n{\nemit CloseAccrualPeriodEvent();\n}","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata)\npublic\n{\nemit CloseAccrualPeriodEvent();\n}","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"TokenHolderRevenueFund","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"TokenHolderRevenueFund","time":0},{"type":"loop-duplication","before":"\nstart line 7009 column 0, end line 7014 column 1\n;\nfor (i = 0; i < balanceTypes.length; i++)\ntotalBalanceAmount = totalBalanceAmount.add(\nbalanceTracker.get(\nwallet, balanceTypes[i], currencyCt, currencyId\n)\n\nstart line 7020 column 0, end line 7037 column 0\n;\nfor (i = 0; i < balanceTypes.length; i++) {\nint256 typeAmount = balanceTracker.get(\nwallet, balanceTypes[i], currencyCt, currencyId\n);\n\nif (typeAmount >= _amount) {\nbalanceTracker.sub(\nwallet, balanceTypes[i], _amount, currencyCt, currencyId, true\n);\nbreak;\n\n} else {\nbalanceTracker.set(\nwallet, balanceTypes[i], 0, currencyCt, currencyId, true\n);\n_amount = _amount.sub(typeAmount);\n}","after":"// merge loop\n\nstart line 7009 column 0, end line 7014 column 1\n;\nfor (i = 0; i < balanceTypes.length; i++)\ntotalBalanceAmount = totalBalanceAmount.add(\nbalanceTracker.get(\nwallet, balanceTypes[i], currencyCt, currencyId\n)\n\nstart line 7020 column 0, end line 7037 column 0\n;\nfor (i = 0; i < balanceTypes.length; i++) {\nint256 typeAmount = balanceTracker.get(\nwallet, balanceTypes[i], currencyCt, currencyId\n);\n\nif (typeAmount >= _amount) {\nbalanceTracker.sub(\nwallet, balanceTypes[i], _amount, currencyCt, currencyId, true\n);\nbreak;\n\n} else {\nbalanceTracker.set(\nwallet, balanceTypes[i], 0, currencyCt, currencyId, true\n);\n_amount = _amount.sub(typeAmount);\n}","contract":"ClientFund","time":0},{"type":"external-function ","before":")\nfunction receiveTokens(string memory balanceType, int256 value, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\nreceiveTokensTo(msg.sender, balanceType, value, currencyCt, currencyId, standard);","after":")\nfunction receiveTokens(string calldata balanceType, int256 value, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\nreceiveTokensTo(msg.sender, balanceType, value, currencyCt, currencyId, standard);","contract":"ClientFund","time":0},{"type":"external-function ","before":"d\nfunction updateSettledBalance(address wallet, int256 value, address currencyCt, uint256 currencyId,\nstring memory standard, uint256 blockNumber)\npublic\nonlyAuthorizedService(wallet)\nnotNullAddress(wallet)\n{\nrequire(value.isPositiveInt256());\n\nif (_isFungible(currencyCt, currencyId, standard)) {\n(int256 depositedValue,) = balanceTracker.fungibleRecordByBlockNumber(\nwallet, balanceTracker.depositedBalanceType(), currencyCt, currencyId, blockNumber\n);\nbalanceTracker.set(\nwallet, balanceTracker.settledBalanceType(), value.sub(depositedValue),\ncurrencyCt, currencyId, true\n);\n\n} else {\nbalanceTracker.sub(\nwallet, balanceTracker.depositedBalanceType(), value, currencyCt, currencyId, false\n);\nbalanceTracker.add(\nwallet, balanceTracker.settledBalanceType(), value, currencyCt, currencyId, false\n);\n}\n\n// Emit event\nemit UpdateSettledBalanceEvent(wallet, value, currencyCt, currencyId);","after":"d\nfunction updateSettledBalance(address wallet, int256 value, address currencyCt, uint256 currencyId,\nstring calldata standard, uint256 blockNumber)\npublic\nonlyAuthorizedService(wallet)\nnotNullAddress(wallet)\n{\nrequire(value.isPositiveInt256());\n\nif (_isFungible(currencyCt, currencyId, standard)) {\n(int256 depositedValue,) = balanceTracker.fungibleRecordByBlockNumber(\nwallet, balanceTracker.depositedBalanceType(), currencyCt, currencyId, blockNumber\n);\nbalanceTracker.set(\nwallet, balanceTracker.settledBalanceType(), value.sub(depositedValue),\ncurrencyCt, currencyId, true\n);\n\n} else {\nbalanceTracker.sub(\nwallet, balanceTracker.depositedBalanceType(), value, currencyCt, currencyId, false\n);\nbalanceTracker.add(\nwallet, balanceTracker.settledBalanceType(), value, currencyCt, currencyId, false\n);\n}\n\n// Emit event\nemit UpdateSettledBalanceEvent(wallet, value, currencyCt, currencyId);","contract":"ClientFund","time":0},{"type":"external-function ","before":")\nfunction stage(address wallet, int256 value, address currencyCt, uint256 currencyId,\nstring memory standard)\npublic\nonlyAuthorizedService(wallet)\n{\nrequire(value.isNonZeroPositiveInt256());\n\n// Deduce fungibility\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n// Subtract stage value from settled, possibly also from deposited\nvalue = _subtractSequentially(wallet, balanceTracker.activeBalanceTypes(), value, currencyCt, currencyId, fungible);\n\n// Add to staged\nbalanceTracker.add(\nwallet, balanceTracker.stagedBalanceType(), value, currencyCt, currencyId, fungible\n);\n\n// Emit event\nemit StageEvent(wallet, value, currencyCt, currencyId, standard);","after":")\nfunction stage(address wallet, int256 value, address currencyCt, uint256 currencyId,\nstring calldata standard)\npublic\nonlyAuthorizedService(wallet)\n{\nrequire(value.isNonZeroPositiveInt256());\n\n// Deduce fungibility\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n// Subtract stage value from settled, possibly also from deposited\nvalue = _subtractSequentially(wallet, balanceTracker.activeBalanceTypes(), value, currencyCt, currencyId, fungible);\n\n// Add to staged\nbalanceTracker.add(\nwallet, balanceTracker.stagedBalanceType(), value, currencyCt, currencyId, fungible\n);\n\n// Emit event\nemit StageEvent(wallet, value, currencyCt, currencyId, standard);","contract":"ClientFund","time":0},{"type":"external-function ","before":")\nfunction unstage(int256 value, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\nrequire(value.isNonZeroPositiveInt256());\n\n// Deduce fungibility\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n// Subtract unstage value from staged\nvalue = _subtractFromStaged(msg.sender, value, currencyCt, currencyId, fungible);\n\n// Add to deposited\nbalanceTracker.add(\nmsg.sender, balanceTracker.depositedBalanceType(), value, currencyCt, currencyId, fungible\n);\n\n// Emit event\nemit UnstageEvent(msg.sender, value, currencyCt, currencyId, standard);","after":")\nfunction unstage(int256 value, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\nrequire(value.isNonZeroPositiveInt256());\n\n// Deduce fungibility\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n// Subtract unstage value from staged\nvalue = _subtractFromStaged(msg.sender, value, currencyCt, currencyId, fungible);\n\n// Add to deposited\nbalanceTracker.add(\nmsg.sender, balanceTracker.depositedBalanceType(), value, currencyCt, currencyId, fungible\n);\n\n// Emit event\nemit UnstageEvent(msg.sender, value, currencyCt, currencyId, standard);","contract":"ClientFund","time":0},{"type":"external-function ","before":")\nfunction stageToBeneficiary(address wallet, Beneficiary beneficiary, int256 value,\naddress currencyCt, uint256 currencyId, string memory standard)\npublic\nonlyAuthorizedService(wallet)\n{\n// Deduce fungibility\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n// Subtract stage value from settled, possibly also from deposited\nvalue = _subtractSequentially(wallet, balanceTracker.activeBalanceTypes(), value, currencyCt, currencyId, fungible);\n\n// Execute transfer\n_transferToBeneficiary(wallet, beneficiary, value, currencyCt, currencyId, standard);\n\n// Emit event\nemit StageToBeneficiaryEvent(wallet, beneficiary, value, currencyCt, currencyId, standard);","after":")\nfunction stageToBeneficiary(address wallet, Beneficiary beneficiary, int256 value,\naddress currencyCt, uint256 currencyId, string calldata standard)\npublic\nonlyAuthorizedService(wallet)\n{\n// Deduce fungibility\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n// Subtract stage value from settled, possibly also from deposited\nvalue = _subtractSequentially(wallet, balanceTracker.activeBalanceTypes(), value, currencyCt, currencyId, fungible);\n\n// Execute transfer\n_transferToBeneficiary(wallet, beneficiary, value, currencyCt, currencyId, standard);\n\n// Emit event\nemit StageToBeneficiaryEvent(wallet, beneficiary, value, currencyCt, currencyId, standard);","contract":"ClientFund","time":0},{"type":"external-function ","before":")\nfunction transferToBeneficiary(address wallet, Beneficiary beneficiary, int256 value,\naddress currencyCt, uint256 currencyId, string memory standard)\npublic\nonlyAuthorizedService(wallet)\n{\n// Execute transfer\n_transferToBeneficiary(wallet, beneficiary, value, currencyCt, currencyId, standard);\n\n// Emit event\nemit TransferToBeneficiaryEvent(wallet, beneficiary, value, currencyCt, currencyId, standard);","after":")\nfunction transferToBeneficiary(address wallet, Beneficiary beneficiary, int256 value,\naddress currencyCt, uint256 currencyId, string calldata standard)\npublic\nonlyAuthorizedService(wallet)\n{\n// Execute transfer\n_transferToBeneficiary(wallet, beneficiary, value, currencyCt, currencyId, standard);\n\n// Emit event\nemit TransferToBeneficiaryEvent(wallet, beneficiary, value, currencyCt, currencyId, standard);","contract":"ClientFund","time":0},{"type":"external-function ","before":")\nfunction seizeBalances(address wallet, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\nif (_isFungible(currencyCt, currencyId, standard))\n_seizeFungibleBalances(wallet, msg.sender, currencyCt, currencyId);\n\nelse\n_seizeNonFungibleBalances(wallet, msg.sender, currencyCt, currencyId);\n\n// Add to the store of seized wallets\nif (!seizedByWallet[wallet]) {\nseizedByWallet[wallet] = true;\nseizedWallets.push(wallet);\n}","after":")\nfunction seizeBalances(address wallet, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\nif (_isFungible(currencyCt, currencyId, standard))\n_seizeFungibleBalances(wallet, msg.sender, currencyCt, currencyId);\n\nelse\n_seizeNonFungibleBalances(wallet, msg.sender, currencyCt, currencyId);\n\n// Add to the store of seized wallets\nif (!seizedByWallet[wallet]) {\nseizedByWallet[wallet] = true;\nseizedWallets.push(wallet);\n}","contract":"ClientFund","time":0},{"type":"external-function ","before":")\nfunction withdraw(int256 value, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\nrequire(value.isNonZeroPositiveInt256());\n\n// Require that msg.sender and currency is not locked\nrequire(!walletLocker.isLocked(msg.sender, currencyCt, currencyId));\n\n// Deduce fungibility\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n// Subtract unstage value from staged\nvalue = _subtractFromStaged(msg.sender, value, currencyCt, currencyId, fungible);\n\n// Log record of this transaction\ntransactionTracker.add(\nmsg.sender, transactionTracker.withdrawalTransactionType(), value, currencyCt, currencyId\n);\n\n// Execute transfer\n_transferToWallet(msg.sender, value, currencyCt, currencyId, standard);\n\n// Emit event\nemit WithdrawEvent(msg.sender, value, currencyCt, currencyId, standard);","after":")\nfunction withdraw(int256 value, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\nrequire(value.isNonZeroPositiveInt256());\n\n// Require that msg.sender and currency is not locked\nrequire(!walletLocker.isLocked(msg.sender, currencyCt, currencyId));\n\n// Deduce fungibility\nbool fungible = _isFungible(currencyCt, currencyId, standard);\n\n// Subtract unstage value from staged\nvalue = _subtractFromStaged(msg.sender, value, currencyCt, currencyId, fungible);\n\n// Log record of this transaction\ntransactionTracker.add(\nmsg.sender, transactionTracker.withdrawalTransactionType(), value, currencyCt, currencyId\n);\n\n// Execute transfer\n_transferToWallet(msg.sender, value, currencyCt, currencyId, standard);\n\n// Emit event\nemit WithdrawEvent(msg.sender, value, currencyCt, currencyId, standard);","contract":"ClientFund","time":0},{"type":"external-function ","before":")\nfunction claimRevenue(address claimer, string memory balanceType, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\nonlyOperator\n{\ntokenHolderRevenueFund.claimAndTransferToBeneficiary(\nthis, claimer, balanceType,\ncurrencyCt, currencyId, standard\n);\n\nemit ClaimRevenueEvent(claimer, balanceType, currencyCt, currencyId, standard);","after":")\nfunction claimRevenue(address claimer, string calldata balanceType, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\nonlyOperator\n{\ntokenHolderRevenueFund.claimAndTransferToBeneficiary(\nthis, claimer, balanceType,\ncurrencyCt, currencyId, standard\n);\n\nemit ClaimRevenueEvent(claimer, balanceType, currencyCt, currencyId, standard);","contract":"ClientFund","time":0},{"type":"external-function ","before":"function authorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        // Ensure service action is registered\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        // Ensure service is not initial\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Enable service action for given wallet\n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n        // Emit event\n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","after":"function authorizeRegisteredServiceAction(address service, string calldata action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        // Ensure service action is registered\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        // Ensure service is not initial\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Enable service action for given wallet\n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n        // Emit event\n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","contract":"ClientFund","time":0},{"type":"external-function ","before":"function unauthorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        // Ensure service is registered and action enabled\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        // Ensure service is not initial as it can not be unauthorized per action\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Disable service action for given wallet\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n        // Emit event\n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","after":"function unauthorizeRegisteredServiceAction(address service, string calldata action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        // Ensure service is registered and action enabled\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        // Ensure service is not initial as it can not be unauthorized per action\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Disable service action for given wallet\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n        // Emit event\n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","contract":"ClientFund","time":0},{"type":"external-function ","before":"function isAuthorizedRegisteredServiceAction(address service, string memory action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }","after":"function isAuthorizedRegisteredServiceAction(address service, string calldata action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }","contract":"ClientFund","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"ClientFund","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"ClientFund","time":0},{"type":"constant-restrict-modification  ","before":";\nuint256 maxDriipNonc","after":";\nuint256 maxDriipNonc","contract":"CommunityVote","time":0},{"type":"constant-restrict-modification  ","before":";\nuint256 maxNullNonc","after":";\nuint256 maxNullNonc","contract":"CommunityVote","time":0},{"type":"immutable-restrict-modification ","before":";\nbool dataAvailabl","after":";\nbool dataAvailabl","contract":"CommunityVote","time":0},{"type":"external-function ","before":")\nfunction receiveTokens(string memory balanceType, int256 amount, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\nreceiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);","after":")\nfunction receiveTokens(string calldata balanceType, int256 amount, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\nreceiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);","contract":"RevenueFund","time":0},{"type":"external-function ","before":"s\nfunction closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\npublic\nonlyOperator\n{\nrequire(\nConstantsLib.PARTS_PER() == totalBeneficiaryFraction,\n\"Total beneficiary fraction out of bounds [RevenueFund.sol:236]\"\n);\n\n// Execute transfer\nfor (uint256 i = 0; i < currencies.length; i++) {\nMonetaryTypesLib.Currency memory currency = currencies[i];\n\nint256 remaining = periodAccrual.get(currency.ct, currency.id);\n\nif (0 >= remaining)\ncontinue;\n\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\nif (beneficiaryFraction(beneficiary) > 0) {\nint256 transferable = periodAccrual.get(currency.ct, currency.id)\n.mul(beneficiaryFraction(beneficiary))\n.div(ConstantsLib.PARTS_PER());\n\nif (transferable > remaining)\ntransferable = remaining;\n\nif (transferable > 0) {\n// Transfer ETH to the beneficiary\nif (currency.ct == address(0))\nbeneficiary.receiveEthersTo.value(uint256(transferable))(address(0), \"\");\n\n// Transfer token to the beneficiary\nelse {\nTransferController controller = transferController(currency.ct, \"\");\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(transferable), currency.ct, currency.id\n)\n);\nrequire(success, \"Approval by controller failed [RevenueFund.sol:274]\");\n\nbeneficiary.receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\n}\n\nremaining = remaining.sub(transferable);\n}\n}\n}\n\n// Roll over remaining to next accrual period\nperiodAccrual.set(remaining, currency.ct, currency.id);\n}\n\n// Close accrual period of accrual beneficiaries\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n// Require that beneficiary fraction is strictly positive\nif (0 >= beneficiaryFraction(beneficiary))\ncontinue;\n\n// Close accrual period\nbeneficiary.closeAccrualPeriod(currencies);\n}\n\n// Emit event\nemit CloseAccrualPeriodEvent();","after":"s\nfunction closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata currencies)\npublic\nonlyOperator\n{\nrequire(\nConstantsLib.PARTS_PER() == totalBeneficiaryFraction,\n\"Total beneficiary fraction out of bounds [RevenueFund.sol:236]\"\n);\n\n// Execute transfer\nfor (uint256 i = 0; i < currencies.length; i++) {\nMonetaryTypesLib.Currency memory currency = currencies[i];\n\nint256 remaining = periodAccrual.get(currency.ct, currency.id);\n\nif (0 >= remaining)\ncontinue;\n\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\nif (beneficiaryFraction(beneficiary) > 0) {\nint256 transferable = periodAccrual.get(currency.ct, currency.id)\n.mul(beneficiaryFraction(beneficiary))\n.div(ConstantsLib.PARTS_PER());\n\nif (transferable > remaining)\ntransferable = remaining;\n\nif (transferable > 0) {\n// Transfer ETH to the beneficiary\nif (currency.ct == address(0))\nbeneficiary.receiveEthersTo.value(uint256(transferable))(address(0), \"\");\n\n// Transfer token to the beneficiary\nelse {\nTransferController controller = transferController(currency.ct, \"\");\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(transferable), currency.ct, currency.id\n)\n);\nrequire(success, \"Approval by controller failed [RevenueFund.sol:274]\");\n\nbeneficiary.receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\n}\n\nremaining = remaining.sub(transferable);\n}\n}\n}\n\n// Roll over remaining to next accrual period\nperiodAccrual.set(remaining, currency.ct, currency.id);\n}\n\n// Close accrual period of accrual beneficiaries\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n// Require that beneficiary fraction is strictly positive\nif (0 >= beneficiaryFraction(beneficiary))\ncontinue;\n\n// Close accrual period\nbeneficiary.closeAccrualPeriod(currencies);\n}\n\n// Emit event\nemit CloseAccrualPeriodEvent();","contract":"RevenueFund","time":1},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\npublic\n{\nemit CloseAccrualPeriodEvent();\n}","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata)\npublic\n{\nemit CloseAccrualPeriodEvent();\n}","contract":"RevenueFund","time":0},{"type":"struct-data-arrangement ","before":"\n{\naddress wall\n;\nuint256 non\n;\nuint256 referenceBlockNumb\n;\nuint256 definitionBlockNumb\n\n\nuint256 expirationTi\ns\nStatus stat\ns\nAmounts amoun\ny\nMonetaryTypesLib.Currency curren\np\nDriip challeng\ne\nbool walletInitiat\nd\nbool terminat\nn\nDisqualification disqualificati","after":";\nuint256 non\n;\nuint256 referenceBlockNumb\n;\nuint256 definitionBlockNumb\n\n\nuint256 expirationTi\ns\nStatus stat\ns\nAmounts amoun\ny\nMonetaryTypesLib.Currency curren\np\nDriip challeng\nn\nDisqualification disqualificati\n{\naddress wall\ne\nbool walletInitiat\nd\nbool terminat\n","contract":"SettlementChallengeTypesLib","time":0},{"type":"external-function ","before":"t\nfunction initiateProposal(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\nMonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated)\npublic\nonlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n{\n// Initiate proposal\n_initiateProposal(\nwallet, nonce, stageAmount, targetBalanceAmount,\ncurrency, blockNumber, walletInitiated\n);\n\n// Emit event\nemit InitiateProposalEvent(\nwallet, nonce, stageAmount, targetBalanceAmount, currency,\nblockNumber, walletInitiated\n);","after":"t\nfunction initiateProposal(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\nMonetaryTypesLib.Currency calldata currency, uint256 blockNumber, bool walletInitiated)\npublic\nonlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n{\n// Initiate proposal\n_initiateProposal(\nwallet, nonce, stageAmount, targetBalanceAmount,\ncurrency, blockNumber, walletInitiated\n);\n\n// Emit event\nemit InitiateProposalEvent(\nwallet, nonce, stageAmount, targetBalanceAmount, currency,\nblockNumber, walletInitiated\n);","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"y\nfunction terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);","after":"y\nfunction terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"d\nfunction terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:143]\");\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);","after":"d\nfunction terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:143]\");\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"y\nfunction removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n\n// Remove proposal\n_removeProposal(index);","after":"y\nfunction removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n\n// Remove proposal\n_removeProposal(index);","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"d\nfunction removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:197]\");\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n\n// Remove proposal\n_removeProposal(index);","after":"d\nfunction removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:197]\");\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n\n// Remove proposal\n_removeProposal(index);","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"d\nfunction disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\nuint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\npublic\nonlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\nrequire(0 != index, \"No settlement found for wallet and currency [NullSettlementChallengeState.sol:226]\");\n\n// Update proposal\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\nproposals[index - 1].disqualification.challenger = challengerWallet;\nproposals[index - 1].disqualification.nonce = candidateNonce;\nproposals[index - 1].disqualification.blockNumber = blockNumber;\nproposals[index - 1].disqualification.candidate.hash = candidateHash;\nproposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n// Emit event\nemit DisqualifyProposalEvent(\nchallengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency, proposals[index - 1].referenceBlockNumber,\nproposals[index - 1].walletInitiated, challengerWallet, candidateNonce, candidateHash, candidateKind\n);","after":"d\nfunction disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency calldata currency, address challengerWallet,\nuint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string calldata candidateKind)\npublic\nonlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\nrequire(0 != index, \"No settlement found for wallet and currency [NullSettlementChallengeState.sol:226]\");\n\n// Update proposal\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\nproposals[index - 1].disqualification.challenger = challengerWallet;\nproposals[index - 1].disqualification.nonce = candidateNonce;\nproposals[index - 1].disqualification.blockNumber = blockNumber;\nproposals[index - 1].disqualification.candidate.hash = candidateHash;\nproposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n// Emit event\nemit DisqualifyProposalEvent(\nchallengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency, proposals[index - 1].referenceBlockNumber,\nproposals[index - 1].walletInitiated, challengerWallet, candidateNonce, candidateHash, candidateKind\n);","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"e\nfunction hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nreturn 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];","after":"e\nfunction hasProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nreturn 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"e\nfunction hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:269]\");\nreturn proposals[index - 1].terminated;","after":"e\nfunction hasProposalTerminated(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:269]\");\nreturn proposals[index - 1].terminated;","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"e\nfunction hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:284]\");\nreturn block.timestamp >= proposals[index - 1].expirationTime;","after":"e\nfunction hasProposalExpired(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:284]\");\nreturn block.timestamp >= proposals[index - 1].expirationTime;","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"e\nfunction proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:298]\");\nreturn proposals[index - 1].nonce;","after":"e\nfunction proposalNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:298]\");\nreturn proposals[index - 1].nonce;","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"r\nfunction proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:312]\");\nreturn proposals[index - 1].referenceBlockNumber;","after":"r\nfunction proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:312]\");\nreturn proposals[index - 1].referenceBlockNumber;","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"r\nfunction proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:326]\");\nreturn proposals[index - 1].definitionBlockNumber;","after":"r\nfunction proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:326]\");\nreturn proposals[index - 1].definitionBlockNumber;","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"e\nfunction proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:340]\");\nreturn proposals[index - 1].expirationTime;","after":"e\nfunction proposalExpirationTime(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:340]\");\nreturn proposals[index - 1].expirationTime;","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"s\nfunction proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (SettlementChallengeTypesLib.Status)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:354]\");\nreturn proposals[index - 1].status;","after":"s\nfunction proposalStatus(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (SettlementChallengeTypesLib.Status)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:354]\");\nreturn proposals[index - 1].status;","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"t\nfunction proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:368]\");\nreturn proposals[index - 1].amounts.stage;","after":"t\nfunction proposalStageAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:368]\");\nreturn proposals[index - 1].amounts.stage;","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"t\nfunction proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:382]\");\nreturn proposals[index - 1].amounts.targetBalance;","after":"t\nfunction proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:382]\");\nreturn proposals[index - 1].amounts.targetBalance;","contract":"NullSettlementChallengeState","time":1},{"type":"external-function ","before":"d\nfunction proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:396]\");\nreturn proposals[index - 1].walletInitiated;","after":"d\nfunction proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:396]\");\nreturn proposals[index - 1].walletInitiated;","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"r\nfunction proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (address)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:410]\");\nreturn proposals[index - 1].disqualification.challenger;","after":"r\nfunction proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (address)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:410]\");\nreturn proposals[index - 1].disqualification.challenger;","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"r\nfunction proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:424]\");\nreturn proposals[index - 1].disqualification.blockNumber;","after":"r\nfunction proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:424]\");\nreturn proposals[index - 1].disqualification.blockNumber;","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"e\nfunction proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:438]\");\nreturn proposals[index - 1].disqualification.nonce;","after":"e\nfunction proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:438]\");\nreturn proposals[index - 1].disqualification.nonce;","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"h\nfunction proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:452]\");\nreturn proposals[index - 1].disqualification.candidate.hash;","after":"h\nfunction proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:452]\");\nreturn proposals[index - 1].disqualification.candidate.hash;","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"d\nfunction proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:466]\");\nreturn proposals[index - 1].disqualification.candidate.kind;","after":"d\nfunction proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:466]\");\nreturn proposals[index - 1].disqualification.candidate.kind;","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"e\nfunction maxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256) {\nreturn walletCurrencyMaxNonce[wallet][currency.ct][currency.id];","after":"e\nfunction maxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256) {\nreturn walletCurrencyMaxNonce[wallet][currency.ct][currency.id];","contract":"NullSettlementState","time":0},{"type":"external-function ","before":"e\nfunction setMaxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency,\nuint256 _maxNullNonce)\npublic\nonlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n{\n// Update max nonce value\nwalletCurrencyMaxNonce[wallet][currency.ct][currency.id] = _maxNullNonce;\n\n// Emit event\nemit SetMaxNonceByWalletAndCurrencyEvent(wallet, currency, _maxNullNonce);","after":"e\nfunction setMaxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency calldata currency,\nuint256 _maxNullNonce)\npublic\nonlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n{\n// Update max nonce value\nwalletCurrencyMaxNonce[wallet][currency.ct][currency.id] = _maxNullNonce;\n\n// Emit event\nemit SetMaxNonceByWalletAndCurrencyEvent(wallet, currency, _maxNullNonce);","contract":"NullSettlementState","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"NullSettlementState","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"NullSettlementState","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"NullSettlementState","time":0},{"type":"external-function ","before":"d\nfunction initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\nint256 targetBalanceAmount, MonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated,\nbytes32 challengedHash, string memory challengedKind)\npublic\nonlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n{\n// Initiate proposal\n_initiateProposal(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\ncurrency, blockNumber, walletInitiated, challengedHash, challengedKind\n);\n\n// Emit event\nemit InitiateProposalEvent(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\nblockNumber, walletInitiated, challengedHash, challengedKind\n);","after":"d\nfunction initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\nint256 targetBalanceAmount, MonetaryTypesLib.Currency calldata currency, uint256 blockNumber, bool walletInitiated,\nbytes32 challengedHash, string calldata challengedKind)\npublic\nonlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n{\n// Initiate proposal\n_initiateProposal(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\ncurrency, blockNumber, walletInitiated, challengedHash, challengedKind\n);\n\n// Emit event\nemit InitiateProposalEvent(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\nblockNumber, walletInitiated, challengedHash, challengedKind\n);","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"y\nfunction terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Clear wallet-nonce-currency triplet entry, which enables reinitiation of proposal for that triplet\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);","after":"y\nfunction terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool clearNonce)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Clear wallet-nonce-currency triplet entry, which enables reinitiation of proposal for that triplet\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"d\nfunction terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce,\nbool walletTerminated)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:163]\");\n\n// Clear wallet-nonce-currency triplet entry, which enables reinitiation of proposal for that triplet\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);","after":"d\nfunction terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool clearNonce,\nbool walletTerminated)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:163]\");\n\n// Clear wallet-nonce-currency triplet entry, which enables reinitiation of proposal for that triplet\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"y\nfunction removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n// Remove proposal\n_removeProposal(index);","after":"y\nfunction removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n// Remove proposal\n_removeProposal(index);","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"d\nfunction removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:223]\");\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n// Remove proposal\n_removeProposal(index);","after":"d\nfunction removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:223]\");\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n// Remove proposal\n_removeProposal(index);","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"d\nfunction disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\nuint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\npublic\nonlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:253]\");\n\n// Update proposal\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\nproposals[index - 1].disqualification.challenger = challengerWallet;\nproposals[index - 1].disqualification.nonce = candidateNonce;\nproposals[index - 1].disqualification.blockNumber = blockNumber;\nproposals[index - 1].disqualification.candidate.hash = candidateHash;\nproposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n// Emit event\nemit DisqualifyProposalEvent(\nchallengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\ncurrency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nchallengerWallet, candidateNonce, candidateHash, candidateKind\n);","after":"d\nfunction disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency calldata currency, address challengerWallet,\nuint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string calldata candidateKind)\npublic\nonlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:253]\");\n\n// Update proposal\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\nproposals[index - 1].disqualification.challenger = challengerWallet;\nproposals[index - 1].disqualification.nonce = candidateNonce;\nproposals[index - 1].disqualification.blockNumber = blockNumber;\nproposals[index - 1].disqualification.candidate.hash = candidateHash;\nproposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n// Emit event\nemit DisqualifyProposalEvent(\nchallengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\ncurrency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nchallengerWallet, candidateNonce, candidateHash, candidateKind\n);","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"y\nfunction qualifyProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nonlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:282]\");\n\n// Emit event\nemit QualifyProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].disqualification.challenger,\nproposals[index - 1].disqualification.nonce,\nproposals[index - 1].disqualification.candidate.hash,\nproposals[index - 1].disqualification.candidate.kind\n);\n\n// Update proposal\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\ndelete proposals[index - 1].disqualification;","after":"y\nfunction qualifyProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nonlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:282]\");\n\n// Emit event\nemit QualifyProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].disqualification.challenger,\nproposals[index - 1].disqualification.nonce,\nproposals[index - 1].disqualification.candidate.hash,\nproposals[index - 1].disqualification.candidate.kind\n);\n\n// Update proposal\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\ndelete proposals[index - 1].disqualification;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"e\nfunction hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nreturn 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];","after":"e\nfunction hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nreturn 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"e\nfunction hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nreturn 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];","after":"e\nfunction hasProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nreturn 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"e\nfunction hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:340]\");\nreturn proposals[index - 1].terminated;","after":"e\nfunction hasProposalTerminated(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:340]\");\nreturn proposals[index - 1].terminated;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"e\nfunction hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:355]\");\nreturn block.timestamp >= proposals[index - 1].expirationTime;","after":"e\nfunction hasProposalExpired(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:355]\");\nreturn block.timestamp >= proposals[index - 1].expirationTime;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"e\nfunction proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:369]\");\nreturn proposals[index - 1].nonce;","after":"e\nfunction proposalNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:369]\");\nreturn proposals[index - 1].nonce;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"r\nfunction proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:383]\");\nreturn proposals[index - 1].referenceBlockNumber;","after":"r\nfunction proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:383]\");\nreturn proposals[index - 1].referenceBlockNumber;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"r\nfunction proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:397]\");\nreturn proposals[index - 1].definitionBlockNumber;","after":"r\nfunction proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:397]\");\nreturn proposals[index - 1].definitionBlockNumber;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"e\nfunction proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:411]\");\nreturn proposals[index - 1].expirationTime;","after":"e\nfunction proposalExpirationTime(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:411]\");\nreturn proposals[index - 1].expirationTime;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"s\nfunction proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (SettlementChallengeTypesLib.Status)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:425]\");\nreturn proposals[index - 1].status;","after":"s\nfunction proposalStatus(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (SettlementChallengeTypesLib.Status)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:425]\");\nreturn proposals[index - 1].status;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"t\nfunction proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:439]\");\nreturn proposals[index - 1].amounts.cumulativeTransfer;","after":"t\nfunction proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:439]\");\nreturn proposals[index - 1].amounts.cumulativeTransfer;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"t\nfunction proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:453]\");\nreturn proposals[index - 1].amounts.stage;","after":"t\nfunction proposalStageAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:453]\");\nreturn proposals[index - 1].amounts.stage;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"t\nfunction proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:467]\");\nreturn proposals[index - 1].amounts.targetBalance;","after":"t\nfunction proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:467]\");\nreturn proposals[index - 1].amounts.targetBalance;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"h\nfunction proposalChallengedHash(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:481]\");\nreturn proposals[index - 1].challenged.hash;","after":"h\nfunction proposalChallengedHash(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:481]\");\nreturn proposals[index - 1].challenged.hash;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"d\nfunction proposalChallengedKind(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:495]\");\nreturn proposals[index - 1].challenged.kind;","after":"d\nfunction proposalChallengedKind(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:495]\");\nreturn proposals[index - 1].challenged.kind;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"d\nfunction proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:509]\");\nreturn proposals[index - 1].walletInitiated;","after":"d\nfunction proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:509]\");\nreturn proposals[index - 1].walletInitiated;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"r\nfunction proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (address)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:523]\");\nreturn proposals[index - 1].disqualification.challenger;","after":"r\nfunction proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (address)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:523]\");\nreturn proposals[index - 1].disqualification.challenger;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"e\nfunction proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:537]\");\nreturn proposals[index - 1].disqualification.nonce;","after":"e\nfunction proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:537]\");\nreturn proposals[index - 1].disqualification.nonce;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"r\nfunction proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:551]\");\nreturn proposals[index - 1].disqualification.blockNumber;","after":"r\nfunction proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:551]\");\nreturn proposals[index - 1].disqualification.blockNumber;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"h\nfunction proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:565]\");\nreturn proposals[index - 1].disqualification.candidate.hash;","after":"h\nfunction proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:565]\");\nreturn proposals[index - 1].disqualification.candidate.hash;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"d\nfunction proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:579]\");\nreturn proposals[index - 1].disqualification.candidate.kind;","after":"d\nfunction proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:579]\");\nreturn proposals[index - 1].disqualification.candidate.kind;","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":")\nfunction settleNull(address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\n// Settle null\n_settleNull(msg.sender, MonetaryTypesLib.Currency(currencyCt, currencyId), standard);\n\n// Emit event\nemit SettleNullEvent(msg.sender, currencyCt, currencyId, standard);","after":")\nfunction settleNull(address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\n// Settle null\n_settleNull(msg.sender, MonetaryTypesLib.Currency(currencyCt, currencyId), standard);\n\n// Emit event\nemit SettleNullEvent(msg.sender, currencyCt, currencyId, standard);","contract":"NullSettlement","time":0},{"type":"external-function ","before":")\nfunction settleNullByProxy(address wallet, address currencyCt, uint256 currencyId, string memory standard)\npublic\nonlyOperator\n{\n// Settle null of wallet\n_settleNull(wallet, MonetaryTypesLib.Currency(currencyCt, currencyId), standard);\n\n// Emit event\nemit SettleNullByProxyEvent(msg.sender, wallet, currencyCt, currencyId, standard);","after":")\nfunction settleNullByProxy(address wallet, address currencyCt, uint256 currencyId, string calldata standard)\npublic\nonlyOperator\n{\n// Settle null of wallet\n_settleNull(wallet, MonetaryTypesLib.Currency(currencyCt, currencyId), standard);\n\n// Emit event\nemit SettleNullByProxyEvent(msg.sender, wallet, currencyCt, currencyId, standard);","contract":"NullSettlement","time":0}]}