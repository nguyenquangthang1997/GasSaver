{"time":280,"results":[{"type":"external-function ","before":"function propose(Transaction[] memory transactions) public onlyRoleHolder(uint(Roles.Proposer)) {\n\n        uint id = proposals.length;\n\n        uint time = getCurrentTime();\n\n\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\n\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\n\n\n\n        // Add an element to the proposals array.\n\n        proposals.length = proposals.length.add(1);\n\n\n        // Initialize the new proposal.\n\n        Proposal storage proposal = proposals[id];\n\n        proposal.requestTime = time;\n\n\n        // Initialize the transaction array.\n\n        proposal.transactions.length = transactions.length;\n\n        for (uint i = 0; i < transactions.length; i++) {\n\n            require(transactions[i].to != address(0), \"The to address cannot be 0x0\");\n\n            proposal.transactions[i] = transactions[i];\n\n        }\n\n\n        bytes32 identifier = _constructIdentifier(id);\n\n\n        // Request a vote on this proposal in the DVM.\n\n        Voting voting = _getVoting();\n\n        voting.addSupportedIdentifier(identifier);\n\n\n        // Note: this check is only here to appease slither.\n\n        require(voting.requestPrice(identifier, time) != ~uint(0), \"Proposal will never be considered\");\n\n        voting.removeSupportedIdentifier(identifier);\n\n\n        emit NewProposal(id, transactions);\n\n    }","after":"function propose(Transaction[] calldata transactions) public onlyRoleHolder(uint(Roles.Proposer)) {\n\n        uint id = proposals.length;\n\n        uint time = getCurrentTime();\n\n\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\n\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\n\n\n\n        // Add an element to the proposals array.\n\n        proposals.length = proposals.length.add(1);\n\n\n        // Initialize the new proposal.\n\n        Proposal storage proposal = proposals[id];\n\n        proposal.requestTime = time;\n\n\n        // Initialize the transaction array.\n\n        proposal.transactions.length = transactions.length;\n\n        for (uint i = 0; i < transactions.length; i++) {\n\n            require(transactions[i].to != address(0), \"The to address cannot be 0x0\");\n\n            proposal.transactions[i] = transactions[i];\n\n        }\n\n\n        bytes32 identifier = _constructIdentifier(id);\n\n\n        // Request a vote on this proposal in the DVM.\n\n        Voting voting = _getVoting();\n\n        voting.addSupportedIdentifier(identifier);\n\n\n        // Note: this check is only here to appease slither.\n\n        require(voting.requestPrice(identifier, time) != ~uint(0), \"Proposal will never be considered\");\n\n        voting.removeSupportedIdentifier(identifier);\n\n\n        emit NewProposal(id, transactions);\n\n    }","contract":"Governor","time":0},{"type":"immutable-restrict-modification ","before":"bool public isTest;","after":"bool public immutable isTest;","contract":"Governor","time":1},{"type":"external-function ","before":"function setInflationRate(FixedPoint.Unsigned memory _inflationRate) public onlyOwner {\n\n        inflationRate = _inflationRate;\n\n    }","after":"function setInflationRate(FixedPoint.Unsigned calldata _inflationRate) public onlyOwner {\n\n        inflationRate = _inflationRate;\n\n    }","contract":"Voting","time":0},{"type":"external-function ","before":"function retrieveRewards(address voterAddress, uint roundId, PendingRequest[] memory toRetrieve)\n\n    public\n\n    returns (FixedPoint.Unsigned memory totalRewardToIssue)\n\n    {\n\n        if (migratedAddress != address(0)) {\n\n            require(msg.sender == migratedAddress);\n\n        }\n\n        uint blockTime = getCurrentTime();\n\n        _updateRound(blockTime);\n\n        require(roundId < voteTiming.computeCurrentRoundId(blockTime));\n\n\n        Round storage round = rounds[roundId];\n\n        FixedPoint.Unsigned memory snapshotBalance = FixedPoint.Unsigned(\n\n            votingToken.balanceOfAt(voterAddress, round.snapshotId));\n\n\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\n\n        FixedPoint.Unsigned memory snapshotTotalSupply = FixedPoint.Unsigned(\n\n            votingToken.totalSupplyAt(round.snapshotId));\n\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\n\n\n        // Keep track of the voter's accumulated token reward.\n\n        totalRewardToIssue = FixedPoint.Unsigned(0);\n\n\n        for (uint i = 0; i < toRetrieve.length; i++) {\n\n            PriceRequest storage priceRequest = _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time);\n\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n\n\n            require(priceRequest.lastVotingRound == roundId, \"Only retrieve rewards for votes resolved in same round\");\n\n\n            _resolvePriceRequest(priceRequest, voteInstance);\n\n\n            if (voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)) {\n\n                // The price was successfully resolved during the voter's last voting round, the voter revealed and was\n\n                // correct, so they are elgible for a reward.\n\n                FixedPoint.Unsigned memory correctTokens = voteInstance.resultComputation.\n\n                getTotalCorrectlyVotedTokens();\n\n\n                // Compute the reward and add to the cumulative reward.\n\n                FixedPoint.Unsigned memory reward = snapshotBalance.mul(totalRewardPerVote).div(correctTokens);\n\n                totalRewardToIssue = totalRewardToIssue.add(reward);\n\n\n                // Emit reward retrieval for this vote.\n\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time,\n\n                    reward.rawValue);\n\n            } else {\n\n                // Emit a 0 token retrieval on incorrect votes.\n\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n\n            }\n\n\n            // Delete the submission to capture any refund and clean up storage.\n\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\n\n        }\n\n\n        // Issue any accumulated rewards.\n\n        if (totalRewardToIssue.isGreaterThan(0)) {\n\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue));\n\n        }\n\n    }","after":"function retrieveRewards(address voterAddress, uint roundId, PendingRequest[] calldata toRetrieve)\n\n    public\n\n    returns (FixedPoint.Unsigned memory totalRewardToIssue)\n\n    {\n\n        if (migratedAddress != address(0)) {\n\n            require(msg.sender == migratedAddress);\n\n        }\n\n        uint blockTime = getCurrentTime();\n\n        _updateRound(blockTime);\n\n        require(roundId < voteTiming.computeCurrentRoundId(blockTime));\n\n\n        Round storage round = rounds[roundId];\n\n        FixedPoint.Unsigned memory snapshotBalance = FixedPoint.Unsigned(\n\n            votingToken.balanceOfAt(voterAddress, round.snapshotId));\n\n\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\n\n        FixedPoint.Unsigned memory snapshotTotalSupply = FixedPoint.Unsigned(\n\n            votingToken.totalSupplyAt(round.snapshotId));\n\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\n\n\n        // Keep track of the voter's accumulated token reward.\n\n        totalRewardToIssue = FixedPoint.Unsigned(0);\n\n\n        for (uint i = 0; i < toRetrieve.length; i++) {\n\n            PriceRequest storage priceRequest = _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time);\n\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n\n\n            require(priceRequest.lastVotingRound == roundId, \"Only retrieve rewards for votes resolved in same round\");\n\n\n            _resolvePriceRequest(priceRequest, voteInstance);\n\n\n            if (voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)) {\n\n                // The price was successfully resolved during the voter's last voting round, the voter revealed and was\n\n                // correct, so they are elgible for a reward.\n\n                FixedPoint.Unsigned memory correctTokens = voteInstance.resultComputation.\n\n                getTotalCorrectlyVotedTokens();\n\n\n                // Compute the reward and add to the cumulative reward.\n\n                FixedPoint.Unsigned memory reward = snapshotBalance.mul(totalRewardPerVote).div(correctTokens);\n\n                totalRewardToIssue = totalRewardToIssue.add(reward);\n\n\n                // Emit reward retrieval for this vote.\n\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time,\n\n                    reward.rawValue);\n\n            } else {\n\n                // Emit a 0 token retrieval on incorrect votes.\n\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n\n            }\n\n\n            // Delete the submission to capture any refund and clean up storage.\n\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\n\n        }\n\n\n        // Issue any accumulated rewards.\n\n        if (totalRewardToIssue.isGreaterThan(0)) {\n\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue));\n\n        }\n\n    }","contract":"Voting","time":0},{"type":"external-function ","before":"function setPublicKey(bytes memory publicKey, bytes32 topicHash) public {\n\n        require(publicKey.length == 64, \"Public key is the wrong length\");\n\n        recipients[msg.sender].topics[topicHash].publicKey = publicKey;\n\n    }","after":"function setPublicKey(bytes calldata publicKey, bytes32 topicHash) public {\n\n        require(publicKey.length == 64, \"Public key is the wrong length\");\n\n        recipients[msg.sender].topics[topicHash].publicKey = publicKey;\n\n    }","contract":"Voting","time":0},{"type":"immutable-restrict-modification ","before":"bool public isTest;","after":"bool public immutable isTest;","contract":"Voting","time":1}]}