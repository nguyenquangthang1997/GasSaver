{"time":139,"results":[{"type":"state-data-arrangement ","before":"\nbool public saleIsActive;\nuint256 public maxByMint;\nuint256 public maxSupply;\nuint256 public maxPublicSupply;\nuint256 public maxReservedSupply;\nuint256 public totalPublicSupply;\nuint256 public totalReservedSupply;\nuint256 public fixedPrice;\naddress public daoAddress;\nstring internal baseTokenURI;","after":"uint256 public maxByMint;\nuint256 public maxSupply;\nuint256 public maxPublicSupply;\nuint256 public maxReservedSupply;\nuint256 public totalPublicSupply;\nuint256 public totalReservedSupply;\nuint256 public fixedPrice;\nstring internal baseTokenURI;\naddress public daoAddress;\nbool public saleIsActive;\n","contract":"Grailer","time":0},{"type":"external-function ","before":"function setBaseTokenURI(string memory _baseTokenURI) external onlyOwner {\n        baseTokenURI = _baseTokenURI;\n    }","after":"function setBaseTokenURI(string calldata _baseTokenURI) external onlyOwner {\n        baseTokenURI = _baseTokenURI;\n    }","contract":"Grailer","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n        nonce : nonces[userAddress],\n        from : userAddress,\n        functionSignature : functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n        nonce : nonces[userAddress],\n        from : userAddress,\n        functionSignature : functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"Grailer","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public maxByMint;","after":"uint256 public immutable maxByMint;","contract":"Grailer","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public maxSupply;","after":"uint256 public immutable maxSupply;","contract":"Grailer","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public maxPublicSupply;","after":"uint256 public immutable maxPublicSupply;","contract":"Grailer","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public maxReservedSupply;","after":"uint256 public immutable maxReservedSupply;","contract":"Grailer","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public fixedPrice;","after":"uint256 public immutable fixedPrice;","contract":"Grailer","time":1},{"type":"immutable-restrict-modification ","before":"address internal proxyRegistryAddress;","after":"address internal immutable proxyRegistryAddress;","contract":"Grailer","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"Grailer","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"Grailer","time":1}]}