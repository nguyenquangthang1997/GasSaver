{"time":893,"results":[{"type":"loop-calculation","before":"RateData storage rate = tokenRates[farm.token];","after":"// move outside for loop\nRateData storage rate = tokenRates[farm.token];","loc":{"start":{"line":1212,"column":12},"end":{"line":1212,"column":58}},"contract":"CoreEvent","time":0},{"type":"state-data-arrangement ","before":"\nDurationInfo public durationInfo;\naddress public immutable treasuryAddress;\nEnumerableSet.AddressSet private supportedTokenAddresses;\nmapping(address => SupportedTokenData) public supportedTokens;\nmapping(address => mapping(address => AccountData)) public accountData;\nmapping(address => RateData) public tokenRates;\nWhitelistSettings public whitelistSettings;\nbool public stage1Locked;","after":"DurationInfo public durationInfo;\nEnumerableSet.AddressSet private supportedTokenAddresses;\nmapping(address => SupportedTokenData) public supportedTokens;\nmapping(address => mapping(address => AccountData)) public accountData;\nmapping(address => RateData) public tokenRates;\nWhitelistSettings public whitelistSettings;\naddress public immutable treasuryAddress;\nbool public stage1Locked;\n","contract":"CoreEvent","time":0},{"type":"external-function ","before":"function configureWhitelist(WhitelistSettings memory settings) external override onlyOwner {\n        whitelistSettings = settings;\n        emit WhitelistConfigured(settings);\n    }","after":"function configureWhitelist(WhitelistSettings calldata settings) external override onlyOwner {\n        whitelistSettings = settings;\n        emit WhitelistConfigured(settings);\n    }","contract":"CoreEvent","time":0},{"type":"loop-calculation","before":"AccountData memory accountTokenInfo = accountData[account];","after":"// move outside for loop\nAccountData memory accountTokenInfo = accountData[account];","loc":{"start":{"line":1607,"column":0},"end":{"line":1607,"column":58}},"contract":"DefiRound","time":0},{"type":"state-data-arrangement ","before":"\naddress public immutable WETH;\naddress public override immutable treasury;\nOversubscriptionRate public overSubscriptionRate;\nmapping(address => uint256) public override totalSupply;\nmapping(address => AccountData) private accountData;\nmapping(address => RateData) private tokenRates;\nmapping(address => SupportedTokenData) private tokenSettings;\nEnumerableSet.AddressSet private supportedTokens;\nEnumerableSet.AddressSet private configuredTokenRates;\nSTAGES public override currentStage;\nWhitelistSettings public whitelistSettings;\nuint256 public lastLookExpiration = type(uint256).max;\nuint256 private immutable maxTotalValue;\nbool private stage1Locked;","after":"OversubscriptionRate public overSubscriptionRate;\nmapping(address => uint256) public override totalSupply;\nmapping(address => AccountData) private accountData;\nmapping(address => RateData) private tokenRates;\nmapping(address => SupportedTokenData) private tokenSettings;\nEnumerableSet.AddressSet private supportedTokens;\nEnumerableSet.AddressSet private configuredTokenRates;\nSTAGES public override currentStage;\nWhitelistSettings public whitelistSettings;\nuint256 public lastLookExpiration = type(uint256).max;\nuint256 private immutable maxTotalValue;\naddress public immutable WETH;\naddress public override immutable treasury;\nbool private stage1Locked;\n","contract":"DefiRound","time":0},{"type":"external-function ","before":"function deposit(TokenData calldata tokenInfo, bytes32[] memory proof) external payable override {\nrequire(currentStage == STAGES.STAGE_1, \"DEPOSITS_NOT_ACCEPTED\");\nrequire(!stage1Locked, \"DEPOSITS_LOCKED\");\n\nif (whitelistSettings.enabled) {\nrequire(verifyDepositor(msg.sender, whitelistSettings.root, proof), \"PROOF_INVALID\");\n}\n\nTokenData memory data = tokenInfo;\naddress token = data.token;\nuint256 tokenAmount = data.amount;\nrequire(supportedTokens.contains(token), \"UNSUPPORTED_TOKEN\");\nrequire(tokenAmount > 0, \"INVALID_AMOUNT\");\n\n// Convert ETH to WETH if ETH is passed in, otherwise treat WETH as a regular ERC20\nif (token == WETH && msg.value > 0) {\nrequire(tokenAmount == msg.value, \"INVALID_MSG_VALUE\");\nIWETH(WETH).deposit{value : tokenAmount}();\n} else {\nrequire(msg.value == 0, \"NO_ETH\");\n}\n\nAccountData storage tokenAccountData = accountData[msg.sender];\n\nif (tokenAccountData.token == address(0)) {\ntokenAccountData.token = token;\n}\n\nrequire(tokenAccountData.token == token, \"SINGLE_ASSET_DEPOSITS\");\n\ntokenAccountData.initialDeposit = tokenAccountData.initialDeposit.add(tokenAmount);\ntokenAccountData.currentBalance = tokenAccountData.currentBalance.add(tokenAmount);\n\nrequire(tokenAccountData.currentBalance <= tokenSettings[token].maxLimit, \"MAX_LIMIT_EXCEEDED\");\n\n// No need to transfer from msg.sender since is ETH was converted to WETH\nif (!(token == WETH && msg.value > 0)) {\nIERC20(token).safeTransferFrom(msg.sender, address(this), tokenAmount);\n}\n\nif (_totalValue() > maxTotalValue) {\nstage1Locked = true;\n}\n\nemit Deposited(msg.sender, tokenInfo);\n}","after":"function deposit(TokenData calldata tokenInfo, bytes32[] calldata proof) external payable override {\nrequire(currentStage == STAGES.STAGE_1, \"DEPOSITS_NOT_ACCEPTED\");\nrequire(!stage1Locked, \"DEPOSITS_LOCKED\");\n\nif (whitelistSettings.enabled) {\nrequire(verifyDepositor(msg.sender, whitelistSettings.root, proof), \"PROOF_INVALID\");\n}\n\nTokenData memory data = tokenInfo;\naddress token = data.token;\nuint256 tokenAmount = data.amount;\nrequire(supportedTokens.contains(token), \"UNSUPPORTED_TOKEN\");\nrequire(tokenAmount > 0, \"INVALID_AMOUNT\");\n\n// Convert ETH to WETH if ETH is passed in, otherwise treat WETH as a regular ERC20\nif (token == WETH && msg.value > 0) {\nrequire(tokenAmount == msg.value, \"INVALID_MSG_VALUE\");\nIWETH(WETH).deposit{value : tokenAmount}();\n} else {\nrequire(msg.value == 0, \"NO_ETH\");\n}\n\nAccountData storage tokenAccountData = accountData[msg.sender];\n\nif (tokenAccountData.token == address(0)) {\ntokenAccountData.token = token;\n}\n\nrequire(tokenAccountData.token == token, \"SINGLE_ASSET_DEPOSITS\");\n\ntokenAccountData.initialDeposit = tokenAccountData.initialDeposit.add(tokenAmount);\ntokenAccountData.currentBalance = tokenAccountData.currentBalance.add(tokenAmount);\n\nrequire(tokenAccountData.currentBalance <= tokenSettings[token].maxLimit, \"MAX_LIMIT_EXCEEDED\");\n\n// No need to transfer from msg.sender since is ETH was converted to WETH\nif (!(token == WETH && msg.value > 0)) {\nIERC20(token).safeTransferFrom(msg.sender, address(this), tokenAmount);\n}\n\nif (_totalValue() > maxTotalValue) {\nstage1Locked = true;\n}\n\nemit Deposited(msg.sender, tokenInfo);\n}","contract":"DefiRound","time":0},{"type":"external-function ","before":"function configureWhitelist(WhitelistSettings memory settings) external override onlyOwner {\nwhitelistSettings = settings;\nemit WhitelistConfigured(settings);\n}","after":"function configureWhitelist(WhitelistSettings calldata settings) external override onlyOwner {\nwhitelistSettings = settings;\nemit WhitelistConfigured(settings);\n}","contract":"DefiRound","time":0},{"type":"external-function ","before":"function publishRates(RateData[] calldata ratesData, OversubscriptionRate memory oversubRate, uint256 lastLookDuration) external override onlyOwner {\n// check rates havent been published before\nrequire(currentStage == STAGES.STAGE_1, \"RATES_ALREADY_SET\");\nrequire(lastLookDuration > 0, \"INVALID_DURATION\");\nrequire(oversubRate.overDenominator > 0, \"INVALID_DENOMINATOR\");\nrequire(oversubRate.overNumerator > 0, \"INVALID_NUMERATOR\");\n\nuint256 ratesLength = ratesData.length;\nfor (uint256 i = 0; i < ratesLength; i++) {\nRateData memory data = ratesData[i];\nrequire(data.numerator > 0, \"INVALID_NUMERATOR\");\nrequire(data.denominator > 0, \"INVALID_DENOMINATOR\");\nrequire(tokenRates[data.token].token == address(0), \"RATE_ALREADY_SET\");\nrequire(configuredTokenRates.add(data.token), \"ALREADY_CONFIGURED\");\ntokenRates[data.token] = data;\n}\n\nrequire(configuredTokenRates.length() == supportedTokens.length(), \"MISSING_RATE\");\n\n// Stage only moves forward when prices are published\ncurrentStage = STAGES.STAGE_2;\nlastLookExpiration = block.number + lastLookDuration;\noverSubscriptionRate = oversubRate;\n\nemit RatesPublished(ratesData);\n}","after":"function publishRates(RateData[] calldata ratesData, OversubscriptionRate calldata oversubRate, uint256 lastLookDuration) external override onlyOwner {\n// check rates havent been published before\nrequire(currentStage == STAGES.STAGE_1, \"RATES_ALREADY_SET\");\nrequire(lastLookDuration > 0, \"INVALID_DURATION\");\nrequire(oversubRate.overDenominator > 0, \"INVALID_DENOMINATOR\");\nrequire(oversubRate.overNumerator > 0, \"INVALID_NUMERATOR\");\n\nuint256 ratesLength = ratesData.length;\nfor (uint256 i = 0; i < ratesLength; i++) {\nRateData memory data = ratesData[i];\nrequire(data.numerator > 0, \"INVALID_NUMERATOR\");\nrequire(data.denominator > 0, \"INVALID_DENOMINATOR\");\nrequire(tokenRates[data.token].token == address(0), \"RATE_ALREADY_SET\");\nrequire(configuredTokenRates.add(data.token), \"ALREADY_CONFIGURED\");\ntokenRates[data.token] = data;\n}\n\nrequire(configuredTokenRates.length() == supportedTokens.length(), \"MISSING_RATE\");\n\n// Stage only moves forward when prices are published\ncurrentStage = STAGES.STAGE_2;\nlastLookExpiration = block.number + lastLookDuration;\noverSubscriptionRate = oversubRate;\n\nemit RatesPublished(ratesData);\n}","contract":"DefiRound","time":0},{"type":"external-function ","before":"   function initialize(\n        IWETH _weth,\n        IManager _manager,\n        string memory _name,\n        string memory _symbol\n    ) public initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20_init_unchained(_name, _symbol);\n        weth = _weth;\n        manager = _manager;\n        withheldLiquidity = 0;\n\n        approveManager(type(uint256).max);\n  ","after":"   function initialize(\n        IWETH _weth,\n        IManager _manager,\n        string calldata _name,\n        string calldata _symbol\n    ) public initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20_init_unchained(_name, _symbol);\n        weth = _weth;\n        manager = _manager;\n        withheldLiquidity = 0;\n\n        approveManager(type(uint256).max);\n  ","contract":"EthPool","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"EthPool","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"EthPool","time":0},{"type":"struct-data-arrangement ","before":"\n   address to\n   uint256 maxUserLi\n   bool systemFinali","after":"   uint256 maxUserLi\n   address to\n   bool systemFinali\n","contract":"ICoreEvent","time":0},{"type":"struct-data-arrangement ","before":"\n   address to\n   uint256 depositedBala\n   bool finali","after":"   uint256 depositedBala\n   address to\n   bool finali\n","contract":"ICoreEvent","time":0},{"type":"struct-data-arrangement ","before":"\n   uint256 cl\n   uint256 durat\n   uint256 inter\n   bool se\n   bool isAct\n   uint256 hardSt\n   bool isPub","after":"   uint256 cl\n   uint256 durat\n   uint256 inter\n   uint256 hardSt\n   bool se\n   bool isAct\n   bool isPub\n","contract":"IStaking","time":0},{"type":"struct-data-arrangement ","before":"\n   IERC20TokenV06 makerTo\n   IERC20TokenV06 takerTo\n   uint128 makerAmo\n   uint128 takerAmo\n   uint128 takerTokenFeeAmo\n   address ma\n   address ta\n   address sen\n   address feeRecipi\n   bytes32 p\n   uint64 exp\n   uint256 s","after":"   IERC20TokenV06 makerTo\n   IERC20TokenV06 takerTo\n   bytes32 p\n   uint256 s\n   address ma\n   address ta\n   address sen\n   address feeRecipi\n   uint128 makerAmo\n   uint128 takerAmo\n   uint128 takerTokenFeeAmo\n   uint64 exp\n","contract":"LibNativeOrder","time":2},{"type":"struct-data-arrangement ","before":"\n   IERC20TokenV06 makerTo\n   IERC20TokenV06 takerTo\n   uint128 makerAmo\n   uint128 takerAmo\n   address ma\n   address ta\n   address txOri\n   bytes32 p\n   uint64 exp\n   uint256 s","after":"   IERC20TokenV06 makerTo\n   IERC20TokenV06 takerTo\n   bytes32 p\n   uint256 s\n   address ma\n   address ta\n   address txOri\n   uint128 makerAmo\n   uint128 takerAmo\n   uint64 exp\n","contract":"LibNativeOrder","time":1},{"type":"external-function ","before":"   function updateInvocationCount(bytes4 methodId, bytes memory originalMsgData) public {\n        require(msg.sender == address(this), \"Can only be called from the contract itself\");\n        invocations += 1;\n        methodIdInvocations[keccak256(abi.encodePacked(resetCount, methodId))] += 1;\n        calldataInvocations[keccak256(abi.encodePacked(resetCount, originalMsgData))] += 1;\n  ","after":"   function updateInvocationCount(bytes4 methodId, bytes calldata originalMsgData) public {\n        require(msg.sender == address(this), \"Can only be called from the contract itself\");\n        invocations += 1;\n        methodIdInvocations[keccak256(abi.encodePacked(resetCount, methodId))] += 1;\n        calldataInvocations[keccak256(abi.encodePacked(resetCount, originalMsgData))] += 1;\n  ","contract":"MockContract","time":0},{"type":"external-function ","before":"   function initialize(\n        IERC20 _underlyer,\n        IManager _manager,\n        string memory _name,\n        string memory _symbol\n    ) public initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20_init_unchained(_name, _symbol);\n        underlyer = _underlyer;\n        manager = _manager;\n\n        approveManager(type(uint256).max);\n  ","after":"   function initialize(\n        IERC20 _underlyer,\n        IManager _manager,\n        string calldata _name,\n        string calldata _symbol\n    ) public initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20_init_unchained(_name, _symbol);\n        underlyer = _underlyer;\n        manager = _manager;\n\n        approveManager(type(uint256).max);\n  ","contract":"Pool","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"Pool","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"Pool","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"PreToke","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"PreToke","time":1},{"type":"external-function ","before":"}\n\nfunction addSchedule(StakingSchedule memory schedule) external override onlyOwner {\n_addSchedule(schedule)","after":"}\n\nfunction addSchedule(StakingSchedule calldata schedule) external override onlyOwner {\n_addSchedule(schedule)","contract":"Staking","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"Toke","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"Toke","time":1},{"type":"immutable-restrict-modification ","before":"   address public manag","after":"   address public manag","contract":"ZeroExTradeWallet","time":0}]}