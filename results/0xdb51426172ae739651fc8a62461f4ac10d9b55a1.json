{"time":338,"results":[{"type":"loop-duplication","before":"\nstart line 1379 column 8, end line 1381 column 8\nfor (uint256 i = 0; i < n; i++) {\n            quantities[0] = quantities[0].add(rightSupplies[i]);\n        }\nstart line 1384 column 8, end line 1386 column 8\nfor (uint256 i = 0; i < n; i++) {\n            quantities[i + 1] = quantities[i].add(leftSupplies[i]).sub(rightSupplies[i]);\n        }","after":"// merge loop\n\nstart line 1379 column 8, end line 1381 column 8\nfor (uint256 i = 0; i < n; i++) {\n            quantities[0] = quantities[0].add(rightSupplies[i]);\n        }\nstart line 1384 column 8, end line 1386 column 8\nfor (uint256 i = 0; i < n; i++) {\n            quantities[i + 1] = quantities[i].add(leftSupplies[i]).sub(rightSupplies[i]);\n        }","contract":"OptionMath","time":0},{"type":"external-function ","before":"function initialize(\n        address _market,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) public initializer {\n        __ERC20_init(name, symbol);\n        _setupDecimals(decimals);\n        market = _market;\n    }","after":"function initialize(\n        address _market,\n        string calldata name,\n        string calldata symbol,\n        uint8 decimals\n    ) public initializer {\n        __ERC20_init(name, symbol);\n        _setupDecimals(decimals);\n        market = _market;\n    }","contract":"OptionToken","time":0},{"type":"state-data-arrangement ","before":"\nuint256 public constant SCALE = 1e18;\nuint256 public constant SCALE_SCALE = 1e36;\nIERC20 public baseToken;\nIOracle public oracle;\nOptionToken[] public longTokens;\nOptionToken[] public shortTokens;\nuint256[] public strikePrices;\nuint256 public expiryTime;\nbool public isPut;\nuint256 public tradingFee;\nuint256 public balanceCap;\nuint256 public totalSupplyCap;\nuint256 public disputePeriod;\nbool public isPaused;\nbool public isSettled;\nuint256 public expiryPrice;\nuint256 public lastCost;\nuint256 public lastPayoff;\nuint256 public poolValue;","after":"uint256 public constant SCALE = 1e18;\nuint256 public constant SCALE_SCALE = 1e36;\nIERC20 public baseToken;\nIOracle public oracle;\nOptionToken[] public longTokens;\nOptionToken[] public shortTokens;\nuint256[] public strikePrices;\nuint256 public expiryTime;\nuint256 public tradingFee;\nuint256 public balanceCap;\nuint256 public totalSupplyCap;\nuint256 public disputePeriod;\nuint256 public expiryPrice;\nuint256 public lastCost;\nuint256 public lastPayoff;\nuint256 public poolValue;\nbool public isPut;\nbool public isPaused;\nbool public isSettled;\n","contract":"OptionMarket","time":1},{"type":"external-function ","before":"function initialize(\n        address _baseToken,\n        address _oracle,\n        address[] memory _longTokens,\n        address[] memory _shortTokens,\n        uint256[] memory _strikePrices,\n        uint256 _expiryTime,\n        bool _isPut,\n        uint256 _tradingFee,\n        string memory _symbol\n    ) public payable initializer {\n        // this contract is also an ERC20 token, representing shares in the liquidity pool\n        __ERC20_init(_symbol, _symbol);\n        __ReentrancyGuard_init();\n        __Ownable_init();\n\n        // use same decimals as base token\n        uint8 decimals = IERC20(_baseToken).isETH() ? 18 : ERC20UpgradeSafe(_baseToken).decimals();\n        _setupDecimals(decimals);\n\n        require(_longTokens.length == _strikePrices.length, \"Lengths do not match\");\n        require(_shortTokens.length == _strikePrices.length, \"Lengths do not match\");\n\n        require(_strikePrices.length > 0, \"Strike prices must not be empty\");\n        require(_strikePrices[0] > 0, \"Strike prices must be > 0\");\n\n        // check strike prices are increasing\n        for (uint256 i = 0; i < _strikePrices.length - 1; i++) {\n            require(_strikePrices[i] < _strikePrices[i + 1], \"Strike prices must be increasing\");\n        }\n\n        // check trading fee is less than 100%\n        // note trading fee can be 0\n        require(_tradingFee < SCALE, \"Trading fee must be < 1\");\n\n        baseToken = IERC20(_baseToken);\n        oracle = IOracle(_oracle);\n        strikePrices = _strikePrices;\n        expiryTime = _expiryTime;\n        isPut = _isPut;\n        tradingFee = _tradingFee;\n\n        for (uint256 i = 0; i < _strikePrices.length; i++) {\n            longTokens.push(OptionToken(_longTokens[i]));\n            shortTokens.push(OptionToken(_shortTokens[i]));\n        }\n\n        require(!isExpired(), \"Already expired\");\n    }","after":"function initialize(\n        address _baseToken,\n        address _oracle,\n        address[] calldata _longTokens,\n        address[] calldata _shortTokens,\n        uint256[] calldata _strikePrices,\n        uint256 _expiryTime,\n        bool _isPut,\n        uint256 _tradingFee,\n        string calldata _symbol\n    ) public payable initializer {\n        // this contract is also an ERC20 token, representing shares in the liquidity pool\n        __ERC20_init(_symbol, _symbol);\n        __ReentrancyGuard_init();\n        __Ownable_init();\n\n        // use same decimals as base token\n        uint8 decimals = IERC20(_baseToken).isETH() ? 18 : ERC20UpgradeSafe(_baseToken).decimals();\n        _setupDecimals(decimals);\n\n        require(_longTokens.length == _strikePrices.length, \"Lengths do not match\");\n        require(_shortTokens.length == _strikePrices.length, \"Lengths do not match\");\n\n        require(_strikePrices.length > 0, \"Strike prices must not be empty\");\n        require(_strikePrices[0] > 0, \"Strike prices must be > 0\");\n\n        // check strike prices are increasing\n        for (uint256 i = 0; i < _strikePrices.length - 1; i++) {\n            require(_strikePrices[i] < _strikePrices[i + 1], \"Strike prices must be increasing\");\n        }\n\n        // check trading fee is less than 100%\n        // note trading fee can be 0\n        require(_tradingFee < SCALE, \"Trading fee must be < 1\");\n\n        baseToken = IERC20(_baseToken);\n        oracle = IOracle(_oracle);\n        strikePrices = _strikePrices;\n        expiryTime = _expiryTime;\n        isPut = _isPut;\n        tradingFee = _tradingFee;\n\n        for (uint256 i = 0; i < _strikePrices.length; i++) {\n            longTokens.push(OptionToken(_longTokens[i]));\n            shortTokens.push(OptionToken(_shortTokens[i]));\n        }\n\n        require(!isExpired(), \"Already expired\");\n    }","contract":"OptionMarket","time":0}]}