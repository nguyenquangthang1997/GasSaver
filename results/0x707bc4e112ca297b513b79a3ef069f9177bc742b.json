{"time":143,"results":[{"type":"external-function ","before":"function sendFundsToUser(address tokenAddress, uint256 amount, address payable receiver, bytes memory depositHash, uint256 tokenGasPrice) public nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {\n\n        uint256 initialGas = gasleft();\n\n        require(tokensInfo[tokenAddress].minCap <= amount && tokensInfo[tokenAddress].maxCap >= amount, \"Withdraw amount should be within allowed Cap limits\");\n\n        require(receiver != address(0), \"Bad receiver address\");\n\n\n        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);\n\n\n        require(!status, \"Already Processed\");\n\n        processedHash[hashSendTransaction] = true;\n\n\n        uint256 calculateAdminFee = amount.mul(adminFee).div(10000);\n\n        uint256 totalGasUsed = (initialGas.sub(gasleft())).add(tokensInfo[tokenAddress].transferOverhead).add(baseGas);\n\n\n        uint256 gasFeeInToken = totalGasUsed.mul(tokenGasPrice);\n\n        uint256 amountToTransfer = amount.sub(calculateAdminFee.add(gasFeeInToken));\n\n\n        if (tokenAddress == NATIVE) {\n\n            require(address(this).balance >= amountToTransfer, \"Not Enough Balance\");\n\n            (bool success,) = receiver.call{value : amount}(\"\");\n\n            require(success, \"Native Transfer Failed\");\n\n        } else {\n\n            require(IERC20(tokenAddress).balanceOf(address(this)) >= amountToTransfer, \"Not Enough Balance\");\n\n            SafeERC20.safeTransfer(IERC20(tokenAddress), receiver, amountToTransfer);\n\n        }\n\n\n        emit AssetSent(tokenAddress, amountToTransfer, receiver);\n\n    }","after":"function sendFundsToUser(address tokenAddress, uint256 amount, address payable receiver, bytes calldata depositHash, uint256 tokenGasPrice) public nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {\n\n        uint256 initialGas = gasleft();\n\n        require(tokensInfo[tokenAddress].minCap <= amount && tokensInfo[tokenAddress].maxCap >= amount, \"Withdraw amount should be within allowed Cap limits\");\n\n        require(receiver != address(0), \"Bad receiver address\");\n\n\n        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);\n\n\n        require(!status, \"Already Processed\");\n\n        processedHash[hashSendTransaction] = true;\n\n\n        uint256 calculateAdminFee = amount.mul(adminFee).div(10000);\n\n        uint256 totalGasUsed = (initialGas.sub(gasleft())).add(tokensInfo[tokenAddress].transferOverhead).add(baseGas);\n\n\n        uint256 gasFeeInToken = totalGasUsed.mul(tokenGasPrice);\n\n        uint256 amountToTransfer = amount.sub(calculateAdminFee.add(gasFeeInToken));\n\n\n        if (tokenAddress == NATIVE) {\n\n            require(address(this).balance >= amountToTransfer, \"Not Enough Balance\");\n\n            (bool success,) = receiver.call{value : amount}(\"\");\n\n            require(success, \"Native Transfer Failed\");\n\n        } else {\n\n            require(IERC20(tokenAddress).balanceOf(address(this)) >= amountToTransfer, \"Not Enough Balance\");\n\n            SafeERC20.safeTransfer(IERC20(tokenAddress), receiver, amountToTransfer);\n\n        }\n\n\n        emit AssetSent(tokenAddress, amountToTransfer, receiver);\n\n    }","contract":"LiquidityPoolManager","time":0}]}