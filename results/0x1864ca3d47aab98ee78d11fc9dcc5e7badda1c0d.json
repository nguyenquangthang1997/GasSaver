{"time":1329,"results":[{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC20","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC20","time":0},{"type":"immutable-restrict-modification ","before":"uint8 private _decimals;","after":"uint8 private immutable _decimals;","contract":"ERC20","time":0},{"type":"state-data-arrangement ","before":"\nstring public symbol;\nstring public name;\nuint8 public constant decimals = 18;\naddress public FRAXStablecoinAdd;\nuint256 public constant genesis_supply = 100000000e18;\nuint256 public FXS_DAO_min;\naddress public owner_address;\naddress public oracle_address;\naddress public timelock_address;\nFRAXStablecoin private FRAX;\nbool public trackingVotes = true;\nmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\nmapping(address => uint32) public numCheckpoints;","after":"string public symbol;\nstring public name;\nuint256 public constant genesis_supply = 100000000e18;\nuint256 public FXS_DAO_min;\nFRAXStablecoin private FRAX;\nmapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\nmapping(address => uint32) public numCheckpoints;\naddress public FRAXStablecoinAdd;\naddress public owner_address;\naddress public oracle_address;\naddress public timelock_address;\nuint8 public constant decimals = 18;\nbool public trackingVotes = true;\n","contract":"FRAXShares","time":1},{"type":"immutable-restrict-modification ","before":"string public symbol;","after":"string public immutable symbol;","contract":"FRAXShares","time":1},{"type":"immutable-restrict-modification ","before":"string public name;","after":"string public immutable name;","contract":"FRAXShares","time":1},{"type":"constant-restrict-modification  ","before":"address public FRAXStablecoinAdd;","after":"address public constant FRAXStablecoinAdd;","contract":"FRAXShares","time":1},{"type":"immutable-restrict-modification ","before":"string public symbol;","after":"string public immutable symbol;","contract":"FakeCollateral_USDC","time":0},{"type":"immutable-restrict-modification ","before":"uint8 public decimals;","after":"uint8 public immutable decimals;","contract":"FakeCollateral_USDC","time":0},{"type":"immutable-restrict-modification ","before":"address public creator_address;","after":"address public immutable creator_address;","contract":"FakeCollateral_USDC","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public genesis_supply;","after":"uint256 public immutable genesis_supply;","contract":"FakeCollateral_USDC","time":0},{"type":"immutable-restrict-modification ","before":"string public symbol;","after":"string public immutable symbol;","contract":"FakeCollateral_USDT","time":1},{"type":"immutable-restrict-modification ","before":"uint8 public decimals;","after":"uint8 public immutable decimals;","contract":"FakeCollateral_USDT","time":1},{"type":"immutable-restrict-modification ","before":"address public creator_address;","after":"address public immutable creator_address;","contract":"FakeCollateral_USDT","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public genesis_supply;","after":"uint256 public immutable genesis_supply;","contract":"FakeCollateral_USDT","time":1},{"type":"immutable-restrict-modification ","before":"string public symbol;","after":"string public immutable symbol;","contract":"FakeCollateral_WETH","time":0},{"type":"immutable-restrict-modification ","before":"uint8 public decimals;","after":"uint8 public immutable decimals;","contract":"FakeCollateral_WETH","time":0},{"type":"immutable-restrict-modification ","before":"address public creator_address;","after":"address public immutable creator_address;","contract":"FakeCollateral_WETH","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public genesis_supply;","after":"uint256 public immutable genesis_supply;","contract":"FakeCollateral_WETH","time":0},{"type":"state-data-arrangement ","before":"\nChainlinkETHUSDPriceConsumer private eth_usd_pricer;\nuint8 private eth_usd_pricer_decimals;\nUniswapPairOracle private fraxEthOracle;\nUniswapPairOracle private fxsEthOracle;\nstring public symbol;\nstring public name;\nuint8 public constant decimals = 18;\naddress public owner_address;\naddress public creator_address;\naddress public timelock_address;\naddress public controller_address;\naddress public fxs_address;\naddress public frax_eth_oracle_address;\naddress public fxs_eth_oracle_address;\naddress public weth_address;\naddress public eth_usd_consumer_address;\nuint256 public constant genesis_supply = 2000000e18;\naddress[] public frax_pools_array;\nmapping(address => bool) public frax_pools;\nuint256 private constant PRICE_PRECISION = 1e6;\nuint256 public global_collateral_ratio;\nuint256 public redemption_fee;\nuint256 public minting_fee;\nuint256 public frax_step;\nuint256 public refresh_cooldown;\nuint256 public price_target;\nuint256 public price_band;\naddress public DEFAULT_ADMIN_ADDRESS;\nbytes32 public constant COLLATERAL_RATIO_PAUSER = keccak256(\"COLLATERAL_RATIO_PAUSER\");\nbool public collateral_ratio_paused = false;\nuint256 public last_call_time;","after":"ChainlinkETHUSDPriceConsumer private eth_usd_pricer;\nUniswapPairOracle private fraxEthOracle;\nUniswapPairOracle private fxsEthOracle;\nstring public symbol;\nstring public name;\nuint256 public constant genesis_supply = 2000000e18;\naddress[] public frax_pools_array;\nmapping(address => bool) public frax_pools;\nuint256 private constant PRICE_PRECISION = 1e6;\nuint256 public global_collateral_ratio;\nuint256 public redemption_fee;\nuint256 public minting_fee;\nuint256 public frax_step;\nuint256 public refresh_cooldown;\nuint256 public price_target;\nuint256 public price_band;\nbytes32 public constant COLLATERAL_RATIO_PAUSER = keccak256(\"COLLATERAL_RATIO_PAUSER\");\nuint256 public last_call_time;\naddress public owner_address;\naddress public creator_address;\naddress public timelock_address;\naddress public controller_address;\naddress public fxs_address;\naddress public frax_eth_oracle_address;\naddress public fxs_eth_oracle_address;\naddress public weth_address;\naddress public eth_usd_consumer_address;\naddress public DEFAULT_ADMIN_ADDRESS;\nuint8 private eth_usd_pricer_decimals;\nuint8 public constant decimals = 18;\nbool public collateral_ratio_paused = false;\n","contract":"FRAXStablecoin","time":14},{"type":"immutable-restrict-modification ","before":"string public symbol;","after":"string public immutable symbol;","contract":"FRAXStablecoin","time":13},{"type":"immutable-restrict-modification ","before":"string public name;","after":"string public immutable name;","contract":"FRAXStablecoin","time":14},{"type":"immutable-restrict-modification ","before":"address public creator_address;","after":"address public immutable creator_address;","contract":"FRAXStablecoin","time":14},{"type":"immutable-restrict-modification ","before":"address public DEFAULT_ADMIN_ADDRESS;","after":"address public immutable DEFAULT_ADMIN_ADDRESS;","contract":"FRAXStablecoin","time":14},{"type":"state-data-arrangement ","before":"\nERC20 private collateral_token;\naddress private collateral_address;\naddress private owner_address;\naddress private frax_contract_address;\naddress private fxs_contract_address;\naddress private timelock_address;\nFRAXShares private FXS;\nFRAXStablecoin private FRAX;\nUniswapPairOracle private collatEthOracle;\naddress public collat_eth_oracle_address;\naddress private weth_address;\nuint256 public minting_fee;\nuint256 public redemption_fee;\nuint256 public buyback_fee;\nuint256 public recollat_fee;\nmapping(address => uint256) public redeemFXSBalances;\nmapping(address => uint256) public redeemCollateralBalances;\nuint256 public unclaimedPoolCollateral;\nuint256 public unclaimedPoolFXS;\nmapping(address => uint256) public lastRedeemed;\nuint256 private constant PRICE_PRECISION = 1e6;\nuint256 private constant COLLATERAL_RATIO_PRECISION = 1e6;\nuint256 private constant COLLATERAL_RATIO_MAX = 1e6;\nuint256 private immutable missing_decimals;\nuint256 public pool_ceiling = 0;\nuint256 public pausedPrice = 0;\nuint256 public bonus_rate = 7500;\nuint256 public redemption_delay = 1;\nbytes32 private constant MINT_PAUSER = keccak256(\"MINT_PAUSER\");\nbytes32 private constant REDEEM_PAUSER = keccak256(\"REDEEM_PAUSER\");\nbytes32 private constant BUYBACK_PAUSER = keccak256(\"BUYBACK_PAUSER\");\nbytes32 private constant RECOLLATERALIZE_PAUSER = keccak256(\"RECOLLATERALIZE_PAUSER\");\nbytes32 private constant COLLATERAL_PRICE_PAUSER = keccak256(\"COLLATERAL_PRICE_PAUSER\");\nbool public mintPaused = false;\nbool public redeemPaused = false;\nbool public recollateralizePaused = false;\nbool public buyBackPaused = false;\nbool public collateralPricePaused = false;","after":"ERC20 private collateral_token;\nFRAXShares private FXS;\nFRAXStablecoin private FRAX;\nUniswapPairOracle private collatEthOracle;\nuint256 public minting_fee;\nuint256 public redemption_fee;\nuint256 public buyback_fee;\nuint256 public recollat_fee;\nmapping(address => uint256) public redeemFXSBalances;\nmapping(address => uint256) public redeemCollateralBalances;\nuint256 public unclaimedPoolCollateral;\nuint256 public unclaimedPoolFXS;\nmapping(address => uint256) public lastRedeemed;\nuint256 private constant PRICE_PRECISION = 1e6;\nuint256 private constant COLLATERAL_RATIO_PRECISION = 1e6;\nuint256 private constant COLLATERAL_RATIO_MAX = 1e6;\nuint256 private immutable missing_decimals;\nuint256 public pool_ceiling = 0;\nuint256 public pausedPrice = 0;\nuint256 public bonus_rate = 7500;\nuint256 public redemption_delay = 1;\nbytes32 private constant MINT_PAUSER = keccak256(\"MINT_PAUSER\");\nbytes32 private constant REDEEM_PAUSER = keccak256(\"REDEEM_PAUSER\");\nbytes32 private constant BUYBACK_PAUSER = keccak256(\"BUYBACK_PAUSER\");\nbytes32 private constant RECOLLATERALIZE_PAUSER = keccak256(\"RECOLLATERALIZE_PAUSER\");\nbytes32 private constant COLLATERAL_PRICE_PAUSER = keccak256(\"COLLATERAL_PRICE_PAUSER\");\naddress private collateral_address;\naddress private owner_address;\naddress private frax_contract_address;\naddress private fxs_contract_address;\naddress private timelock_address;\naddress public collat_eth_oracle_address;\naddress private weth_address;\nbool public mintPaused = false;\nbool public redeemPaused = false;\nbool public recollateralizePaused = false;\nbool public buyBackPaused = false;\nbool public collateralPricePaused = false;\n","contract":"FraxPool","time":47},{"type":"struct-data-arrangement ","before":"\nuint id\naddress proposer\nuint eta\naddress[] targets\nuint[] values\nstring[] signatures\nbytes[] calldatas\nuint startBlock\nuint endBlock\nuint forVotes\nuint againstVotes\nbool canceled\nbool executed\nstring title\nstring description\nmapping(address => Receipt) receipts","after":"uint id\nuint eta\naddress[] targets\nuint[] values\nstring[] signatures\nbytes[] calldatas\nuint startBlock\nuint endBlock\nuint forVotes\nuint againstVotes\nstring title\nstring description\nmapping(address => Receipt) receipts\naddress proposer\nbool canceled\nbool executed\n","contract":"GovernorAlpha","time":0},{"type":"external-function ","before":"function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory title, string memory description) public returns (uint) {\n        require(fxs.getPriorVotes(msg.sender, sub256(block.number, 1)) >= proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        }\n\n        uint startBlock = add256(block.number, votingDelay());\n        uint endBlock = add256(startBlock, votingPeriod);\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n        id : proposalCount,\n        proposer : msg.sender,\n        eta : 0,\n        targets : targets,\n        values : values,\n        signatures : signatures,\n        calldatas : calldatas,\n        startBlock : startBlock,\n        endBlock : endBlock,\n        forVotes : 0,\n        againstVotes : 0,\n        canceled : false,\n        executed : false,\n        title : title,\n        description : description\n        });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;\n    }","after":"function propose(address[] calldata targets, uint[] calldata values, string[] calldata signatures, bytes[] calldata calldatas, string calldata title, string calldata description) public returns (uint) {\n        require(fxs.getPriorVotes(msg.sender, sub256(block.number, 1)) >= proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        }\n\n        uint startBlock = add256(block.number, votingDelay());\n        uint endBlock = add256(startBlock, votingPeriod);\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n        id : proposalCount,\n        proposer : msg.sender,\n        eta : 0,\n        targets : targets,\n        values : values,\n        signatures : signatures,\n        calldatas : calldatas,\n        startBlock : startBlock,\n        endBlock : endBlock,\n        forVotes : 0,\n        againstVotes : 0,\n        canceled : false,\n        executed : false,\n        title : title,\n        description : description\n        });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n        return newProposal.id;\n    }","contract":"GovernorAlpha","time":0},{"type":"immutable-restrict-modification ","before":"address public owner;","after":"address public immutable owner;","contract":"MigrationHelper","time":0},{"type":"immutable-restrict-modification ","before":"address public owner;","after":"address public immutable owner;","contract":"Migrations","time":0},{"type":"immutable-restrict-modification ","before":"address public USDC_address;","after":"address public immutable USDC_address;","contract":"Pool_USDC","time":1},{"type":"immutable-restrict-modification ","before":"address private collateral_address;","after":"address private immutable collateral_address;","contract":"Pool_USDC","time":1},{"type":"immutable-restrict-modification ","before":"address private frax_contract_address;","after":"address private immutable frax_contract_address;","contract":"Pool_USDC","time":1},{"type":"immutable-restrict-modification ","before":"address private fxs_contract_address;","after":"address private immutable fxs_contract_address;","contract":"Pool_USDC","time":1},{"type":"immutable-restrict-modification ","before":"address public USDT_address;","after":"address public immutable USDT_address;","contract":"Pool_USDT","time":1},{"type":"immutable-restrict-modification ","before":"address private collateral_address;","after":"address private immutable collateral_address;","contract":"Pool_USDT","time":1},{"type":"immutable-restrict-modification ","before":"address private frax_contract_address;","after":"address private immutable frax_contract_address;","contract":"Pool_USDT","time":1},{"type":"immutable-restrict-modification ","before":"address private fxs_contract_address;","after":"address private immutable fxs_contract_address;","contract":"Pool_USDT","time":1},{"type":"immutable-restrict-modification ","before":"uint256 private pool_weight;","after":"uint256 private immutable pool_weight;","contract":"Stake_FRAX_FXS","time":2},{"type":"immutable-restrict-modification ","before":"uint256 private pool_weight;","after":"uint256 private immutable pool_weight;","contract":"Stake_FRAX_USDC","time":1},{"type":"immutable-restrict-modification ","before":"uint256 private pool_weight;","after":"uint256 private immutable pool_weight;","contract":"Stake_FRAX_WETH","time":1},{"type":"immutable-restrict-modification ","before":"uint256 private pool_weight;","after":"uint256 private immutable pool_weight;","contract":"Stake_FXS_WETH","time":0},{"type":"state-data-arrangement ","before":"\nFRAXStablecoin private FRAX;\nERC20 public rewardsToken;\nERC20 public stakingToken;\nuint256 public periodFinish;\nuint256 private constant PRICE_PRECISION = 1e6;\nuint256 private constant MULTIPLIER_BASE = 1e6;\nuint256 public rewardRate;\nuint256 public rewardsDuration = 604800;\nuint256 public lastUpdateTime;\nuint256 public rewardPerTokenStored = 0;\nuint256 private pool_weight;\naddress public owner_address;\naddress public timelock_address;\nuint256 public locked_stake_max_multiplier = 3000000;\nuint256 public locked_stake_time_for_max_multiplier = 3 * 365 * 86400;\nuint256 public locked_stake_min_time = 604800;\nstring private locked_stake_min_time_str = \"604800\";\nuint256 public cr_boost_max_multiplier = 3000000;\nmapping(address => uint256) public userRewardPerTokenPaid;\nmapping(address => uint256) public rewards;\nuint256 private _staking_token_supply = 0;\nuint256 private _staking_token_boosted_supply = 0;\nmapping(address => uint256) private _unlocked_balances;\nmapping(address => uint256) private _locked_balances;\nmapping(address => uint256) private _boosted_balances;\nmapping(address => LockedStake[]) private lockedStakes;\nmapping(address => bool) public greylist;\nbool public unlockedStakes;","after":"FRAXStablecoin private FRAX;\nERC20 public rewardsToken;\nERC20 public stakingToken;\nuint256 public periodFinish;\nuint256 private constant PRICE_PRECISION = 1e6;\nuint256 private constant MULTIPLIER_BASE = 1e6;\nuint256 public rewardRate;\nuint256 public rewardsDuration = 604800;\nuint256 public lastUpdateTime;\nuint256 public rewardPerTokenStored = 0;\nuint256 private pool_weight;\nuint256 public locked_stake_max_multiplier = 3000000;\nuint256 public locked_stake_time_for_max_multiplier = 3 * 365 * 86400;\nuint256 public locked_stake_min_time = 604800;\nstring private locked_stake_min_time_str = \"604800\";\nuint256 public cr_boost_max_multiplier = 3000000;\nmapping(address => uint256) public userRewardPerTokenPaid;\nmapping(address => uint256) public rewards;\nuint256 private _staking_token_supply = 0;\nuint256 private _staking_token_boosted_supply = 0;\nmapping(address => uint256) private _unlocked_balances;\nmapping(address => uint256) private _locked_balances;\nmapping(address => uint256) private _boosted_balances;\nmapping(address => LockedStake[]) private lockedStakes;\nmapping(address => bool) public greylist;\naddress public owner_address;\naddress public timelock_address;\nbool public unlockedStakes;\n","contract":"StakingRewards","time":1},{"type":"immutable-restrict-modification ","before":"address public USDT_address;","after":"address public immutable USDT_address;","contract":"TestSwap","time":0},{"type":"immutable-restrict-modification ","before":"address public WETH_address;","after":"address public immutable WETH_address;","contract":"TestSwap","time":0},{"type":"external-function ","before":"function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }","after":"function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }","contract":"Timelock","time":0},{"type":"external-function ","before":"function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }","after":"function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }","contract":"Timelock","time":0},{"type":"external-function ","before":"function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // Execute the call\n        (bool success, bytes memory returnData) = target.call{value : value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }","after":"function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // Execute the call\n        (bool success, bytes memory returnData) = target.call{value : value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }","contract":"Timelock","time":0},{"type":"state-data-arrangement ","before":"\naddress private _beneficiary;\naddress private _owner;\nuint256 private _cliff;\nuint256 private _start;\nuint256 private _duration;\naddress public _FXS_contract_address;\nERC20 FXS;\naddress public _timelock_address;\nbool public _revocable;\nuint256 private _released;\nbool public _revoked;\nuint256[44] private __gap;","after":"uint256 private _cliff;\nuint256 private _start;\nuint256 private _duration;\nERC20 FXS;\nuint256 private _released;\nuint256[44] private __gap;\naddress private _beneficiary;\naddress private _owner;\naddress public _FXS_contract_address;\naddress public _timelock_address;\nbool public _revocable;\nbool public _revoked;\n","contract":"TokenVesting","time":1},{"type":"immutable-restrict-modification ","before":"address private _beneficiary;","after":"address private immutable _beneficiary;","contract":"TokenVesting","time":0},{"type":"immutable-restrict-modification ","before":"address private _owner;","after":"address private immutable _owner;","contract":"TokenVesting","time":0},{"type":"immutable-restrict-modification ","before":"uint256 private _cliff;","after":"uint256 private immutable _cliff;","contract":"TokenVesting","time":0},{"type":"immutable-restrict-modification ","before":"uint256 private _start;","after":"uint256 private immutable _start;","contract":"TokenVesting","time":0},{"type":"immutable-restrict-modification ","before":"uint256 private _duration;","after":"uint256 private immutable _duration;","contract":"TokenVesting","time":0},{"type":"immutable-restrict-modification ","before":"bool public _revocable;","after":"bool public immutable _revocable;","contract":"TokenVesting","time":0},{"type":"state-data-arrangement ","before":"\naddress owner_address;\naddress timelock_address;\nuint public PERIOD = 3600;\nuint public CONSULT_LENIENCY = 120;\nbool public ALLOW_STALE_CONSULTS = false;\nIUniswapV2Pair public immutable pair;\naddress public immutable token0;\naddress public immutable token1;\nuint    public price0CumulativeLast;\nuint    public price1CumulativeLast;\nuint32  public blockTimestampLast;\nFixedPoint.uq112x112 public price0Average;\nFixedPoint.uq112x112 public price1Average;","after":"uint public PERIOD = 3600;\nuint public CONSULT_LENIENCY = 120;\nIUniswapV2Pair public immutable pair;\nuint    public price0CumulativeLast;\nuint    public price1CumulativeLast;\nFixedPoint.uq112x112 public price0Average;\nFixedPoint.uq112x112 public price1Average;\naddress owner_address;\naddress timelock_address;\naddress public immutable token0;\naddress public immutable token1;\nuint32  public blockTimestampLast;\nbool public ALLOW_STALE_CONSULTS = false;\n","contract":"UniswapPairOracle","time":2},{"type":"state-data-arrangement ","before":"\naddress owner_address;\naddress timelock_address;\nuint public PERIOD = 3600;\nIUniswapV2Pair public immutable pair;\naddress public immutable token0;\naddress public immutable token1;\nuint    public price0CumulativeLast;\nuint    public price1CumulativeLast;\nuint32  public blockTimestampLast;\nFixedPoint.uq112x112 public price0Average;\nFixedPoint.uq112x112 public price1Average;","after":"uint public PERIOD = 3600;\nIUniswapV2Pair public immutable pair;\nuint    public price0CumulativeLast;\nuint    public price1CumulativeLast;\nFixedPoint.uq112x112 public price0Average;\nFixedPoint.uq112x112 public price1Average;\naddress owner_address;\naddress timelock_address;\naddress public immutable token0;\naddress public immutable token1;\nuint32  public blockTimestampLast;\n","contract":"UniswapPairOracle_OLD","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public override DOMAIN_SEPARATOR;","after":"bytes32 public override immutable DOMAIN_SEPARATOR;","contract":"UniswapV2ERC20","time":0},{"type":"state-data-arrangement ","before":"\nstring public override constant name = 'Uniswap V2';\nstring public override constant symbol = 'UNI-V2';\nuint8 public override constant decimals = 18;\nuint  public override totalSupply;\nmapping(address => uint) public override balanceOf;\nmapping(address => mapping(address => uint)) public override allowance;\nuint public override constant MINIMUM_LIQUIDITY = 10 ** 3;\nbytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\nbytes32 public override DOMAIN_SEPARATOR;\nbytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\nmapping(address => uint) public override nonces;\naddress public override factory;\naddress public override token0;\naddress public override token1;\nuint112 private reserve0;\nuint112 private reserve1;\nuint32  private blockTimestampLast;\nuint public override price0CumulativeLast;\nuint public override price1CumulativeLast;\nuint public override kLast;\nuint private unlocked = 1;","after":"string public override constant name = 'Uniswap V2';\nstring public override constant symbol = 'UNI-V2';\nuint  public override totalSupply;\nmapping(address => uint) public override balanceOf;\nmapping(address => mapping(address => uint)) public override allowance;\nuint public override constant MINIMUM_LIQUIDITY = 10 ** 3;\nbytes32 public override DOMAIN_SEPARATOR;\nbytes32 public constant override PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\nmapping(address => uint) public override nonces;\nuint public override price0CumulativeLast;\nuint public override price1CumulativeLast;\nuint public override kLast;\nuint private unlocked = 1;\naddress public override factory;\naddress public override token0;\naddress public override token1;\nuint112 private reserve0;\nuint112 private reserve1;\nbytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\nuint32  private blockTimestampLast;\nuint8 public override constant decimals = 18;\n","contract":"UniswapV2Pair","time":42},{"type":"constant-restrict-modification  ","before":"bytes32 public override DOMAIN_SEPARATOR;","after":"bytes32 public override constant DOMAIN_SEPARATOR;","contract":"UniswapV2Pair","time":0},{"type":"immutable-restrict-modification ","before":"address public override factory;","after":"address public override immutable factory;","contract":"UniswapV2Pair","time":0},{"type":"external-function ","before":"function getAmountsOut(uint amountIn, address[] memory path)\n    public\n    view\n    virtual\n    override\n    returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    }","after":"function getAmountsOut(uint amountIn, address[] calldata path)\n    public\n    view\n    virtual\n    override\n    returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    }","contract":"UniswapV2Router02","time":0},{"type":"external-function ","before":"function getAmountsIn(uint amountOut, address[] memory path)\n    public\n    view\n    virtual\n    override\n    returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    }","after":"function getAmountsIn(uint amountOut, address[] calldata path)\n    public\n    view\n    virtual\n    override\n    returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    }","contract":"UniswapV2Router02","time":0},{"type":"external-function ","before":"function getAmountsOut(uint amountIn, address[] memory path)\n    public\n    view\n    virtual\n    override\n    returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    }","after":"function getAmountsOut(uint amountIn, address[] calldata path)\n    public\n    view\n    virtual\n    override\n    returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    }","contract":"UniswapV2Router02_Modified","time":0},{"type":"external-function ","before":"function getAmountsIn(uint amountOut, address[] memory path)\n    public\n    view\n    virtual\n    override\n    returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    }","after":"function getAmountsIn(uint amountOut, address[] calldata path)\n    public\n    view\n    virtual\n    override\n    returns (uint[] memory amounts)\n    {\n        return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    }","contract":"UniswapV2Router02_Modified","time":0},{"type":"constant-restrict-modification  ","before":"string public name = \"Wrapped Ether\";","after":"string public constant name = \"Wrapped Ether\";","contract":"WETH","time":0},{"type":"constant-restrict-modification  ","before":"string public symbol = \"WETH\";","after":"string public constant symbol = \"WETH\";","contract":"WETH","time":0},{"type":"constant-restrict-modification  ","before":"uint8  public decimals = 18;","after":"uint8  public constant decimals = 18;","contract":"WETH","time":0}]}