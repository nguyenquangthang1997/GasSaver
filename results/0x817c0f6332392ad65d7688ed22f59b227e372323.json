{"time":1337,"results":[{"type":"external-function ","before":"function requestFunderAbort(bytes memory _abortOutputScript) public {// not external to allow bytes memory parameters\n        require(\n            self.depositOwner() == msg.sender,\n            \"Only TDT holder can request funder abort\"\n        );\n\n        self.requestFunderAbort(_abortOutputScript);\n    }","after":"function requestFunderAbort(bytes calldata _abortOutputScript) public {// not external to allow bytes memory parameters\n        require(\n            self.depositOwner() == msg.sender,\n            \"Only TDT holder can request funder abort\"\n        );\n\n        self.requestFunderAbort(_abortOutputScript);\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function provideFundingECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public {// not external to allow bytes memory parameters\n        self.provideFundingECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n    }","after":"function provideFundingECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public {// not external to allow bytes memory parameters\n        self.provideFundingECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function provideBTCFundingProof(\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n        self.provideBTCFundingProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n    }","after":"function provideBTCFundingProof(\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n        self.provideBTCFundingProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function provideECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public {// not external to allow bytes memory parameters\n        self.provideECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n    }","after":"function provideECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public {// not external to allow bytes memory parameters\n        self.provideECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function requestRedemption(\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript\n    ) public {// not external to allow bytes memory parameters\n        self.requestRedemption(_outputValueBytes, _redeemerOutputScript);\n    }","after":"function requestRedemption(\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript\n    ) public {// not external to allow bytes memory parameters\n        self.requestRedemption(_outputValueBytes, _redeemerOutputScript);\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function provideRedemptionProof(\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n        self.provideRedemptionProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n    }","after":"function provideRedemptionProof(\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n        self.provideRedemptionProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function transferAndRequestRedemption(\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public {// not external to allow bytes memory parameters\n        require(\n            msg.sender == self.vendingMachineAddress,\n            \"Only the vending machine can call transferAndRequestRedemption\"\n        );\n        self.transferAndRequestRedemption(\n            _outputValueBytes,\n            _redeemerOutputScript,\n            _finalRecipient\n        );\n    }","after":"function transferAndRequestRedemption(\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public {// not external to allow bytes memory parameters\n        require(\n            msg.sender == self.vendingMachineAddress,\n            \"Only the vending machine can call transferAndRequestRedemption\"\n        );\n        self.transferAndRequestRedemption(\n            _outputValueBytes,\n            _redeemerOutputScript,\n            _finalRecipient\n        );\n    }","contract":"Deposit","time":0},{"type":"immutable-restrict-modification ","before":" bond, _maxSecuredLifetime);\n    }\n","after":" bond, _maxSecuredLifetime);\n    }\n","contract":"DepositFactory","time":0},{"type":"external-function ","before":"function requestFunderAbort(\n        DepositUtils.Deposit storage _d,\n        bytes memory _abortOutputScript\n    ) public {// not external to allow bytes memory parameters\n        require(\n            _d.inFailedSetup(),\n            \"The deposit has not failed funding\"\n        );\n\n        _d.logFunderRequestedAbort(_abortOutputScript);\n    }","after":"function requestFunderAbort(\n        DepositUtils.Deposit storage _d,\n        bytes calldata _abortOutputScript\n    ) public {// not external to allow bytes memory parameters\n        require(\n            _d.inFailedSetup(),\n            \"The deposit has not failed funding\"\n        );\n\n        _d.logFunderRequestedAbort(_abortOutputScript);\n    }","contract":"DepositFunding","time":0},{"type":"external-function ","before":"function provideFundingECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public {// not external to allow bytes memory parameters\n        require(\n            _d.inAwaitingBTCFundingProof(),\n            \"Signer fraud during funding flow only available while awaiting funding\"\n        );\n\n        _d.submitSignatureFraud(_v, _r, _s, _signedDigest, _preimage);\n        _d.logFraudDuringSetup();\n\n        // Allow deposit owner to withdraw seized bonds after contract termination.\n        uint256 _seized = _d.seizeSignerBonds();\n        _d.enableWithdrawal(_d.depositOwner(), _seized);\n\n        fundingFraudTeardown(_d);\n        _d.setFailedSetup();\n        _d.logSetupFailed();\n    }","after":"function provideFundingECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public {// not external to allow bytes memory parameters\n        require(\n            _d.inAwaitingBTCFundingProof(),\n            \"Signer fraud during funding flow only available while awaiting funding\"\n        );\n\n        _d.submitSignatureFraud(_v, _r, _s, _signedDigest, _preimage);\n        _d.logFraudDuringSetup();\n\n        // Allow deposit owner to withdraw seized bonds after contract termination.\n        uint256 _seized = _d.seizeSignerBonds();\n        _d.enableWithdrawal(_d.depositOwner(), _seized);\n\n        fundingFraudTeardown(_d);\n        _d.setFailedSetup();\n        _d.logSetupFailed();\n    }","contract":"DepositFunding","time":0},{"type":"external-function ","before":"function provideBTCFundingProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n\n        require(_d.inAwaitingBTCFundingProof(), \"Not awaiting funding\");\n\n        bytes8 _valueBytes;\n        bytes memory _utxoOutpoint;\n\n        (_valueBytes, _utxoOutpoint) = _d.validateAndParseFundingSPVProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n\n        // Write down the UTXO info and set to active. Congratulations :)\n        _d.utxoValueBytes = _valueBytes;\n        _d.utxoOutpoint = _utxoOutpoint;\n        _d.fundedAt = block.timestamp;\n\n        bytes32 _txid = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n\n        fundingTeardown(_d);\n        _d.setActive();\n        _d.logFunded(_txid);\n    }","after":"function provideBTCFundingProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n\n        require(_d.inAwaitingBTCFundingProof(), \"Not awaiting funding\");\n\n        bytes8 _valueBytes;\n        bytes memory _utxoOutpoint;\n\n        (_valueBytes, _utxoOutpoint) = _d.validateAndParseFundingSPVProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n\n        // Write down the UTXO info and set to active. Congratulations :)\n        _d.utxoValueBytes = _valueBytes;\n        _d.utxoOutpoint = _utxoOutpoint;\n        _d.fundedAt = block.timestamp;\n\n        bytes32 _txid = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n\n        fundingTeardown(_d);\n        _d.setActive();\n        _d.logFunded(_txid);\n    }","contract":"DepositFunding","time":0},{"type":"external-function ","before":"function provideECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public {// not external to allow bytes memory parameters\n        require(\n            !_d.inFunding(),\n            \"Use provideFundingECDSAFraudProof instead\"\n        );\n        require(\n            !_d.inSignerLiquidation(),\n            \"Signer liquidation already in progress\"\n        );\n        require(!_d.inEndState(), \"Contract has halted\");\n        submitSignatureFraud(_d, _v, _r, _s, _signedDigest, _preimage);\n\n        startLiquidation(_d, true);\n    }","after":"function provideECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public {// not external to allow bytes memory parameters\n        require(\n            !_d.inFunding(),\n            \"Use provideFundingECDSAFraudProof instead\"\n        );\n        require(\n            !_d.inSignerLiquidation(),\n            \"Signer liquidation already in progress\"\n        );\n        require(!_d.inEndState(), \"Contract has halted\");\n        submitSignatureFraud(_d, _v, _r, _s, _signedDigest, _preimage);\n\n        startLiquidation(_d, true);\n    }","contract":"DepositLiquidation","time":0},{"type":"external-function ","before":"function transferAndRequestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public {// not external to allow bytes memory parameters\n        _d.tbtcDepositToken.transferFrom(msg.sender, _finalRecipient, uint256(address(this)));\n\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, _finalRecipient);\n    }","after":"function transferAndRequestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public {// not external to allow bytes memory parameters\n        _d.tbtcDepositToken.transferFrom(msg.sender, _finalRecipient, uint256(address(this)));\n\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, _finalRecipient);\n    }","contract":"DepositRedemption","time":0},{"type":"external-function ","before":"function requestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript\n    ) public {// not external to allow bytes memory parameters\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, msg.sender);\n    }","after":"function requestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript\n    ) public {// not external to allow bytes memory parameters\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, msg.sender);\n    }","contract":"DepositRedemption","time":0},{"type":"external-function ","before":"function provideRedemptionProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n        bytes32 _txid;\n        uint256 _fundingOutputValue;\n\n        require(_d.inRedemption(), \"Redemption proof only allowed from redemption flow\");\n\n        _fundingOutputValue = redemptionTransactionChecks(_d, _txInputVector, _txOutputVector);\n\n        _txid = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n        _d.checkProofFromTxId(_txid, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        require((_d.utxoValue().sub(_fundingOutputValue)) <= _d.latestRedemptionFee, \"Incorrect fee amount\");\n\n        // Transfer TBTC to signers and close the keep.\n        distributeSignerFee(_d);\n        _d.closeKeep();\n\n        _d.distributeFeeRebate();\n\n        // We're done yey!\n        _d.setRedeemed();\n        _d.redemptionTeardown();\n        _d.logRedeemed(_txid);\n    }","after":"function provideRedemptionProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public {// not external to allow bytes memory parameters\n        bytes32 _txid;\n        uint256 _fundingOutputValue;\n\n        require(_d.inRedemption(), \"Redemption proof only allowed from redemption flow\");\n\n        _fundingOutputValue = redemptionTransactionChecks(_d, _txInputVector, _txOutputVector);\n\n        _txid = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n        _d.checkProofFromTxId(_txid, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        require((_d.utxoValue().sub(_fundingOutputValue)) <= _d.latestRedemptionFee, \"Incorrect fee amount\");\n\n        // Transfer TBTC to signers and close the keep.\n        distributeSignerFee(_d);\n        _d.closeKeep();\n\n        _d.distributeFeeRebate();\n\n        // We're done yey!\n        _d.setRedeemed();\n        _d.redemptionTeardown();\n        _d.logRedeemed(_txid);\n    }","contract":"DepositRedemption","time":0},{"type":"struct-data-arrangement ","before":"\nITBTCSystem tbtcSystem\nTBTCToken tbtcToken\nIERC721 tbtcDepositToken\nFeeRebateToken feeRebateToken\naddress vendingMachineAddress\nuint64 lotSizeSatoshis\nuint8 currentState\nuint16 signerFeeDivisor\nuint16 initialCollateralizedPercent\nuint16 undercollateralizedThresholdPercent\nuint16 severelyUndercollateralizedThresholdPercent\nuint256 keepSetupFee\nuint256 liquidationInitiated\nuint256 courtesyCallInitiated\naddress payable liquidationInitiator\naddress keepAddress\nuint256 signingGroupRequestedAt\nuint256 fundingProofTimerStart\nbytes32 signingGroupPubkeyX\nbytes32 signingGroupPubkeyY\naddress payable redeemerAddress\nbytes redeemerOutputScript\nuint256 initialRedemptionFee\nuint256 latestRedemptionFee\nuint256 withdrawalRequestTime\nbytes32 lastRequestedDigest\nbytes8 utxoValueBytes\nuint256 fundedAt\nbytes utxoOutpoint\nmapping(address => uint256) withdrawableAmounts\nmapping(bytes32 => uint256) approvedDigests","after":"ITBTCSystem tbtcSystem\nTBTCToken tbtcToken\nIERC721 tbtcDepositToken\nFeeRebateToken feeRebateToken\nuint256 keepSetupFee\nuint256 liquidationInitiated\nuint256 courtesyCallInitiated\nuint256 signingGroupRequestedAt\nuint256 fundingProofTimerStart\nbytes32 signingGroupPubkeyX\nbytes32 signingGroupPubkeyY\nbytes redeemerOutputScript\nuint256 initialRedemptionFee\nuint256 latestRedemptionFee\nuint256 withdrawalRequestTime\nbytes32 lastRequestedDigest\nuint256 fundedAt\nbytes utxoOutpoint\nmapping(address => uint256) withdrawableAmounts\nmapping(bytes32 => uint256) approvedDigests\naddress vendingMachineAddress\naddress payable liquidationInitiator\naddress keepAddress\naddress payable redeemerAddress\nuint64 lotSizeSatoshis\nbytes8 utxoValueBytes\nuint16 signerFeeDivisor\nuint16 initialCollateralizedPercent\nuint16 undercollateralizedThresholdPercent\nuint16 severelyUndercollateralizedThresholdPercent\nuint8 currentState\n","contract":"DepositUtils","time":326},{"type":"external-function ","before":"function validateAndParseFundingSPVProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public view returns (bytes8 _valueBytes, bytes memory _utxoOutpoint){// not external to allow bytes memory parameters\n        require(_txInputVector.validateVin(), \"invalid input vector provided\");\n        require(_txOutputVector.validateVout(), \"invalid output vector provided\");\n\n        bytes32 txID = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n\n        _valueBytes = findAndParseFundingOutput(_d, _txOutputVector, _fundingOutputIndex);\n\n        require(bytes8LEToUint(_valueBytes) >= _d.lotSizeSatoshis, \"Deposit too small\");\n\n        checkProofFromTxId(_d, txID, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        // The utxoOutpoint is the LE txID plus the index of the output as a 4-byte LE int\n        // _fundingOutputIndex is a uint8, so we know it is only 1 byte\n        // Therefore, pad with 3 more bytes\n        _utxoOutpoint = abi.encodePacked(txID, _fundingOutputIndex, hex\"000000\");\n    }","after":"function validateAndParseFundingSPVProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public view returns (bytes8 _valueBytes, bytes memory _utxoOutpoint){// not external to allow bytes memory parameters\n        require(_txInputVector.validateVin(), \"invalid input vector provided\");\n        require(_txOutputVector.validateVout(), \"invalid output vector provided\");\n\n        bytes32 txID = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n\n        _valueBytes = findAndParseFundingOutput(_d, _txOutputVector, _fundingOutputIndex);\n\n        require(bytes8LEToUint(_valueBytes) >= _d.lotSizeSatoshis, \"Deposit too small\");\n\n        checkProofFromTxId(_d, txID, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        // The utxoOutpoint is the LE txID plus the index of the output as a 4-byte LE int\n        // _fundingOutputIndex is a uint8, so we know it is only 1 byte\n        // Therefore, pad with 3 more bytes\n        _utxoOutpoint = abi.encodePacked(txID, _fundingOutputIndex, hex\"000000\");\n    }","contract":"DepositUtils","time":0},{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping(uint256 => address) private _tokenOwner;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => Counters.Counter) private _ownedTokensCount;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;","after":"mapping(uint256 => address) private _tokenOwner;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => Counters.Counter) private _ownedTokensCount;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n","contract":"ERC721","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"FeeRebateToken","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"FeeRebateToken","time":1},{"type":"immutable-restrict-modification ","before":"ternal to allow bytes memory par","after":"ternal to allow bytes memory par","contract":"FeeRebateToken","time":1},{"type":"external-function ","before":"function receiveApproval(\n        address _from,\n        uint256 _tokenId,\n        address,\n        bytes memory _extraData\n    ) public {// not external to allow bytes memory parameters\n        require(msg.sender == address(tbtcDepositToken), \"Only token contract can call receiveApproval\");\n\n        tbtcDepositToken.transferFrom(_from, address(this), _tokenId);\n        tbtcDepositToken.approve(address(vendingMachine), _tokenId);\n\n        // Verify _extraData is a call to unqualifiedDepositToTbtc.\n        bytes4 functionSignature;\n        assembly {\n            functionSignature := and(mload(add(_extraData, 0x20)), not(0xff))\n        }\n        require(\n            functionSignature == vendingMachine.unqualifiedDepositToTbtc.selector,\n            \"Bad _extraData signature. Call must be to unqualifiedDepositToTbtc.\"\n        );\n\n        // Call the VendingMachine.\n        // We could explictly encode the call to vending machine, but this would\n        // involve manually parsing _extraData and allocating variables.\n        // We capture the `returnData` in order to forward any nested revert message\n        // from the contract call.\n        /* solium-disable-next-line security/no-low-level-calls */\n        (bool success, bytes memory returnData) = address(vendingMachine).call(_extraData);\n\n        string memory revertMessage;\n        assembly {\n        // A revert message is ABI-encoded as a call to Error(string).\n        // Slicing the Error() signature (4 bytes) and Data offset (4 bytes)\n        // leaves us with a pre-encoded string.\n        // We also slice off the ABI-coded length of returnData (32).\n            revertMessage := add(returnData, 0x44)\n        }\n\n        require(success, revertMessage);\n\n        // Transfer the TBTC and feeRebateToken to the user.\n        tbtcToken.transfer(_from, tbtcToken.balanceOf(address(this)));\n        feeRebateToken.transferFrom(address(this), _from, uint256(_tokenId));\n    }","after":"function receiveApproval(\n        address _from,\n        uint256 _tokenId,\n        address,\n        bytes calldata _extraData\n    ) public {// not external to allow bytes memory parameters\n        require(msg.sender == address(tbtcDepositToken), \"Only token contract can call receiveApproval\");\n\n        tbtcDepositToken.transferFrom(_from, address(this), _tokenId);\n        tbtcDepositToken.approve(address(vendingMachine), _tokenId);\n\n        // Verify _extraData is a call to unqualifiedDepositToTbtc.\n        bytes4 functionSignature;\n        assembly {\n            functionSignature := and(mload(add(_extraData, 0x20)), not(0xff))\n        }\n        require(\n            functionSignature == vendingMachine.unqualifiedDepositToTbtc.selector,\n            \"Bad _extraData signature. Call must be to unqualifiedDepositToTbtc.\"\n        );\n\n        // Call the VendingMachine.\n        // We could explictly encode the call to vending machine, but this would\n        // involve manually parsing _extraData and allocating variables.\n        // We capture the `returnData` in order to forward any nested revert message\n        // from the contract call.\n        /* solium-disable-next-line security/no-low-level-calls */\n        (bool success, bytes memory returnData) = address(vendingMachine).call(_extraData);\n\n        string memory revertMessage;\n        assembly {\n        // A revert message is ABI-encoded as a call to Error(string).\n        // Slicing the Error() signature (4 bytes) and Data offset (4 bytes)\n        // leaves us with a pre-encoded string.\n        // We also slice off the ABI-coded length of returnData (32).\n            revertMessage := add(returnData, 0x44)\n        }\n\n        require(success, revertMessage);\n\n        // Transfer the TBTC and feeRebateToken to the user.\n        tbtcToken.transfer(_from, tbtcToken.balanceOf(address(this)));\n        feeRebateToken.transferFrom(address(this), _from, uint256(_tokenId));\n    }","contract":"FundingScript","time":0},{"type":"external-function ","before":"dress of the regular, KEEP-stake based keep\n    /// factory.\n    /// @param _fullyBackedFactory Address of the fully-backed, ETH-bond-only based\n    /// keep factory.\n    /// @param _factorySelector Address of the keep factory selection strategy.\n    function setFactories(\n        Storage storage _self,\n        address _keepStakedFactory,\n        address _fullyBackedFactory,\n        address _factorySelector\n    ) internal {\n        require(\n            address(_keepStakedFactory) != address(0),\n            \"Invalid KEEP-staked factory address\"\n        );\n\n        _self.keepStakedFactory = ","after":"dress of the regular, KEEP-stake based keep\n    /// factory.\n    /// @param _fullyBackedFactory Address of the fully-backed, ETH-bond-only based\n    /// keep factory.\n    /// @param _factorySelector Address of the keep factory selection strategy.\n    function setFactories(\n        Storage storage _self,\n        address _keepStakedFactory,\n        address _fullyBackedFactory,\n        address _factorySelector\n    ) internal {\n        require(\n            address(_keepStakedFactory) != address(0),\n            \"Invalid KEEP-staked factory address\"\n        );\n\n        _self.keepStakedFactory = ","contract":"OutsourceDepositLogging","time":1},{"type":"external-function ","before":"txoValue,\n        bytes memory _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes memory _outpoint\n    ) public {// not external to allow bytes memory parameters\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logRedemptionRequested(\n            _redeemer,\n  ","after":"txoValue,\n        bytes calldata _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes memory _outpoint\n    ) public {// not external to allow bytes memory parameters\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _logger.logRedemptionRequested(\n            _redeemer,\n  ","contract":"OutsourceDepositLogging","time":0},{"type":"external-function ","before":"ontract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\npragma solidity 0.5.17;\n\nimport {ITokenRecipient} from \"../interfaces/ITokenRecipient.sol\";\nimport {TBTCDepositToken} from \"../system/TBTCDepositToken.sol\";\nimport {TBTCToken} from \"../system/TBTCToken.sol\";\nimport {FeeRebateToken} from \"../system/FeeRebateToken.sol\";\nimport {VendingMachine} from \"../system/VendingMachine.sol\";\nimport {Deposit} from \"../deposit/Deposit.sol\";\nimport {BytesLib} from \"@summa-tx/bitcoin-spv-sol/contracts/BytesLib.sol\";\n\n/// @notice A one-click script for redeeming TBTC into BTC.\n/// @dev Wrapper script for VendingMachine.tbtcToBtc\n/// This contract implements receiveApproval() and can therefore use\n/// approveAndCall(). This pattern combines TBTC Token approval and\n/// vendingMachine.tbtcToBtc() in a single transaction.\ncontract RedemptionScript is ITokenRecipient {\n    using BytesLib for bytes;\n\n    TBTCToken tbtcToken;\n    VendingMachine vendingMachine;\n    FeeRebateToken feeRebateToken;\n\n    con","after":"ontract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\npragma solidity 0.5.17;\n\nimport {ITokenRecipient} from \"../interfaces/ITokenRecipient.sol\";\nimport {TBTCDepositToken} from \"../system/TBTCDepositToken.sol\";\nimport {TBTCToken} from \"../system/TBTCToken.sol\";\nimport {FeeRebateToken} from \"../system/FeeRebateToken.sol\";\nimport {VendingMachine} from \"../system/VendingMachine.sol\";\nimport {Deposit} from \"../deposit/Deposit.sol\";\nimport {BytesLib} from \"@summa-tx/bitcoin-spv-sol/contracts/BytesLib.sol\";\n\n/// @notice A one-click script for redeeming TBTC into BTC.\n/// @dev Wrapper script for VendingMachine.tbtcToBtc\n/// This contract implements receiveApproval() and can therefore use\n/// approveAndCall(). This pattern combines TBTC Token approval and\n/// vendingMachine.tbtcToBtc() in a single transaction.\ncontract RedemptionScript is ITokenRecipient {\n    using BytesLib for bytes;\n\n    TBTCToken tbtcToken;\n    VendingMachine vendingMachine;\n    FeeRebateToken feeRebateToken;\n\n    con","contract":"RedemptionScript","time":0},{"type":"immutable-restrict-modification ","before":"dress,\n        bytes memory _e","after":"dress,\n        bytes memory _e","contract":"TestRelay","time":1},{"type":"external-function ","before":"eely. tBTC's VendingMachine\n///         contract takes ownership of TDTs and in exchange returns fungible\n///         TBTC tokens whose value is backed 1-to-1 by the corresponding\n///         deposit's BTC.\n/// @dev Currently, TDTs are minted using the uint256 casting of the\n///      corresponding deposit contract's address. That is, the TDT'","after":"eely. tBTC's VendingMachine\n///         contract takes ownership of TDTs and in exchange returns fungible\n///         TBTC tokens whose value is backed 1-to-1 by the corresponding\n///         deposit's BTC.\n/// @dev Currently, TDTs are minted using the uint256 casting of the\n///      corresponding deposit contract's address. That is, the TDT'","contract":"TBTCDepositToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"TBTCDepositToken","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"TBTCDepositToken","time":1},{"type":"state-data-arrangement ","before":"\nsumma-tx/relay-sol/contracts/Rela\n\";\nimport \"../external/I\nnizer.sol\";\n\nimport {ITBTCSystem} from \"..\nfaces/ITBTCSystem.sol\";\nimport {IS\nPriceFeed} from \"../\naces/ISatWeiPriceFeed.sol\";\nimport {DepositLog} fr\n/DepositLog.sol\";\n\nimpo\nBTCDepositToken} from \"./TBT\neeRebateToken.sol\";\nimport \"openzeppel\nlidity/contracts/ownership/Ownable.sol\"\nmath/SafeMath.sol\";\nimport \"./KeepFactorySelection\nle TBTC System.\n/// @notice This contract acts as a centr\nss control,\n///         value governance, and price feed.\n/// @de\nvalues should only affect new deposit creation.\ncontract TBTCSystem is Ownable, IT\nath for uint256;\n    using KeepFactorySelection \neepFactorySelection.Storage;\n\n    event EthBtcPriceFeedAdditio\ned(address _priceFeed, uint256 _timestamp);\n    \n LotSizesUpdateStarted(uint64[] _lotSize\nnt256 _timestamp);\n    event SignerFeeDivisorUpdateStarted(\n6 _signerFeeDivisor, uint256 _timestamp);\n   \n CollateralizationThresholdsUpdateS\nd(\n        uint16 _initialCol\nalizedPercent,\n        uint16 _undercollaterali\nresholdPercent,\n        uint16 _severelyUndercollatera\nThresholdPercent,\n        uint256 _timestamp\n    );\n    event \nactoriesUpdateStarted(\n        addres\nepStakedFactory,\n        address _full\nedFactory,\n        address _factory\n6 _timestamp\n    );\n\n    event EthBtcPriceFeedAdded(addr\npriceFeed);\n    event LotSizesUpdated(uin\n _lotSizes);\n    event AllowNewD","after":"summa-tx/relay-sol/contracts/Rela\n\";\nimport \"../external/I\nnizer.sol\";\n\nimport {ITBTCSystem} from \"..\nfaces/ITBTCSystem.sol\";\nimport {IS\nPriceFeed} from \"../\naces/ISatWeiPriceFeed.sol\";\nimport {DepositLog} fr\nvalues should only affect new deposit creation.\ncontract TBTCSystem is Ownable, IT\nath for uint256;\n    using KeepFactorySelection \neepFactorySelection.Storage;\n\n    event EthBtcPriceFeedAdditio\ned(address _priceFeed, uint256 _timestamp);\n    \n LotSizesUpdateStarted(uint64[] _lotSize\nnt256 _timestamp);\n    event SignerFeeDivisorUpdateStarted(\n6 _signerFeeDivisor, uint256 _timestamp);\n   \nd(\n        uint16 _initialCol\n6 _timestamp\n    );\n\n    event EthBtcPriceFeedAdded(addr\npriceFeed);\n    event LotSizesUpdated(uin\n _lotSizes);\n    event AllowNewD\nactoriesUpdateStarted(\n        addres\nepStakedFactory,\n        address _full\nedFactory,\n        address _factory\n/DepositLog.sol\";\n\nimpo\nBTCDepositToken} from \"./TBT\nlidity/contracts/ownership/Ownable.sol\"\nmath/SafeMath.sol\";\nimport \"./KeepFactorySelection\nle TBTC System.\n/// @notice This contract acts as a centr\nss control,\n///         value governance, and price feed.\n/// @de\n CollateralizationThresholdsUpdateS\nalizedPercent,\n        uint16 _undercollaterali\nresholdPercent,\n        uint16 _severelyUndercollatera\nThresholdPercent,\n        uint256 _timestamp\n    );\n    event \neeRebateToken.sol\";\nimport \"openzeppel\n","contract":"TBTCSystem","time":119},{"type":"external-function ","before":"function logRedemptionRequested(\n        address _requester,\n        bytes32 _digest,\n        uint256 _utxoValue,\n        bytes memory _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes memory _outpoint\n    ) public {\n        // not external to allow bytes memory parameters\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit RedemptionRequested(\n            msg.sender,\n            _requester,\n            _digest,\n            _utxoValue,\n            _redeemerOutputScript,\n            _requestedFee,\n            _outpoint\n        );\n    }","after":"function logRedemptionRequested(\n        address _requester,\n        bytes32 _digest,\n        uint256 _utxoValue,\n        bytes calldata _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes calldata _outpoint\n    ) public {\n        // not external to allow bytes memory parameters\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit RedemptionRequested(\n            msg.sender,\n            _requester,\n            _digest,\n            _utxoValue,\n            _redeemerOutputScript,\n            _requestedFee,\n            _outpoint\n        );\n    }","contract":"TBTCSystem","time":0},{"type":"external-function ","before":"function logFunderRequestedAbort(bytes memory _abortOutputScript) public {\n        // not external to allow bytes memory parameters\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit FunderAbortRequested(msg.sender, _abortOutputScript);\n    }","after":"function logFunderRequestedAbort(bytes calldata _abortOutputScript) public {\n        // not external to allow bytes memory parameters\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit FunderAbortRequested(msg.sender, _abortOutputScript);\n    }","contract":"TBTCSystem","time":0},{"type":"external-function ","before":"able-previous-line no-empty-blocks\n    }\n\n    /// @dev             Mints an amount of the token and assigns it to an account.\n    ///                  Uses the internal _mint function.\n    /// @param _account  The account that will receive the created tokens.\n    /// @param _amount   The amount of tokens that will be created.\n    function mint(address _account, uint256 _amount) external ","after":"able-previous-line no-empty-blocks\n    }\n\n    /// @dev             Mints an amount of the token and assigns it to an account.\n    ///                  Uses the internal _mint function.\n    /// @param _account  The account that will receive the created tokens.\n    /// @param _amount   The amount of tokens that will be created.\n    function mint(address _account, uint256 _amount) external ","contract":"TBTCToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"TBTCToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"TBTCToken","time":0},{"type":"immutable-restrict-modification ","before":"uint8 private _decimals;","after":"uint8 private immutable _decimals;","contract":"TBTCToken","time":0},{"type":"immutable-restrict-modification ","before":"ternal to allow bytes memory par","after":"ternal to allow bytes memory par","contract":"TBTCToken","time":0},{"type":"external-function ","before":"the max supply, false otherwise.\n    function canMint(uint256 amount) public view returns (bool) {\n        return getMintedSupply().add(amount) < getMaxSupply();\n    }\n\n    /// @notice Determines whether a deposit is qualified for minting TBTC.\n    /// @param _depositAddress The address of the deposit\n    function isQualified(address payable _depositAddress) public view returns (bool) {\n        return Deposit(_depositAddress).inActive();\n    }\n\n    /// @notice Return the minted TBTC supply in weitoshis (BTC * 10 ** 18).\n    function getMintedSupply() public view returns (uint256) {\n        return tbtcToken.totalSupply();\n    }\n\n    /// @notice Get the maximum TBTC token supply based on the age of the\n    ///         contract deployment. The supply cap starts at 2 B","after":"the max supply, false otherwise.\n    function canMint(uint256 amount) public view returns (bool) {\n        return getMintedSupply().add(amount) < getMaxSupply();\n    }\n\n    /// @notice Determines whether a deposit is qualified for minting TBTC.\n    /// @param _depositAddress The address of the deposit\n    function isQualified(address payable _depositAddress) public view returns (bool) {\n        return Deposit(_depositAddress).inActive();\n    }\n\n    /// @notice Return the minted TBTC supply in weitoshis (BTC * 10 ** 18).\n    function getMintedSupply() public view returns (uint256) {\n        return tbtcToken.totalSupply();\n    }\n\n    /// @notice Get the maximum TBTC token supply based on the age of the\n    ///         contract deployment. The supply cap starts at 2 B","contract":"VendingMachine","time":0},{"type":"external-function ","before":"18;\n        }\n\n        if (age < 14 days) {\n            return 250 * 10 ** 18;\n        }\n\n        if (age < 21 days) {\n            return 500 * 10 ** 18;\n        }\n\n        if (age < 28 days) {\n            return 750 * 10 ** 18;\n        }\n\n        if (age < 35 days) {\n            return 1000 * 10 ** 18;\n        }\n\n        if (age < 42 days) {\n            return 1500 * 10 ** 18;\n        }\n\n        if (age < 49 days) {\n            return 2000 * 10 ** 18;\n        }\n\n        if (age < 56 days) {\n            return 2500 * 10 ** 18;\n        }\n\n        if (age < 63 days) {\n            return 3000 * 10 ** 18;\n        }\n\n        return 21e6 * 10 ** 18;\n    }\n\n    // WRAPPERS\n\n    /// @notice Qualifies a deposit and mints TBTC.\n    /// @dev User must allow VendingManchine to transfer TDT.\n    function unqualifiedDepositToTbtc(\n        ad","after":"18;\n        }\n\n        if (age < 14 days) {\n            return 250 * 10 ** 18;\n        }\n\n        if (age < 21 days) {\n            return 500 * 10 ** 18;\n        }\n\n        if (age < 28 days) {\n            return 750 * 10 ** 18;\n        }\n\n        if (age < 35 days) {\n            return 1000 * 10 ** 18;\n        }\n\n        if (age < 42 days) {\n            return 1500 * 10 ** 18;\n        }\n\n        if (age < 49 days) {\n            return 2000 * 10 ** 18;\n        }\n\n        if (age < 56 days) {\n            return 2500 * 10 ** 18;\n        }\n\n        if (age < 63 days) {\n            return 3000 * 10 ** 18;\n        }\n\n        return 21e6 * 10 ** 18;\n    }\n\n    // WRAPPERS\n\n    /// @notice Qualifies a deposit and mints TBTC.\n    /// @dev User must allow VendingManchine to transfer TDT.\n    function unqualifiedDepositToTbtc(\n        ad","contract":"VendingMachine","time":0},{"type":"immutable-restrict-modification ","before":"    _totalDifficul","after":"    _totalDifficul","contract":"VendingMachine","time":0},{"type":"immutable-restrict-modification ","before":" bond, _maxSecuredLifetime);\n    }\n","after":" bond, _maxSecuredLifetime);\n    }\n","contract":"VendingMachine","time":0}]}