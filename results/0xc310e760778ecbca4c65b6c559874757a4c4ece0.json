{"time":267,"results":[{"type":"immutable-restrict-modification ","before":"address private punkOwner;","after":"address private immutable punkOwner;","contract":"PunkProxy","time":0},{"type":"state-data-arrangement ","before":"\naddress constant ERC20 = 0x90b7cf88476cc99D295429d4C1Bb1ff52448abeE;\naddress constant ERC721 = 0x58874d2951524F7f851bbBE240f0C3cF0b992d79;\naddress constant ERC1155 = 0xEDfdd7266667D48f3C9aB10194C3d325813d8c39;\naddress public CRYPTOPUNK = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\nmapping(address => PunkProxy) punkProxies;\nmapping(uint256 => bool) punkInUse;\naddress public TRADESQUAD = 0xdbD4264248e2f814838702E0CB3015AC3a7157a1;\naddress payable public VAULT = 0xdbD4264248e2f814838702E0CB3015AC3a7157a1;\nmapping(address => address) dappRelations;\nmapping(address => bool) whiteList;\nuint256 constant secs = 86400;\nCounters.Counter private _swapIds;\nbool private swapFlag;\nmapping(uint256 => swapStruct[]) nftsOne;\nmapping(uint256 => swapStruct[]) nftsTwo;\nmapping(address => swapIntent[]) swapList;\nmapping(uint256 => uint256) swapMatch;\npaymentStruct payment;","after":"mapping(address => PunkProxy) punkProxies;\nmapping(uint256 => bool) punkInUse;\nmapping(address => address) dappRelations;\nmapping(address => bool) whiteList;\nuint256 constant secs = 86400;\nCounters.Counter private _swapIds;\nmapping(uint256 => swapStruct[]) nftsOne;\nmapping(uint256 => swapStruct[]) nftsTwo;\nmapping(address => swapIntent[]) swapList;\nmapping(uint256 => uint256) swapMatch;\npaymentStruct payment;\naddress constant ERC20 = 0x90b7cf88476cc99D295429d4C1Bb1ff52448abeE;\naddress constant ERC721 = 0x58874d2951524F7f851bbBE240f0C3cF0b992d79;\naddress constant ERC1155 = 0xEDfdd7266667D48f3C9aB10194C3d325813d8c39;\naddress public CRYPTOPUNK = 0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB;\naddress public TRADESQUAD = 0xdbD4264248e2f814838702E0CB3015AC3a7157a1;\naddress payable public VAULT = 0xdbD4264248e2f814838702E0CB3015AC3a7157a1;\nbool private swapFlag;\n","contract":"BatchSwap","time":0},{"type":"external-function ","before":"function createSwapIntent(swapIntent memory _swapIntent, swapStruct[] memory _nftsOne, swapStruct[] memory _nftsTwo) payable public whenNotPaused {\n        if (payment.status) {\n            if (ERC721Interface(TRADESQUAD).balanceOf(msg.sender) == 0) {\n                require(msg.value >= payment.value.add(_swapIntent.valueOne), \"Not enought WEI for handle the transaction\");\n                _swapIntent.swapFee = getWeiPayValueAmount();\n            }\n            else {\n                require(msg.value >= _swapIntent.valueOne, \"Not enought WEI for handle the transaction\");\n                _swapIntent.swapFee = 0;\n            }\n        }\n        else\n            require(msg.value >= _swapIntent.valueOne, \"Not enought WEI for handle the transaction\");\n\n        _swapIntent.addressOne = msg.sender;\n        _swapIntent.id = _swapIds.current();\n        _swapIntent.swapStart = block.timestamp;\n        _swapIntent.swapEnd = 0;\n        _swapIntent.status = swapStatus.Opened;\n\n        swapMatch[_swapIds.current()] = swapList[msg.sender].length;\n        swapList[msg.sender].push(_swapIntent);\n\n        uint256 i;\n        for (i = 0; i < _nftsOne.length; i++)\n            nftsOne[_swapIntent.id].push(_nftsOne[i]);\n\n        for (i = 0; i < _nftsTwo.length; i++)\n            nftsTwo[_swapIntent.id].push(_nftsTwo[i]);\n\n        for (i = 0; i < nftsOne[_swapIntent.id].length; i++) {\n            require(whiteList[nftsOne[_swapIntent.id][i].dapp], \"A DAPP is not handled by the system\");\n            if (nftsOne[_swapIntent.id][i].typeStd == ERC20) {\n                ERC20Interface(nftsOne[_swapIntent.id][i].dapp).transferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].blc[0]);\n            }\n            else if (nftsOne[_swapIntent.id][i].typeStd == ERC721) {\n                ERC721Interface(nftsOne[_swapIntent.id][i].dapp).safeTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId[0], nftsOne[_swapIntent.id][i].data);\n            }\n            else if (nftsOne[_swapIntent.id][i].typeStd == ERC1155) {\n                ERC1155Interface(nftsOne[_swapIntent.id][i].dapp).safeBatchTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data);\n            }\n            else if (nftsOne[_swapIntent.id][i].typeStd == CRYPTOPUNK) {// Controllo che il CP sia presente sul proxy e che non sia in uso in un altro trade\n                require(punkInUse[nftsOne[_swapIntent.id][i].tokenId[0]] == false, \"Punk in use on another trade\");\n                require(CPInterface(CRYPTOPUNK).punkIndexToAddress(nftsOne[_swapIntent.id][i].tokenId[0]) == address(punkProxies[msg.sender]), \"CryptoPunk missing\");\n                punkInUse[nftsOne[_swapIntent.id][i].tokenId[0]] = true;\n            }\n            else {\n                customInterface(dappRelations[nftsOne[_swapIntent.id][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapIntent.id][i].dapp, _swapIntent.addressOne, dappRelations[nftsOne[_swapIntent.id][i].dapp], nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data);\n            }\n        }\n\n        emit swapEvent(msg.sender, (block.timestamp - (block.timestamp % secs)), _swapIntent.status, _swapIntent.id, _swapIntent.addressTwo);\n        _swapIds.increment();\n    }","after":"function createSwapIntent(swapIntent calldata _swapIntent, swapStruct[] calldata _nftsOne, swapStruct[] memory _nftsTwo) payable public whenNotPaused {\n        if (payment.status) {\n            if (ERC721Interface(TRADESQUAD).balanceOf(msg.sender) == 0) {\n                require(msg.value >= payment.value.add(_swapIntent.valueOne), \"Not enought WEI for handle the transaction\");\n                _swapIntent.swapFee = getWeiPayValueAmount();\n            }\n            else {\n                require(msg.value >= _swapIntent.valueOne, \"Not enought WEI for handle the transaction\");\n                _swapIntent.swapFee = 0;\n            }\n        }\n        else\n            require(msg.value >= _swapIntent.valueOne, \"Not enought WEI for handle the transaction\");\n\n        _swapIntent.addressOne = msg.sender;\n        _swapIntent.id = _swapIds.current();\n        _swapIntent.swapStart = block.timestamp;\n        _swapIntent.swapEnd = 0;\n        _swapIntent.status = swapStatus.Opened;\n\n        swapMatch[_swapIds.current()] = swapList[msg.sender].length;\n        swapList[msg.sender].push(_swapIntent);\n\n        uint256 i;\n        for (i = 0; i < _nftsOne.length; i++)\n            nftsOne[_swapIntent.id].push(_nftsOne[i]);\n\n        for (i = 0; i < _nftsTwo.length; i++)\n            nftsTwo[_swapIntent.id].push(_nftsTwo[i]);\n\n        for (i = 0; i < nftsOne[_swapIntent.id].length; i++) {\n            require(whiteList[nftsOne[_swapIntent.id][i].dapp], \"A DAPP is not handled by the system\");\n            if (nftsOne[_swapIntent.id][i].typeStd == ERC20) {\n                ERC20Interface(nftsOne[_swapIntent.id][i].dapp).transferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].blc[0]);\n            }\n            else if (nftsOne[_swapIntent.id][i].typeStd == ERC721) {\n                ERC721Interface(nftsOne[_swapIntent.id][i].dapp).safeTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId[0], nftsOne[_swapIntent.id][i].data);\n            }\n            else if (nftsOne[_swapIntent.id][i].typeStd == ERC1155) {\n                ERC1155Interface(nftsOne[_swapIntent.id][i].dapp).safeBatchTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data);\n            }\n            else if (nftsOne[_swapIntent.id][i].typeStd == CRYPTOPUNK) {// Controllo che il CP sia presente sul proxy e che non sia in uso in un altro trade\n                require(punkInUse[nftsOne[_swapIntent.id][i].tokenId[0]] == false, \"Punk in use on another trade\");\n                require(CPInterface(CRYPTOPUNK).punkIndexToAddress(nftsOne[_swapIntent.id][i].tokenId[0]) == address(punkProxies[msg.sender]), \"CryptoPunk missing\");\n                punkInUse[nftsOne[_swapIntent.id][i].tokenId[0]] = true;\n            }\n            else {\n                customInterface(dappRelations[nftsOne[_swapIntent.id][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapIntent.id][i].dapp, _swapIntent.addressOne, dappRelations[nftsOne[_swapIntent.id][i].dapp], nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data);\n            }\n        }\n\n        emit swapEvent(msg.sender, (block.timestamp - (block.timestamp % secs)), _swapIntent.status, _swapIntent.id, _swapIntent.addressTwo);\n        _swapIds.increment();\n    }","contract":"BatchSwap","time":0},{"type":"constant-restrict-modification  ","before":"bool private swapFlag;","after":"bool private constant swapFlag;","contract":"BatchSwap","time":0}]}