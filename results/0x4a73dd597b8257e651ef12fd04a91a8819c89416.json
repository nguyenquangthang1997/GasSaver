{"time":264,"results":[{"type":"loop-duplication","before":"\nstart line 1487 column 8, end line 1519 column 8\nfor (uint256 i = 0; i < mAssets.length; i++) {\n\n\n            if (address(mAssets[i].lpPool) != address(0)) {\n                mAssets[i].lpPool.getReward();\n                //withdraw rewards\n                //tokens are in mirror's lpPool contract\n                uint amounOfLpTokensStacked = mAssets[i].lpPool.balanceOf(address(this));\n                if (amounOfLpTokensStacked != 0) {\n                    mAssets[i].lpPool.withdraw(amounOfLpTokensStacked);\n                }\n            }\n\n            uint amountOfLpTokenToRemove = mAssets[i].lpToken.balanceOf(address(this));\n\n            if (amountOfLpTokenToRemove != 0) {\n                (uint256 mAssetAmount,) = router.removeLiquidity(address(mAssets[i].mAssetToken), address(ust), amountOfLpTokenToRemove, 0, 0, address(this), block.timestamp);\n                path[0] = address(mAssets[i].mAssetToken);\n\n                router.swapExactTokensForTokens(\n                    mAssetAmount,\n                    0,\n                    path,\n                    address(this),\n                    block.timestamp\n                );\n\n                //setting value to zero , since all amounts are withdrawn\n                mAssets[i].amountOfATotal = 0;\n                mAssets[i].amountOfBTotal = 0;\n                userTotalLPToken[mAssets[i].lpToken] = 0;\n            }\n        }\nstart line 1523 column 8, end line 1551 column 8\nfor (uint256 i = 0; i < mAssets.length; i++) {\n            address addr_ = address(mAssets[i].mAssetToken);\n            // UST -> mAsset on Uniswap\n            path[0] = address(ust);\n            path[1] = addr_;\n            uint _ustAmount = ustAmount.mul(mAssets[i].weight).div(10000);\n            uint[] memory amounts = router.swapExactTokensForTokens(\n                _ustAmount,\n                0,\n                path,\n                address(this),\n                block.timestamp\n            );\n\n            (, , uint256 poolTokenAmount) = router.addLiquidity(addr_, address(ust), amounts[1], _ustAmount, 0, 0, address(this), block.timestamp);\n\n            // stake LPToken to LPPool\n            //no incentives for mFB pool tokens so address(0)\n            if (address(mAssets[i].lpPool) != address(0)) {\n                mAssets[i].lpPool.stake(poolTokenAmount);\n            }\n\n            userTotalLPToken[mAssets[i].lpToken] = userTotalLPToken[mAssets[i].lpToken].add(poolTokenAmount);\n\n            (uint mAssetAmount, uint ustAmountFromPool) = updatelpTokenValue(address(mAssets[i].lpToken), userTotalLPToken[mAssets[i].lpToken]);\n            mAssets[i].amountOfATotal = mAssetAmount;\n            mAssets[i].amountOfBTotal = ustAmountFromPool;\n\n        }","after":"// merge loop\n\nstart line 1487 column 8, end line 1519 column 8\nfor (uint256 i = 0; i < mAssets.length; i++) {\n\n\n            if (address(mAssets[i].lpPool) != address(0)) {\n                mAssets[i].lpPool.getReward();\n                //withdraw rewards\n                //tokens are in mirror's lpPool contract\n                uint amounOfLpTokensStacked = mAssets[i].lpPool.balanceOf(address(this));\n                if (amounOfLpTokensStacked != 0) {\n                    mAssets[i].lpPool.withdraw(amounOfLpTokensStacked);\n                }\n            }\n\n            uint amountOfLpTokenToRemove = mAssets[i].lpToken.balanceOf(address(this));\n\n            if (amountOfLpTokenToRemove != 0) {\n                (uint256 mAssetAmount,) = router.removeLiquidity(address(mAssets[i].mAssetToken), address(ust), amountOfLpTokenToRemove, 0, 0, address(this), block.timestamp);\n                path[0] = address(mAssets[i].mAssetToken);\n\n                router.swapExactTokensForTokens(\n                    mAssetAmount,\n                    0,\n                    path,\n                    address(this),\n                    block.timestamp\n                );\n\n                //setting value to zero , since all amounts are withdrawn\n                mAssets[i].amountOfATotal = 0;\n                mAssets[i].amountOfBTotal = 0;\n                userTotalLPToken[mAssets[i].lpToken] = 0;\n            }\n        }\nstart line 1523 column 8, end line 1551 column 8\nfor (uint256 i = 0; i < mAssets.length; i++) {\n            address addr_ = address(mAssets[i].mAssetToken);\n            // UST -> mAsset on Uniswap\n            path[0] = address(ust);\n            path[1] = addr_;\n            uint _ustAmount = ustAmount.mul(mAssets[i].weight).div(10000);\n            uint[] memory amounts = router.swapExactTokensForTokens(\n                _ustAmount,\n                0,\n                path,\n                address(this),\n                block.timestamp\n            );\n\n            (, , uint256 poolTokenAmount) = router.addLiquidity(addr_, address(ust), amounts[1], _ustAmount, 0, 0, address(this), block.timestamp);\n\n            // stake LPToken to LPPool\n            //no incentives for mFB pool tokens so address(0)\n            if (address(mAssets[i].lpPool) != address(0)) {\n                mAssets[i].lpPool.stake(poolTokenAmount);\n            }\n\n            userTotalLPToken[mAssets[i].lpToken] = userTotalLPToken[mAssets[i].lpToken].add(poolTokenAmount);\n\n            (uint mAssetAmount, uint ustAmountFromPool) = updatelpTokenValue(address(mAssets[i].lpToken), userTotalLPToken[mAssets[i].lpToken]);\n            mAssets[i].amountOfATotal = mAssetAmount;\n            mAssets[i].amountOfBTotal = ustAmountFromPool;\n\n        }","contract":"FAANGStrategy","time":0},{"type":"external-function ","before":"function reBalance(uint[] memory weights) external onlyOwner {\n        require(weights.length == mAssets.length, \"Weight length mismatch\");\n        uint _weightsSum;\n        for (uint i = 0; i < weights.length; i++) {\n            Asset memory _masset = mAssets[i];\n            _masset.weight = weights[i];\n            mAssets[i] = _masset;\n            _weightsSum = _weightsSum.add(weights[i]);\n        }\n\n        require(_weightsSum == 5000, \"Invalid weights percentages\");\n        //50% mAssets 50% UST\n\n        _rebalance();\n        // rebalance based n new weights\n    }","after":"function reBalance(uint[] calldata weights) external onlyOwner {\n        require(weights.length == mAssets.length, \"Weight length mismatch\");\n        uint _weightsSum;\n        for (uint i = 0; i < weights.length; i++) {\n            Asset memory _masset = mAssets[i];\n            _masset.weight = weights[i];\n            mAssets[i] = _masset;\n            _weightsSum = _weightsSum.add(weights[i]);\n        }\n\n        require(_weightsSum == 5000, \"Invalid weights percentages\");\n        //50% mAssets 50% UST\n\n        _rebalance();\n        // rebalance based n new weights\n    }","contract":"FAANGStrategy","time":0}]}