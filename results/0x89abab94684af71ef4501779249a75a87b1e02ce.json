{"time":884,"results":[{"type":"external-function ","before":"function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) external override(IERC1155Receiver) returns (bytes4) {\n        return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\n    }","after":"function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external override(IERC1155Receiver) returns (bytes4) {\n        return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\n    }","contract":"AMM","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) external override(IERC1155Receiver) returns (bytes4) {\n        return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\n    }","after":"function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external override(IERC1155Receiver) returns (bytes4) {\n        return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\n    }","contract":"AMM","time":0},{"type":"external-function ","before":"function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n    public\n    view\n    virtual\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","after":"function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    )\n    public\n    view\n    virtual\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","contract":"AMM","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n    public\n    virtual\n    override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n    public\n    virtual\n    override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"AMM","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n    public\n    virtual\n    override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n    public\n    virtual\n    override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"AMM","time":0},{"type":"loop-calculation","before":"Tick storage tick = _pool.ticks[tickId];","after":"// move outside for loop\nTick storage tick = _pool.ticks[tickId];","loc":{"start":{"line":911,"column":12},"end":{"line":911,"column":51}},"contract":"AMMLib","time":0},{"type":"state-data-arrangement ","before":"\nuint256 constant MAX_UINT256 = 2 ** 256 - 1;\nuint32 constant MIN_TICK = 2;\nuint32 constant MAX_TICK = 30;\nuint256 constant SAFETY_PERIOD = 6 minutes;\nuint8 public constant PROTOCOL_FEE_RATIO = 1;\nuint8 public constant MIN_DELTA = 3;\nuint8 public constant BASE_SPREAD = 4;","after":"uint256 constant MAX_UINT256 = 2 ** 256 - 1;\nuint256 constant SAFETY_PERIOD = 6 minutes;\nuint32 constant MIN_TICK = 2;\nuint32 constant MAX_TICK = 30;\nuint8 public constant PROTOCOL_FEE_RATIO = 1;\nuint8 public constant MIN_DELTA = 3;\nuint8 public constant BASE_SPREAD = 4;\n","contract":"AMMLib","time":0},{"type":"struct-data-arrangement ","before":"\nuint32 currentTick\nuint32 nextTick\nuint128 stepAmount\nuint128 remain\nuint128 currentIV\naddress trader\nbool isTickLong\nuint128 pricePerSize","after":"address trader\nuint128 stepAmount\nuint128 remain\nuint128 currentIV\nuint128 pricePerSize\nuint32 currentTick\nuint32 nextTick\nbool isTickLong\n","contract":"AMMLib","time":11},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC20","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC20","time":0},{"type":"struct-data-arrangement ","before":"\nbool isSettled\nmapping(uint256 => uint128) shorts\nmapping(uint256 => uint128) longs\nuint128 collateral\nint256 hedgePosition\nuint128 shortLiquidity","after":"mapping(uint256 => uint128) shorts\nmapping(uint256 => uint128) longs\nint256 hedgePosition\nuint128 collateral\nuint128 shortLiquidity\nbool isSettled\n","contract":"IOptionVault","time":1},{"type":"struct-data-arrangement ","before":"\naddress owner\nbool isSettled\nuint128 collateral\nint256 hedgePosition\nuint128 shortLiquidity","after":"int256 hedgePosition\naddress owner\nuint128 collateral\nuint128 shortLiquidity\nbool isSettled\n","contract":"IOptionVault","time":0},{"type":"loop-calculation","before":"int128 position = vault.longs[seriesId].toInt128() - vault.shorts[seriesId].toInt128();","after":"// move outside for loop\nint128 position = vault.longs[seriesId].toInt128() - vault.shorts[seriesId].toInt128();","loc":{"start":{"line":4313,"column":12},"end":{"line":4313,"column":98}},"contract":"OptionLib","time":0},{"type":"loop-calculation","before":"uint128 shortAmount = vault.shorts[seriesId];","after":"// move outside for loop\nuint128 shortAmount = vault.shorts[seriesId];","loc":{"start":{"line":4375,"column":12},"end":{"line":4375,"column":56}},"contract":"OptionLib","time":0},{"type":"loop-calculation","before":"uint128 longAmount = vault.longs[seriesId];","after":"// move outside for loop\nuint128 longAmount = vault.longs[seriesId];","loc":{"start":{"line":4376,"column":12},"end":{"line":4376,"column":54}},"contract":"OptionLib","time":0},{"type":"struct-data-arrangement ","before":"\naddress aggregator\nTokenContracts tokens\nuint128 seriesCount\nuint128 expiryCount\nuint128 expiredCount\nmapping(uint256 => IOptionVault.Expiration) expiries\nmapping(uint256 => IOptionVault.OptionSeries) serieses\nuint256 vaultCount\nuint128 totalDepositedToLendingPool\nmapping(uint256 => IOptionVault.Account) accounts\nmapping(uint8 => uint128) configs\nLendingPool lendingPool","after":"TokenContracts tokens\nmapping(uint256 => IOptionVault.Expiration) expiries\nmapping(uint256 => IOptionVault.OptionSeries) serieses\nuint256 vaultCount\nmapping(uint256 => IOptionVault.Account) accounts\nmapping(uint8 => uint128) configs\nLendingPool lendingPool\naddress aggregator\nuint128 seriesCount\nuint128 expiryCount\nuint128 expiredCount\nuint128 totalDepositedToLendingPool\n","contract":"OptionLib","time":0},{"type":"external-function ","before":"function onERC1155Received(\n        address _operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) external override(IERC1155Receiver) returns (bytes4) {\n        return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\n    }","after":"function onERC1155Received(\n        address _operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external override(IERC1155Receiver) returns (bytes4) {\n        return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\n    }","contract":"OptionVault","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(\n        address _operator,\n        address from,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) external override(IERC1155Receiver) returns (bytes4) {\n        return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\n    }","after":"function onERC1155BatchReceived(\n        address _operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external override(IERC1155Receiver) returns (bytes4) {\n        return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\n    }","contract":"OptionVault","time":0},{"type":"external-function ","before":"function createExpiry(\n        uint64 _expiry,\n        uint64[] memory _strikes,\n        uint64[] memory _callIVs,\n        uint64[] memory _putIVs\n    ) external onlyOperator {\n        uint128 expiryId = optionInfo.createExpiry(_expiry);\n\n        for (uint256 i = 0; i < _strikes.length; i++) {\n            createSeries(expiryId, _strikes[i], false, _callIVs[i]);\n            createSeries(expiryId, _strikes[i], true, _putIVs[i]);\n        }\n\n        emit ExpiryCreated(expiryId, _expiry);\n    }","after":"function createExpiry(\n        uint64 _expiry,\n        uint64[] calldata _strikes,\n        uint64[] calldata _callIVs,\n        uint64[] calldata _putIVs\n    ) external onlyOperator {\n        uint128 expiryId = optionInfo.createExpiry(_expiry);\n\n        for (uint256 i = 0; i < _strikes.length; i++) {\n            createSeries(expiryId, _strikes[i], false, _callIVs[i]);\n            createSeries(expiryId, _strikes[i], true, _putIVs[i]);\n        }\n\n        emit ExpiryCreated(expiryId, _expiry);\n    }","contract":"OptionVault","time":0},{"type":"external-function ","before":"function balanceOfBatch(\n        address[] memory accounts,\n        uint256[] memory ids\n    )\n    public\n    view\n    virtual\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","after":"function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    )\n    public\n    view\n    virtual\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","contract":"OptionVault","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n    public\n    virtual\n    override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n    public\n    virtual\n    override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"OptionVault","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n    public\n    virtual\n    override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n    public\n    virtual\n    override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"OptionVault","time":0}]}