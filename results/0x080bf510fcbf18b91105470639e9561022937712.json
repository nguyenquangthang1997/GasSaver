{"time":439,"results":[{"type":"loop-calculation","before":"uint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);","after":"// move outside for loop\nuint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);","loc":{"start":{"line":6653,"column":0},"end":{"line":6653,"column":110}},"contract":"MixinWrapperFunctions","time":0},{"type":"loop-calculation","before":"uint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);","after":"// move outside for loop\nuint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);","loc":{"start":{"line":6740,"column":0},"end":{"line":6740,"column":110}},"contract":"MixinWrapperFunctions","time":0},{"type":"loop-calculation","before":"uint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);","after":"// move outside for loop\nuint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);","loc":{"start":{"line":6827,"column":0},"end":{"line":6827,"column":110}},"contract":"MixinWrapperFunctions","time":0},{"type":"loop-calculation","before":"uint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);","after":"// move outside for loop\nuint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);","loc":{"start":{"line":6930,"column":0},"end":{"line":6930,"column":110}},"contract":"MixinWrapperFunctions","time":0},{"type":"external-function ","before":"function fillOrder(\n\n        Order memory order,\n\n        uint256 takerAssetFillAmount,\n\n        bytes memory signature\n\n    )\n\n    public\n\n    nonReentrant\n\n    returns (FillResults memory fillResults)\n\n    {\n\n        fillResults = fillOrderInternal(\n\n            order,\n\n            takerAssetFillAmount,\n\n            signature\n\n        );\n\n        return fillResults;\n\n    }","after":"function fillOrder(\n\n        Order calldata order,\n\n        uint256 takerAssetFillAmount,\n\n        bytes calldata signature\n\n    )\n\n    public\n\n    nonReentrant\n\n    returns (FillResults memory fillResults)\n\n    {\n\n        fillResults = fillOrderInternal(\n\n            order,\n\n            takerAssetFillAmount,\n\n            signature\n\n        );\n\n        return fillResults;\n\n    }","contract":"Exchange","time":0},{"type":"external-function ","before":"function cancelOrder(Order memory order)\n\n    public\n\n    nonReentrant\n\n    {\n\n        cancelOrderInternal(order);\n\n    }","after":"function cancelOrder(Order calldata order)\n\n    public\n\n    nonReentrant\n\n    {\n\n        cancelOrderInternal(order);\n\n    }","contract":"Exchange","time":0},{"type":"external-function ","before":"function matchOrders(\n\nLibOrder.Order memory leftOrder,\n\nLibOrder.Order memory rightOrder,\n\nbytes memory leftSignature,\n\nbytes memory rightSignature\n\n)\n\npublic\n\nnonReentrant\n\nreturns (LibFillResults.MatchedFillResults memory matchedFillResults)\n\n{\n\n// We assume that rightOrder.takerAssetData == leftOrder.makerAssetData and rightOrder.makerAssetData == leftOrder.takerAssetData.\n\n// If this assumption isn't true, the match will fail at signature validation.\n\nrightOrder.makerAssetData = leftOrder.takerAssetData;\n\nrightOrder.takerAssetData = leftOrder.makerAssetData;\n\n\n\n// Get left & right order info\n\nLibOrder.OrderInfo memory leftOrderInfo = getOrderInfo(leftOrder);\n\nLibOrder.OrderInfo memory rightOrderInfo = getOrderInfo(rightOrder);\n\n\n\n// Fetch taker address\n\naddress takerAddress = getCurrentContextAddress();\n\n\n\n// Either our context is valid or we revert\n\nassertFillableOrder(\n\nleftOrder,\n\nleftOrderInfo,\n\ntakerAddress,\n\nleftSignature\n\n);\n\nassertFillableOrder(\n\nrightOrder,\n\nrightOrderInfo,\n\ntakerAddress,\n\nrightSignature\n\n);\n\nassertValidMatch(leftOrder, rightOrder);\n\n\n\n// Compute proportional fill amounts\n\nmatchedFillResults = calculateMatchedFillResults(\n\nleftOrder,\n\nrightOrder,\n\nleftOrderInfo.orderTakerAssetFilledAmount,\n\nrightOrderInfo.orderTakerAssetFilledAmount\n\n);\n\n\n\n// Validate fill contexts\n\nassertValidFill(\n\nleftOrder,\n\nleftOrderInfo,\n\nmatchedFillResults.left.takerAssetFilledAmount,\n\nmatchedFillResults.left.takerAssetFilledAmount,\n\nmatchedFillResults.left.makerAssetFilledAmount\n\n);\n\nassertValidFill(\n\nrightOrder,\n\nrightOrderInfo,\n\nmatchedFillResults.right.takerAssetFilledAmount,\n\nmatchedFillResults.right.takerAssetFilledAmount,\n\nmatchedFillResults.right.makerAssetFilledAmount\n\n);\n\n\n\n// Update exchange state\n\nupdateFilledState(\n\nleftOrder,\n\ntakerAddress,\n\nleftOrderInfo.orderHash,\n\nleftOrderInfo.orderTakerAssetFilledAmount,\n\nmatchedFillResults.left\n\n);\n\nupdateFilledState(\n\nrightOrder,\n\ntakerAddress,\n\nrightOrderInfo.orderHash,\n\nrightOrderInfo.orderTakerAssetFilledAmount,\n\nmatchedFillResults.right\n\n);\n\n\n\n// Settle matched orders. Succeeds or throws.\n\nsettleMatchedOrders(\n\nleftOrder,\n\nrightOrder,\n\ntakerAddress,\n\nmatchedFillResults\n\n);\n\n\n\nreturn matchedFillResults;\n\n}","after":"function matchOrders(\n\nLibOrder.Order calldata leftOrder,\n\nLibOrder.Order calldata rightOrder,\n\nbytes calldata leftSignature,\n\nbytes memory rightSignature\n\n)\n\npublic\n\nnonReentrant\n\nreturns (LibFillResults.MatchedFillResults memory matchedFillResults)\n\n{\n\n// We assume that rightOrder.takerAssetData == leftOrder.makerAssetData and rightOrder.makerAssetData == leftOrder.takerAssetData.\n\n// If this assumption isn't true, the match will fail at signature validation.\n\nrightOrder.makerAssetData = leftOrder.takerAssetData;\n\nrightOrder.takerAssetData = leftOrder.makerAssetData;\n\n\n\n// Get left & right order info\n\nLibOrder.OrderInfo memory leftOrderInfo = getOrderInfo(leftOrder);\n\nLibOrder.OrderInfo memory rightOrderInfo = getOrderInfo(rightOrder);\n\n\n\n// Fetch taker address\n\naddress takerAddress = getCurrentContextAddress();\n\n\n\n// Either our context is valid or we revert\n\nassertFillableOrder(\n\nleftOrder,\n\nleftOrderInfo,\n\ntakerAddress,\n\nleftSignature\n\n);\n\nassertFillableOrder(\n\nrightOrder,\n\nrightOrderInfo,\n\ntakerAddress,\n\nrightSignature\n\n);\n\nassertValidMatch(leftOrder, rightOrder);\n\n\n\n// Compute proportional fill amounts\n\nmatchedFillResults = calculateMatchedFillResults(\n\nleftOrder,\n\nrightOrder,\n\nleftOrderInfo.orderTakerAssetFilledAmount,\n\nrightOrderInfo.orderTakerAssetFilledAmount\n\n);\n\n\n\n// Validate fill contexts\n\nassertValidFill(\n\nleftOrder,\n\nleftOrderInfo,\n\nmatchedFillResults.left.takerAssetFilledAmount,\n\nmatchedFillResults.left.takerAssetFilledAmount,\n\nmatchedFillResults.left.makerAssetFilledAmount\n\n);\n\nassertValidFill(\n\nrightOrder,\n\nrightOrderInfo,\n\nmatchedFillResults.right.takerAssetFilledAmount,\n\nmatchedFillResults.right.takerAssetFilledAmount,\n\nmatchedFillResults.right.makerAssetFilledAmount\n\n);\n\n\n\n// Update exchange state\n\nupdateFilledState(\n\nleftOrder,\n\ntakerAddress,\n\nleftOrderInfo.orderHash,\n\nleftOrderInfo.orderTakerAssetFilledAmount,\n\nmatchedFillResults.left\n\n);\n\nupdateFilledState(\n\nrightOrder,\n\ntakerAddress,\n\nrightOrderInfo.orderHash,\n\nrightOrderInfo.orderTakerAssetFilledAmount,\n\nmatchedFillResults.right\n\n);\n\n\n\n// Settle matched orders. Succeeds or throws.\n\nsettleMatchedOrders(\n\nleftOrder,\n\nrightOrder,\n\ntakerAddress,\n\nmatchedFillResults\n\n);\n\n\n\nreturn matchedFillResults;\n\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function fillOrKillOrder(\n\nLibOrder.Order memory order,\n\nuint256 takerAssetFillAmount,\n\nbytes memory signature\n\n)\n\npublic\n\nnonReentrant\n\nreturns (FillResults memory fillResults)\n\n{\n\nfillResults = fillOrKillOrderInternal(\n\norder,\n\ntakerAssetFillAmount,\n\nsignature\n\n);\n\nreturn fillResults;\n\n}","after":"function fillOrKillOrder(\n\nLibOrder.Order calldata order,\n\nuint256 takerAssetFillAmount,\n\nbytes calldata signature\n\n)\n\npublic\n\nnonReentrant\n\nreturns (FillResults memory fillResults)\n\n{\n\nfillResults = fillOrKillOrderInternal(\n\norder,\n\ntakerAssetFillAmount,\n\nsignature\n\n);\n\nreturn fillResults;\n\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function batchFillOrders(\n\nLibOrder.Order[] memory orders,\n\nuint256[] memory takerAssetFillAmounts,\n\nbytes[] memory signatures\n\n)\n\npublic\n\nnonReentrant\n\nreturns (FillResults memory totalFillResults)\n\n{\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\nFillResults memory singleFillResults = fillOrderInternal(\n\norders[i],\n\ntakerAssetFillAmounts[i],\n\nsignatures[i]\n\n);\n\naddFillResults(totalFillResults, singleFillResults);\n\n}\n\nreturn totalFillResults;\n\n}","after":"function batchFillOrders(\n\nLibOrder.Order[] calldata orders,\n\nuint256[] calldata takerAssetFillAmounts,\n\nbytes[] calldata signatures\n\n)\n\npublic\n\nnonReentrant\n\nreturns (FillResults memory totalFillResults)\n\n{\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\nFillResults memory singleFillResults = fillOrderInternal(\n\norders[i],\n\ntakerAssetFillAmounts[i],\n\nsignatures[i]\n\n);\n\naddFillResults(totalFillResults, singleFillResults);\n\n}\n\nreturn totalFillResults;\n\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function batchFillOrKillOrders(\n\nLibOrder.Order[] memory orders,\n\nuint256[] memory takerAssetFillAmounts,\n\nbytes[] memory signatures\n\n)\n\npublic\n\nnonReentrant\n\nreturns (FillResults memory totalFillResults)\n\n{\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\nFillResults memory singleFillResults = fillOrKillOrderInternal(\n\norders[i],\n\ntakerAssetFillAmounts[i],\n\nsignatures[i]\n\n);\n\naddFillResults(totalFillResults, singleFillResults);\n\n}\n\nreturn totalFillResults;\n\n}","after":"function batchFillOrKillOrders(\n\nLibOrder.Order[] calldata orders,\n\nuint256[] calldata takerAssetFillAmounts,\n\nbytes[] calldata signatures\n\n)\n\npublic\n\nnonReentrant\n\nreturns (FillResults memory totalFillResults)\n\n{\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\nFillResults memory singleFillResults = fillOrKillOrderInternal(\n\norders[i],\n\ntakerAssetFillAmounts[i],\n\nsignatures[i]\n\n);\n\naddFillResults(totalFillResults, singleFillResults);\n\n}\n\nreturn totalFillResults;\n\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function batchFillOrdersNoThrow(\n\nLibOrder.Order[] memory orders,\n\nuint256[] memory takerAssetFillAmounts,\n\nbytes[] memory signatures\n\n)\n\npublic\n\nreturns (FillResults memory totalFillResults)\n\n{\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\nFillResults memory singleFillResults = fillOrderNoThrow(\n\norders[i],\n\ntakerAssetFillAmounts[i],\n\nsignatures[i]\n\n);\n\naddFillResults(totalFillResults, singleFillResults);\n\n}\n\nreturn totalFillResults;\n\n}","after":"function batchFillOrdersNoThrow(\n\nLibOrder.Order[] calldata orders,\n\nuint256[] calldata takerAssetFillAmounts,\n\nbytes[] calldata signatures\n\n)\n\npublic\n\nreturns (FillResults memory totalFillResults)\n\n{\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\nFillResults memory singleFillResults = fillOrderNoThrow(\n\norders[i],\n\ntakerAssetFillAmounts[i],\n\nsignatures[i]\n\n);\n\naddFillResults(totalFillResults, singleFillResults);\n\n}\n\nreturn totalFillResults;\n\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function marketSellOrders(\n\nLibOrder.Order[] memory orders,\n\nuint256 takerAssetFillAmount,\n\nbytes[] memory signatures\n\n)\n\npublic\n\nnonReentrant\n\nreturns (FillResults memory totalFillResults)\n\n{\n\nbytes memory takerAssetData = orders[0].takerAssetData;\n\n\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n\n// We assume that asset being sold by taker is the same for each order.\n\n// Rather than passing this in as calldata, we use the takerAssetData from the first order in all later orders.\n\norders[i].takerAssetData = takerAssetData;\n\n\n\n// Calculate the remaining amount of takerAsset to sell\n\nuint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);\n\n\n\n// Attempt to sell the remaining amount of takerAsset\n\nFillResults memory singleFillResults = fillOrderInternal(\n\norders[i],\n\nremainingTakerAssetFillAmount,\n\nsignatures[i]\n\n);\n\n\n\n// Update amounts filled and fees paid by maker and taker\n\naddFillResults(totalFillResults, singleFillResults);\n\n\n\n// Stop execution if the entire amount of takerAsset has been sold\n\nif (totalFillResults.takerAssetFilledAmount >= takerAssetFillAmount) {\n\nbreak;\n\n}\n\n}\n\nreturn totalFillResults;\n\n}","after":"function marketSellOrders(\n\nLibOrder.Order[] calldata orders,\n\nuint256 takerAssetFillAmount,\n\nbytes[] memory signatures\n\n)\n\npublic\n\nnonReentrant\n\nreturns (FillResults memory totalFillResults)\n\n{\n\nbytes memory takerAssetData = orders[0].takerAssetData;\n\n\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n\n// We assume that asset being sold by taker is the same for each order.\n\n// Rather than passing this in as calldata, we use the takerAssetData from the first order in all later orders.\n\norders[i].takerAssetData = takerAssetData;\n\n\n\n// Calculate the remaining amount of takerAsset to sell\n\nuint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);\n\n\n\n// Attempt to sell the remaining amount of takerAsset\n\nFillResults memory singleFillResults = fillOrderInternal(\n\norders[i],\n\nremainingTakerAssetFillAmount,\n\nsignatures[i]\n\n);\n\n\n\n// Update amounts filled and fees paid by maker and taker\n\naddFillResults(totalFillResults, singleFillResults);\n\n\n\n// Stop execution if the entire amount of takerAsset has been sold\n\nif (totalFillResults.takerAssetFilledAmount >= takerAssetFillAmount) {\n\nbreak;\n\n}\n\n}\n\nreturn totalFillResults;\n\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function marketSellOrdersNoThrow(\n\nLibOrder.Order[] memory orders,\n\nuint256 takerAssetFillAmount,\n\nbytes[] memory signatures\n\n)\n\npublic\n\nreturns (FillResults memory totalFillResults)\n\n{\n\nbytes memory takerAssetData = orders[0].takerAssetData;\n\n\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n\n// We assume that asset being sold by taker is the same for each order.\n\n// Rather than passing this in as calldata, we use the takerAssetData from the first order in all later orders.\n\norders[i].takerAssetData = takerAssetData;\n\n\n\n// Calculate the remaining amount of takerAsset to sell\n\nuint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);\n\n\n\n// Attempt to sell the remaining amount of takerAsset\n\nFillResults memory singleFillResults = fillOrderNoThrow(\n\norders[i],\n\nremainingTakerAssetFillAmount,\n\nsignatures[i]\n\n);\n\n\n\n// Update amounts filled and fees paid by maker and taker\n\naddFillResults(totalFillResults, singleFillResults);\n\n\n\n// Stop execution if the entire amount of takerAsset has been sold\n\nif (totalFillResults.takerAssetFilledAmount >= takerAssetFillAmount) {\n\nbreak;\n\n}\n\n}\n\nreturn totalFillResults;\n\n}","after":"function marketSellOrdersNoThrow(\n\nLibOrder.Order[] calldata orders,\n\nuint256 takerAssetFillAmount,\n\nbytes[] memory signatures\n\n)\n\npublic\n\nreturns (FillResults memory totalFillResults)\n\n{\n\nbytes memory takerAssetData = orders[0].takerAssetData;\n\n\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n\n// We assume that asset being sold by taker is the same for each order.\n\n// Rather than passing this in as calldata, we use the takerAssetData from the first order in all later orders.\n\norders[i].takerAssetData = takerAssetData;\n\n\n\n// Calculate the remaining amount of takerAsset to sell\n\nuint256 remainingTakerAssetFillAmount = safeSub(takerAssetFillAmount, totalFillResults.takerAssetFilledAmount);\n\n\n\n// Attempt to sell the remaining amount of takerAsset\n\nFillResults memory singleFillResults = fillOrderNoThrow(\n\norders[i],\n\nremainingTakerAssetFillAmount,\n\nsignatures[i]\n\n);\n\n\n\n// Update amounts filled and fees paid by maker and taker\n\naddFillResults(totalFillResults, singleFillResults);\n\n\n\n// Stop execution if the entire amount of takerAsset has been sold\n\nif (totalFillResults.takerAssetFilledAmount >= takerAssetFillAmount) {\n\nbreak;\n\n}\n\n}\n\nreturn totalFillResults;\n\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function marketBuyOrders(\n\nLibOrder.Order[] memory orders,\n\nuint256 makerAssetFillAmount,\n\nbytes[] memory signatures\n\n)\n\npublic\n\nnonReentrant\n\nreturns (FillResults memory totalFillResults)\n\n{\n\nbytes memory makerAssetData = orders[0].makerAssetData;\n\n\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n\n// We assume that asset being bought by taker is the same for each order.\n\n// Rather than passing this in as calldata, we copy the makerAssetData from the first order onto all later orders.\n\norders[i].makerAssetData = makerAssetData;\n\n\n\n// Calculate the remaining amount of makerAsset to buy\n\nuint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);\n\n\n\n// Convert the remaining amount of makerAsset to buy into remaining amount\n\n// of takerAsset to sell, assuming entire amount can be sold in the current order\n\nuint256 remainingTakerAssetFillAmount = getPartialAmountFloor(\n\norders[i].takerAssetAmount,\n\norders[i].makerAssetAmount,\n\nremainingMakerAssetFillAmount\n\n);\n\n\n\n// Attempt to sell the remaining amount of takerAsset\n\nFillResults memory singleFillResults = fillOrderInternal(\n\norders[i],\n\nremainingTakerAssetFillAmount,\n\nsignatures[i]\n\n);\n\n\n\n// Update amounts filled and fees paid by maker and taker\n\naddFillResults(totalFillResults, singleFillResults);\n\n\n\n// Stop execution if the entire amount of makerAsset has been bought\n\nif (totalFillResults.makerAssetFilledAmount >= makerAssetFillAmount) {\n\nbreak;\n\n}\n\n}\n\nreturn totalFillResults;\n\n}","after":"function marketBuyOrders(\n\nLibOrder.Order[] calldata orders,\n\nuint256 makerAssetFillAmount,\n\nbytes[] memory signatures\n\n)\n\npublic\n\nnonReentrant\n\nreturns (FillResults memory totalFillResults)\n\n{\n\nbytes memory makerAssetData = orders[0].makerAssetData;\n\n\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n\n// We assume that asset being bought by taker is the same for each order.\n\n// Rather than passing this in as calldata, we copy the makerAssetData from the first order onto all later orders.\n\norders[i].makerAssetData = makerAssetData;\n\n\n\n// Calculate the remaining amount of makerAsset to buy\n\nuint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);\n\n\n\n// Convert the remaining amount of makerAsset to buy into remaining amount\n\n// of takerAsset to sell, assuming entire amount can be sold in the current order\n\nuint256 remainingTakerAssetFillAmount = getPartialAmountFloor(\n\norders[i].takerAssetAmount,\n\norders[i].makerAssetAmount,\n\nremainingMakerAssetFillAmount\n\n);\n\n\n\n// Attempt to sell the remaining amount of takerAsset\n\nFillResults memory singleFillResults = fillOrderInternal(\n\norders[i],\n\nremainingTakerAssetFillAmount,\n\nsignatures[i]\n\n);\n\n\n\n// Update amounts filled and fees paid by maker and taker\n\naddFillResults(totalFillResults, singleFillResults);\n\n\n\n// Stop execution if the entire amount of makerAsset has been bought\n\nif (totalFillResults.makerAssetFilledAmount >= makerAssetFillAmount) {\n\nbreak;\n\n}\n\n}\n\nreturn totalFillResults;\n\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function marketBuyOrdersNoThrow(\n\nLibOrder.Order[] memory orders,\n\nuint256 makerAssetFillAmount,\n\nbytes[] memory signatures\n\n)\n\npublic\n\nreturns (FillResults memory totalFillResults)\n\n{\n\nbytes memory makerAssetData = orders[0].makerAssetData;\n\n\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n\n// We assume that asset being bought by taker is the same for each order.\n\n// Rather than passing this in as calldata, we copy the makerAssetData from the first order onto all later orders.\n\norders[i].makerAssetData = makerAssetData;\n\n\n\n// Calculate the remaining amount of makerAsset to buy\n\nuint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);\n\n\n\n// Convert the remaining amount of makerAsset to buy into remaining amount\n\n// of takerAsset to sell, assuming entire amount can be sold in the current order\n\nuint256 remainingTakerAssetFillAmount = getPartialAmountFloor(\n\norders[i].takerAssetAmount,\n\norders[i].makerAssetAmount,\n\nremainingMakerAssetFillAmount\n\n);\n\n\n\n// Attempt to sell the remaining amount of takerAsset\n\nFillResults memory singleFillResults = fillOrderNoThrow(\n\norders[i],\n\nremainingTakerAssetFillAmount,\n\nsignatures[i]\n\n);\n\n\n\n// Update amounts filled and fees paid by maker and taker\n\naddFillResults(totalFillResults, singleFillResults);\n\n\n\n// Stop execution if the entire amount of makerAsset has been bought\n\nif (totalFillResults.makerAssetFilledAmount >= makerAssetFillAmount) {\n\nbreak;\n\n}\n\n}\n\nreturn totalFillResults;\n\n}","after":"function marketBuyOrdersNoThrow(\n\nLibOrder.Order[] calldata orders,\n\nuint256 makerAssetFillAmount,\n\nbytes[] memory signatures\n\n)\n\npublic\n\nreturns (FillResults memory totalFillResults)\n\n{\n\nbytes memory makerAssetData = orders[0].makerAssetData;\n\n\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\n\n// We assume that asset being bought by taker is the same for each order.\n\n// Rather than passing this in as calldata, we copy the makerAssetData from the first order onto all later orders.\n\norders[i].makerAssetData = makerAssetData;\n\n\n\n// Calculate the remaining amount of makerAsset to buy\n\nuint256 remainingMakerAssetFillAmount = safeSub(makerAssetFillAmount, totalFillResults.makerAssetFilledAmount);\n\n\n\n// Convert the remaining amount of makerAsset to buy into remaining amount\n\n// of takerAsset to sell, assuming entire amount can be sold in the current order\n\nuint256 remainingTakerAssetFillAmount = getPartialAmountFloor(\n\norders[i].takerAssetAmount,\n\norders[i].makerAssetAmount,\n\nremainingMakerAssetFillAmount\n\n);\n\n\n\n// Attempt to sell the remaining amount of takerAsset\n\nFillResults memory singleFillResults = fillOrderNoThrow(\n\norders[i],\n\nremainingTakerAssetFillAmount,\n\nsignatures[i]\n\n);\n\n\n\n// Update amounts filled and fees paid by maker and taker\n\naddFillResults(totalFillResults, singleFillResults);\n\n\n\n// Stop execution if the entire amount of makerAsset has been bought\n\nif (totalFillResults.makerAssetFilledAmount >= makerAssetFillAmount) {\n\nbreak;\n\n}\n\n}\n\nreturn totalFillResults;\n\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function batchCancelOrders(LibOrder.Order[] memory orders)\n\npublic\n\nnonReentrant\n\n{\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\ncancelOrderInternal(orders[i]);\n\n}\n\n}","after":"function batchCancelOrders(LibOrder.Order[] calldata orders)\n\npublic\n\nnonReentrant\n\n{\n\nuint256 ordersLength = orders.length;\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\ncancelOrderInternal(orders[i]);\n\n}\n\n}","contract":"Exchange","time":0},{"type":"external-function ","before":"function getOrdersInfo(LibOrder.Order[] memory orders)\n\npublic\n\nview\n\nreturns (LibOrder.OrderInfo[] memory)\n\n{\n\nuint256 ordersLength = orders.length;\n\nLibOrder.OrderInfo[] memory ordersInfo = new LibOrder.OrderInfo[](ordersLength);\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\nordersInfo[i] = getOrderInfo(orders[i]);\n\n}\n\nreturn ordersInfo;\n\n}","after":"function getOrdersInfo(LibOrder.Order[] calldata orders)\n\npublic\n\nview\n\nreturns (LibOrder.OrderInfo[] memory)\n\n{\n\nuint256 ordersLength = orders.length;\n\nLibOrder.OrderInfo[] memory ordersInfo = new LibOrder.OrderInfo[](ordersLength);\n\nfor (uint256 i = 0; i != ordersLength; i++) {\n\nordersInfo[i] = getOrderInfo(orders[i]);\n\n}\n\nreturn ordersInfo;\n\n}","contract":"Exchange","time":0},{"type":"immutable-restrict-modification ","before":"bytes public ZRX_ASSET_DATA;","after":"bytes public immutable ZRX_ASSET_DATA;","contract":"Exchange","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 public EIP712_DOMAIN_HASH;","after":"bytes32 public immutable EIP712_DOMAIN_HASH;","contract":"Exchange","time":1}]}