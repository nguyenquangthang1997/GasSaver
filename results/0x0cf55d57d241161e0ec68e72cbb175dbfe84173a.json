{"time":196,"results":[{"type":"state-data-arrangement ","before":"\nVaultAPI public vault;\naddress public strategist;\naddress public rewards;\naddress public keeper;\nIERC20 public want;\nuint256 public maxReportDelay = 86400;\nuint256 public profitFactor = 100;\nuint256 public debtThreshold = 0;\nbool public emergencyExit;","after":"VaultAPI public vault;\nIERC20 public want;\nuint256 public maxReportDelay = 86400;\nuint256 public profitFactor = 100;\nuint256 public debtThreshold = 0;\naddress public strategist;\naddress public rewards;\naddress public keeper;\nbool public emergencyExit;\n","contract":"BaseStrategy","time":0},{"type":"loop-duplication","before":"\nstart line 2657 column 8, end line 2671 column 8\nfor (uint256 i = 0; i < lenders.length; i++) {\n\n            uint256 apr = lenders[i].aprAfterDeposit(change);\n\n            if (apr > highestAPR) {\n\n                aprChoice = i;\n\n                highestAPR = apr;\n\n                assets = lenders[i].nav();\n\n            }\n\n        }\nstart line 2677 column 8, end line 2685 column 8\nfor (uint256 i = 0; i < lenders.length; i++) {\n\n            if (i != aprChoice) {\n\n                weightedAPR += lenders[i].weightedApr();\n\n            }\n\n        }","after":"// merge loop\n\nstart line 2657 column 8, end line 2671 column 8\nfor (uint256 i = 0; i < lenders.length; i++) {\n\n            uint256 apr = lenders[i].aprAfterDeposit(change);\n\n            if (apr > highestAPR) {\n\n                aprChoice = i;\n\n                highestAPR = apr;\n\n                assets = lenders[i].nav();\n\n            }\n\n        }\nstart line 2677 column 8, end line 2685 column 8\nfor (uint256 i = 0; i < lenders.length; i++) {\n\n            if (i != aprChoice) {\n\n                weightedAPR += lenders[i].weightedApr();\n\n            }\n\n        }","contract":"Strategy","time":0},{"type":"loop-duplication","before":"\nstart line 2706 column 8, end line 2718 column 8\nfor (uint256 i = 0; i < lenders.length; i++) {\n\n            uint256 apr = lenders[i].aprAfterDeposit(change);\n\n            if (apr < lowestApr) {\n\n                aprChoice = i;\n\n                lowestApr = apr;\n\n            }\n\n        }\nstart line 2724 column 8, end line 2746 column 8\nfor (uint256 i = 0; i < lenders.length; i++) {\n\n            if (i != aprChoice) {\n\n                weightedAPR += lenders[i].weightedApr();\n\n            } else {\n\n                uint256 asset = lenders[i].nav();\n\n                if (asset < change) {\n\n                    //simplistic. not accurate\n\n                    change = asset;\n\n                }\n\n                weightedAPR += lowestApr.mul(change);\n\n            }\n\n        }","after":"// merge loop\n\nstart line 2706 column 8, end line 2718 column 8\nfor (uint256 i = 0; i < lenders.length; i++) {\n\n            uint256 apr = lenders[i].aprAfterDeposit(change);\n\n            if (apr < lowestApr) {\n\n                aprChoice = i;\n\n                lowestApr = apr;\n\n            }\n\n        }\nstart line 2724 column 8, end line 2746 column 8\nfor (uint256 i = 0; i < lenders.length; i++) {\n\n            if (i != aprChoice) {\n\n                weightedAPR += lenders[i].weightedApr();\n\n            } else {\n\n                uint256 asset = lenders[i].nav();\n\n                if (asset < change) {\n\n                    //simplistic. not accurate\n\n                    change = asset;\n\n                }\n\n                weightedAPR += lowestApr.mul(change);\n\n            }\n\n        }","contract":"Strategy","time":0},{"type":"loop-duplication","before":"\nstart line 2795 column 8, end line 2813 column 8\nfor (uint256 i = 0; i < lenders.length; i++) {\n\n            if (lenders[i].hasAssets()) {\n\n                uint256 apr = lenders[i].apr();\n\n                if (apr < _lowestApr) {\n\n                    _lowestApr = apr;\n\n                    _lowest = i;\n\n                    lowestNav = lenders[i].nav();\n\n                }\n\n            }\n\n        }\nstart line 2824 column 8, end line 2839 column 8\nfor (uint256 i = 0; i < lenders.length; i++) {\n\n            uint256 apr;\n\n            apr = lenders[i].aprAfterDeposit(looseAssets);\n\n\n            if (apr > highestApr) {\n\n                highestApr = apr;\n\n                _highest = i;\n\n            }\n\n        }","after":"// merge loop\n\nstart line 2795 column 8, end line 2813 column 8\nfor (uint256 i = 0; i < lenders.length; i++) {\n\n            if (lenders[i].hasAssets()) {\n\n                uint256 apr = lenders[i].apr();\n\n                if (apr < _lowestApr) {\n\n                    _lowestApr = apr;\n\n                    _lowest = i;\n\n                    lowestNav = lenders[i].nav();\n\n                }\n\n            }\n\n        }\nstart line 2824 column 8, end line 2839 column 8\nfor (uint256 i = 0; i < lenders.length; i++) {\n\n            uint256 apr;\n\n            apr = lenders[i].aprAfterDeposit(looseAssets);\n\n\n            if (apr > highestApr) {\n\n                highestApr = apr;\n\n                _highest = i;\n\n            }\n\n        }","contract":"Strategy","time":0},{"type":"external-function ","before":"function manualAllocation(lenderRatio[] memory _newPositions) public onlyAuthorized {\n\n        uint256 share = 0;\n\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n\n            lenders[i].withdrawAll();\n\n        }\n\n\n        uint256 assets = want.balanceOf(address(this));\n\n\n        for (uint256 i = 0; i < _newPositions.length; i++) {\n\n            bool found = false;\n\n\n            //might be annoying and expensive to do this second loop but worth it for safety\n\n            for (uint256 j = 0; j < lenders.length; j++) {\n\n                if (address(lenders[j]) == _newPositions[j].lender) {\n\n                    found = true;\n\n                }\n\n            }\n\n            require(found, \"NOT LENDER\");\n\n\n            share += _newPositions[i].share;\n\n            uint256 toSend = assets.mul(_newPositions[i].share).div(1000);\n\n            want.safeTransfer(_newPositions[i].lender, toSend);\n\n            IGenericLender(_newPositions[i].lender).deposit();\n\n        }\n\n\n        require(share == 1000, \"SHARE!=1000\");\n\n    }","after":"function manualAllocation(lenderRatio[] calldata _newPositions) public onlyAuthorized {\n\n        uint256 share = 0;\n\n\n        for (uint256 i = 0; i < lenders.length; i++) {\n\n            lenders[i].withdrawAll();\n\n        }\n\n\n        uint256 assets = want.balanceOf(address(this));\n\n\n        for (uint256 i = 0; i < _newPositions.length; i++) {\n\n            bool found = false;\n\n\n            //might be annoying and expensive to do this second loop but worth it for safety\n\n            for (uint256 j = 0; j < lenders.length; j++) {\n\n                if (address(lenders[j]) == _newPositions[j].lender) {\n\n                    found = true;\n\n                }\n\n            }\n\n            require(found, \"NOT LENDER\");\n\n\n            share += _newPositions[i].share;\n\n            uint256 toSend = assets.mul(_newPositions[i].share).div(1000);\n\n            want.safeTransfer(_newPositions[i].lender, toSend);\n\n            IGenericLender(_newPositions[i].lender).deposit();\n\n        }\n\n\n        require(share == 1000, \"SHARE!=1000\");\n\n    }","contract":"Strategy","time":0},{"type":"constant-restrict-modification  ","before":"bool public externalOracle = false;","after":"bool public constant externalOracle = false;","contract":"Strategy","time":1}]}