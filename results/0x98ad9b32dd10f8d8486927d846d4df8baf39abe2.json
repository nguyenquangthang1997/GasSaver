{"time":557,"results":[{"type":"state-data-arrangement ","before":"\n uint256 public constant GRACE_PERIOD = 14 days\n uint256 public constant MINIMUM_DELAY = 12 hours + 2 * 60 * 15\n uint256 public constant MAXIMUM_DELAY = 30 days\n address public admin\n address public pendingAdmin\n uint256 public delay\n bool public admin_initialized\n mapping(bytes32 => bool) public queuedTransactions","after":" uint256 public constant GRACE_PERIOD = 14 days\n uint256 public constant MINIMUM_DELAY = 12 hours + 2 * 60 * 15\n uint256 public constant MAXIMUM_DELAY = 30 days\n uint256 public delay\n mapping(bytes32 => bool) public queuedTransactions\n address public admin\n address public pendingAdmin\n bool public admin_initialized\n","contract":"Timelock","time":0},{"type":"external-function ","before":" function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    )\n    public\n    returns (bytes32)\n    {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    ","after":" function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    )\n    public\n    returns (bytes32)\n    {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    ","contract":"Timelock","time":0},{"type":"external-function ","before":" function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    )\n    public\n    {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    ","after":" function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    )\n    public\n    {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    ","contract":"Timelock","time":0},{"type":"external-function ","before":" function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    )\n    public\n    payable\n    returns (bytes memory)\n    {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        // timelock not enforced prior to updating the admin. This should occur on\n        // deployment.\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        if (admin_initialized) {\n            require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n            require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n            require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n            queuedTransactions[txHash] = false;\n        }\n\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call.value(value)(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    ","after":" function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    )\n    public\n    payable\n    returns (bytes memory)\n    {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        // timelock not enforced prior to updating the admin. This should occur on\n        // deployment.\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        if (admin_initialized) {\n            require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n            require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n            require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n            queuedTransactions[txHash] = false;\n        }\n\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call.value(value)(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    ","contract":"Timelock","time":0},{"type":"immutable-restrict-modification ","before":" string public name = \"Test\"","after":" string public immutable name = \"Test\"","contract":"Token","time":0},{"type":"immutable-restrict-modification ","before":" string public symbol = \"TST\"","after":" string public immutable symbol = \"TST\"","contract":"Token","time":0},{"type":"immutable-restrict-modification ","before":" uint256 public decimals = 18","after":" uint256 public immutable decimals = 18","contract":"Token","time":0},{"type":"external-function ","before":" function _becomeImplementation(bytes memory data) public {\n        // Shh -- currently unused\n        data;\n\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == gov, \"only the gov may call _becomeImplementation\");\n    ","after":" function _becomeImplementation(bytes calldata data) public {\n        // Shh -- currently unused\n        data;\n\n        // Shh -- we don't ever want this hook to be marked pure\n        if (false) {\n            implementation = address(0);\n        }\n\n        require(msg.sender == gov, \"only the gov may call _becomeImplementation\");\n    ","contract":"VELODelegate","time":0},{"type":"external-function ","before":" function initialize(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_,\n        address initial_owner,\n        uint256 initSupply_\n    )\n    public\n    {\n        require(initSupply_ > 0, \"0 init supply\");\n\n        super.initialize(name_, symbol_, decimals_);\n\n        initSupply = initSupply_;\n        //.mul(10**24 / (BASE));\n        totalSupply = initSupply_;\n        velosScalingFactor = BASE;\n        _veloBalances[initial_owner] = initSupply_;\n        //.mul(10**24 / (BASE));\n\n        emit Transfer(address(0), msg.sender, initSupply_);\n\n        // owner renounces ownership after deployment as they need to set\n        // rebaser and incentivizer\n        // gov = gov_;\n    ","after":" function initialize(\n        string calldata name_,\n        string calldata symbol_,\n        uint8 decimals_,\n        address initial_owner,\n        uint256 initSupply_\n    )\n    public\n    {\n        require(initSupply_ > 0, \"0 init supply\");\n\n        super.initialize(name_, symbol_, decimals_);\n\n        initSupply = initSupply_;\n        //.mul(10**24 / (BASE));\n        totalSupply = initSupply_;\n        velosScalingFactor = BASE;\n        _veloBalances[initial_owner] = initSupply_;\n        //.mul(10**24 / (BASE));\n\n        emit Transfer(address(0), msg.sender, initSupply_);\n\n        // owner renounces ownership after deployment as they need to set\n        // rebaser and incentivizer\n        // gov = gov_;\n    ","contract":"VELODelegate","time":0},{"type":"external-function ","before":" function initialize(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    )\n    public\n    {\n        require(velosScalingFactor == 0, \"already initialized\");\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    ","after":" function initialize(\n        string calldata name_,\n        string calldata symbol_,\n        uint8 decimals_\n    )\n    public\n    {\n        require(velosScalingFactor == 0, \"already initialized\");\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    ","contract":"VELODelegate","time":0},{"type":"constant-restrict-modification  ","before":" bool internal _notEntered","after":" bool internal constant _notEntered","contract":"VELODelegate","time":1},{"type":"external-function ","before":" function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize)\n            }\n        }\n        return abi.decode(returnData, (bytes));\n    ","after":" function delegateToViewImplementation(bytes calldata data) public view returns (bytes memory) {\n        (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n        assembly {\n            if eq(success, 0) {\n                revert(add(returnData, 0x20), returndatasize)\n            }\n        }\n        return abi.decode(returnData, (bytes));\n    ","contract":"VELODelegator","time":0},{"type":"constant-restrict-modification  ","before":" bool internal _notEntered","after":" bool internal constant _notEntered","contract":"VELODelegator","time":0},{"type":"constant-restrict-modification  ","before":" string public name","after":" string public constant name","contract":"VELODelegator","time":0},{"type":"constant-restrict-modification  ","before":" string public symbol","after":" string public constant symbol","contract":"VELODelegator","time":0},{"type":"constant-restrict-modification  ","before":" uint8 public decimals","after":" uint8 public constant decimals","contract":"VELODelegator","time":0},{"type":"immutable-restrict-modification ","before":" address public gov","after":" address public immutable gov","contract":"VELODelegator","time":0},{"type":"constant-restrict-modification  ","before":" address public pendingGov","after":" address public constant pendingGov","contract":"VELODelegator","time":0},{"type":"constant-restrict-modification  ","before":" address public rebaser","after":" address public constant rebaser","contract":"VELODelegator","time":0},{"type":"constant-restrict-modification  ","before":" uint256 public totalSupply","after":" uint256 public constant totalSupply","contract":"VELODelegator","time":0},{"type":"constant-restrict-modification  ","before":" uint256 public velosScalingFactor","after":" uint256 public constant velosScalingFactor","contract":"VELODelegator","time":0},{"type":"constant-restrict-modification  ","before":" uint256 public initSupply","after":" uint256 public constant initSupply","contract":"VELODelegator","time":0},{"type":"constant-restrict-modification  ","before":" address public feeCharger","after":" address public constant feeCharger","contract":"VELODelegator","time":0},{"type":"struct-data-arrangement ","before":"\n uint256 i\n address propose\n uint256 et\n address[] target\n uint[] value\n string[] signature\n bytes[] calldata\n uint256 startBloc\n uint256 endBloc\n uint256 forVote\n uint256 againstVote\n bool cancele\n bool execute\n mapping(address => Receipt) receipt","after":" uint256 i\n uint256 et\n address[] target\n uint[] value\n string[] signature\n bytes[] calldata\n uint256 startBloc\n uint256 endBloc\n uint256 forVote\n uint256 againstVote\n mapping(address => Receipt) receipt\n address propose\n bool cancele\n bool execute\n","contract":"GovernorAlpha","time":0},{"type":"external-function ","before":" function propose(\n        address[] memory targets,\n        uint[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    )\n    public\n    returns (uint256)\n    {\n        require(velo.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        }\n\n        uint256 startBlock = add256(block.number, votingDelay());\n        uint256 endBlock = add256(startBlock, votingPeriod());\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n        id : proposalCount,\n        proposer : msg.sender,\n        eta : 0,\n        targets : targets,\n        values : values,\n        signatures : signatures,\n        calldatas : calldatas,\n        startBlock : startBlock,\n        endBlock : endBlock,\n        forVotes : 0,\n        againstVotes : 0,\n        canceled : false,\n        executed : false\n        });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            startBlock,\n            endBlock,\n            description\n        );\n        return newProposal.id;\n    ","after":" function propose(\n        address[] calldata targets,\n        uint[] calldata values,\n        string[] calldata signatures,\n        bytes[] calldata calldatas,\n        string calldata description\n    )\n    public\n    returns (uint256)\n    {\n        require(velo.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n        uint256 latestProposalId = latestProposalIds[msg.sender];\n        if (latestProposalId != 0) {\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n        }\n\n        uint256 startBlock = add256(block.number, votingDelay());\n        uint256 endBlock = add256(startBlock, votingPeriod());\n\n        proposalCount++;\n        Proposal memory newProposal = Proposal({\n        id : proposalCount,\n        proposer : msg.sender,\n        eta : 0,\n        targets : targets,\n        values : values,\n        signatures : signatures,\n        calldatas : calldatas,\n        startBlock : startBlock,\n        endBlock : endBlock,\n        forVotes : 0,\n        againstVotes : 0,\n        canceled : false,\n        executed : false\n        });\n\n        proposals[newProposal.id] = newProposal;\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            startBlock,\n            endBlock,\n            description\n        );\n        return newProposal.id;\n    ","contract":"GovernorAlpha","time":0},{"type":"external-function ","before":" function addTransaction(address destination, bytes memory data) public onlyGov {\n        transactions.push(Transaction({\n        destination : destination,\n        data : data\n        }));\n    ","after":" function addTransaction(address destination, bytes calldata data) public onlyGov {\n        transactions.push(Transaction({\n        destination : destination,\n        data : data\n        }));\n    ","contract":"VELORebaser","time":0},{"type":"immutable-restrict-modification ","before":" uint256 public REBASE_INTERVAL","after":" uint256 public immutable REBASE_INTERVAL","contract":"VELORebaser","time":0},{"type":"immutable-restrict-modification ","before":" uint256 public START_REBASE_AT","after":" uint256 public immutable START_REBASE_AT","contract":"VELORebaser","time":0},{"type":"immutable-restrict-modification ","before":" address public VELO","after":" address public immutable VELO","contract":"VELORebaser","time":0},{"type":"immutable-restrict-modification ","before":" uint256 public duration","after":" uint256 public immutable duration","contract":"VELOStakingPool","time":0},{"type":"immutable-restrict-modification ","before":" uint256 public starttime","after":" uint256 public immutable starttime","contract":"VELOStakingPool","time":0},{"type":"state-data-arrangement ","before":"\n bool internal _notEntered\n string public name\n string public symbol\n uint8 public decimals\n address public gov\n address public pendingGov\n address public rebaser\n uint256 public totalSupply\n uint256 public constant internalDecimals = 10 ** 18\n uint256 public constant BASE = 10 ** 18\n uint256 public velosScalingFactor\n mapping(address => uint256) internal _veloBalances\n mapping(address => mapping(address => uint256)) internal _allowedFragments\n uint256 public initSupply\n address public feeCharger","after":" string public name\n string public symbol\n uint256 public totalSupply\n uint256 public constant internalDecimals = 10 ** 18\n uint256 public constant BASE = 10 ** 18\n uint256 public velosScalingFactor\n mapping(address => uint256) internal _veloBalances\n mapping(address => mapping(address => uint256)) internal _allowedFragments\n uint256 public initSupply\n address public gov\n address public pendingGov\n address public rebaser\n address public feeCharger\n bool internal _notEntered\n uint8 public decimals\n","contract":"VELOTokenStorage","time":1},{"type":"constant-restrict-modification  ","before":" string public name = \"Wrapped Ether\"","after":" string public constant name = \"Wrapped Ether\"","contract":"WETH9","time":0},{"type":"constant-restrict-modification  ","before":" string public symbol = \"WETH\"","after":" string public constant symbol = \"WETH\"","contract":"WETH9","time":0},{"type":"constant-restrict-modification  ","before":" uint8  public decimals = 18","after":" uint8  public constant decimals = 18","contract":"WETH9","time":0}]}