{"time":2613,"results":[{"type":"external-function ","before":"function requestRedemption(\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript\n    ) public returns (bool) {\n        self.requestRedemption(_outputValueBytes, _redeemerOutputScript);\n        return true;\n    }","after":"function requestRedemption(\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript\n    ) public returns (bool) {\n        self.requestRedemption(_outputValueBytes, _redeemerOutputScript);\n        return true;\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function transferAndRequestRedemption(\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public returns (bool) {\n        self.transferAndRequestRedemption(\n            _outputValueBytes,\n            _redeemerOutputScript,\n            _finalRecipient\n        );\n        return true;\n    }","after":"function transferAndRequestRedemption(\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public returns (bool) {\n        self.transferAndRequestRedemption(\n            _outputValueBytes,\n            _redeemerOutputScript,\n            _finalRecipient\n        );\n        return true;\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function provideRedemptionProof(\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public returns (bool) {\n        self.provideRedemptionProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n        return true;\n    }","after":"function provideRedemptionProof(\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public returns (bool) {\n        self.provideRedemptionProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n        return true;\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function requestFunderAbort(bytes memory _abortOutputScript) public {\n        require(\n            self.depositOwner() == msg.sender,\n            \"Only TDT holder can request funder abort\"\n        );\n\n        self.requestFunderAbort(_abortOutputScript);\n    }","after":"function requestFunderAbort(bytes calldata _abortOutputScript) public {\n        require(\n            self.depositOwner() == msg.sender,\n            \"Only TDT holder can request funder abort\"\n        );\n\n        self.requestFunderAbort(_abortOutputScript);\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function provideFundingECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public returns (bool) {\n        self.provideFundingECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n        return true;\n    }","after":"function provideFundingECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public returns (bool) {\n        self.provideFundingECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n        return true;\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function provideBTCFundingProof(\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public returns (bool) {\n        self.provideBTCFundingProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n        return true;\n    }","after":"function provideBTCFundingProof(\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public returns (bool) {\n        self.provideBTCFundingProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n        return true;\n    }","contract":"Deposit","time":0},{"type":"external-function ","before":"function provideECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public returns (bool) {\n        self.provideECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n        return true;\n    }","after":"function provideECDSAFraudProof(\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public returns (bool) {\n        self.provideECDSAFraudProof(_v, _r, _s, _signedDigest, _preimage);\n        return true;\n    }","contract":"Deposit","time":0},{"type":"immutable-restrict-modification ","before":"urns (uint256) {\n        return gov","after":"urns (uint256) {\n        return gov","contract":"DepositFactory","time":0},{"type":"external-function ","before":"function requestFunderAbort(\n        DepositUtils.Deposit storage _d,\n        bytes memory _abortOutputScript\n    ) public {\n        require(\n            _d.inFailedSetup(),\n            \"The deposit has not failed funding\"\n        );\n\n        _d.logFunderRequestedAbort(_abortOutputScript);\n    }","after":"function requestFunderAbort(\n        DepositUtils.Deposit storage _d,\n        bytes calldata _abortOutputScript\n    ) public {\n        require(\n            _d.inFailedSetup(),\n            \"The deposit has not failed funding\"\n        );\n\n        _d.logFunderRequestedAbort(_abortOutputScript);\n    }","contract":"DepositFunding","time":0},{"type":"external-function ","before":"function provideFundingECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public {\n        require(\n            _d.inAwaitingBTCFundingProof(),\n            \"Signer fraud during funding flow only available while awaiting funding\"\n        );\n\n        _d.submitSignatureFraud(_v, _r, _s, _signedDigest, _preimage);\n        _d.logFraudDuringSetup();\n\n        // Allow deposit owner to withdraw seized bonds after contract termination.\n        uint256 _seized = _d.seizeSignerBonds();\n        _d.enableWithdrawal(_d.depositOwner(), _seized);\n\n        fundingFraudTeardown(_d);\n        _d.setFailedSetup();\n        _d.logSetupFailed();\n    }","after":"function provideFundingECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public {\n        require(\n            _d.inAwaitingBTCFundingProof(),\n            \"Signer fraud during funding flow only available while awaiting funding\"\n        );\n\n        _d.submitSignatureFraud(_v, _r, _s, _signedDigest, _preimage);\n        _d.logFraudDuringSetup();\n\n        // Allow deposit owner to withdraw seized bonds after contract termination.\n        uint256 _seized = _d.seizeSignerBonds();\n        _d.enableWithdrawal(_d.depositOwner(), _seized);\n\n        fundingFraudTeardown(_d);\n        _d.setFailedSetup();\n        _d.logSetupFailed();\n    }","contract":"DepositFunding","time":0},{"type":"external-function ","before":"function provideBTCFundingProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public returns (bool) {\n\n        require(_d.inAwaitingBTCFundingProof(), \"Not awaiting funding\");\n\n        bytes8 _valueBytes;\n        bytes memory _utxoOutpoint;\n\n        (_valueBytes, _utxoOutpoint) = _d.validateAndParseFundingSPVProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n\n        // Write down the UTXO info and set to active. Congratulations :)\n        _d.utxoSizeBytes = _valueBytes;\n        _d.utxoOutpoint = _utxoOutpoint;\n        _d.fundedAt = block.timestamp;\n\n        fundingTeardown(_d);\n        _d.setActive();\n        _d.logFunded();\n\n        return true;\n    }","after":"function provideBTCFundingProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public returns (bool) {\n\n        require(_d.inAwaitingBTCFundingProof(), \"Not awaiting funding\");\n\n        bytes8 _valueBytes;\n        bytes memory _utxoOutpoint;\n\n        (_valueBytes, _utxoOutpoint) = _d.validateAndParseFundingSPVProof(\n            _txVersion,\n            _txInputVector,\n            _txOutputVector,\n            _txLocktime,\n            _fundingOutputIndex,\n            _merkleProof,\n            _txIndexInBlock,\n            _bitcoinHeaders\n        );\n\n        // Write down the UTXO info and set to active. Congratulations :)\n        _d.utxoSizeBytes = _valueBytes;\n        _d.utxoOutpoint = _utxoOutpoint;\n        _d.fundedAt = block.timestamp;\n\n        fundingTeardown(_d);\n        _d.setActive();\n        _d.logFunded();\n\n        return true;\n    }","contract":"DepositFunding","time":0},{"type":"external-function ","before":"function provideECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes memory _preimage\n    ) public {\n        require(\n            !_d.inFunding(),\n            \"Use provideFundingECDSAFraudProof instead\"\n        );\n        require(\n            !_d.inSignerLiquidation(),\n            \"Signer liquidation already in progress\"\n        );\n        require(!_d.inEndState(), \"Contract has halted\");\n        submitSignatureFraud(_d, _v, _r, _s, _signedDigest, _preimage);\n\n        startLiquidation(_d, true);\n    }","after":"function provideECDSAFraudProof(\n        DepositUtils.Deposit storage _d,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s,\n        bytes32 _signedDigest,\n        bytes calldata _preimage\n    ) public {\n        require(\n            !_d.inFunding(),\n            \"Use provideFundingECDSAFraudProof instead\"\n        );\n        require(\n            !_d.inSignerLiquidation(),\n            \"Signer liquidation already in progress\"\n        );\n        require(!_d.inEndState(), \"Contract has halted\");\n        submitSignatureFraud(_d, _v, _r, _s, _signedDigest, _preimage);\n\n        startLiquidation(_d, true);\n    }","contract":"DepositLiquidation","time":0},{"type":"external-function ","before":"  function transferAndRequestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public {\n        _d.tbtcDepositToken.transferFrom(msg.sender, _finalRecipient, uint256(address(this)));\n\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, _finalRecipient);\n   ","after":"  function transferAndRequestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript,\n        address payable _finalRecipient\n    ) public {\n        _d.tbtcDepositToken.transferFrom(msg.sender, _finalRecipient, uint256(address(this)));\n\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, _finalRecipient);\n   ","contract":"DepositRedemption","time":0},{"type":"external-function ","before":"  function requestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes memory _redeemerOutputScript\n    ) public {\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, msg.sender);\n   ","after":"  function requestRedemption(\n        DepositUtils.Deposit storage _d,\n        bytes8 _outputValueBytes,\n        bytes calldata _redeemerOutputScript\n    ) public {\n        _requestRedemption(_d, _outputValueBytes, _redeemerOutputScript, msg.sender);\n   ","contract":"DepositRedemption","time":0},{"type":"external-function ","before":"  function provideRedemptionProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public {\n        bytes32 _txid;\n        uint256 _fundingOutputValue;\n\n        require(_d.inRedemption(), \"Redemption proof only allowed from redemption flow\");\n\n        _fundingOutputValue = redemptionTransactionChecks(_d, _txInputVector, _txOutputVector);\n\n        _txid = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n        _d.checkProofFromTxId(_txid, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        require((_d.utxoSize().sub(_fundingOutputValue)) <= _d.latestRedemptionFee, \"Incorrect fee amount\");\n\n        // Transfer TBTC to signers and close the keep.\n        distributeSignerFee(_d);\n        _d.closeKeep();\n\n        _d.distributeFeeRebate();\n\n        // We're done yey!\n        _d.setRedeemed();\n        _d.redemptionTeardown();\n        _d.logRedeemed(_txid);\n   ","after":"  function provideRedemptionProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public {\n        bytes32 _txid;\n        uint256 _fundingOutputValue;\n\n        require(_d.inRedemption(), \"Redemption proof only allowed from redemption flow\");\n\n        _fundingOutputValue = redemptionTransactionChecks(_d, _txInputVector, _txOutputVector);\n\n        _txid = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n        _d.checkProofFromTxId(_txid, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        require((_d.utxoSize().sub(_fundingOutputValue)) <= _d.latestRedemptionFee, \"Incorrect fee amount\");\n\n        // Transfer TBTC to signers and close the keep.\n        distributeSignerFee(_d);\n        _d.closeKeep();\n\n        _d.distributeFeeRebate();\n\n        // We're done yey!\n        _d.setRedeemed();\n        _d.redemptionTeardown();\n        _d.logRedeemed(_txid);\n   ","contract":"DepositRedemption","time":0},{"type":"struct-data-arrangement ","before":"\n  ITBTCSystem tbtcSyst\n  TBTCToken tbtcTok\n  IERC721 tbtcDepositTok\n  FeeRebateToken feeRebateTok\n  address vendingMachineAddre\n  uint64 lotSizeSatosh\n  uint8 currentSta\n  uint16 signerFeeDivis\n  uint16 initialCollateralizedPerce\n  uint16 undercollateralizedThresholdPerce\n  uint16 severelyUndercollateralizedThresholdPerce\n  uint256 keepSetupF\n  uint256 liquidationInitiat\n  uint256 courtesyCallInitiat\n  address payable liquidationInitiat\n  address keepAddre\n  uint256 signingGroupRequested\n  uint256 fundingProofTimerSta\n  bytes32 signingGroupPubke\n  bytes32 signingGroupPubke\n  address payable redeemerAddre\n  bytes redeemerOutputScri\n  uint256 initialRedemptionF\n  uint256 latestRedemptionF\n  uint256 withdrawalRequestTi\n  bytes32 lastRequestedDige\n  bytes8 utxoSizeByt\n  uint256 funded\n  bytes utxoOutpoi\n  mapping(address => uint256) withdrawalAllowanc\n  mapping(bytes32 => uint256) approvedDiges","after":"  ITBTCSystem tbtcSyst\n  TBTCToken tbtcTok\n  IERC721 tbtcDepositTok\n  FeeRebateToken feeRebateTok\n  uint256 keepSetupF\n  uint256 liquidationInitiat\n  uint256 courtesyCallInitiat\n  uint256 signingGroupRequested\n  uint256 fundingProofTimerSta\n  bytes32 signingGroupPubke\n  bytes32 signingGroupPubke\n  bytes redeemerOutputScri\n  uint256 initialRedemptionF\n  uint256 latestRedemptionF\n  uint256 withdrawalRequestTi\n  bytes32 lastRequestedDige\n  uint256 funded\n  bytes utxoOutpoi\n  mapping(address => uint256) withdrawalAllowanc\n  mapping(bytes32 => uint256) approvedDiges\n  address vendingMachineAddre\n  address payable liquidationInitiat\n  address keepAddre\n  address payable redeemerAddre\n  uint64 lotSizeSatosh\n  bytes8 utxoSizeByt\n  uint16 signerFeeDivis\n  uint16 initialCollateralizedPerce\n  uint16 undercollateralizedThresholdPerce\n  uint16 severelyUndercollateralizedThresholdPerce\n  uint8 currentSta\n","contract":"DepositUtils","time":665},{"type":"external-function ","before":"  function validateAndParseFundingSPVProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes memory _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes memory _bitcoinHeaders\n    ) public view returns (bytes8 _valueBytes, bytes memory _utxoOutpoint){\n        require(_txInputVector.validateVin(), \"invalid input vector provided\");\n        require(_txOutputVector.validateVout(), \"invalid output vector provided\");\n\n        bytes32 txID = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n\n        _valueBytes = findAndParseFundingOutput(_d, _txOutputVector, _fundingOutputIndex);\n\n        require(bytes8LEToUint(_valueBytes) >= _d.lotSizeSatoshis, \"Deposit too small\");\n\n        checkProofFromTxId(_d, txID, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        // The utxoOutpoint is the LE txID plus the index of the output as a 4-byte LE int\n        // _fundingOutputIndex is a uint8, so we know it is only 1 byte\n        // Therefore, pad with 3 more bytes\n        _utxoOutpoint = abi.encodePacked(txID, _fundingOutputIndex, hex\"000000\");\n   ","after":"  function validateAndParseFundingSPVProof(\n        DepositUtils.Deposit storage _d,\n        bytes4 _txVersion,\n        bytes calldata _txInputVector,\n        bytes calldata _txOutputVector,\n        bytes4 _txLocktime,\n        uint8 _fundingOutputIndex,\n        bytes calldata _merkleProof,\n        uint256 _txIndexInBlock,\n        bytes calldata _bitcoinHeaders\n    ) public view returns (bytes8 _valueBytes, bytes memory _utxoOutpoint){\n        require(_txInputVector.validateVin(), \"invalid input vector provided\");\n        require(_txOutputVector.validateVout(), \"invalid output vector provided\");\n\n        bytes32 txID = abi.encodePacked(_txVersion, _txInputVector, _txOutputVector, _txLocktime).hash256();\n\n        _valueBytes = findAndParseFundingOutput(_d, _txOutputVector, _fundingOutputIndex);\n\n        require(bytes8LEToUint(_valueBytes) >= _d.lotSizeSatoshis, \"Deposit too small\");\n\n        checkProofFromTxId(_d, txID, _merkleProof, _txIndexInBlock, _bitcoinHeaders);\n\n        // The utxoOutpoint is the LE txID plus the index of the output as a 4-byte LE int\n        // _fundingOutputIndex is a uint8, so we know it is only 1 byte\n        // Therefore, pad with 3 more bytes\n        _utxoOutpoint = abi.encodePacked(txID, _fundingOutputIndex, hex\"000000\");\n   ","contract":"DepositUtils","time":0},{"type":"state-data-arrangement ","before":"\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a0\n  mapping(uint256 => address) private _tokenOwne\n  mapping(uint256 => address) private _tokenApproval\n  mapping(address => Counters.Counter) private _ownedTokensCoun\n  mapping(address => mapping(address => bool)) private _operatorApproval\n  bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58c","after":"  mapping(uint256 => address) private _tokenOwne\n  mapping(uint256 => address) private _tokenApproval\n  mapping(address => Counters.Counter) private _ownedTokensCoun\n  mapping(address => mapping(address => bool)) private _operatorApproval\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a0\n  bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58c\n","contract":"ERC721","time":0},{"type":"immutable-restrict-modification ","before":"  string private _nam","after":"  string private _nam","contract":"FeeRebateToken","time":1},{"type":"immutable-restrict-modification ","before":"  string private _symbo","after":"  string private _symbo","contract":"FeeRebateToken","time":1},{"type":"immutable-restrict-modification ","before":"InputVector,\n                _tx","after":"InputVector,\n                _tx","contract":"FeeRebateToken","time":1},{"type":"external-function ","before":"actory.\n    /// Once both fully-backed keep factory and factory selection strategy are\n    /// set, KEEP-stake-based factory is no longer the default choice and it is\n    /// up to the selection strategy to decide which factory should be chosen.\n    /// @dev Can be called only one time!\n    /// @param _factorySelector Address of the keep factory selection strategy.\n    function setKeepFactorySelector(\n        Storage storage _self,\n        address _factorySelector\n    ) internal {\n        require(\n            address(_self.factorySelector) == address(0),\n            \"Factory selector already","after":"actory.\n    /// Once both fully-backed keep factory and factory selection strategy are\n    /// set, KEEP-stake-based factory is no longer the default choice and it is\n    /// up to the selection strategy to decide which factory should be chosen.\n    /// @dev Can be called only one time!\n    /// @param _factorySelector Address of the keep factory selection strategy.\n    function setKeepFactorySelector(\n        Storage storage _self,\n        address _factorySelector\n    ) internal {\n        require(\n            address(_self.factorySelector) == address(0),\n            \"Factory selector already","contract":"OutsourceDepositLogging","time":0},{"type":"external-function ","before":"_utxoSize,\n        bytes memory _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes memory _outpoint\n    ) public {// not external to allow bytes memory output scripts\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _log","after":"_utxoSize,\n        bytes calldata _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes memory _outpoint\n    ) public {// not external to allow bytes memory output scripts\n        DepositLog _logger = DepositLog(address(_d.tbtcSystem));\n        _log","contract":"OutsourceDepositLogging","time":0},{"type":"immutable-restrict-modification ","before":"tesLib} from \"@summa-tx/bitcoi","after":"tesLib} from \"@summa-tx/bitcoi","contract":"Relay","time":1},{"type":"external-function ","before":"erred freely. tBTC's VendingMachine\n///         contract takes ownership of TDTs and in exchange returns fungible\n///         TBTC tokens whose value is backed 1-to-1 by the corresponding\n///         deposit's BTC.\n/// @dev Currently, TDTs are minted using the uint2","after":"erred freely. tBTC's VendingMachine\n///         contract takes ownership of TDTs and in exchange returns fungible\n///         TBTC tokens whose value is backed 1-to-1 by the corresponding\n///         deposit's BTC.\n/// @dev Currently, TDTs are minted using the uint2","contract":"TBTCDepositToken","time":0},{"type":"immutable-restrict-modification ","before":"  string private _nam","after":"  string private _nam","contract":"TBTCDepositToken","time":1},{"type":"immutable-restrict-modification ","before":"  string private _symbo","after":"  string private _symbo","contract":"TBTCDepositToken","time":1},{"type":"state-data-arrangement ","before":"\nry} from \"../proxy/Deposit\nry.sol\";\n\nimport {IRelay\nm \"@summa-tx/relay-sol/contracts/Relay.sol\nort \"../external/IMedianizer.sol\";\nort {ITBTCSystem} fr\n/interfaces/ITBTCSystem.sol\";\nimport {ISatWeiPrice\nDepositLog} from \"../DepositLog.sol\";\n\nrt {TBTCDepositToken} from \"./TBTCDepos\nport \"./FeeRebateToken.sol\";\nimport \"openzeppelin-\nts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/\nfeMath.sol\";\nimport \"./KeepFactorySelection.sol\";\n\n/// @title  TB\nnotice This contract acts as a central point for access control,\n///         value governan\nes should only affect new deposit creation.\ncont\nBTCSystem is Ownable, ITBTCSystem, DepositLog {\n\nusing SafeMath for uint256;\n    using Ke\ntorySelection for KeepFactorySelection.Storage;\n\n    event \ncPriceFeedAdditionStarted(address _priceFeed, uint256\nstamp);\n    event LotSizesUpdateSta\nuint64[] _lotSizes, uint256 _\ntamp);\n    event SignerFeeDivisorUpdateStarted(\n6 _signerFeeDivisor, uint256 _timestamp);\n    event Co\nralizationThresholdsUpdateStarted(\n        uint16 _initialColl\nlizedPercent,\n        uint16 _under\nteralizedThresholdPercent,\n        u\nateralizedThresholdPercent,\n        uint256 _ti\nmp\n    );\n    event KeepFactorySingleShot\neStarted(\n        address _facto","after":"ry.sol\";\n\nimport {IRelay\nm \"@summa-tx/relay-sol/contracts/Relay.sol\nort \"../external/IMedianizer.sol\";\nort {ITBTCSystem} fr\n/interfaces/ITBTCSystem.sol\";\nimport {ISatWeiPrice\nnotice This contract acts as a central point for access control,\n///         value governan\nes should only affect new deposit creation.\ncont\nBTCSystem is Ownable, ITBTCSystem, DepositLog {\n\nusing SafeMath for uint256;\n    using Ke\ntorySelection for KeepFactorySelection.Storage;\n\n    event \ncPriceFeedAdditionStarted(address _priceFeed, uint256\nuint64[] _lotSizes, uint256 _\nateralizedThresholdPercent,\n        uint256 _ti\nmp\n    );\n    event KeepFactorySingleShot\neStarted(\n        address _facto\nlizedPercent,\n        uint16 _under\nteralizedThresholdPercent,\n        u\nrt {TBTCDepositToken} from \"./TBTCDepos\nport \"./FeeRebateToken.sol\";\nimport \"openzeppelin-\nts/ownership/Ownable.sol\";\nimport \"openzeppelin-solidity/\nfeMath.sol\";\nimport \"./KeepFactorySelection.sol\";\n\n/// @title  TB\nstamp);\n    event LotSizesUpdateSta\ntamp);\n    event SignerFeeDivisorUpdateStarted(\n6 _signerFeeDivisor, uint256 _timestamp);\n    event Co\nralizationThresholdsUpdateStarted(\n        uint16 _initialColl\nry} from \"../proxy/Deposit\nDepositLog} from \"../DepositLog.sol\";\n\n","contract":"TBTCSystem","time":41},{"type":"external-function ","before":"function logRedemptionRequested(\n        address _requester,\n        bytes32 _digest,\n        uint256 _utxoSize,\n        bytes memory _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes memory _outpoint\n    ) public {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit RedemptionRequested(\n            msg.sender,\n            _requester,\n            _digest,\n            _utxoSize,\n            _redeemerOutputScript,\n            _requestedFee,\n            _outpoint\n        );\n    }","after":"function logRedemptionRequested(\n        address _requester,\n        bytes32 _digest,\n        uint256 _utxoSize,\n        bytes calldata _redeemerOutputScript,\n        uint256 _requestedFee,\n        bytes calldata _outpoint\n    ) public {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit RedemptionRequested(\n            msg.sender,\n            _requester,\n            _digest,\n            _utxoSize,\n            _redeemerOutputScript,\n            _requestedFee,\n            _outpoint\n        );\n    }","contract":"TBTCSystem","time":0},{"type":"external-function ","before":"function logFunderRequestedAbort(bytes memory _abortOutputScript) public {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit FunderAbortRequested(msg.sender, _abortOutputScript);\n    }","after":"function logFunderRequestedAbort(bytes calldata _abortOutputScript) public {\n        require(\n            approvedToLog(msg.sender),\n            \"Caller is not approved to log events\"\n        );\n        emit FunderAbortRequested(msg.sender, _abortOutputScript);\n    }","contract":"TBTCSystem","time":0},{"type":"constant-restrict-modification  ","before":"ateralizedThresholdPercent,\n        uint256 _ti","after":"ateralizedThresholdPercent,\n        uint256 _ti","contract":"TBTCSystem","time":3},{"type":"external-function ","before":"s _VendingMachine)\n    ERC20Detailed(\"tBTC\", \"TBTC\", 18)\n    VendingMachineAuthority(_VendingMachine)\n    public {\n        // solium-disable-previous-line no-empty-blocks\n    }\n\n    /// @dev             Mints an amount of the token and assigns it to an account.\n    ///                  Uses the internal _mint f","after":"s _VendingMachine)\n    ERC20Detailed(\"tBTC\", \"TBTC\", 18)\n    VendingMachineAuthority(_VendingMachine)\n    public {\n        // solium-disable-previous-line no-empty-blocks\n    }\n\n    /// @dev             Mints an amount of the token and assigns it to an account.\n    ///                  Uses the internal _mint f","contract":"TBTCToken","time":0},{"type":"immutable-restrict-modification ","before":"  string private _nam","after":"  string private _nam","contract":"TBTCToken","time":1},{"type":"immutable-restrict-modification ","before":"  string private _symbo","after":"  string private _symbo","contract":"TBTCToken","time":1},{"type":"immutable-restrict-modification ","before":"  uint8 private _decimal","after":"  uint8 private _decimal","contract":"TBTCToken","time":1},{"type":"immutable-restrict-modification ","before":"InputVector,\n                _tx","after":"InputVector,\n                _tx","contract":"TBTCToken","time":1},{"type":"external-function ","before":"btcToTdt(uint256 _tdtId) public {\n        require(tbtcDepositToken.exists(_tdtId), \"tBTC Deposit Token does not exist\");\n        require(isQualified(address(_tdtId)), \"Deposit must be qualified\");\n\n        uint256 depositValue = Deposit(address(uint160(_tdtId))).lotSizeTbtc();\n        require(tbtcToken.balanceOf(msg.sender) >= depositValue, \"Not enough TBTC for TDT exchange\");\n        tbtcToken.burnFrom(msg.sender, depositValue);\n\n        // TODO do we need the owner check below? transferFrom can be approved for a user, which might be an interesting use case.\n        require(tbtcDepositToken.ownerOf(_tdtId) == address(this), \"Deposit is locked\");\n        tbtcDepositToken.transferFrom(address(this), msg.sender, _tdtId);\n    }\n\n    /// @notice Transfer the tBTC Deposit Token and mint TBTC.\n    /// @dev    Transfers TDT fro","after":"btcToTdt(uint256 _tdtId) public {\n        require(tbtcDepositToken.exists(_tdtId), \"tBTC Deposit Token does not exist\");\n        require(isQualified(address(_tdtId)), \"Deposit must be qualified\");\n\n        uint256 depositValue = Deposit(address(uint160(_tdtId))).lotSizeTbtc();\n        require(tbtcToken.balanceOf(msg.sender) >= depositValue, \"Not enough TBTC for TDT exchange\");\n        tbtcToken.burnFrom(msg.sender, depositValue);\n\n        // TODO do we need the owner check below? transferFrom can be approved for a user, which might be an interesting use case.\n        require(tbtcDepositToken.ownerOf(_tdtId) == address(this), \"Deposit is locked\");\n        tbtcDepositToken.transferFrom(address(this), msg.sender, _tdtId);\n    }\n\n    /// @notice Transfer the tBTC Deposit Token and mint TBTC.\n    /// @dev    Transfers TDT fro","contract":"VendingMachine","time":0},{"type":"external-function ","before":"     uint256 depositValue = deposit.lotSizeTbtc();\n\n        if (tbtcToken.balanceOf(address(_tdtId)) < signerFee) {\n            tbtcToken.mint(msg.sender, depositValue.sub(signerFee));\n            tbtcToken.mint(address(_tdtId), signerFee);\n        }\n        else {\n            tbtcToken.mint(msg.sender, depositValue);\n        }\n\n        // owner of the TDT during first TBTC mint receives the FRT\n        if (!feeRebateToken.exists(_tdtId)) {\n            feeRebateToken.mint(msg.sender, _tdtId);\n        }\n    }\n\n    // WRAPPERS\n\n    /// @notice Qualifies a deposit and mints TBTC.\n    /// @dev User must allow VendingManchine to transfer TDT.\n    function unqualifiedDepositToTbtc(\n        address payable _depositAddress,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        b","after":"     uint256 depositValue = deposit.lotSizeTbtc();\n\n        if (tbtcToken.balanceOf(address(_tdtId)) < signerFee) {\n            tbtcToken.mint(msg.sender, depositValue.sub(signerFee));\n            tbtcToken.mint(address(_tdtId), signerFee);\n        }\n        else {\n            tbtcToken.mint(msg.sender, depositValue);\n        }\n\n        // owner of the TDT during first TBTC mint receives the FRT\n        if (!feeRebateToken.exists(_tdtId)) {\n            feeRebateToken.mint(msg.sender, _tdtId);\n        }\n    }\n\n    // WRAPPERS\n\n    /// @notice Qualifies a deposit and mints TBTC.\n    /// @dev User must allow VendingManchine to transfer TDT.\n    function unqualifiedDepositToTbtc(\n        address payable _depositAddress,\n        bytes4 _txVersion,\n        bytes memory _txInputVector,\n        bytes memory _txOutputVector,\n        b","contract":"VendingMachine","time":0},{"type":"immutable-restrict-modification ","before":"urns (uint256) {\n        return gov","after":"urns (uint256) {\n        return gov","contract":"VendingMachine","time":0}]}