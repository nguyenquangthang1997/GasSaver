{"time":238,"results":[{"type":"struct-data-arrangement ","before":"\nuint id\naddress proposer\nuint eta\naddress[] targets\nuint[] values\nstring[] signatures\nbytes[] calldatas\nuint startBlock\nuint endBlock\nuint forVotes\nuint againstVotes\nbool canceled\nbool executed\nmapping(address => Receipt) receipts","after":"uint id\nuint eta\naddress[] targets\nuint[] values\nstring[] signatures\nbytes[] calldatas\nuint startBlock\nuint endBlock\nuint forVotes\nuint againstVotes\nmapping(address => Receipt) receipts\naddress proposer\nbool canceled\nbool executed\n","contract":"GovernorAlpha","time":0},{"type":"external-function ","before":"function propose(address[] memory targets, uint[] memory values, string[] memory signatures, bytes[] memory calldatas, string memory description) public returns (uint) {\n\n        require(uni.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n\n        if (latestProposalId != 0) {\n\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n\n        }\n\n\n        uint startBlock = add256(block.number, votingDelay());\n\n        uint endBlock = add256(startBlock, votingPeriod());\n\n\n        proposalCount++;\n\n        Proposal memory newProposal = Proposal({\n\n        id : proposalCount,\n\n        proposer : msg.sender,\n\n        eta : 0,\n\n        targets : targets,\n\n        values : values,\n\n        signatures : signatures,\n\n        calldatas : calldatas,\n\n        startBlock : startBlock,\n\n        endBlock : endBlock,\n\n        forVotes : 0,\n\n        againstVotes : 0,\n\n        canceled : false,\n\n        executed : false\n\n        });\n\n\n        proposals[newProposal.id] = newProposal;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n\n        return newProposal.id;\n\n    }","after":"function propose(address[] calldata targets, uint[] calldata values, string[] calldata signatures, bytes[] calldata calldatas, string calldata description) public returns (uint) {\n\n        require(uni.getPriorVotes(msg.sender, sub256(block.number, 1)) > proposalThreshold(), \"GovernorAlpha::propose: proposer votes below proposal threshold\");\n\n        require(targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length, \"GovernorAlpha::propose: proposal function information arity mismatch\");\n\n        require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n\n        require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n\n        uint latestProposalId = latestProposalIds[msg.sender];\n\n        if (latestProposalId != 0) {\n\n            ProposalState proposersLatestProposalState = state(latestProposalId);\n\n            require(proposersLatestProposalState != ProposalState.Active, \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\");\n\n            require(proposersLatestProposalState != ProposalState.Pending, \"GovernorAlpha::propose: one live proposal per proposer, found an already pending proposal\");\n\n        }\n\n\n        uint startBlock = add256(block.number, votingDelay());\n\n        uint endBlock = add256(startBlock, votingPeriod());\n\n\n        proposalCount++;\n\n        Proposal memory newProposal = Proposal({\n\n        id : proposalCount,\n\n        proposer : msg.sender,\n\n        eta : 0,\n\n        targets : targets,\n\n        values : values,\n\n        signatures : signatures,\n\n        calldatas : calldatas,\n\n        startBlock : startBlock,\n\n        endBlock : endBlock,\n\n        forVotes : 0,\n\n        againstVotes : 0,\n\n        canceled : false,\n\n        executed : false\n\n        });\n\n\n        proposals[newProposal.id] = newProposal;\n\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n\n        emit ProposalCreated(newProposal.id, msg.sender, targets, values, signatures, calldatas, startBlock, endBlock, description);\n\n        return newProposal.id;\n\n    }","contract":"GovernorAlpha","time":1}]}