{"time":658,"results":[{"type":"external-function ","before":"function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable onlyOwner {\n        proxy.upgradeToAndCall{value : msg.value}(implementation, data);\n    }","after":"function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes calldata data) public payable onlyOwner {\n        proxy.upgradeToAndCall{value : msg.value}(implementation, data);\n    }","contract":"DeploymentAdmin","time":0},{"type":"external-function ","before":"function store(Types.Config storage cs, Types.Config memory config) public {\n        cs.devTeam = config.devTeam;\n        cs.minFee = config.minFee;\n        cs.penaltyFee = config.penaltyFee;\n        cs.lockoutBlocks = config.lockoutBlocks;\n        require(cs.devTeam != address(0), \"Invalid dev team address\");\n    }","after":"function store(Types.Config storage cs, Types.Config calldata config) public {\n        cs.devTeam = config.devTeam;\n        cs.minFee = config.minFee;\n        cs.penaltyFee = config.penaltyFee;\n        cs.lockoutBlocks = config.lockoutBlocks;\n        require(cs.devTeam != address(0), \"Invalid dev team address\");\n    }","contract":"LibConfig","time":0},{"type":"external-function ","before":"function canSwap(Types.Order memory order, uint256 gasPrice) public view returns (bool) {\n        return _hasFunds(order, gasPrice) &&\n        _hasTokens(order) &&\n        _canSpend(order);\n    }","after":"function canSwap(Types.Order calldata order, uint256 gasPrice) public view returns (bool) {\n        return _hasFunds(order, gasPrice) &&\n        _hasTokens(order) &&\n        _canSpend(order);\n    }","contract":"SwapSettlement","time":0},{"type":"external-function ","before":"function initialize(Types.Config memory config) public initializer {\n        BaseConfig.initConfig(config);\n    }","after":"function initialize(Types.Config calldata config) public initializer {\n        BaseConfig.initConfig(config);\n    }","contract":"SwapSettlement","time":0},{"type":"external-function ","before":"function fill(\n        Types.Order memory order,\n        ISwapAction script) public onlyRelay nonReentrant {\n\n        uint256 startGas = gasleft();\n\n        //if the trader ran out of funds, they can't pay so bail as quickly as possible\n        require(_hasFunds(order, tx.gasprice), \"Insufficient funds to pay for txn\");\n\n        //make sure not attempting bad script\n        if (!hasRole(ACTION_ROLE, address(script))) {\n            //console.log(\"Unapproved action script\");\n            _penalize(order, startGas, \"Attempting to call unapproved action script\");\n            return;\n        }\n\n        //make sure tokens are still in tact\n        if (!_hasTokens(order)) {\n            _penalize(order, startGas, \"Insufficient token balance for trade\");\n            return;\n        }\n\n        //make sure we are still allowed to transfer\n        if (!_canSpend(order)) {\n            _penalize(order, startGas, \"Insufficient spend allowance for trade\");\n            return;\n        }\n\n\n        //before balances\n        uint256 inBal = order.input.token.balanceOf(order.trader);\n        uint256 outBal = order.output.token.balanceOf(order.trader);\n\n\n        bool success;\n        string memory failReason;\n\n        //execute action\n        try this.trySwap{\n        gas : gasleft().sub(OP_GAS)\n        }(order, script) {\n\n            //success, verify outputs\n            success = true;\n\n        } catch Error(string memory err) {\n            success = false;\n            failReason = err;\n        } catch {\n            success = false;\n            failReason = \"Unknown fail reason\";\n        }\n\n        uint256 afterInBal = order.input.token.balanceOf(order.trader);\n        if (!success) {\n            //console.log(\"Swap failed\", failReason);\n            //have to revert if funds were not refunded in order to roll everything back.\n            //in this case, the action is at fault, which is owner's fault and therefore \n            //owner's relay address should eat the cost of failure\n            require(afterInBal == inBal, \"failed swap action did not refund input funds\");\n\n            //otherwise, funds returned but something else is wrong like benign slippage\n            //which the trader has to pay for since they set the slippage rate.\n\n            //tell trader it failed\n            emit SwapFailed(order.trader, failReason);\n\n            //pay relayer back their gas but take no fee\n            uint256 totalGasUsed = startGas.sub(gasleft()).add(GAS_OVERHEAD);\n            uint256 gasFee = totalGasUsed.mul(tx.gasprice);\n            deduct(order.trader, uint112(gasFee));\n            //console.log(\"Paying gas\", gasFee);\n            _msgSender().transfer(gasFee);\n            return;\n        }\n\n        {\n            uint256 afterOut = order.output.token.balanceOf(order.trader);\n            //if the in/out amounts don't line up, then transfers weren't made properly in the\n            //script.\n            //console.log(\"Before output\", outBal);\n            //console.log(\"After output\", afterOut);\n\n            require(afterOut > outBal, \"Insufficient output produced\");\n            require(afterOut.sub(outBal) >= order.output.amount, \"Swap action did not transfer output tokens to trader\");\n            require(afterInBal < inBal, \"Input tokens not used!\");\n            require(inBal.sub(afterInBal) <= order.input.amount, \"Used too many input tokens\");\n            //otherwise, pay fee and gas\n            uint256 totalGasUsed = startGas.sub(gasleft()).add(GAS_OVERHEAD);\n            uint256 gasFee = totalGasUsed.mul(tx.gasprice);\n            //console.log(\"Gas fee\", gasFee);\n            deduct(order.trader, uint112(gasFee.add(order.fee)));\n\n            _msgSender().transfer(gasFee);\n            payable(LibStorage.getConfigStorage().devTeam).transfer(order.fee);\n\n            emit SwapSuccess(order.trader,\n                _msgSender(),\n                inBal.sub(afterInBal),\n                afterOut.sub(outBal),\n                order.fee,\n                gasFee);\n        }\n    }","after":"function fill(\n        Types.Order calldata order,\n        ISwapAction script) public onlyRelay nonReentrant {\n\n        uint256 startGas = gasleft();\n\n        //if the trader ran out of funds, they can't pay so bail as quickly as possible\n        require(_hasFunds(order, tx.gasprice), \"Insufficient funds to pay for txn\");\n\n        //make sure not attempting bad script\n        if (!hasRole(ACTION_ROLE, address(script))) {\n            //console.log(\"Unapproved action script\");\n            _penalize(order, startGas, \"Attempting to call unapproved action script\");\n            return;\n        }\n\n        //make sure tokens are still in tact\n        if (!_hasTokens(order)) {\n            _penalize(order, startGas, \"Insufficient token balance for trade\");\n            return;\n        }\n\n        //make sure we are still allowed to transfer\n        if (!_canSpend(order)) {\n            _penalize(order, startGas, \"Insufficient spend allowance for trade\");\n            return;\n        }\n\n\n        //before balances\n        uint256 inBal = order.input.token.balanceOf(order.trader);\n        uint256 outBal = order.output.token.balanceOf(order.trader);\n\n\n        bool success;\n        string memory failReason;\n\n        //execute action\n        try this.trySwap{\n        gas : gasleft().sub(OP_GAS)\n        }(order, script) {\n\n            //success, verify outputs\n            success = true;\n\n        } catch Error(string memory err) {\n            success = false;\n            failReason = err;\n        } catch {\n            success = false;\n            failReason = \"Unknown fail reason\";\n        }\n\n        uint256 afterInBal = order.input.token.balanceOf(order.trader);\n        if (!success) {\n            //console.log(\"Swap failed\", failReason);\n            //have to revert if funds were not refunded in order to roll everything back.\n            //in this case, the action is at fault, which is owner's fault and therefore \n            //owner's relay address should eat the cost of failure\n            require(afterInBal == inBal, \"failed swap action did not refund input funds\");\n\n            //otherwise, funds returned but something else is wrong like benign slippage\n            //which the trader has to pay for since they set the slippage rate.\n\n            //tell trader it failed\n            emit SwapFailed(order.trader, failReason);\n\n            //pay relayer back their gas but take no fee\n            uint256 totalGasUsed = startGas.sub(gasleft()).add(GAS_OVERHEAD);\n            uint256 gasFee = totalGasUsed.mul(tx.gasprice);\n            deduct(order.trader, uint112(gasFee));\n            //console.log(\"Paying gas\", gasFee);\n            _msgSender().transfer(gasFee);\n            return;\n        }\n\n        {\n            uint256 afterOut = order.output.token.balanceOf(order.trader);\n            //if the in/out amounts don't line up, then transfers weren't made properly in the\n            //script.\n            //console.log(\"Before output\", outBal);\n            //console.log(\"After output\", afterOut);\n\n            require(afterOut > outBal, \"Insufficient output produced\");\n            require(afterOut.sub(outBal) >= order.output.amount, \"Swap action did not transfer output tokens to trader\");\n            require(afterInBal < inBal, \"Input tokens not used!\");\n            require(inBal.sub(afterInBal) <= order.input.amount, \"Used too many input tokens\");\n            //otherwise, pay fee and gas\n            uint256 totalGasUsed = startGas.sub(gasleft()).add(GAS_OVERHEAD);\n            uint256 gasFee = totalGasUsed.mul(tx.gasprice);\n            //console.log(\"Gas fee\", gasFee);\n            deduct(order.trader, uint112(gasFee.add(order.fee)));\n\n            _msgSender().transfer(gasFee);\n            payable(LibStorage.getConfigStorage().devTeam).transfer(order.fee);\n\n            emit SwapSuccess(order.trader,\n                _msgSender(),\n                inBal.sub(afterInBal),\n                afterOut.sub(outBal),\n                order.fee,\n                gasFee);\n        }\n    }","contract":"SwapSettlement","time":0},{"type":"external-function ","before":"function setConfig(Types.Config memory config) public onlyAdmin {\n        LibStorage.getConfigStorage().store(config);\n    }","after":"function setConfig(Types.Config calldata config) public onlyAdmin {\n        LibStorage.getConfigStorage().store(config);\n    }","contract":"SwapSettlement","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"TokenA","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"TokenA","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"TokenB","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"TokenB","time":0},{"type":"struct-data-arrangement ","before":"\naddress devTeam\nuint128 minFee\nuint128 penaltyFee\nuint8 lockoutBlocks","after":"address devTeam\nuint128 minFee\nuint128 penaltyFee\nuint8 lockoutBlocks\n","contract":"Types","time":0},{"type":"external-function ","before":"function getQuote(Types.Order memory order) public view returns (uint) {\n        if (order.orderType == Types.OrderType.EXACT_IN) {\n            (uint amount,) = _getOutputQuote(order);\n            return amount;\n        }\n        (uint amount,) = _getInputQuote(order);\n        return amount;\n    }","after":"function getQuote(Types.Order calldata order) public view returns (uint) {\n        if (order.orderType == Types.OrderType.EXACT_IN) {\n            (uint amount,) = _getOutputQuote(order);\n            return amount;\n        }\n        (uint amount,) = _getInputQuote(order);\n        return amount;\n    }","contract":"Uniswapper","time":0}]}