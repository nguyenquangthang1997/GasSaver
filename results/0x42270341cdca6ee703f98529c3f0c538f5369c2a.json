{"time":104,"results":[{"type":"loop-calculation","before":" address _signer","after":"// move outside for loop\n address _signer","loc":{"start":{"line":88,"column":12},"end":{"line":88,"column":27}},"contract":"CertiDApp","time":0},{"type":"loop-calculation","before":" bytes32 _r","after":"// move outside for loop\n bytes32 _r","loc":{"start":{"line":141,"column":12},"end":{"line":141,"column":22}},"contract":"CertiDApp","time":0},{"type":"loop-calculation","before":" bytes32 _s","after":"// move outside for loop\n bytes32 _s","loc":{"start":{"line":142,"column":12},"end":{"line":142,"column":22}},"contract":"CertiDApp","time":0},{"type":"loop-calculation","before":" uint8 _v","after":"// move outside for loop\n uint8 _v","loc":{"start":{"line":143,"column":12},"end":{"line":143,"column":20}},"contract":"CertiDApp","time":0},{"type":"external-function ","before":" function updateCertifyingAuthority(\n        address _authorityAddress,\n        bytes memory _data,\n        AuthorityStatus _status\n    ) public onlyManager {\n        if (_data.length > 0) {\n            certifyingAuthorities[_authorityAddress].data = _data;\n        }\n\n        certifyingAuthorities[_authorityAddress].status = _status;\n\n        emit AuthorityStatusUpdated(_authorityAddress, _status);\n    ","after":" function updateCertifyingAuthority(\n        address _authorityAddress,\n        bytes calldata _data,\n        AuthorityStatus _status\n    ) public onlyManager {\n        if (_data.length > 0) {\n            certifyingAuthorities[_authorityAddress].data = _data;\n        }\n\n        certifyingAuthorities[_authorityAddress].status = _status;\n\n        emit AuthorityStatusUpdated(_authorityAddress, _status);\n    ","contract":"CertiDApp","time":0},{"type":"external-function ","before":" function registerCertificate(\n        bytes memory _signedCertificate\n    ) public returns (\n        bytes32\n    ) {\n        (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n        /// @notice Signers in this transaction\n        bytes memory _newSigners = _certificateObj.signers;\n\n        /// @notice If certificate already registered then signers can be updated.\n        ///   Initializing _updatedSigners with existing signers on blockchain if any.\n        ///   More signers would be appended to this in next 'for' loop.\n        bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n        /// @notice Check with every the new signer if it is not already included in storage.\n        ///   This is helpful when a same certificate is submitted again with more signatures,\n        ///   the contract will consider only new signers in that case.\n        for (uint256 i = 0; i < _newSigners.length; i += 20) {\n            address _signer;\n            assembly {\n                _signer := mload(add(_newSigners, add(0x14, i)))\n            }\n            if (_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n                _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n                emit Certified(\n                    _certificateHash,\n                    _signer\n                );\n            }\n        }\n\n        /// @notice check whether the certificate is freshly being registered.\n        ///   For new certificates, directly proceed with adding it.\n        ///   For existing certificates only update the signers if there are any new.\n        if (certificates[_certificateHash].signers.length > 0) {\n            require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n            certificates[_certificateHash].signers = _updatedSigners;\n        } else {\n            certificates[_certificateHash] = _certificateObj;\n        }\n\n        return _certificateHash;\n    ","after":" function registerCertificate(\n        bytes calldata _signedCertificate\n    ) public returns (\n        bytes32\n    ) {\n        (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n        /// @notice Signers in this transaction\n        bytes memory _newSigners = _certificateObj.signers;\n\n        /// @notice If certificate already registered then signers can be updated.\n        ///   Initializing _updatedSigners with existing signers on blockchain if any.\n        ///   More signers would be appended to this in next 'for' loop.\n        bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n        /// @notice Check with every the new signer if it is not already included in storage.\n        ///   This is helpful when a same certificate is submitted again with more signatures,\n        ///   the contract will consider only new signers in that case.\n        for (uint256 i = 0; i < _newSigners.length; i += 20) {\n            address _signer;\n            assembly {\n                _signer := mload(add(_newSigners, add(0x14, i)))\n            }\n            if (_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n                _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n                emit Certified(\n                    _certificateHash,\n                    _signer\n                );\n            }\n        }\n\n        /// @notice check whether the certificate is freshly being registered.\n        ///   For new certificates, directly proceed with adding it.\n        ///   For existing certificates only update the signers if there are any new.\n        if (certificates[_certificateHash].signers.length > 0) {\n            require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n            certificates[_certificateHash].signers = _updatedSigners;\n        } else {\n            certificates[_certificateHash] = _certificateObj;\n        }\n\n        return _certificateHash;\n    ","contract":"CertiDApp","time":0},{"type":"immutable-restrict-modification ","before":"  address public manage","after":"  address public manage","contract":"Proxy","time":0}]}