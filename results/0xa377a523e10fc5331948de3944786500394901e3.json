{"time":973,"results":[{"type":"external-function ","before":"function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }","after":"function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"Configuration","time":0},{"type":"loop-duplication","before":"\nstart line 2673 column 8, end line 2674 column 103\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\nstart line 2678 column 8, end line 2679 column 107\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = i + 1;","after":"// merge loop\n\nstart line 2673 column 8, end line 2674 column 103\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\nstart line 2678 column 8, end line 2679 column 107\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = i + 1;","contract":"NonFungibleBalanceLib","time":0},{"type":"external-function ","before":"function setIds(address wallet, bytes32 _type, int256[] memory ids, address currencyCt, uint256 currencyId)\n    public\n    onlyActiveService\n    {\n        // Update the balance\n        walletMap[wallet].nonFungibleBalanceByType[_type].set(\n            ids, currencyCt, currencyId\n        );\n\n        // Update balance type hashes\n        _updateTrackedBalanceTypes(_type);\n\n        // Update tracked wallets\n        _updateTrackedWallets(wallet);\n    }","after":"function setIds(address wallet, bytes32 _type, int256[] calldata ids, address currencyCt, uint256 currencyId)\n    public\n    onlyActiveService\n    {\n        // Update the balance\n        walletMap[wallet].nonFungibleBalanceByType[_type].set(\n            ids, currencyCt, currencyId\n        );\n\n        // Update balance type hashes\n        _updateTrackedBalanceTypes(_type);\n\n        // Update tracked wallets\n        _updateTrackedWallets(wallet);\n    }","contract":"BalanceTracker","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"BalanceTracker","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"BalanceTracker","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"BalanceTracker","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public depositedBalanceType;","after":"bytes32 public immutable depositedBalanceType;","contract":"BalanceTracker","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 public settledBalanceType;","after":"bytes32 public immutable settledBalanceType;","contract":"BalanceTracker","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 public stagedBalanceType;","after":"bytes32 public immutable stagedBalanceType;","contract":"BalanceTracker","time":1},{"type":"external-function ","before":"function lockNonFungibleByProxy(address lockedWallet, address lockerWallet, int256[] memory ids,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n        // Require that locked and locker wallets are not identical\n        require(lockedWallet != lockerWallet);\n\n        // Get index of lock\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n        // Require that there is no existing conflicting lock\n        require(\n            (0 == lockIndex) ||\n            (block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n        );\n\n        // Add lock object for this triplet of locked wallet, currency and locker wallet if it does not exist\n        if (0 == lockIndex) {\n            lockIndex = ++(walletNonFungibleLocks[lockedWallet].length);\n            lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\n            walletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n        }\n\n        // Update lock parameters\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids = ids;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\n        block.timestamp.add(visibleTimeoutInSeconds);\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\n        block.timestamp.add(configuration.walletLockTimeout());\n\n        // Emit event\n        emit LockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId, visibleTimeoutInSeconds);\n    }","after":"function lockNonFungibleByProxy(address lockedWallet, address lockerWallet, int256[] calldata ids,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n        // Require that locked and locker wallets are not identical\n        require(lockedWallet != lockerWallet);\n\n        // Get index of lock\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n        // Require that there is no existing conflicting lock\n        require(\n            (0 == lockIndex) ||\n            (block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n        );\n\n        // Add lock object for this triplet of locked wallet, currency and locker wallet if it does not exist\n        if (0 == lockIndex) {\n            lockIndex = ++(walletNonFungibleLocks[lockedWallet].length);\n            lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\n            walletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n        }\n\n        // Update lock parameters\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids = ids;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\n        block.timestamp.add(visibleTimeoutInSeconds);\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\n        block.timestamp.add(configuration.walletLockTimeout());\n\n        // Emit event\n        emit LockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId, visibleTimeoutInSeconds);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function authorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        // Ensure service action is registered\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        // Ensure service is not initial\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Enable service action for given wallet\n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n        // Emit event\n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","after":"function authorizeRegisteredServiceAction(address service, string calldata action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        // Ensure service action is registered\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        // Ensure service is not initial\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Enable service action for given wallet\n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n        // Emit event\n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function unauthorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        // Ensure service is registered and action enabled\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        // Ensure service is not initial as it can not be unauthorized per action\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Disable service action for given wallet\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n        // Emit event\n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","after":"function unauthorizeRegisteredServiceAction(address service, string calldata action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n        // Ensure service is registered and action enabled\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        // Ensure service is not initial as it can not be unauthorized per action\n        require(!initialServiceAuthorizedMap[service]);\n\n        // Disable service action for given wallet\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n        // Emit event\n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function isAuthorizedRegisteredServiceAction(address service, string memory action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }","after":"function isAuthorizedRegisteredServiceAction(address service, string calldata action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function hashPaymentAsWallet(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 amountCurrencyHash = hashPaymentAmountCurrency(payment);\n        bytes32 senderHash = hashPaymentSenderPartyAsWallet(payment.sender);\n        bytes32 recipientHash = hashAddress(payment.recipient.wallet);\n\n        return keccak256(abi.encodePacked(amountCurrencyHash, senderHash, recipientHash));\n    }","after":"function hashPaymentAsWallet(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 amountCurrencyHash = hashPaymentAmountCurrency(payment);\n        bytes32 senderHash = hashPaymentSenderPartyAsWallet(payment.sender);\n        bytes32 recipientHash = hashAddress(payment.recipient.wallet);\n\n        return keccak256(abi.encodePacked(amountCurrencyHash, senderHash, recipientHash));\n    }","contract":"PaymentHasher","time":0},{"type":"external-function ","before":"function hashPaymentAsOperator(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 walletSignatureHash = hashSignature(payment.seals.wallet.signature);\n        bytes32 senderHash = hashPaymentSenderPartyAsOperator(payment.sender);\n        bytes32 recipientHash = hashPaymentRecipientPartyAsOperator(payment.recipient);\n        bytes32 transfersHash = hashSingleTotalInt256(payment.transfers);\n        bytes32 operatorHash = hashString(payment.operator.data);\n\n        return keccak256(abi.encodePacked(\n                walletSignatureHash, senderHash, recipientHash, transfersHash, operatorHash\n            ));\n    }","after":"function hashPaymentAsOperator(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 walletSignatureHash = hashSignature(payment.seals.wallet.signature);\n        bytes32 senderHash = hashPaymentSenderPartyAsOperator(payment.sender);\n        bytes32 recipientHash = hashPaymentRecipientPartyAsOperator(payment.recipient);\n        bytes32 transfersHash = hashSingleTotalInt256(payment.transfers);\n        bytes32 operatorHash = hashString(payment.operator.data);\n\n        return keccak256(abi.encodePacked(\n                walletSignatureHash, senderHash, recipientHash, transfersHash, operatorHash\n            ));\n    }","contract":"PaymentHasher","time":1},{"type":"external-function ","before":"function isGenuinePaymentSeals(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentWalletSeal(payment) && isGenuinePaymentOperatorSeal(payment);\n    }","after":"function isGenuinePaymentSeals(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentWalletSeal(payment) && isGenuinePaymentOperatorSeal(payment);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentFeeOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        int256 feePartsPer = int256(ConstantsLib.PARTS_PER());\n\n        int256 feeAmount = payment.amount\n        .mul(\n            configuration.currencyPaymentFee(\n                payment.blockNumber, payment.currency.ct, payment.currency.id, payment.amount\n            )\n        ).div(feePartsPer);\n\n        if (1 > feeAmount)\n            feeAmount = 1;\n\n        return (payment.sender.fees.single.amount == feeAmount);\n    }","after":"function isGenuinePaymentFeeOfFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        int256 feePartsPer = int256(ConstantsLib.PARTS_PER());\n\n        int256 feeAmount = payment.amount\n        .mul(\n            configuration.currencyPaymentFee(\n                payment.blockNumber, payment.currency.ct, payment.currency.id, payment.amount\n            )\n        ).div(feePartsPer);\n\n        if (1 > feeAmount)\n            feeAmount = 1;\n\n        return (payment.sender.fees.single.amount == feeAmount);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentFeeOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        (address feeCurrencyCt, uint256 feeCurrencyId) = configuration.feeCurrency(\n            payment.blockNumber, payment.currency.ct, payment.currency.id\n        );\n\n        return feeCurrencyCt == payment.sender.fees.single.currency.ct\n        && feeCurrencyId == payment.sender.fees.single.currency.id;\n    }","after":"function isGenuinePaymentFeeOfNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        (address feeCurrencyCt, uint256 feeCurrencyId) = configuration.feeCurrency(\n            payment.blockNumber, payment.currency.ct, payment.currency.id\n        );\n\n        return feeCurrencyCt == payment.sender.fees.single.currency.ct\n        && feeCurrencyId == payment.sender.fees.single.currency.id;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentSenderOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet))\n        && (payment.sender.balances.current == payment.sender.balances.previous.sub(payment.transfers.single).sub(payment.sender.fees.single.amount));\n    }","after":"function isGenuinePaymentSenderOfFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet))\n        && (payment.sender.balances.current == payment.sender.balances.previous.sub(payment.transfers.single).sub(payment.sender.fees.single.amount));\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentRecipientOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (payment.recipient.balances.current == payment.recipient.balances.previous.add(payment.transfers.single));\n    }","after":"function isGenuinePaymentRecipientOfFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (payment.recipient.balances.current == payment.recipient.balances.previous.add(payment.transfers.single));\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentSenderOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet));\n    }","after":"function isGenuinePaymentSenderOfNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet));\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentRecipientOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet);\n    }","after":"function isGenuinePaymentRecipientOfNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isSuccessivePaymentsPartyNonces(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment memory lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole\n    )\n    public\n    pure\n    returns (bool)\n    {\n        uint256 firstNonce = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.nonce : firstPayment.recipient.nonce);\n        uint256 lastNonce = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.nonce : lastPayment.recipient.nonce);\n        return lastNonce == firstNonce.add(1);\n    }","after":"function isSuccessivePaymentsPartyNonces(\n        PaymentTypesLib.Payment calldata firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment calldata lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole\n    )\n    public\n    pure\n    returns (bool)\n    {\n        uint256 firstNonce = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.nonce : firstPayment.recipient.nonce);\n        uint256 lastNonce = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.nonce : lastPayment.recipient.nonce);\n        return lastNonce == firstNonce.add(1);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuineSuccessivePaymentsBalances(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment memory lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole,\n        int256 delta\n    )\n    public\n    pure\n    returns (bool)\n    {\n        NahmiiTypesLib.CurrentPreviousInt256 memory firstCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.balances : firstPayment.recipient.balances);\n        NahmiiTypesLib.CurrentPreviousInt256 memory lastCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.balances : lastPayment.recipient.balances);\n\n        return lastCurrentPreviousBalances.previous == firstCurrentPreviousBalances.current.add(delta);\n    }","after":"function isGenuineSuccessivePaymentsBalances(\n        PaymentTypesLib.Payment calldata firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment calldata lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole,\n        int256 delta\n    )\n    public\n    pure\n    returns (bool)\n    {\n        NahmiiTypesLib.CurrentPreviousInt256 memory firstCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.balances : firstPayment.recipient.balances);\n        NahmiiTypesLib.CurrentPreviousInt256 memory lastCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.balances : lastPayment.recipient.balances);\n\n        return lastCurrentPreviousBalances.previous == firstCurrentPreviousBalances.current.add(delta);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuineSuccessivePaymentsTotalFees(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.Payment memory lastPayment\n    )\n    public\n    pure\n    returns (bool)\n    {\n        MonetaryTypesLib.Figure memory firstTotalFee = getProtocolFigureByCurrency(firstPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        MonetaryTypesLib.Figure memory lastTotalFee = getProtocolFigureByCurrency(lastPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        return lastTotalFee.amount == firstTotalFee.amount.add(lastPayment.sender.fees.single.amount);\n    }","after":"function isGenuineSuccessivePaymentsTotalFees(\n        PaymentTypesLib.Payment calldata firstPayment,\n        PaymentTypesLib.Payment calldata lastPayment\n    )\n    public\n    pure\n    returns (bool)\n    {\n        MonetaryTypesLib.Figure memory firstTotalFee = getProtocolFigureByCurrency(firstPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        MonetaryTypesLib.Figure memory lastTotalFee = getProtocolFigureByCurrency(lastPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        return lastTotalFee.amount == firstTotalFee.amount.add(lastPayment.sender.fees.single.amount);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentParty(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet || wallet == payment.recipient.wallet;\n    }","after":"function isPaymentParty(PaymentTypesLib.Payment calldata payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet || wallet == payment.recipient.wallet;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentSender(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet;\n    }","after":"function isPaymentSender(PaymentTypesLib.Payment calldata payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentRecipient(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.recipient.wallet;\n    }","after":"function isPaymentRecipient(PaymentTypesLib.Payment calldata payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.recipient.wallet;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentCurrency(PaymentTypesLib.Payment memory payment, MonetaryTypesLib.Currency memory currency)\n    public\n    pure\n    returns (bool)\n    {\n        return currency.ct == payment.currency.ct && currency.id == payment.currency.id;\n    }","after":"function isPaymentCurrency(PaymentTypesLib.Payment calldata payment, MonetaryTypesLib.Currency calldata currency)\n    public\n    pure\n    returns (bool)\n    {\n        return currency.ct == payment.currency.ct && currency.id == payment.currency.id;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentCurrencyNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return payment.currency.ct != payment.sender.fees.single.currency.ct\n        || payment.currency.id != payment.sender.fees.single.currency.id;\n    }","after":"function isPaymentCurrencyNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bool)\n    {\n        return payment.currency.ct != payment.sender.fees.single.currency.ct\n        || payment.currency.id != payment.sender.fees.single.currency.id;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function transferController(address currencyCt, string memory standard)\npublic\nview\nreturns (TransferController)\n{\nif (bytes(standard).length > 0) {\nbytes32 standardHash = keccak256(abi.encodePacked(standard));\n\nrequire(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\nreturn TransferController(registeredTransferControllers[standardHash]);\n}\n\nrequire(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\nrequire(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\naddress controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\nrequire(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\nreturn TransferController(controllerAddress);\n}","after":"function transferController(address currencyCt, string calldata standard)\npublic\nview\nreturns (TransferController)\n{\nif (bytes(standard).length > 0) {\nbytes32 standardHash = keccak256(abi.encodePacked(standard));\n\nrequire(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\nreturn TransferController(registeredTransferControllers[standardHash]);\n}\n\nrequire(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\nrequire(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\naddress controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\nrequire(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\nreturn TransferController(controllerAddress);\n}","contract":"TransferControllerManager","time":0},{"type":"external-function ","before":"function receiveTokens(string memory, int256 amount, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\nreceiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n}","after":"function receiveTokens(string calldata, int256 amount, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\nreceiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n}","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function claimAndTransferToBeneficiary(Beneficiary beneficiary, string memory balanceType, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\n// Claim reward\nint256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n// Subtract from deposited balance\ndeposited.sub(claimedAmount, currencyCt, currencyId);\n\n// Execute transfer\nif (address(0) == currencyCt && 0 == currencyId)\nbeneficiary.receiveEthersTo.value(uint256(claimedAmount))(msg.sender, balanceType);\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\n)\n);\nrequire(success, \"Approval by controller failed [SecurityBond.sol:350]\");\nbeneficiary.receiveTokensTo(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}\n\n// Emit event\nemit ClaimAndTransferToBeneficiaryEvent(msg.sender, beneficiary, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}","after":"function claimAndTransferToBeneficiary(Beneficiary beneficiary, string calldata balanceType, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\n// Claim reward\nint256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n// Subtract from deposited balance\ndeposited.sub(claimedAmount, currencyCt, currencyId);\n\n// Execute transfer\nif (address(0) == currencyCt && 0 == currencyId)\nbeneficiary.receiveEthersTo.value(uint256(claimedAmount))(msg.sender, balanceType);\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\n)\n);\nrequire(success, \"Approval by controller failed [SecurityBond.sol:350]\");\nbeneficiary.receiveTokensTo(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}\n\n// Emit event\nemit ClaimAndTransferToBeneficiaryEvent(msg.sender, beneficiary, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\n// Require that amount is strictly positive\nrequire(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [SecurityBond.sol:386]\");\n\n// Clamp amount to the max given by staged balance\namount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n// Subtract to per-wallet staged balance\nstagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n// Execute transfer\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Dispatch by controller failed [SecurityBond.sol:405]\");\n}\n\n// Emit event\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n}","after":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\n// Require that amount is strictly positive\nrequire(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [SecurityBond.sol:386]\");\n\n// Clamp amount to the max given by staged balance\namount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n// Subtract to per-wallet staged balance\nstagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n// Execute transfer\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Dispatch by controller failed [SecurityBond.sol:405]\");\n}\n\n// Emit event\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n}","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"SecurityBond","time":1},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"FraudChallenge","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"FraudChallenge","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"FraudChallenge","time":0},{"type":"struct-data-arrangement ","before":"\naddress wallet\nuint256 nonce\nuint256 referenceBlockNumber\nuint256 definitionBlockNumber\nuint256 expirationTime\nStatus status\nAmounts amounts\nMonetaryTypesLib.Currency currency\nDriip challenged\nbool walletInitiated\nbool terminated\nDisqualification disqualification","after":"uint256 nonce\nuint256 referenceBlockNumber\nuint256 definitionBlockNumber\nuint256 expirationTime\nStatus status\nAmounts amounts\nMonetaryTypesLib.Currency currency\nDriip challenged\nDisqualification disqualification\naddress wallet\nbool walletInitiated\nbool terminated\n","contract":"SettlementChallengeTypesLib","time":0},{"type":"external-function ","before":"function initiateProposal(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\nMonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated)\npublic\nonlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n{\n// Initiate proposal\n_initiateProposal(\nwallet, nonce, stageAmount, targetBalanceAmount,\ncurrency, blockNumber, walletInitiated\n);\n\n// Emit event\nemit InitiateProposalEvent(\nwallet, nonce, stageAmount, targetBalanceAmount, currency,\nblockNumber, walletInitiated\n);\n}","after":"function initiateProposal(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\nMonetaryTypesLib.Currency calldata currency, uint256 blockNumber, bool walletInitiated)\npublic\nonlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n{\n// Initiate proposal\n_initiateProposal(\nwallet, nonce, stageAmount, targetBalanceAmount,\ncurrency, blockNumber, walletInitiated\n);\n\n// Emit event\nemit InitiateProposalEvent(\nwallet, nonce, stageAmount, targetBalanceAmount, currency,\nblockNumber, walletInitiated\n);\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n}","after":"function terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:143]\");\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n}","after":"function terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:143]\");\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n\n// Remove proposal\n_removeProposal(index);\n}","after":"function removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n\n// Remove proposal\n_removeProposal(index);\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:197]\");\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n\n// Remove proposal\n_removeProposal(index);\n}","after":"function removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:197]\");\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n\n// Remove proposal\n_removeProposal(index);\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\nuint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\npublic\nonlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\nrequire(0 != index, \"No settlement found for wallet and currency [NullSettlementChallengeState.sol:226]\");\n\n// Update proposal\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\nproposals[index - 1].disqualification.challenger = challengerWallet;\nproposals[index - 1].disqualification.nonce = candidateNonce;\nproposals[index - 1].disqualification.blockNumber = blockNumber;\nproposals[index - 1].disqualification.candidate.hash = candidateHash;\nproposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n// Emit event\nemit DisqualifyProposalEvent(\nchallengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency, proposals[index - 1].referenceBlockNumber,\nproposals[index - 1].walletInitiated, challengerWallet, candidateNonce, candidateHash, candidateKind\n);\n}","after":"function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency calldata currency, address challengerWallet,\nuint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string calldata candidateKind)\npublic\nonlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\nrequire(0 != index, \"No settlement found for wallet and currency [NullSettlementChallengeState.sol:226]\");\n\n// Update proposal\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\nproposals[index - 1].disqualification.challenger = challengerWallet;\nproposals[index - 1].disqualification.nonce = candidateNonce;\nproposals[index - 1].disqualification.blockNumber = blockNumber;\nproposals[index - 1].disqualification.candidate.hash = candidateHash;\nproposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n// Emit event\nemit DisqualifyProposalEvent(\nchallengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency, proposals[index - 1].referenceBlockNumber,\nproposals[index - 1].walletInitiated, challengerWallet, candidateNonce, candidateHash, candidateKind\n);\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nreturn 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n}","after":"function hasProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nreturn 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:269]\");\nreturn proposals[index - 1].terminated;\n}","after":"function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:269]\");\nreturn proposals[index - 1].terminated;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:284]\");\nreturn block.timestamp >= proposals[index - 1].expirationTime;\n}","after":"function hasProposalExpired(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:284]\");\nreturn block.timestamp >= proposals[index - 1].expirationTime;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:298]\");\nreturn proposals[index - 1].nonce;\n}","after":"function proposalNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:298]\");\nreturn proposals[index - 1].nonce;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:312]\");\nreturn proposals[index - 1].referenceBlockNumber;\n}","after":"function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:312]\");\nreturn proposals[index - 1].referenceBlockNumber;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:326]\");\nreturn proposals[index - 1].definitionBlockNumber;\n}","after":"function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:326]\");\nreturn proposals[index - 1].definitionBlockNumber;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:340]\");\nreturn proposals[index - 1].expirationTime;\n}","after":"function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:340]\");\nreturn proposals[index - 1].expirationTime;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (SettlementChallengeTypesLib.Status)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:354]\");\nreturn proposals[index - 1].status;\n}","after":"function proposalStatus(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (SettlementChallengeTypesLib.Status)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:354]\");\nreturn proposals[index - 1].status;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:368]\");\nreturn proposals[index - 1].amounts.stage;\n}","after":"function proposalStageAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:368]\");\nreturn proposals[index - 1].amounts.stage;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:382]\");\nreturn proposals[index - 1].amounts.targetBalance;\n}","after":"function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:382]\");\nreturn proposals[index - 1].amounts.targetBalance;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:396]\");\nreturn proposals[index - 1].walletInitiated;\n}","after":"function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:396]\");\nreturn proposals[index - 1].walletInitiated;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (address)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:410]\");\nreturn proposals[index - 1].disqualification.challenger;\n}","after":"function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (address)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:410]\");\nreturn proposals[index - 1].disqualification.challenger;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:424]\");\nreturn proposals[index - 1].disqualification.blockNumber;\n}","after":"function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:424]\");\nreturn proposals[index - 1].disqualification.blockNumber;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:438]\");\nreturn proposals[index - 1].disqualification.nonce;\n}","after":"function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:438]\");\nreturn proposals[index - 1].disqualification.nonce;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:452]\");\nreturn proposals[index - 1].disqualification.candidate.hash;\n}","after":"function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:452]\");\nreturn proposals[index - 1].disqualification.candidate.hash;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:466]\");\nreturn proposals[index - 1].disqualification.candidate.kind;\n}","after":"function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:466]\");\nreturn proposals[index - 1].disqualification.candidate.kind;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function challengeByPayment(address wallet, PaymentTypesLib.Payment memory payment, address challenger)\npublic\nonlyEnabledServiceAction(CHALLENGE_BY_PAYMENT_ACTION)\nonlySealedPayment(payment)\nonlyPaymentSender(payment, wallet)\n{\n// Require that payment candidate is not labelled fraudulent\nrequire(!fraudChallenge.isFraudulentPaymentHash(payment.seals.operator.hash), \"Payment deemed fraudulent [NullSettlementDisputeByPayment.sol:86]\");\n\n// Require that proposal has been initiated\nrequire(nullSettlementChallengeState.hasProposal(wallet, payment.currency), \"No proposal found [NullSettlementDisputeByPayment.sol:89]\");\n\n// Require that proposal has not expired\nrequire(!nullSettlementChallengeState.hasProposalExpired(wallet, payment.currency), \"Proposal found expired [NullSettlementDisputeByPayment.sol:92]\");\n\n// Require that payment party's nonce is strictly greater than proposal's nonce and its current\n// disqualification nonce\nrequire(payment.sender.nonce > nullSettlementChallengeState.proposalNonce(\nwallet, payment.currency\n), \"Payment nonce not strictly greater than proposal nonce [NullSettlementDisputeByPayment.sol:96]\");\nrequire(payment.sender.nonce > nullSettlementChallengeState.proposalDisqualificationNonce(\nwallet, payment.currency\n), \"Payment nonce not strictly greater than proposal disqualification nonce [NullSettlementDisputeByPayment.sol:99]\");\n\n// Require overrun for this payment to be a valid challenge candidate\nrequire(_overrun(wallet, payment), \"No overrun found [NullSettlementDisputeByPayment.sol:104]\");\n\n// Reward challenger\n_settleRewards(wallet, payment.sender.balances.current, payment.currency, challenger);\n\n// Disqualify proposal, effectively overriding any previous disqualification\nnullSettlementChallengeState.disqualifyProposal(\nwallet, payment.currency, challenger, payment.blockNumber,\npayment.sender.nonce, payment.seals.operator.hash, PaymentTypesLib.PAYMENT_KIND()\n);\n\n// Emit event\nemit ChallengeByPaymentEvent(\nwallet, nullSettlementChallengeState.proposalNonce(wallet, payment.currency), payment, challenger\n);\n}","after":"function challengeByPayment(address wallet, PaymentTypesLib.Payment calldata payment, address challenger)\npublic\nonlyEnabledServiceAction(CHALLENGE_BY_PAYMENT_ACTION)\nonlySealedPayment(payment)\nonlyPaymentSender(payment, wallet)\n{\n// Require that payment candidate is not labelled fraudulent\nrequire(!fraudChallenge.isFraudulentPaymentHash(payment.seals.operator.hash), \"Payment deemed fraudulent [NullSettlementDisputeByPayment.sol:86]\");\n\n// Require that proposal has been initiated\nrequire(nullSettlementChallengeState.hasProposal(wallet, payment.currency), \"No proposal found [NullSettlementDisputeByPayment.sol:89]\");\n\n// Require that proposal has not expired\nrequire(!nullSettlementChallengeState.hasProposalExpired(wallet, payment.currency), \"Proposal found expired [NullSettlementDisputeByPayment.sol:92]\");\n\n// Require that payment party's nonce is strictly greater than proposal's nonce and its current\n// disqualification nonce\nrequire(payment.sender.nonce > nullSettlementChallengeState.proposalNonce(\nwallet, payment.currency\n), \"Payment nonce not strictly greater than proposal nonce [NullSettlementDisputeByPayment.sol:96]\");\nrequire(payment.sender.nonce > nullSettlementChallengeState.proposalDisqualificationNonce(\nwallet, payment.currency\n), \"Payment nonce not strictly greater than proposal disqualification nonce [NullSettlementDisputeByPayment.sol:99]\");\n\n// Require overrun for this payment to be a valid challenge candidate\nrequire(_overrun(wallet, payment), \"No overrun found [NullSettlementDisputeByPayment.sol:104]\");\n\n// Reward challenger\n_settleRewards(wallet, payment.sender.balances.current, payment.currency, challenger);\n\n// Disqualify proposal, effectively overriding any previous disqualification\nnullSettlementChallengeState.disqualifyProposal(\nwallet, payment.currency, challenger, payment.blockNumber,\npayment.sender.nonce, payment.seals.operator.hash, PaymentTypesLib.PAYMENT_KIND()\n);\n\n// Emit event\nemit ChallengeByPaymentEvent(\nwallet, nullSettlementChallengeState.proposalNonce(wallet, payment.currency), payment, challenger\n);\n}","contract":"NullSettlementDisputeByPayment","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"NullSettlementDisputeByPayment","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"NullSettlementDisputeByPayment","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"NullSettlementDisputeByPayment","time":0},{"type":"external-function ","before":"function initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\nint256 targetBalanceAmount, MonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated,\nbytes32 challengedHash, string memory challengedKind)\npublic\nonlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n{\n// Initiate proposal\n_initiateProposal(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\ncurrency, blockNumber, walletInitiated, challengedHash, challengedKind\n);\n\n// Emit event\nemit InitiateProposalEvent(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\nblockNumber, walletInitiated, challengedHash, challengedKind\n);\n}","after":"function initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\nint256 targetBalanceAmount, MonetaryTypesLib.Currency calldata currency, uint256 blockNumber, bool walletInitiated,\nbytes32 challengedHash, string calldata challengedKind)\npublic\nonlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n{\n// Initiate proposal\n_initiateProposal(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\ncurrency, blockNumber, walletInitiated, challengedHash, challengedKind\n);\n\n// Emit event\nemit InitiateProposalEvent(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\nblockNumber, walletInitiated, challengedHash, challengedKind\n);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Clear wallet-nonce-currency triplet entry, which enables reinitiation of proposal for that triplet\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n}","after":"function terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool clearNonce)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Clear wallet-nonce-currency triplet entry, which enables reinitiation of proposal for that triplet\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce,\nbool walletTerminated)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:163]\");\n\n// Clear wallet-nonce-currency triplet entry, which enables reinitiation of proposal for that triplet\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n}","after":"function terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool clearNonce,\nbool walletTerminated)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to terminate\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:163]\");\n\n// Clear wallet-nonce-currency triplet entry, which enables reinitiation of proposal for that triplet\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n// Terminate proposal\nproposals[index - 1].terminated = true;\n\n// Emit event\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n// Remove proposal\n_removeProposal(index);\n}","after":"function removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n// Remove proposal\n_removeProposal(index);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:223]\");\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n// Remove proposal\n_removeProposal(index);\n}","after":"function removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n// Return gracefully if there is no proposal to remove\nif (0 == index)\nreturn;\n\n// Require that role that initialized (wallet or operator) can only cancel its own proposal\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:223]\");\n\n// Emit event\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n// Remove proposal\n_removeProposal(index);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\nuint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\npublic\nonlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:253]\");\n\n// Update proposal\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\nproposals[index - 1].disqualification.challenger = challengerWallet;\nproposals[index - 1].disqualification.nonce = candidateNonce;\nproposals[index - 1].disqualification.blockNumber = blockNumber;\nproposals[index - 1].disqualification.candidate.hash = candidateHash;\nproposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n// Emit event\nemit DisqualifyProposalEvent(\nchallengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\ncurrency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nchallengerWallet, candidateNonce, candidateHash, candidateKind\n);\n}","after":"function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency calldata currency, address challengerWallet,\nuint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string calldata candidateKind)\npublic\nonlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:253]\");\n\n// Update proposal\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\nproposals[index - 1].disqualification.challenger = challengerWallet;\nproposals[index - 1].disqualification.nonce = candidateNonce;\nproposals[index - 1].disqualification.blockNumber = blockNumber;\nproposals[index - 1].disqualification.candidate.hash = candidateHash;\nproposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n// Emit event\nemit DisqualifyProposalEvent(\nchallengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\ncurrency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nchallengerWallet, candidateNonce, candidateHash, candidateKind\n);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function qualifyProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nonlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:282]\");\n\n// Emit event\nemit QualifyProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].disqualification.challenger,\nproposals[index - 1].disqualification.nonce,\nproposals[index - 1].disqualification.candidate.hash,\nproposals[index - 1].disqualification.candidate.kind\n);\n\n// Update proposal\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\ndelete proposals[index - 1].disqualification;\n}","after":"function qualifyProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nonlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\n{\n// Get the proposal index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:282]\");\n\n// Emit event\nemit QualifyProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].disqualification.challenger,\nproposals[index - 1].disqualification.nonce,\nproposals[index - 1].disqualification.candidate.hash,\nproposals[index - 1].disqualification.candidate.kind\n);\n\n// Update proposal\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\ndelete proposals[index - 1].disqualification;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nreturn 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];\n}","after":"function hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nreturn 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nreturn 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n}","after":"function hasProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nreturn 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:340]\");\nreturn proposals[index - 1].terminated;\n}","after":"function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:340]\");\nreturn proposals[index - 1].terminated;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:355]\");\nreturn block.timestamp >= proposals[index - 1].expirationTime;\n}","after":"function hasProposalExpired(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n// 1-based index\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:355]\");\nreturn block.timestamp >= proposals[index - 1].expirationTime;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:369]\");\nreturn proposals[index - 1].nonce;\n}","after":"function proposalNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:369]\");\nreturn proposals[index - 1].nonce;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:383]\");\nreturn proposals[index - 1].referenceBlockNumber;\n}","after":"function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:383]\");\nreturn proposals[index - 1].referenceBlockNumber;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:397]\");\nreturn proposals[index - 1].definitionBlockNumber;\n}","after":"function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:397]\");\nreturn proposals[index - 1].definitionBlockNumber;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:411]\");\nreturn proposals[index - 1].expirationTime;\n}","after":"function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:411]\");\nreturn proposals[index - 1].expirationTime;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (SettlementChallengeTypesLib.Status)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:425]\");\nreturn proposals[index - 1].status;\n}","after":"function proposalStatus(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (SettlementChallengeTypesLib.Status)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:425]\");\nreturn proposals[index - 1].status;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:439]\");\nreturn proposals[index - 1].amounts.cumulativeTransfer;\n}","after":"function proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:439]\");\nreturn proposals[index - 1].amounts.cumulativeTransfer;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:453]\");\nreturn proposals[index - 1].amounts.stage;\n}","after":"function proposalStageAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:453]\");\nreturn proposals[index - 1].amounts.stage;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:467]\");\nreturn proposals[index - 1].amounts.targetBalance;\n}","after":"function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:467]\");\nreturn proposals[index - 1].amounts.targetBalance;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalChallengedHash(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:481]\");\nreturn proposals[index - 1].challenged.hash;\n}","after":"function proposalChallengedHash(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:481]\");\nreturn proposals[index - 1].challenged.hash;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalChallengedKind(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:495]\");\nreturn proposals[index - 1].challenged.kind;\n}","after":"function proposalChallengedKind(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:495]\");\nreturn proposals[index - 1].challenged.kind;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:509]\");\nreturn proposals[index - 1].walletInitiated;\n}","after":"function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:509]\");\nreturn proposals[index - 1].walletInitiated;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (address)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:523]\");\nreturn proposals[index - 1].disqualification.challenger;\n}","after":"function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (address)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:523]\");\nreturn proposals[index - 1].disqualification.challenger;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:537]\");\nreturn proposals[index - 1].disqualification.nonce;\n}","after":"function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:537]\");\nreturn proposals[index - 1].disqualification.nonce;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:551]\");\nreturn proposals[index - 1].disqualification.blockNumber;\n}","after":"function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:551]\");\nreturn proposals[index - 1].disqualification.blockNumber;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:565]\");\nreturn proposals[index - 1].disqualification.candidate.hash;\n}","after":"function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:565]\");\nreturn proposals[index - 1].disqualification.candidate.hash;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:579]\");\nreturn proposals[index - 1].disqualification.candidate.kind;\n}","after":"function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:579]\");\nreturn proposals[index - 1].disqualification.candidate.kind;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function challengeByPayment(address wallet, PaymentTypesLib.Payment memory payment)\npublic\nonlyOperationalModeNormal\n{\n// Challenge by payment\nnullSettlementDisputeByPayment.challengeByPayment(wallet, payment, msg.sender);\n\n// Emit event\nemit ChallengeByPaymentEvent(\nwallet,\nnullSettlementChallengeState.proposalNonce(wallet, payment.currency),\nnullSettlementChallengeState.proposalStageAmount(wallet, payment.currency),\nnullSettlementChallengeState.proposalTargetBalanceAmount(wallet, payment.currency),\npayment.currency.ct, payment.currency.id, msg.sender\n);\n}","after":"function challengeByPayment(address wallet, PaymentTypesLib.Payment calldata payment)\npublic\nonlyOperationalModeNormal\n{\n// Challenge by payment\nnullSettlementDisputeByPayment.challengeByPayment(wallet, payment, msg.sender);\n\n// Emit event\nemit ChallengeByPaymentEvent(\nwallet,\nnullSettlementChallengeState.proposalNonce(wallet, payment.currency),\nnullSettlementChallengeState.proposalStageAmount(wallet, payment.currency),\nnullSettlementChallengeState.proposalTargetBalanceAmount(wallet, payment.currency),\npayment.currency.ct, payment.currency.id, msg.sender\n);\n}","contract":"NullSettlementChallengeByPayment","time":0}]}