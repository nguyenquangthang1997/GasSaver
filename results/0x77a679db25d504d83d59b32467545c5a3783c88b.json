{"time":616,"results":[{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping(address => EnumerableSet.UintSet) private _holderTokens;\nEnumerableMap.UintToAddressMap private _tokenOwners;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nstring private _name;\nstring private _symbol;\nmapping(uint256 => string) private _tokenURIs;\nstring private _baseURI;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\nbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;","after":"mapping(address => EnumerableSet.UintSet) private _holderTokens;\nEnumerableMap.UintToAddressMap private _tokenOwners;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nstring private _name;\nstring private _symbol;\nmapping(uint256 => string) private _tokenURIs;\nstring private _baseURI;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\nbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n","contract":"ERC721","time":0},{"type":"state-data-arrangement ","before":"\nuint256 internal constant ALL_TOKEN_NUM = 10133;\nstring public constant SHA256 = \"253762fe521a835df8726d8c614f0f7bbb86e67690b422e0c3556d7b4d5e146d\";\nuint256 internal constant ALL_DRAW_NUM = 3;\nDraw[ALL_DRAW_NUM] internal allDraws;\nuint256 internal soldNumber;\nbool internal enabled = true;\nuint256 internal constant ALL_SLICE_NUM = 6;\nSlice[ALL_SLICE_NUM] internal slices;\nuint256 internal giftFund;\naddress internal giftFundAddress;","after":"uint256 internal constant ALL_TOKEN_NUM = 10133;\nstring public constant SHA256 = \"253762fe521a835df8726d8c614f0f7bbb86e67690b422e0c3556d7b4d5e146d\";\nuint256 internal constant ALL_DRAW_NUM = 3;\nDraw[ALL_DRAW_NUM] internal allDraws;\nuint256 internal soldNumber;\nuint256 internal constant ALL_SLICE_NUM = 6;\nSlice[ALL_SLICE_NUM] internal slices;\nuint256 internal giftFund;\naddress internal giftFundAddress;\nbool internal enabled = true;\n","contract":"Anon","time":0},{"type":"external-function ","before":"function draw(string memory uuid) public onlyWhenEnabled payable {\n\n        uint256 number;\n\n        for (uint256 i = 0; i < ALL_DRAW_NUM; i++) {\n\n            if (allDraws[i].price == msg.value) {\n\n                number = allDraws[i].number;\n\n                break;\n\n            }\n\n        }\n\n\n        require(\n\n            number > 0,\n\n            \"Invalid price, please pay either 0.1 ETH for 1 draw or 0.45 ETH for 5 draws or 0.8 ETH for 10 draws\"\n\n        );\n\n\n        uint256 newSoldNumber = soldNumber + number;\n\n\n        require(newSoldNumber <= ALL_TOKEN_NUM, \"Not enough supply\");\n\n\n        uint256[] memory tokens = new uint256[](number);\n\n\n        for (uint256 i = 0; i < number; i++) {\n\n            // tokenId is taken sequential\n\n            uint256 tokenId = soldNumber + i;\n\n            // mint the token immediately\n\n            _mint(msg.sender, tokenId);\n\n\n            tokens[i] = tokenId;\n\n        }\n\n\n        // update the sold number\n\n        soldNumber = newSoldNumber;\n\n\n        // Emit token drawn event\n\n        emit TokenDrawn(uuid, tokens);\n\n    }","after":"function draw(string calldata uuid) public onlyWhenEnabled payable {\n\n        uint256 number;\n\n        for (uint256 i = 0; i < ALL_DRAW_NUM; i++) {\n\n            if (allDraws[i].price == msg.value) {\n\n                number = allDraws[i].number;\n\n                break;\n\n            }\n\n        }\n\n\n        require(\n\n            number > 0,\n\n            \"Invalid price, please pay either 0.1 ETH for 1 draw or 0.45 ETH for 5 draws or 0.8 ETH for 10 draws\"\n\n        );\n\n\n        uint256 newSoldNumber = soldNumber + number;\n\n\n        require(newSoldNumber <= ALL_TOKEN_NUM, \"Not enough supply\");\n\n\n        uint256[] memory tokens = new uint256[](number);\n\n\n        for (uint256 i = 0; i < number; i++) {\n\n            // tokenId is taken sequential\n\n            uint256 tokenId = soldNumber + i;\n\n            // mint the token immediately\n\n            _mint(msg.sender, tokenId);\n\n\n            tokens[i] = tokenId;\n\n        }\n\n\n        // update the sold number\n\n        soldNumber = newSoldNumber;\n\n\n        // Emit token drawn event\n\n        emit TokenDrawn(uuid, tokens);\n\n    }","contract":"Anon","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseURI_) public onlyOwner {\n\n        _setBaseURI(baseURI_);\n\n    }","after":"function setBaseURI(string calldata baseURI_) public onlyOwner {\n\n        _setBaseURI(baseURI_);\n\n    }","contract":"Anon","time":0},{"type":"immutable-restrict-modification ","before":"address internal giftFundAddress;","after":"address internal immutable giftFundAddress;","contract":"Anon","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"Anon","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"Anon","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"DummyERC20","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"DummyERC20","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"DummyLINK","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"DummyLINK","time":0},{"type":"external-function ","before":"function onTokenTransfer(address sender, uint256 fee, bytes memory _data)\n\n    public\n\n    {\n\n        (bytes32 keyHash, uint256 seed) = abi.decode(_data, (bytes32, uint256));\n\n        emit RandomnessRequest(sender, keyHash, seed);\n\n    }","after":"function onTokenTransfer(address sender, uint256 fee, bytes calldata _data)\n\n    public\n\n    {\n\n        (bytes32 keyHash, uint256 seed) = abi.decode(_data, (bytes32, uint256));\n\n        emit RandomnessRequest(sender, keyHash, seed);\n\n    }","contract":"DummyVRF","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n\n        address userAddress,\n\n        bytes memory functionSignature,\n\n        bytes32 sigR,\n\n        bytes32 sigS,\n\n        uint8 sigV\n\n    ) public payable returns (bytes memory) {\n\n        MetaTransaction memory metaTx = MetaTransaction({\n\n        nonce : nonces[userAddress],\n\n        from : userAddress,\n\n        functionSignature : functionSignature\n\n        });\n\n        require(\n\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n\n            \"Signer and signature do not match\"\n\n        );\n\n\n        // increase nonce for user (to avoid re-use)\n\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n\n        emit MetaTransactionExecuted(\n\n            userAddress,\n\n            msg.sender,\n\n            functionSignature\n\n        );\n\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n\n        (bool success, bytes memory returnData) = address(this).call(\n\n            abi.encodePacked(functionSignature, userAddress)\n\n        );\n\n        require(success, \"Function call not successful\");\n\n\n        return returnData;\n\n    }","after":"function executeMetaTransaction(\n\n        address userAddress,\n\n        bytes calldata functionSignature,\n\n        bytes32 sigR,\n\n        bytes32 sigS,\n\n        uint8 sigV\n\n    ) public payable returns (bytes memory) {\n\n        MetaTransaction memory metaTx = MetaTransaction({\n\n        nonce : nonces[userAddress],\n\n        from : userAddress,\n\n        functionSignature : functionSignature\n\n        });\n\n        require(\n\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n\n            \"Signer and signature do not match\"\n\n        );\n\n\n        // increase nonce for user (to avoid re-use)\n\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n\n        emit MetaTransactionExecuted(\n\n            userAddress,\n\n            msg.sender,\n\n            functionSignature\n\n        );\n\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n\n        (bool success, bytes memory returnData) = address(this).call(\n\n            abi.encodePacked(functionSignature, userAddress)\n\n        );\n\n        require(success, \"Function call not successful\");\n\n\n        return returnData;\n\n    }","contract":"NativeMetaTransaction","time":0}]}