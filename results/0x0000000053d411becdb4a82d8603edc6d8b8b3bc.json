{"time":90,"results":[{"type":"external-function ","before":"function aggregate(\n\n        IERC20 fromToken,\n\n        IERC20 toToken,\n\n        uint tokensAmount,\n\n        address[] memory callAddresses,\n\n        bytes memory callDataConcat,\n\n        uint[] memory starts,\n\n        uint[] memory values,\n\n        uint mintGasPrice,\n\n        uint minTokensAmount,\n\n        address payable referrer\n\n    )\n\n    public\n\n    payable\n\n    returns (uint returnAmount)\n\n    {\n\n        returnAmount = gasleft();\n\n        uint gasTokenBalance = gasToken.balanceOf(address(this));\n\n\n        require(callAddresses.length + 1 == starts.length);\n\n\n        if (address(fromToken) != ETH_ADDRESS) {\n\n\n            spender.claimTokens(fromToken, msg.sender, address(this), tokensAmount);\n\n        }\n\n\n        for (uint i = 0; i < starts.length - 1; i++) {\n\n\n            if (starts[i + 1] - starts[i] > 0) {\n\n\n                require(\n\n                    callDataConcat[starts[i] + 0] != spender.claimTokens.selector[0] ||\n\n                    callDataConcat[starts[i] + 1] != spender.claimTokens.selector[1] ||\n\n                    callDataConcat[starts[i] + 2] != spender.claimTokens.selector[2] ||\n\n                    callDataConcat[starts[i] + 3] != spender.claimTokens.selector[3]\n\n                );\n\n                require(callAddresses[i].externalCall(values[i], callDataConcat, starts[i], starts[i + 1] - starts[i]));\n\n            }\n\n        }\n\n\n        require(_balanceOf(toToken, address(this)) >= minTokensAmount);\n\n\n        //\n\n\n\n        require(gasTokenBalance == gasToken.balanceOf(address(this)));\n\n        if (mintGasPrice > 0) {\n\n            audoRefundGas(returnAmount, mintGasPrice);\n\n        }\n\n\n        //\n\n\n\n        returnAmount = _balanceOf(toToken, address(this)) * fee / 10000;\n\n        if (referrer != address(0)) {\n\n            returnAmount /= 2;\n\n            if (!_transfer(toToken, referrer, returnAmount, true)) {\n\n                returnAmount *= 2;\n\n                emit OneInchFeePaid(toToken, address(0), returnAmount);\n\n            } else {\n\n                emit OneInchFeePaid(toToken, referrer, returnAmount / 2);\n\n            }\n\n        }\n\n\n        _transfer(toToken, owner, returnAmount, false);\n\n\n        returnAmount = _balanceOf(toToken, address(this));\n\n        _transfer(toToken, msg.sender, returnAmount, false);\n\n    }","after":"function aggregate(\n\n        IERC20 fromToken,\n\n        IERC20 toToken,\n\n        uint tokensAmount,\n\n        address[] calldata callAddresses,\n\n        bytes calldata callDataConcat,\n\n        uint[] calldata starts,\n\n        uint[] calldata values,\n\n        uint mintGasPrice,\n\n        uint minTokensAmount,\n\n        address payable referrer\n\n    )\n\n    public\n\n    payable\n\n    returns (uint returnAmount)\n\n    {\n\n        returnAmount = gasleft();\n\n        uint gasTokenBalance = gasToken.balanceOf(address(this));\n\n\n        require(callAddresses.length + 1 == starts.length);\n\n\n        if (address(fromToken) != ETH_ADDRESS) {\n\n\n            spender.claimTokens(fromToken, msg.sender, address(this), tokensAmount);\n\n        }\n\n\n        for (uint i = 0; i < starts.length - 1; i++) {\n\n\n            if (starts[i + 1] - starts[i] > 0) {\n\n\n                require(\n\n                    callDataConcat[starts[i] + 0] != spender.claimTokens.selector[0] ||\n\n                    callDataConcat[starts[i] + 1] != spender.claimTokens.selector[1] ||\n\n                    callDataConcat[starts[i] + 2] != spender.claimTokens.selector[2] ||\n\n                    callDataConcat[starts[i] + 3] != spender.claimTokens.selector[3]\n\n                );\n\n                require(callAddresses[i].externalCall(values[i], callDataConcat, starts[i], starts[i + 1] - starts[i]));\n\n            }\n\n        }\n\n\n        require(_balanceOf(toToken, address(this)) >= minTokensAmount);\n\n\n        //\n\n\n\n        require(gasTokenBalance == gasToken.balanceOf(address(this)));\n\n        if (mintGasPrice > 0) {\n\n            audoRefundGas(returnAmount, mintGasPrice);\n\n        }\n\n\n        //\n\n\n\n        returnAmount = _balanceOf(toToken, address(this)) * fee / 10000;\n\n        if (referrer != address(0)) {\n\n            returnAmount /= 2;\n\n            if (!_transfer(toToken, referrer, returnAmount, true)) {\n\n                returnAmount *= 2;\n\n                emit OneInchFeePaid(toToken, address(0), returnAmount);\n\n            } else {\n\n                emit OneInchFeePaid(toToken, referrer, returnAmount / 2);\n\n            }\n\n        }\n\n\n        _transfer(toToken, owner, returnAmount, false);\n\n\n        returnAmount = _balanceOf(toToken, address(this));\n\n        _transfer(toToken, msg.sender, returnAmount, false);\n\n    }","contract":"AggregatedTokenSwap","time":0},{"type":"immutable-restrict-modification ","before":"address payable owner;","after":"address payable immutable owner;","contract":"AggregatedTokenSwap","time":0}]}