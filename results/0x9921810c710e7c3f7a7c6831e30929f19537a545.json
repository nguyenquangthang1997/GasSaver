{"time":1353,"results":[{"type":"loop-duplication","before":"\nstart line 325 column 8, end line 329 column 8\nfor (uint256 i = 0; i < whitelistIndices.length; i++) {\n            if (whitelist[whitelistIndices[i]] == Status.In) {\n                activeCount++;\n            }\n        }\nstart line 334 column 8, end line 340 column 8\nfor (uint256 i = 0; i < whitelistIndices.length; i++) {\n            address addr = whitelistIndices[i];\n            if (whitelist[addr] == Status.In) {\n                activeWhitelist[activeCount] = addr;\n                activeCount++;\n            }\n        }","after":"// merge loop\n\nstart line 325 column 8, end line 329 column 8\nfor (uint256 i = 0; i < whitelistIndices.length; i++) {\n            if (whitelist[whitelistIndices[i]] == Status.In) {\n                activeCount++;\n            }\n        }\nstart line 334 column 8, end line 340 column 8\nfor (uint256 i = 0; i < whitelistIndices.length; i++) {\n            address addr = whitelistIndices[i];\n            if (whitelist[addr] == Status.In) {\n                activeWhitelist[activeCount] = addr;\n                activeCount++;\n            }\n        }","contract":"AddressWhitelist","time":0},{"type":"external-function ","before":"function retrieveRewards(uint256 roundId, VotingInterface.PendingRequest[] memory toRetrieve)\n    public\n    onlyRoleHolder(uint256(Roles.Voter))\n    returns (FixedPoint.Unsigned memory)\n    {\n        return _getVotingAddress().retrieveRewards(address(this), roundId, toRetrieve);\n    }","after":"function retrieveRewards(uint256 roundId, VotingInterface.PendingRequest[] calldata toRetrieve)\n    public\n    onlyRoleHolder(uint256(Roles.Voter))\n    returns (FixedPoint.Unsigned memory)\n    {\n        return _getVotingAddress().retrieveRewards(address(this), roundId, toRetrieve);\n    }","contract":"DesignatedVoting","time":0},{"type":"immutable-restrict-modification ","before":"address private finder;","after":"address private immutable finder;","contract":"DesignatedVotingFactory","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 private _c","after":"   uint256 private _c","contract":"ERC20Capped","time":1},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"ERC20Capped","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"ERC20Capped","time":1},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"ERC20PresetMinterPauser","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"ERC20PresetMinterPauser","time":1},{"type":"state-data-arrangement ","before":"\n   bytes4 private constant _ERC721_RECEIVED = 0x150b7a\n   mapping(address => EnumerableSet.UintSet) private _holderToke\n   EnumerableMap.UintToAddressMap private _tokenOwne\n   mapping(uint256 => address) private _tokenApprova\n   mapping(address => mapping(address => bool)) private _operatorApprova\n   string private _na\n   string private _symb\n   mapping(uint256 => string) private _tokenUR\n   string private _baseU\n   bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58\n   bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e13\n   bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d","after":"   mapping(address => EnumerableSet.UintSet) private _holderToke\n   EnumerableMap.UintToAddressMap private _tokenOwne\n   mapping(uint256 => address) private _tokenApprova\n   mapping(address => mapping(address => bool)) private _operatorApprova\n   string private _na\n   string private _symb\n   mapping(uint256 => string) private _tokenUR\n   string private _baseU\n   bytes4 private constant _ERC721_RECEIVED = 0x150b7a\n   bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58\n   bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e13\n   bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d\n","contract":"ERC721","time":1},{"type":"external-function ","before":"   function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n  ","after":"   function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n  ","contract":"ERC721Holder","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"ERC721PresetMinterPauserAutoId","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"ERC721PresetMinterPauserAutoId","time":1},{"type":"external-function ","before":"   function send(address recipient, uint256 amount, bytes memory data) public override {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n  ","after":"   function send(address recipient, uint256 amount, bytes calldata data) public override {\n        _send(_msgSender(), recipient, amount, data, \"\", true);\n  ","contract":"ERC777","time":0},{"type":"external-function ","before":"   function burn(uint256 amount, bytes memory data) public override {\n        _burn(_msgSender(), amount, data, \"\");\n  ","after":"   function burn(uint256 amount, bytes calldata data) public override {\n        _burn(_msgSender(), amount, data, \"\");\n  ","contract":"ERC777","time":0},{"type":"external-function ","before":"   function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n    public override\n    {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n  ","after":"   function operatorSend(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    )\n    public override\n    {\n        require(isOperatorFor(_msgSender(), sender), \"ERC777: caller is not an operator for holder\");\n        _send(sender, recipient, amount, data, operatorData, true);\n  ","contract":"ERC777","time":0},{"type":"external-function ","before":"   function operatorBurn(address account, uint256 amount, bytes memory data, bytes memory operatorData) public override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n  ","after":"   function operatorBurn(address account, uint256 amount, bytes calldata data, bytes calldata operatorData) public override {\n        require(isOperatorFor(_msgSender(), account), \"ERC777: caller is not an operator for holder\");\n        _burn(account, amount, data, operatorData);\n  ","contract":"ERC777","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"ERC777","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"ERC777","time":1},{"type":"external-function ","before":"\n    function deposit(FixedPoint.Unsigned memory collateralAmount) public onlyPreExpiration() fees() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n        _addCollateral(positionData.rawCollateral, collateralAmount);\n        _addCollateral(rawTotalPositionCollateral, collateralAmount);\n\n        // Move collateral currency from sender to contract.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n\n        emit Deposit(msg.sender, collateralAmount.rawValue);\n","after":"\n    function deposit(FixedPoint.Unsigned calldata collateralAmount) public onlyPreExpiration() fees() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n        _addCollateral(positionData.rawCollateral, collateralAmount);\n        _addCollateral(rawTotalPositionCollateral, collateralAmount);\n\n        // Move collateral currency from sender to contract.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n\n        emit Deposit(msg.sender, collateralAmount.rawValue);\n","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"\n    function withdraw(FixedPoint.Unsigned memory collateralAmount)\n    public\n    onlyPreExpiration()\n    fees()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n\n        _removeCollateral(positionData.rawCollateral, collateralAmount);\n        require(_checkPositionCollateralization(positionData));\n        // We elect to withdraw the amount that the global collateral is decreased by,\n        // rather than the individual position's collateral, because we need to maintain the invariant that\n        // the global collateral is always <= the collateral owned by the contract to avoid reverts on withdrawals.\n        amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, collateralAmount);\n\n        // Move collateral currency from contract to sender.\n        // Note that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n        // instead of the user requested amount. This eliminates precision loss that could occur\n        // where the user withdraws more collateral than rawCollateral is decremented by.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n","after":"\n    function withdraw(FixedPoint.Unsigned calldata collateralAmount)\n    public\n    onlyPreExpiration()\n    fees()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n\n        _removeCollateral(positionData.rawCollateral, collateralAmount);\n        require(_checkPositionCollateralization(positionData));\n        // We elect to withdraw the amount that the global collateral is decreased by,\n        // rather than the individual position's collateral, because we need to maintain the invariant that\n        // the global collateral is always <= the collateral owned by the contract to avoid reverts on withdrawals.\n        amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, collateralAmount);\n\n        // Move collateral currency from contract to sender.\n        // Note that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n        // instead of the user requested amount. This eliminates precision loss that could occur\n        // where the user withdraws more collateral than rawCollateral is decremented by.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"\n    function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount) public onlyPreExpiration() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n\n        // Make sure the proposed expiration of this request is not post-expiry.\n        uint256 requestPassTime = getCurrentTime() + withdrawalLiveness;\n        require(requestPassTime <= expirationTimestamp);\n\n        // Update the position object for the user.\n        positionData.requestPassTimestamp = requestPassTime;\n        positionData.withdrawalRequestAmount = collateralAmount;\n\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n","after":"\n    function requestWithdrawal(FixedPoint.Unsigned calldata collateralAmount) public onlyPreExpiration() {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n\n        // Make sure the proposed expiration of this request is not post-expiry.\n        uint256 requestPassTime = getCurrentTime() + withdrawalLiveness;\n        require(requestPassTime <= expirationTimestamp);\n\n        // Update the position object for the user.\n        positionData.requestPassTimestamp = requestPassTime;\n        positionData.withdrawalRequestAmount = collateralAmount;\n\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"\n    function create(FixedPoint.Unsigned memory collateralAmount, FixedPoint.Unsigned memory numTokens)\n    public\n    onlyPreExpiration()\n    fees()\n    {\n        require(_checkCollateralization(collateralAmount, numTokens));\n\n        PositionData storage positionData = positions[msg.sender];\n        require(positionData.requestPassTimestamp == 0);\n        if (positionData.tokensOutstanding.isEqual(0)) {\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens));\n            emit NewSponsor(msg.sender);\n        }\n        _addCollateral(positionData.rawCollateral, collateralAmount);\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n\n        _addCollateral(rawTotalPositionCollateral, collateralAmount);\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n\n        // Transfer tokens into the contract from caller and mint the caller synthetic tokens.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue), \"Minting synthetic tokens failed\");\n\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n","after":"\n    function create(FixedPoint.Unsigned calldata collateralAmount, FixedPoint.Unsigned calldata numTokens)\n    public\n    onlyPreExpiration()\n    fees()\n    {\n        require(_checkCollateralization(collateralAmount, numTokens));\n\n        PositionData storage positionData = positions[msg.sender];\n        require(positionData.requestPassTimestamp == 0);\n        if (positionData.tokensOutstanding.isEqual(0)) {\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens));\n            emit NewSponsor(msg.sender);\n        }\n        _addCollateral(positionData.rawCollateral, collateralAmount);\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n\n        _addCollateral(rawTotalPositionCollateral, collateralAmount);\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n\n        // Transfer tokens into the contract from caller and mint the caller synthetic tokens.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue), \"Minting synthetic tokens failed\");\n\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"\n    function redeem(FixedPoint.Unsigned memory numTokens)\n    public\n    onlyPreExpiration()\n    fees()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n        require(!numTokens.isGreaterThan(positionData.tokensOutstanding));\n\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n        FixedPoint.Unsigned memory collateralRedeemed = fractionRedeemed.mul(\n            _getCollateral(positionData.rawCollateral)\n        );\n\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n        } else {\n            // Decrease the sponsors position size of collateral and tokens.\n            _removeCollateral(positionData.rawCollateral, collateralRedeemed);\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n            positionData.tokensOutstanding = newTokenCount;\n\n            // Decrease the contract's collateral and tokens.\n            amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, collateralRedeemed);\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n        }\n\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n","after":"\n    function redeem(FixedPoint.Unsigned calldata numTokens)\n    public\n    onlyPreExpiration()\n    fees()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(positionData.requestPassTimestamp == 0);\n        require(!numTokens.isGreaterThan(positionData.tokensOutstanding));\n\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n        FixedPoint.Unsigned memory collateralRedeemed = fractionRedeemed.mul(\n            _getCollateral(positionData.rawCollateral)\n        );\n\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n        } else {\n            // Decrease the sponsors position size of collateral and tokens.\n            _removeCollateral(positionData.rawCollateral, collateralRedeemed);\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n            positionData.tokensOutstanding = newTokenCount;\n\n            // Decrease the contract's collateral and tokens.\n            amountWithdrawn = _removeCollateral(rawTotalPositionCollateral, collateralRedeemed);\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n        }\n\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n","contract":"ExpiringMultiParty","time":0},{"type":"immutable-restrict-modification ","before":"\n    uint256 public liquidationLive","after":"\n    uint256 public liquidationLive","contract":"ExpiringMultiParty","time":1},{"type":"immutable-restrict-modification ","before":"\n    bytes32 public priceIdent","after":"\n    bytes32 public priceIdent","contract":"ExpiringMultiParty","time":1},{"type":"immutable-restrict-modification ","before":"\n    uint256 public withdrawalLive","after":"\n    uint256 public withdrawalLive","contract":"ExpiringMultiParty","time":1},{"type":"immutable-restrict-modification ","before":"\n    address public timerAdd","after":"\n    address public timerAdd","contract":"ExpiringMultiParty","time":1},{"type":"external-function ","before":"\n    function createExpiringMultiParty(Params memory params) public returns (address) {\n        ExpiringMultiParty derivative = new ExpiringMultiParty(_convertParams(params));\n\n        address[] memory parties = new address[](1);\n        parties[0] = msg.sender;\n\n        _registerContract(parties, address(derivative));\n\n        emit CreatedExpiringMultiParty(address(derivative), msg.sender);\n\n        return address(derivative);\n","after":"\n    function createExpiringMultiParty(Params calldata params) public returns (address) {\n        ExpiringMultiParty derivative = new ExpiringMultiParty(_convertParams(params));\n\n        address[] memory parties = new address[](1);\n        parties[0] = msg.sender;\n\n        _registerContract(parties, address(derivative));\n\n        emit CreatedExpiringMultiParty(address(derivative), msg.sender);\n\n        return address(derivative);\n","contract":"ExpiringMultiPartyCreator","time":0},{"type":"immutable-restrict-modification ","before":"   address public tokenFactoryAddre","after":"   address public tokenFactoryAddre","contract":"ExpiringMultiPartyCreator","time":0},{"type":"immutable-restrict-modification ","before":"address internal finderAddress;","after":"address internal immutable finderAddress;","contract":"ExpiringMultiPartyCreator","time":0},{"type":"immutable-restrict-modification ","before":"\n    address public timerAdd","after":"\n    address public timerAdd","contract":"ExpiringMultiPartyCreator","time":0},{"type":"external-function ","before":"\n    function acceptRelayedCall(\n        address,\n        address from,\n        bytes memory,\n        uint256 transactionFee,\n        uint256 gasPrice,\n        uint256,\n        uint256,\n        bytes memory,\n        uint256 maxPossibleCharge\n    )\n    public\n    view\n    virtual\n    override\n    returns (uint256, bytes memory)\n    {\n        if (_token.balanceOf(from) < maxPossibleCharge) {\n            return _rejectRelayedCall(uint256(GSNRecipientERC20FeeErrorCodes.INSUFFICIENT_BALANCE));\n        }\n\n        return _approveRelayedCall(abi.encode(from, maxPossibleCharge, transactionFee, gasPrice));\n","after":"\n    function acceptRelayedCall(\n        address,\n        address from,\n        bytes calldata,\n        uint256 transactionFee,\n        uint256 gasPrice,\n        uint256,\n        uint256,\n        bytes calldata,\n        uint256 maxPossibleCharge\n    )\n    public\n    view\n    virtual\n    override\n    returns (uint256, bytes memory)\n    {\n        if (_token.balanceOf(from) < maxPossibleCharge) {\n            return _rejectRelayedCall(uint256(GSNRecipientERC20FeeErrorCodes.INSUFFICIENT_BALANCE));\n        }\n\n        return _approveRelayedCall(abi.encode(from, maxPossibleCharge, transactionFee, gasPrice));\n","contract":"GSNRecipientERC20Fee","time":0},{"type":"external-function ","before":"\n    function preRelayedCall(bytes memory context) public virtual override returns (bytes32) {\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n        return _preRelayedCall(context);\n","after":"\n    function preRelayedCall(bytes calldata context) public virtual override returns (bytes32) {\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n        return _preRelayedCall(context);\n","contract":"GSNRecipientERC20Fee","time":0},{"type":"external-function ","before":"\n    function postRelayedCall(bytes memory context, bool success, uint256 actualCharge, bytes32 preRetVal) public virtual override {\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n        _postRelayedCall(context, success, actualCharge, preRetVal);\n","after":"\n    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) public virtual override {\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n        _postRelayedCall(context, success, actualCharge, preRetVal);\n","contract":"GSNRecipientERC20Fee","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"__unstable__ERC20Owned","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"__unstable__ERC20Owned","time":0},{"type":"external-function ","before":"\n    function acceptRelayedCall(\n        address relay,\n        address from,\n        bytes memory encodedFunction,\n        uint256 transactionFee,\n        uint256 gasPrice,\n        uint256 gasLimit,\n        uint256 nonce,\n        bytes memory approvalData,\n        uint256\n    )\n    public\n    view\n    virtual\n    override\n    returns (uint256, bytes memory)\n    {\n        bytes memory blob = abi.encodePacked(\n            relay,\n            from,\n            encodedFunction,\n            transactionFee,\n            gasPrice,\n            gasLimit,\n            nonce, // Prevents replays on RelayHub\n            getHubAddr(), // Prevents replays in multiple RelayHubs\n            address(this) // Prevents replays in multiple recipients\n        );\n        if (keccak256(blob).toEthSignedMessageHash().recover(approvalData) == _trustedSigner) {\n            return _approveRelayedCall();\n        } else {\n            return _rejectRelayedCall(uint256(GSNRecipientSignatureErrorCodes.INVALID_SIGNER));\n        }\n","after":"\n    function acceptRelayedCall(\n        address relay,\n        address from,\n        bytes calldata encodedFunction,\n        uint256 transactionFee,\n        uint256 gasPrice,\n        uint256 gasLimit,\n        uint256 nonce,\n        bytes calldata approvalData,\n        uint256\n    )\n    public\n    view\n    virtual\n    override\n    returns (uint256, bytes memory)\n    {\n        bytes memory blob = abi.encodePacked(\n            relay,\n            from,\n            encodedFunction,\n            transactionFee,\n            gasPrice,\n            gasLimit,\n            nonce, // Prevents replays on RelayHub\n            getHubAddr(), // Prevents replays in multiple RelayHubs\n            address(this) // Prevents replays in multiple recipients\n        );\n        if (keccak256(blob).toEthSignedMessageHash().recover(approvalData) == _trustedSigner) {\n            return _approveRelayedCall();\n        } else {\n            return _rejectRelayedCall(uint256(GSNRecipientSignatureErrorCodes.INVALID_SIGNER));\n        }\n","contract":"GSNRecipientSignature","time":0},{"type":"external-function ","before":"\n    function preRelayedCall(bytes memory context) public virtual override returns (bytes32) {\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n        return _preRelayedCall(context);\n","after":"\n    function preRelayedCall(bytes calldata context) public virtual override returns (bytes32) {\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n        return _preRelayedCall(context);\n","contract":"GSNRecipientSignature","time":0},{"type":"external-function ","before":"\n    function postRelayedCall(bytes memory context, bool success, uint256 actualCharge, bytes32 preRetVal) public virtual override {\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n        _postRelayedCall(context, success, actualCharge, preRetVal);\n","after":"\n    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) public virtual override {\n        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");\n        _postRelayedCall(context, success, actualCharge, preRetVal);\n","contract":"GSNRecipientSignature","time":0},{"type":"immutable-restrict-modification ","before":"\n    address private _trustedSi","after":"\n    address private _trustedSi","contract":"GSNRecipientSignature","time":0},{"type":"external-function ","before":"\n    function propose(Transaction[] memory transactions) public onlyRoleHolder(uint256(Roles.Proposer)) {\n        uint256 id = proposals.length;\n        uint256 time = getCurrentTime();\n\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\n\n        // Add a zero-initialized element to the proposals array.\n        proposals.push();\n\n        // Initialize the new proposal.\n        Proposal storage proposal = proposals[id];\n        proposal.requestTime = time;\n\n        // Initialize the transaction array.\n        for (uint256 i = 0; i < transactions.length; i++) {\n            require(transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\n            if (transactions[i].data.length > 0) {\n                require(transactions[i].to.isContract(), \"EOA can't accept tx with data\");\n            }\n            proposal.transactions.push(transactions[i]);\n        }\n\n        bytes32 identifier = _constructIdentifier(id);\n\n        // Request a vote on this proposal in the DVM.\n        OracleInterface oracle = _getOracle();\n        IdentifierWhitelistInterface supportedIdentifiers = _getIdentifierWhitelist();\n        supportedIdentifiers.addSupportedIdentifier(identifier);\n\n        oracle.requestPrice(identifier, time);\n        supportedIdentifiers.removeSupportedIdentifier(identifier);\n\n        emit NewProposal(id, transactions);\n","after":"\n    function propose(Transaction[] calldata transactions) public onlyRoleHolder(uint256(Roles.Proposer)) {\n        uint256 id = proposals.length;\n        uint256 time = getCurrentTime();\n\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\n\n        // Add a zero-initialized element to the proposals array.\n        proposals.push();\n\n        // Initialize the new proposal.\n        Proposal storage proposal = proposals[id];\n        proposal.requestTime = time;\n\n        // Initialize the transaction array.\n        for (uint256 i = 0; i < transactions.length; i++) {\n            require(transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\n            if (transactions[i].data.length > 0) {\n                require(transactions[i].to.isContract(), \"EOA can't accept tx with data\");\n            }\n            proposal.transactions.push(transactions[i]);\n        }\n\n        bytes32 identifier = _constructIdentifier(id);\n\n        // Request a vote on this proposal in the DVM.\n        OracleInterface oracle = _getOracle();\n        IdentifierWhitelistInterface supportedIdentifiers = _getIdentifierWhitelist();\n        supportedIdentifiers.addSupportedIdentifier(identifier);\n\n        oracle.requestPrice(identifier, time);\n        supportedIdentifiers.removeSupportedIdentifier(identifier);\n\n        emit NewProposal(id, transactions);\n","contract":"GovernorTest","time":0},{"type":"immutable-restrict-modification ","before":"\n    address public timerAdd","after":"\n    address public timerAdd","contract":"GovernorTest","time":1},{"type":"immutable-restrict-modification ","before":"\n    int256 internal leverageMultip","after":"\n    int256 internal leverageMultip","contract":"LeveragedReturnCalculator","time":1},{"type":"immutable-restrict-modification ","before":"\n    address public timerAdd","after":"\n    address public timerAdd","contract":"ManualPriceFeed","time":1},{"type":"immutable-restrict-modification ","before":"\n    address public o","after":"\n    address public o","contract":"Migrations","time":0},{"type":"de-morgan-condition ","before":" if (!lookup.isAvailable && !queryIndices[identifier][time].is","after":"!( if (lookup.isAvailable && queryIndices[identifier][time].is)","loc":{"start":{"line":7130,"column":12},"end":{"line":7130,"column":67}},"contract":"MockOracle","time":0},{"type":"immutable-restrict-modification ","before":"\n    address public timerAdd","after":"\n    address public timerAdd","contract":"MockOracle","time":0},{"type":"external-function ","before":"\n    function setTransactionData(bytes memory _txnData) public {\n        txnData = _txnData;\n","after":"\n    function setTransactionData(bytes calldata _txnData) public {\n        txnData = _txnData;\n","contract":"ReentrancyChecker","time":0},{"type":"immutable-restrict-modification ","before":"\n    address payable private _benefic","after":"\n    address payable private _benefic","contract":"RefundEscrow","time":0},{"type":"external-function ","before":"\n    function setFinalFee(address currency, FixedPoint.Unsigned memory newFinalFee)\n    public\n    onlyRoleHolder(uint256(Roles.Owner))\n    {\n        finalFees[currency] = newFinalFee;\n        emit NewFinalFee(newFinalFee);\n","after":"\n    function setFinalFee(address currency, FixedPoint.Unsigned calldata newFinalFee)\n    public\n    onlyRoleHolder(uint256(Roles.Owner))\n    {\n        finalFees[currency] = newFinalFee;\n        emit NewFinalFee(newFinalFee);\n","contract":"Store","time":0},{"type":"immutable-restrict-modification ","before":"\n    address public timerAdd","after":"\n    address public timerAdd","contract":"Store","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"SyntheticToken","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"SyntheticToken","time":1},{"type":"immutable-restrict-modification ","before":"\n    address public timerAdd","after":"\n    address public timerAdd","contract":"TestableTest","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"TestnetERC20","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"TestnetERC20","time":0},{"type":"immutable-restrict-modification ","before":"\n    uint256 public snapsh","after":"\n    uint256 public snapsh","contract":"TokenMigrator","time":0},{"type":"immutable-restrict-modification ","before":"leased\n    address private _b","after":"leased\n    address private _b","contract":"TokenTimelock","time":0},{"type":"immutable-restrict-modification ","before":"nabled\n    uint256 private _r","after":"nabled\n    uint256 private _r","contract":"TokenTimelock","time":0},{"type":"state-data-arrangement ","before":"\nleased\n    address private _b\nstamp.\n    uint256 priv\ncliff;\n    uint256 priv\nstart;\n    uint256 private\ntion;\n\n    bool private \nable;\n\n    mapping(address => uint256) private\neased;\n    mapping(address => bool) privat","after":"stamp.\n    uint256 priv\ncliff;\n    uint256 priv\nstart;\n    uint256 private\nable;\n\n    mapping(address => uint256) private\neased;\n    mapping(address => bool) privat\nleased\n    address private _b\ntion;\n\n    bool private \n","contract":"TokenVesting","time":0},{"type":"immutable-restrict-modification ","before":"leased\n    address private _b","after":"leased\n    address private _b","contract":"TokenVesting","time":1},{"type":"immutable-restrict-modification ","before":"stamp.\n    uint256 priv","after":"stamp.\n    uint256 priv","contract":"TokenVesting","time":1},{"type":"immutable-restrict-modification ","before":"cliff;\n    uint256 priv","after":"cliff;\n    uint256 priv","contract":"TokenVesting","time":1},{"type":"immutable-restrict-modification ","before":"start;\n    uint256 private","after":"start;\n    uint256 private","contract":"TokenVesting","time":1},{"type":"immutable-restrict-modification ","before":"tion;\n\n    bool private ","after":"tion;\n\n    bool private ","contract":"TokenVesting","time":1},{"type":"external-function ","before":"ions).\n    function _initialize(\n        TDS.Storage storage s,\n        TokenizedDerivativeParams.ConstructorParams memory params,\n        string memory symbol\n    ) public {\n        s._setFixedParameters(params, symbol);\n        s._setExternalAddresses(params);\n\n        // Keep the starting token price relatively close to FP_SCALING_FACTOR to prevent users from unintentionally\n        // creating rounding or overflow errors.\n        require(params.startingTokenPrice >= UINT_FP_SCALING_FACTOR.div(10 ** 9));\n        require(params.startingTokenPrice <= UINT_FP_SCALING_FACTOR.mul(10 ** 9));\n\n        // TODO(mrice32): we should have an ideal start time rather than blindly polling.\n        (uint256 latestTime, int256 latestUnderlyingPrice) = s.externalAddresses.priceFeed.latestPrice(\n            s.fixedParameters.product\n        );\n\n        // If nonzero, take the user input as the starting price.\n        if (params.startingUnderlyingPrice != 0) {\n            latestUnderlyingPrice = _safeIntCast(params.startingUnderlyingPrice);\n        }\n\n        require(latestUnderlyingPrice > 0);\n        require(latestTime != 0);\n\n        // Keep the ratio in case it's needed for margin computation.\n        s.fixedParameters.initialTokenUnderlyingRatio = params.startingTokenPrice.mul(UINT_FP_SCALING_FACTOR).div(\n            _safeUintCast(latestUnderlyingPrice)\n        );\n        require(s.fixedParameters.initialTokenUnderlyingRatio != 0);\n\n        // Set end time to max value of uint256 to implement no expiry.\n        if (params.expiry == 0) {\n            s.endTime = ~uint256(0);\n        } else {\n            require(params.expiry >= latestTime);\n            s.endTime = params.expiry;\n        }\n\n        s.nav = s._computeInitialNav(latestUnderlyingPrice, latestTime, params.startingTokenPrice);\n\n        s.state = TDS.State.","after":"ions).\n    function _initialize(\n        TDS.Storage storage s,\n        TokenizedDerivativeParams.ConstructorParams calldata params,\n        string memory symbol\n    ) public {\n        s._setFixedParameters(params, symbol);\n        s._setExternalAddresses(params);\n\n        // Keep the starting token price relatively close to FP_SCALING_FACTOR to prevent users from unintentionally\n        // creating rounding or overflow errors.\n        require(params.startingTokenPrice >= UINT_FP_SCALING_FACTOR.div(10 ** 9));\n        require(params.startingTokenPrice <= UINT_FP_SCALING_FACTOR.mul(10 ** 9));\n\n        // TODO(mrice32): we should have an ideal start time rather than blindly polling.\n        (uint256 latestTime, int256 latestUnderlyingPrice) = s.externalAddresses.priceFeed.latestPrice(\n            s.fixedParameters.product\n        );\n\n        // If nonzero, take the user input as the starting price.\n        if (params.startingUnderlyingPrice != 0) {\n            latestUnderlyingPrice = _safeIntCast(params.startingUnderlyingPrice);\n        }\n\n        require(latestUnderlyingPrice > 0);\n        require(latestTime != 0);\n\n        // Keep the ratio in case it's needed for margin computation.\n        s.fixedParameters.initialTokenUnderlyingRatio = params.startingTokenPrice.mul(UINT_FP_SCALING_FACTOR).div(\n            _safeUintCast(latestUnderlyingPrice)\n        );\n        require(s.fixedParameters.initialTokenUnderlyingRatio != 0);\n\n        // Set end time to max value of uint256 to implement no expiry.\n        if (params.expiry == 0) {\n            s.endTime = ~uint256(0);\n        } else {\n            require(params.expiry >= latestTime);\n            s.endTime = params.expiry;\n        }\n\n        s.nav = s._computeInitialNav(latestUnderlyingPrice, latestTime, params.startingTokenPrice);\n\n        s.state = TDS.State.","contract":"TokenizedDerivativeUtils","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"TokenizedDerivative","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"TokenizedDerivative","time":1},{"type":"external-function ","before":"    */\n    function createTokenizedDerivative(Params memory params) public returns (address derivativeAddress) {\n        TokenizedDerivative derivative = new TokenizedDerivative(_convertParams(params), params.name, params.symbol);\n\n        address[] memory parties = new address[](1);\n        parties[0] = msg.sender;\n\n        _registerContract(parties, address(derivative));\n\n        emit CreatedTokenizedDerivative(address(derivative));\n\n        return address(derivat","after":"    */\n    function createTokenizedDerivative(Params memory params) public returns (address derivativeAddress) {\n        TokenizedDerivative derivative = new TokenizedDerivative(_convertParams(params), params.name, params.symbol);\n\n        address[] memory parties = new address[](1);\n        parties[0] = msg.sender;\n\n        _registerContract(parties, address(derivative));\n\n        emit CreatedTokenizedDerivative(address(derivative));\n\n        return address(derivat","contract":"TokenizedDerivativeCreator","time":0},{"type":"immutable-restrict-modification ","before":"address internal finderAddress;","after":"address internal immutable finderAddress;","contract":"TokenizedDerivativeCreator","time":0},{"type":"immutable-restrict-modification ","before":"\n    address public timerAdd","after":"\n    address public timerAdd","contract":"TokenizedDerivativeCreator","time":0},{"type":"immutable-restrict-modification ","before":"grade.\n    address public existi","after":"grade.\n    address public existi","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"inder.\n    address public n","after":"inder.\n    address public n","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"grade.\n    address pub","after":"grade.\n    address pub","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"oting;\n    address public identifie","after":"oting;\n    address public identifie","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"elist;\n    address pu","after":"elist;\n    address pu","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"store;\n    address public financialCont","after":"store;\n    address public financialCont","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"Admin;\n    address publi","after":"Admin;\n    address publi","contract":"Umip3Upgrader","time":0},{"type":"external-function ","before":"    */\n    function getPriceRequestStatuses(PendingRequest[] memory requests) public view returns (RequestState[] memory) {\n        RequestState[] memory requestStates = new RequestState[](requests.length);\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        for (uint256 i = 0; i < requests.length; i++) {\n            PriceRequest storage priceRequest = _getPriceRequest(requests[i].identifier, requests[i].time);\n\n            RequestStatus status = _getRequestStatus(priceRequest, currentRoundId);\n\n            // If it's an active request, its true lastVotingRound is the current one, even if it hasn't been updated.\n            if (status == RequestStatus.Active) {\n                requestStates[i].lastVotingRound = currentRoundId;\n            } else {\n                requestStates[i].lastVotingRound = priceRequest.lastVotingRound;\n            }\n            requestStates[i].status = status;\n        }\n        return requestSt","after":"    */\n    function getPriceRequestStatuses(PendingRequest[] memory requests) public view returns (RequestState[] memory) {\n        RequestState[] memory requestStates = new RequestState[](requests.length);\n        uint256 currentRoundId = voteTiming.computeCurrentRoundId(getCurrentTime());\n        for (uint256 i = 0; i < requests.length; i++) {\n            PriceRequest storage priceRequest = _getPriceRequest(requests[i].identifier, requests[i].time);\n\n            RequestStatus status = _getRequestStatus(priceRequest, currentRoundId);\n\n            // If it's an active request, its true lastVotingRound is the current one, even if it hasn't been updated.\n            if (status == RequestStatus.Active) {\n                requestStates[i].lastVotingRound = currentRoundId;\n            } else {\n                requestStates[i].lastVotingRound = priceRequest.lastVotingRound;\n            }\n            requestStates[i].status = status;\n        }\n        return requestSt","contract":"VotingTest","time":0},{"type":"external-function ","before":"\n     */\n    function retrieveRewards(\n        address voterAddress,\n        uint256 roundId,\n        PendingRequest[] memory toRetrieve\n    ) public override returns (FixedPoint.Unsigned memory totalRewardToIssue) {\n        if (migratedAddress != address(0)) {\n            require(msg.sender == migratedAddress, \"Can only call from migrated\");\n        }\n        uint256 blockTime = getCurrentTime();\n        require(roundId < voteTiming.computeCurrentRoundId(blockTime), \"Invalid roundId\");\n\n        Round storage round = rounds[roundId];\n        bool isExpired = blockTime > round.rewardsExpirationTime;\n        FixedPoint.Unsigned memory snapshotBalance = FixedPoint.Unsigned(\n            votingToken.balanceOfAt(voterAddress, round.snapshotId)\n        );\n\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\n        FixedPoint.Unsigned memory snapshotTotalSupply = FixedPoint.Unsigned(\n            votingToken.totalSupplyAt(round.snapshotId)\n        );\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\n\n        // Keep track of the voter's accumulated token reward.\n        totalRewardToIssue = FixedPoint.Unsigned(0);\n\n        for (uint256 i = 0; i < toRetrieve.length; i++) {\n            PriceRequest storage priceRequest = _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time);\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n            // Only retrieve rewards for votes resolved in same round\n            require(priceRequest.lastVotingRound == roundId, \"Retrieve for votes same round\");\n\n            _resolvePriceRequest(priceRequest, voteInstance);\n\n            if (voteInstance.voteSubmissions[voterAddress].revealHash == 0) {\n                continue;\n            } else if (isExpired) {\n                // Emit a 0 token retrieval on expired rewards.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n            } else if (\n                voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)\n            ) {\n                // The price was successfully resolved during the voter's last voting round, the voter revealed\n                // and was correct, so they are eligible for a reward.\n                // Compute the reward and add to the cumulative reward.\n                FixedPoint.Unsigned memory reward = snapshotBalance.mul(totalRewardPerVote).div(\n                    voteInstance.resultComputation.getTotalCorrectlyVotedTokens()\n                );\n                totalRewardToIssue = totalRewardToIssue.add(reward);\n\n                // Emit reward retrieval for this vote.\n                emit RewardsRetrieved(\n                    voterAddress,\n                    roundId,\n                    toRetrieve[i].identifier,\n                    toRetrieve[i].time,\n                    reward.rawValue\n                );\n            } else {\n                // Emit a 0 token retrieval on incorrect votes.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n            }\n\n            // Delete the submission to capture any refund and clean up storage.\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\n        }\n\n        // Issue any accumulated rewards.\n        if (totalRewardToIssue.isGreaterThan(0)) {\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue), \"Voting token issuance failed\");\n  ","after":"\n     */\n    function retrieveRewards(\n        address voterAddress,\n        uint256 roundId,\n        PendingRequest[] memory toRetrieve\n    ) public override returns (FixedPoint.Unsigned memory totalRewardToIssue) {\n        if (migratedAddress != address(0)) {\n            require(msg.sender == migratedAddress, \"Can only call from migrated\");\n        }\n        uint256 blockTime = getCurrentTime();\n        require(roundId < voteTiming.computeCurrentRoundId(blockTime), \"Invalid roundId\");\n\n        Round storage round = rounds[roundId];\n        bool isExpired = blockTime > round.rewardsExpirationTime;\n        FixedPoint.Unsigned memory snapshotBalance = FixedPoint.Unsigned(\n            votingToken.balanceOfAt(voterAddress, round.snapshotId)\n        );\n\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\n        FixedPoint.Unsigned memory snapshotTotalSupply = FixedPoint.Unsigned(\n            votingToken.totalSupplyAt(round.snapshotId)\n        );\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\n\n        // Keep track of the voter's accumulated token reward.\n        totalRewardToIssue = FixedPoint.Unsigned(0);\n\n        for (uint256 i = 0; i < toRetrieve.length; i++) {\n            PriceRequest storage priceRequest = _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time);\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n            // Only retrieve rewards for votes resolved in same round\n            require(priceRequest.lastVotingRound == roundId, \"Retrieve for votes same round\");\n\n            _resolvePriceRequest(priceRequest, voteInstance);\n\n            if (voteInstance.voteSubmissions[voterAddress].revealHash == 0) {\n                continue;\n            } else if (isExpired) {\n                // Emit a 0 token retrieval on expired rewards.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n            } else if (\n                voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)\n            ) {\n                // The price was successfully resolved during the voter's last voting round, the voter revealed\n                // and was correct, so they are eligible for a reward.\n                // Compute the reward and add to the cumulative reward.\n                FixedPoint.Unsigned memory reward = snapshotBalance.mul(totalRewardPerVote).div(\n                    voteInstance.resultComputation.getTotalCorrectlyVotedTokens()\n                );\n                totalRewardToIssue = totalRewardToIssue.add(reward);\n\n                // Emit reward retrieval for this vote.\n                emit RewardsRetrieved(\n                    voterAddress,\n                    roundId,\n                    toRetrieve[i].identifier,\n                    toRetrieve[i].time,\n                    reward.rawValue\n                );\n            } else {\n                // Emit a 0 token retrieval on incorrect votes.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n            }\n\n            // Delete the submission to capture any refund and clean up storage.\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\n        }\n\n        // Issue any accumulated rewards.\n        if (totalRewardToIssue.isGreaterThan(0)) {\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue), \"Voting token issuance failed\");\n  ","contract":"VotingTest","time":0},{"type":"external-function ","before":"\n     */\n    function setInflationRate(FixedPoint.Unsigned memory newInflationRate) public onlyOwner {\n        inflationRate = newInflati","after":"\n     */\n    function setInflationRate(FixedPoint.Unsigned calldata newInflationRate) public onlyOwner {\n        inflationRate = newInflati","contract":"VotingTest","time":0},{"type":"external-function ","before":"\n     */\n    function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage) public onlyOwner {\n        require(newGatPercentage.isLessThan(1), \"GAT percentage must be < 100%\");\n        gatPercentage = newGatPerc","after":"\n     */\n    function setGatPercentage(FixedPoint.Unsigned calldata newGatPercentage) public onlyOwner {\n        require(newGatPercentage.isLessThan(1), \"GAT percentage must be < 100%\");\n        gatPercentage = newGatPerc","contract":"VotingTest","time":0},{"type":"immutable-restrict-modification ","before":"\n    address public timerAdd","after":"\n    address public timerAdd","contract":"VotingTest","time":1},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"VotingToken","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"VotingToken","time":1},{"type":"constant-restrict-modification  ","before":"ct WETH9 {\n    string public name = \"","after":"ct WETH9 {\n    string public constant name = \"","contract":"WETH9","time":0},{"type":"constant-restrict-modification  ","before":"ed Ether\";\n    string public s","after":"ed Ether\";\n    string public s","contract":"WETH9","time":0},{"type":"constant-restrict-modification  ","before":" = \"WETH\";\n    uint8 public","after":" = \"WETH\";\n    uint8 public","contract":"WETH9","time":0}]}