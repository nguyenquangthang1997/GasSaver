{"time":520,"results":[{"type":"struct-data-arrangement ","before":"\nbool isReserve\nuint256 identifier\naddress giveToken\nuint256 giveAmount\nuint256 fee\nuint256 rebate\nuint256 gasLimit","after":"uint256 identifier\nuint256 giveAmount\nuint256 fee\nuint256 rebate\nuint256 gasLimit\naddress giveToken\nbool isReserve\n","contract":"dexBlueStructs","time":0},{"type":"constant-restrict-modification  ","before":"address payable owner;","after":"address payable constant owner;","contract":"dexBlueSettlementModule","time":2},{"type":"constant-restrict-modification  ","before":"bool marketActive = true;","after":"bool constant marketActive = true;","contract":"dexBlueSettlementModule","time":2},{"type":"constant-restrict-modification  ","before":"address payable feeCollector;","after":"address payable constant feeCollector;","contract":"dexBlueSettlementModule","time":2},{"type":"constant-restrict-modification  ","before":"bool feeCollectorLocked = false;","after":"bool constant feeCollectorLocked = false;","contract":"dexBlueSettlementModule","time":2},{"type":"constant-restrict-modification  ","before":"uint256 single_sig_waiting_period = 86400;","after":"uint256 constant single_sig_waiting_period = 86400;","contract":"dexBlueSettlementModule","time":2},{"type":"constant-restrict-modification  ","before":"bytes32          EIP712_DOMAIN_SEPARATOR;","after":"bytes32          constant EIP712_DOMAIN_SEPARATOR;","contract":"dexBlueSettlementModule","time":2},{"type":"external-function ","before":"function orderFromInput(OrderInputPacked memory orderInput) view public returns (Order memory){\n\n        // Parse packed input\n\n        Order memory order = Order({\n\n        sellToken : tokens[uint256(orderInput.packedInput2 >> 240)],\n\n        sellAmount : uint256(orderInput.packedInput1 >> 128),\n\n        buyToken : tokens[uint256((orderInput.packedInput2 & 0x0000ffff00000000000000000000000000000000000000000000000000000000) >> 224)],\n\n        buyAmount : uint256(orderInput.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n        expiry : uint256((orderInput.packedInput2 & 0x00000000ffffffff000000000000000000000000000000000000000000000000) >> 192),\n\n        hash : 0x0,\n\n        signee : address(0x0)\n\n        });\n\n\n        // Restore order hash\n\n        if (\n\n            orderInput.packedInput2[17] == byte(0x00)   // Signing scheme\n\n        ) {// Order is hashed after signature scheme personal.sign()\n\n            order.hash = keccak256(abi.encodePacked(// Restore the hash of this order\n\n                    \"\\x19Ethereum Signed Message:\\n32\",\n\n                    keccak256(abi.encodePacked(\n\n                        order.sellToken,\n\n                        uint128(order.sellAmount),\n\n                        order.buyToken,\n\n                        uint128(order.buyAmount),\n\n                        uint32(order.expiry),\n\n                        uint64(uint256((orderInput.packedInput2 & 0x0000000000000000ffffffffffffffff00000000000000000000000000000000) >> 128)), // nonce\n\n                        address(this)                       // This contract's address\n\n                    ))\n\n                ));\n\n        } else {// Order is hashed after EIP712\n\n            order.hash = keccak256(abi.encodePacked(\n\n                    \"\\x19\\x01\",\n\n                    EIP712_DOMAIN_SEPARATOR,\n\n                    keccak256(abi.encode(\n\n                        EIP712_ORDER_TYPEHASH,\n\n                        order.sellToken,\n\n                        order.sellAmount,\n\n                        order.buyToken,\n\n                        order.buyAmount,\n\n                        order.expiry,\n\n                        uint256((orderInput.packedInput2 & 0x0000000000000000ffffffffffffffff00000000000000000000000000000000) >> 128) // nonce\n\n                    ))\n\n                ));\n\n        }\n\n\n        // Restore the signee of this order\n\n        order.signee = ecrecover(\n\n            order.hash, // Order hash\n\n            uint8(orderInput.packedInput2[16]), // Signature v\n\n            orderInput.r, // Signature r\n\n            orderInput.s                            // Signature s\n\n        );\n\n\n        // When the signature was delegated restore delegating address\n\n        if (\n\n            orderInput.packedInput2[18] == byte(0x01)  // Is delegated\n\n        ) {\n\n            order.signee = delegates[order.signee];\n\n        }\n\n\n        return order;\n\n    }","after":"function orderFromInput(OrderInputPacked calldata orderInput) view public returns (Order memory){\n\n        // Parse packed input\n\n        Order memory order = Order({\n\n        sellToken : tokens[uint256(orderInput.packedInput2 >> 240)],\n\n        sellAmount : uint256(orderInput.packedInput1 >> 128),\n\n        buyToken : tokens[uint256((orderInput.packedInput2 & 0x0000ffff00000000000000000000000000000000000000000000000000000000) >> 224)],\n\n        buyAmount : uint256(orderInput.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n        expiry : uint256((orderInput.packedInput2 & 0x00000000ffffffff000000000000000000000000000000000000000000000000) >> 192),\n\n        hash : 0x0,\n\n        signee : address(0x0)\n\n        });\n\n\n        // Restore order hash\n\n        if (\n\n            orderInput.packedInput2[17] == byte(0x00)   // Signing scheme\n\n        ) {// Order is hashed after signature scheme personal.sign()\n\n            order.hash = keccak256(abi.encodePacked(// Restore the hash of this order\n\n                    \"\\x19Ethereum Signed Message:\\n32\",\n\n                    keccak256(abi.encodePacked(\n\n                        order.sellToken,\n\n                        uint128(order.sellAmount),\n\n                        order.buyToken,\n\n                        uint128(order.buyAmount),\n\n                        uint32(order.expiry),\n\n                        uint64(uint256((orderInput.packedInput2 & 0x0000000000000000ffffffffffffffff00000000000000000000000000000000) >> 128)), // nonce\n\n                        address(this)                       // This contract's address\n\n                    ))\n\n                ));\n\n        } else {// Order is hashed after EIP712\n\n            order.hash = keccak256(abi.encodePacked(\n\n                    \"\\x19\\x01\",\n\n                    EIP712_DOMAIN_SEPARATOR,\n\n                    keccak256(abi.encode(\n\n                        EIP712_ORDER_TYPEHASH,\n\n                        order.sellToken,\n\n                        order.sellAmount,\n\n                        order.buyToken,\n\n                        order.buyAmount,\n\n                        order.expiry,\n\n                        uint256((orderInput.packedInput2 & 0x0000000000000000ffffffffffffffff00000000000000000000000000000000) >> 128) // nonce\n\n                    ))\n\n                ));\n\n        }\n\n\n        // Restore the signee of this order\n\n        order.signee = ecrecover(\n\n            order.hash, // Order hash\n\n            uint8(orderInput.packedInput2[16]), // Signature v\n\n            orderInput.r, // Signature r\n\n            orderInput.s                            // Signature s\n\n        );\n\n\n        // When the signature was delegated restore delegating address\n\n        if (\n\n            orderInput.packedInput2[18] == byte(0x01)  // Is delegated\n\n        ) {\n\n            order.signee = delegates[order.signee];\n\n        }\n\n\n        return order;\n\n    }","contract":"dexBlue","time":0},{"type":"external-function ","before":"function tradeFromInput(TradeInputPacked memory packed) public pure returns (Trade memory){\n\n        return Trade({\n\n        makerAmount : uint256(packed.packedInput1 >> 128),\n\n        takerAmount : uint256(packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n        makerFee : uint256(packed.packedInput2 >> 128),\n\n        takerFee : uint256(packed.packedInput2 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n        makerRebate : uint256(packed.packedInput3 >> 128)\n\n        });\n\n    }","after":"function tradeFromInput(TradeInputPacked calldata packed) public pure returns (Trade memory){\n\n        return Trade({\n\n        makerAmount : uint256(packed.packedInput1 >> 128),\n\n        takerAmount : uint256(packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n        makerFee : uint256(packed.packedInput2 >> 128),\n\n        takerFee : uint256(packed.packedInput2 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n        makerRebate : uint256(packed.packedInput3 >> 128)\n\n        });\n\n    }","contract":"dexBlue","time":0},{"type":"external-function ","before":"function reserveTradeFromInput(TradeInputPacked memory packed) public pure returns (ReserveTrade memory){\n\n        if (packed.packedInput3[16] == byte(0x10)) {\n\n            // maker is order, taker is reserve\n\n            return ReserveTrade({\n\n            orderAmount : uint256(packed.packedInput1 >> 128),\n\n            reserveAmount : uint256(packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n            orderFee : uint256(packed.packedInput2 >> 128),\n\n            reserveFee : uint256(packed.packedInput2 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n            orderRebate : uint256((packed.packedInput3 & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128),\n\n            reserveRebate : 0,\n\n            orderIsMaker : true,\n\n            gasLimit : uint256((packed.packedInput3 & 0x00000000000000000000000000000000000000000000000000ffffff00000000) >> 32)\n\n            });\n\n        } else {\n\n            // taker is order, maker is reserve\n\n            return ReserveTrade({\n\n            orderAmount : uint256(packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n            reserveAmount : uint256(packed.packedInput1 >> 128),\n\n            orderFee : uint256(packed.packedInput2 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n            reserveFee : uint256(packed.packedInput2 >> 128),\n\n            orderRebate : 0,\n\n            reserveRebate : uint256((packed.packedInput3 & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128),\n\n            orderIsMaker : false,\n\n            gasLimit : uint256((packed.packedInput3 & 0x00000000000000000000000000000000000000000000000000ffffff00000000) >> 32)\n\n            });\n\n        }\n\n    }","after":"function reserveTradeFromInput(TradeInputPacked calldata packed) public pure returns (ReserveTrade memory){\n\n        if (packed.packedInput3[16] == byte(0x10)) {\n\n            // maker is order, taker is reserve\n\n            return ReserveTrade({\n\n            orderAmount : uint256(packed.packedInput1 >> 128),\n\n            reserveAmount : uint256(packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n            orderFee : uint256(packed.packedInput2 >> 128),\n\n            reserveFee : uint256(packed.packedInput2 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n            orderRebate : uint256((packed.packedInput3 & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128),\n\n            reserveRebate : 0,\n\n            orderIsMaker : true,\n\n            gasLimit : uint256((packed.packedInput3 & 0x00000000000000000000000000000000000000000000000000ffffff00000000) >> 32)\n\n            });\n\n        } else {\n\n            // taker is order, maker is reserve\n\n            return ReserveTrade({\n\n            orderAmount : uint256(packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n            reserveAmount : uint256(packed.packedInput1 >> 128),\n\n            orderFee : uint256(packed.packedInput2 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n            reserveFee : uint256(packed.packedInput2 >> 128),\n\n            orderRebate : 0,\n\n            reserveRebate : uint256((packed.packedInput3 & 0xffffffffffffffffffffffffffffffff00000000000000000000000000000000) >> 128),\n\n            orderIsMaker : false,\n\n            gasLimit : uint256((packed.packedInput3 & 0x00000000000000000000000000000000000000000000000000ffffff00000000) >> 32)\n\n            });\n\n        }\n\n    }","contract":"dexBlue","time":0},{"type":"external-function ","before":"function reserveReserveTradeFromInput(TradeInputPacked memory packed) public view returns (ReserveReserveTrade memory){\n\n        return ReserveReserveTrade({\n\n        makerToken : tokens[uint256((packed.packedInput3 & 0x000000000000000000000000000000000000000000ffff000000000000000000) >> 72)],\n\n        takerToken : tokens[uint256((packed.packedInput3 & 0x0000000000000000000000000000000000000000000000ffff00000000000000) >> 56)],\n\n        makerAmount : uint256(packed.packedInput1 >> 128),\n\n        takerAmount : uint256(packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n        makerFee : uint256(packed.packedInput2 >> 128),\n\n        takerFee : uint256(packed.packedInput2 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n        gasLimit : uint256((packed.packedInput3 & 0x00000000000000000000000000000000000000000000000000ffffff00000000) >> 32)\n\n        });\n\n    }","after":"function reserveReserveTradeFromInput(TradeInputPacked calldata packed) public view returns (ReserveReserveTrade memory){\n\n        return ReserveReserveTrade({\n\n        makerToken : tokens[uint256((packed.packedInput3 & 0x000000000000000000000000000000000000000000ffff000000000000000000) >> 72)],\n\n        takerToken : tokens[uint256((packed.packedInput3 & 0x0000000000000000000000000000000000000000000000ffff00000000000000) >> 56)],\n\n        makerAmount : uint256(packed.packedInput1 >> 128),\n\n        takerAmount : uint256(packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n        makerFee : uint256(packed.packedInput2 >> 128),\n\n        takerFee : uint256(packed.packedInput2 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n        gasLimit : uint256((packed.packedInput3 & 0x00000000000000000000000000000000000000000000000000ffffff00000000) >> 32)\n\n        });\n\n    }","contract":"dexBlue","time":0},{"type":"external-function ","before":"function ringTradeFromInput(RingTradeInputPacked memory packed) view public returns (RingTrade memory){\n\n        return RingTrade({\n\n        isReserve : (packed.packedInput2[16] == bytes1(0x01)),\n\n        identifier : uint256((packed.packedInput2 & 0x0000000000000000000000000000000000ffff00000000000000000000000000) >> 104),\n\n        giveToken : tokens[uint256((packed.packedInput2 & 0x00000000000000000000000000000000000000ffff0000000000000000000000) >> 88)],\n\n        giveAmount : uint256(packed.packedInput1 >> 128),\n\n        fee : uint256(packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n        rebate : uint256(packed.packedInput2 >> 128),\n\n        gasLimit : uint256((packed.packedInput2 & 0x000000000000000000000000000000000000000000ffffff0000000000000000) >> 64)\n\n        });\n\n    }","after":"function ringTradeFromInput(RingTradeInputPacked calldata packed) view public returns (RingTrade memory){\n\n        return RingTrade({\n\n        isReserve : (packed.packedInput2[16] == bytes1(0x01)),\n\n        identifier : uint256((packed.packedInput2 & 0x0000000000000000000000000000000000ffff00000000000000000000000000) >> 104),\n\n        giveToken : tokens[uint256((packed.packedInput2 & 0x00000000000000000000000000000000000000ffff0000000000000000000000) >> 88)],\n\n        giveAmount : uint256(packed.packedInput1 >> 128),\n\n        fee : uint256(packed.packedInput1 & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff),\n\n        rebate : uint256(packed.packedInput2 >> 128),\n\n        gasLimit : uint256((packed.packedInput2 & 0x000000000000000000000000000000000000000000ffffff0000000000000000) >> 64)\n\n        });\n\n    }","contract":"dexBlue","time":0},{"type":"immutable-restrict-modification ","before":"bytes32          EIP712_DOMAIN_SEPARATOR;","after":"bytes32          immutable EIP712_DOMAIN_SEPARATOR;","contract":"dexBlue","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public decimals;","after":"uint256 public constant decimals;","contract":"WETH","time":2},{"type":"constant-restrict-modification  ","before":"string public name;","after":"string public constant name;","contract":"WETH","time":2}]}