{"time":230,"results":[{"type":"external-function ","before":"function setBaseMetadataURI(string memory _newBaseMetadataURI) public onlyAdminOrOwner {\n        _setBaseMetadataURI(_newBaseMetadataURI);\n    }","after":"function setBaseMetadataURI(string calldata _newBaseMetadataURI) public onlyAdminOrOwner {\n        _setBaseMetadataURI(_newBaseMetadataURI);\n    }","contract":"CryptoKombatCollection","time":0},{"type":"external-function ","before":"function create(\n        uint256 _max,\n        uint256 _initial,\n        bytes memory _data\n    ) external onlyAdminOrOwner returns (uint256 tokenId) {\n        //TODO Need to test lte condition\n        require(_initial <= _max, 'ERC1155Tradable: Initial supply cannot be more than max supply');\n        uint256 id = _getNextTokenID();\n        _incrementTokenTypeId();\n        creators[id] = _msgSender();\n\n        if (_initial != 0) {\n            _mint(_msgSender(), id, _initial, _data);\n        }\n        tokenSupply[id] = _initial;\n        tokenMaxSupply[id] = _max;\n        return id;\n    }","after":"function create(\n        uint256 _max,\n        uint256 _initial,\n        bytes calldata _data\n    ) external onlyAdminOrOwner returns (uint256 tokenId) {\n        //TODO Need to test lte condition\n        require(_initial <= _max, 'ERC1155Tradable: Initial supply cannot be more than max supply');\n        uint256 id = _getNextTokenID();\n        _incrementTokenTypeId();\n        creators[id] = _msgSender();\n\n        if (_initial != 0) {\n            _mint(_msgSender(), id, _initial, _data);\n        }\n        tokenSupply[id] = _initial;\n        tokenMaxSupply[id] = _max;\n        return id;\n    }","contract":"CryptoKombatCollection","time":0},{"type":"external-function ","before":"function createBatch(\n        uint256[] memory _maxs,\n        uint256[] memory _initials,\n        bytes memory _data\n    ) external onlyAdminOrOwner {\n        require(_maxs.length == _initials.length, 'ERC1155Tradable: maxs and initials length mismatch');\n\n        uint256[] memory ids = new uint256[](_maxs.length);\n        uint256[] memory quantities = new uint256[](_maxs.length);\n\n        for (uint256 i = 0; i < _maxs.length; i++) {\n            uint256 max = _maxs[i];\n            uint256 initial = _initials[i];\n\n            //TODO Need to test lte condition\n            require(initial <= max, 'ERC1155Tradable: Initial supply cannot be more than max supply');\n\n            uint256 tokenId = _getNextTokenID();\n            _incrementTokenTypeId();\n            creators[tokenId] = _msgSender();\n\n            tokenSupply[tokenId] = initial;\n            tokenMaxSupply[tokenId] = max;\n\n            ids[i] = tokenId;\n            quantities[i] = initial;\n        }\n\n        _mintBatch(_msgSender(), ids, quantities, _data);\n    }","after":"function createBatch(\n        uint256[] calldata _maxs,\n        uint256[] calldata _initials,\n        bytes calldata _data\n    ) external onlyAdminOrOwner {\n        require(_maxs.length == _initials.length, 'ERC1155Tradable: maxs and initials length mismatch');\n\n        uint256[] memory ids = new uint256[](_maxs.length);\n        uint256[] memory quantities = new uint256[](_maxs.length);\n\n        for (uint256 i = 0; i < _maxs.length; i++) {\n            uint256 max = _maxs[i];\n            uint256 initial = _initials[i];\n\n            //TODO Need to test lte condition\n            require(initial <= max, 'ERC1155Tradable: Initial supply cannot be more than max supply');\n\n            uint256 tokenId = _getNextTokenID();\n            _incrementTokenTypeId();\n            creators[tokenId] = _msgSender();\n\n            tokenSupply[tokenId] = initial;\n            tokenMaxSupply[tokenId] = max;\n\n            ids[i] = tokenId;\n            quantities[i] = initial;\n        }\n\n        _mintBatch(_msgSender(), ids, quantities, _data);\n    }","contract":"CryptoKombatCollection","time":1},{"type":"external-function ","before":"function mint(\n        address _to,\n        uint256 _id,\n        uint256 _quantity,\n        bytes memory _data\n    ) public onlyMinter {\n        //TODO Need to test lte condition\n        require(tokenSupply[_id].add(_quantity) <= tokenMaxSupply[_id], 'ERC1155Tradable: Max supply reached');\n        tokenSupply[_id] = tokenSupply[_id].add(_quantity);\n        _mint(_to, _id, _quantity, _data);\n    }","after":"function mint(\n        address _to,\n        uint256 _id,\n        uint256 _quantity,\n        bytes calldata _data\n    ) public onlyMinter {\n        //TODO Need to test lte condition\n        require(tokenSupply[_id].add(_quantity) <= tokenMaxSupply[_id], 'ERC1155Tradable: Max supply reached');\n        tokenSupply[_id] = tokenSupply[_id].add(_quantity);\n        _mint(_to, _id, _quantity, _data);\n    }","contract":"CryptoKombatCollection","time":0},{"type":"external-function ","before":"function mintBatch(\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _quantities,\n        bytes memory _data\n    ) public onlyMinter {\n        require(_to != address(0), 'ERC1155Tradable: mint to the zero address');\n        require(_ids.length == _quantities.length, 'ERC1155Tradable: ids and amounts length mismatch');\n        for (uint256 i = 0; i < _ids.length; i++) {\n            uint256 id = _ids[i];\n            uint256 quantity = _quantities[i];\n            //TODO Need to test lte condition\n            require(tokenSupply[id].add(quantity) <= tokenMaxSupply[id], 'ERC1155Tradable: Max supply reached');\n            tokenSupply[id] = tokenSupply[id].add(quantity);\n        }\n        _mintBatch(_to, _ids, _quantities, _data);\n    }","after":"function mintBatch(\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _quantities,\n        bytes calldata _data\n    ) public onlyMinter {\n        require(_to != address(0), 'ERC1155Tradable: mint to the zero address');\n        require(_ids.length == _quantities.length, 'ERC1155Tradable: ids and amounts length mismatch');\n        for (uint256 i = 0; i < _ids.length; i++) {\n            uint256 id = _ids[i];\n            uint256 quantity = _quantities[i];\n            //TODO Need to test lte condition\n            require(tokenSupply[id].add(quantity) <= tokenMaxSupply[id], 'ERC1155Tradable: Max supply reached');\n            tokenSupply[id] = tokenSupply[id].add(quantity);\n        }\n        _mintBatch(_to, _ids, _quantities, _data);\n    }","contract":"CryptoKombatCollection","time":0},{"type":"external-function ","before":"function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n    public\n    view\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, 'ERC1155: accounts and ids length mismatch');\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            require(accounts[i] != address(0), 'ERC1155: batch balance query for the zero address');\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }","after":"function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    public\n    view\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, 'ERC1155: accounts and ids length mismatch');\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            require(accounts[i] != address(0), 'ERC1155: batch balance query for the zero address');\n            batchBalances[i] = _balances[ids[i]][accounts[i]];\n        }\n\n        return batchBalances;\n    }","contract":"CryptoKombatCollection","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(to != address(0), 'ERC1155: transfer to the zero address');\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            'ERC1155: caller is not owner nor approved'\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, 'ERC1155: insufficient balance for transfer');\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(to != address(0), 'ERC1155: transfer to the zero address');\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            'ERC1155: caller is not owner nor approved'\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, 'ERC1155: insufficient balance for transfer');\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"CryptoKombatCollection","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(ids.length == amounts.length, 'ERC1155: ids and amounts length mismatch');\n        require(to != address(0), 'ERC1155: transfer to the zero address');\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            'ERC1155: transfer caller is not owner nor approved'\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(amount, 'ERC1155: insufficient balance for transfer');\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(ids.length == amounts.length, 'ERC1155: ids and amounts length mismatch');\n        require(to != address(0), 'ERC1155: transfer to the zero address');\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            'ERC1155: transfer caller is not owner nor approved'\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(amount, 'ERC1155: insufficient balance for transfer');\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"CryptoKombatCollection","time":0},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"CryptoKombatCollection","time":0},{"type":"immutable-restrict-modification ","before":"string public name;","after":"string public immutable name;","contract":"CryptoKombatCollection","time":0},{"type":"immutable-restrict-modification ","before":"string public symbol;","after":"string public immutable symbol;","contract":"CryptoKombatCollection","time":0},{"type":"external-function ","before":"function addHeroes(uint256[] memory _heroes, uint256[] memory _prices) public virtual {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), 'LaunchPool: Must have admin role to add heroes');\n        require(_heroes.length == _prices.length, 'LaunchPool: Heroes and prices length mismatch');\n        for (uint256 i = 0; i < _heroes.length; i++) {\n            uint256 heroId = _heroes[i];\n            uint256 price = _prices[i];\n            require(price >= 1e18, 'LaunchPool: Price too low');\n            heroes[heroId] = price;\n        }\n        emit HeroesAdded(_heroes, _prices);\n    }","after":"function addHeroes(uint256[] calldata _heroes, uint256[] calldata _prices) public virtual {\n        require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), 'LaunchPool: Must have admin role to add heroes');\n        require(_heroes.length == _prices.length, 'LaunchPool: Heroes and prices length mismatch');\n        for (uint256 i = 0; i < _heroes.length; i++) {\n            uint256 heroId = _heroes[i];\n            uint256 price = _prices[i];\n            require(price >= 1e18, 'LaunchPool: Price too low');\n            heroes[heroId] = price;\n        }\n        emit HeroesAdded(_heroes, _prices);\n    }","contract":"LaunchPool","time":0}]}