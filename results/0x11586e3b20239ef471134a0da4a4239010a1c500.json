{"time":161,"results":[{"type":"constant-restrict-modification  ","before":"address public WETH;","after":"address public constant WETH;","contract":"ChainlinkedKeydonixOracleMainAssetAbstract","time":0},{"type":"constant-restrict-modification  ","before":"uint public immutable Q112 = 2 ** 112;","after":"uint public immutable constant Q112 = 2 ** 112;","contract":"ChainlinkedKeydonixOracleMainAssetAbstract","time":1},{"type":"external-function ","before":"function assetToUsd(\n        address asset,\n        uint amount,\n        UniswapOracle.ProofData memory proofData\n    )\n    public\n    override\n    view\n    returns (uint)\n    {\n        IUniswapV2Pair pair = IUniswapV2Pair(asset);\n        address underlyingAsset;\n        if (pair.token0() == uniswapOracleMainAsset.WETH()) {\n            underlyingAsset = pair.token1();\n        } else if (pair.token1() == uniswapOracleMainAsset.WETH()) {\n            underlyingAsset = pair.token0();\n        } else {\n            revert(\"Unit Protocol: NOT_REGISTERED_PAIR\");\n        }\n\n        uint eAvg = uniswapOracleMainAsset.assetToEth(underlyingAsset, 1, proofData);\n        // average price of 1 token in ETH\n\n        (uint112 _reserve0, uint112 _reserve1,) = pair.getReserves();\n        uint aPool;\n        // current asset pool\n        uint ePool;\n        // current WETH pool\n        if (pair.token0() == underlyingAsset) {\n            aPool = uint(_reserve0);\n            ePool = uint(_reserve1);\n        } else {\n            aPool = uint(_reserve1);\n            ePool = uint(_reserve0);\n        }\n\n        uint eCurr = ePool.mul(Q112).div(aPool);\n        // current price of 1 token in WETH\n        uint ePoolCalc;\n        // calculated WETH pool\n\n        if (eCurr < eAvg) {\n            // flashloan buying WETH\n            uint sqrtd = ePool.mul((ePool).mul(9).add(\n                    aPool.mul(3988000).mul(eAvg).div(Q112)\n                ));\n            uint eChange = sqrt(sqrtd).sub(ePool.mul(1997)).div(2000);\n            ePoolCalc = ePool.add(eChange);\n        } else {\n            // flashloan selling WETH\n            uint a = aPool.mul(eAvg);\n            uint b = a.mul(9).div(Q112);\n            uint c = ePool.mul(3988000);\n            uint sqRoot = sqrt(a.div(Q112).mul(b.add(c)));\n            uint d = a.mul(3).div(Q112);\n            uint eChange = ePool.sub(d.add(sqRoot).div(2000));\n            ePoolCalc = ePool.sub(eChange);\n        }\n\n        uint num = ePoolCalc.mul(2).mul(amount).mul(Q112);\n        uint priceInEth = num.div(pair.totalSupply());\n\n        return uniswapOracleMainAsset.ethToUsd(priceInEth);\n    }","after":"function assetToUsd(\n        address asset,\n        uint amount,\n        UniswapOracle.ProofData calldata proofData\n    )\n    public\n    override\n    view\n    returns (uint)\n    {\n        IUniswapV2Pair pair = IUniswapV2Pair(asset);\n        address underlyingAsset;\n        if (pair.token0() == uniswapOracleMainAsset.WETH()) {\n            underlyingAsset = pair.token1();\n        } else if (pair.token1() == uniswapOracleMainAsset.WETH()) {\n            underlyingAsset = pair.token0();\n        } else {\n            revert(\"Unit Protocol: NOT_REGISTERED_PAIR\");\n        }\n\n        uint eAvg = uniswapOracleMainAsset.assetToEth(underlyingAsset, 1, proofData);\n        // average price of 1 token in ETH\n\n        (uint112 _reserve0, uint112 _reserve1,) = pair.getReserves();\n        uint aPool;\n        // current asset pool\n        uint ePool;\n        // current WETH pool\n        if (pair.token0() == underlyingAsset) {\n            aPool = uint(_reserve0);\n            ePool = uint(_reserve1);\n        } else {\n            aPool = uint(_reserve1);\n            ePool = uint(_reserve0);\n        }\n\n        uint eCurr = ePool.mul(Q112).div(aPool);\n        // current price of 1 token in WETH\n        uint ePoolCalc;\n        // calculated WETH pool\n\n        if (eCurr < eAvg) {\n            // flashloan buying WETH\n            uint sqrtd = ePool.mul((ePool).mul(9).add(\n                    aPool.mul(3988000).mul(eAvg).div(Q112)\n                ));\n            uint eChange = sqrt(sqrtd).sub(ePool.mul(1997)).div(2000);\n            ePoolCalc = ePool.add(eChange);\n        } else {\n            // flashloan selling WETH\n            uint a = aPool.mul(eAvg);\n            uint b = a.mul(9).div(Q112);\n            uint c = ePool.mul(3988000);\n            uint sqRoot = sqrt(a.div(Q112).mul(b.add(c)));\n            uint d = a.mul(3).div(Q112);\n            uint eChange = ePool.sub(d.add(sqRoot).div(2000));\n            ePoolCalc = ePool.sub(eChange);\n        }\n\n        uint num = ePoolCalc.mul(2).mul(amount).mul(Q112);\n        uint priceInEth = num.div(pair.totalSupply());\n\n        return uniswapOracleMainAsset.ethToUsd(priceInEth);\n    }","contract":"ChainlinkedKeydonixOraclePoolToken","time":0},{"type":"constant-restrict-modification  ","before":"uint public immutable Q112 = 2 ** 112;","after":"uint public immutable constant Q112 = 2 ** 112;","contract":"ChainlinkedKeydonixOraclePoolToken","time":0},{"type":"external-function ","before":"function getPrice(IUniswapV2Pair uniswapV2Pair, address denominationToken, uint8 minBlocksBack, uint8 maxBlocksBack, ProofData memory proofData) public view returns (uint256 price, uint256 blockNumber) {\n        // exchange = the ExchangeV2Pair. check denomination token (USE create2 check?!) check gas cost\n        bool denominationTokenIs0;\n        if (uniswapV2Pair.token0() == denominationToken) {\n            denominationTokenIs0 = true;\n        } else if (uniswapV2Pair.token1() == denominationToken) {\n            denominationTokenIs0 = false;\n        } else {\n            revert(\"denominationToken invalid\");\n        }\n        return getPriceRaw(uniswapV2Pair, denominationTokenIs0, minBlocksBack, maxBlocksBack, proofData);\n    }","after":"function getPrice(IUniswapV2Pair uniswapV2Pair, address denominationToken, uint8 minBlocksBack, uint8 maxBlocksBack, ProofData calldata proofData) public view returns (uint256 price, uint256 blockNumber) {\n        // exchange = the ExchangeV2Pair. check denomination token (USE create2 check?!) check gas cost\n        bool denominationTokenIs0;\n        if (uniswapV2Pair.token0() == denominationToken) {\n            denominationTokenIs0 = true;\n        } else if (uniswapV2Pair.token1() == denominationToken) {\n            denominationTokenIs0 = false;\n        } else {\n            revert(\"denominationToken invalid\");\n        }\n        return getPriceRaw(uniswapV2Pair, denominationTokenIs0, minBlocksBack, maxBlocksBack, proofData);\n    }","contract":"UniswapOracle","time":0}]}