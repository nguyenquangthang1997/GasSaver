{"time":609,"results":[{"type":"external-function ","before":"function initialize(address _logic, address _admin, bytes memory _data) public payable {\n\n        require(_implementation() == address(0));\n\n        InitializableUpgradeabilityProxy.initialize(_logic, _data);\n\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n\n        _setAdmin(_admin);\n\n    }","after":"function initialize(address _logic, address _admin, bytes calldata _data) public payable {\n\n        require(_implementation() == address(0));\n\n        InitializableUpgradeabilityProxy.initialize(_logic, _data);\n\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n\n        _setAdmin(_admin);\n\n    }","contract":"InitializableAdminUpgradeabilityProxy","time":0},{"type":"external-function ","before":"function initialize(address _logic, bytes memory _data) public payable {\n\n        require(_implementation() == address(0));\n\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n\n        _setImplementation(_logic);\n\n        if (_data.length > 0) {\n\n            (bool success,) = _logic.delegatecall(_data);\n\n            require(success);\n\n        }\n\n    }","after":"function initialize(address _logic, bytes calldata _data) public payable {\n\n        require(_implementation() == address(0));\n\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n\n        _setImplementation(_logic);\n\n        if (_data.length > 0) {\n\n            (bool success,) = _logic.delegatecall(_data);\n\n            require(success);\n\n        }\n\n    }","contract":"InitializableAdminUpgradeabilityProxy","time":0},{"type":"de-morgan-condition ","before":"!vars.reserveUsageAsCollateralEnabled ||\n\n        !core.isUserUseReserveAsCollateralEnabled(_reserve, _user)","after":"!(vars.reserveUsageAsCollateralEnabled ||\n\n        core.isUserUseReserveAsCollateralEnabled(_reserve, _user))","loc":{"start":{"line":4313,"column":12},"end":{"line":4315,"column":65}},"contract":"LendingPoolDataProvider","time":0},{"type":"immutable-restrict-modification ","before":"address public underlyingAssetAddress;","after":"address public immutable underlyingAssetAddress;","contract":"AToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"AToken","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"AToken","time":0},{"type":"immutable-restrict-modification ","before":"uint8 private _decimals;","after":"uint8 private immutable _decimals;","contract":"AToken","time":0},{"type":"de-morgan-condition ","before":"!user.useAsCollateral ||\n\n        !reserve.usageAsCollateralEnabled","after":"!(user.useAsCollateral ||\n\n        reserve.usageAsCollateralEnabled)","loc":{"start":{"line":7282,"column":8},"end":{"line":7284,"column":17}},"contract":"LendingPoolCore","time":0},{"type":"external-function ","before":"function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes memory _params)\n\n    public\n\n    nonReentrant\n\n    onlyActiveReserve(_reserve)\n\n    onlyAmountGreaterThanZero(_amount)\n\n    {\n\n        //check that the reserve has enough available liquidity\n\n        //we avoid using the getAvailableLiquidity() function in LendingPoolCore to save gas\n\n        uint256 availableLiquidityBefore = _reserve == EthAddressLib.ethAddress()\n\n        ? address(core).balance\n\n        : IERC20(_reserve).balanceOf(address(core));\n\n\n        require(\n\n            availableLiquidityBefore >= _amount,\n\n            \"There is not enough liquidity available to borrow\"\n\n        );\n\n\n        (uint256 totalFeeBips, uint256 protocolFeeBips) = parametersProvider\n\n        .getFlashLoanFeesInBips();\n\n        //calculate amount fee\n\n        uint256 amountFee = _amount.mul(totalFeeBips).div(10000);\n\n\n        //protocol fee is the part of the amountFee reserved for the protocol - the rest goes to depositors\n\n        uint256 protocolFee = amountFee.mul(protocolFeeBips).div(10000);\n\n        require(\n\n            amountFee > 0 && protocolFee > 0,\n\n            \"The requested amount is too small for a flashLoan.\"\n\n        );\n\n\n        //get the FlashLoanReceiver instance\n\n        IFlashLoanReceiver receiver = IFlashLoanReceiver(_receiver);\n\n\n        address payable userPayable = address(uint160(_receiver));\n\n\n        //transfer funds to the receiver\n\n        core.transferToUser(_reserve, userPayable, _amount);\n\n\n        //execute action of the receiver\n\n        receiver.executeOperation(_reserve, _amount, amountFee, _params);\n\n\n        //check that the actual balance of the core contract includes the returned amount\n\n        uint256 availableLiquidityAfter = _reserve == EthAddressLib.ethAddress()\n\n        ? address(core).balance\n\n        : IERC20(_reserve).balanceOf(address(core));\n\n\n        require(\n\n            availableLiquidityAfter == availableLiquidityBefore.add(amountFee),\n\n            \"The actual balance of the protocol is inconsistent\"\n\n        );\n\n\n        core.updateStateOnFlashLoan(\n\n            _reserve,\n\n            availableLiquidityBefore,\n\n            amountFee.sub(protocolFee),\n\n            protocolFee\n\n        );\n\n\n        //solium-disable-next-line\n\n        emit FlashLoan(_receiver, _reserve, _amount, amountFee, protocolFee, block.timestamp);\n\n    }","after":"function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes calldata _params)\n\n    public\n\n    nonReentrant\n\n    onlyActiveReserve(_reserve)\n\n    onlyAmountGreaterThanZero(_amount)\n\n    {\n\n        //check that the reserve has enough available liquidity\n\n        //we avoid using the getAvailableLiquidity() function in LendingPoolCore to save gas\n\n        uint256 availableLiquidityBefore = _reserve == EthAddressLib.ethAddress()\n\n        ? address(core).balance\n\n        : IERC20(_reserve).balanceOf(address(core));\n\n\n        require(\n\n            availableLiquidityBefore >= _amount,\n\n            \"There is not enough liquidity available to borrow\"\n\n        );\n\n\n        (uint256 totalFeeBips, uint256 protocolFeeBips) = parametersProvider\n\n        .getFlashLoanFeesInBips();\n\n        //calculate amount fee\n\n        uint256 amountFee = _amount.mul(totalFeeBips).div(10000);\n\n\n        //protocol fee is the part of the amountFee reserved for the protocol - the rest goes to depositors\n\n        uint256 protocolFee = amountFee.mul(protocolFeeBips).div(10000);\n\n        require(\n\n            amountFee > 0 && protocolFee > 0,\n\n            \"The requested amount is too small for a flashLoan.\"\n\n        );\n\n\n        //get the FlashLoanReceiver instance\n\n        IFlashLoanReceiver receiver = IFlashLoanReceiver(_receiver);\n\n\n        address payable userPayable = address(uint160(_receiver));\n\n\n        //transfer funds to the receiver\n\n        core.transferToUser(_reserve, userPayable, _amount);\n\n\n        //execute action of the receiver\n\n        receiver.executeOperation(_reserve, _amount, amountFee, _params);\n\n\n        //check that the actual balance of the core contract includes the returned amount\n\n        uint256 availableLiquidityAfter = _reserve == EthAddressLib.ethAddress()\n\n        ? address(core).balance\n\n        : IERC20(_reserve).balanceOf(address(core));\n\n\n        require(\n\n            availableLiquidityAfter == availableLiquidityBefore.add(amountFee),\n\n            \"The actual balance of the protocol is inconsistent\"\n\n        );\n\n\n        core.updateStateOnFlashLoan(\n\n            _reserve,\n\n            availableLiquidityBefore,\n\n            amountFee.sub(protocolFee),\n\n            protocolFee\n\n        );\n\n\n        //solium-disable-next-line\n\n        emit FlashLoan(_receiver, _reserve, _amount, amountFee, protocolFee, block.timestamp);\n\n    }","contract":"LendingPool","time":1},{"type":"constant-restrict-modification  ","before":"address ethereumAddress;","after":"address constant ethereumAddress;","contract":"LendingPoolLiquidationManager","time":0}]}