{"time":461,"results":[{"type":"state-data-arrangement ","before":"\n\n\n    bool public constant IS_RARI_FUND_CONTROLLER =\n\n\n    bool private _fundDis\n\n\n    address payable private _rariFundManagerCon\n\n\n    address private _rariFundRebalancerAd\n\n\n    uint8[] private _supported\n\n\n    address constant private COMP_TOKEN = 0xc00e94Cb662C3520282E6f5717214004A7f\n\n\n    IEtherToken constant private _weth = IEtherToken(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C75\n\n\n    uint256[] private _cachedBal\n\n\n    mapping(uint8 => bool) _poolsWith\n\n\n    uint16 _aaveReferra","after":"\n\n    uint8[] private _supported\n\n\n    IEtherToken constant private _weth = IEtherToken(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C75\n\n\n    uint256[] private _cachedBal\n\n\n    mapping(uint8 => bool) _poolsWith\n\n\n    address payable private _rariFundManagerCon\n\n\n    address private _rariFundRebalancerAd\n\n\n    address constant private COMP_TOKEN = 0xc00e94Cb662C3520282E6f5717214004A7f\n\n\n    uint16 _aaveReferra\n\n\n    bool public constant IS_RARI_FUND_CONTROLLER =\n\n\n    bool private _fundDis\n","contract":"RariFundController","time":0},{"type":"external-function ","before":"\n\n    function marketSell0xOrdersFillOrKill(LibOrder.Order[] memory orders, bytes[] memory signatures, uint256 takerAssetFillAmount) public payable fundEnabled onlyRebalancer {\n\n        // Exchange COMP to ETH\n\n        uint256 ethBalanceBefore = address(this).balance;\n\n        uint256[2] memory filledAmounts = ZeroExExchangeController.marketSellOrdersFillOrKill(orders, signatures, takerAssetFillAmount, msg.value);\n\n        uint256 ethBalanceAfter = address(this).balance;\n\n        emit CompToEthTrade(filledAmounts[0], filledAmounts[1]);\n\n\n        // Unwrap outputted WETH\n\n        uint256 wethBalance = _weth.balanceOf(address(this));\n\n        require(wethBalance > 0, \"No WETH outputted.\");\n\n        _weth.withdraw(wethBalance);\n\n\n        // Refund unspent ETH protocol fee\n\n        uint256 refund = ethBalanceAfter.sub(ethBalanceBefore.sub(msg.value));\n\n\n        if (refund > 0) {\n\n            (bool success,) = msg.sender.call.value(refund)(\"\");\n\n            require(success, \"Failed to refund unspent ETH protocol fee.\");\n\n        }\n","after":"\n\n    function marketSell0xOrdersFillOrKill(LibOrder.Order[] calldata orders, bytes[] calldata signatures, uint256 takerAssetFillAmount) public payable fundEnabled onlyRebalancer {\n\n        // Exchange COMP to ETH\n\n        uint256 ethBalanceBefore = address(this).balance;\n\n        uint256[2] memory filledAmounts = ZeroExExchangeController.marketSellOrdersFillOrKill(orders, signatures, takerAssetFillAmount, msg.value);\n\n        uint256 ethBalanceAfter = address(this).balance;\n\n        emit CompToEthTrade(filledAmounts[0], filledAmounts[1]);\n\n\n        // Unwrap outputted WETH\n\n        uint256 wethBalance = _weth.balanceOf(address(this));\n\n        require(wethBalance > 0, \"No WETH outputted.\");\n\n        _weth.withdraw(wethBalance);\n\n\n        // Refund unspent ETH protocol fee\n\n        uint256 refund = ethBalanceAfter.sub(ethBalanceBefore.sub(msg.value));\n\n\n        if (refund > 0) {\n\n            (bool success,) = msg.sender.call.value(refund)(\"\");\n\n            require(success, \"Failed to refund unspent ETH protocol fee.\");\n\n        }\n","contract":"RariFundController","time":0},{"type":"external-function ","before":"*/\n\n    function exchangeAndDeposit(address inputErc20Contract, uint256 inputAmount, LibOrder.Order[] memory orders, bytes[] memory signatures, uint256 takerAssetFillAmount) public payable {\n\n        // Input validation\n\n        require(_rariFundManagerContract != address(0), \"Fund manager contract not set. This may be due to an upgrade of this proxy contract.\");\n\n        require(inputAmount > 0, \"Input amount must be greater than 0.\");\n\n        require(inputErc20Contract != 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, \"Input and output currencies cannot be the same.\");\n\n        require(orders.length > 0, \"Orders array is empty.\");\n\n        require(orders.length == signatures.length, \"Length of orders and signatures arrays must be equal.\");\n\n        require(takerAssetFillAmount > 0, \"Taker asset fill amount must be greater than 0.\");\n\n\n        // Transfer input tokens from msg.sender if not inputting ETH\n\n        IERC20(inputErc20Contract).safeTransferFrom(msg.sender, address(this), inputAmount);\n        // The user must approve the transfer of tokens beforehand\n\n\n\n        // Approve and exchange tokens\n\n        if (inputAmount > ZeroExExchangeController.allowance(inputErc20Contract)) ZeroExExchangeController.approve(inputErc20Contract, uint256(- 1));\n\n        uint256[2] memory filledAmounts = ZeroExExchangeController.marketSellOrdersFillOrKill(orders, signatures, takerAssetFillAmount, msg.value);\n\n\n        // Unwrap outputted WETH\n\n        uint256 wethBalance = _weth.balanceOf(address(this));\n\n        require(wethBalance > 0, \"No WETH outputted.\");\n\n        _weth.withdraw(wethBalance);\n\n\n        // Refund unused input tokens\n\n        IERC20 inputToken = IERC20(inputErc20Contract);\n\n        uint256 inputTokenBalance = inputToken.balanceOf(address(this));\n\n        if (inputTokenBalance > 0) inputToken.safeTransfer(msg.sender, inputTokenBalance);\n\n\n        // Emit event\n\n        emit PreDepositExchange(inputErc20Contract, msg.sender, filledAmounts[0], filledAmounts[1]);\n\n\n        // Deposit output tokens\n\n        rariFundManager.depositTo.value(wethBalance)(msg.sender)","after":"*/\n\n    function exchangeAndDeposit(address inputErc20Contract, uint256 inputAmount, LibOrder.Order[] calldata orders, bytes[] calldata signatures, uint256 takerAssetFillAmount) public payable {\n\n        // Input validation\n\n        require(_rariFundManagerContract != address(0), \"Fund manager contract not set. This may be due to an upgrade of this proxy contract.\");\n\n        require(inputAmount > 0, \"Input amount must be greater than 0.\");\n\n        require(inputErc20Contract != 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, \"Input and output currencies cannot be the same.\");\n\n        require(orders.length > 0, \"Orders array is empty.\");\n\n        require(orders.length == signatures.length, \"Length of orders and signatures arrays must be equal.\");\n\n        require(takerAssetFillAmount > 0, \"Taker asset fill amount must be greater than 0.\");\n\n\n        // Transfer input tokens from msg.sender if not inputting ETH\n\n        IERC20(inputErc20Contract).safeTransferFrom(msg.sender, address(this), inputAmount);\n        // The user must approve the transfer of tokens beforehand\n\n\n\n        // Approve and exchange tokens\n\n        if (inputAmount > ZeroExExchangeController.allowance(inputErc20Contract)) ZeroExExchangeController.approve(inputErc20Contract, uint256(- 1));\n\n        uint256[2] memory filledAmounts = ZeroExExchangeController.marketSellOrdersFillOrKill(orders, signatures, takerAssetFillAmount, msg.value);\n\n\n        // Unwrap outputted WETH\n\n        uint256 wethBalance = _weth.balanceOf(address(this));\n\n        require(wethBalance > 0, \"No WETH outputted.\");\n\n        _weth.withdraw(wethBalance);\n\n\n        // Refund unused input tokens\n\n        IERC20 inputToken = IERC20(inputErc20Contract);\n\n        uint256 inputTokenBalance = inputToken.balanceOf(address(this));\n\n        if (inputTokenBalance > 0) inputToken.safeTransfer(msg.sender, inputTokenBalance);\n\n\n        // Emit event\n\n        emit PreDepositExchange(inputErc20Contract, msg.sender, filledAmounts[0], filledAmounts[1]);\n\n\n        // Deposit output tokens\n\n        rariFundManager.depositTo.value(wethBalance)(msg.sender)","contract":"RariFundProxy","time":0},{"type":"external-function ","before":"*/\n\n    function withdrawAndExchange(uint256 inputAmount, address outputErc20Contract, LibOrder.Order[] memory orders, bytes[] memory signatures, uint256 makerAssetFillAmount) public payable {\n\n        // Input validation\n\n        require(inputAmount > 0, \"Input amount must be greater than 0.\");\n\n        require(outputErc20Contract != 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, \"Input and output currencies cannot be the same.\");\n\n        require(makerAssetFillAmount > 0, \"Maker asset amount must be greater than 0.\");\n\n        require(orders.length > 0 && signatures.length > 0, \"Must supply more than 0 orders and signatures.\");\n\n        require(orders.length == signatures.length, \"Lengths of all orders and signatures arrays must be equal.\");\n\n        require(_rariFundManagerContract != address(0), \"Fund manager contract not set. This may be due to an upgrade of this proxy contract.\");\n\n\n        // Withdraw input tokens\n\n        rariFundManager.withdrawFrom(msg.sender, inputAmount);\n\n\n        // Wrap ETH for exchanging with 0x\n\n        _weth.deposit.value(inputAmount)();\n\n\n        // Exchange tokens and emit event\n\n        uint256[2] memory filledAmounts = ZeroExExchangeController.marketBuyOrdersFillOrKill(orders, signatures, makerAssetFillAmount, msg.value);\n\n        emit PostWithdrawalExchange(outputErc20Contract, msg.sender, filledAmounts[0], filledAmounts[1]);\n\n\n        // Unwrap unused WETH\n\n        uint256 wethBalance = _weth.balanceOf(address(this));\n\n        _weth.withdraw(wethBalance);\n\n\n        // Forward output tokens\n\n        IERC20 outputToken = IERC20(outputErc20Contract);\n\n        uint256 outputTokenBalance = outputToken.balanceOf(address(this));\n\n        if (outputTokenBalance > 0) outputToken.safeTransfer(msg.sender, outputTokenBalance);\n\n\n        // Forward unused ETH\n\n        uint256 ethBalance = address(this).balance;\n\n\n        if (ethBalance > 0) {\n\n            (bool success,) = msg.sender.call.value(ethBalance)(\"\");\n\n            require(success, \"Failed to transfer ETH to msg.sender after exchange.\");\n\n        ","after":"*/\n\n    function withdrawAndExchange(uint256 inputAmount, address outputErc20Contract, LibOrder.Order[] calldata orders, bytes[] calldata signatures, uint256 makerAssetFillAmount) public payable {\n\n        // Input validation\n\n        require(inputAmount > 0, \"Input amount must be greater than 0.\");\n\n        require(outputErc20Contract != 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2, \"Input and output currencies cannot be the same.\");\n\n        require(makerAssetFillAmount > 0, \"Maker asset amount must be greater than 0.\");\n\n        require(orders.length > 0 && signatures.length > 0, \"Must supply more than 0 orders and signatures.\");\n\n        require(orders.length == signatures.length, \"Lengths of all orders and signatures arrays must be equal.\");\n\n        require(_rariFundManagerContract != address(0), \"Fund manager contract not set. This may be due to an upgrade of this proxy contract.\");\n\n\n        // Withdraw input tokens\n\n        rariFundManager.withdrawFrom(msg.sender, inputAmount);\n\n\n        // Wrap ETH for exchanging with 0x\n\n        _weth.deposit.value(inputAmount)();\n\n\n        // Exchange tokens and emit event\n\n        uint256[2] memory filledAmounts = ZeroExExchangeController.marketBuyOrdersFillOrKill(orders, signatures, makerAssetFillAmount, msg.value);\n\n        emit PostWithdrawalExchange(outputErc20Contract, msg.sender, filledAmounts[0], filledAmounts[1]);\n\n\n        // Unwrap unused WETH\n\n        uint256 wethBalance = _weth.balanceOf(address(this));\n\n        _weth.withdraw(wethBalance);\n\n\n        // Forward output tokens\n\n        IERC20 outputToken = IERC20(outputErc20Contract);\n\n        uint256 outputTokenBalance = outputToken.balanceOf(address(this));\n\n        if (outputTokenBalance > 0) outputToken.safeTransfer(msg.sender, outputTokenBalance);\n\n\n        // Forward unused ETH\n\n        uint256 ethBalance = address(this).balance;\n\n\n        if (ethBalance > 0) {\n\n            (bool success,) = msg.sender.call.value(ethBalance)(\"\");\n\n            require(success, \"Failed to transfer ETH to msg.sender after exchange.\");\n\n        ","contract":"RariFundProxy","time":0},{"type":"external-function ","before":"   function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n  ","after":"   function initialize(string calldata name, string calldata symbol, uint8 decimals) public initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n  ","contract":"RariFundToken","time":0}]}