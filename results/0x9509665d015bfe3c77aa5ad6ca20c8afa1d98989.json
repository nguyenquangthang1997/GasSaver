{"time":196,"results":[{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC20","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC20","time":0},{"type":"state-data-arrangement ","before":"\nTokenTransferProxy private _tokenTransferProxy;\nbool private _paused;\nIWhitelisted private _whitelisted;\nIPartnerRegistry private _partnerRegistry;\naddress payable private _feeWallet;\nstring private _version = \"2.0.0\";","after":"TokenTransferProxy private _tokenTransferProxy;\nIWhitelisted private _whitelisted;\nIPartnerRegistry private _partnerRegistry;\nstring private _version = \"2.0.0\";\naddress payable private _feeWallet;\nbool private _paused;\n","contract":"AugustusSwapper","time":0},{"type":"external-function ","before":"function multiSwap(\n\n        IERC20 fromToken,\n\n        IERC20 toToken,\n\n        uint256 fromAmount,\n\n        uint256 toAmount,\n\n        uint256 expectedAmount,\n\n        Utils.Path[] memory path,\n\n        uint256 mintPrice,\n\n        address payable beneficiary,\n\n        uint256 donationBasisPoints,\n\n        string memory referrer\n\n    )\n\n    public\n\n    payable\n\n    whenNotPaused\n\n    returns (uint256)\n\n    {\n\n        //Referral id can never be empty\n\n        require(bytes(referrer).length > 0, \"Invalid referrer\");\n\n\n        require(donationBasisPoints <= 10000, \"Invalid value\");\n\n\n        require(toAmount > 0, \"To amount can not be 0\");\n\n\n        uint256 receivedAmount = performSwap(\n\n            fromToken,\n\n            toToken,\n\n            fromAmount,\n\n            toAmount,\n\n            path,\n\n            mintPrice\n\n        );\n\n\n        takeFeeAndTransferTokens(\n\n            toToken,\n\n            toAmount,\n\n            receivedAmount,\n\n            beneficiary,\n\n            donationBasisPoints,\n\n            referrer\n\n        );\n\n\n        //If any ether is left at this point then we transfer it back to the user\n\n        uint256 remEthBalance = Utils.tokenBalance(\n\n            Utils.ethAddress(),\n\n            address(this)\n\n        );\n\n        if (remEthBalance > 0) {\n\n            msg.sender.transfer(remEthBalance);\n\n        }\n\n\n        //Contract should not have any remaining balance after entire execution\n\n        require(\n\n            Utils.tokenBalance(address(toToken), address(this)) == 0,\n\n            \"Destination tokens are stuck\"\n\n        );\n\n\n        emit Swapped(\n\n            msg.sender,\n\n            beneficiary == address(0) ? msg.sender : beneficiary,\n\n            address(fromToken),\n\n            address(toToken),\n\n            fromAmount,\n\n            receivedAmount,\n\n            expectedAmount,\n\n            referrer\n\n        );\n\n\n        return receivedAmount;\n\n    }","after":"function multiSwap(\n\n        IERC20 fromToken,\n\n        IERC20 toToken,\n\n        uint256 fromAmount,\n\n        uint256 toAmount,\n\n        uint256 expectedAmount,\n\n        Utils.Path[] calldata path,\n\n        uint256 mintPrice,\n\n        address payable beneficiary,\n\n        uint256 donationBasisPoints,\n\n        string calldata referrer\n\n    )\n\n    public\n\n    payable\n\n    whenNotPaused\n\n    returns (uint256)\n\n    {\n\n        //Referral id can never be empty\n\n        require(bytes(referrer).length > 0, \"Invalid referrer\");\n\n\n        require(donationBasisPoints <= 10000, \"Invalid value\");\n\n\n        require(toAmount > 0, \"To amount can not be 0\");\n\n\n        uint256 receivedAmount = performSwap(\n\n            fromToken,\n\n            toToken,\n\n            fromAmount,\n\n            toAmount,\n\n            path,\n\n            mintPrice\n\n        );\n\n\n        takeFeeAndTransferTokens(\n\n            toToken,\n\n            toAmount,\n\n            receivedAmount,\n\n            beneficiary,\n\n            donationBasisPoints,\n\n            referrer\n\n        );\n\n\n        //If any ether is left at this point then we transfer it back to the user\n\n        uint256 remEthBalance = Utils.tokenBalance(\n\n            Utils.ethAddress(),\n\n            address(this)\n\n        );\n\n        if (remEthBalance > 0) {\n\n            msg.sender.transfer(remEthBalance);\n\n        }\n\n\n        //Contract should not have any remaining balance after entire execution\n\n        require(\n\n            Utils.tokenBalance(address(toToken), address(this)) == 0,\n\n            \"Destination tokens are stuck\"\n\n        );\n\n\n        emit Swapped(\n\n            msg.sender,\n\n            beneficiary == address(0) ? msg.sender : beneficiary,\n\n            address(fromToken),\n\n            address(toToken),\n\n            fromAmount,\n\n            receivedAmount,\n\n            expectedAmount,\n\n            referrer\n\n        );\n\n\n        return receivedAmount;\n\n    }","contract":"AugustusSwapper","time":0},{"type":"external-function ","before":"function buy(\n\n        IERC20 fromToken,\n\n        IERC20 toToken,\n\n        uint256 fromAmount,\n\n        uint256 toAmount,\n\n        uint256 expectedAmount,\n\n        Utils.BuyRoute[] memory route,\n\n        uint256 mintPrice,\n\n        address payable beneficiary,\n\n        uint256 donationBasisPoints,\n\n        string memory referrer\n\n    )\n\n    public\n\n    payable\n\n    whenNotPaused\n\n    returns (uint256)\n\n    {\n\n        //Referral id can never be empty\n\n        require(bytes(referrer).length > 0, \"Invalid referrer\");\n\n\n        require(donationBasisPoints <= 10000, \"Invalid value\");\n\n\n        require(toAmount > 0, \"To amount can not be 0\");\n\n\n        uint256 receivedAmount = performBuy(\n\n            fromToken,\n\n            toToken,\n\n            fromAmount,\n\n            toAmount,\n\n            route,\n\n            mintPrice\n\n        );\n\n\n        takeFeeAndTransferTokens(\n\n            toToken,\n\n            toAmount,\n\n            receivedAmount,\n\n            beneficiary,\n\n            donationBasisPoints,\n\n            referrer\n\n        );\n\n\n        uint256 remainingAmount = Utils.tokenBalance(\n\n            address(fromToken),\n\n            address(this)\n\n        );\n\n        Utils.transferTokens(address(fromToken), msg.sender, remainingAmount);\n\n\n        //If any ether is left at this point then we transfer it back to the user\n\n        remainingAmount = Utils.tokenBalance(\n\n            Utils.ethAddress(),\n\n            address(this)\n\n        );\n\n        if (remainingAmount > 0) {\n\n            Utils.transferTokens(Utils.ethAddress(), msg.sender, remainingAmount);\n\n        }\n\n\n        //Contract should not have any remaining balance after entire execution\n\n        require(\n\n            Utils.tokenBalance(address(toToken), address(this)) == 0,\n\n            \"Destination tokens are stuck\"\n\n        );\n\n\n        emit Bought(\n\n            msg.sender,\n\n            beneficiary == address(0) ? msg.sender : beneficiary,\n\n            address(fromToken),\n\n            address(toToken),\n\n            fromAmount,\n\n            receivedAmount,\n\n            expectedAmount,\n\n            referrer\n\n        );\n\n\n        return receivedAmount;\n\n    }","after":"function buy(\n\n        IERC20 fromToken,\n\n        IERC20 toToken,\n\n        uint256 fromAmount,\n\n        uint256 toAmount,\n\n        uint256 expectedAmount,\n\n        Utils.BuyRoute[] calldata route,\n\n        uint256 mintPrice,\n\n        address payable beneficiary,\n\n        uint256 donationBasisPoints,\n\n        string calldata referrer\n\n    )\n\n    public\n\n    payable\n\n    whenNotPaused\n\n    returns (uint256)\n\n    {\n\n        //Referral id can never be empty\n\n        require(bytes(referrer).length > 0, \"Invalid referrer\");\n\n\n        require(donationBasisPoints <= 10000, \"Invalid value\");\n\n\n        require(toAmount > 0, \"To amount can not be 0\");\n\n\n        uint256 receivedAmount = performBuy(\n\n            fromToken,\n\n            toToken,\n\n            fromAmount,\n\n            toAmount,\n\n            route,\n\n            mintPrice\n\n        );\n\n\n        takeFeeAndTransferTokens(\n\n            toToken,\n\n            toAmount,\n\n            receivedAmount,\n\n            beneficiary,\n\n            donationBasisPoints,\n\n            referrer\n\n        );\n\n\n        uint256 remainingAmount = Utils.tokenBalance(\n\n            address(fromToken),\n\n            address(this)\n\n        );\n\n        Utils.transferTokens(address(fromToken), msg.sender, remainingAmount);\n\n\n        //If any ether is left at this point then we transfer it back to the user\n\n        remainingAmount = Utils.tokenBalance(\n\n            Utils.ethAddress(),\n\n            address(this)\n\n        );\n\n        if (remainingAmount > 0) {\n\n            Utils.transferTokens(Utils.ethAddress(), msg.sender, remainingAmount);\n\n        }\n\n\n        //Contract should not have any remaining balance after entire execution\n\n        require(\n\n            Utils.tokenBalance(address(toToken), address(this)) == 0,\n\n            \"Destination tokens are stuck\"\n\n        );\n\n\n        emit Bought(\n\n            msg.sender,\n\n            beneficiary == address(0) ? msg.sender : beneficiary,\n\n            address(fromToken),\n\n            address(toToken),\n\n            fromAmount,\n\n            receivedAmount,\n\n            expectedAmount,\n\n            referrer\n\n        );\n\n\n        return receivedAmount;\n\n    }","contract":"AugustusSwapper","time":0},{"type":"constant-restrict-modification  ","before":"string private _version = \"2.0.0\";","after":"string private constant _version = \"2.0.0\";","contract":"AugustusSwapper","time":0}]}