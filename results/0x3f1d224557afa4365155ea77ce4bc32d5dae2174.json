{"time":657,"results":[{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC20","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC20","time":0},{"type":"external-function ","before":"function initialize(string memory name, string memory symbol)\n    external\n    initializer\n    returns (bool)\n    {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __Ownable_init_unchained();\n        return true;\n    }","after":"function initialize(string calldata name, string calldata symbol)\n    external\n    initializer\n    returns (bool)\n    {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __Ownable_init_unchained();\n        return true;\n    }","contract":"LPToken","time":0},{"type":"external-function ","before":"function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual override initializer {\n        revert(\"use initializeMetaSwap() instead\");\n    }","after":"function initialize(\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual override initializer {\n        revert(\"use initializeMetaSwap() instead\");\n    }","contract":"MetaSwap","time":0},{"type":"external-function ","before":"function initializeMetaSwap(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress,\n        ISwap baseSwap\n    ) external virtual initializer {\n        Swap.initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress\n        );\n\n        // MetaSwap initializer\n        metaSwapStorage.baseSwap = baseSwap;\n        metaSwapStorage.baseVirtualPrice = baseSwap.getVirtualPrice();\n        metaSwapStorage.baseCacheLastUpdated = block.timestamp;\n\n        // Read all tokens that belong to baseSwap\n        {\n            uint8 i;\n            for (; i < 32; i++) {\n                try baseSwap.getToken(i) returns (IERC20 token) {\n                    metaSwapStorage.baseTokens.push(token);\n                    token.safeApprove(address(baseSwap), MAX_UINT256);\n                } catch {\n                    break;\n                }\n            }\n            require(i > 1, \"baseSwap must pool at least 2 tokens\");\n        }\n\n        // Check the last element of _pooledTokens is owned by baseSwap\n        IERC20 baseLPToken = _pooledTokens[_pooledTokens.length - 1];\n        require(\n            LPToken(address(baseLPToken)).owner() == address(baseSwap),\n            \"baseLPToken is not owned by baseSwap\"\n        );\n\n        // Pre-approve the baseLPToken to be used by baseSwap\n        baseLPToken.safeApprove(address(baseSwap), MAX_UINT256);\n    }","after":"function initializeMetaSwap(\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress,\n        ISwap baseSwap\n    ) external virtual initializer {\n        Swap.initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress\n        );\n\n        // MetaSwap initializer\n        metaSwapStorage.baseSwap = baseSwap;\n        metaSwapStorage.baseVirtualPrice = baseSwap.getVirtualPrice();\n        metaSwapStorage.baseCacheLastUpdated = block.timestamp;\n\n        // Read all tokens that belong to baseSwap\n        {\n            uint8 i;\n            for (; i < 32; i++) {\n                try baseSwap.getToken(i) returns (IERC20 token) {\n                    metaSwapStorage.baseTokens.push(token);\n                    token.safeApprove(address(baseSwap), MAX_UINT256);\n                } catch {\n                    break;\n                }\n            }\n            require(i > 1, \"baseSwap must pool at least 2 tokens\");\n        }\n\n        // Check the last element of _pooledTokens is owned by baseSwap\n        IERC20 baseLPToken = _pooledTokens[_pooledTokens.length - 1];\n        require(\n            LPToken(address(baseLPToken)).owner() == address(baseSwap),\n            \"baseLPToken is not owned by baseSwap\"\n        );\n\n        // Pre-approve the baseLPToken to be used by baseSwap\n        baseLPToken.safeApprove(address(baseSwap), MAX_UINT256);\n    }","contract":"MetaSwap","time":0},{"type":"external-function ","before":"function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual initializer {\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                    _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            precisionMultipliers[i] =\n            10 **\n            uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(\n                uint256(decimals[i])\n            );\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < AmplificationUtils.MAX_A, \"_a exceeds maximum\");\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < SwapUtils.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n\n        // Clone and initialize a LPToken contract\n        LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n        require(\n            lpToken.initialize(lpTokenName, lpTokenSymbol),\n            \"could not init lpToken clone\"\n        );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = lpToken;\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a.mul(AmplificationUtils.A_PRECISION);\n        swapStorage.futureA = _a.mul(AmplificationUtils.A_PRECISION);\n        // swapStorage.initialATime = 0;\n        // swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n    }","after":"function initialize(\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual initializer {\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                    _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            precisionMultipliers[i] =\n            10 **\n            uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(\n                uint256(decimals[i])\n            );\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < AmplificationUtils.MAX_A, \"_a exceeds maximum\");\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < SwapUtils.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n\n        // Clone and initialize a LPToken contract\n        LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n        require(\n            lpToken.initialize(lpTokenName, lpTokenSymbol),\n            \"could not init lpToken clone\"\n        );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = lpToken;\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a.mul(AmplificationUtils.A_PRECISION);\n        swapStorage.futureA = _a.mul(AmplificationUtils.A_PRECISION);\n        // swapStorage.initialATime = 0;\n        // swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n    }","contract":"MetaSwap","time":0},{"type":"loop-duplication","before":"\nstart line 3274 column 12, end line 3279 column 12\nfor (uint256 i = 0; i < v.newBalances.length; i++) {\n                balances1[i] = v.newBalances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\nstart line 3285 column 12, end line 3293 column 12\nfor (uint256 i = 0; i < v.newBalances.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.newBalances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }","after":"// merge loop\n\nstart line 3274 column 12, end line 3279 column 12\nfor (uint256 i = 0; i < v.newBalances.length; i++) {\n                balances1[i] = v.newBalances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\nstart line 3285 column 12, end line 3293 column 12\nfor (uint256 i = 0; i < v.newBalances.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.newBalances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }","contract":"MetaSwapUtils","time":0},{"type":"struct-data-arrangement ","before":"\nuint256 x\nuint256 dx\nuint256 dy\nuint256[] tokenPrecisionMultipliers\nuint256[] oldBalances\nIERC20[] baseTokens\nIERC20 tokenFrom\nuint8 metaIndexFrom\nIERC20 tokenTo\nuint8 metaIndexTo\nuint256 baseVirtualPrice","after":"uint256 x\nuint256 dx\nuint256 dy\nuint256[] tokenPrecisionMultipliers\nuint256[] oldBalances\nIERC20[] baseTokens\nIERC20 tokenFrom\nIERC20 tokenTo\nuint256 baseVirtualPrice\nuint8 metaIndexFrom\nuint8 metaIndexTo\n","contract":"MetaSwapUtils","time":0},{"type":"external-function ","before":"function removeLiquidityImbalance(\n        SwapUtils.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint256[] memory amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        // Using this struct to avoid stack too deep error\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            self.lpToken,\n            0,\n            self._getAPrecise(),\n            _updateBaseVirtualPrice(metaSwapStorage),\n            self.tokenPrecisionMultipliers,\n            self.balances\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        require(\n            amounts.length == v.newBalances.length,\n            \"Amounts should match pool tokens\"\n        );\n        require(maxBurnAmount != 0, \"Must burn more than 0\");\n\n        uint256 feePerToken = SwapUtils._feePerToken(\n            self.swapFee,\n            v.newBalances.length\n        );\n\n        // Calculate how much LPToken should be burned\n        uint256[] memory fees = new uint256[](v.newBalances.length);\n        {\n            uint256[] memory balances1 = new uint256[](v.newBalances.length);\n\n            v.d0 = SwapUtils.getD(\n                _xp(\n                    v.newBalances,\n                    v.tokenPrecisionMultipliers,\n                    v.baseVirtualPrice\n                ),\n                v.preciseA\n            );\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\n                balances1[i] = v.newBalances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n            v.d1 = SwapUtils.getD(\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\n                v.preciseA\n            );\n\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.newBalances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }\n\n            v.d2 = SwapUtils.getD(\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\n                v.preciseA\n            );\n        }\n\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n\n        // Scale up by withdraw fee\n        tokenAmount = tokenAmount.add(1);\n\n        // Check for max burn amount\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        // Burn the calculated amount of LPToken from the caller and send the desired tokens\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n        for (uint256 i = 0; i < v.newBalances.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }","after":"function removeLiquidityImbalance(\n        SwapUtils.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        // Using this struct to avoid stack too deep error\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            self.lpToken,\n            0,\n            self._getAPrecise(),\n            _updateBaseVirtualPrice(metaSwapStorage),\n            self.tokenPrecisionMultipliers,\n            self.balances\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        require(\n            amounts.length == v.newBalances.length,\n            \"Amounts should match pool tokens\"\n        );\n        require(maxBurnAmount != 0, \"Must burn more than 0\");\n\n        uint256 feePerToken = SwapUtils._feePerToken(\n            self.swapFee,\n            v.newBalances.length\n        );\n\n        // Calculate how much LPToken should be burned\n        uint256[] memory fees = new uint256[](v.newBalances.length);\n        {\n            uint256[] memory balances1 = new uint256[](v.newBalances.length);\n\n            v.d0 = SwapUtils.getD(\n                _xp(\n                    v.newBalances,\n                    v.tokenPrecisionMultipliers,\n                    v.baseVirtualPrice\n                ),\n                v.preciseA\n            );\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\n                balances1[i] = v.newBalances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n            v.d1 = SwapUtils.getD(\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\n                v.preciseA\n            );\n\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.newBalances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }\n\n            v.d2 = SwapUtils.getD(\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\n                v.preciseA\n            );\n        }\n\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n\n        // Scale up by withdraw fee\n        tokenAmount = tokenAmount.add(1);\n\n        // Check for max burn amount\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        // Burn the calculated amount of LPToken from the caller and send the desired tokens\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n        for (uint256 i = 0; i < v.newBalances.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }","contract":"MetaSwapUtils","time":0},{"type":"loop-duplication","before":"\nstart line 5633 column 12, end line 5638 column 12\nfor (uint256 i = 0; i < pooledTokens.length; i++) {\n                balances1[i] = v.balances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\nstart line 5641 column 12, end line 5649 column 12\nfor (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }","after":"// merge loop\n\nstart line 5633 column 12, end line 5638 column 12\nfor (uint256 i = 0; i < pooledTokens.length; i++) {\n                balances1[i] = v.balances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\nstart line 5641 column 12, end line 5649 column 12\nfor (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }","contract":"SwapUtils","time":0},{"type":"external-function ","before":"function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] memory amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            _getAPrecise(self),\n            self.lpToken,\n            0,\n            self.balances,\n            self.tokenPrecisionMultipliers\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        IERC20[] memory pooledTokens = self.pooledTokens;\n\n        require(\n            amounts.length == pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n\n        require(\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\n            maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n        {\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                balances1[i] = v.balances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }\n\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n        }\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1);\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }","after":"function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            _getAPrecise(self),\n            self.lpToken,\n            0,\n            self.balances,\n            self.tokenPrecisionMultipliers\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        IERC20[] memory pooledTokens = self.pooledTokens;\n\n        require(\n            amounts.length == pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n\n        require(\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\n            maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n        {\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                balances1[i] = v.balances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }\n\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n        }\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1);\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }","contract":"SwapUtils","time":0}]}