{"time":559,"results":[{"type":"loop-duplication","before":"\nstart line 2021 column 8, end line 2030 column 8\nfor (uint256 i = 0; i < mpIndexes.length; i++) {\n            console.log('checking token ', mpIndexes[i]);\n            console.log('quantity ', amounts[i]);\n            //console.log(woodiesMintPassportFactory.mintPasses(mpIndexs[i]));\n            require(amounts[i] > 0, \"Redeem: amount cannot be zero\");\n            require(amounts[i] <= redemptionWindows[mpIndexes[i]].maxRedeemPerTxn, \"Redeem: max redeem per transaction reached\");\n            require(woodiesMintPassportFactory.balanceOf(msg.sender, mpIndexes[i]) >= amounts[i], \"Redeem: insufficient amount of Mint Passports\");\n            require(block.timestamp > redemptionWindows[mpIndexes[i]].windowOpens, \"Redeem: redeption window not open for this Mint Passport\");\n            require(block.timestamp < redemptionWindows[mpIndexes[i]].windowCloses, \"Redeem: redeption window is closed for this Mint Passport\");\n        }\nstart line 2034 column 8, end line 2050 column 8\nfor (uint256 i = 0; i < mpIndexes.length; i++) {\n\n            woodiesMintPassportFactory.burnFromRedeem(msg.sender, mpIndexes[i], amounts[i]);\n            for (uint256 j = 0; j < amounts[i]; j++) {\n                _safeMint(msg.sender, mpIndexes[i] == 0 ? ultraDAOCounter.current() : generalCounter.current());\n                tokens = string(abi.encodePacked(tokens, mpIndexes[i] == 0 ? ultraDAOCounter.current().toString() : generalCounter.current().toString(), \",\"));\n                if (mpIndexes[i] == 0) {\n                    ultraDAOCounter.increment();\n                }\n                else {\n                    generalCounter.increment();\n                }\n\n            }\n\n            console.log('new token IDs redeemed:', tokens);\n        }","after":"// merge loop\n\nstart line 2021 column 8, end line 2030 column 8\nfor (uint256 i = 0; i < mpIndexes.length; i++) {\n            console.log('checking token ', mpIndexes[i]);\n            console.log('quantity ', amounts[i]);\n            //console.log(woodiesMintPassportFactory.mintPasses(mpIndexs[i]));\n            require(amounts[i] > 0, \"Redeem: amount cannot be zero\");\n            require(amounts[i] <= redemptionWindows[mpIndexes[i]].maxRedeemPerTxn, \"Redeem: max redeem per transaction reached\");\n            require(woodiesMintPassportFactory.balanceOf(msg.sender, mpIndexes[i]) >= amounts[i], \"Redeem: insufficient amount of Mint Passports\");\n            require(block.timestamp > redemptionWindows[mpIndexes[i]].windowOpens, \"Redeem: redeption window not open for this Mint Passport\");\n            require(block.timestamp < redemptionWindows[mpIndexes[i]].windowCloses, \"Redeem: redeption window is closed for this Mint Passport\");\n        }\nstart line 2034 column 8, end line 2050 column 8\nfor (uint256 i = 0; i < mpIndexes.length; i++) {\n\n            woodiesMintPassportFactory.burnFromRedeem(msg.sender, mpIndexes[i], amounts[i]);\n            for (uint256 j = 0; j < amounts[i]; j++) {\n                _safeMint(msg.sender, mpIndexes[i] == 0 ? ultraDAOCounter.current() : generalCounter.current());\n                tokens = string(abi.encodePacked(tokens, mpIndexes[i] == 0 ? ultraDAOCounter.current().toString() : generalCounter.current().toString(), \",\"));\n                if (mpIndexes[i] == 0) {\n                    ultraDAOCounter.increment();\n                }\n                else {\n                    generalCounter.increment();\n                }\n\n            }\n\n            console.log('new token IDs redeemed:', tokens);\n        }","contract":"Woodie","time":0},{"type":"external-function ","before":"function setBaseURI(string memory _baseTokenURI) external override onlyOwner {\n        baseTokenURI = _baseTokenURI;\n    }","after":"function setBaseURI(string calldata _baseTokenURI) external override onlyOwner {\n        baseTokenURI = _baseTokenURI;\n    }","contract":"Woodie","time":0},{"type":"external-function ","before":"function setIpfsURI(string memory _ipfsURI) external override onlyOwner {\n        ipfsURI = _ipfsURI;\n    }","after":"function setIpfsURI(string calldata _ipfsURI) external override onlyOwner {\n        ipfsURI = _ipfsURI;\n    }","contract":"Woodie","time":0},{"type":"external-function ","before":"function setIndividualTokenURI(uint256 id, string memory uri) external override {\n        require(hasRole(WOODIE_URI_UPDATER_ROLE, msg.sender), \"Access: sender does not have access\");\n        require(_exists(id), \"ERC721Metadata: Token does not exist\");\n        tokenData[id].tokenURI = uri;\n        tokenData[id].exists = true;\n    }","after":"function setIndividualTokenURI(uint256 id, string calldata uri) external override {\n        require(hasRole(WOODIE_URI_UPDATER_ROLE, msg.sender), \"Access: sender does not have access\");\n        require(_exists(id), \"ERC721Metadata: Token does not exist\");\n        tokenData[id].tokenURI = uri;\n        tokenData[id].exists = true;\n    }","contract":"Woodie","time":0},{"type":"external-function ","before":"function setContractURI(string memory uri) external {\n        require(hasRole(WOODIE_URI_UPDATER_ROLE, msg.sender));\n        _contractURI = uri;\n    }","after":"function setContractURI(string calldata uri) external {\n        require(hasRole(WOODIE_URI_UPDATER_ROLE, msg.sender));\n        _contractURI = uri;\n    }","contract":"Woodie","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"Woodie","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"Woodie","time":1}]}