{"time":323,"results":[{"type":"external-function ","before":"function setAddress(\n        string memory _name,\n        address _address\n    )\n    external\n    onlyOwner\n    {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(\n            _name,\n            _address,\n            oldAddress\n        );\n    }","after":"function setAddress(\n        string calldata _name,\n        address _address\n    )\n    external\n    onlyOwner\n    {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(\n            _name,\n            _address,\n            oldAddress\n        );\n    }","contract":"Lib_AddressManager","time":0},{"type":"external-function ","before":"function getAddress(\n        string memory _name\n    )\n    external\n    view\n    returns (\n        address\n    )\n    {\n        return addresses[_getNameHash(_name)];\n    }","after":"function getAddress(\n        string calldata _name\n    )\n    external\n    view\n    returns (\n        address\n    )\n    {\n        return addresses[_getNameHash(_name)];\n    }","contract":"Lib_AddressManager","time":0},{"type":"loop-calculation","before":"uint256 listPtr;","after":"// move outside for loop\nuint256 listPtr;","loc":{"start":{"line":2893,"column":12},"end":{"line":2893,"column":27}},"contract":"Lib_RLPWriter","time":0},{"type":"external-function ","before":"function proveContractState(\n        address _ovmContractAddress,\n        address _ethContractAddress,\n        bytes memory _stateTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        // Exit quickly to avoid unnecessary work.\n        require(\n            (\n            ovmStateManager.hasAccount(_ovmContractAddress) == false\n            && ovmStateManager.hasEmptyAccount(_ovmContractAddress) == false\n            ),\n            \"Account state has already been proven.\"\n        );\n\n        // Function will fail if the proof is not a valid inclusion or exclusion proof.\n        (\n        bool exists,\n        bytes memory encodedAccount\n        ) = Lib_SecureMerkleTrie.get(\n            abi.encodePacked(_ovmContractAddress),\n            _stateTrieWitness,\n            preStateRoot\n        );\n\n        if (exists == true) {\n            // Account exists, this was an inclusion proof.\n            Lib_OVMCodec.EVMAccount memory account = Lib_OVMCodec.decodeEVMAccount(\n                encodedAccount\n            );\n\n            address ethContractAddress = _ethContractAddress;\n            if (account.codeHash == EMPTY_ACCOUNT_CODE_HASH) {\n                // Use a known empty contract to prevent an attack in which a user provides a\n                // contract address here and then later deploys code to it.\n                ethContractAddress = 0x0000000000000000000000000000000000000000;\n            } else {\n                // Otherwise, make sure that the code at the provided eth address matches the hash\n                // of the code stored on L2.\n                require(\n                    Lib_EthUtils.getCodeHash(ethContractAddress) == account.codeHash,\n                    \"OVM_StateTransitioner: Provided L1 contract code hash does not match L2 contract code hash.\"\n                );\n            }\n\n            ovmStateManager.putAccount(\n                _ovmContractAddress,\n                Lib_OVMCodec.Account({\n            nonce : account.nonce,\n            balance : account.balance,\n            storageRoot : account.storageRoot,\n            codeHash : account.codeHash,\n            ethAddress : ethContractAddress,\n            isFresh : false\n            })\n            );\n        } else {\n            // Account does not exist, this was an exclusion proof.\n            ovmStateManager.putEmptyAccount(_ovmContractAddress);\n        }\n    }","after":"function proveContractState(\n        address _ovmContractAddress,\n        address _ethContractAddress,\n        bytes calldata _stateTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        // Exit quickly to avoid unnecessary work.\n        require(\n            (\n            ovmStateManager.hasAccount(_ovmContractAddress) == false\n            && ovmStateManager.hasEmptyAccount(_ovmContractAddress) == false\n            ),\n            \"Account state has already been proven.\"\n        );\n\n        // Function will fail if the proof is not a valid inclusion or exclusion proof.\n        (\n        bool exists,\n        bytes memory encodedAccount\n        ) = Lib_SecureMerkleTrie.get(\n            abi.encodePacked(_ovmContractAddress),\n            _stateTrieWitness,\n            preStateRoot\n        );\n\n        if (exists == true) {\n            // Account exists, this was an inclusion proof.\n            Lib_OVMCodec.EVMAccount memory account = Lib_OVMCodec.decodeEVMAccount(\n                encodedAccount\n            );\n\n            address ethContractAddress = _ethContractAddress;\n            if (account.codeHash == EMPTY_ACCOUNT_CODE_HASH) {\n                // Use a known empty contract to prevent an attack in which a user provides a\n                // contract address here and then later deploys code to it.\n                ethContractAddress = 0x0000000000000000000000000000000000000000;\n            } else {\n                // Otherwise, make sure that the code at the provided eth address matches the hash\n                // of the code stored on L2.\n                require(\n                    Lib_EthUtils.getCodeHash(ethContractAddress) == account.codeHash,\n                    \"OVM_StateTransitioner: Provided L1 contract code hash does not match L2 contract code hash.\"\n                );\n            }\n\n            ovmStateManager.putAccount(\n                _ovmContractAddress,\n                Lib_OVMCodec.Account({\n            nonce : account.nonce,\n            balance : account.balance,\n            storageRoot : account.storageRoot,\n            codeHash : account.codeHash,\n            ethAddress : ethContractAddress,\n            isFresh : false\n            })\n            );\n        } else {\n            // Account does not exist, this was an exclusion proof.\n            ovmStateManager.putEmptyAccount(_ovmContractAddress);\n        }\n    }","contract":"OVM_StateTransitioner","time":0},{"type":"external-function ","before":"function proveStorageSlot(\n        address _ovmContractAddress,\n        bytes32 _key,\n        bytes memory _storageTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        // Exit quickly to avoid unnecessary work.\n        require(\n            ovmStateManager.hasContractStorage(_ovmContractAddress, _key) == false,\n            \"Storage slot has already been proven.\"\n        );\n\n        require(\n            ovmStateManager.hasAccount(_ovmContractAddress) == true,\n            \"Contract must be verified before proving a storage slot.\"\n        );\n\n        bytes32 storageRoot = ovmStateManager.getAccountStorageRoot(_ovmContractAddress);\n        bytes32 value;\n\n        if (storageRoot == EMPTY_ACCOUNT_STORAGE_ROOT) {\n            // Storage trie was empty, so the user is always allowed to insert zero-byte values.\n            value = bytes32(0);\n        } else {\n            // Function will fail if the proof is not a valid inclusion or exclusion proof.\n            (\n            bool exists,\n            bytes memory encodedValue\n            ) = Lib_SecureMerkleTrie.get(\n                abi.encodePacked(_key),\n                _storageTrieWitness,\n                storageRoot\n            );\n\n            if (exists == true) {\n                // Inclusion proof.\n                // Stored values are RLP encoded, with leading zeros removed.\n                value = Lib_BytesUtils.toBytes32PadLeft(\n                    Lib_RLPReader.readBytes(encodedValue)\n                );\n            } else {\n                // Exclusion proof, can only be zero bytes.\n                value = bytes32(0);\n            }\n        }\n\n        ovmStateManager.putContractStorage(\n            _ovmContractAddress,\n            _key,\n            value\n        );\n    }","after":"function proveStorageSlot(\n        address _ovmContractAddress,\n        bytes32 _key,\n        bytes calldata _storageTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        // Exit quickly to avoid unnecessary work.\n        require(\n            ovmStateManager.hasContractStorage(_ovmContractAddress, _key) == false,\n            \"Storage slot has already been proven.\"\n        );\n\n        require(\n            ovmStateManager.hasAccount(_ovmContractAddress) == true,\n            \"Contract must be verified before proving a storage slot.\"\n        );\n\n        bytes32 storageRoot = ovmStateManager.getAccountStorageRoot(_ovmContractAddress);\n        bytes32 value;\n\n        if (storageRoot == EMPTY_ACCOUNT_STORAGE_ROOT) {\n            // Storage trie was empty, so the user is always allowed to insert zero-byte values.\n            value = bytes32(0);\n        } else {\n            // Function will fail if the proof is not a valid inclusion or exclusion proof.\n            (\n            bool exists,\n            bytes memory encodedValue\n            ) = Lib_SecureMerkleTrie.get(\n                abi.encodePacked(_key),\n                _storageTrieWitness,\n                storageRoot\n            );\n\n            if (exists == true) {\n                // Inclusion proof.\n                // Stored values are RLP encoded, with leading zeros removed.\n                value = Lib_BytesUtils.toBytes32PadLeft(\n                    Lib_RLPReader.readBytes(encodedValue)\n                );\n            } else {\n                // Exclusion proof, can only be zero bytes.\n                value = bytes32(0);\n            }\n        }\n\n        ovmStateManager.putContractStorage(\n            _ovmContractAddress,\n            _key,\n            value\n        );\n    }","contract":"OVM_StateTransitioner","time":0},{"type":"external-function ","before":"function applyTransaction(\n        Lib_OVMCodec.Transaction memory _transaction\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            Lib_OVMCodec.hashTransaction(_transaction) == transactionHash,\n            \"Invalid transaction provided.\"\n        );\n\n        // We require gas to complete the logic here in run() before/after execution,\n        // But must ensure the full _tx.gasLimit can be given to the ovmCALL (determinism)\n        // This includes 1/64 of the gas getting lost because of EIP-150 (lost twice--first\n        // going into EM, then going into the code contract).\n        require(\n            gasleft() >= 100000 + _transaction.gasLimit * 1032 / 1000, // 1032/1000 = 1.032 = (64/63)^2 rounded up\n            \"Not enough gas to execute transaction deterministically.\"\n        );\n\n        iOVM_ExecutionManager ovmExecutionManager = iOVM_ExecutionManager(resolve(\"OVM_ExecutionManager\"));\n\n        // We call `setExecutionManager` right before `run` (and not earlier) just in case the\n        // OVM_ExecutionManager address was updated between the time when this contract was created\n        // and when `applyTransaction` was called.\n        ovmStateManager.setExecutionManager(address(ovmExecutionManager));\n\n        // `run` always succeeds *unless* the user hasn't provided enough gas to `applyTransaction`\n        // or an INVALID_STATE_ACCESS flag was triggered. Either way, we won't get beyond this line\n        // if that's the case.\n        ovmExecutionManager.run(_transaction, address(ovmStateManager));\n\n        // Prevent the Execution Manager from calling this SM again.\n        ovmStateManager.setExecutionManager(address(0));\n        phase = TransitionPhase.POST_EXECUTION;\n    }","after":"function applyTransaction(\n        Lib_OVMCodec.Transaction calldata _transaction\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            Lib_OVMCodec.hashTransaction(_transaction) == transactionHash,\n            \"Invalid transaction provided.\"\n        );\n\n        // We require gas to complete the logic here in run() before/after execution,\n        // But must ensure the full _tx.gasLimit can be given to the ovmCALL (determinism)\n        // This includes 1/64 of the gas getting lost because of EIP-150 (lost twice--first\n        // going into EM, then going into the code contract).\n        require(\n            gasleft() >= 100000 + _transaction.gasLimit * 1032 / 1000, // 1032/1000 = 1.032 = (64/63)^2 rounded up\n            \"Not enough gas to execute transaction deterministically.\"\n        );\n\n        iOVM_ExecutionManager ovmExecutionManager = iOVM_ExecutionManager(resolve(\"OVM_ExecutionManager\"));\n\n        // We call `setExecutionManager` right before `run` (and not earlier) just in case the\n        // OVM_ExecutionManager address was updated between the time when this contract was created\n        // and when `applyTransaction` was called.\n        ovmStateManager.setExecutionManager(address(ovmExecutionManager));\n\n        // `run` always succeeds *unless* the user hasn't provided enough gas to `applyTransaction`\n        // or an INVALID_STATE_ACCESS flag was triggered. Either way, we won't get beyond this line\n        // if that's the case.\n        ovmExecutionManager.run(_transaction, address(ovmStateManager));\n\n        // Prevent the Execution Manager from calling this SM again.\n        ovmStateManager.setExecutionManager(address(0));\n        phase = TransitionPhase.POST_EXECUTION;\n    }","contract":"OVM_StateTransitioner","time":0},{"type":"external-function ","before":"function commitContractState(\n        address _ovmContractAddress,\n        bytes memory _stateTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.POST_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            ovmStateManager.getTotalUncommittedContractStorage() == 0,\n            \"All storage must be committed before committing account states.\"\n        );\n\n        require(\n            ovmStateManager.commitAccount(_ovmContractAddress) == true,\n            \"Account state wasn't changed or has already been committed.\"\n        );\n\n        Lib_OVMCodec.Account memory account = ovmStateManager.getAccount(_ovmContractAddress);\n\n        postStateRoot = Lib_SecureMerkleTrie.update(\n            abi.encodePacked(_ovmContractAddress),\n            Lib_OVMCodec.encodeEVMAccount(\n                Lib_OVMCodec.toEVMAccount(account)\n            ),\n            _stateTrieWitness,\n            postStateRoot\n        );\n\n        // Emit an event to help clients figure out the proof ordering.\n        emit AccountCommitted(\n            _ovmContractAddress\n        );\n    }","after":"function commitContractState(\n        address _ovmContractAddress,\n        bytes calldata _stateTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.POST_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            ovmStateManager.getTotalUncommittedContractStorage() == 0,\n            \"All storage must be committed before committing account states.\"\n        );\n\n        require(\n            ovmStateManager.commitAccount(_ovmContractAddress) == true,\n            \"Account state wasn't changed or has already been committed.\"\n        );\n\n        Lib_OVMCodec.Account memory account = ovmStateManager.getAccount(_ovmContractAddress);\n\n        postStateRoot = Lib_SecureMerkleTrie.update(\n            abi.encodePacked(_ovmContractAddress),\n            Lib_OVMCodec.encodeEVMAccount(\n                Lib_OVMCodec.toEVMAccount(account)\n            ),\n            _stateTrieWitness,\n            postStateRoot\n        );\n\n        // Emit an event to help clients figure out the proof ordering.\n        emit AccountCommitted(\n            _ovmContractAddress\n        );\n    }","contract":"OVM_StateTransitioner","time":0},{"type":"external-function ","before":"function commitStorageSlot(\n        address _ovmContractAddress,\n        bytes32 _key,\n        bytes memory _storageTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.POST_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            ovmStateManager.commitContractStorage(_ovmContractAddress, _key) == true,\n            \"Storage slot value wasn't changed or has already been committed.\"\n        );\n\n        Lib_OVMCodec.Account memory account = ovmStateManager.getAccount(_ovmContractAddress);\n        bytes32 value = ovmStateManager.getContractStorage(_ovmContractAddress, _key);\n\n        account.storageRoot = Lib_SecureMerkleTrie.update(\n            abi.encodePacked(_key),\n            Lib_RLPWriter.writeBytes(\n                Lib_Bytes32Utils.removeLeadingZeros(value)\n            ),\n            _storageTrieWitness,\n            account.storageRoot\n        );\n\n        ovmStateManager.putAccount(_ovmContractAddress, account);\n\n        // Emit an event to help clients figure out the proof ordering.\n        emit ContractStorageCommitted(\n            _ovmContractAddress,\n            _key\n        );\n    }","after":"function commitStorageSlot(\n        address _ovmContractAddress,\n        bytes32 _key,\n        bytes calldata _storageTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.POST_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            ovmStateManager.commitContractStorage(_ovmContractAddress, _key) == true,\n            \"Storage slot value wasn't changed or has already been committed.\"\n        );\n\n        Lib_OVMCodec.Account memory account = ovmStateManager.getAccount(_ovmContractAddress);\n        bytes32 value = ovmStateManager.getContractStorage(_ovmContractAddress, _key);\n\n        account.storageRoot = Lib_SecureMerkleTrie.update(\n            abi.encodePacked(_key),\n            Lib_RLPWriter.writeBytes(\n                Lib_Bytes32Utils.removeLeadingZeros(value)\n            ),\n            _storageTrieWitness,\n            account.storageRoot\n        );\n\n        ovmStateManager.putAccount(_ovmContractAddress, account);\n\n        // Emit an event to help clients figure out the proof ordering.\n        emit ContractStorageCommitted(\n            _ovmContractAddress,\n            _key\n        );\n    }","contract":"OVM_StateTransitioner","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 internal preStateRoot;","after":"bytes32 internal immutable preStateRoot;","contract":"OVM_StateTransitioner","time":0},{"type":"immutable-restrict-modification ","before":"uint256 internal stateTransitionIndex;","after":"uint256 internal immutable stateTransitionIndex;","contract":"OVM_StateTransitioner","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 internal transactionHash;","after":"bytes32 internal immutable transactionHash;","contract":"OVM_StateTransitioner","time":0},{"type":"struct-data-arrangement ","before":"\naddress ovmCALLER\naddress ovmADDRESS\nuint256 ovmCALLVALUE\nbool isStatic","after":"uint256 ovmCALLVALUE\naddress ovmCALLER\naddress ovmADDRESS\nbool isStatic\n","contract":"iOVM_ExecutionManager","time":1}]}