{"time":161,"results":[{"type":"external-function ","before":"function init(address owner, address[] memory proxies) external {\n\n        initOwner(owner);\n\n        for (uint i = 0; i < proxies.length; i++)\n\n            _IS_ALLOWED_PROXY_[proxies[i]] = true;\n\n    }","after":"function init(address owner, address[] calldata proxies) external {\n\n        initOwner(owner);\n\n        for (uint i = 0; i < proxies.length; i++)\n\n            _IS_ALLOWED_PROXY_[proxies[i]] = true;\n\n    }","contract":"DODOApproveProxy","time":0},{"type":"external-function ","before":"function dodoSwapV1(\n\n        address fromToken,\n\n        address toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] memory dodoPairs,\n\n        uint256 directions,\n\n        uint256 deadLine\n\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n\n        require(dodoPairs.length > 0, \"DODOV1Proxy04: PAIRS_EMPTY\");\n\n        require(minReturnAmount > 0, \"DODOV1Proxy04: RETURN_AMOUNT_ZERO\");\n\n        require(fromToken != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_SELL_CHI\");\n\n        require(toToken != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_BUY_CHI\");\n\n\n        uint256 originGas = gasleft();\n\n\n        if (fromToken != _ETH_ADDRESS_) {\n\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n\n                fromToken,\n\n                msg.sender,\n\n                address(this),\n\n                fromTokenAmount\n\n            );\n\n        } else {\n\n            require(msg.value == fromTokenAmount, \"DODOV1Proxy04: ETH_AMOUNT_NOT_MATCH\");\n\n            IWETH(_WETH_).deposit{value : fromTokenAmount}();\n\n        }\n\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n\n            address curDodoPair = dodoPairs[i];\n\n            if (directions & 1 == 0) {\n\n                address curDodoBase = IDODOV1(curDodoPair)._BASE_TOKEN_();\n\n                require(curDodoBase != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_CHI\");\n\n                uint256 curAmountIn = IERC20(curDodoBase).balanceOf(address(this));\n\n                IERC20(curDodoBase).universalApproveMax(curDodoPair, curAmountIn);\n\n                IDODOV1(curDodoPair).sellBaseToken(curAmountIn, 0, \"\");\n\n            } else {\n\n                address curDodoQuote = IDODOV1(curDodoPair)._QUOTE_TOKEN_();\n\n                require(curDodoQuote != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_CHI\");\n\n                uint256 curAmountIn = IERC20(curDodoQuote).balanceOf(address(this));\n\n                IERC20(curDodoQuote).universalApproveMax(curDodoPair, curAmountIn);\n\n                uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n\n                    curDodoPair,\n\n                    curAmountIn\n\n                );\n\n                IDODOV1(curDodoPair).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\n\n            }\n\n            directions = directions >> 1;\n\n        }\n\n\n        if (toToken == _ETH_ADDRESS_) {\n\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n\n            IWETH(_WETH_).withdraw(returnAmount);\n\n        } else {\n\n            returnAmount = IERC20(toToken).tokenBalanceOf(address(this));\n\n        }\n\n\n        require(returnAmount >= minReturnAmount, \"DODOV1Proxy04: Return amount is not enough\");\n\n        IERC20(toToken).universalTransfer(msg.sender, returnAmount);\n\n\n        emit OrderHistory(fromToken, toToken, msg.sender, fromTokenAmount, returnAmount);\n\n\n        uint256 _gasDodoMaxReturn = _GAS_DODO_MAX_RETURN_;\n\n        if (_gasDodoMaxReturn > 0) {\n\n            uint256 calcGasTokenBurn = originGas.sub(gasleft()) / 65000;\n\n            uint256 gasTokenBurn = calcGasTokenBurn > _gasDodoMaxReturn ? _gasDodoMaxReturn : calcGasTokenBurn;\n\n            if (gasleft() > 27710 + gasTokenBurn * 6080)\n\n                IChi(_CHI_TOKEN_).freeUpTo(gasTokenBurn);\n\n        }\n\n    }","after":"function dodoSwapV1(\n\n        address fromToken,\n\n        address toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] calldata dodoPairs,\n\n        uint256 directions,\n\n        uint256 deadLine\n\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n\n        require(dodoPairs.length > 0, \"DODOV1Proxy04: PAIRS_EMPTY\");\n\n        require(minReturnAmount > 0, \"DODOV1Proxy04: RETURN_AMOUNT_ZERO\");\n\n        require(fromToken != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_SELL_CHI\");\n\n        require(toToken != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_BUY_CHI\");\n\n\n        uint256 originGas = gasleft();\n\n\n        if (fromToken != _ETH_ADDRESS_) {\n\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n\n                fromToken,\n\n                msg.sender,\n\n                address(this),\n\n                fromTokenAmount\n\n            );\n\n        } else {\n\n            require(msg.value == fromTokenAmount, \"DODOV1Proxy04: ETH_AMOUNT_NOT_MATCH\");\n\n            IWETH(_WETH_).deposit{value : fromTokenAmount}();\n\n        }\n\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n\n            address curDodoPair = dodoPairs[i];\n\n            if (directions & 1 == 0) {\n\n                address curDodoBase = IDODOV1(curDodoPair)._BASE_TOKEN_();\n\n                require(curDodoBase != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_CHI\");\n\n                uint256 curAmountIn = IERC20(curDodoBase).balanceOf(address(this));\n\n                IERC20(curDodoBase).universalApproveMax(curDodoPair, curAmountIn);\n\n                IDODOV1(curDodoPair).sellBaseToken(curAmountIn, 0, \"\");\n\n            } else {\n\n                address curDodoQuote = IDODOV1(curDodoPair)._QUOTE_TOKEN_();\n\n                require(curDodoQuote != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_CHI\");\n\n                uint256 curAmountIn = IERC20(curDodoQuote).balanceOf(address(this));\n\n                IERC20(curDodoQuote).universalApproveMax(curDodoPair, curAmountIn);\n\n                uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n\n                    curDodoPair,\n\n                    curAmountIn\n\n                );\n\n                IDODOV1(curDodoPair).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\n\n            }\n\n            directions = directions >> 1;\n\n        }\n\n\n        if (toToken == _ETH_ADDRESS_) {\n\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n\n            IWETH(_WETH_).withdraw(returnAmount);\n\n        } else {\n\n            returnAmount = IERC20(toToken).tokenBalanceOf(address(this));\n\n        }\n\n\n        require(returnAmount >= minReturnAmount, \"DODOV1Proxy04: Return amount is not enough\");\n\n        IERC20(toToken).universalTransfer(msg.sender, returnAmount);\n\n\n        emit OrderHistory(fromToken, toToken, msg.sender, fromTokenAmount, returnAmount);\n\n\n        uint256 _gasDodoMaxReturn = _GAS_DODO_MAX_RETURN_;\n\n        if (_gasDodoMaxReturn > 0) {\n\n            uint256 calcGasTokenBurn = originGas.sub(gasleft()) / 65000;\n\n            uint256 gasTokenBurn = calcGasTokenBurn > _gasDodoMaxReturn ? _gasDodoMaxReturn : calcGasTokenBurn;\n\n            if (gasleft() > 27710 + gasTokenBurn * 6080)\n\n                IChi(_CHI_TOKEN_).freeUpTo(gasTokenBurn);\n\n        }\n\n    }","contract":"DODOV1Proxy04","time":0},{"type":"external-function ","before":"function externalSwap(\n\n        address fromToken,\n\n        address toToken,\n\n        address approveTarget,\n\n        address swapTarget,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        bytes memory callDataConcat,\n\n        uint256 deadLine\n\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n\n        require(minReturnAmount > 0, \"DODOV1Proxy04: RETURN_AMOUNT_ZERO\");\n\n        require(fromToken != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_SELL_CHI\");\n\n        require(toToken != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_BUY_CHI\");\n\n\n        address _fromToken = fromToken;\n\n        address _toToken = toToken;\n\n\n        uint256 toTokenOriginBalance = IERC20(_toToken).universalBalanceOf(msg.sender);\n\n\n        if (_fromToken != _ETH_ADDRESS_) {\n\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n\n                _fromToken,\n\n                msg.sender,\n\n                address(this),\n\n                fromTokenAmount\n\n            );\n\n            IERC20(_fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n\n        }\n\n\n        require(isWhiteListed[swapTarget], \"DODOV1Proxy04: Not Whitelist Contract\");\n\n        (bool success,) = swapTarget.call{value : _fromToken == _ETH_ADDRESS_ ? msg.value : 0}(callDataConcat);\n\n\n        require(success, \"DODOV1Proxy04: External Swap execution Failed\");\n\n\n        IERC20(_toToken).universalTransfer(\n\n            msg.sender,\n\n            IERC20(_toToken).universalBalanceOf(address(this))\n\n        );\n\n        returnAmount = IERC20(_toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\n\n        require(returnAmount >= minReturnAmount, \"DODOV1Proxy04: Return amount is not enough\");\n\n\n        emit OrderHistory(_fromToken, _toToken, msg.sender, fromTokenAmount, returnAmount);\n\n\n        uint256 _gasExternalReturn = _GAS_EXTERNAL_RETURN_;\n\n        if (_gasExternalReturn > 0) {\n\n            if (gasleft() > 27710 + _gasExternalReturn * 6080)\n\n                IChi(_CHI_TOKEN_).freeUpTo(_gasExternalReturn);\n\n        }\n\n    }","after":"function externalSwap(\n\n        address fromToken,\n\n        address toToken,\n\n        address approveTarget,\n\n        address swapTarget,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        bytes calldata callDataConcat,\n\n        uint256 deadLine\n\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n\n        require(minReturnAmount > 0, \"DODOV1Proxy04: RETURN_AMOUNT_ZERO\");\n\n        require(fromToken != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_SELL_CHI\");\n\n        require(toToken != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_BUY_CHI\");\n\n\n        address _fromToken = fromToken;\n\n        address _toToken = toToken;\n\n\n        uint256 toTokenOriginBalance = IERC20(_toToken).universalBalanceOf(msg.sender);\n\n\n        if (_fromToken != _ETH_ADDRESS_) {\n\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n\n                _fromToken,\n\n                msg.sender,\n\n                address(this),\n\n                fromTokenAmount\n\n            );\n\n            IERC20(_fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n\n        }\n\n\n        require(isWhiteListed[swapTarget], \"DODOV1Proxy04: Not Whitelist Contract\");\n\n        (bool success,) = swapTarget.call{value : _fromToken == _ETH_ADDRESS_ ? msg.value : 0}(callDataConcat);\n\n\n        require(success, \"DODOV1Proxy04: External Swap execution Failed\");\n\n\n        IERC20(_toToken).universalTransfer(\n\n            msg.sender,\n\n            IERC20(_toToken).universalBalanceOf(address(this))\n\n        );\n\n        returnAmount = IERC20(_toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\n\n        require(returnAmount >= minReturnAmount, \"DODOV1Proxy04: Return amount is not enough\");\n\n\n        emit OrderHistory(_fromToken, _toToken, msg.sender, fromTokenAmount, returnAmount);\n\n\n        uint256 _gasExternalReturn = _GAS_EXTERNAL_RETURN_;\n\n        if (_gasExternalReturn > 0) {\n\n            if (gasleft() > 27710 + _gasExternalReturn * 6080)\n\n                IChi(_CHI_TOKEN_).freeUpTo(_gasExternalReturn);\n\n        }\n\n    }","contract":"DODOV1Proxy04","time":0},{"type":"external-function ","before":"function mixSwapV1(\n\n        address fromToken,\n\n        address toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] memory mixPairs,\n\n        uint256[] memory directions,\n\n        address[] memory portionPath,\n\n        uint256 deadLine\n\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n\n        require(mixPairs.length == directions.length, \"DODOV1Proxy04: PARAMS_LENGTH_NOT_MATCH\");\n\n        require(mixPairs.length > 0, \"DODOV1Proxy04: PAIRS_EMPTY\");\n\n        require(minReturnAmount > 0, \"DODOV1Proxy04: RETURN_AMOUNT_ZERO\");\n\n        require(fromToken != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_SELL_CHI\");\n\n        require(toToken != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_BUY_CHI\");\n\n\n        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);\n\n\n        if (fromToken != _ETH_ADDRESS_) {\n\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n\n                fromToken,\n\n                msg.sender,\n\n                address(this),\n\n                fromTokenAmount\n\n            );\n\n        } else {\n\n            require(msg.value == fromTokenAmount, \"DODOV1Proxy04: ETH_AMOUNT_NOT_MATCH\");\n\n            IWETH(_WETH_).deposit{value : fromTokenAmount}();\n\n        }\n\n\n        for (uint256 i = 0; i < mixPairs.length; i++) {\n\n            address curPair = mixPairs[i];\n\n            if (directions[i] == 0) {\n\n                address curDodoBase = IDODOV1(curPair)._BASE_TOKEN_();\n\n                require(curDodoBase != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_CHI\");\n\n                uint256 curAmountIn = IERC20(curDodoBase).balanceOf(address(this));\n\n                IERC20(curDodoBase).universalApproveMax(curPair, curAmountIn);\n\n                IDODOV1(curPair).sellBaseToken(curAmountIn, 0, \"\");\n\n            } else if (directions[i] == 1) {\n\n                address curDodoQuote = IDODOV1(curPair)._QUOTE_TOKEN_();\n\n                require(curDodoQuote != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_CHI\");\n\n                uint256 curAmountIn = IERC20(curDodoQuote).balanceOf(address(this));\n\n                IERC20(curDodoQuote).universalApproveMax(curPair, curAmountIn);\n\n                uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n\n                    curPair,\n\n                    curAmountIn\n\n                );\n\n                IDODOV1(curPair).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\n\n            } else {\n\n                require(portionPath[0] != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_CHI\");\n\n                uint256 curAmountIn = IERC20(portionPath[0]).balanceOf(address(this));\n\n                IERC20(portionPath[0]).universalApproveMax(curPair, curAmountIn);\n\n                IUni(curPair).swapExactTokensForTokens(curAmountIn, 0, portionPath, address(this), deadLine);\n\n            }\n\n        }\n\n\n        IERC20(toToken).universalTransfer(\n\n            msg.sender,\n\n            IERC20(toToken).universalBalanceOf(address(this))\n\n        );\n\n\n        returnAmount = IERC20(toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\n\n        require(returnAmount >= minReturnAmount, \"DODOV1Proxy04: Return amount is not enough\");\n\n\n        emit OrderHistory(fromToken, toToken, msg.sender, fromTokenAmount, returnAmount);\n\n\n        uint256 _gasExternalReturn = _GAS_EXTERNAL_RETURN_;\n\n        if (_gasExternalReturn > 0) {\n\n            if (gasleft() > 27710 + _gasExternalReturn * 6080)\n\n                IChi(_CHI_TOKEN_).freeUpTo(_gasExternalReturn);\n\n        }\n\n    }","after":"function mixSwapV1(\n\n        address fromToken,\n\n        address toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] calldata mixPairs,\n\n        uint256[] calldata directions,\n\n        address[] calldata portionPath,\n\n        uint256 deadLine\n\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n\n        require(mixPairs.length == directions.length, \"DODOV1Proxy04: PARAMS_LENGTH_NOT_MATCH\");\n\n        require(mixPairs.length > 0, \"DODOV1Proxy04: PAIRS_EMPTY\");\n\n        require(minReturnAmount > 0, \"DODOV1Proxy04: RETURN_AMOUNT_ZERO\");\n\n        require(fromToken != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_SELL_CHI\");\n\n        require(toToken != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_BUY_CHI\");\n\n\n        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);\n\n\n        if (fromToken != _ETH_ADDRESS_) {\n\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n\n                fromToken,\n\n                msg.sender,\n\n                address(this),\n\n                fromTokenAmount\n\n            );\n\n        } else {\n\n            require(msg.value == fromTokenAmount, \"DODOV1Proxy04: ETH_AMOUNT_NOT_MATCH\");\n\n            IWETH(_WETH_).deposit{value : fromTokenAmount}();\n\n        }\n\n\n        for (uint256 i = 0; i < mixPairs.length; i++) {\n\n            address curPair = mixPairs[i];\n\n            if (directions[i] == 0) {\n\n                address curDodoBase = IDODOV1(curPair)._BASE_TOKEN_();\n\n                require(curDodoBase != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_CHI\");\n\n                uint256 curAmountIn = IERC20(curDodoBase).balanceOf(address(this));\n\n                IERC20(curDodoBase).universalApproveMax(curPair, curAmountIn);\n\n                IDODOV1(curPair).sellBaseToken(curAmountIn, 0, \"\");\n\n            } else if (directions[i] == 1) {\n\n                address curDodoQuote = IDODOV1(curPair)._QUOTE_TOKEN_();\n\n                require(curDodoQuote != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_CHI\");\n\n                uint256 curAmountIn = IERC20(curDodoQuote).balanceOf(address(this));\n\n                IERC20(curDodoQuote).universalApproveMax(curPair, curAmountIn);\n\n                uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n\n                    curPair,\n\n                    curAmountIn\n\n                );\n\n                IDODOV1(curPair).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\n\n            } else {\n\n                require(portionPath[0] != _CHI_TOKEN_, \"DODOV1Proxy04: NOT_SUPPORT_CHI\");\n\n                uint256 curAmountIn = IERC20(portionPath[0]).balanceOf(address(this));\n\n                IERC20(portionPath[0]).universalApproveMax(curPair, curAmountIn);\n\n                IUni(curPair).swapExactTokensForTokens(curAmountIn, 0, portionPath, address(this), deadLine);\n\n            }\n\n        }\n\n\n        IERC20(toToken).universalTransfer(\n\n            msg.sender,\n\n            IERC20(toToken).universalBalanceOf(address(this))\n\n        );\n\n\n        returnAmount = IERC20(toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\n\n        require(returnAmount >= minReturnAmount, \"DODOV1Proxy04: Return amount is not enough\");\n\n\n        emit OrderHistory(fromToken, toToken, msg.sender, fromTokenAmount, returnAmount);\n\n\n        uint256 _gasExternalReturn = _GAS_EXTERNAL_RETURN_;\n\n        if (_gasExternalReturn > 0) {\n\n            if (gasleft() > 27710 + _gasExternalReturn * 6080)\n\n                IChi(_CHI_TOKEN_).freeUpTo(_gasExternalReturn);\n\n        }\n\n    }","contract":"DODOV1Proxy04","time":0}]}