{"time":270,"results":[{"type":"external-function ","before":"function init(address owner, address[] memory proxies) external {\n\n        initOwner(owner);\n\n        for (uint i = 0; i < proxies.length; i++)\n\n            _IS_ALLOWED_PROXY_[proxies[i]] = true;\n\n    }","after":"function init(address owner, address[] calldata proxies) external {\n\n        initOwner(owner);\n\n        for (uint i = 0; i < proxies.length; i++)\n\n            _IS_ALLOWED_PROXY_[proxies[i]] = true;\n\n    }","contract":"DODOApproveProxy","time":0},{"type":"external-function ","before":"function resetDODOPrivatePool(\n\n        address dppAddress,\n\n        uint256[] memory paramList, //0 - newLpFeeRate, 1 - newI, 2 - newK\n\n        uint256[] memory amountList, //0 - baseInAmount, 1 - quoteInAmount, 2 - baseOutAmount, 3- quoteOutAmount\n\n        uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH, 3 - baseOutETH, 4 - quoteOutETH\n\n        uint256 minBaseReserve,\n\n        uint256 minQuoteReserve,\n\n        uint256 deadLine\n\n    ) external override payable preventReentrant judgeExpired(deadLine) {\n\n        _deposit(\n\n            msg.sender,\n\n            dppAddress,\n\n            IDODOV2(dppAddress)._BASE_TOKEN_(),\n\n            amountList[0],\n\n            flag == 1\n\n        );\n\n        _deposit(\n\n            msg.sender,\n\n            dppAddress,\n\n            IDODOV2(dppAddress)._QUOTE_TOKEN_(),\n\n            amountList[1],\n\n            flag == 2\n\n        );\n\n\n        require(IDODOV2(IDODOV2(dppAddress)._OWNER_()).reset(\n\n                msg.sender,\n\n                paramList[0],\n\n                paramList[1],\n\n                paramList[2],\n\n                amountList[2],\n\n                amountList[3],\n\n                minBaseReserve,\n\n                minQuoteReserve\n\n            ), \"Reset Failed\");\n\n\n        _withdraw(msg.sender, IDODOV2(dppAddress)._BASE_TOKEN_(), amountList[2], flag == 3);\n\n        _withdraw(msg.sender, IDODOV2(dppAddress)._QUOTE_TOKEN_(), amountList[3], flag == 4);\n\n    }","after":"function resetDODOPrivatePool(\n\n        address dppAddress,\n\n        uint256[] calldata paramList, //0 - newLpFeeRate, 1 - newI, 2 - newK\n\n        uint256[] calldata amountList, //0 - baseInAmount, 1 - quoteInAmount, 2 - baseOutAmount, 3- quoteOutAmount\n\n        uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH, 3 - baseOutETH, 4 - quoteOutETH\n\n        uint256 minBaseReserve,\n\n        uint256 minQuoteReserve,\n\n        uint256 deadLine\n\n    ) external override payable preventReentrant judgeExpired(deadLine) {\n\n        _deposit(\n\n            msg.sender,\n\n            dppAddress,\n\n            IDODOV2(dppAddress)._BASE_TOKEN_(),\n\n            amountList[0],\n\n            flag == 1\n\n        );\n\n        _deposit(\n\n            msg.sender,\n\n            dppAddress,\n\n            IDODOV2(dppAddress)._QUOTE_TOKEN_(),\n\n            amountList[1],\n\n            flag == 2\n\n        );\n\n\n        require(IDODOV2(IDODOV2(dppAddress)._OWNER_()).reset(\n\n                msg.sender,\n\n                paramList[0],\n\n                paramList[1],\n\n                paramList[2],\n\n                amountList[2],\n\n                amountList[3],\n\n                minBaseReserve,\n\n                minQuoteReserve\n\n            ), \"Reset Failed\");\n\n\n        _withdraw(msg.sender, IDODOV2(dppAddress)._BASE_TOKEN_(), amountList[2], flag == 3);\n\n        _withdraw(msg.sender, IDODOV2(dppAddress)._QUOTE_TOKEN_(), amountList[3], flag == 4);\n\n    }","contract":"DODOV2Proxy02","time":0},{"type":"external-function ","before":"function dodoSwapV2ETHToToken(\n\n        address toToken,\n\n        uint256 minReturnAmount,\n\n        address[] memory dodoPairs,\n\n        uint256 directions,\n\n        bool isIncentive,\n\n        uint256 deadLine\n\n    )\n\n    external\n\n    override\n\n    payable\n\n    judgeExpired(deadLine)\n\n    returns (uint256 returnAmount)\n\n    {\n\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n        uint256 originGas = gasleft();\n\n\n        uint256 originToTokenBalance = IERC20(toToken).balanceOf(msg.sender);\n\n        IWETH(_WETH_).deposit{value : msg.value}();\n\n        IWETH(_WETH_).transfer(dodoPairs[0], msg.value);\n\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n\n            if (i == dodoPairs.length - 1) {\n\n                if (directions & 1 == 0) {\n\n                    IDODOV2(dodoPairs[i]).sellBase(msg.sender);\n\n                } else {\n\n                    IDODOV2(dodoPairs[i]).sellQuote(msg.sender);\n\n                }\n\n            } else {\n\n                if (directions & 1 == 0) {\n\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n\n                } else {\n\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n\n                }\n\n            }\n\n            directions = directions >> 1;\n\n        }\n\n\n        returnAmount = IERC20(toToken).balanceOf(msg.sender).sub(originToTokenBalance);\n\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n\n        _dodoGasReturn(originGas);\n\n\n        _execIncentive(isIncentive, _ETH_ADDRESS_, toToken);\n\n\n        emit OrderHistory(\n\n            _ETH_ADDRESS_,\n\n            toToken,\n\n            msg.sender,\n\n            msg.value,\n\n            returnAmount\n\n        );\n\n    }","after":"function dodoSwapV2ETHToToken(\n\n        address toToken,\n\n        uint256 minReturnAmount,\n\n        address[] calldata dodoPairs,\n\n        uint256 directions,\n\n        bool isIncentive,\n\n        uint256 deadLine\n\n    )\n\n    external\n\n    override\n\n    payable\n\n    judgeExpired(deadLine)\n\n    returns (uint256 returnAmount)\n\n    {\n\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n        uint256 originGas = gasleft();\n\n\n        uint256 originToTokenBalance = IERC20(toToken).balanceOf(msg.sender);\n\n        IWETH(_WETH_).deposit{value : msg.value}();\n\n        IWETH(_WETH_).transfer(dodoPairs[0], msg.value);\n\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n\n            if (i == dodoPairs.length - 1) {\n\n                if (directions & 1 == 0) {\n\n                    IDODOV2(dodoPairs[i]).sellBase(msg.sender);\n\n                } else {\n\n                    IDODOV2(dodoPairs[i]).sellQuote(msg.sender);\n\n                }\n\n            } else {\n\n                if (directions & 1 == 0) {\n\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n\n                } else {\n\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n\n                }\n\n            }\n\n            directions = directions >> 1;\n\n        }\n\n\n        returnAmount = IERC20(toToken).balanceOf(msg.sender).sub(originToTokenBalance);\n\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n\n        _dodoGasReturn(originGas);\n\n\n        _execIncentive(isIncentive, _ETH_ADDRESS_, toToken);\n\n\n        emit OrderHistory(\n\n            _ETH_ADDRESS_,\n\n            toToken,\n\n            msg.sender,\n\n            msg.value,\n\n            returnAmount\n\n        );\n\n    }","contract":"DODOV2Proxy02","time":0},{"type":"external-function ","before":"function dodoSwapV2TokenToETH(\n\n        address fromToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] memory dodoPairs,\n\n        uint256 directions,\n\n        bool isIncentive,\n\n        uint256 deadLine\n\n    )\n\n    external\n\n    override\n\n    judgeExpired(deadLine)\n\n    returns (uint256 returnAmount)\n\n    {\n\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n        uint256 originGas = gasleft();\n\n\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(fromToken, msg.sender, dodoPairs[0], fromTokenAmount);\n\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n\n            if (i == dodoPairs.length - 1) {\n\n                if (directions & 1 == 0) {\n\n                    IDODOV2(dodoPairs[i]).sellBase(address(this));\n\n                } else {\n\n                    IDODOV2(dodoPairs[i]).sellQuote(address(this));\n\n                }\n\n            } else {\n\n                if (directions & 1 == 0) {\n\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n\n                } else {\n\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n\n                }\n\n            }\n\n            directions = directions >> 1;\n\n        }\n\n        returnAmount = IWETH(_WETH_).balanceOf(address(this));\n\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n        IWETH(_WETH_).withdraw(returnAmount);\n\n        msg.sender.transfer(returnAmount);\n\n\n        _dodoGasReturn(originGas);\n\n\n        _execIncentive(isIncentive, fromToken, _ETH_ADDRESS_);\n\n\n        emit OrderHistory(\n\n            fromToken,\n\n            _ETH_ADDRESS_,\n\n            msg.sender,\n\n            fromTokenAmount,\n\n            returnAmount\n\n        );\n\n    }","after":"function dodoSwapV2TokenToETH(\n\n        address fromToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] calldata dodoPairs,\n\n        uint256 directions,\n\n        bool isIncentive,\n\n        uint256 deadLine\n\n    )\n\n    external\n\n    override\n\n    judgeExpired(deadLine)\n\n    returns (uint256 returnAmount)\n\n    {\n\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n        uint256 originGas = gasleft();\n\n\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(fromToken, msg.sender, dodoPairs[0], fromTokenAmount);\n\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n\n            if (i == dodoPairs.length - 1) {\n\n                if (directions & 1 == 0) {\n\n                    IDODOV2(dodoPairs[i]).sellBase(address(this));\n\n                } else {\n\n                    IDODOV2(dodoPairs[i]).sellQuote(address(this));\n\n                }\n\n            } else {\n\n                if (directions & 1 == 0) {\n\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n\n                } else {\n\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n\n                }\n\n            }\n\n            directions = directions >> 1;\n\n        }\n\n        returnAmount = IWETH(_WETH_).balanceOf(address(this));\n\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n        IWETH(_WETH_).withdraw(returnAmount);\n\n        msg.sender.transfer(returnAmount);\n\n\n        _dodoGasReturn(originGas);\n\n\n        _execIncentive(isIncentive, fromToken, _ETH_ADDRESS_);\n\n\n        emit OrderHistory(\n\n            fromToken,\n\n            _ETH_ADDRESS_,\n\n            msg.sender,\n\n            fromTokenAmount,\n\n            returnAmount\n\n        );\n\n    }","contract":"DODOV2Proxy02","time":0},{"type":"external-function ","before":"function dodoSwapV2TokenToToken(\n\n        address fromToken,\n\n        address toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] memory dodoPairs,\n\n        uint256 directions,\n\n        bool isIncentive,\n\n        uint256 deadLine\n\n    )\n\n    external\n\n    override\n\n    judgeExpired(deadLine)\n\n    returns (uint256 returnAmount)\n\n    {\n\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n        uint256 originGas = gasleft();\n\n\n        uint256 originToTokenBalance = IERC20(toToken).balanceOf(msg.sender);\n\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(fromToken, msg.sender, dodoPairs[0], fromTokenAmount);\n\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n\n            if (i == dodoPairs.length - 1) {\n\n                if (directions & 1 == 0) {\n\n                    IDODOV2(dodoPairs[i]).sellBase(msg.sender);\n\n                } else {\n\n                    IDODOV2(dodoPairs[i]).sellQuote(msg.sender);\n\n                }\n\n            } else {\n\n                if (directions & 1 == 0) {\n\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n\n                } else {\n\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n\n                }\n\n            }\n\n            directions = directions >> 1;\n\n        }\n\n        returnAmount = IERC20(toToken).balanceOf(msg.sender).sub(originToTokenBalance);\n\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n\n        _dodoGasReturn(originGas);\n\n\n        _execIncentive(isIncentive, fromToken, toToken);\n\n\n        emit OrderHistory(\n\n            fromToken,\n\n            toToken,\n\n            msg.sender,\n\n            fromTokenAmount,\n\n            returnAmount\n\n        );\n\n    }","after":"function dodoSwapV2TokenToToken(\n\n        address fromToken,\n\n        address toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] calldata dodoPairs,\n\n        uint256 directions,\n\n        bool isIncentive,\n\n        uint256 deadLine\n\n    )\n\n    external\n\n    override\n\n    judgeExpired(deadLine)\n\n    returns (uint256 returnAmount)\n\n    {\n\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n        uint256 originGas = gasleft();\n\n\n        uint256 originToTokenBalance = IERC20(toToken).balanceOf(msg.sender);\n\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(fromToken, msg.sender, dodoPairs[0], fromTokenAmount);\n\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n\n            if (i == dodoPairs.length - 1) {\n\n                if (directions & 1 == 0) {\n\n                    IDODOV2(dodoPairs[i]).sellBase(msg.sender);\n\n                } else {\n\n                    IDODOV2(dodoPairs[i]).sellQuote(msg.sender);\n\n                }\n\n            } else {\n\n                if (directions & 1 == 0) {\n\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n\n                } else {\n\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n\n                }\n\n            }\n\n            directions = directions >> 1;\n\n        }\n\n        returnAmount = IERC20(toToken).balanceOf(msg.sender).sub(originToTokenBalance);\n\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n\n        _dodoGasReturn(originGas);\n\n\n        _execIncentive(isIncentive, fromToken, toToken);\n\n\n        emit OrderHistory(\n\n            fromToken,\n\n            toToken,\n\n            msg.sender,\n\n            fromTokenAmount,\n\n            returnAmount\n\n        );\n\n    }","contract":"DODOV2Proxy02","time":0},{"type":"external-function ","before":"function externalSwap(\n\n        address fromToken,\n\n        address toToken,\n\n        address approveTarget,\n\n        address swapTarget,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        bytes memory callDataConcat,\n\n        bool isIncentive,\n\n        uint256 deadLine\n\n    )\n\n    external\n\n    override\n\n    payable\n\n    judgeExpired(deadLine)\n\n    returns (uint256 returnAmount)\n\n    {\n\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n        require(fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\n\n        require(toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\n\n\n        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);\n\n        if (fromToken != _ETH_ADDRESS_) {\n\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n\n                fromToken,\n\n                msg.sender,\n\n                address(this),\n\n                fromTokenAmount\n\n            );\n\n            IERC20(fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n\n        }\n\n\n        require(isWhiteListed[swapTarget], \"DODOV2Proxy02: Not Whitelist Contract\");\n\n        (bool success,) = swapTarget.call{value : fromToken == _ETH_ADDRESS_ ? msg.value : 0}(callDataConcat);\n\n\n        require(success, \"DODOV2Proxy02: External Swap execution Failed\");\n\n\n        IERC20(toToken).universalTransfer(\n\n            msg.sender,\n\n            IERC20(toToken).universalBalanceOf(address(this))\n\n        );\n\n\n        returnAmount = IERC20(toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\n\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n\n        _externalGasReturn();\n\n\n        _execIncentive(isIncentive, fromToken, toToken);\n\n\n        emit OrderHistory(\n\n            fromToken,\n\n            toToken,\n\n            msg.sender,\n\n            fromTokenAmount,\n\n            returnAmount\n\n        );\n\n    }","after":"function externalSwap(\n\n        address fromToken,\n\n        address toToken,\n\n        address approveTarget,\n\n        address swapTarget,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        bytes calldata callDataConcat,\n\n        bool isIncentive,\n\n        uint256 deadLine\n\n    )\n\n    external\n\n    override\n\n    payable\n\n    judgeExpired(deadLine)\n\n    returns (uint256 returnAmount)\n\n    {\n\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n        require(fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\n\n        require(toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\n\n\n        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);\n\n        if (fromToken != _ETH_ADDRESS_) {\n\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n\n                fromToken,\n\n                msg.sender,\n\n                address(this),\n\n                fromTokenAmount\n\n            );\n\n            IERC20(fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n\n        }\n\n\n        require(isWhiteListed[swapTarget], \"DODOV2Proxy02: Not Whitelist Contract\");\n\n        (bool success,) = swapTarget.call{value : fromToken == _ETH_ADDRESS_ ? msg.value : 0}(callDataConcat);\n\n\n        require(success, \"DODOV2Proxy02: External Swap execution Failed\");\n\n\n        IERC20(toToken).universalTransfer(\n\n            msg.sender,\n\n            IERC20(toToken).universalBalanceOf(address(this))\n\n        );\n\n\n        returnAmount = IERC20(toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\n\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n\n        _externalGasReturn();\n\n\n        _execIncentive(isIncentive, fromToken, toToken);\n\n\n        emit OrderHistory(\n\n            fromToken,\n\n            toToken,\n\n            msg.sender,\n\n            fromTokenAmount,\n\n            returnAmount\n\n        );\n\n    }","contract":"DODOV2Proxy02","time":0},{"type":"external-function ","before":"function dodoSwapV1(\n\n        address fromToken,\n\n        address toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] memory dodoPairs,\n\n        uint256 directions,\n\n        bool isIncentive,\n\n        uint256 deadLine\n\n    )\n\n    external\n\n    override\n\n    payable\n\n    judgeExpired(deadLine)\n\n    returns (uint256 returnAmount)\n\n    {\n\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n        require(fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\n\n        require(toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\n\n\n        uint256 originGas = gasleft();\n\n\n        address _fromToken = fromToken;\n\n        address _toToken = toToken;\n\n\n        _deposit(msg.sender, address(this), _fromToken, fromTokenAmount, _fromToken == _ETH_ADDRESS_);\n\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n\n            address curDodoPair = dodoPairs[i];\n\n            if (directions & 1 == 0) {\n\n                address curDodoBase = IDODOV1(curDodoPair)._BASE_TOKEN_();\n\n                require(curDodoBase != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_CHI\");\n\n                uint256 curAmountIn = IERC20(curDodoBase).balanceOf(address(this));\n\n                IERC20(curDodoBase).universalApproveMax(curDodoPair, curAmountIn);\n\n                IDODOV1(curDodoPair).sellBaseToken(curAmountIn, 0, \"\");\n\n            } else {\n\n                address curDodoQuote = IDODOV1(curDodoPair)._QUOTE_TOKEN_();\n\n                require(curDodoQuote != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_CHI\");\n\n                uint256 curAmountIn = IERC20(curDodoQuote).balanceOf(address(this));\n\n                IERC20(curDodoQuote).universalApproveMax(curDodoPair, curAmountIn);\n\n                uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n\n                    curDodoPair,\n\n                    curAmountIn\n\n                );\n\n                IDODOV1(curDodoPair).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\n\n            }\n\n            directions = directions >> 1;\n\n        }\n\n\n        if (_toToken == _ETH_ADDRESS_) {\n\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n\n            IWETH(_WETH_).withdraw(returnAmount);\n\n        } else {\n\n            returnAmount = IERC20(_toToken).tokenBalanceOf(address(this));\n\n        }\n\n\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n        IERC20(_toToken).universalTransfer(msg.sender, returnAmount);\n\n\n        _dodoGasReturn(originGas);\n\n\n        _execIncentive(isIncentive, _fromToken, _toToken);\n\n\n        emit OrderHistory(_fromToken, _toToken, msg.sender, fromTokenAmount, returnAmount);\n\n    }","after":"function dodoSwapV1(\n\n        address fromToken,\n\n        address toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] calldata dodoPairs,\n\n        uint256 directions,\n\n        bool isIncentive,\n\n        uint256 deadLine\n\n    )\n\n    external\n\n    override\n\n    payable\n\n    judgeExpired(deadLine)\n\n    returns (uint256 returnAmount)\n\n    {\n\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n        require(fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\n\n        require(toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\n\n\n        uint256 originGas = gasleft();\n\n\n        address _fromToken = fromToken;\n\n        address _toToken = toToken;\n\n\n        _deposit(msg.sender, address(this), _fromToken, fromTokenAmount, _fromToken == _ETH_ADDRESS_);\n\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n\n            address curDodoPair = dodoPairs[i];\n\n            if (directions & 1 == 0) {\n\n                address curDodoBase = IDODOV1(curDodoPair)._BASE_TOKEN_();\n\n                require(curDodoBase != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_CHI\");\n\n                uint256 curAmountIn = IERC20(curDodoBase).balanceOf(address(this));\n\n                IERC20(curDodoBase).universalApproveMax(curDodoPair, curAmountIn);\n\n                IDODOV1(curDodoPair).sellBaseToken(curAmountIn, 0, \"\");\n\n            } else {\n\n                address curDodoQuote = IDODOV1(curDodoPair)._QUOTE_TOKEN_();\n\n                require(curDodoQuote != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_CHI\");\n\n                uint256 curAmountIn = IERC20(curDodoQuote).balanceOf(address(this));\n\n                IERC20(curDodoQuote).universalApproveMax(curDodoPair, curAmountIn);\n\n                uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n\n                    curDodoPair,\n\n                    curAmountIn\n\n                );\n\n                IDODOV1(curDodoPair).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\n\n            }\n\n            directions = directions >> 1;\n\n        }\n\n\n        if (_toToken == _ETH_ADDRESS_) {\n\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n\n            IWETH(_WETH_).withdraw(returnAmount);\n\n        } else {\n\n            returnAmount = IERC20(_toToken).tokenBalanceOf(address(this));\n\n        }\n\n\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n        IERC20(_toToken).universalTransfer(msg.sender, returnAmount);\n\n\n        _dodoGasReturn(originGas);\n\n\n        _execIncentive(isIncentive, _fromToken, _toToken);\n\n\n        emit OrderHistory(_fromToken, _toToken, msg.sender, fromTokenAmount, returnAmount);\n\n    }","contract":"DODOV2Proxy02","time":0},{"type":"external-function ","before":"function mixSwap(\n\n        address fromToken,\n\n        address toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] memory mixAdapters,\n\n        address[] memory mixPairs,\n\n        address[] memory assetTo,\n\n        uint256 directions,\n\n        bool isIncentive,\n\n        uint256 deadLine\n\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n\n        require(mixPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n\n        require(mixPairs.length == mixAdapters.length, \"DODOV2Proxy02: PAIR_ADAPTER_NOT_MATCH\");\n\n        require(mixPairs.length == assetTo.length - 1, \"DODOV2Proxy02: PAIR_ASSETTO_NOT_MATCH\");\n\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n\n        address _fromToken = fromToken;\n\n        address _toToken = toToken;\n\n        uint256 _fromTokenAmount = fromTokenAmount;\n\n\n        require(_fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\n\n        require(_toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\n\n\n        uint256 originGas = gasleft();\n\n        uint256 toTokenOriginBalance = IERC20(_toToken).universalBalanceOf(msg.sender);\n\n\n        _deposit(msg.sender, assetTo[0], _fromToken, _fromTokenAmount, _fromToken == _ETH_ADDRESS_);\n\n\n        for (uint256 i = 0; i < mixPairs.length; i++) {\n\n            if (directions & 1 == 0) {\n\n                IDODOAdapter(mixAdapters[i]).sellBase(assetTo[i + 1], mixPairs[i]);\n\n            } else {\n\n                IDODOAdapter(mixAdapters[i]).sellQuote(assetTo[i + 1], mixPairs[i]);\n\n            }\n\n            directions = directions >> 1;\n\n        }\n\n\n        if (_toToken == _ETH_ADDRESS_) {\n\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n\n            IWETH(_WETH_).withdraw(returnAmount);\n\n            msg.sender.transfer(returnAmount);\n\n        } else {\n\n            returnAmount = IERC20(_toToken).tokenBalanceOf(msg.sender).sub(toTokenOriginBalance);\n\n        }\n\n\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n\n        _dodoGasReturn(originGas);\n\n\n        _execIncentive(isIncentive, _fromToken, _toToken);\n\n\n        emit OrderHistory(\n\n            _fromToken,\n\n            _toToken,\n\n            msg.sender,\n\n            _fromTokenAmount,\n\n            returnAmount\n\n        );\n\n    }","after":"function mixSwap(\n\n        address fromToken,\n\n        address toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        address[] calldata mixAdapters,\n\n        address[] calldata mixPairs,\n\n        address[] calldata assetTo,\n\n        uint256 directions,\n\n        bool isIncentive,\n\n        uint256 deadLine\n\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n\n        require(mixPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n\n        require(mixPairs.length == mixAdapters.length, \"DODOV2Proxy02: PAIR_ADAPTER_NOT_MATCH\");\n\n        require(mixPairs.length == assetTo.length - 1, \"DODOV2Proxy02: PAIR_ASSETTO_NOT_MATCH\");\n\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n\n        address _fromToken = fromToken;\n\n        address _toToken = toToken;\n\n        uint256 _fromTokenAmount = fromTokenAmount;\n\n\n        require(_fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\n\n        require(_toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\n\n\n        uint256 originGas = gasleft();\n\n        uint256 toTokenOriginBalance = IERC20(_toToken).universalBalanceOf(msg.sender);\n\n\n        _deposit(msg.sender, assetTo[0], _fromToken, _fromTokenAmount, _fromToken == _ETH_ADDRESS_);\n\n\n        for (uint256 i = 0; i < mixPairs.length; i++) {\n\n            if (directions & 1 == 0) {\n\n                IDODOAdapter(mixAdapters[i]).sellBase(assetTo[i + 1], mixPairs[i]);\n\n            } else {\n\n                IDODOAdapter(mixAdapters[i]).sellQuote(assetTo[i + 1], mixPairs[i]);\n\n            }\n\n            directions = directions >> 1;\n\n        }\n\n\n        if (_toToken == _ETH_ADDRESS_) {\n\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n\n            IWETH(_WETH_).withdraw(returnAmount);\n\n            msg.sender.transfer(returnAmount);\n\n        } else {\n\n            returnAmount = IERC20(_toToken).tokenBalanceOf(msg.sender).sub(toTokenOriginBalance);\n\n        }\n\n\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n\n        _dodoGasReturn(originGas);\n\n\n        _execIncentive(isIncentive, _fromToken, _toToken);\n\n\n        emit OrderHistory(\n\n            _fromToken,\n\n            _toToken,\n\n            msg.sender,\n\n            _fromTokenAmount,\n\n            returnAmount\n\n        );\n\n    }","contract":"DODOV2Proxy02","time":0},{"type":"external-function ","before":"function createCrowdPooling(\n\n        address baseToken,\n\n        address quoteToken,\n\n        uint256 baseInAmount,\n\n        uint256[] memory timeLine,\n\n        uint256[] memory valueList,\n\n        bool isOpenTWAP,\n\n        uint256 deadLine\n\n    ) external override payable preventReentrant judgeExpired(deadLine) returns (address payable newCrowdPooling) {\n\n        address _baseToken = baseToken;\n\n        address _quoteToken = quoteToken == _ETH_ADDRESS_ ? _WETH_ : quoteToken;\n\n\n        newCrowdPooling = IDODOV2(_CP_FACTORY_).createCrowdPooling();\n\n\n        _deposit(\n\n            msg.sender,\n\n            newCrowdPooling,\n\n            _baseToken,\n\n            baseInAmount,\n\n            false\n\n        );\n\n\n        newCrowdPooling.transfer(msg.value);\n\n\n        IDODOV2(_CP_FACTORY_).initCrowdPooling(\n\n            newCrowdPooling,\n\n            msg.sender,\n\n            _baseToken,\n\n            _quoteToken,\n\n            timeLine,\n\n            valueList,\n\n            isOpenTWAP\n\n        );\n\n    }","after":"function createCrowdPooling(\n\n        address baseToken,\n\n        address quoteToken,\n\n        uint256 baseInAmount,\n\n        uint256[] calldata timeLine,\n\n        uint256[] calldata valueList,\n\n        bool isOpenTWAP,\n\n        uint256 deadLine\n\n    ) external override payable preventReentrant judgeExpired(deadLine) returns (address payable newCrowdPooling) {\n\n        address _baseToken = baseToken;\n\n        address _quoteToken = quoteToken == _ETH_ADDRESS_ ? _WETH_ : quoteToken;\n\n\n        newCrowdPooling = IDODOV2(_CP_FACTORY_).createCrowdPooling();\n\n\n        _deposit(\n\n            msg.sender,\n\n            newCrowdPooling,\n\n            _baseToken,\n\n            baseInAmount,\n\n            false\n\n        );\n\n\n        newCrowdPooling.transfer(msg.value);\n\n\n        IDODOV2(_CP_FACTORY_).initCrowdPooling(\n\n            newCrowdPooling,\n\n            msg.sender,\n\n            _baseToken,\n\n            _quoteToken,\n\n            timeLine,\n\n            valueList,\n\n            isOpenTWAP\n\n        );\n\n    }","contract":"DODOV2Proxy02","time":0}]}