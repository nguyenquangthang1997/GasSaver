{"time":167,"results":[{"type":"struct-data-arrangement ","before":"\naddress payable bidder\nuint256 amount\nbool exists","after":"uint256 amount\naddress payable bidder\nbool exists\n","contract":"AsyncArtwork","time":0},{"type":"external-function ","before":"function setupControlToken(uint256 controlTokenId, string memory controlTokenURI,\n        int256[] memory leverMinValues,\n        int256[] memory leverMaxValues,\n        int256[] memory leverStartValues,\n        address payable[] memory additionalCollaborators\n    ) public {\n        // check that a control token exists for this token id\n        require(controlTokenMapping[controlTokenId].exists, \"No control token found\");\n        // ensure that this token is not setup yet\n        require(controlTokenMapping[controlTokenId].isSetup == false, \"Already setup\");\n        // ensure that only the control token artist is attempting this mint\n        require(uniqueTokenCreators[controlTokenId][0] == msg.sender, \"Must be control token artist\");\n        // enforce that the length of all the array lengths are equal\n        require((leverMinValues.length == leverMaxValues.length) && (leverMaxValues.length == leverStartValues.length), \"Values array mismatch\");\n        // mint the control token here\n        super._safeMint(msg.sender, controlTokenId);\n        // set token URI\n        super._setTokenURI(controlTokenId, controlTokenURI);\n        // create the control token\n        controlTokenMapping[controlTokenId] = ControlToken(leverStartValues.length, true, true);\n        // create the control token levers now\n        for (uint256 k = 0; k < leverStartValues.length; k++) {\n            // enforce that maxValue is greater than or equal to minValue\n            require(leverMaxValues[k] >= leverMinValues[k], \"Max val must >= min\");\n            // enforce that currentValue is valid\n            require((leverStartValues[k] >= leverMinValues[k]) && (leverStartValues[k] <= leverMaxValues[k]), \"Invalid start val\");\n            // add the lever to this token\n            controlTokenMapping[controlTokenId].levers[k] = ControlLever(leverMinValues[k],\n                leverMaxValues[k], leverStartValues[k], true);\n        }\n        // the control token artist can optionally specify additional collaborators on this layer\n        for (uint256 i = 0; i < additionalCollaborators.length; i++) {\n            // can't provide burn address as collaborator\n            require(additionalCollaborators[i] != address(0));\n\n            uniqueTokenCreators[controlTokenId].push(additionalCollaborators[i]);\n        }\n    }","after":"function setupControlToken(uint256 controlTokenId, string calldata controlTokenURI,\n        int256[] calldata leverMinValues,\n        int256[] calldata leverMaxValues,\n        int256[] calldata leverStartValues,\n        address payable[] calldata additionalCollaborators\n    ) public {\n        // check that a control token exists for this token id\n        require(controlTokenMapping[controlTokenId].exists, \"No control token found\");\n        // ensure that this token is not setup yet\n        require(controlTokenMapping[controlTokenId].isSetup == false, \"Already setup\");\n        // ensure that only the control token artist is attempting this mint\n        require(uniqueTokenCreators[controlTokenId][0] == msg.sender, \"Must be control token artist\");\n        // enforce that the length of all the array lengths are equal\n        require((leverMinValues.length == leverMaxValues.length) && (leverMaxValues.length == leverStartValues.length), \"Values array mismatch\");\n        // mint the control token here\n        super._safeMint(msg.sender, controlTokenId);\n        // set token URI\n        super._setTokenURI(controlTokenId, controlTokenURI);\n        // create the control token\n        controlTokenMapping[controlTokenId] = ControlToken(leverStartValues.length, true, true);\n        // create the control token levers now\n        for (uint256 k = 0; k < leverStartValues.length; k++) {\n            // enforce that maxValue is greater than or equal to minValue\n            require(leverMaxValues[k] >= leverMinValues[k], \"Max val must >= min\");\n            // enforce that currentValue is valid\n            require((leverStartValues[k] >= leverMinValues[k]) && (leverStartValues[k] <= leverMaxValues[k]), \"Invalid start val\");\n            // add the lever to this token\n            controlTokenMapping[controlTokenId].levers[k] = ControlLever(leverMinValues[k],\n                leverMaxValues[k], leverStartValues[k], true);\n        }\n        // the control token artist can optionally specify additional collaborators on this layer\n        for (uint256 i = 0; i < additionalCollaborators.length; i++) {\n            // can't provide burn address as collaborator\n            require(additionalCollaborators[i] != address(0));\n\n            uniqueTokenCreators[controlTokenId].push(additionalCollaborators[i]);\n        }\n    }","contract":"AsyncArtwork","time":0},{"type":"external-function ","before":"function mintArtwork(uint256 artworkTokenId, string memory artworkTokenURI, address payable[] memory controlTokenArtists\n    ) public onlyWhitelistedCreator {\n        require(artworkTokenId == expectedTokenSupply, \"ExpectedTokenSupply different\");\n        // Mint the token that represents ownership of the entire artwork    \n        super._safeMint(msg.sender, artworkTokenId);\n        expectedTokenSupply++;\n\n        super._setTokenURI(artworkTokenId, artworkTokenURI);\n        // track the msg.sender address as the artist address for future royalties\n        uniqueTokenCreators[artworkTokenId].push(msg.sender);\n\n        // iterate through all control token URIs (1 for each control token)\n        for (uint256 i = 0; i < controlTokenArtists.length; i++) {\n            // can't provide burn address as artist\n            require(controlTokenArtists[i] != address(0));\n\n            // use the curren token supply as the next token id\n            uint256 controlTokenId = expectedTokenSupply;\n            expectedTokenSupply++;\n\n            uniqueTokenCreators[controlTokenId].push(controlTokenArtists[i]);\n            // stub in an existing control token so exists is true\n            controlTokenMapping[controlTokenId] = ControlToken(0, true, false);\n\n            if (controlTokenArtists[i] != msg.sender) {\n                bool containsControlTokenArtist = false;\n\n                for (uint256 k = 0; k < uniqueTokenCreators[artworkTokenId].length; k++) {\n                    if (uniqueTokenCreators[artworkTokenId][k] == controlTokenArtists[i]) {\n                        containsControlTokenArtist = true;\n                        break;\n                    }\n                }\n                if (containsControlTokenArtist == false) {\n                    uniqueTokenCreators[artworkTokenId].push(controlTokenArtists[i]);\n                }\n            }\n        }\n    }","after":"function mintArtwork(uint256 artworkTokenId, string calldata artworkTokenURI, address payable[] calldata controlTokenArtists\n    ) public onlyWhitelistedCreator {\n        require(artworkTokenId == expectedTokenSupply, \"ExpectedTokenSupply different\");\n        // Mint the token that represents ownership of the entire artwork    \n        super._safeMint(msg.sender, artworkTokenId);\n        expectedTokenSupply++;\n\n        super._setTokenURI(artworkTokenId, artworkTokenURI);\n        // track the msg.sender address as the artist address for future royalties\n        uniqueTokenCreators[artworkTokenId].push(msg.sender);\n\n        // iterate through all control token URIs (1 for each control token)\n        for (uint256 i = 0; i < controlTokenArtists.length; i++) {\n            // can't provide burn address as artist\n            require(controlTokenArtists[i] != address(0));\n\n            // use the curren token supply as the next token id\n            uint256 controlTokenId = expectedTokenSupply;\n            expectedTokenSupply++;\n\n            uniqueTokenCreators[controlTokenId].push(controlTokenArtists[i]);\n            // stub in an existing control token so exists is true\n            controlTokenMapping[controlTokenId] = ControlToken(0, true, false);\n\n            if (controlTokenArtists[i] != msg.sender) {\n                bool containsControlTokenArtist = false;\n\n                for (uint256 k = 0; k < uniqueTokenCreators[artworkTokenId].length; k++) {\n                    if (uniqueTokenCreators[artworkTokenId][k] == controlTokenArtists[i]) {\n                        containsControlTokenArtist = true;\n                        break;\n                    }\n                }\n                if (containsControlTokenArtist == false) {\n                    uniqueTokenCreators[artworkTokenId].push(controlTokenArtists[i]);\n                }\n            }\n        }\n    }","contract":"AsyncArtwork","time":0},{"type":"external-function ","before":"function useControlToken(uint256 controlTokenId, uint256[] memory leverIds, int256[] memory newValues) public payable {\n        // check if sender is owner/approved of token OR if they're a permissioned controller for the token owner\n        require(_isApprovedOrOwner(msg.sender, controlTokenId) || (permissionedControllers[ownerOf(controlTokenId)] == msg.sender),\n            \"Owner or permissioned only\");\n        // collect the previous lever values for the event emit below\n        int256[] memory previousValues = new int256[](newValues.length);\n\n        for (uint256 i = 0; i < leverIds.length; i++) {\n            // get the control lever\n            ControlLever storage lever = controlTokenMapping[controlTokenId].levers[leverIds[i]];\n\n            // Enforce that the new value is valid        \n            require((newValues[i] >= lever.minValue) && (newValues[i] <= lever.maxValue), \"Invalid val\");\n\n            // Enforce that the new value is different\n            require(newValues[i] != lever.currentValue, \"Must provide different val\");\n\n            // grab previous value for the event emit\n            int256 previousValue = lever.currentValue;\n\n            // Update token current value\n            lever.currentValue = newValues[i];\n\n            // collect the previous lever values for the event emit below\n            previousValues[i] = previousValue;\n        }\n\n        // if there's a payment then send it to the platform (for higher priority updates)\n        if (msg.value > 0) {\n            platformAddress.transfer(msg.value);\n        }\n\n        // emit event\n        emit ControlLeverUpdated(controlTokenId, msg.value, leverIds, previousValues, newValues);\n    }","after":"function useControlToken(uint256 controlTokenId, uint256[] calldata leverIds, int256[] calldata newValues) public payable {\n        // check if sender is owner/approved of token OR if they're a permissioned controller for the token owner\n        require(_isApprovedOrOwner(msg.sender, controlTokenId) || (permissionedControllers[ownerOf(controlTokenId)] == msg.sender),\n            \"Owner or permissioned only\");\n        // collect the previous lever values for the event emit below\n        int256[] memory previousValues = new int256[](newValues.length);\n\n        for (uint256 i = 0; i < leverIds.length; i++) {\n            // get the control lever\n            ControlLever storage lever = controlTokenMapping[controlTokenId].levers[leverIds[i]];\n\n            // Enforce that the new value is valid        \n            require((newValues[i] >= lever.minValue) && (newValues[i] <= lever.maxValue), \"Invalid val\");\n\n            // Enforce that the new value is different\n            require(newValues[i] != lever.currentValue, \"Must provide different val\");\n\n            // grab previous value for the event emit\n            int256 previousValue = lever.currentValue;\n\n            // Update token current value\n            lever.currentValue = newValues[i];\n\n            // collect the previous lever values for the event emit below\n            previousValues[i] = previousValue;\n        }\n\n        // if there's a payment then send it to the platform (for higher priority updates)\n        if (msg.value > 0) {\n            platformAddress.transfer(msg.value);\n        }\n\n        // emit event\n        emit ControlLeverUpdated(controlTokenId, msg.value, leverIds, previousValues, newValues);\n    }","contract":"AsyncArtwork","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"AsyncArtwork","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"AsyncArtwork","time":1}]}