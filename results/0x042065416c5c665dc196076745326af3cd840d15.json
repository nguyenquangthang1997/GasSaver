{"time":388,"results":[{"type":"external-function ","before":"function setAddress(\n        string memory _name,\n        address _address\n    )\n    external\n    onlyOwner\n    {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(\n            _name,\n            _address,\n            oldAddress\n        );\n    }","after":"function setAddress(\n        string calldata _name,\n        address _address\n    )\n    external\n    onlyOwner\n    {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(\n            _name,\n            _address,\n            oldAddress\n        );\n    }","contract":"Lib_AddressManager","time":0},{"type":"external-function ","before":"function getAddress(\n        string memory _name\n    )\n    external\n    view\n    returns (\n        address\n    )\n    {\n        return addresses[_getNameHash(_name)];\n    }","after":"function getAddress(\n        string calldata _name\n    )\n    external\n    view\n    returns (\n        address\n    )\n    {\n        return addresses[_getNameHash(_name)];\n    }","contract":"Lib_AddressManager","time":0},{"type":"loop-calculation","before":"uint256 listPtr;","after":"// move outside for loop\nuint256 listPtr;","loc":{"start":{"line":1720,"column":12},"end":{"line":1720,"column":27}},"contract":"Lib_RLPWriter","time":0},{"type":"external-function ","before":"function initializeFraudVerification(\n        bytes32 _preStateRoot,\n        Lib_OVMCodec.ChainBatchHeader memory _preStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _preStateRootProof,\n        Lib_OVMCodec.Transaction memory _transaction,\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader memory _transactionBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _transactionProof\n    )\n    override\n    public\n    contributesToFraudProof(_preStateRoot, Lib_OVMCodec.hashTransaction(_transaction))\n    {\n        bytes32 _txHash = Lib_OVMCodec.hashTransaction(_transaction);\n\n        if (_hasStateTransitioner(_preStateRoot, _txHash)) {\n            return;\n        }\n\n        iOVM_StateCommitmentChain ovmStateCommitmentChain = iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n        iOVM_CanonicalTransactionChain ovmCanonicalTransactionChain = iOVM_CanonicalTransactionChain(resolve(\"OVM_CanonicalTransactionChain\"));\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _preStateRoot,\n                _preStateRootBatchHeader,\n                _preStateRootProof\n            ),\n            \"Invalid pre-state root inclusion proof.\"\n        );\n\n        require(\n            ovmCanonicalTransactionChain.verifyTransaction(\n                _transaction,\n                _txChainElement,\n                _transactionBatchHeader,\n                _transactionProof\n            ),\n            \"Invalid transaction inclusion proof.\"\n        );\n\n        require(\n            _preStateRootBatchHeader.prevTotalElements + _preStateRootProof.index + 1 == _transactionBatchHeader.prevTotalElements + _transactionProof.index,\n            \"Pre-state root global index must equal to the transaction root global index.\"\n        );\n\n        _deployTransitioner(_preStateRoot, _txHash, _preStateRootProof.index);\n\n        emit FraudProofInitialized(\n            _preStateRoot,\n            _preStateRootProof.index,\n            _txHash,\n            msg.sender\n        );\n    }","after":"function initializeFraudVerification(\n        bytes32 _preStateRoot,\n        Lib_OVMCodec.ChainBatchHeader calldata _preStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof calldata _preStateRootProof,\n        Lib_OVMCodec.Transaction calldata _transaction,\n        Lib_OVMCodec.TransactionChainElement calldata _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader calldata _transactionBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof calldata _transactionProof\n    )\n    override\n    public\n    contributesToFraudProof(_preStateRoot, Lib_OVMCodec.hashTransaction(_transaction))\n    {\n        bytes32 _txHash = Lib_OVMCodec.hashTransaction(_transaction);\n\n        if (_hasStateTransitioner(_preStateRoot, _txHash)) {\n            return;\n        }\n\n        iOVM_StateCommitmentChain ovmStateCommitmentChain = iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n        iOVM_CanonicalTransactionChain ovmCanonicalTransactionChain = iOVM_CanonicalTransactionChain(resolve(\"OVM_CanonicalTransactionChain\"));\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _preStateRoot,\n                _preStateRootBatchHeader,\n                _preStateRootProof\n            ),\n            \"Invalid pre-state root inclusion proof.\"\n        );\n\n        require(\n            ovmCanonicalTransactionChain.verifyTransaction(\n                _transaction,\n                _txChainElement,\n                _transactionBatchHeader,\n                _transactionProof\n            ),\n            \"Invalid transaction inclusion proof.\"\n        );\n\n        require(\n            _preStateRootBatchHeader.prevTotalElements + _preStateRootProof.index + 1 == _transactionBatchHeader.prevTotalElements + _transactionProof.index,\n            \"Pre-state root global index must equal to the transaction root global index.\"\n        );\n\n        _deployTransitioner(_preStateRoot, _txHash, _preStateRootProof.index);\n\n        emit FraudProofInitialized(\n            _preStateRoot,\n            _preStateRootProof.index,\n            _txHash,\n            msg.sender\n        );\n    }","contract":"OVM_FraudVerifier","time":0},{"type":"external-function ","before":"function finalizeFraudVerification(\n        bytes32 _preStateRoot,\n        Lib_OVMCodec.ChainBatchHeader memory _preStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _preStateRootProof,\n        bytes32 _txHash,\n        bytes32 _postStateRoot,\n        Lib_OVMCodec.ChainBatchHeader memory _postStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _postStateRootProof\n    )\n    override\n    public\n    contributesToFraudProof(_preStateRoot, _txHash)\n    {\n        iOVM_StateTransitioner transitioner = getStateTransitioner(_preStateRoot, _txHash);\n        iOVM_StateCommitmentChain ovmStateCommitmentChain = iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n\n        require(\n            transitioner.isComplete() == true,\n            \"State transition process must be completed prior to finalization.\"\n        );\n\n        require(\n            _postStateRootBatchHeader.prevTotalElements + _postStateRootProof.index == _preStateRootBatchHeader.prevTotalElements + _preStateRootProof.index + 1,\n            \"Post-state root global index must equal to the pre state root global index plus one.\"\n        );\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _preStateRoot,\n                _preStateRootBatchHeader,\n                _preStateRootProof\n            ),\n            \"Invalid pre-state root inclusion proof.\"\n        );\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _postStateRoot,\n                _postStateRootBatchHeader,\n                _postStateRootProof\n            ),\n            \"Invalid post-state root inclusion proof.\"\n        );\n\n        // If the post state root did not match, then there was fraud and we should delete the batch\n        require(\n            _postStateRoot != transitioner.getPostStateRoot(),\n            \"State transition has not been proven fraudulent.\"\n        );\n\n        _cancelStateTransition(_postStateRootBatchHeader, _preStateRoot);\n\n        // TEMPORARY: Remove the transitioner; for minnet.\n        transitioners[keccak256(abi.encodePacked(_preStateRoot, _txHash))] = iOVM_StateTransitioner(0x0000000000000000000000000000000000000000);\n\n        emit FraudProofFinalized(\n            _preStateRoot,\n            _preStateRootProof.index,\n            _txHash,\n            msg.sender\n        );\n    }","after":"function finalizeFraudVerification(\n        bytes32 _preStateRoot,\n        Lib_OVMCodec.ChainBatchHeader calldata _preStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof calldata _preStateRootProof,\n        bytes32 _txHash,\n        bytes32 _postStateRoot,\n        Lib_OVMCodec.ChainBatchHeader calldata _postStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof calldata _postStateRootProof\n    )\n    override\n    public\n    contributesToFraudProof(_preStateRoot, _txHash)\n    {\n        iOVM_StateTransitioner transitioner = getStateTransitioner(_preStateRoot, _txHash);\n        iOVM_StateCommitmentChain ovmStateCommitmentChain = iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n\n        require(\n            transitioner.isComplete() == true,\n            \"State transition process must be completed prior to finalization.\"\n        );\n\n        require(\n            _postStateRootBatchHeader.prevTotalElements + _postStateRootProof.index == _preStateRootBatchHeader.prevTotalElements + _preStateRootProof.index + 1,\n            \"Post-state root global index must equal to the pre state root global index plus one.\"\n        );\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _preStateRoot,\n                _preStateRootBatchHeader,\n                _preStateRootProof\n            ),\n            \"Invalid pre-state root inclusion proof.\"\n        );\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _postStateRoot,\n                _postStateRootBatchHeader,\n                _postStateRootProof\n            ),\n            \"Invalid post-state root inclusion proof.\"\n        );\n\n        // If the post state root did not match, then there was fraud and we should delete the batch\n        require(\n            _postStateRoot != transitioner.getPostStateRoot(),\n            \"State transition has not been proven fraudulent.\"\n        );\n\n        _cancelStateTransition(_postStateRootBatchHeader, _preStateRoot);\n\n        // TEMPORARY: Remove the transitioner; for minnet.\n        transitioners[keccak256(abi.encodePacked(_preStateRoot, _txHash))] = iOVM_StateTransitioner(0x0000000000000000000000000000000000000000);\n\n        emit FraudProofFinalized(\n            _preStateRoot,\n            _preStateRootProof.index,\n            _txHash,\n            msg.sender\n        );\n    }","contract":"OVM_FraudVerifier","time":0}]}