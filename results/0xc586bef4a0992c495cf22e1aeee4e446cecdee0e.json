{"time":78,"results":[{"type":"external-function ","before":"function swap(\n\n        IERC20 fromToken,\n\n        IERC20 toToken,\n\n        uint256 amount,\n\n        uint256 minReturn,\n\n        uint256[] memory distribution,\n\n        uint256 featureFlags // See contants in IOneSplit.sol\n\n    ) public payable {\n\n        require(fromToken != toToken && amount > 0, \"OneSplit: swap makes no sense\");\n\n        require((msg.value != 0) == fromToken.isETH(), \"OneSplit: msg.value shoule be used only for ETH swap\");\n\n\n        uint256 fromTokenBalanceBefore = fromToken.universalBalanceOf(address(this)).sub(msg.value);\n\n        uint256 toTokenBalanceBefore = toToken.universalBalanceOf(address(this));\n\n\n        fromToken.universalTransferFromSenderToThis(amount);\n\n        fromToken.universalApprove(address(oneSplitImpl), amount);\n\n\n        oneSplitImpl.swap.value(msg.value)(\n\n            fromToken,\n\n            toToken,\n\n            amount,\n\n            minReturn,\n\n            distribution,\n\n            featureFlags\n\n        );\n\n\n        uint256 fromTokenBalanceAfter = fromToken.universalBalanceOf(address(this));\n\n        uint256 toTokenBalanceAfter = toToken.universalBalanceOf(address(this));\n\n\n        uint256 returnAmount = toTokenBalanceAfter.sub(toTokenBalanceBefore);\n\n        require(returnAmount >= minReturn, \"OneSplit: actual return amount is less than minReturn\");\n\n        toToken.universalTransfer(msg.sender, returnAmount);\n\n\n        if (fromTokenBalanceAfter > fromTokenBalanceBefore) {\n\n            fromToken.universalTransfer(msg.sender, fromTokenBalanceAfter.sub(fromTokenBalanceBefore));\n\n        }\n\n    }","after":"function swap(\n\n        IERC20 fromToken,\n\n        IERC20 toToken,\n\n        uint256 amount,\n\n        uint256 minReturn,\n\n        uint256[] calldata distribution,\n\n        uint256 featureFlags // See contants in IOneSplit.sol\n\n    ) public payable {\n\n        require(fromToken != toToken && amount > 0, \"OneSplit: swap makes no sense\");\n\n        require((msg.value != 0) == fromToken.isETH(), \"OneSplit: msg.value shoule be used only for ETH swap\");\n\n\n        uint256 fromTokenBalanceBefore = fromToken.universalBalanceOf(address(this)).sub(msg.value);\n\n        uint256 toTokenBalanceBefore = toToken.universalBalanceOf(address(this));\n\n\n        fromToken.universalTransferFromSenderToThis(amount);\n\n        fromToken.universalApprove(address(oneSplitImpl), amount);\n\n\n        oneSplitImpl.swap.value(msg.value)(\n\n            fromToken,\n\n            toToken,\n\n            amount,\n\n            minReturn,\n\n            distribution,\n\n            featureFlags\n\n        );\n\n\n        uint256 fromTokenBalanceAfter = fromToken.universalBalanceOf(address(this));\n\n        uint256 toTokenBalanceAfter = toToken.universalBalanceOf(address(this));\n\n\n        uint256 returnAmount = toTokenBalanceAfter.sub(toTokenBalanceBefore);\n\n        require(returnAmount >= minReturn, \"OneSplit: actual return amount is less than minReturn\");\n\n        toToken.universalTransfer(msg.sender, returnAmount);\n\n\n        if (fromTokenBalanceAfter > fromTokenBalanceBefore) {\n\n            fromToken.universalTransfer(msg.sender, fromTokenBalanceAfter.sub(fromTokenBalanceBefore));\n\n        }\n\n    }","contract":"OneSplitAudit","time":0}]}