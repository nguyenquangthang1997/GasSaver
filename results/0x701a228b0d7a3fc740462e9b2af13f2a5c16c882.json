{"time":155,"results":[{"type":"constant-restrict-modification  ","before":"address public WETH;","after":"address public constant WETH;","contract":"ChainlinkedKeydonixOracleMainAssetAbstract","time":0},{"type":"external-function ","before":"function triggerLiquidation(\n        address asset,\n        address user,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory mainProof,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct memory colProof\n    )\n    public\n    override\n    nonReentrant\n    {\n        // USD value of the main collateral\n        uint mainUsdValue_q112 = uniswapOracleMainAsset.assetToUsd(asset, vault.collaterals(asset, user), mainProof);\n\n        // USD value of the COL amount of a position\n        uint colUsdValue_q112 = uniswapOracleMainAsset.assetToUsd(vault.col(), vault.colToken(asset, user), colProof);\n\n        // reverts if a position is not liquidatable\n        require(isLiquidatablePosition(asset, user, mainUsdValue_q112, colUsdValue_q112), \"Unit Protocol: SAFE_POSITION\");\n\n        uint liquidationDiscount_q112 = mainUsdValue_q112.add(colUsdValue_q112).mul(\n            vaultManagerParameters.liquidationDiscount(asset)\n        ).div(DENOMINATOR_1E5);\n\n        uint initialLiquidationPrice = mainUsdValue_q112.add(colUsdValue_q112).sub(liquidationDiscount_q112).div(Q112);\n\n        // sends liquidation command to the Vault\n        vault.triggerLiquidation(asset, user, initialLiquidationPrice);\n\n        // fire an liquidation event\n        emit LiquidationTriggered(asset, user);\n    }","after":"function triggerLiquidation(\n        address asset,\n        address user,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata mainProof,\n        ChainlinkedKeydonixOracleMainAssetAbstract.ProofDataStruct calldata colProof\n    )\n    public\n    override\n    nonReentrant\n    {\n        // USD value of the main collateral\n        uint mainUsdValue_q112 = uniswapOracleMainAsset.assetToUsd(asset, vault.collaterals(asset, user), mainProof);\n\n        // USD value of the COL amount of a position\n        uint colUsdValue_q112 = uniswapOracleMainAsset.assetToUsd(vault.col(), vault.colToken(asset, user), colProof);\n\n        // reverts if a position is not liquidatable\n        require(isLiquidatablePosition(asset, user, mainUsdValue_q112, colUsdValue_q112), \"Unit Protocol: SAFE_POSITION\");\n\n        uint liquidationDiscount_q112 = mainUsdValue_q112.add(colUsdValue_q112).mul(\n            vaultManagerParameters.liquidationDiscount(asset)\n        ).div(DENOMINATOR_1E5);\n\n        uint initialLiquidationPrice = mainUsdValue_q112.add(colUsdValue_q112).sub(liquidationDiscount_q112).div(Q112);\n\n        // sends liquidation command to the Vault\n        vault.triggerLiquidation(asset, user, initialLiquidationPrice);\n\n        // fire an liquidation event\n        emit LiquidationTriggered(asset, user);\n    }","contract":"LiquidationTriggerKeydonixMainAsset","time":0},{"type":"immutable-restrict-modification ","before":"address payable public vault;","after":"address payable public immutable vault;","contract":"VaultParameters","time":0}]}