{"time":785,"results":[{"type":"external-function ","before":"function getCollectedFeeAmounts(IERC20[] memory tokens) external view returns (uint256[] memory feeAmounts) {\n\n        feeAmounts = new uint256[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n\n            feeAmounts[i] = tokens[i].balanceOf(address(this));\n\n        }\n\n    }","after":"function getCollectedFeeAmounts(IERC20[] calldata tokens) external view returns (uint256[] memory feeAmounts) {\n\n        feeAmounts = new uint256[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n\n            feeAmounts[i] = tokens[i].balanceOf(address(this));\n\n        }\n\n    }","contract":"ProtocolFeesCollector","time":0},{"type":"immutable-restrict-modification ","before":"ate _totalSupply;\n\n\n ","after":"ate _totalSupply;\n\n\n ","contract":"ERC20","time":0},{"type":"immutable-restrict-modification ","before":"ing private _name;\n\n   ","after":"ing private _name;\n\n   ","contract":"ERC20","time":0},{"type":"external-function ","before":"       _;\n\n    }\n\n\n\n    function onJoinPool(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] memory balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    ) external virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n\n        uint256[] memory scalingFactors = _scalingFactors();\n\n\n        if (totalSupply() == 0) {\n\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(poolId, sender, recipient, userData);\n\n\n            // On initialization, we lock _MINIMUM_BPT by minting it for the zero address. This BPT acts as a minimum\n\n            // as it will never be burned, which reduces potential issues with rounding, and also prevents the Pool from\n\n            // ever being fully drained.\n\n            _require(bptAmountOut >= _MINIMUM_BPT, Errors.MINIMUM_BPT);\n\n            _mintPoolTokens(address(0), _MINIMUM_BPT);\n\n            _mintPoolTokens(recipient, bptAmountOut - _MINIMUM_BPT);\n\n\n            // amountsIn are amounts entering the Pool, so we round up.\n\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n\n            return (amountsIn, new uint256[](_getTotalTokens()));\n\n        } else {\n\n            _upscaleArray(balances, scalingFactors);\n\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\n\n                poolId,\n\n                sender,\n\n                recipient,\n\n                balances,\n\n                lastChangeBlock,\n\n                protocolSwapFeePercentage,\n\n                userData\n\n            );\n\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n\n            // amountsIn are amounts entering the Pool, so we round up.\n\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n\n            return (amountsIn, dueProtocolFeeAmo","after":"       _;\n\n    }\n\n\n\n    function onJoinPool(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] calldata balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    ) external virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n\n        uint256[] memory scalingFactors = _scalingFactors();\n\n\n        if (totalSupply() == 0) {\n\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(poolId, sender, recipient, userData);\n\n\n            // On initialization, we lock _MINIMUM_BPT by minting it for the zero address. This BPT acts as a minimum\n\n            // as it will never be burned, which reduces potential issues with rounding, and also prevents the Pool from\n\n            // ever being fully drained.\n\n            _require(bptAmountOut >= _MINIMUM_BPT, Errors.MINIMUM_BPT);\n\n            _mintPoolTokens(address(0), _MINIMUM_BPT);\n\n            _mintPoolTokens(recipient, bptAmountOut - _MINIMUM_BPT);\n\n\n            // amountsIn are amounts entering the Pool, so we round up.\n\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n\n            return (amountsIn, new uint256[](_getTotalTokens()));\n\n        } else {\n\n            _upscaleArray(balances, scalingFactors);\n\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\n\n                poolId,\n\n                sender,\n\n                recipient,\n\n                balances,\n\n                lastChangeBlock,\n\n                protocolSwapFeePercentage,\n\n                userData\n\n            );\n\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n\n            // amountsIn are amounts entering the Pool, so we round up.\n\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n\n            return (amountsIn, dueProtocolFeeAmo","contract":"WeightedPool","time":0},{"type":"external-function ","before":"\n        }\n\n    }\n\n\n    function onExitPool(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] memory balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    ) external virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        _upscaleArray(balances, scalingFactors);\n\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n\n            poolId,\n\n            sender,\n\n            recipient,\n\n            balances,\n\n            lastChangeBlock,\n\n            protocolSwapFeePercentage,\n\n            userData\n\n        );\n\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n\n        _downscaleDownArray(amountsOut, scalingFactors);\n\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n\n        return (amountsOut, duePro","after":"\n        }\n\n    }\n\n\n    function onExitPool(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] calldata balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    ) external virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        _upscaleArray(balances, scalingFactors);\n\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n\n            poolId,\n\n            sender,\n\n            recipient,\n\n            balances,\n\n            lastChangeBlock,\n\n            protocolSwapFeePercentage,\n\n            userData\n\n        );\n\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n\n        _downscaleDownArray(amountsOut, scalingFactors);\n\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n\n        return (amountsOut, duePro","contract":"WeightedPool","time":0},{"type":"external-function ","before":"nsaction.\n\n     */\n\n    function queryJoin(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] memory balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n\n        _queryAction(\n\n            poolId,\n\n            sender,\n\n            recipient,\n\n            balances,\n\n            lastChangeBlock,\n\n            protocolSwapFeePercentage,\n\n            userData,\n\n            _onJoinPool,\n\n            _downscaleUpArray\n\n        );\n\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n\n        // and we don't need to return anything here - it just silences compiler warnings.\n\n        return (bp","after":"nsaction.\n\n     */\n\n    function queryJoin(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] calldata balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n\n        _queryAction(\n\n            poolId,\n\n            sender,\n\n            recipient,\n\n            balances,\n\n            lastChangeBlock,\n\n            protocolSwapFeePercentage,\n\n            userData,\n\n            _onJoinPool,\n\n            _downscaleUpArray\n\n        );\n\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n\n        // and we don't need to return anything here - it just silences compiler warnings.\n\n        return (bp","contract":"WeightedPool","time":0},{"type":"external-function ","before":"nsaction.\n\n     */\n\n    function queryExit(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] memory balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n\n        _queryAction(\n\n            poolId,\n\n            sender,\n\n            recipient,\n\n            balances,\n\n            lastChangeBlock,\n\n            protocolSwapFeePercentage,\n\n            userData,\n\n            _onExitPool,\n\n            _downscaleDownArray\n\n        );\n\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n\n        // and we don't need to return anything here - it just silences compiler warnings.\n\n        return (bp","after":"nsaction.\n\n     */\n\n    function queryExit(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] calldata balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n\n        _queryAction(\n\n            poolId,\n\n            sender,\n\n            recipient,\n\n            balances,\n\n            lastChangeBlock,\n\n            protocolSwapFeePercentage,\n\n            userData,\n\n            _onExitPool,\n\n            _downscaleDownArray\n\n        );\n\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n\n        // and we don't need to return anything here - it just silences compiler warnings.\n\n        return (bp","contract":"WeightedPool","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"WeightedPool","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"WeightedPool","time":1},{"type":"constant-restrict-modification  ","before":"bytes32 private immutable _PERMIT_TYPE_HASH = keccak256(\n\n        \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n\n    );","after":"bytes32 private immutable constant _PERMIT_TYPE_HASH = keccak256(\n\n        \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n\n    );","contract":"WeightedPool","time":1},{"type":"external-function ","before":"    // Join Hook\n\n\n\n    function onJoinPool(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] memory balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    )\n\n    external\n\n    virtual\n\n    override\n\n    onlyVault(poolId)\n\n    whenNotPaused\n\n    returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts)\n\n    {\n\n        // All joins, including initializations, are disabled while the contract is paused.\n\n\n\n        uint256 bptAmountOut;\n\n        if (totalSupply() == 0) {\n\n            (bptAmountOut, amountsIn) = _onInitializePool(poolId, sender, recipient, userData);\n\n\n            // On initialization, we lock _MINIMUM_BPT by minting it for the zero address. This BPT acts as a minimum\n\n            // as it will never be burned, which reduces potential issues with rounding, and also prevents the Pool from\n\n            // ever being fully drained.\n\n            _require(bptAmountOut >= _MINIMUM_BPT, Errors.MINIMUM_BPT);\n\n            _mintPoolTokens(address(0), _MINIMUM_BPT);\n\n            _mintPoolTokens(recipient, bptAmountOut - _MINIMUM_BPT);\n\n\n            // amountsIn are amounts entering the Pool, so we round up.\n\n            _downscaleUpArray(amountsIn);\n\n\n            // There are no due protocol fee amounts during initialization\n\n            dueProtocolFeeAmounts = new uint256[](2);\n\n        } else {\n\n            _upscaleArray(balances);\n\n\n            // Update price oracle with the pre-join balances\n\n            _updateOracle(lastChangeBlock, balances[0], balances[1]);\n\n\n            (bptAmountOut, amountsIn, dueProtocolFeeAmounts) = _onJoinPool(\n\n                poolId,\n\n                sender,\n\n                recipient,\n\n                balances,\n\n                lastChangeBlock,\n\n                protocolSwapFeePercentage,\n\n                userData\n\n            );\n\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n\n            // amountsIn are amounts entering the Pool, so we round up.\n\n            _downscaleUpArray(amountsIn);\n\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n\n            _downscaleDownArray(dueProtocolFeeAmounts);\n\n        }\n\n\n        // Update cached total supply and invariant using the results after the join that will be used for future\n\n        // oracle updates.\n\n        _cacheInva","after":"    // Join Hook\n\n\n\n    function onJoinPool(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] calldata balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    )\n\n    external\n\n    virtual\n\n    override\n\n    onlyVault(poolId)\n\n    whenNotPaused\n\n    returns (uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts)\n\n    {\n\n        // All joins, including initializations, are disabled while the contract is paused.\n\n\n\n        uint256 bptAmountOut;\n\n        if (totalSupply() == 0) {\n\n            (bptAmountOut, amountsIn) = _onInitializePool(poolId, sender, recipient, userData);\n\n\n            // On initialization, we lock _MINIMUM_BPT by minting it for the zero address. This BPT acts as a minimum\n\n            // as it will never be burned, which reduces potential issues with rounding, and also prevents the Pool from\n\n            // ever being fully drained.\n\n            _require(bptAmountOut >= _MINIMUM_BPT, Errors.MINIMUM_BPT);\n\n            _mintPoolTokens(address(0), _MINIMUM_BPT);\n\n            _mintPoolTokens(recipient, bptAmountOut - _MINIMUM_BPT);\n\n\n            // amountsIn are amounts entering the Pool, so we round up.\n\n            _downscaleUpArray(amountsIn);\n\n\n            // There are no due protocol fee amounts during initialization\n\n            dueProtocolFeeAmounts = new uint256[](2);\n\n        } else {\n\n            _upscaleArray(balances);\n\n\n            // Update price oracle with the pre-join balances\n\n            _updateOracle(lastChangeBlock, balances[0], balances[1]);\n\n\n            (bptAmountOut, amountsIn, dueProtocolFeeAmounts) = _onJoinPool(\n\n                poolId,\n\n                sender,\n\n                recipient,\n\n                balances,\n\n                lastChangeBlock,\n\n                protocolSwapFeePercentage,\n\n                userData\n\n            );\n\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n\n            // amountsIn are amounts entering the Pool, so we round up.\n\n            _downscaleUpArray(amountsIn);\n\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n\n            _downscaleDownArray(dueProtocolFeeAmounts);\n\n        }\n\n\n        // Update cached total supply and invariant using the results after the join that will be used for future\n\n        // oracle updates.\n\n        _cacheInva","contract":"WeightedPool2Tokens","time":0},{"type":"external-function ","before":"    // Exit Hook\n\n\n\n    function onExitPool(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] memory balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    ) external virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n\n        _upscaleArray(balances);\n\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n\n            poolId,\n\n            sender,\n\n            recipient,\n\n            balances,\n\n            lastChangeBlock,\n\n            protocolSwapFeePercentage,\n\n            userData\n\n        );\n\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n\n        _downscaleDownArray(amountsOut);\n\n        _downscaleDownArray(dueProtocolFeeAmounts);\n\n\n        // Update cached total supply and invariant using the results after the exit that will be used for future\n\n        // oracle updates, only if the pool was not paused (to minimize code paths taken while paused).\n\n        if (_isNotPaused()) {\n\n            _cacheInvariantAndSupply();\n\n        }\n\n\n        return (amountsOut, duePro","after":"    // Exit Hook\n\n\n\n    function onExitPool(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] calldata balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    ) external virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n\n        _upscaleArray(balances);\n\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n\n            poolId,\n\n            sender,\n\n            recipient,\n\n            balances,\n\n            lastChangeBlock,\n\n            protocolSwapFeePercentage,\n\n            userData\n\n        );\n\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n\n        _downscaleDownArray(amountsOut);\n\n        _downscaleDownArray(dueProtocolFeeAmounts);\n\n\n        // Update cached total supply and invariant using the results after the exit that will be used for future\n\n        // oracle updates, only if the pool was not paused (to minimize code paths taken while paused).\n\n        if (_isNotPaused()) {\n\n            _cacheInvariantAndSupply();\n\n        }\n\n\n        return (amountsOut, duePro","contract":"WeightedPool2Tokens","time":0},{"type":"external-function ","before":"antValue);\n\n    }\n\n\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n\n    external\n\n    view\n\n    override\n\n    returns (uint256[] memory results)\n\n    {\n\n        results = new uint256[](queries.length);\n\n\n        uint256 oracleIndex = _miscData.oracleIndex();\n\n\n        OracleAverageQuery memory query;\n\n        for (uint256 i = 0; i < queries.length; ++i) {\n\n            query = queries[i];\n\n            _require(query.secs != 0, Errors.ORACLE_BAD_SECS);\n\n\n            int256 beginAccumulator = _getPastAccumulator(query.variable, oracleIndex, query.ago + query.secs);\n\n            int256 endAccumulator = _getPastAccumulator(query.variable, oracleIndex, query.ago);\n\n            results[i] = _fromLowResLog((endAccumulator - beginAccumulator) / int256(query.s","after":"antValue);\n\n    }\n\n\n    function getTimeWeightedAverage(OracleAverageQuery[] memory queries)\n\n    external\n\n    view\n\n    override\n\n    returns (uint256[] memory results)\n\n    {\n\n        results = new uint256[](queries.length);\n\n\n        uint256 oracleIndex = _miscData.oracleIndex();\n\n\n        OracleAverageQuery memory query;\n\n        for (uint256 i = 0; i < queries.length; ++i) {\n\n            query = queries[i];\n\n            _require(query.secs != 0, Errors.ORACLE_BAD_SECS);\n\n\n            int256 beginAccumulator = _getPastAccumulator(query.variable, oracleIndex, query.ago + query.secs);\n\n            int256 endAccumulator = _getPastAccumulator(query.variable, oracleIndex, query.ago);\n\n            results[i] = _fromLowResLog((endAccumulator - beginAccumulator) / int256(query.s","contract":"WeightedPool2Tokens","time":0},{"type":"external-function ","before":"\n        }\n\n    }\n\n\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\n\n    external\n\n    view\n\n    override\n\n    returns (int256[] memory results)\n\n    {\n\n        results = new int256[](queries.length);\n\n\n        uint256 oracleIndex = _miscData.oracleIndex();\n\n\n        OracleAccumulatorQuery memory query;\n\n        for (uint256 i = 0; i < queries.length; ++i) {\n\n            query = queries[i];\n\n            results[i] = _getPastAccumulator(query.variable, oracleIndex, query","after":"\n        }\n\n    }\n\n\n    function getPastAccumulators(OracleAccumulatorQuery[] memory queries)\n\n    external\n\n    view\n\n    override\n\n    returns (int256[] memory results)\n\n    {\n\n        results = new int256[](queries.length);\n\n\n        uint256 oracleIndex = _miscData.oracleIndex();\n\n\n        OracleAccumulatorQuery memory query;\n\n        for (uint256 i = 0; i < queries.length; ++i) {\n\n            query = queries[i];\n\n            results[i] = _getPastAccumulator(query.variable, oracleIndex, query","contract":"WeightedPool2Tokens","time":0},{"type":"external-function ","before":"nsaction.\n\n     */\n\n    function queryJoin(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] memory balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n\n        InputHelpers.ensureInputLengthMatch(balances.length, 2);\n\n\n        _queryAction(\n\n            poolId,\n\n            sender,\n\n            recipient,\n\n            balances,\n\n            lastChangeBlock,\n\n            protocolSwapFeePercentage,\n\n            userData,\n\n            _onJoinPool,\n\n            _downscaleUpArray\n\n        );\n\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n\n        // and we don't need to return anything here - it just silences compiler warnings.\n\n        return (bp","after":"nsaction.\n\n     */\n\n    function queryJoin(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] calldata balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n\n        InputHelpers.ensureInputLengthMatch(balances.length, 2);\n\n\n        _queryAction(\n\n            poolId,\n\n            sender,\n\n            recipient,\n\n            balances,\n\n            lastChangeBlock,\n\n            protocolSwapFeePercentage,\n\n            userData,\n\n            _onJoinPool,\n\n            _downscaleUpArray\n\n        );\n\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n\n        // and we don't need to return anything here - it just silences compiler warnings.\n\n        return (bp","contract":"WeightedPool2Tokens","time":0},{"type":"external-function ","before":"nsaction.\n\n     */\n\n    function queryExit(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] memory balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n\n        InputHelpers.ensureInputLengthMatch(balances.length, 2);\n\n\n        _queryAction(\n\n            poolId,\n\n            sender,\n\n            recipient,\n\n            balances,\n\n            lastChangeBlock,\n\n            protocolSwapFeePercentage,\n\n            userData,\n\n            _onExitPool,\n\n            _downscaleDownArray\n\n        );\n\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n\n        // and we don't need to return anything here - it just silences compiler warnings.\n\n        return (bp","after":"nsaction.\n\n     */\n\n    function queryExit(\n\n        bytes32 poolId,\n\n        address sender,\n\n        address recipient,\n\n        uint256[] calldata balances,\n\n        uint256 lastChangeBlock,\n\n        uint256 protocolSwapFeePercentage,\n\n        bytes memory userData\n\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n\n        InputHelpers.ensureInputLengthMatch(balances.length, 2);\n\n\n        _queryAction(\n\n            poolId,\n\n            sender,\n\n            recipient,\n\n            balances,\n\n            lastChangeBlock,\n\n            protocolSwapFeePercentage,\n\n            userData,\n\n            _onExitPool,\n\n            _downscaleDownArray\n\n        );\n\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n\n        // and we don't need to return anything here - it just silences compiler warnings.\n\n        return (bp","contract":"WeightedPool2Tokens","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"WeightedPool2Tokens","time":2},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"WeightedPool2Tokens","time":2},{"type":"constant-restrict-modification  ","before":"bytes32 private immutable _PERMIT_TYPE_HASH = keccak256(\n\n        \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n\n    );","after":"bytes32 private immutable constant _PERMIT_TYPE_HASH = keccak256(\n\n        \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n\n    );","contract":"WeightedPool2Tokens","time":2}]}