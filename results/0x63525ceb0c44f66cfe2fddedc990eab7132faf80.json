{"time":309,"results":[{"type":"state-data-arrangement ","before":"\nuint8 internal constant FALSE = 0;\nuint8 internal constant TRUE = 1;\nbool internal _paused;\nuint256 internal _iTrustFeePercentage;\nuint256 public addressRequestFee;\naddress internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\naddress payable public iTrustTreasury;\naddress internal _nxmTokenAddress;\naddress internal _distributorAddress;\naddress[] internal _exchangeList;\nstring[] internal _userIds;\nuint8 internal LOCKED;\nmapping(address => uint8) internal _adminList;\nmapping(address => Exchange) internal _exchanges;\nmapping(uint256 => address) internal _exchangeLocations;\nmapping(address => string) internal _addressRequests;\nmapping(string => User) internal _userPolicies;\nmapping(uint256 => uint256) internal _claimIds;\nmapping(uint256 => uint256) internal _claimedAmounts;\nmapping(uint256 => uint8) internal _claimCount;\nbool private _initialized;\nbool private _initializing;\nuint constant DIV_PRECISION = 10000;","after":"uint256 internal _iTrustFeePercentage;\nuint256 public addressRequestFee;\naddress[] internal _exchangeList;\nstring[] internal _userIds;\nmapping(address => uint8) internal _adminList;\nmapping(address => Exchange) internal _exchanges;\nmapping(uint256 => address) internal _exchangeLocations;\nmapping(address => string) internal _addressRequests;\nmapping(string => User) internal _userPolicies;\nmapping(uint256 => uint256) internal _claimIds;\nmapping(uint256 => uint256) internal _claimedAmounts;\nmapping(uint256 => uint8) internal _claimCount;\nuint constant DIV_PRECISION = 10000;\naddress internal constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\naddress payable public iTrustTreasury;\naddress internal _nxmTokenAddress;\naddress internal _distributorAddress;\nuint8 internal constant FALSE = 0;\nuint8 internal constant TRUE = 1;\nbool internal _paused;\nuint8 internal LOCKED;\nbool private _initialized;\nbool private _initializing;\n","contract":"ITrustInsureV2_1","time":5},{"type":"struct-data-arrangement ","before":"\nbool active\nuint256 feePercentage\naddress payable treasuryAddress\nstring name\nuint256[] coverIds","after":"uint256 feePercentage\nstring name\nuint256[] coverIds\naddress payable treasuryAddress\nbool active\n","contract":"ITrustInsureV2_1","time":0},{"type":"struct-data-arrangement ","before":"\nuint256 coverId\nuint8 status\nuint256 sumAssured\nuint16 coverPeriod\nuint256 validUntil\naddress contractAddress\naddress coverAsset\nuint256 premiumInNXM\naddress memberAddress\nuint256 claimId\nuint256 claimStatus\nuint256 claimAmountPaid\naddress claimAsset\nbool claimsAllowed\nbool claimed\nbool iTrustOwned","after":"uint256 coverId\nuint256 sumAssured\nuint256 validUntil\nuint256 premiumInNXM\nuint256 claimId\nuint256 claimStatus\nuint256 claimAmountPaid\naddress contractAddress\naddress coverAsset\naddress memberAddress\naddress claimAsset\nuint16 coverPeriod\nuint8 status\nbool claimsAllowed\nbool claimed\nbool iTrustOwned\n","contract":"ITrustInsureV2_1","time":4},{"type":"external-function ","before":"function buyCover(\n\n        address exchangeAddress,\n\n        address contractAddress,\n\n        address coverAsset,\n\n        uint256 sumAssured,\n\n        uint16 coverPeriod,\n\n        uint8 coverType,\n\n        string memory userGUID,\n\n        bytes calldata coverData\n\n    )\n\n    external\n\n    payable\n\n    returns (uint256) {\n\n        nonReentrant();\n\n        ifNotPaused();\n\n        LOCKED = TRUE;\n\n\n        require(msg.value == _iTrustFeePercentage.mul(_getCoverPrice(coverData)).div(DIV_PRECISION).add(_getCoverPrice(coverData))\n\n        , \"Eth Sent and Price Mismatch\");\n\n\n        Exchange memory purchaseExchange = _exchanges[address(exchangeAddress)];\n\n        require(\n\n            purchaseExchange.treasuryAddress != address(0) && purchaseExchange.active,\n\n            \"iTrust: Inactive exchange\"\n\n        );\n\n\n        uint256 coverId = getDistributorContract().buyCover{value : msg.value}(\n\n            contractAddress,\n\n            coverAsset,\n\n            sumAssured,\n\n            coverPeriod,\n\n            coverType,\n\n            msg.value, //max cover price with fee\n\n            coverData\n\n        );\n\n\n        _saveCoverDetails(userGUID, coverId, purchaseExchange.treasuryAddress);\n\n\n        //send funds to exchange\n\n        require(\n\n            address(this).balance >= msg.value.sub(_getCoverPrice(coverData)),\n\n            \"iTrust: Insufficient ETH left for commission\"\n\n        );\n\n        uint256 exchangeCommission;\n\n        if (purchaseExchange.feePercentage > 0) {\n\n            exchangeCommission = _getCoverPrice(coverData)\n\n            .mul(purchaseExchange.feePercentage)\n\n            .div(DIV_PRECISION);\n\n        }\n\n\n        iTrustTreasury.transfer(msg.value.sub(_getCoverPrice(coverData)).sub(exchangeCommission));\n\n\n        if (exchangeCommission > 0) {\n\n            purchaseExchange.treasuryAddress.transfer(exchangeCommission);\n\n        }\n\n        //transfer NFT to itrust Treasury\n\n        getDistributorContract().safeTransferFrom(\n\n            address(this),\n\n            iTrustTreasury,\n\n            coverId\n\n        );\n\n        LOCKED = FALSE;\n\n        return coverId;\n\n    }","after":"function buyCover(\n\n        address exchangeAddress,\n\n        address contractAddress,\n\n        address coverAsset,\n\n        uint256 sumAssured,\n\n        uint16 coverPeriod,\n\n        uint8 coverType,\n\n        string calldata userGUID,\n\n        bytes calldata coverData\n\n    )\n\n    external\n\n    payable\n\n    returns (uint256) {\n\n        nonReentrant();\n\n        ifNotPaused();\n\n        LOCKED = TRUE;\n\n\n        require(msg.value == _iTrustFeePercentage.mul(_getCoverPrice(coverData)).div(DIV_PRECISION).add(_getCoverPrice(coverData))\n\n        , \"Eth Sent and Price Mismatch\");\n\n\n        Exchange memory purchaseExchange = _exchanges[address(exchangeAddress)];\n\n        require(\n\n            purchaseExchange.treasuryAddress != address(0) && purchaseExchange.active,\n\n            \"iTrust: Inactive exchange\"\n\n        );\n\n\n        uint256 coverId = getDistributorContract().buyCover{value : msg.value}(\n\n            contractAddress,\n\n            coverAsset,\n\n            sumAssured,\n\n            coverPeriod,\n\n            coverType,\n\n            msg.value, //max cover price with fee\n\n            coverData\n\n        );\n\n\n        _saveCoverDetails(userGUID, coverId, purchaseExchange.treasuryAddress);\n\n\n        //send funds to exchange\n\n        require(\n\n            address(this).balance >= msg.value.sub(_getCoverPrice(coverData)),\n\n            \"iTrust: Insufficient ETH left for commission\"\n\n        );\n\n        uint256 exchangeCommission;\n\n        if (purchaseExchange.feePercentage > 0) {\n\n            exchangeCommission = _getCoverPrice(coverData)\n\n            .mul(purchaseExchange.feePercentage)\n\n            .div(DIV_PRECISION);\n\n        }\n\n\n        iTrustTreasury.transfer(msg.value.sub(_getCoverPrice(coverData)).sub(exchangeCommission));\n\n\n        if (exchangeCommission > 0) {\n\n            purchaseExchange.treasuryAddress.transfer(exchangeCommission);\n\n        }\n\n        //transfer NFT to itrust Treasury\n\n        getDistributorContract().safeTransferFrom(\n\n            address(this),\n\n            iTrustTreasury,\n\n            coverId\n\n        );\n\n        LOCKED = FALSE;\n\n        return coverId;\n\n    }","contract":"ITrustInsureV2_1","time":0},{"type":"external-function ","before":"function onERC721Received(\n\n        address,\n\n        address,\n\n        uint256,\n\n        bytes memory\n\n    )\n\n    public\n\n    returns (bytes4)\n\n    {\n\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n\n    }","after":"function onERC721Received(\n\n        address,\n\n        address,\n\n        uint256,\n\n        bytes calldata\n\n    )\n\n    public\n\n    returns (bytes4)\n\n    {\n\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\n\n    }","contract":"ITrustInsureV2_1","time":0},{"type":"external-function ","before":"function addOrUpdateExchange(\n\n        address payable exchangeAddress,\n\n        uint256 feePercentage,\n\n        bool active,\n\n        string memory name\n\n    )\n\n    external\n\n    {\n\n        onlyAdmin();\n\n        if (_exchanges[exchangeAddress].treasuryAddress == address(0)) {\n\n            _exchangeList.push(exchangeAddress);\n\n        }\n\n        _exchanges[exchangeAddress] = Exchange({\n\n        feePercentage : feePercentage,\n\n        treasuryAddress : exchangeAddress,\n\n        active : active,\n\n        name : name,\n\n        coverIds : new uint256[](0)\n\n        });\n\n    }","after":"function addOrUpdateExchange(\n\n        address payable exchangeAddress,\n\n        uint256 feePercentage,\n\n        bool active,\n\n        string calldata name\n\n    )\n\n    external\n\n    {\n\n        onlyAdmin();\n\n        if (_exchanges[exchangeAddress].treasuryAddress == address(0)) {\n\n            _exchangeList.push(exchangeAddress);\n\n        }\n\n        _exchanges[exchangeAddress] = Exchange({\n\n        feePercentage : feePercentage,\n\n        treasuryAddress : exchangeAddress,\n\n        active : active,\n\n        name : name,\n\n        coverIds : new uint256[](0)\n\n        });\n\n    }","contract":"ITrustInsureV2_1","time":0},{"type":"external-function ","before":"function submitClaim(\n\n        string memory userGUID,\n\n        uint256 coverId,\n\n        bytes calldata coverClaimData\n\n    )\n\n    external\n\n    returns (uint256)\n\n    {\n\n        ifNotPaused();\n\n        CoverData memory cover = _getCoverData(coverId);\n\n        require(cover.iTrustOwned, \"submit NFT\");\n\n        require(cover.claimsAllowed\n\n        && _userOwnsCover(userGUID, coverId) == TRUE\n\n            && msg.sender == _userPolicies[userGUID].walletAddress);\n        //check cover\n\n\n\n        uint256 claimId =\n\n        getDistributorContract().submitClaim(coverId, coverClaimData);\n\n        _claimIds[coverId] = claimId;\n\n        _claimCount[coverId] = _claimCount[coverId] + TRUE;\n\n        return claimId;\n\n    }","after":"function submitClaim(\n\n        string calldata userGUID,\n\n        uint256 coverId,\n\n        bytes calldata coverClaimData\n\n    )\n\n    external\n\n    returns (uint256)\n\n    {\n\n        ifNotPaused();\n\n        CoverData memory cover = _getCoverData(coverId);\n\n        require(cover.iTrustOwned, \"submit NFT\");\n\n        require(cover.claimsAllowed\n\n        && _userOwnsCover(userGUID, coverId) == TRUE\n\n            && msg.sender == _userPolicies[userGUID].walletAddress);\n        //check cover\n\n\n\n        uint256 claimId =\n\n        getDistributorContract().submitClaim(coverId, coverClaimData);\n\n        _claimIds[coverId] = claimId;\n\n        _claimCount[coverId] = _claimCount[coverId] + TRUE;\n\n        return claimId;\n\n    }","contract":"ITrustInsureV2_1","time":0},{"type":"external-function ","before":"function getCoverData(string memory userGUID)\n\n    external\n\n    view\n\n    returns (CoverData[] memory covers)\n\n    {\n\n        onlyAdmin();\n\n\n        uint256 i;\n\n\n        CoverData[] memory userCover = new CoverData[](_userPolicies[userGUID].coverIds.length);\n\n\n        while (i < _userPolicies[userGUID].coverIds.length) {\n\n            userCover[i] = _getCoverData(_userPolicies[userGUID].coverIds[i]);\n\n            i++;\n\n        }\n\n        return userCover;\n\n    }","after":"function getCoverData(string calldata userGUID)\n\n    external\n\n    view\n\n    returns (CoverData[] memory covers)\n\n    {\n\n        onlyAdmin();\n\n\n        uint256 i;\n\n\n        CoverData[] memory userCover = new CoverData[](_userPolicies[userGUID].coverIds.length);\n\n\n        while (i < _userPolicies[userGUID].coverIds.length) {\n\n            userCover[i] = _getCoverData(_userPolicies[userGUID].coverIds[i]);\n\n            i++;\n\n        }\n\n        return userCover;\n\n    }","contract":"ITrustInsureV2_1","time":0},{"type":"external-function ","before":"function addAddressRequest(string memory uid)\n\n    external\n\n    payable\n\n    {\n\n        ifNotPaused();\n\n        require(\n\n            msg.value >= addressRequestFee,\n\n            \"Insufficient ETH\"\n\n        );\n\n\n        _addressRequests[msg.sender] = uid;\n\n\n        iTrustTreasury.transfer(msg.value);\n\n\n    }","after":"function addAddressRequest(string calldata uid)\n\n    external\n\n    payable\n\n    {\n\n        ifNotPaused();\n\n        require(\n\n            msg.value >= addressRequestFee,\n\n            \"Insufficient ETH\"\n\n        );\n\n\n        _addressRequests[msg.sender] = uid;\n\n\n        iTrustTreasury.transfer(msg.value);\n\n\n    }","contract":"ITrustInsureV2_1","time":0},{"type":"external-function ","before":"function hasAddressRequest(string memory uid) external view returns (bool) {\n\n        return\n\n        keccak256(abi.encodePacked(_addressRequests[msg.sender])) ==\n\n        keccak256(abi.encodePacked(uid));\n\n    }","after":"function hasAddressRequest(string calldata uid) external view returns (bool) {\n\n        return\n\n        keccak256(abi.encodePacked(_addressRequests[msg.sender])) ==\n\n        keccak256(abi.encodePacked(uid));\n\n    }","contract":"ITrustInsureV2_1","time":0},{"type":"external-function ","before":"function isValidAddressRequest(string memory uid, address newAddress)\n\n    external\n\n    view\n\n    returns (bool)\n\n    {\n\n        onlyAdmin();\n\n\n        return\n\n        keccak256(abi.encodePacked(_addressRequests[newAddress])) ==\n\n        keccak256(abi.encodePacked(uid));\n\n    }","after":"function isValidAddressRequest(string calldata uid, address newAddress)\n\n    external\n\n    view\n\n    returns (bool)\n\n    {\n\n        onlyAdmin();\n\n\n        return\n\n        keccak256(abi.encodePacked(_addressRequests[newAddress])) ==\n\n        keccak256(abi.encodePacked(uid));\n\n    }","contract":"ITrustInsureV2_1","time":0},{"type":"external-function ","before":"function validateAddressRequest(string memory uid, address newAddress)\n\n    external\n\n    {\n\n        onlyAdmin();\n\n        ifNotPaused();\n\n        require(\n\n            (keccak256(abi.encodePacked(_addressRequests[newAddress])) ==\n\n        keccak256(abi.encodePacked(uid))),\n\n            \"address missmatch\"\n\n        );\n\n\n        delete _addressRequests[newAddress];\n\n\n        _userPolicies[uid].walletAddress = newAddress;\n\n    }","after":"function validateAddressRequest(string calldata uid, address newAddress)\n\n    external\n\n    {\n\n        onlyAdmin();\n\n        ifNotPaused();\n\n        require(\n\n            (keccak256(abi.encodePacked(_addressRequests[newAddress])) ==\n\n        keccak256(abi.encodePacked(uid))),\n\n            \"address missmatch\"\n\n        );\n\n\n        delete _addressRequests[newAddress];\n\n\n        _userPolicies[uid].walletAddress = newAddress;\n\n    }","contract":"ITrustInsureV2_1","time":0},{"type":"external-function ","before":"function redeemClaim(string memory userId, uint256 coverId)\n\n    external\n\n    {\n\n        nonReentrant();\n\n        LOCKED = TRUE;\n\n        require(msg.sender == _userPolicies[userId].walletAddress);\n\n\n        (\n\n        IDistributor.ClaimStatus claimStatus,\n\n        uint amountPaid,\n\n        address coverAsset\n\n        ) = getDistributorContract().getPayoutOutcome(_claimIds[coverId]);\n\n        require(claimStatus == IDistributor.ClaimStatus.ACCEPTED &&\n\n        amountPaid > uint(0) &&\n\n            _claimedAmounts[coverId] == uint(0));\n\n\n        _claimedAmounts[coverId] = amountPaid;\n\n        getDistributorContract().redeemClaim(coverId, _claimIds[coverId]);\n\n        if (coverAsset == ETH) {\n\n            payable(msg.sender).transfer(amountPaid);\n\n        } else {\n\n            IERC20 erc20 = IERC20(coverAsset);\n\n            erc20.safeTransfer(msg.sender, amountPaid);\n\n        }\n\n\n        emit ITrustClaimPayoutRedeemed(coverId, _claimIds[coverId], msg.sender, amountPaid, coverAsset);\n\n        LOCKED = FALSE;\n\n    }","after":"function redeemClaim(string calldata userId, uint256 coverId)\n\n    external\n\n    {\n\n        nonReentrant();\n\n        LOCKED = TRUE;\n\n        require(msg.sender == _userPolicies[userId].walletAddress);\n\n\n        (\n\n        IDistributor.ClaimStatus claimStatus,\n\n        uint amountPaid,\n\n        address coverAsset\n\n        ) = getDistributorContract().getPayoutOutcome(_claimIds[coverId]);\n\n        require(claimStatus == IDistributor.ClaimStatus.ACCEPTED &&\n\n        amountPaid > uint(0) &&\n\n            _claimedAmounts[coverId] == uint(0));\n\n\n        _claimedAmounts[coverId] = amountPaid;\n\n        getDistributorContract().redeemClaim(coverId, _claimIds[coverId]);\n\n        if (coverAsset == ETH) {\n\n            payable(msg.sender).transfer(amountPaid);\n\n        } else {\n\n            IERC20 erc20 = IERC20(coverAsset);\n\n            erc20.safeTransfer(msg.sender, amountPaid);\n\n        }\n\n\n        emit ITrustClaimPayoutRedeemed(coverId, _claimIds[coverId], msg.sender, amountPaid, coverAsset);\n\n        LOCKED = FALSE;\n\n    }","contract":"ITrustInsureV2_1","time":0},{"type":"external-function ","before":"function withdrawNFT(string memory userGUID, uint coverId) external {\n\n        nonReentrant();\n\n        LOCKED = TRUE;\n\n        require(\n\n            _userOwnsCover(userGUID, coverId) == TRUE &&\n\n            msg.sender == _userPolicies[userGUID].walletAddress);\n\n\n        IERC721 nftToken = IERC721(_distributorAddress);\n\n        nftToken.safeTransferFrom(iTrustTreasury, payable(_userPolicies[userGUID].walletAddress), coverId);\n\n        LOCKED = FALSE;\n\n    }","after":"function withdrawNFT(string calldata userGUID, uint coverId) external {\n\n        nonReentrant();\n\n        LOCKED = TRUE;\n\n        require(\n\n            _userOwnsCover(userGUID, coverId) == TRUE &&\n\n            msg.sender == _userPolicies[userGUID].walletAddress);\n\n\n        IERC721 nftToken = IERC721(_distributorAddress);\n\n        nftToken.safeTransferFrom(iTrustTreasury, payable(_userPolicies[userGUID].walletAddress), coverId);\n\n        LOCKED = FALSE;\n\n    }","contract":"ITrustInsureV2_1","time":0}]}