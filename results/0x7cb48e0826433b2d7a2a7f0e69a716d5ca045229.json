{"time":1232,"results":[{"type":"immutable-restrict-modification ","before":"   address public timelo","after":"   address public timelo","contract":"EarnedAggregator","time":0},{"type":"external-function ","before":" and whitelister for the contract.\n   * @param _root The default merkleRoot.\n   * @param _uri The link to the full whitelist.\n   */\n    constructor(\n        address _admin,\n        bytes32 _root,\n        string memory _uri\n    ) {\n        merkleRoot = _root;\n        sourceUri = _uri;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        _setupRo","after":" and whitelister for the contract.\n   * @param _root The default merkleRoot.\n   * @param _uri The link to the full whitelist.\n   */\n    constructor(\n        address _admin,\n        bytes32 _root,\n        string memory _uri\n    ) {\n        merkleRoot = _root;\n        sourceUri = _uri;\n\n        _setupRole(DEFAULT_ADMIN_ROLE, _admin);\n        _setupRo","contract":"MerkleWhitelist","time":0},{"type":"external-function ","before":"       bytes32[] memory _proof,\n        bytes32 _leaf\n    ) internal pure returns (bool) {\n        bytes32 computedHash = _leaf;\n\n        for (uint256 i = 0; i < _proof.length; i++) {\n            bytes32 proofElement = _proof[i];\n\n            if (computedHash < proofElement) {\n                computedHash = keccak256(\n                    abi.encodePacked(bytes1(0x01), computedHash, pro","after":"       bytes32[] calldata _proof,\n        bytes32 _leaf\n    ) internal pure returns (bool) {\n        bytes32 computedHash = _leaf;\n\n        for (uint256 i = 0; i < _proof.length; i++) {\n            bytes32 proofElement = _proof[i];\n\n            if (computedHash < proofElement) {\n                computedHash = keccak256(\n                    abi.encodePacked(bytes1(0x01), computedHash, pro","contract":"MerkleWhitelist","time":0},{"type":"immutable-restrict-modification ","before":"t Whitelisted is Context {\n","after":"t Whitelisted is Context {\n","contract":"MintingCeremonyHarness","time":1},{"type":"immutable-restrict-modification ","before":"s32[] calldata proof) {\n ","after":"s32[] calldata proof) {\n ","contract":"MintingCeremonyHarness","time":1},{"type":"immutable-restrict-modification ","before":"    _paused = true;\n        emit Pa","after":"    _paused = true;\n        emit Pa","contract":"Phase1Pool","time":1},{"type":"immutable-restrict-modification ","before":"t Whitelisted is Context {\n","after":"t Whitelisted is Context {\n","contract":"Phase4aPool","time":1},{"type":"immutable-restrict-modification ","before":"s32[] calldata proof) {\n ","after":"s32[] calldata proof) {\n ","contract":"Phase4aPool","time":1},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"SupplyControlledTokenMock","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"SupplyControlledTokenMock","time":0},{"type":"external-function ","before":"       delay_ <= MAXIMUM_DELAY,\n            \"TimeLock::setDelay: Delay must not exceed maximum delay.\"\n        );\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(\n            msg.sender == pendingAdmin,\n            \"TimeLock::acceptAdmin: Call must come from pendingAdmin.\"\n        );\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(\n            msg.sender == address(this),\n            \"TimeLock::setPendingAdmin: Call must come from TimeLock.\"\n        );\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdm","after":"       delay_ <= MAXIMUM_DELAY,\n            \"TimeLock::setDelay: Delay must not exceed maximum delay.\"\n        );\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(\n            msg.sender == pendingAdmin,\n            \"TimeLock::acceptAdmin: Call must come from pendingAdmin.\"\n        );\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(\n            msg.sender == address(this),\n            \"TimeLock::setPendingAdmin: Call must come from TimeLock.\"\n        );\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdm","contract":"TimeLockMock","time":0},{"type":"external-function ","before":"dingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(\n            msg.sender == admin,\n            \"TimeLock::queueTransaction: Call must come from admin.\"\n        );\n        require(\n            eta >= getBlockTimestamp().add(delay),\n            \"TimeLock::queueTransaction: Estimated execution block must satisfy delay.\"\n        );\n\n      ","after":"dingAdmin);\n    }\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(\n            msg.sender == admin,\n            \"TimeLock::queueTransaction: Call must come from admin.\"\n        );\n        require(\n            eta >= getBlockTimestamp().add(delay),\n            \"TimeLock::queueTransaction: Estimated execution block must satisfy delay.\"\n        );\n\n      ","contract":"TimeLockMock","time":0},{"type":"external-function ","before":"s32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(\n            msg.sender == admin,\n            \"TimeLock::cancelTransaction: Call must come from admin.\"\n        );\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public payable returns (bytes memory) {\n        require(\n            msg.sender == admin,\n            \"TimeLock::executeTransaction: Call must come from admin.\"\n        );\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(\n            queuedTransactions[txHash],\n            \"TimeLock::executeTransaction: Transaction hasn't been queued.\"\n        );\n        require(\n            getBlockTimestamp() >= eta,\n            \"TimeLock::executeTransaction: Transaction hasn't surpassed time lock.\"\n        );\n        require(\n            getBlockTimestamp() <= eta.add(","after":"s32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public {\n        require(\n            msg.sender == admin,\n            \"TimeLock::cancelTransaction: Call must come from admin.\"\n        );\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) public payable returns (bytes memory) {\n        require(\n            msg.sender == admin,\n            \"TimeLock::executeTransaction: Call must come from admin.\"\n        );\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(\n            queuedTransactions[txHash],\n            \"TimeLock::executeTransaction: Transaction hasn't been queued.\"\n        );\n        require(\n            getBlockTimestamp() >= eta,\n            \"TimeLock::executeTransaction: Transaction hasn't surpassed time lock.\"\n        );\n        require(\n            getBlockTimestamp() <= eta.add(","contract":"TimeLockMock","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"TokenMock","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"TokenMock","time":1},{"type":"state-data-arrangement ","before":"\neton TWAP that only needs to be d\nsingPastObsr   - We do not have suff\nMath for uint256;\n\n    struct Obser\ntive;\n    }\n\n    /* ========== IMMUT\n// @notice The desired amount of time over which the movin","after":"singPastObsr   - We do not have suff\ntive;\n    }\n\n    /* ========== IMMUT\n// @notice The desired amount of time over which the movin\neton TWAP that only needs to be d\nMath for uint256;\n\n    struct Obser\n","contract":"Twap","time":0},{"type":"state-data-arrangement ","before":"\n�═╝░██╔══╝\n�══╝░░██║\n// █████�\n��██║░░██�\n��░░█████\n�██╗██║░░░░░██║\n��╚═╝╚═╝░░░░░╚═╝░░░░░╚═══�\n�═╝╚═╝╚═╝░░░░░╚═╝\n// Copy\n(C) 2021 zapper\n\n// This program is free software: you can redistribute it and/or modi","after":"�══╝░░██║\n// █████�\n��██║░░██�\n��░░█████\n�██╗██║░░░░░██║\n��╚═╝╚═╝░░░░░╚═╝░░░░░╚═══�\n�═╝╚═╝╚═╝░░░░░╚═╝\n// Copy\n(C) 2021 zapper\n\n// This program is free software: you can redistribute it and/or modi\n�═╝░██╔══╝\n","contract":"ZapBaseV1","time":0}]}