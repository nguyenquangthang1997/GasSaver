{"time":2832,"results":[{"type":"external-function ","before":"function _executeDeposit(Orders.DepositOrder memory depositOrder) public {\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\n        require(depositOrder.deadline >= block.timestamp, 'ID_EXPIRED');\n\n        (address pair, address token0, address token1, uint256 amount0Left, uint256 amount1Left) = _initialDeposit(\n            depositOrder\n        );\n        if (\n            (amount0Left != 0 || amount1Left != 0) &&\n            AddLiquidity.canSwap(\n                depositOrder.initialRatio,\n                depositOrder.minRatioChangeToSwap,\n                orders.pairs[depositOrder.pairId].pair\n            )\n        ) {\n            if (amount0Left != 0) {\n                (amount0Left, amount1Left) = AddLiquidity.swapDeposit0(\n                    pair,\n                    token0,\n                    amount0Left,\n                    depositOrder.minSwapPrice\n                );\n            } else if (amount1Left != 0) {\n                (amount0Left, amount1Left) = AddLiquidity.swapDeposit1(\n                    pair,\n                    token1,\n                    amount1Left,\n                    depositOrder.maxSwapPrice\n                );\n            }\n        }\n        if (amount0Left != 0 && amount1Left != 0) {\n            (amount0Left, amount1Left) = _addLiquidityAndMint(\n                pair,\n                depositOrder.to,\n                token0,\n                token1,\n                amount0Left,\n                amount1Left\n            );\n        }\n\n        _refundDeposit(depositOrder.to, token0, token1, amount0Left, amount1Left);\n    }","after":"function _executeDeposit(Orders.DepositOrder calldata depositOrder) public {\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\n        require(depositOrder.deadline >= block.timestamp, 'ID_EXPIRED');\n\n        (address pair, address token0, address token1, uint256 amount0Left, uint256 amount1Left) = _initialDeposit(\n            depositOrder\n        );\n        if (\n            (amount0Left != 0 || amount1Left != 0) &&\n            AddLiquidity.canSwap(\n                depositOrder.initialRatio,\n                depositOrder.minRatioChangeToSwap,\n                orders.pairs[depositOrder.pairId].pair\n            )\n        ) {\n            if (amount0Left != 0) {\n                (amount0Left, amount1Left) = AddLiquidity.swapDeposit0(\n                    pair,\n                    token0,\n                    amount0Left,\n                    depositOrder.minSwapPrice\n                );\n            } else if (amount1Left != 0) {\n                (amount0Left, amount1Left) = AddLiquidity.swapDeposit1(\n                    pair,\n                    token1,\n                    amount1Left,\n                    depositOrder.maxSwapPrice\n                );\n            }\n        }\n        if (amount0Left != 0 && amount1Left != 0) {\n            (amount0Left, amount1Left) = _addLiquidityAndMint(\n                pair,\n                depositOrder.to,\n                token0,\n                token1,\n                amount0Left,\n                amount1Left\n            );\n        }\n\n        _refundDeposit(depositOrder.to, token0, token1, amount0Left, amount1Left);\n    }","contract":"IntegralDelay","time":0},{"type":"external-function ","before":"function _executeWithdraw(Orders.WithdrawOrder memory withdrawOrder) public {\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\n        require(withdrawOrder.deadline >= block.timestamp, 'ID_EXPIRED');\n\n        (address pair, ,) = orders.getPairInfo(withdrawOrder.pairId);\n        IIntegralPair(pair).fullSync();\n        TransferHelper.safeTransfer(pair, pair, withdrawOrder.liquidity);\n        (uint256 amount0, uint256 amount1) = IIntegralPair(pair).burn(withdrawOrder.to);\n\n        require(amount0 >= withdrawOrder.amount0Min && amount1 >= withdrawOrder.amount1Min, 'ID_INSUFFICIENT_AMOUNT');\n    }","after":"function _executeWithdraw(Orders.WithdrawOrder calldata withdrawOrder) public {\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\n        require(withdrawOrder.deadline >= block.timestamp, 'ID_EXPIRED');\n\n        (address pair, ,) = orders.getPairInfo(withdrawOrder.pairId);\n        IIntegralPair(pair).fullSync();\n        TransferHelper.safeTransfer(pair, pair, withdrawOrder.liquidity);\n        (uint256 amount0, uint256 amount1) = IIntegralPair(pair).burn(withdrawOrder.to);\n\n        require(amount0 >= withdrawOrder.amount0Min && amount1 >= withdrawOrder.amount1Min, 'ID_INSUFFICIENT_AMOUNT');\n    }","contract":"IntegralDelay","time":0},{"type":"external-function ","before":"function _executeBuy(Orders.BuyOrder memory buyOrder) public {\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\n        require(buyOrder.deadline >= block.timestamp, 'ID_EXPIRED');\n\n        (address pairAddress, address token0, address token1) = orders.getPairInfo(buyOrder.pairId);\n        (address tokenIn, address tokenOut) = buyOrder.inverse ? (token1, token0) : (token0, token1);\n        uint256 amountInMax = tokenShares.sharesToAmount(tokenIn, buyOrder.shareInMax);\n        IIntegralPair pair = IIntegralPair(pairAddress);\n        pair.fullSync();\n        uint256 amountIn = buyOrder.inverse\n        ? BuyHelper.getSwapAmount1In(tradeMoe, pairAddress, buyOrder.amountOut)\n        : BuyHelper.getSwapAmount0In(tradeMoe, pairAddress, buyOrder.amountOut);\n        require(amountInMax >= amountIn, 'ID_INSUFFICIENT_INPUT_AMOUNT');\n        (uint256 amount0Out, uint256 amount1Out) = buyOrder.inverse\n        ? (buyOrder.amountOut, uint256(0))\n        : (uint256(0), buyOrder.amountOut);\n        TransferHelper.safeTransfer(tokenIn, pairAddress, amountIn);\n        if (tokenOut == tokenShares.weth && buyOrder.unwrap) {\n            pair.swap(amount0Out, amount1Out, address(this));\n            IWETH(tokenShares.weth).withdraw(buyOrder.amountOut);\n            (bool success,) = buyOrder.to.call{value : buyOrder.amountOut, gas : Orders.ETHER_TRANSFER_CALL_COST}('');\n            if (!success) {\n                tokenShares.onUnwrapFailed(buyOrder.to, buyOrder.amountOut);\n            }\n        } else {\n            pair.swap(amount0Out, amount1Out, buyOrder.to);\n        }\n    }","after":"function _executeBuy(Orders.BuyOrder calldata buyOrder) public {\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\n        require(buyOrder.deadline >= block.timestamp, 'ID_EXPIRED');\n\n        (address pairAddress, address token0, address token1) = orders.getPairInfo(buyOrder.pairId);\n        (address tokenIn, address tokenOut) = buyOrder.inverse ? (token1, token0) : (token0, token1);\n        uint256 amountInMax = tokenShares.sharesToAmount(tokenIn, buyOrder.shareInMax);\n        IIntegralPair pair = IIntegralPair(pairAddress);\n        pair.fullSync();\n        uint256 amountIn = buyOrder.inverse\n        ? BuyHelper.getSwapAmount1In(tradeMoe, pairAddress, buyOrder.amountOut)\n        : BuyHelper.getSwapAmount0In(tradeMoe, pairAddress, buyOrder.amountOut);\n        require(amountInMax >= amountIn, 'ID_INSUFFICIENT_INPUT_AMOUNT');\n        (uint256 amount0Out, uint256 amount1Out) = buyOrder.inverse\n        ? (buyOrder.amountOut, uint256(0))\n        : (uint256(0), buyOrder.amountOut);\n        TransferHelper.safeTransfer(tokenIn, pairAddress, amountIn);\n        if (tokenOut == tokenShares.weth && buyOrder.unwrap) {\n            pair.swap(amount0Out, amount1Out, address(this));\n            IWETH(tokenShares.weth).withdraw(buyOrder.amountOut);\n            (bool success,) = buyOrder.to.call{value : buyOrder.amountOut, gas : Orders.ETHER_TRANSFER_CALL_COST}('');\n            if (!success) {\n                tokenShares.onUnwrapFailed(buyOrder.to, buyOrder.amountOut);\n            }\n        } else {\n            pair.swap(amount0Out, amount1Out, buyOrder.to);\n        }\n    }","contract":"IntegralDelay","time":0},{"type":"external-function ","before":"function _executeSell(Orders.SellOrder memory sellOrder) public {\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\n        require(sellOrder.deadline >= block.timestamp, 'ID_EXPIRED');\n\n        (address pairAddress, address token0, address token1) = orders.getPairInfo(sellOrder.pairId);\n        (address tokenIn, address tokenOut) = sellOrder.inverse ? (token1, token0) : (token0, token1);\n        uint256 amountIn = tokenShares.sharesToAmount(tokenIn, sellOrder.shareIn);\n        IIntegralPair pair = IIntegralPair(pairAddress);\n        pair.fullSync();\n        TransferHelper.safeTransfer(tokenIn, pairAddress, amountIn);\n        uint256 amountOut = sellOrder.inverse ? pair.getSwapAmount0Out(amountIn) : pair.getSwapAmount1Out(amountIn);\n        require(amountOut >= sellOrder.amountOutMin, 'ID_INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint256 amount0Out, uint256 amount1Out) = sellOrder.inverse\n        ? (amountOut, uint256(0))\n        : (uint256(0), amountOut);\n        if (tokenOut == tokenShares.weth && sellOrder.unwrap) {\n            pair.swap(amount0Out, amount1Out, address(this));\n            IWETH(tokenShares.weth).withdraw(amountOut);\n            (bool success,) = sellOrder.to.call{value : amountOut, gas : Orders.ETHER_TRANSFER_CALL_COST}('');\n            if (!success) {\n                tokenShares.onUnwrapFailed(sellOrder.to, amountOut);\n            }\n        } else {\n            pair.swap(amount0Out, amount1Out, sellOrder.to);\n        }\n    }","after":"function _executeSell(Orders.SellOrder calldata sellOrder) public {\n        require(msg.sender == address(this), 'ID_FORBIDDEN');\n        require(sellOrder.deadline >= block.timestamp, 'ID_EXPIRED');\n\n        (address pairAddress, address token0, address token1) = orders.getPairInfo(sellOrder.pairId);\n        (address tokenIn, address tokenOut) = sellOrder.inverse ? (token1, token0) : (token0, token1);\n        uint256 amountIn = tokenShares.sharesToAmount(tokenIn, sellOrder.shareIn);\n        IIntegralPair pair = IIntegralPair(pairAddress);\n        pair.fullSync();\n        TransferHelper.safeTransfer(tokenIn, pairAddress, amountIn);\n        uint256 amountOut = sellOrder.inverse ? pair.getSwapAmount0Out(amountIn) : pair.getSwapAmount1Out(amountIn);\n        require(amountOut >= sellOrder.amountOutMin, 'ID_INSUFFICIENT_OUTPUT_AMOUNT');\n        (uint256 amount0Out, uint256 amount1Out) = sellOrder.inverse\n        ? (amountOut, uint256(0))\n        : (uint256(0), amountOut);\n        if (tokenOut == tokenShares.weth && sellOrder.unwrap) {\n            pair.swap(amount0Out, amount1Out, address(this));\n            IWETH(tokenShares.weth).withdraw(amountOut);\n            (bool success,) = sellOrder.to.call{value : amountOut, gas : Orders.ETHER_TRANSFER_CALL_COST}('');\n            if (!success) {\n                tokenShares.onUnwrapFailed(sellOrder.to, amountOut);\n            }\n        } else {\n            pair.swap(amount0Out, amount1Out, sellOrder.to);\n        }\n    }","contract":"IntegralDelay","time":0},{"type":"struct-data-arrangement ","before":"\nuint32 pairId\nuint256 share0\nuint256 share1\nuint256 initialRatio\nuint256 minRatioChangeToSwap\nuint256 minSwapPrice\nuint256 maxSwapPrice\nbool unwrap\naddress to\nuint256 gasPrice\nuint256 gasLimit\nuint256 deadline","after":"uint256 share0\nuint256 share1\nuint256 initialRatio\nuint256 minRatioChangeToSwap\nuint256 minSwapPrice\nuint256 maxSwapPrice\nuint256 gasPrice\nuint256 gasLimit\nuint256 deadline\naddress to\nuint32 pairId\nbool unwrap\n","contract":"Orders","time":0},{"type":"struct-data-arrangement ","before":"\nuint32 pairId\nuint256 liquidity\nuint256 amount0Min\nuint256 amount1Min\nbool unwrap\naddress to\nuint256 gasPrice\nuint256 gasLimit\nuint256 deadline","after":"uint256 liquidity\nuint256 amount0Min\nuint256 amount1Min\nuint256 gasPrice\nuint256 gasLimit\nuint256 deadline\naddress to\nuint32 pairId\nbool unwrap\n","contract":"Orders","time":0},{"type":"struct-data-arrangement ","before":"\nuint32 pairId\nbool inverse\nuint256 shareIn\nuint256 amountOutMin\nbool unwrap\naddress to\nuint256 gasPrice\nuint256 gasLimit\nuint256 deadline","after":"uint256 shareIn\nuint256 amountOutMin\nuint256 gasPrice\nuint256 gasLimit\nuint256 deadline\naddress to\nuint32 pairId\nbool inverse\nbool unwrap\n","contract":"Orders","time":0},{"type":"struct-data-arrangement ","before":"\nuint32 pairId\nbool inverse\nuint256 shareInMax\nuint256 amountOut\nbool unwrap\naddress to\nuint256 gasPrice\nuint256 gasLimit\nuint256 deadline","after":"uint256 shareInMax\nuint256 amountOut\nuint256 gasPrice\nuint256 gasLimit\nuint256 deadline\naddress to\nuint32 pairId\nbool inverse\nbool unwrap\n","contract":"Orders","time":0}]}