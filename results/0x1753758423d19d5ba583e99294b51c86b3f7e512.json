{"time":185,"results":[{"type":"loop-duplication","before":"\nstart line 1799 column 8, end line 1810 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            address _token = _tokens[i] == ethAddr ? wethAddr : _tokens[i];\n\n            _marketIds[i] = _getMarketIdFromTokenAddress(soloAddr, _token);\n\n            _tokenContracts[i] = IERC20(_token);\n\n            _tokenContracts[i].approve(soloAddr, _amounts[i] + 2);\n            // TODO - give infinity allowance??\n\n        }\nstart line 1818 column 8, end line 1822 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            operations[i] = _getWithdrawAction(_marketIds[i], _amounts[i]);\n\n        }\nstart line 1826 column 8, end line 1832 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            uint _opIndex = _length + 1 + i;\n\n            operations[_opIndex] = _getDepositAction(_marketIds[i], _amounts[i] + 2);\n\n        }\nstart line 1846 column 8, end line 1850 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            iniBals[i] = _tokenContracts[i].balanceOf(address(this));\n\n        }\nstart line 1856 column 8, end line 1882 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            finBals[i] = _tokenContracts[i].balanceOf(address(this));\n\n            if (fee == 0) {\n\n                _feeAmts[i] = 0;\n\n                require(sub(iniBals[i], finBals[i]) < 10000, \"amount-paid-less\");\n\n            } else {\n\n                uint _feeLowerLimit = wmul(_amounts[i], wmul(fee, 999500000000000000));\n                // removing 0.05% fee for decimal/dust error\n\n                uint _feeUpperLimit = wmul(_amounts[i], wmul(fee, 1000500000000000000));\n                // adding 0.05% fee for decimal/dust error\n\n                require(finBals[i] >= iniBals[i], \"final-balance-less-than-inital-balance\");\n\n                _feeAmts[i] = sub(finBals[i], iniBals[i]);\n\n                require(_feeLowerLimit < _feeAmts[i] && _feeAmts[i] < _feeUpperLimit, \"amount-paid-less\");\n\n            }\n\n        }","after":"// merge loop\n\nstart line 1799 column 8, end line 1810 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            address _token = _tokens[i] == ethAddr ? wethAddr : _tokens[i];\n\n            _marketIds[i] = _getMarketIdFromTokenAddress(soloAddr, _token);\n\n            _tokenContracts[i] = IERC20(_token);\n\n            _tokenContracts[i].approve(soloAddr, _amounts[i] + 2);\n            // TODO - give infinity allowance??\n\n        }\nstart line 1818 column 8, end line 1822 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            operations[i] = _getWithdrawAction(_marketIds[i], _amounts[i]);\n\n        }\nstart line 1826 column 8, end line 1832 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            uint _opIndex = _length + 1 + i;\n\n            operations[_opIndex] = _getDepositAction(_marketIds[i], _amounts[i] + 2);\n\n        }\nstart line 1846 column 8, end line 1850 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            iniBals[i] = _tokenContracts[i].balanceOf(address(this));\n\n        }\nstart line 1856 column 8, end line 1882 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            finBals[i] = _tokenContracts[i].balanceOf(address(this));\n\n            if (fee == 0) {\n\n                _feeAmts[i] = 0;\n\n                require(sub(iniBals[i], finBals[i]) < 10000, \"amount-paid-less\");\n\n            } else {\n\n                uint _feeLowerLimit = wmul(_amounts[i], wmul(fee, 999500000000000000));\n                // removing 0.05% fee for decimal/dust error\n\n                uint _feeUpperLimit = wmul(_amounts[i], wmul(fee, 1000500000000000000));\n                // adding 0.05% fee for decimal/dust error\n\n                require(finBals[i] >= iniBals[i], \"final-balance-less-than-inital-balance\");\n\n                _feeAmts[i] = sub(finBals[i], iniBals[i]);\n\n                require(_feeLowerLimit < _feeAmts[i] && _feeAmts[i] < _feeUpperLimit, \"amount-paid-less\");\n\n            }\n\n        }","contract":"DydxFlashloaner","time":0},{"type":"loop-duplication","before":"\nstart line 1942 column 8, end line 1950 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            address _token = _tokens[i] == ethAddr ? wethAddr : _tokens[i];\n\n            _tokenContracts[i] = IERC20(_token);\n\n            iniBals[i] = _tokenContracts[i].balanceOf(address(this));\n\n        }\nstart line 1956 column 8, end line 1985 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            finBals[i] = _tokenContracts[i].balanceOf(address(this));\n\n            if (fee == 0) {\n\n                _feeAmts[i] = 0;\n\n                uint _dif = wmul(_amounts[i], 200000000000);\n                // Taking margin of 0.0000002%.\n\n                require(sub(iniBals[i], finBals[i]) < _dif, \"amount-paid-less\");\n\n            } else {\n\n                uint _feeLowerLimit = wmul(_amounts[i], wmul(fee, 999500000000000000));\n                // removing 0.05% fee for decimal/dust error\n\n                uint _feeUpperLimit = wmul(_amounts[i], wmul(fee, 1000500000000000000));\n                // adding 0.05% fee for decimal/dust error\n\n                require(finBals[i] >= iniBals[i], \"final-balance-less-than-inital-balance\");\n\n                _feeAmts[i] = sub(finBals[i], iniBals[i]);\n\n                require(_feeLowerLimit < _feeAmts[i] && _feeAmts[i] < _feeUpperLimit, \"amount-paid-less\");\n\n            }\n\n        }","after":"// merge loop\n\nstart line 1942 column 8, end line 1950 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            address _token = _tokens[i] == ethAddr ? wethAddr : _tokens[i];\n\n            _tokenContracts[i] = IERC20(_token);\n\n            iniBals[i] = _tokenContracts[i].balanceOf(address(this));\n\n        }\nstart line 1956 column 8, end line 1985 column 8\nfor (uint i = 0; i < _length; i++) {\n\n            finBals[i] = _tokenContracts[i].balanceOf(address(this));\n\n            if (fee == 0) {\n\n                _feeAmts[i] = 0;\n\n                uint _dif = wmul(_amounts[i], 200000000000);\n                // Taking margin of 0.0000002%.\n\n                require(sub(iniBals[i], finBals[i]) < _dif, \"amount-paid-less\");\n\n            } else {\n\n                uint _feeLowerLimit = wmul(_amounts[i], wmul(fee, 999500000000000000));\n                // removing 0.05% fee for decimal/dust error\n\n                uint _feeUpperLimit = wmul(_amounts[i], wmul(fee, 1000500000000000000));\n                // adding 0.05% fee for decimal/dust error\n\n                require(finBals[i] >= iniBals[i], \"final-balance-less-than-inital-balance\");\n\n                _feeAmts[i] = sub(finBals[i], iniBals[i]);\n\n                require(_feeLowerLimit < _feeAmts[i] && _feeAmts[i] < _feeUpperLimit, \"amount-paid-less\");\n\n            }\n\n        }","contract":"DydxFlashloaner","time":0},{"type":"external-function ","before":"function callFunction(\n\n        address sender,\n\n        Account.Info memory account,\n\n        bytes memory data\n\n    ) public override {\n\n        require(sender == address(this), \"not-same-sender\");\n\n        require(msg.sender == soloAddr, \"not-solo-dydx-sender\");\n\n        CastData memory cd;\n\n        (cd.dsa, cd.route, cd.tokens, cd.amounts, cd.dsaTargets, cd.dsaData) = abi.decode(\n\n            data,\n\n            (address, uint256, address[], uint256[], address[], bytes[])\n\n        );\n\n\n        bool isWeth = checkWeth(cd.tokens, cd.route);\n\n        if (isWeth) {\n\n            wethContract.withdraw(wethContract.balanceOf(address(this)));\n\n        }\n\n\n        selectBorrow(cd.tokens, cd.amounts, cd.route);\n\n\n        uint _length = cd.tokens.length;\n\n\n        for (uint i = 0; i < _length; i++) {\n\n            if (cd.tokens[i] == ethAddr) {\n\n                payable(cd.dsa).transfer(cd.amounts[i]);\n\n            } else {\n\n                IERC20(cd.tokens[i]).safeTransfer(cd.dsa, cd.amounts[i]);\n\n            }\n\n        }\n\n\n        DSAInterface(cd.dsa).cast(cd.dsaTargets, cd.dsaData, 0xB7fA44c2E964B6EB24893f7082Ecc08c8d0c0F87);\n\n\n        selectPayback(cd.tokens, cd.route);\n\n\n        if (isWeth) {\n\n            wethContract.deposit{value : address(this).balance}();\n\n        }\n\n    }","after":"function callFunction(\n\n        address sender,\n\n        Account.Info calldata account,\n\n        bytes calldata data\n\n    ) public override {\n\n        require(sender == address(this), \"not-same-sender\");\n\n        require(msg.sender == soloAddr, \"not-solo-dydx-sender\");\n\n        CastData memory cd;\n\n        (cd.dsa, cd.route, cd.tokens, cd.amounts, cd.dsaTargets, cd.dsaData) = abi.decode(\n\n            data,\n\n            (address, uint256, address[], uint256[], address[], bytes[])\n\n        );\n\n\n        bool isWeth = checkWeth(cd.tokens, cd.route);\n\n        if (isWeth) {\n\n            wethContract.withdraw(wethContract.balanceOf(address(this)));\n\n        }\n\n\n        selectBorrow(cd.tokens, cd.amounts, cd.route);\n\n\n        uint _length = cd.tokens.length;\n\n\n        for (uint i = 0; i < _length; i++) {\n\n            if (cd.tokens[i] == ethAddr) {\n\n                payable(cd.dsa).transfer(cd.amounts[i]);\n\n            } else {\n\n                IERC20(cd.tokens[i]).safeTransfer(cd.dsa, cd.amounts[i]);\n\n            }\n\n        }\n\n\n        DSAInterface(cd.dsa).cast(cd.dsaTargets, cd.dsaData, 0xB7fA44c2E964B6EB24893f7082Ecc08c8d0c0F87);\n\n\n        selectPayback(cd.tokens, cd.route);\n\n\n        if (isWeth) {\n\n            wethContract.deposit{value : address(this).balance}();\n\n        }\n\n    }","contract":"InstaDydxFlashLoan","time":0},{"type":"constant-restrict-modification  ","before":"address public makerConnect = address(0x33c4f6d6c0A123AF5F1655EA5Fd730098d0aBD50);","after":"address public constant makerConnect = address(0x33c4f6d6c0A123AF5F1655EA5Fd730098d0aBD50);","contract":"InstaDydxFlashLoan","time":1},{"type":"constant-restrict-modification  ","before":"address public compoundConnect = address(0x33d4876A16F712f1a305C5594A5AdeDc9b7A9f14);","after":"address public constant compoundConnect = address(0x33d4876A16F712f1a305C5594A5AdeDc9b7A9f14);","contract":"InstaDydxFlashLoan","time":1},{"type":"constant-restrict-modification  ","before":"address public aaveConnect = address(0x01d0734e34B0251f46aD34d1a82c4946a5B943D9);","after":"address public constant aaveConnect = address(0x01d0734e34B0251f46aD34d1a82c4946a5B943D9);","contract":"InstaDydxFlashLoan","time":1},{"type":"immutable-restrict-modification ","before":"uint public vaultId;","after":"uint public immutable vaultId;","contract":"InstaDydxFlashLoan","time":1}]}