{"time":201,"results":[{"type":"immutable-restrict-modification ","before":"address target;","after":"address immutable target;","contract":"PartnerRegistry","time":0},{"type":"external-function ","before":"function payout(\n\n        address[] memory tokens,\n\n        uint256[] memory amounts\n\n    ) public {\n\n        uint totalFeePercentage = getTotalFeePercentage();\n\n        address payable companyBeneficiary = companyBeneficiary();\n\n        // Payout both the partner and the company at the same time\n\n        for (uint256 index = 0; index < tokens.length; index++) {\n\n            uint256 partnerAmount = SafeMath.div(SafeMath.mul(amounts[index], partnerPercentage), getTotalFeePercentage());\n\n            uint256 companyAmount = amounts[index] - partnerAmount;\n\n            if (tokens[index] == Utils.eth_address()) {\n\n                partnerBeneficiary.transfer(partnerAmount);\n\n                companyBeneficiary.transfer(companyAmount);\n\n            } else {\n\n                ERC20SafeTransfer.safeTransfer(tokens[index], partnerBeneficiary, partnerAmount);\n\n                ERC20SafeTransfer.safeTransfer(tokens[index], companyBeneficiary, companyAmount);\n\n            }\n\n        }\n\n        emit LogPayout(tokens, amounts);\n\n    }","after":"function payout(\n\n        address[] calldata tokens,\n\n        uint256[] calldata amounts\n\n    ) public {\n\n        uint totalFeePercentage = getTotalFeePercentage();\n\n        address payable companyBeneficiary = companyBeneficiary();\n\n        // Payout both the partner and the company at the same time\n\n        for (uint256 index = 0; index < tokens.length; index++) {\n\n            uint256 partnerAmount = SafeMath.div(SafeMath.mul(amounts[index], partnerPercentage), getTotalFeePercentage());\n\n            uint256 companyAmount = amounts[index] - partnerAmount;\n\n            if (tokens[index] == Utils.eth_address()) {\n\n                partnerBeneficiary.transfer(partnerAmount);\n\n                companyBeneficiary.transfer(companyAmount);\n\n            } else {\n\n                ERC20SafeTransfer.safeTransfer(tokens[index], partnerBeneficiary, partnerAmount);\n\n                ERC20SafeTransfer.safeTransfer(tokens[index], companyBeneficiary, companyAmount);\n\n            }\n\n        }\n\n        emit LogPayout(tokens, amounts);\n\n    }","contract":"Partner","time":0},{"type":"struct-data-arrangement ","before":"\naddress sourceToken\naddress destinationToken\nuint256 amount\nbool isSourceAmount\nOrder[] orders","after":"uint256 amount\nOrder[] orders\naddress sourceToken\naddress destinationToken\nbool isSourceAmount\n","contract":"TotlePrimary","time":0},{"type":"struct-data-arrangement ","before":"\nSwap[] swaps\naddress payable partnerContract\nuint256 expirationBlock\nbytes32 id\nuint256 maxGasPrice\nuint8 v\nbytes32 r\nbytes32 s","after":"Swap[] swaps\nuint256 expirationBlock\nbytes32 id\nuint256 maxGasPrice\nbytes32 r\nbytes32 s\naddress payable partnerContract\nuint8 v\n","contract":"TotlePrimary","time":0},{"type":"external-function ","before":"function performSwapCollection(\n\n        SwapCollection memory swaps\n\n    )\n\n    public\n\n    payable\n\n    whenNotPaused\n\n    notExpired(swaps)\n\n    validSignature(swaps)\n\n    notAboveMaxGas(swaps)\n\n    {\n\n        TokenBalance[20] memory balances;\n\n        balances[0] = TokenBalance(address(Utils.eth_address()), msg.value);\n\n        //this.log(\"Created eth balance\", balances[0].balance, 0x0);\n\n        for (uint256 swapIndex = 0; swapIndex < swaps.swaps.length; swapIndex++) {\n\n            //this.log(\"About to perform swap\", swapIndex, swaps.id);\n\n            performSwap(swaps.id, swaps.swaps[swapIndex], balances, swaps.partnerContract);\n\n        }\n\n        emit LogSwapCollection(swaps.id, swaps.partnerContract, msg.sender);\n\n        transferAllTokensToUser(balances);\n\n    }","after":"function performSwapCollection(\n\n        SwapCollection calldata swaps\n\n    )\n\n    public\n\n    payable\n\n    whenNotPaused\n\n    notExpired(swaps)\n\n    validSignature(swaps)\n\n    notAboveMaxGas(swaps)\n\n    {\n\n        TokenBalance[20] memory balances;\n\n        balances[0] = TokenBalance(address(Utils.eth_address()), msg.value);\n\n        //this.log(\"Created eth balance\", balances[0].balance, 0x0);\n\n        for (uint256 swapIndex = 0; swapIndex < swaps.swaps.length; swapIndex++) {\n\n            //this.log(\"About to perform swap\", swapIndex, swaps.id);\n\n            performSwap(swaps.id, swaps.swaps[swapIndex], balances, swaps.partnerContract);\n\n        }\n\n        emit LogSwapCollection(swaps.id, swaps.partnerContract, msg.sender);\n\n        transferAllTokensToUser(balances);\n\n    }","contract":"TotlePrimary","time":0},{"type":"external-function ","before":"function log(string memory a, uint256 b, bytes32 c) public {\n\n        emit Log(a, b, c);\n\n    }","after":"function log(string calldata a, uint256 b, bytes32 c) public {\n\n        emit Log(a, b, c);\n\n    }","contract":"TotlePrimary","time":0}]}