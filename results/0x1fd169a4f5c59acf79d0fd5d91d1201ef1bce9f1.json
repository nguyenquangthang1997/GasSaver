{"time":117,"results":[{"type":"struct-data-arrangement ","before":"\naddress delegateKey\nuint256 shares\nbool exists\nuint256 highestIndexYesVote","after":"uint256 shares\nuint256 highestIndexYesVote\naddress delegateKey\nbool exists\n","contract":"Moloch","time":0},{"type":"struct-data-arrangement ","before":"\naddress proposer\naddress applicant\nuint256 sharesRequested\nuint256 startingPeriod\nuint256 yesVotes\nuint256 noVotes\nbool processed\nbool didPass\nbool aborted\nuint256 tokenTribute\nstring details\nuint256 maxTotalSharesAtYesVote\nmapping(address => Vote) votesByMember","after":"uint256 sharesRequested\nuint256 startingPeriod\nuint256 yesVotes\nuint256 noVotes\nuint256 tokenTribute\nstring details\nuint256 maxTotalSharesAtYesVote\nmapping(address => Vote) votesByMember\naddress proposer\naddress applicant\nbool processed\nbool didPass\nbool aborted\n","contract":"Moloch","time":0},{"type":"external-function ","before":"function submitProposal(\n\n        address applicant,\n\n        uint256 tokenTribute,\n\n        uint256 sharesRequested,\n\n        string memory details\n\n    )\n\n    public\n\n    onlyDelegate\n\n    {\n\n        require(applicant != address(0), \"Moloch::submitProposal - applicant cannot be 0\");\n\n\n        // Make sure we won't run into overflows when doing calculations with shares.\n\n        // Note that totalShares + totalSharesRequested + sharesRequested is an upper bound\n\n        // on the number of shares that can exist until this proposal has been processed.\n\n        require(totalShares.add(totalSharesRequested).add(sharesRequested) <= MAX_NUMBER_OF_SHARES, \"Moloch::submitProposal - too many shares requested\");\n\n\n        totalSharesRequested = totalSharesRequested.add(sharesRequested);\n\n\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\n\n\n        // collect proposal deposit from proposer and store it in the Moloch until the proposal is processed\n\n        require(approvedToken.transferFrom(msg.sender, address(this), proposalDeposit), \"Moloch::submitProposal - proposal deposit token transfer failed\");\n\n\n        // collect tribute from applicant and store it in the Moloch until the proposal is processed\n\n        require(approvedToken.transferFrom(applicant, address(this), tokenTribute), \"Moloch::submitProposal - tribute token transfer failed\");\n\n\n        // compute startingPeriod for proposal\n\n        uint256 startingPeriod = max(\n\n            getCurrentPeriod(),\n\n            proposalQueue.length == 0 ? 0 : proposalQueue[proposalQueue.length.sub(1)].startingPeriod\n\n        ).add(1);\n\n\n        // create proposal ...\n\n        Proposal memory proposal = Proposal({\n\n        proposer : memberAddress,\n\n        applicant : applicant,\n\n        sharesRequested : sharesRequested,\n\n        startingPeriod : startingPeriod,\n\n        yesVotes : 0,\n\n        noVotes : 0,\n\n        processed : false,\n\n        didPass : false,\n\n        aborted : false,\n\n        tokenTribute : tokenTribute,\n\n        details : details,\n\n        maxTotalSharesAtYesVote : 0\n\n        });\n\n\n        // ... and append it to the queue\n\n        proposalQueue.push(proposal);\n\n\n        uint256 proposalIndex = proposalQueue.length.sub(1);\n\n        emit SubmitProposal(proposalIndex, msg.sender, memberAddress, applicant, tokenTribute, sharesRequested);\n\n    }","after":"function submitProposal(\n\n        address applicant,\n\n        uint256 tokenTribute,\n\n        uint256 sharesRequested,\n\n        string calldata details\n\n    )\n\n    public\n\n    onlyDelegate\n\n    {\n\n        require(applicant != address(0), \"Moloch::submitProposal - applicant cannot be 0\");\n\n\n        // Make sure we won't run into overflows when doing calculations with shares.\n\n        // Note that totalShares + totalSharesRequested + sharesRequested is an upper bound\n\n        // on the number of shares that can exist until this proposal has been processed.\n\n        require(totalShares.add(totalSharesRequested).add(sharesRequested) <= MAX_NUMBER_OF_SHARES, \"Moloch::submitProposal - too many shares requested\");\n\n\n        totalSharesRequested = totalSharesRequested.add(sharesRequested);\n\n\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\n\n\n        // collect proposal deposit from proposer and store it in the Moloch until the proposal is processed\n\n        require(approvedToken.transferFrom(msg.sender, address(this), proposalDeposit), \"Moloch::submitProposal - proposal deposit token transfer failed\");\n\n\n        // collect tribute from applicant and store it in the Moloch until the proposal is processed\n\n        require(approvedToken.transferFrom(applicant, address(this), tokenTribute), \"Moloch::submitProposal - tribute token transfer failed\");\n\n\n        // compute startingPeriod for proposal\n\n        uint256 startingPeriod = max(\n\n            getCurrentPeriod(),\n\n            proposalQueue.length == 0 ? 0 : proposalQueue[proposalQueue.length.sub(1)].startingPeriod\n\n        ).add(1);\n\n\n        // create proposal ...\n\n        Proposal memory proposal = Proposal({\n\n        proposer : memberAddress,\n\n        applicant : applicant,\n\n        sharesRequested : sharesRequested,\n\n        startingPeriod : startingPeriod,\n\n        yesVotes : 0,\n\n        noVotes : 0,\n\n        processed : false,\n\n        didPass : false,\n\n        aborted : false,\n\n        tokenTribute : tokenTribute,\n\n        details : details,\n\n        maxTotalSharesAtYesVote : 0\n\n        });\n\n\n        // ... and append it to the queue\n\n        proposalQueue.push(proposal);\n\n\n        uint256 proposalIndex = proposalQueue.length.sub(1);\n\n        emit SubmitProposal(proposalIndex, msg.sender, memberAddress, applicant, tokenTribute, sharesRequested);\n\n    }","contract":"Moloch","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public periodDuration;","after":"uint256 public immutable periodDuration;","contract":"Moloch","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public votingPeriodLength;","after":"uint256 public immutable votingPeriodLength;","contract":"Moloch","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public gracePeriodLength;","after":"uint256 public immutable gracePeriodLength;","contract":"Moloch","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public abortWindow;","after":"uint256 public immutable abortWindow;","contract":"Moloch","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public proposalDeposit;","after":"uint256 public immutable proposalDeposit;","contract":"Moloch","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public dilutionBound;","after":"uint256 public immutable dilutionBound;","contract":"Moloch","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public processingReward;","after":"uint256 public immutable processingReward;","contract":"Moloch","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public summoningTime;","after":"uint256 public immutable summoningTime;","contract":"Moloch","time":0}]}