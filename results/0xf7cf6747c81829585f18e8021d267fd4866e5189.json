{"time":318,"results":[{"type":"state-data-arrangement ","before":"\nbool public metadataFrozen;\nmapping(uint256 => bool) claimedFrames;\nstring public baseUri;\naddress public ommContractAddress;","after":"mapping(uint256 => bool) claimedFrames;\nstring public baseUri;\naddress public ommContractAddress;\nbool public metadataFrozen;\n","contract":"Frames","time":0},{"type":"external-function ","before":"function setBaseUri(string memory _baseUri) external onlyOwner whenMetadataIsNotFrozen {\n        baseUri = _baseUri;\n        emit SetBaseUri(baseUri);\n    }","after":"function setBaseUri(string calldata _baseUri) external onlyOwner whenMetadataIsNotFrozen {\n        baseUri = _baseUri;\n        emit SetBaseUri(baseUri);\n    }","contract":"Frames","time":0},{"type":"external-function ","before":"function setTokenURI(uint256 tokenId, string memory tokenURI) external onlyOwner whenMetadataIsNotFrozen {\n        super._setTokenURI(tokenId, tokenURI);\n    }","after":"function setTokenURI(uint256 tokenId, string calldata tokenURI) external onlyOwner whenMetadataIsNotFrozen {\n        super._setTokenURI(tokenId, tokenURI);\n    }","contract":"Frames","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"Frames","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"Frames","time":1},{"type":"state-data-arrangement ","before":"\nstring public provenanceHash = \"\";\nuint256 public maxOmm;\nuint256 public maxOmmPresale;\nbool public metadataFrozen;\nbool public provenanceFrozen;\nuint256 public mintIndex;\nstring public baseUri;\nbool public burnIsActive;\nbool public saleIsActive;\nbool public presaleIsActive;\nuint256 public mintPricePresale;\nuint256 public mintPrice;\nuint256 public mintInterval;\nuint256 public maxPerMint;\nuint256 public maxPerUser;\naddress public presaleSigner;\nbool public revealed;\nstring public unrevealedTokenUri;\nmapping(address => uint256) public lastPurchase;\nmapping(bytes32 => bool) public usedLink;\nFrames public framesContract;","after":"string public provenanceHash = \"\";\nuint256 public maxOmm;\nuint256 public maxOmmPresale;\nuint256 public mintIndex;\nstring public baseUri;\nuint256 public mintPricePresale;\nuint256 public mintPrice;\nuint256 public mintInterval;\nuint256 public maxPerMint;\nuint256 public maxPerUser;\nstring public unrevealedTokenUri;\nmapping(address => uint256) public lastPurchase;\nmapping(bytes32 => bool) public usedLink;\nFrames public framesContract;\naddress public presaleSigner;\nbool public metadataFrozen;\nbool public provenanceFrozen;\nbool public burnIsActive;\nbool public saleIsActive;\nbool public presaleIsActive;\nbool public revealed;\n","contract":"OldMasterMemes","time":1},{"type":"external-function ","before":"function presaleMintOMM(\n        address wallet,\n        uint256 maxAmount,\n        uint256 timestamp,\n        bytes memory signature,\n        uint256 amount\n    ) external payable whenPresaleIsActive {\n        require(balanceOf(msg.sender) + amount <= maxPerUser, \"OldMasterMemes: Amount exceeds max presale amount per user\");\n        require(amount <= maxAmount, \"OldMasterMemes: Amount exceeds max\");\n        require(mintIndex + amount <= maxOmmPresale, \"OldMasterMemes: Purchase would exceed presale cap\");\n        require(mintPricePresale * amount <= msg.value, \"OldMasterMemes: Ether value sent is not correct\");\n        require(msg.sender == wallet, \"OldMasterMemes: Wallet from signature does not match message sender\");\n        require(_verifySignature(wallet, maxAmount, timestamp, signature), \"OldMasterMemes: Invalid signature\");\n        bytes32 linkHash = keccak256(signature);\n        require(!usedLink[linkHash],\n            \"OldMasterMemes: The presale link has already been used. Please request a new one\"\n        );\n\n        for (uint256 i = 0; i < amount; i++) {\n            mintIndex += 1;\n            _safeMint(msg.sender, mintIndex);\n        }\n        usedLink[linkHash] = true;\n    }","after":"function presaleMintOMM(\n        address wallet,\n        uint256 maxAmount,\n        uint256 timestamp,\n        bytes calldata signature,\n        uint256 amount\n    ) external payable whenPresaleIsActive {\n        require(balanceOf(msg.sender) + amount <= maxPerUser, \"OldMasterMemes: Amount exceeds max presale amount per user\");\n        require(amount <= maxAmount, \"OldMasterMemes: Amount exceeds max\");\n        require(mintIndex + amount <= maxOmmPresale, \"OldMasterMemes: Purchase would exceed presale cap\");\n        require(mintPricePresale * amount <= msg.value, \"OldMasterMemes: Ether value sent is not correct\");\n        require(msg.sender == wallet, \"OldMasterMemes: Wallet from signature does not match message sender\");\n        require(_verifySignature(wallet, maxAmount, timestamp, signature), \"OldMasterMemes: Invalid signature\");\n        bytes32 linkHash = keccak256(signature);\n        require(!usedLink[linkHash],\n            \"OldMasterMemes: The presale link has already been used. Please request a new one\"\n        );\n\n        for (uint256 i = 0; i < amount; i++) {\n            mintIndex += 1;\n            _safeMint(msg.sender, mintIndex);\n        }\n        usedLink[linkHash] = true;\n    }","contract":"OldMasterMemes","time":0},{"type":"external-function ","before":"function setBaseUri(string memory _baseUri) external onlyOwner whenMetadataIsNotFrozen {\n        baseUri = _baseUri;\n        emit SetBaseUri(baseUri);\n    }","after":"function setBaseUri(string calldata _baseUri) external onlyOwner whenMetadataIsNotFrozen {\n        baseUri = _baseUri;\n        emit SetBaseUri(baseUri);\n    }","contract":"OldMasterMemes","time":0},{"type":"external-function ","before":"function setTokenURI(uint256 tokenId, string memory _tokenURI) external onlyOwner whenMetadataIsNotFrozen {\n        super._setTokenURI(tokenId, _tokenURI);\n    }","after":"function setTokenURI(uint256 tokenId, string calldata _tokenURI) external onlyOwner whenMetadataIsNotFrozen {\n        super._setTokenURI(tokenId, _tokenURI);\n    }","contract":"OldMasterMemes","time":0},{"type":"external-function ","before":"function setProvenanceHash(string memory _provenanceHash) external onlyOwner whenProvenanceIsNotFrozen {\n        provenanceHash = _provenanceHash;\n    }","after":"function setProvenanceHash(string calldata _provenanceHash) external onlyOwner whenProvenanceIsNotFrozen {\n        provenanceHash = _provenanceHash;\n    }","contract":"OldMasterMemes","time":0},{"type":"external-function ","before":"function setUnrevealedTokenUri(string memory _unrevealedTokenUri) external onlyOwner whenMetadataIsNotFrozen {\n        unrevealedTokenUri = _unrevealedTokenUri;\n    }","after":"function setUnrevealedTokenUri(string calldata _unrevealedTokenUri) external onlyOwner whenMetadataIsNotFrozen {\n        unrevealedTokenUri = _unrevealedTokenUri;\n    }","contract":"OldMasterMemes","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public maxOmm;","after":"uint256 public immutable maxOmm;","contract":"OldMasterMemes","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"OldMasterMemes","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"OldMasterMemes","time":0}]}