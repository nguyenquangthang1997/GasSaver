{"time":75,"results":[{"type":"loop-calculation","before":"int priceBefore = prices[key];","after":"// move outside for loop\nint priceBefore = prices[key];","loc":{"start":{"line":563,"column":12},"end":{"line":563,"column":41}},"contract":"ChainLinkOracle2","time":0},{"type":"loop-calculation","before":"address feedAddr = feedMap[key];","after":"// move outside for loop\naddress feedAddr = feedMap[key];","loc":{"start":{"line":565,"column":12},"end":{"line":565,"column":43}},"contract":"ChainLinkOracle2","time":0},{"type":"struct-data-arrangement ","before":"\nuint id\nuint time\nbool confirmed\nuint roundId\nuint winnerIndex\nuint challengeWinnerIndex\naddress challenger\nbytes32 challengeEvidence\nbytes32 confirmationEvidence","after":"uint id\nuint time\nuint roundId\nuint winnerIndex\nuint challengeWinnerIndex\nbytes32 challengeEvidence\nbytes32 confirmationEvidence\naddress challenger\nbool confirmed\n","contract":"ChainLinkOracle2","time":0},{"type":"external-function ","before":"function setTickerSymbols(bytes32[] memory newKeys, int[] memory newPrices) public managementOnly latestProposalConfirmed {\n\n        bytes32[] memory oldKeys = tickerSymbols;\n\n        tickerSymbols = newKeys;\n\n        setPricesInternal(newPrices);\n\n        // test that this function does not fail before setting\n\n        getWinner();\n\n        emit TickerSymbolsUpdated(oldKeys, newKeys, newPrices);\n\n    }","after":"function setTickerSymbols(bytes32[] calldata newKeys, int[] calldata newPrices) public managementOnly latestProposalConfirmed {\n\n        bytes32[] memory oldKeys = tickerSymbols;\n\n        tickerSymbols = newKeys;\n\n        setPricesInternal(newPrices);\n\n        // test that this function does not fail before setting\n\n        getWinner();\n\n        emit TickerSymbolsUpdated(oldKeys, newKeys, newPrices);\n\n    }","contract":"ChainLinkOracle2","time":0},{"type":"external-function ","before":"function confirmWinnerChallenged(uint chosenWinnerIndex, int[] memory localPrices, bytes32 evidence) public managementOnly {\n\n        Proposal storage proposal = proposals[numProposals];\n\n        require(proposal.challenger != address(0), 'Proposal has not been challenged');\n\n        require(chosenWinnerIndex <= tickerSymbols.length, 'Winner index out of range');\n\n        require(chosenWinnerIndex > 0, 'Winner index must be positive');\n\n        require(localPrices.length == tickerSymbols.length, 'Must specify prices for all ticker symbols');\n\n\n        // set official winner\n\n        proposal.winnerIndex = chosenWinnerIndex;\n\n        proposal.confirmationEvidence = evidence;\n\n\n        // record prices\n\n        setPricesInternal(localPrices);\n\n\n        confirmWinnerInternal();\n\n\n        // if challenger failed, slash their deposit\n\n        if (chosenWinnerIndex != proposal.challengeWinnerIndex) {\n\n            token.transfer(address(0), challengeDeposit);\n\n            emit ChallengerSlashed(numProposals, proposal.challenger, challengeDeposit, evidence);\n\n            // else send it back to them\n\n        } else {\n\n            token.transfer(proposal.challenger, challengeDeposit);\n\n            emit ChallengerVindicated(numProposals, proposal.challenger, evidence);\n\n        }\n\n    }","after":"function confirmWinnerChallenged(uint chosenWinnerIndex, int[] calldata localPrices, bytes32 evidence) public managementOnly {\n\n        Proposal storage proposal = proposals[numProposals];\n\n        require(proposal.challenger != address(0), 'Proposal has not been challenged');\n\n        require(chosenWinnerIndex <= tickerSymbols.length, 'Winner index out of range');\n\n        require(chosenWinnerIndex > 0, 'Winner index must be positive');\n\n        require(localPrices.length == tickerSymbols.length, 'Must specify prices for all ticker symbols');\n\n\n        // set official winner\n\n        proposal.winnerIndex = chosenWinnerIndex;\n\n        proposal.confirmationEvidence = evidence;\n\n\n        // record prices\n\n        setPricesInternal(localPrices);\n\n\n        confirmWinnerInternal();\n\n\n        // if challenger failed, slash their deposit\n\n        if (chosenWinnerIndex != proposal.challengeWinnerIndex) {\n\n            token.transfer(address(0), challengeDeposit);\n\n            emit ChallengerSlashed(numProposals, proposal.challenger, challengeDeposit, evidence);\n\n            // else send it back to them\n\n        } else {\n\n            token.transfer(proposal.challenger, challengeDeposit);\n\n            emit ChallengerVindicated(numProposals, proposal.challenger, evidence);\n\n        }\n\n    }","contract":"ChainLinkOracle2","time":0},{"type":"constant-restrict-modification  ","before":"uint public numProposals = 0;","after":"uint public constant numProposals = 0;","contract":"ChainLinkOracle2","time":0},{"type":"immutable-restrict-modification ","before":"uint public tournamentId = 1;","after":"uint public immutable tournamentId = 1;","contract":"ChainLinkOracle2","time":0},{"type":"immutable-restrict-modification ","before":"uint public startingRoundId = 0;","after":"uint public immutable startingRoundId = 0;","contract":"ChainLinkOracle2","time":0}]}