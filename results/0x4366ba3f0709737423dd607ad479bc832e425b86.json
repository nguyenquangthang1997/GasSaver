{"time":298,"results":[{"type":"struct-data-arrangement ","before":"\naddress component\naddress module\nint256 unit\nuint8 positionState\nbytes data","after":"int256 unit\nbytes data\naddress component\naddress module\nuint8 positionState\n","contract":"ISetToken","time":0},{"type":"state-data-arrangement ","before":"\nstring constant internal DEFAULT_ISSUANCE_MODULE_NAME = \"DefaultIssuanceModule\";\nuint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\nmapping(address => address) public underlyingToCToken;\naddress internal weth;\naddress internal cEther;\nIComptroller internal comptroller;\naddress internal compToken;\nmapping(ISetToken => mapping(address => bool)) public isCollateralCTokenEnabled;\nmapping(ISetToken => mapping(address => bool)) public isBorrowCTokenEnabled;\nmapping(ISetToken => EnabledAssets) internal enabledAssets;\nmapping(ISetToken => bool) public allowList;\nbool public anySetInitializable;","after":"string constant internal DEFAULT_ISSUANCE_MODULE_NAME = \"DefaultIssuanceModule\";\nuint256 constant internal PROTOCOL_TRADE_FEE_INDEX = 0;\nmapping(address => address) public underlyingToCToken;\nIComptroller internal comptroller;\nmapping(ISetToken => mapping(address => bool)) public isCollateralCTokenEnabled;\nmapping(ISetToken => mapping(address => bool)) public isBorrowCTokenEnabled;\nmapping(ISetToken => EnabledAssets) internal enabledAssets;\nmapping(ISetToken => bool) public allowList;\naddress internal weth;\naddress internal cEther;\naddress internal compToken;\nbool public anySetInitializable;\n","contract":"CompoundLeverageModule","time":1},{"type":"external-function ","before":"function lever(\n\n        ISetToken _setToken,\n\n        address _borrowAsset,\n\n        address _collateralAsset,\n\n        uint256 _borrowQuantity,\n\n        uint256 _minReceiveQuantity,\n\n        string memory _tradeAdapterName,\n\n        bytes memory _tradeData\n\n    )\n\n    external\n\n    nonReentrant\n\n    onlyManagerAndValidSet(_setToken)\n\n    {\n\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from \n\n        // collateral asset\n\n        ActionInfo memory leverInfo = _createActionInfo(\n\n            _setToken,\n\n            _borrowAsset,\n\n            _collateralAsset,\n\n            _borrowQuantity,\n\n            _minReceiveQuantity,\n\n            _tradeAdapterName,\n\n            true\n\n        );\n\n\n        _validateCommon(leverInfo);\n\n\n        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);\n\n\n        (uint256 protocolFee, uint256 postTradeCollateralQuantity) = _tradeAndHandleFees(\n\n            _setToken,\n\n            _borrowAsset,\n\n            _collateralAsset,\n\n            leverInfo.notionalSendQuantity,\n\n            leverInfo.minNotionalReceiveQuantity,\n\n            leverInfo.preTradeReceiveTokenBalance,\n\n            leverInfo.exchangeAdapter,\n\n            _tradeData\n\n        );\n\n\n        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);\n\n\n        _updateCollateralPosition(\n\n            leverInfo.setToken,\n\n            leverInfo.collateralCTokenAsset,\n\n            _getCollateralPosition(\n\n                leverInfo.setToken,\n\n                leverInfo.collateralCTokenAsset,\n\n                leverInfo.setTotalSupply\n\n            )\n\n        );\n\n\n        _updateBorrowPosition(\n\n            leverInfo.setToken,\n\n            _borrowAsset,\n\n            _getBorrowPosition(\n\n                leverInfo.setToken,\n\n                leverInfo.borrowCTokenAsset,\n\n                leverInfo.setTotalSupply\n\n            )\n\n        );\n\n\n        emit LeverageIncreased(\n\n            _setToken,\n\n            _borrowAsset,\n\n            _collateralAsset,\n\n            leverInfo.exchangeAdapter,\n\n            leverInfo.notionalSendQuantity,\n\n            postTradeCollateralQuantity,\n\n            protocolFee\n\n        );\n\n    }","after":"function lever(\n\n        ISetToken _setToken,\n\n        address _borrowAsset,\n\n        address _collateralAsset,\n\n        uint256 _borrowQuantity,\n\n        uint256 _minReceiveQuantity,\n\n        string calldata _tradeAdapterName,\n\n        bytes calldata _tradeData\n\n    )\n\n    external\n\n    nonReentrant\n\n    onlyManagerAndValidSet(_setToken)\n\n    {\n\n        // For levering up, send quantity is derived from borrow asset and receive quantity is derived from \n\n        // collateral asset\n\n        ActionInfo memory leverInfo = _createActionInfo(\n\n            _setToken,\n\n            _borrowAsset,\n\n            _collateralAsset,\n\n            _borrowQuantity,\n\n            _minReceiveQuantity,\n\n            _tradeAdapterName,\n\n            true\n\n        );\n\n\n        _validateCommon(leverInfo);\n\n\n        _borrow(leverInfo.setToken, leverInfo.borrowCTokenAsset, leverInfo.notionalSendQuantity);\n\n\n        (uint256 protocolFee, uint256 postTradeCollateralQuantity) = _tradeAndHandleFees(\n\n            _setToken,\n\n            _borrowAsset,\n\n            _collateralAsset,\n\n            leverInfo.notionalSendQuantity,\n\n            leverInfo.minNotionalReceiveQuantity,\n\n            leverInfo.preTradeReceiveTokenBalance,\n\n            leverInfo.exchangeAdapter,\n\n            _tradeData\n\n        );\n\n\n        _mintCToken(leverInfo.setToken, leverInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);\n\n\n        _updateCollateralPosition(\n\n            leverInfo.setToken,\n\n            leverInfo.collateralCTokenAsset,\n\n            _getCollateralPosition(\n\n                leverInfo.setToken,\n\n                leverInfo.collateralCTokenAsset,\n\n                leverInfo.setTotalSupply\n\n            )\n\n        );\n\n\n        _updateBorrowPosition(\n\n            leverInfo.setToken,\n\n            _borrowAsset,\n\n            _getBorrowPosition(\n\n                leverInfo.setToken,\n\n                leverInfo.borrowCTokenAsset,\n\n                leverInfo.setTotalSupply\n\n            )\n\n        );\n\n\n        emit LeverageIncreased(\n\n            _setToken,\n\n            _borrowAsset,\n\n            _collateralAsset,\n\n            leverInfo.exchangeAdapter,\n\n            leverInfo.notionalSendQuantity,\n\n            postTradeCollateralQuantity,\n\n            protocolFee\n\n        );\n\n    }","contract":"CompoundLeverageModule","time":0},{"type":"external-function ","before":"function delever(\n\n        ISetToken _setToken,\n\n        address _collateralAsset,\n\n        address _repayAsset,\n\n        uint256 _redeemQuantity,\n\n        uint256 _minRepayQuantity,\n\n        string memory _tradeAdapterName,\n\n        bytes memory _tradeData\n\n    )\n\n    external\n\n    nonReentrant\n\n    onlyManagerAndValidSet(_setToken)\n\n    {\n\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from \n\n        // repay asset\n\n        ActionInfo memory deleverInfo = _createActionInfo(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _repayAsset,\n\n            _redeemQuantity,\n\n            _minRepayQuantity,\n\n            _tradeAdapterName,\n\n            false\n\n        );\n\n\n        _validateCommon(deleverInfo);\n\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n\n        (uint256 protocolFee, uint256 postTradeRepayQuantity) = _tradeAndHandleFees(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _repayAsset,\n\n            deleverInfo.notionalSendQuantity,\n\n            deleverInfo.minNotionalReceiveQuantity,\n\n            deleverInfo.preTradeReceiveTokenBalance,\n\n            deleverInfo.exchangeAdapter,\n\n            _tradeData\n\n        );\n\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, postTradeRepayQuantity);\n\n\n        _updateCollateralPosition(\n\n            deleverInfo.setToken,\n\n            deleverInfo.collateralCTokenAsset,\n\n            _getCollateralPosition(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.setTotalSupply)\n\n        );\n\n\n        _updateBorrowPosition(\n\n            deleverInfo.setToken,\n\n            _repayAsset,\n\n            _getBorrowPosition(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, deleverInfo.setTotalSupply)\n\n        );\n\n\n        emit LeverageDecreased(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _repayAsset,\n\n            deleverInfo.exchangeAdapter,\n\n            deleverInfo.notionalSendQuantity,\n\n            postTradeRepayQuantity,\n\n            protocolFee\n\n        );\n\n    }","after":"function delever(\n\n        ISetToken _setToken,\n\n        address _collateralAsset,\n\n        address _repayAsset,\n\n        uint256 _redeemQuantity,\n\n        uint256 _minRepayQuantity,\n\n        string calldata _tradeAdapterName,\n\n        bytes calldata _tradeData\n\n    )\n\n    external\n\n    nonReentrant\n\n    onlyManagerAndValidSet(_setToken)\n\n    {\n\n        // Note: for delevering, send quantity is derived from collateral asset and receive quantity is derived from \n\n        // repay asset\n\n        ActionInfo memory deleverInfo = _createActionInfo(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _repayAsset,\n\n            _redeemQuantity,\n\n            _minRepayQuantity,\n\n            _tradeAdapterName,\n\n            false\n\n        );\n\n\n        _validateCommon(deleverInfo);\n\n\n        _redeemUnderlying(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.notionalSendQuantity);\n\n\n        (uint256 protocolFee, uint256 postTradeRepayQuantity) = _tradeAndHandleFees(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _repayAsset,\n\n            deleverInfo.notionalSendQuantity,\n\n            deleverInfo.minNotionalReceiveQuantity,\n\n            deleverInfo.preTradeReceiveTokenBalance,\n\n            deleverInfo.exchangeAdapter,\n\n            _tradeData\n\n        );\n\n\n        _repayBorrow(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, _repayAsset, postTradeRepayQuantity);\n\n\n        _updateCollateralPosition(\n\n            deleverInfo.setToken,\n\n            deleverInfo.collateralCTokenAsset,\n\n            _getCollateralPosition(deleverInfo.setToken, deleverInfo.collateralCTokenAsset, deleverInfo.setTotalSupply)\n\n        );\n\n\n        _updateBorrowPosition(\n\n            deleverInfo.setToken,\n\n            _repayAsset,\n\n            _getBorrowPosition(deleverInfo.setToken, deleverInfo.borrowCTokenAsset, deleverInfo.setTotalSupply)\n\n        );\n\n\n        emit LeverageDecreased(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _repayAsset,\n\n            deleverInfo.exchangeAdapter,\n\n            deleverInfo.notionalSendQuantity,\n\n            postTradeRepayQuantity,\n\n            protocolFee\n\n        );\n\n    }","contract":"CompoundLeverageModule","time":1},{"type":"external-function ","before":"function gulp(\n\n        ISetToken _setToken,\n\n        address _collateralAsset,\n\n        uint256 _minNotionalReceiveQuantity,\n\n        string memory _tradeAdapterName,\n\n        bytes memory _tradeData\n\n    )\n\n    external\n\n    nonReentrant\n\n    onlyManagerAndValidSet(_setToken)\n\n    {\n\n        // Claim COMP. Note: COMP can be claimed by anyone for any address\n\n        comptroller.claimComp(address(_setToken));\n\n\n        ActionInfo memory gulpInfo = _createGulpInfoAndValidate(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _tradeAdapterName\n\n        );\n\n\n        uint256 protocolFee;\n\n        uint256 postTradeCollateralQuantity;\n\n        if (_collateralAsset == compToken) {\n\n            // If specified collateral asset is COMP, then skip trade and set post trade collateral quantity\n\n            postTradeCollateralQuantity = gulpInfo.preTradeReceiveTokenBalance;\n\n        } else {\n\n            (protocolFee, postTradeCollateralQuantity) = _tradeAndHandleFees(\n\n                _setToken,\n\n                compToken,\n\n                _collateralAsset,\n\n                gulpInfo.notionalSendQuantity,\n\n                _minNotionalReceiveQuantity,\n\n                gulpInfo.preTradeReceiveTokenBalance,\n\n                gulpInfo.exchangeAdapter,\n\n                _tradeData\n\n            );\n\n        }\n\n\n        _mintCToken(_setToken, gulpInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);\n\n\n        _updateCollateralPosition(\n\n            _setToken,\n\n            gulpInfo.collateralCTokenAsset,\n\n            _getCollateralPosition(_setToken, gulpInfo.collateralCTokenAsset, gulpInfo.setTotalSupply)\n\n        );\n\n\n        emit CompGulped(\n\n            _setToken,\n\n            _collateralAsset,\n\n            gulpInfo.exchangeAdapter,\n\n            gulpInfo.notionalSendQuantity,\n\n            postTradeCollateralQuantity,\n\n            protocolFee\n\n        );\n\n    }","after":"function gulp(\n\n        ISetToken _setToken,\n\n        address _collateralAsset,\n\n        uint256 _minNotionalReceiveQuantity,\n\n        string calldata _tradeAdapterName,\n\n        bytes calldata _tradeData\n\n    )\n\n    external\n\n    nonReentrant\n\n    onlyManagerAndValidSet(_setToken)\n\n    {\n\n        // Claim COMP. Note: COMP can be claimed by anyone for any address\n\n        comptroller.claimComp(address(_setToken));\n\n\n        ActionInfo memory gulpInfo = _createGulpInfoAndValidate(\n\n            _setToken,\n\n            _collateralAsset,\n\n            _tradeAdapterName\n\n        );\n\n\n        uint256 protocolFee;\n\n        uint256 postTradeCollateralQuantity;\n\n        if (_collateralAsset == compToken) {\n\n            // If specified collateral asset is COMP, then skip trade and set post trade collateral quantity\n\n            postTradeCollateralQuantity = gulpInfo.preTradeReceiveTokenBalance;\n\n        } else {\n\n            (protocolFee, postTradeCollateralQuantity) = _tradeAndHandleFees(\n\n                _setToken,\n\n                compToken,\n\n                _collateralAsset,\n\n                gulpInfo.notionalSendQuantity,\n\n                _minNotionalReceiveQuantity,\n\n                gulpInfo.preTradeReceiveTokenBalance,\n\n                gulpInfo.exchangeAdapter,\n\n                _tradeData\n\n            );\n\n        }\n\n\n        _mintCToken(_setToken, gulpInfo.collateralCTokenAsset, _collateralAsset, postTradeCollateralQuantity);\n\n\n        _updateCollateralPosition(\n\n            _setToken,\n\n            gulpInfo.collateralCTokenAsset,\n\n            _getCollateralPosition(_setToken, gulpInfo.collateralCTokenAsset, gulpInfo.setTotalSupply)\n\n        );\n\n\n        emit CompGulped(\n\n            _setToken,\n\n            _collateralAsset,\n\n            gulpInfo.exchangeAdapter,\n\n            gulpInfo.notionalSendQuantity,\n\n            postTradeCollateralQuantity,\n\n            protocolFee\n\n        );\n\n    }","contract":"CompoundLeverageModule","time":0},{"type":"external-function ","before":"function initialize(\n\n        ISetToken _setToken,\n\n        address[] memory _collateralAssets,\n\n        address[] memory _borrowAssets\n\n    )\n\n    external\n\n    onlySetManager(_setToken, msg.sender)\n\n    onlyValidAndPendingSet(_setToken)\n\n    {\n\n        if (!anySetInitializable) {\n\n            require(allowList[_setToken], \"Not allowlisted\");\n\n        }\n\n\n        // Initialize module before trying register\n\n        _setToken.initializeModule();\n\n\n        // Get debt issuance module registered to this module and require that it is initialized\n\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), \"Issuance not initialized\");\n\n\n        // Try if register exists on any of the modules including the debt issuance module\n\n        address[] memory modules = _setToken.getModules();\n\n        for (uint256 i = 0; i < modules.length; i++) {\n\n            try IDebtIssuanceModule(modules[i]).register(_setToken) {} catch {}\n\n        }\n\n\n        // Enable collateral and borrow assets on Compound\n\n        addCollateralAssets(_setToken, _collateralAssets);\n\n\n        addBorrowAssets(_setToken, _borrowAssets);\n\n    }","after":"function initialize(\n\n        ISetToken _setToken,\n\n        address[] calldata _collateralAssets,\n\n        address[] calldata _borrowAssets\n\n    )\n\n    external\n\n    onlySetManager(_setToken, msg.sender)\n\n    onlyValidAndPendingSet(_setToken)\n\n    {\n\n        if (!anySetInitializable) {\n\n            require(allowList[_setToken], \"Not allowlisted\");\n\n        }\n\n\n        // Initialize module before trying register\n\n        _setToken.initializeModule();\n\n\n        // Get debt issuance module registered to this module and require that it is initialized\n\n        require(_setToken.isInitializedModule(getAndValidateAdapter(DEFAULT_ISSUANCE_MODULE_NAME)), \"Issuance not initialized\");\n\n\n        // Try if register exists on any of the modules including the debt issuance module\n\n        address[] memory modules = _setToken.getModules();\n\n        for (uint256 i = 0; i < modules.length; i++) {\n\n            try IDebtIssuanceModule(modules[i]).register(_setToken) {} catch {}\n\n        }\n\n\n        // Enable collateral and borrow assets on Compound\n\n        addCollateralAssets(_setToken, _collateralAssets);\n\n\n        addBorrowAssets(_setToken, _borrowAssets);\n\n    }","contract":"CompoundLeverageModule","time":0},{"type":"external-function ","before":"function removeCollateralAssets(ISetToken _setToken, address[] memory _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n\n        // Sync Compound and SetToken positions prior to any removal action\n\n        sync(_setToken);\n\n\n        for (uint256 i = 0; i < _collateralAssets.length; i++) {\n\n            address cToken = underlyingToCToken[_collateralAssets[i]];\n\n            require(isCollateralCTokenEnabled[_setToken][cToken], \"Collateral not enabled\");\n\n\n            // Note: Will only exit market if cToken is not enabled as a borrow asset as well\n\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n\n            if (!isBorrowCTokenEnabled[_setToken][cToken]) {\n\n                _exitMarket(_setToken, cToken);\n\n            }\n\n\n            delete isCollateralCTokenEnabled[_setToken][cToken];\n\n            enabledAssets[_setToken].collateralCTokens = enabledAssets[_setToken].collateralCTokens.remove(cToken);\n\n        }\n\n\n        emit CollateralAssetsRemoved(_setToken, _collateralAssets);\n\n    }","after":"function removeCollateralAssets(ISetToken _setToken, address[] calldata _collateralAssets) external onlyManagerAndValidSet(_setToken) {\n\n        // Sync Compound and SetToken positions prior to any removal action\n\n        sync(_setToken);\n\n\n        for (uint256 i = 0; i < _collateralAssets.length; i++) {\n\n            address cToken = underlyingToCToken[_collateralAssets[i]];\n\n            require(isCollateralCTokenEnabled[_setToken][cToken], \"Collateral not enabled\");\n\n\n            // Note: Will only exit market if cToken is not enabled as a borrow asset as well\n\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n\n            if (!isBorrowCTokenEnabled[_setToken][cToken]) {\n\n                _exitMarket(_setToken, cToken);\n\n            }\n\n\n            delete isCollateralCTokenEnabled[_setToken][cToken];\n\n            enabledAssets[_setToken].collateralCTokens = enabledAssets[_setToken].collateralCTokens.remove(cToken);\n\n        }\n\n\n        emit CollateralAssetsRemoved(_setToken, _collateralAssets);\n\n    }","contract":"CompoundLeverageModule","time":0},{"type":"external-function ","before":"function removeBorrowAssets(ISetToken _setToken, address[] memory _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n\n        // Sync Compound and SetToken positions prior to any removal action\n\n        sync(_setToken);\n\n\n        for (uint256 i = 0; i < _borrowAssets.length; i++) {\n\n            address cToken = underlyingToCToken[_borrowAssets[i]];\n\n            require(isBorrowCTokenEnabled[_setToken][cToken], \"Borrow not enabled\");\n\n\n            // Note: Will only exit market if cToken is not enabled as a collateral asset as well\n\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n\n            if (!isCollateralCTokenEnabled[_setToken][cToken]) {\n\n                _exitMarket(_setToken, cToken);\n\n            }\n\n\n            delete isBorrowCTokenEnabled[_setToken][cToken];\n\n            enabledAssets[_setToken].borrowCTokens = enabledAssets[_setToken].borrowCTokens.remove(cToken);\n\n            enabledAssets[_setToken].borrowAssets = enabledAssets[_setToken].borrowAssets.remove(_borrowAssets[i]);\n\n        }\n\n\n        emit BorrowAssetsRemoved(_setToken, _borrowAssets);\n\n    }","after":"function removeBorrowAssets(ISetToken _setToken, address[] calldata _borrowAssets) external onlyManagerAndValidSet(_setToken) {\n\n        // Sync Compound and SetToken positions prior to any removal action\n\n        sync(_setToken);\n\n\n        for (uint256 i = 0; i < _borrowAssets.length; i++) {\n\n            address cToken = underlyingToCToken[_borrowAssets[i]];\n\n            require(isBorrowCTokenEnabled[_setToken][cToken], \"Borrow not enabled\");\n\n\n            // Note: Will only exit market if cToken is not enabled as a collateral asset as well\n\n            // If there is an existing borrow balance, will revert and market cannot be exited on Compound\n\n            if (!isCollateralCTokenEnabled[_setToken][cToken]) {\n\n                _exitMarket(_setToken, cToken);\n\n            }\n\n\n            delete isBorrowCTokenEnabled[_setToken][cToken];\n\n            enabledAssets[_setToken].borrowCTokens = enabledAssets[_setToken].borrowCTokens.remove(cToken);\n\n            enabledAssets[_setToken].borrowAssets = enabledAssets[_setToken].borrowAssets.remove(_borrowAssets[i]);\n\n        }\n\n\n        emit BorrowAssetsRemoved(_setToken, _borrowAssets);\n\n    }","contract":"CompoundLeverageModule","time":0},{"type":"immutable-restrict-modification ","before":"address internal weth;","after":"address internal immutable weth;","contract":"CompoundLeverageModule","time":0},{"type":"immutable-restrict-modification ","before":"address internal cEther;","after":"address internal immutable cEther;","contract":"CompoundLeverageModule","time":0},{"type":"immutable-restrict-modification ","before":"address internal compToken;","after":"address internal immutable compToken;","contract":"CompoundLeverageModule","time":0}]}