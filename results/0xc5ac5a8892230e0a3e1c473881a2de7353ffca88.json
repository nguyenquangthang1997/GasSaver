{"time":1208,"results":[{"type":"state-data-arrangement ","before":"\n�▓▓▓\n▓▓▓�\n��▓ ▐▓▓▓▓▓�\n▓▓▓  ▓▓▓▓▓▓�\nport \"./api/IBondingMan\nmport \"openzeppelin-so\nndedECDSAKeep is IBondedECDSAKeep {\n    usi\n    // Status of the keep.\n    // Active mean\nAddress of the keep's owner.\n    addres\nof honest keep members required to produce a signature.\nbytes, where X and Y coordinates\n    // are padded with\nests requested to be signed. Used to validate submit\nionStartTimestamp;\n\n   \ne timestamp at which signing process\nress. When set to `0` indica","after":"��▓ ▐▓▓▓▓▓�\n▓▓▓  ▓▓▓▓▓▓�\nport \"./api/IBondingMan\nmport \"openzeppelin-so\nndedECDSAKeep is IBondedECDSAKeep {\n    usi\n    // Status of the keep.\n    // Active mean\nAddress of the keep's owner.\n    addres\nof honest keep members required to produce a signature.\nbytes, where X and Y coordinates\n    // are padded with\nests requested to be signed. Used to validate submit\nionStartTimestamp;\n\n   \ne timestamp at which signing process\n�▓▓▓\n▓▓▓�\nress. When set to `0` indica\n","contract":"AbstractBondedECDSAKeep","time":1},{"type":"external-function ","before":"rce of the delegated authority.\n    /// If the contract doesn't use delegated authority,\n    /// returns the contract itself.\n    /// Authorize `getAuthoritySource(operatorContract)`\n    /// to grant `operatorContract` the authority to penalize an operator.\n    function getAuthoritySource(\n        address operatorContract\n    ) public view returns (address) {\n        address delegatedAuthoritySource = delegatedAuthority[operatorContract];\n        if (delegatedAuthoritySource == address(0)) {\n            return operatorContract;\n        }\n        return getAuthority","after":"rce of the delegated authority.\n    /// If the contract doesn't use delegated authority,\n    /// returns the contract itself.\n    /// Authorize `getAuthoritySource(operatorContract)`\n    /// to grant `operatorContract` the authority to penalize an operator.\n    function getAuthoritySource(\n        address operatorContract\n    ) public view returns (address) {\n        address delegatedAuthoritySource = delegatedAuthority[operatorContract];\n        if (delegatedAuthoritySource == address(0)) {\n            return operatorContract;\n        }\n        return getAuthority","contract":"BondedECDSAKeep","time":0},{"type":"immutable-restrict-modification ","before":" (uint256);\n\n    /// @notice Subm","after":" (uint256);\n\n    /// @notice Subm","contract":"BondedECDSAKeepFactory","time":0},{"type":"external-function ","before":"other bits.\n        // If this number is equal or greater than `range`,\n        // the range [0, range-1] fits in `bits` bits.\n        //\n        // Because we loop from high bits to low bits,\n        // we find the highest number of bits that doesn't fit the range,\n        // and return that number + 1.\n        while (1 << bits >= range) {\n            bits--;\n        }\n\n        return bits + 1;\n    }\n\n    /// @notice Truncate `input` to the `bits` least significant bits.\n    function truncate(uint256 bits, uint256 input)\n    internal\n    pure\n    returns (uint256)\n    {\n        return input & ((1 << bits) - 1);\n    }\n\n    /// @notice Get an index in the range `[0 .","after":"other bits.\n        // If this number is equal or greater than `range`,\n        // the range [0, range-1] fits in `bits` bits.\n        //\n        // Because we loop from high bits to low bits,\n        // we find the highest number of bits that doesn't fit the range,\n        // and return that number + 1.\n        while (1 << bits >= range) {\n            bits--;\n        }\n\n        return bits + 1;\n    }\n\n    /// @notice Truncate `input` to the `bits` least significant bits.\n    function truncate(uint256 bits, uint256 input)\n    internal\n    pure\n    returns (uint256)\n    {\n        return input & ((1 << bits) - 1);\n    }\n\n    /// @notice Get an index in the range `[0 .","contract":"ECDSARewards","time":0},{"type":"external-function ","before":"   /// @dev Calculates the number of bits required for the desired range,\n    /// takes the least significant bits of `state`\n    /// and checks if the obtained index is within the desired ran","after":"   /// @dev Calculates the number of bits required for the desired range,\n    /// takes the least significant bits of `state`\n    /// and checks if the obtained index is within the desired ran","contract":"ECDSARewards","time":0},{"type":"external-function ","before":"ith the latest output.\n    function getIndex(uint256 range, bytes32 state)\n    internal\n    view\n    returns (uint256, bytes32)\n    {\n        uint256 bits = bitsRequired(range);\n        bool found = f","after":"ith the latest output.\n    function getIndex(uint256 range, bytes32 state)\n    internal\n    view\n    returns (uint256, bytes32)\n    {\n        uint256 bits = bitsRequired(range);\n        bool found = f","contract":"ECDSARewards","time":0},{"type":"constant-restrict-modification  ","before":"ngth := mul(length, 0x20)\n            mstore(dest, length","after":"ngth := mul(length, 0x20)\n            mstore(dest, length","contract":"ECDSARewards","time":1},{"type":"immutable-restrict-modification ","before":"edIndex;\n        // The ra","after":"edIndex;\n        // The ra","contract":"ECDSARewards","time":1},{"type":"immutable-restrict-modification ","before":"rated random numbers are in [0, fullRan","after":"rated random numbers are in [0, fullRan","contract":"ECDSARewards","time":1},{"type":"immutable-restrict-modification ","before":"d(\n        State memory self,\n    ","after":"d(\n        State memory self,\n    ","contract":"ECDSARewards","time":1},{"type":"external-function ","before":" - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set","after":" - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set","contract":"GrantStaking","time":0},{"type":"external-function ","before":"ction withdrawAsManagedGrantee(\n        uint256 amount,\n        address operator,\n        address managedGrant\n    ) public {\n        require(\n            msg.sender.isManagedGranteeForOperator(\n                operator,\n                managedGrant,\n                tokenGrant\n            ),\n            \"Only grantee is allowed to withdr","after":"ction withdrawAsManagedGrantee(\n        uint256 amount,\n        address operator,\n        address managedGrant\n    ) public {\n        require(\n            msg.sender.isManagedGranteeForOperator(\n                operator,\n                managedGrant,\n                tokenGrant\n            ),\n            \"Only grantee is allowed to withdr","contract":"KeepToken","time":0},{"type":"immutable-restrict-modification ","before":" See `IERC20.allowanc","after":" See `IERC20.allowanc","contract":"KeepToken","time":0},{"type":"immutable-restrict-modification ","before":"    */\n    function all","after":"    */\n    function all","contract":"KeepToken","time":0},{"type":"immutable-restrict-modification ","before":"e(address owner, address","after":"e(address owner, address","contract":"KeepToken","time":0},{"type":"external-function ","before":"rue;\n        }\n    }\n\n}\npragma solidity 0.5.17;\n\nlibrary Leaf {\n    ////////////////////////////////////////////////////////////////////////////\n    // Parameters for configuration\n\n    // How many bits a position","after":"rue;\n        }\n    }\n\n}\npragma solidity 0.5.17;\n\nlibrary Leaf {\n    ////////////////////////////////////////////////////////////////////////////\n    // Parameters for configuration\n\n    // How many bits a position","contract":"ManagedGrant","time":0},{"type":"immutable-restrict-modification ","before":"      );\n\n        panicButto","after":"      );\n\n        panicButto","contract":"ManagedGrant","time":0},{"type":"immutable-restrict-modification ","before":"peratorContract] = addr","after":"peratorContract] = addr","contract":"ManagedGrant","time":0},{"type":"state-data-arrangement ","before":"\n_BITS;\n    uint256 cons\n/////\n\n    struct State {\n       \nedIndex;\n        // The ra\nrated random numbers are in [0, fullRan\n are left to consider.\n     \npped to the full range by skipping\n     uint256 expectedSkippedCoun\nd(\n        State memory self,\n    \nrrentSeed = keccak256(\n            abi.\nemory self) internal view {\n        uint25\ndex < self.truncatedRange) {\n            self.current\n  generateNewIndex(self);\n        }\n    }\n\n    function up\nge = uint256(int256(self.tr\n;\n    }\n\n    function addSkippedInterval(\n    State memory self,\n        uint256 st\ndex,\n        uint256 weight\n    ) ","after":"_BITS;\n    uint256 cons\n/////\n\n    struct State {\n       \nedIndex;\n        // The ra\nrated random numbers are in [0, fullRan\n are left to consider.\n     \npped to the full range by skipping\n     uint256 expectedSkippedCoun\nd(\n        State memory self,\n    \nrrentSeed = keccak256(\n            abi.\nemory self) internal view {\n        uint25\ndex < self.truncatedRange) {\n            self.current\n  generateNewIndex(self);\n        }\n    }\n\n    function up\n;\n    }\n\n    function addSkippedInterval(\n    State memory self,\n        uint256 st\ndex,\n        uint256 weight\n    ) \nge = uint256(int256(self.tr\n","contract":"Rewards","time":0},{"type":"struct-data-arrangement ","before":"\nentire\n * class of b\n always.\n */\nli\nd integers, rever\nrator.\n     *\n     * \n function add(uint256 a,\n a + b;\n      \n  return c;\n  \nion of two unsig\nCounterpart t\nn cannot over\nre returns (uint2\nerflow\");\n    \n /**\n     * @dev Returns the mul","after":"d integers, rever\nrator.\n     *\n     * \n function add(uint256 a,\n  return c;\n  \nion of two unsig\nCounterpart t\nn cannot over\nre returns (uint2\nerflow\");\n    \n /**\n     * @dev Returns the mul\nentire\n * class of b\n always.\n */\nli\n a + b;\n      \n","contract":"TokenGrant","time":0},{"type":"external-function ","before":"6 newNode;\n        uint256 nodeWeight = theLeaf.weight();\n\n        // set leaf\n        leaves[position] = theLeaf;\n\n        uint256 parent = position;\n        // set levels 7 to 2\n        for (uint256 level = LEVELS; level >= 2; level--) {\n            childSlot = parent.slot();\n            parent = parent.parent();\n            treeNode = branches[level][parent];\n            newNode = treeNode.setSlot(childSlot, nodeWeight);\n            branches[level][parent] = newNode;\n            nodeWeight = newNode.sumWeight();\n        }\n\n        // set level Root\n        childSlot = parent.slot();\n        return _root.setSlot(childSlot, nodeWeight);\n    }\n\n    function pickWeightedLeaf(uint256 index, uint256 _root)\n    internal\n    view\n    returns (uint256 leafPosition, uint256 leafFirstIndex)\n    {\n        uint256 currentIndex = index;\n        uint256 currentNode = _root;\n        uint256 currentPosition = 0;\n        uint256 currentSlot;\n\n        require(index < currentNode.sumWeight(), \"Index exceeds weight\");\n\n        // get root slot\n        (currentSlot, currentIndex) = currentNode.pickWeightedSlot(currentIndex);\n\n        // get slots from levels 2 to 7\n        for (uint256 level = 2; level <= LEVELS; level++) {\n            currentPosition = currentPosition.child(currentSlot);\n            currentNode = branches[level][currentPosition];\n            (currentSlot, currentIndex) = currentNode.pickWeightedSlot(currentIndex);\n        }\n\n        // get leaf position\n        leafPosition = currentPosition.child(currentSlot);\n        // get the first index of the leaf\n        // This works because the last weight returned from `pickWeightedSlot()`\n        // equals the \"overflow\" from getting the current slot.\n        le","after":"6 newNode;\n        uint256 nodeWeight = theLeaf.weight();\n\n        // set leaf\n        leaves[position] = theLeaf;\n\n        uint256 parent = position;\n        // set levels 7 to 2\n        for (uint256 level = LEVELS; level >= 2; level--) {\n            childSlot = parent.slot();\n            parent = parent.parent();\n            treeNode = branches[level][parent];\n            newNode = treeNode.setSlot(childSlot, nodeWeight);\n            branches[level][parent] = newNode;\n            nodeWeight = newNode.sumWeight();\n        }\n\n        // set level Root\n        childSlot = parent.slot();\n        return _root.setSlot(childSlot, nodeWeight);\n    }\n\n    function pickWeightedLeaf(uint256 index, uint256 _root)\n    internal\n    view\n    returns (uint256 leafPosition, uint256 leafFirstIndex)\n    {\n        uint256 currentIndex = index;\n        uint256 currentNode = _root;\n        uint256 currentPosition = 0;\n        uint256 currentSlot;\n\n        require(index < currentNode.sumWeight(), \"Index exceeds weight\");\n\n        // get root slot\n        (currentSlot, currentIndex) = currentNode.pickWeightedSlot(currentIndex);\n\n        // get slots from levels 2 to 7\n        for (uint256 level = 2; level <= LEVELS; level++) {\n            currentPosition = currentPosition.child(currentSlot);\n            currentNode = branches[level][currentPosition];\n            (currentSlot, currentIndex) = currentNode.pickWeightedSlot(currentIndex);\n        }\n\n        // get leaf position\n        leafPosition = currentPosition.child(currentSlot);\n        // get the first index of the leaf\n        // This works because the last weight returned from `pickWeightedSlot()`\n        // equals the \"overflow\" from getting the current slot.\n        le","contract":"TokenGrant","time":0},{"type":"external-function ","before":" A token grant contract for a specified standard ERC20Burnable token.\n/// Has additional functionality to stake delegate/undelegate token grants.\n/// Tokens are granted to the grantee via unlocking scheme and can be\n/// withdrawn gradually based on the unlocking schedule cliff and unlocking duration.\n/// Optionally grant can be revoked by the token grant manager.\ncontract TokenGrant {\n    using SafeMath for uint256;\n    using UnlockingSchedule for uint256;\n    using SafeERC20 for ERC20Burnable;\n    using BytesLib for bytes;\n    using AddressArrayUtils for address[];\n\n    event TokenGrantCreated(uint256 id);\n    event TokenGrantWithdrawn(uint256 indexed grantId, uint256 amount);\n    event TokenGrantStaked(uint256 indexed grantId, uint256 amount, address operator);\n    event TokenGrantRevoked(uint256 id);\n\n    event StakingContractAuthorized(address indexed grantManager, address stakingContract);\n\n    struct Grant {\n        address grantManager; // Token grant manager.\n        address grantee; // Address to which granted tokens are going to be withdrawn.\n        uint256 revokedAt; // Timestamp at which grant was revoked by the grant manager.\n        uint256 revokedAmount; // The number of tokens revoked from the grantee.\n        uint256 revokedWithdrawn; // The number of tokens returned to the grant creator.\n        bool revocable; // Whether grant manager can revoke the grant.\n        uint256 amount; // Amount of tokens to be granted.\n        uint256 duration; // Durat","after":" A token grant contract for a specified standard ERC20Burnable token.\n/// Has additional functionality to stake delegate/undelegate token grants.\n/// Tokens are granted to the grantee via unlocking scheme and can be\n/// withdrawn gradually based on the unlocking schedule cliff and unlocking duration.\n/// Optionally grant can be revoked by the token grant manager.\ncontract TokenGrant {\n    using SafeMath for uint256;\n    using UnlockingSchedule for uint256;\n    using SafeERC20 for ERC20Burnable;\n    using BytesLib for bytes;\n    using AddressArrayUtils for address[];\n\n    event TokenGrantCreated(uint256 id);\n    event TokenGrantWithdrawn(uint256 indexed grantId, uint256 amount);\n    event TokenGrantStaked(uint256 indexed grantId, uint256 amount, address operator);\n    event TokenGrantRevoked(uint256 id);\n\n    event StakingContractAuthorized(address indexed grantManager, address stakingContract);\n\n    struct Grant {\n        address grantManager; // Token grant manager.\n        address grantee; // Address to which granted tokens are going to be withdrawn.\n        uint256 revokedAt; // Timestamp at which grant was revoked by the grant manager.\n        uint256 revokedAmount; // The number of tokens revoked from the grantee.\n        uint256 revokedWithdrawn; // The number of tokens returned to the grant creator.\n        bool revocable; // Whether grant manager can revoke the grant.\n        uint256 amount; // Amount of tokens to be granted.\n        uint256 duration; // Durat","contract":"TokenGrant","time":0},{"type":"external-function ","before":"iven operator.\n    /// @param operator The operator address.\n    /// @return grantId ID of the token grant.\n    /// @return amount The amount of tokens the given operator delegated.\n    /// @return stakingContract The address of staking contract.\n    function getGrantStakeDetails(address operator) public view retur","after":"iven operator.\n    /// @param operator The operator address.\n    /// @return grantId ID of the token grant.\n    /// @return amount The amount of tokens the given operator delegated.\n    /// @return stakingContract The address of staking contract.\n    function getGrantStakeDetails(address operator) public view retur","contract":"TokenGrantStake","time":0},{"type":"immutable-restrict-modification ","before":"dress(grants[_id].s","after":"dress(grants[_id].s","contract":"TokenGrantStake","time":0},{"type":"immutable-restrict-modification ","before":" Gets grant ids ","after":" Gets grant ids ","contract":"TokenGrantStake","time":0},{"type":"external-function ","before":"ontract is not authorized.\"\n        );\n\n        // Expecting 60 bytes _extraData for stake delegation.\n        require(_extraData.length == 60, \"Stake delegation data must be provided.\");\n        address operator = _extraData.toAddress(20);\n\n        // Calculate available amount. Amount of unlocked tokens minus what user already withdrawn and staked.\n        require(_amount <= availableToStake(_id), \"Must have available granted amount to stake.\");\n\n        // Keep staking record.\n        TokenGrantStake grantStake = new TokenGrantStake(\n            address(token),\n            _id,\n            _stakingContract\n        );\n        grantStakes[operator] = grantStake;\n        granteesToOperators[grants[_id].grantee].push(operator);\n        grants[_id].staked += _amount;\n\n        token.transfer(address(grantStake), _amount);\n\n        // Staking contract expects 40 bytes _extraData for stake delegation.\n        // 20 bytes beneficiary's addr","after":"ontract is not authorized.\"\n        );\n\n        // Expecting 60 bytes _extraData for stake delegation.\n        require(_extraData.length == 60, \"Stake delegation data must be provided.\");\n        address operator = _extraData.toAddress(20);\n\n        // Calculate available amount. Amount of unlocked tokens minus what user already withdrawn and staked.\n        require(_amount <= availableToStake(_id), \"Must have available granted amount to stake.\");\n\n        // Keep staking record.\n        TokenGrantStake grantStake = new TokenGrantStake(\n            address(token),\n            _id,\n            _stakingContract\n        );\n        grantStakes[operator] = grantStake;\n        granteesToOperators[grants[_id].grantee].push(operator);\n        grants[_id].staked += _amount;\n\n        token.transfer(address(grantStake), _amount);\n\n        // Staking contract expects 40 bytes _extraData for stake delegation.\n        // 20 bytes beneficiary's addr","contract":"TokenStaking","time":0},{"type":"external-function ","before":"   TokenGrant _tokenGrant,\n        TokenStakingEscrow _escrow,\n        KeepRegistry _registry,\n        uint256 _initializationPeriod\n    ) Authorizations(_registry) public {\n        token = _token;\n        tokenGrant = _tokenGrant;\n        escrow = _escrow;\n        registry = _registry;\n        initializationPeriod = _initializationPeriod;\n        deployedAt = block.timestamp;\n    }\n\n    /// @notice Returns minimum amount of KEEP that allows sMPC cluster client to\n    /// participate in the Keep network. Expressed as number with 18-decimal places.\n    /// Initial minimum stake is higher than the final and lowered periodically based\n    /// on the amount of steps and the length of the minimum stake schedule in seconds.\n    function minimumStake() public view returns (uint256) {\n        return MinimumStakeSchedule.current(minimumStakeScheduleStart);\n    }\n\n    /// @notice Returns the current value of the undelegation period.\n    /// The staking contract guarantees that an undelegated operator’s stakes\n    /// will stay locked for a period of time after undelegation, and thus\n    /// available as collateral for any work the operator is engaged in.\n    /// The undelegation period is two weeks for the first two months and\n    /// two months after that.\n    function undelegationPeriod() public view returns (uint256) {\n        return block.timestamp < deployedAt.add(twoMonths) ? twoWeeks : twoMonths;\n    }\n\n    /// @notice Receives approval of token transfe","after":"   TokenGrant _tokenGrant,\n        TokenStakingEscrow _escrow,\n        KeepRegistry _registry,\n        uint256 _initializationPeriod\n    ) Authorizations(_registry) public {\n        token = _token;\n        tokenGrant = _tokenGrant;\n        escrow = _escrow;\n        registry = _registry;\n        initializationPeriod = _initializationPeriod;\n        deployedAt = block.timestamp;\n    }\n\n    /// @notice Returns minimum amount of KEEP that allows sMPC cluster client to\n    /// participate in the Keep network. Expressed as number with 18-decimal places.\n    /// Initial minimum stake is higher than the final and lowered periodically based\n    /// on the amount of steps and the length of the minimum stake schedule in seconds.\n    function minimumStake() public view returns (uint256) {\n        return MinimumStakeSchedule.current(minimumStakeScheduleStart);\n    }\n\n    /// @notice Returns the current value of the undelegation period.\n    /// The staking contract guarantees that an undelegated operator’s stakes\n    /// will stay locked for a period of time after undelegation, and thus\n    /// available as collateral for any work the operator is engaged in.\n    /// The undelegation period is two weeks for the first two months and\n    /// two months after that.\n    function undelegationPeriod() public view returns (uint256) {\n        return block.timestamp < deployedAt.add(twoMonths) ? twoWeeks : twoMonths;\n    }\n\n    /// @notice Receives approval of token transfe","contract":"TokenStaking","time":0},{"type":"external-function ","before":"op-up can not be cancelled so it is important to be careful with the\n    /// amount of KEEP added to the stake.\n    /// @dev Requires that the provided token contract be the same one linked to\n    /// this contract.\n    /// @param _from The owner of the tokens who approved them to transfer.\n    /// @param _value Approved amount for the transfer and stake.\n    /// @param _token Token contract address.\n    /// @param _extraData Data for stake delegation. This byte array must have\n    /// the following values concatenated:\n    /// - Beneficiary address (20 bytes), ignored for a top-up\n    /// - Operator address (20 bytes)\n    /// - Authorizer address (20 bytes), ignored for a top-up\n    /// - Grant ID (32 bytes) - required only when called by TokenStakingEscrow\n    function receiveApproval(\n        address _from,\n        uint256 _value,\n        address _token,\n        bytes memory _extraData\n    ) public {\n        require(ERC20Burnable(_token) == token, \"Unrecognized token\");\n        require(_extraData.length >= 60, \"Corrupted delegation data\");\n\n        // Transfer tokens to this contract.\n        token.safeTransferFrom(_from, address(this), _value);\n\n        address operator = _extraData.toAddress(20);\n        // See if there is an existing delegation for this operator...\n        if (operators[operator].packedParams.getCreationTimestamp() == 0) {\n            // If there is no existing delegation, delegate tokens using\n            // beneficiary and authorizer passed in _extraData.\n            delegate(_from, _value, operator, _extraData);\n        } else {\n            // If there is an existing delegation, top-up the stake.\n            topUp(_from, _value, operator, _extraData);\n        }\n    }\n\n","after":"op-up can not be cancelled so it is important to be careful with the\n    /// amount of KEEP added to the stake.\n    /// @dev Requires that the provided token contract be the same one linked to\n    /// this contract.\n    /// @param _from The owner of the tokens who approved them to transfer.\n    /// @param _value Approved amount for the transfer and stake.\n    /// @param _token Token contract address.\n    /// @param _extraData Data for stake delegation. This byte array must have\n    /// the following values concatenated:\n    /// - Beneficiary address (20 bytes), ignored for a top-up\n    /// - Operator address (20 bytes)\n    /// - Authorizer address (20 bytes), ignored for a top-up\n    /// - Grant ID (32 bytes) - required only when called by TokenStakingEscrow\n    function receiveApproval(\n        address _from,\n        uint256 _value,\n        address _token,\n        bytes memory _extraData\n    ) public {\n        require(ERC20Burnable(_token) == token, \"Unrecognized token\");\n        require(_extraData.length >= 60, \"Corrupted delegation data\");\n\n        // Transfer tokens to this contract.\n        token.safeTransferFrom(_from, address(this), _value);\n\n        address operator = _extraData.toAddress(20);\n        // See if there is an existing delegation for this operator...\n        if (operators[operator].packedParams.getCreationTimestamp() == 0) {\n            // If there is no existing delegation, delegate tokens using\n            // beneficiary and authorizer passed in _extraData.\n            delegate(_from, _value, operator, _extraData);\n        } else {\n            // If there is an existing delegation, top-up the stake.\n            topUp(_from, _value, operator, _extraData);\n        }\n    }\n\n","contract":"TokenStaking","time":0},{"type":"immutable-restrict-modification ","before":"    grant.cliff\n        );","after":"    grant.cliff\n        );","contract":"TokenStaking","time":1},{"type":"immutable-restrict-modification ","before":"}\n\n    /// @notice Calculates withdr","after":"}\n\n    /// @notice Calculates withdr","contract":"TokenStaking","time":1},{"type":"external-function ","before":"     \"Not authorized\"\n        );\n\n        uint256 operatorParams = operators[operator].packedParams;\n\n        require(\n            _isInitialized(operatorParams),\n            \"Inactive stake\"\n        );\n        require(\n            !_isUndelegating(operatorParams),\n            \"Undelegating stake\"\n        );\n\n        locks.lockStake(operator, duration);\n    }\n\n    /// @notice Removes a lock the caller had previously placed on the operator.\n    /// @dev Only for operator contracts.\n    /// To remove expired or ","after":"     \"Not authorized\"\n        );\n\n        uint256 operatorParams = operators[operator].packedParams;\n\n        require(\n            _isInitialized(operatorParams),\n            \"Inactive stake\"\n        );\n        require(\n            !_isUndelegating(operatorParams),\n            \"Undelegating stake\"\n        );\n\n        locks.lockStake(operator, duration);\n    }\n\n    /// @notice Removes a lock the caller had previously placed on the operator.\n    /// @dev Only for operator contracts.\n    /// To remove expired or ","contract":"TokenStakingEscrow","time":0},{"type":"external-function ","before":"   /// @notice Removes the lock of the specified operator contract\n    /// if the lock has expired or the contract has been disabled.\n    /// @dev Necessary for removing locks placed by contracts\n    /// that have been disabled by the panic button.\n    /// Also applicable to prevent inadvertent DoS of `recoverStake`\n    /// if too many operator contracts have failed to clean up their locks.\n    function releaseExpiredLock(\n        address operator,\n        address operatorContract\n    ) public {\n        locks.releaseExpiredLock(operator, operatorContract, address(this));\n    }\n\n    /// @notice Check whether the operator has any active locks\n    /// that haven't expired yet\n    /// and whose creators aren't disabled by the panic button.\n    function isStakeLocked(address operator) public view returns (bool) {\n        return locks.isStakeLocked(operator, address(this));\n    }\n\n    /// @notice Get the locks placed on the operator.\n    /// @return creators The addresses of operator contracts\n    /// that have placed a lock on the operator.\n    /// @return expirations The expiration times\n    /// of the locks placed on the operator.\n    function getLocks(address operato","after":"   /// @notice Removes the lock of the specified operator contract\n    /// if the lock has expired or the contract has been disabled.\n    /// @dev Necessary for removing locks placed by contracts\n    /// that have been disabled by the panic button.\n    /// Also applicable to prevent inadvertent DoS of `recoverStake`\n    /// if too many operator contracts have failed to clean up their locks.\n    function releaseExpiredLock(\n        address operator,\n        address operatorContract\n    ) public {\n        locks.releaseExpiredLock(operator, operatorContract, address(this));\n    }\n\n    /// @notice Check whether the operator has any active locks\n    /// that haven't expired yet\n    /// and whose creators aren't disabled by the panic button.\n    function isStakeLocked(address operator) public view returns (bool) {\n        return locks.isStakeLocked(operator, address(this));\n    }\n\n    /// @notice Get the locks placed on the operator.\n    /// @return creators The addresses of operator contracts\n    /// that have placed a lock on the operator.\n    /// @return expirations The expiration times\n    /// of the locks placed on the operator.\n    function getLocks(address operato","contract":"TokenStakingEscrow","time":0}]}