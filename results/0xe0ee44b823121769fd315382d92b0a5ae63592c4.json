{"time":127,"results":[{"type":"state-data-arrangement ","before":"\nstring public _FILTER_NAME_;\naddress public _NFT_COLLECTION_;\nuint256 public _NFT_ID_START_;\nuint256 public _NFT_ID_END_ = uint256(- 1);\nmapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\nmapping(uint256 => uint256) public _NFT_RESERVE_;\nuint256[] public _NFT_IDS_;\nmapping(uint256 => uint256) public _TOKENID_IDX_;\nuint256 public _TOTAL_NFT_AMOUNT_;\nuint256 public _MAX_NFT_AMOUNT_;\nuint256 public _MIN_NFT_AMOUNT_;\nuint256 public _GS_START_IN_;\nuint256 public _CR_IN_;\nbool public _NFT_IN_TOGGLE_ = false;\nuint256 public _GS_START_RANDOM_OUT_;\nuint256 public _CR_RANDOM_OUT_;\nbool public _NFT_RANDOM_OUT_TOGGLE_ = false;\nuint256 public _GS_START_TARGET_OUT_;\nuint256 public _CR_TARGET_OUT_;\nbool public _NFT_TARGET_OUT_TOGGLE_ = false;","after":"string public _FILTER_NAME_;\nuint256 public _NFT_ID_START_;\nuint256 public _NFT_ID_END_ = uint256(- 1);\nmapping(uint256 => bool) public _SPREAD_IDS_REGISTRY_;\nmapping(uint256 => uint256) public _NFT_RESERVE_;\nuint256[] public _NFT_IDS_;\nmapping(uint256 => uint256) public _TOKENID_IDX_;\nuint256 public _TOTAL_NFT_AMOUNT_;\nuint256 public _MAX_NFT_AMOUNT_;\nuint256 public _MIN_NFT_AMOUNT_;\nuint256 public _GS_START_IN_;\nuint256 public _CR_IN_;\nuint256 public _GS_START_RANDOM_OUT_;\nuint256 public _CR_RANDOM_OUT_;\nuint256 public _GS_START_TARGET_OUT_;\nuint256 public _CR_TARGET_OUT_;\naddress public _NFT_COLLECTION_;\nbool public _NFT_IN_TOGGLE_ = false;\nbool public _NFT_RANDOM_OUT_TOGGLE_ = false;\nbool public _NFT_TARGET_OUT_TOGGLE_ = false;\n","contract":"BaseFilterV1","time":0},{"type":"loop-calculation","before":"uint256 index = _getRandomNum() % _NFT_IDS_.length;","after":"// move outside for loop\nuint256 index = _getRandomNum() % _NFT_IDS_.length;","loc":{"start":{"line":1678,"column":12},"end":{"line":1678,"column":62}},"contract":"FilterERC721V1","time":0},{"type":"loop-calculation","before":"uint256 tokenId = _NFT_IDS_[index];","after":"// move outside for loop\nuint256 tokenId = _NFT_IDS_[index];","loc":{"start":{"line":1680,"column":12},"end":{"line":1680,"column":46}},"contract":"FilterERC721V1","time":0},{"type":"external-function ","before":"function init(\n\n        address filterAdmin,\n\n        address nftCollection,\n\n        bool[] memory toggles,\n\n        string memory filterName,\n\n        uint256[] memory numParams, //0 - startId, 1 - endId, 2 - maxAmount, 3 - minAmount\n\n        uint256[] memory priceRules,\n\n        uint256[] memory spreadIds\n\n    ) external {\n\n        initOwner(filterAdmin);\n\n\n        _changeFilterName(filterName);\n\n        _NFT_COLLECTION_ = nftCollection;\n\n        _changeNFTInPrice(priceRules[0], priceRules[1], toggles[0]);\n\n        _changeNFTRandomOutPrice(priceRules[2], priceRules[3], toggles[1]);\n\n        _changeNFTTargetOutPrice(priceRules[4], priceRules[5], toggles[2]);\n\n\n        _changeNFTAmountRange(numParams[2], numParams[3]);\n\n\n        _changeTokenIdRange(numParams[0], numParams[1]);\n\n        for (uint256 i = 0; i < spreadIds.length; i++) {\n\n            _SPREAD_IDS_REGISTRY_[spreadIds[i]] = true;\n\n            emit ChangeTokenIdMap(spreadIds[i], true);\n\n        }\n\n\n        emit FilterInit(filterAdmin, nftCollection, filterName);\n\n    }","after":"function init(\n\n        address filterAdmin,\n\n        address nftCollection,\n\n        bool[] calldata toggles,\n\n        string calldata filterName,\n\n        uint256[] calldata numParams, //0 - startId, 1 - endId, 2 - maxAmount, 3 - minAmount\n\n        uint256[] calldata priceRules,\n\n        uint256[] calldata spreadIds\n\n    ) external {\n\n        initOwner(filterAdmin);\n\n\n        _changeFilterName(filterName);\n\n        _NFT_COLLECTION_ = nftCollection;\n\n        _changeNFTInPrice(priceRules[0], priceRules[1], toggles[0]);\n\n        _changeNFTRandomOutPrice(priceRules[2], priceRules[3], toggles[1]);\n\n        _changeNFTTargetOutPrice(priceRules[4], priceRules[5], toggles[2]);\n\n\n        _changeNFTAmountRange(numParams[2], numParams[3]);\n\n\n        _changeTokenIdRange(numParams[0], numParams[1]);\n\n        for (uint256 i = 0; i < spreadIds.length; i++) {\n\n            _SPREAD_IDS_REGISTRY_[spreadIds[i]] = true;\n\n            emit ChangeTokenIdMap(spreadIds[i], true);\n\n        }\n\n\n        emit FilterInit(filterAdmin, nftCollection, filterName);\n\n    }","contract":"FilterERC721V1","time":1},{"type":"external-function ","before":"function ERC721In(uint256[] memory tokenIds, address to)\n\n    external\n\n    preventReentrant\n\n    returns (uint256 received)\n\n    {\n\n        require(tokenIds.length <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n\n        uint256 originTotalNftAmount = _TOTAL_NFT_AMOUNT_;\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n\n            uint256 tokenId = tokenIds[i];\n\n            require(isNFTIDValid(tokenId), \"NFT_ID_NOT_SUPPORT\");\n\n            require(\n\n                _NFT_RESERVE_[tokenId] == 0 &&\n\n                IERC721(_NFT_COLLECTION_).ownerOf(tokenId) == address(this),\n\n                \"NFT_NOT_SEND\"\n\n            );\n\n            _NFT_IDS_.push(tokenId);\n\n            _TOKENID_IDX_[tokenId] = _NFT_IDS_.length;\n\n            _NFT_RESERVE_[tokenId] = 1;\n\n\n            emit NftIn(tokenId);\n\n        }\n\n        _TOTAL_NFT_AMOUNT_ = _NFT_IDS_.length;\n\n        (uint256 rawReceive,) = _queryNFTIn(originTotalNftAmount, originTotalNftAmount + tokenIds.length);\n\n        received = IFilterAdmin(_OWNER_).mintFragTo(to, rawReceive);\n\n\n        emit NftInOrder(to, received);\n\n    }","after":"function ERC721In(uint256[] calldata tokenIds, address to)\n\n    external\n\n    preventReentrant\n\n    returns (uint256 received)\n\n    {\n\n        require(tokenIds.length <= getAvaliableNFTInAmount(), \"EXCEDD_IN_AMOUNT\");\n\n        uint256 originTotalNftAmount = _TOTAL_NFT_AMOUNT_;\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n\n            uint256 tokenId = tokenIds[i];\n\n            require(isNFTIDValid(tokenId), \"NFT_ID_NOT_SUPPORT\");\n\n            require(\n\n                _NFT_RESERVE_[tokenId] == 0 &&\n\n                IERC721(_NFT_COLLECTION_).ownerOf(tokenId) == address(this),\n\n                \"NFT_NOT_SEND\"\n\n            );\n\n            _NFT_IDS_.push(tokenId);\n\n            _TOKENID_IDX_[tokenId] = _NFT_IDS_.length;\n\n            _NFT_RESERVE_[tokenId] = 1;\n\n\n            emit NftIn(tokenId);\n\n        }\n\n        _TOTAL_NFT_AMOUNT_ = _NFT_IDS_.length;\n\n        (uint256 rawReceive,) = _queryNFTIn(originTotalNftAmount, originTotalNftAmount + tokenIds.length);\n\n        received = IFilterAdmin(_OWNER_).mintFragTo(to, rawReceive);\n\n\n        emit NftInOrder(to, received);\n\n    }","contract":"FilterERC721V1","time":0},{"type":"external-function ","before":"function ERC721TargetOut(uint256[] memory tokenIds, address to, uint256 maxBurnAmount)\n\n    external\n\n    preventReentrant\n\n    returns (uint256 paid)\n\n    {\n\n        (uint256 rawPay,) = queryNFTTargetOut(tokenIds.length);\n\n        paid = IFilterAdmin(_OWNER_).burnFragFrom(msg.sender, rawPay);\n\n        require(paid <= maxBurnAmount, \"BURN_AMOUNT_EXCEED\");\n\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n\n            _transferOutERC721(to, tokenIds[i]);\n\n\n            emit TargetOut(tokenIds[i]);\n\n        }\n\n        _TOTAL_NFT_AMOUNT_ = _NFT_IDS_.length;\n\n\n        emit TargetOutOrder(msg.sender, paid);\n\n    }","after":"function ERC721TargetOut(uint256[] calldata tokenIds, address to, uint256 maxBurnAmount)\n\n    external\n\n    preventReentrant\n\n    returns (uint256 paid)\n\n    {\n\n        (uint256 rawPay,) = queryNFTTargetOut(tokenIds.length);\n\n        paid = IFilterAdmin(_OWNER_).burnFragFrom(msg.sender, rawPay);\n\n        require(paid <= maxBurnAmount, \"BURN_AMOUNT_EXCEED\");\n\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n\n            _transferOutERC721(to, tokenIds[i]);\n\n\n            emit TargetOut(tokenIds[i]);\n\n        }\n\n        _TOTAL_NFT_AMOUNT_ = _NFT_IDS_.length;\n\n\n        emit TargetOutOrder(msg.sender, paid);\n\n    }","contract":"FilterERC721V1","time":0},{"type":"external-function ","before":"function emergencyWithdraw(\n\n        address[] memory nftContract,\n\n        uint256[] memory tokenIds,\n\n        address to\n\n    ) external onlySuperOwner {\n\n        require(nftContract.length == tokenIds.length, \"PARAM_INVALID\");\n\n        address controller = IFilterAdmin(_OWNER_)._CONTROLLER_();\n\n        require(\n\n            IController(controller).isEmergencyWithdrawOpen(address(this)),\n\n            \"EMERGENCY_WITHDRAW_NOT_OPEN\"\n\n        );\n\n\n        for (uint256 i = 0; i < nftContract.length; i++) {\n\n            uint256 tokenId = tokenIds[i];\n\n            if (_NFT_RESERVE_[tokenId] > 0 && nftContract[i] == _NFT_COLLECTION_) {\n\n                uint256 index = getNFTIndexById(tokenId);\n\n                if (index != _NFT_IDS_.length - 1) {\n\n                    uint256 lastTokenId = _NFT_IDS_[_NFT_IDS_.length - 1];\n\n                    _NFT_IDS_[index] = lastTokenId;\n\n                    _TOKENID_IDX_[lastTokenId] = index + 1;\n\n                }\n\n                _NFT_IDS_.pop();\n\n                _NFT_RESERVE_[tokenId] = 0;\n\n                _TOKENID_IDX_[tokenId] = 0;\n\n            }\n\n            IERC721(nftContract[i]).safeTransferFrom(address(this), to, tokenIds[i]);\n\n            emit EmergencyWithdraw(nftContract[i], tokenIds[i], to);\n\n        }\n\n        _TOTAL_NFT_AMOUNT_ = _NFT_IDS_.length;\n\n    }","after":"function emergencyWithdraw(\n\n        address[] calldata nftContract,\n\n        uint256[] calldata tokenIds,\n\n        address to\n\n    ) external onlySuperOwner {\n\n        require(nftContract.length == tokenIds.length, \"PARAM_INVALID\");\n\n        address controller = IFilterAdmin(_OWNER_)._CONTROLLER_();\n\n        require(\n\n            IController(controller).isEmergencyWithdrawOpen(address(this)),\n\n            \"EMERGENCY_WITHDRAW_NOT_OPEN\"\n\n        );\n\n\n        for (uint256 i = 0; i < nftContract.length; i++) {\n\n            uint256 tokenId = tokenIds[i];\n\n            if (_NFT_RESERVE_[tokenId] > 0 && nftContract[i] == _NFT_COLLECTION_) {\n\n                uint256 index = getNFTIndexById(tokenId);\n\n                if (index != _NFT_IDS_.length - 1) {\n\n                    uint256 lastTokenId = _NFT_IDS_[_NFT_IDS_.length - 1];\n\n                    _NFT_IDS_[index] = lastTokenId;\n\n                    _TOKENID_IDX_[lastTokenId] = index + 1;\n\n                }\n\n                _NFT_IDS_.pop();\n\n                _NFT_RESERVE_[tokenId] = 0;\n\n                _TOKENID_IDX_[tokenId] = 0;\n\n            }\n\n            IERC721(nftContract[i]).safeTransferFrom(address(this), to, tokenIds[i]);\n\n            emit EmergencyWithdraw(nftContract[i], tokenIds[i], to);\n\n        }\n\n        _TOTAL_NFT_AMOUNT_ = _NFT_IDS_.length;\n\n    }","contract":"FilterERC721V1","time":0},{"type":"external-function ","before":"function changeTokenIdMap(uint256[] memory tokenIds, bool[] memory isRegistered)\n\n    external\n\n    onlySuperOwner\n\n    {\n\n        _changeTokenIdMap(tokenIds, isRegistered);\n\n    }","after":"function changeTokenIdMap(uint256[] calldata tokenIds, bool[] calldata isRegistered)\n\n    external\n\n    onlySuperOwner\n\n    {\n\n        _changeTokenIdMap(tokenIds, isRegistered);\n\n    }","contract":"FilterERC721V1","time":0},{"type":"external-function ","before":"function changeFilterName(string memory newFilterName)\n\n    external\n\n    onlySuperOwner\n\n    {\n\n        _changeFilterName(newFilterName);\n\n    }","after":"function changeFilterName(string calldata newFilterName)\n\n    external\n\n    onlySuperOwner\n\n    {\n\n        _changeFilterName(newFilterName);\n\n    }","contract":"FilterERC721V1","time":0},{"type":"external-function ","before":"function resetFilter(\n\n        string memory filterName,\n\n        bool[] memory toggles,\n\n        uint256[] memory numParams, //0 - startId, 1 - endId, 2 - maxAmount, 3 - minAmount\n\n        uint256[] memory priceRules,\n\n        uint256[] memory spreadIds,\n\n        bool[] memory isRegistered\n\n    ) external onlySuperOwner {\n\n        _changeFilterName(filterName);\n\n        _changeNFTInPrice(priceRules[0], priceRules[1], toggles[0]);\n\n        _changeNFTRandomOutPrice(priceRules[2], priceRules[3], toggles[1]);\n\n        _changeNFTTargetOutPrice(priceRules[4], priceRules[5], toggles[2]);\n\n\n        _changeNFTAmountRange(numParams[2], numParams[3]);\n\n        _changeTokenIdRange(numParams[0], numParams[1]);\n\n\n        _changeTokenIdMap(spreadIds, isRegistered);\n\n    }","after":"function resetFilter(\n\n        string calldata filterName,\n\n        bool[] calldata toggles,\n\n        uint256[] calldata numParams, //0 - startId, 1 - endId, 2 - maxAmount, 3 - minAmount\n\n        uint256[] calldata priceRules,\n\n        uint256[] calldata spreadIds,\n\n        bool[] calldata isRegistered\n\n    ) external onlySuperOwner {\n\n        _changeFilterName(filterName);\n\n        _changeNFTInPrice(priceRules[0], priceRules[1], toggles[0]);\n\n        _changeNFTRandomOutPrice(priceRules[2], priceRules[3], toggles[1]);\n\n        _changeNFTTargetOutPrice(priceRules[4], priceRules[5], toggles[2]);\n\n\n        _changeNFTAmountRange(numParams[2], numParams[3]);\n\n        _changeTokenIdRange(numParams[0], numParams[1]);\n\n\n        _changeTokenIdMap(spreadIds, isRegistered);\n\n    }","contract":"FilterERC721V1","time":0}]}