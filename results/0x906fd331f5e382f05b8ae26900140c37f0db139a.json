{"time":1482,"results":[{"type":"external-function ","before":"function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setTradeMakerFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeMakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeMakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setTradeTakerFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        tradeTakerFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetTradeTakerFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","after":"function setPaymentFee(uint256 fromBlockNumber, int256 nominal, int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        paymentFeeByBlockNumber.addDiscountedEntry(fromBlockNumber, nominal, discountTiers, discountValues);\n        emit SetPaymentFeeEvent(fromBlockNumber, nominal, discountTiers, discountValues);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] memory discountTiers, int256[] memory discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }","after":"function setCurrencyPaymentFee(uint256 fromBlockNumber, address currencyCt, uint256 currencyId, int256 nominal,\n        int256[] calldata discountTiers, int256[] calldata discountValues)\n    public\n    onlyOperator\n    onlyDelayedBlockNumber(fromBlockNumber)\n    {\n        currencyPaymentFeeByBlockNumber[currencyCt][currencyId].addDiscountedEntry(\n            fromBlockNumber, nominal, discountTiers, discountValues\n        );\n        emit SetCurrencyPaymentFeeEvent(\n            fromBlockNumber, currencyCt, currencyId, nominal, discountTiers, discountValues\n        );\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"Configuration","time":0},{"type":"external-function ","before":"function hashPaymentAsWallet(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 amountCurrencyHash = hashPaymentAmountCurrency(payment);\n        bytes32 senderHash = hashPaymentSenderPartyAsWallet(payment.sender);\n        bytes32 recipientHash = hashAddress(payment.recipient.wallet);\n\n        return keccak256(abi.encodePacked(amountCurrencyHash, senderHash, recipientHash));\n    }","after":"function hashPaymentAsWallet(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 amountCurrencyHash = hashPaymentAmountCurrency(payment);\n        bytes32 senderHash = hashPaymentSenderPartyAsWallet(payment.sender);\n        bytes32 recipientHash = hashAddress(payment.recipient.wallet);\n\n        return keccak256(abi.encodePacked(amountCurrencyHash, senderHash, recipientHash));\n    }","contract":"PaymentHasher","time":0},{"type":"external-function ","before":"function hashPaymentAsOperator(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 walletSignatureHash = hashSignature(payment.seals.wallet.signature);\n        bytes32 senderHash = hashPaymentSenderPartyAsOperator(payment.sender);\n        bytes32 recipientHash = hashPaymentRecipientPartyAsOperator(payment.recipient);\n        bytes32 transfersHash = hashSingleTotalInt256(payment.transfers);\n        bytes32 operatorHash = hashString(payment.operator.data);\n\n        return keccak256(abi.encodePacked(\n                walletSignatureHash, senderHash, recipientHash, transfersHash, operatorHash\n            ));\n    }","after":"function hashPaymentAsOperator(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bytes32)\n    {\n        bytes32 walletSignatureHash = hashSignature(payment.seals.wallet.signature);\n        bytes32 senderHash = hashPaymentSenderPartyAsOperator(payment.sender);\n        bytes32 recipientHash = hashPaymentRecipientPartyAsOperator(payment.recipient);\n        bytes32 transfersHash = hashSingleTotalInt256(payment.transfers);\n        bytes32 operatorHash = hashString(payment.operator.data);\n\n        return keccak256(abi.encodePacked(\n                walletSignatureHash, senderHash, recipientHash, transfersHash, operatorHash\n            ));\n    }","contract":"PaymentHasher","time":0},{"type":"external-function ","before":"function isGenuinePaymentSeals(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentWalletSeal(payment) && isGenuinePaymentOperatorSeal(payment);\n    }","after":"function isGenuinePaymentSeals(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        return isGenuinePaymentWalletSeal(payment) && isGenuinePaymentOperatorSeal(payment);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentFeeOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        int256 feePartsPer = int256(ConstantsLib.PARTS_PER());\n\n        int256 feeAmount = payment.amount\n        .mul(\n            configuration.currencyPaymentFee(\n                payment.blockNumber, payment.currency.ct, payment.currency.id, payment.amount\n            )\n        ).div(feePartsPer);\n\n        if (1 > feeAmount)\n            feeAmount = 1;\n\n        return (payment.sender.fees.single.amount == feeAmount);\n    }","after":"function isGenuinePaymentFeeOfFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        int256 feePartsPer = int256(ConstantsLib.PARTS_PER());\n\n        int256 feeAmount = payment.amount\n        .mul(\n            configuration.currencyPaymentFee(\n                payment.blockNumber, payment.currency.ct, payment.currency.id, payment.amount\n            )\n        ).div(feePartsPer);\n\n        if (1 > feeAmount)\n            feeAmount = 1;\n\n        return (payment.sender.fees.single.amount == feeAmount);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentFeeOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        (address feeCurrencyCt, uint256 feeCurrencyId) = configuration.feeCurrency(\n            payment.blockNumber, payment.currency.ct, payment.currency.id\n        );\n\n        return feeCurrencyCt == payment.sender.fees.single.currency.ct\n        && feeCurrencyId == payment.sender.fees.single.currency.id;\n    }","after":"function isGenuinePaymentFeeOfNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        (address feeCurrencyCt, uint256 feeCurrencyId) = configuration.feeCurrency(\n            payment.blockNumber, payment.currency.ct, payment.currency.id\n        );\n\n        return feeCurrencyCt == payment.sender.fees.single.currency.ct\n        && feeCurrencyId == payment.sender.fees.single.currency.id;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentSenderOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet))\n        && (payment.sender.balances.current == payment.sender.balances.previous.sub(payment.transfers.single).sub(payment.sender.fees.single.amount));\n    }","after":"function isGenuinePaymentSenderOfFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet))\n        && (payment.sender.balances.current == payment.sender.balances.previous.sub(payment.transfers.single).sub(payment.sender.fees.single.amount));\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentRecipientOfFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (payment.recipient.balances.current == payment.recipient.balances.previous.add(payment.transfers.single));\n    }","after":"function isGenuinePaymentRecipientOfFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (payment.recipient.balances.current == payment.recipient.balances.previous.add(payment.transfers.single));\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentSenderOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet));\n    }","after":"function isGenuinePaymentSenderOfNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    view\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet)\n        && (!signerManager.isSigner(payment.sender.wallet));\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuinePaymentRecipientOfNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet);\n    }","after":"function isGenuinePaymentRecipientOfNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bool)\n    {\n        return (payment.sender.wallet != payment.recipient.wallet);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isSuccessivePaymentsPartyNonces(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment memory lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole\n    )\n    public\n    pure\n    returns (bool)\n    {\n        uint256 firstNonce = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.nonce : firstPayment.recipient.nonce);\n        uint256 lastNonce = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.nonce : lastPayment.recipient.nonce);\n        return lastNonce == firstNonce.add(1);\n    }","after":"function isSuccessivePaymentsPartyNonces(\n        PaymentTypesLib.Payment calldata firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment calldata lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole\n    )\n    public\n    pure\n    returns (bool)\n    {\n        uint256 firstNonce = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.nonce : firstPayment.recipient.nonce);\n        uint256 lastNonce = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.nonce : lastPayment.recipient.nonce);\n        return lastNonce == firstNonce.add(1);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuineSuccessivePaymentsBalances(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment memory lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole,\n        int256 delta\n    )\n    public\n    pure\n    returns (bool)\n    {\n        NahmiiTypesLib.CurrentPreviousInt256 memory firstCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.balances : firstPayment.recipient.balances);\n        NahmiiTypesLib.CurrentPreviousInt256 memory lastCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.balances : lastPayment.recipient.balances);\n\n        return lastCurrentPreviousBalances.previous == firstCurrentPreviousBalances.current.add(delta);\n    }","after":"function isGenuineSuccessivePaymentsBalances(\n        PaymentTypesLib.Payment calldata firstPayment,\n        PaymentTypesLib.PaymentPartyRole firstPaymentPartyRole,\n        PaymentTypesLib.Payment calldata lastPayment,\n        PaymentTypesLib.PaymentPartyRole lastPaymentPartyRole,\n        int256 delta\n    )\n    public\n    pure\n    returns (bool)\n    {\n        NahmiiTypesLib.CurrentPreviousInt256 memory firstCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == firstPaymentPartyRole ? firstPayment.sender.balances : firstPayment.recipient.balances);\n        NahmiiTypesLib.CurrentPreviousInt256 memory lastCurrentPreviousBalances = (PaymentTypesLib.PaymentPartyRole.Sender == lastPaymentPartyRole ? lastPayment.sender.balances : lastPayment.recipient.balances);\n\n        return lastCurrentPreviousBalances.previous == firstCurrentPreviousBalances.current.add(delta);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isGenuineSuccessivePaymentsTotalFees(\n        PaymentTypesLib.Payment memory firstPayment,\n        PaymentTypesLib.Payment memory lastPayment\n    )\n    public\n    pure\n    returns (bool)\n    {\n        MonetaryTypesLib.Figure memory firstTotalFee = getProtocolFigureByCurrency(firstPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        MonetaryTypesLib.Figure memory lastTotalFee = getProtocolFigureByCurrency(lastPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        return lastTotalFee.amount == firstTotalFee.amount.add(lastPayment.sender.fees.single.amount);\n    }","after":"function isGenuineSuccessivePaymentsTotalFees(\n        PaymentTypesLib.Payment calldata firstPayment,\n        PaymentTypesLib.Payment calldata lastPayment\n    )\n    public\n    pure\n    returns (bool)\n    {\n        MonetaryTypesLib.Figure memory firstTotalFee = getProtocolFigureByCurrency(firstPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        MonetaryTypesLib.Figure memory lastTotalFee = getProtocolFigureByCurrency(lastPayment.sender.fees.total, lastPayment.sender.fees.single.currency);\n        return lastTotalFee.amount == firstTotalFee.amount.add(lastPayment.sender.fees.single.amount);\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentParty(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet || wallet == payment.recipient.wallet;\n    }","after":"function isPaymentParty(PaymentTypesLib.Payment calldata payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet || wallet == payment.recipient.wallet;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentSender(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet;\n    }","after":"function isPaymentSender(PaymentTypesLib.Payment calldata payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.sender.wallet;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentRecipient(PaymentTypesLib.Payment memory payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.recipient.wallet;\n    }","after":"function isPaymentRecipient(PaymentTypesLib.Payment calldata payment, address wallet)\n    public\n    pure\n    returns (bool)\n    {\n        return wallet == payment.recipient.wallet;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentCurrency(PaymentTypesLib.Payment memory payment, MonetaryTypesLib.Currency memory currency)\n    public\n    pure\n    returns (bool)\n    {\n        return currency.ct == payment.currency.ct && currency.id == payment.currency.id;\n    }","after":"function isPaymentCurrency(PaymentTypesLib.Payment calldata payment, MonetaryTypesLib.Currency calldata currency)\n    public\n    pure\n    returns (bool)\n    {\n        return currency.ct == payment.currency.ct && currency.id == payment.currency.id;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function isPaymentCurrencyNonFungible(PaymentTypesLib.Payment memory payment)\n    public\n    pure\n    returns (bool)\n    {\n        return payment.currency.ct != payment.sender.fees.single.currency.ct\n        || payment.currency.id != payment.sender.fees.single.currency.id;\n    }","after":"function isPaymentCurrencyNonFungible(PaymentTypesLib.Payment calldata payment)\n    public\n    pure\n    returns (bool)\n    {\n        return payment.currency.ct != payment.sender.fees.single.currency.ct\n        || payment.currency.id != payment.sender.fees.single.currency.id;\n    }","contract":"Validator","time":0},{"type":"external-function ","before":"function lockNonFungibleByProxy(address lockedWallet, address lockerWallet, int256[] memory ids,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n\n        require(lockedWallet != lockerWallet);\n\n\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n\n        require(\n            (0 == lockIndex) ||\n            (block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n        );\n\n\n        if (0 == lockIndex) {\n            lockIndex = ++(walletNonFungibleLocks[lockedWallet].length);\n            lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\n            walletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n        }\n\n\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids = ids;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\n        block.timestamp.add(visibleTimeoutInSeconds);\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\n        block.timestamp.add(configuration.walletLockTimeout());\n\n\n        emit LockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId, visibleTimeoutInSeconds);\n    }","after":"function lockNonFungibleByProxy(address lockedWallet, address lockerWallet, int256[] calldata ids,\n        address currencyCt, uint256 currencyId, uint256 visibleTimeoutInSeconds)\n    public\n    onlyAuthorizedService(lockedWallet)\n    {\n\n        require(lockedWallet != lockerWallet);\n\n\n        uint256 lockIndex = lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockedWallet];\n\n\n        require(\n            (0 == lockIndex) ||\n            (block.timestamp >= walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime)\n        );\n\n\n        if (0 == lockIndex) {\n            lockIndex = ++(walletNonFungibleLocks[lockedWallet].length);\n            lockedCurrencyLockerNonFungibleLockIndex[lockedWallet][currencyCt][currencyId][lockerWallet] = lockIndex;\n            walletCurrencyNonFungibleLockCount[lockedWallet][currencyCt][currencyId]++;\n        }\n\n\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].locker = lockerWallet;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].ids = ids;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyCt = currencyCt;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].currencyId = currencyId;\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].visibleTime =\n        block.timestamp.add(visibleTimeoutInSeconds);\n        walletNonFungibleLocks[lockedWallet][lockIndex - 1].unlockTime =\n        block.timestamp.add(configuration.walletLockTimeout());\n\n\n        emit LockNonFungibleByProxyEvent(lockedWallet, lockerWallet, ids, currencyCt, currencyId, visibleTimeoutInSeconds);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function authorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        require(!initialServiceAuthorizedMap[service]);\n\n\n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n\n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","after":"function authorizeRegisteredServiceAction(address service, string calldata action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        require(!initialServiceAuthorizedMap[service]);\n\n\n        serviceWalletAuthorizedMap[service][msg.sender] = false;\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = true;\n        if (!serviceActionWalletTouchedMap[service][actionHash][msg.sender]) {\n            serviceActionWalletTouchedMap[service][actionHash][msg.sender] = true;\n            serviceWalletActionList[service][msg.sender].push(actionHash);\n        }\n\n\n        emit AuthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function unauthorizeRegisteredServiceAction(address service, string memory action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        require(!initialServiceAuthorizedMap[service]);\n\n\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n\n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","after":"function unauthorizeRegisteredServiceAction(address service, string calldata action)\n    public\n    notNullOrThisAddress(service)\n    {\n        require(msg.sender != service);\n\n        bytes32 actionHash = hashString(action);\n\n\n        require(registeredServicesMap[service].registered && registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n\n        require(!initialServiceAuthorizedMap[service]);\n\n\n        serviceActionWalletAuthorizedMap[service][actionHash][msg.sender] = false;\n\n\n        emit UnauthorizeRegisteredServiceActionEvent(msg.sender, service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function isAuthorizedRegisteredServiceAction(address service, string memory action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }","after":"function isAuthorizedRegisteredServiceAction(address service, string calldata action, address wallet)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n\n        return isEnabledServiceAction(service, action) &&\n        (\n        isInitialServiceAuthorizedForWallet(service, wallet) ||\n        serviceWalletAuthorizedMap[service][wallet] ||\n        serviceActionWalletAuthorizedMap[service][actionHash][wallet]\n        );\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"WalletLocker","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"WalletLocker","time":0},{"type":"loop-duplication","before":"\nstart line 3757 column 8, end line 3758 column 103\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\nstart line 3762 column 8, end line 3763 column 107\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = i + 1;","after":"// merge loop\n\nstart line 3757 column 8, end line 3758 column 103\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = 0;\nstart line 3762 column 8, end line 3763 column 107\nfor (i = 0; i < self.idsByCurrency[currencyCt][currencyId].length; i++)\n            self.idIndexById[currencyCt][currencyId][self.idsByCurrency[currencyCt][currencyId][i]] = i + 1;","contract":"NonFungibleBalanceLib","time":0},{"type":"external-function ","before":"function setIds(address wallet, bytes32 _type, int256[] memory ids, address currencyCt, uint256 currencyId)\n    public\n    onlyActiveService\n    {\n\n        walletMap[wallet].nonFungibleBalanceByType[_type].set(\n            ids, currencyCt, currencyId\n        );\n\n\n        _updateTrackedBalanceTypes(_type);\n\n\n        _updateTrackedWallets(wallet);\n    }","after":"function setIds(address wallet, bytes32 _type, int256[] calldata ids, address currencyCt, uint256 currencyId)\n    public\n    onlyActiveService\n    {\n\n        walletMap[wallet].nonFungibleBalanceByType[_type].set(\n            ids, currencyCt, currencyId\n        );\n\n\n        _updateTrackedBalanceTypes(_type);\n\n\n        _updateTrackedWallets(wallet);\n    }","contract":"BalanceTracker","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"BalanceTracker","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"BalanceTracker","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"BalanceTracker","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public depositedBalanceType;","after":"bytes32 public immutable depositedBalanceType;","contract":"BalanceTracker","time":2},{"type":"immutable-restrict-modification ","before":"bytes32 public settledBalanceType;","after":"bytes32 public immutable settledBalanceType;","contract":"BalanceTracker","time":2},{"type":"immutable-restrict-modification ","before":"bytes32 public stagedBalanceType;","after":"bytes32 public immutable stagedBalanceType;","contract":"BalanceTracker","time":2},{"type":"external-function ","before":"function transferController(address currencyCt, string memory standard)\npublic\nview\nreturns (TransferController)\n{\nif (bytes(standard).length > 0) {\nbytes32 standardHash = keccak256(abi.encodePacked(standard));\n\nrequire(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\nreturn TransferController(registeredTransferControllers[standardHash]);\n}\n\nrequire(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\nrequire(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\naddress controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\nrequire(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\nreturn TransferController(controllerAddress);\n}","after":"function transferController(address currencyCt, string calldata standard)\npublic\nview\nreturns (TransferController)\n{\nif (bytes(standard).length > 0) {\nbytes32 standardHash = keccak256(abi.encodePacked(standard));\n\nrequire(registeredTransferControllers[standardHash] != address(0), \"Standard not registered [TransferControllerManager.sol:150]\");\nreturn TransferController(registeredTransferControllers[standardHash]);\n}\n\nrequire(registeredCurrencies[currencyCt].standard != bytes32(0), \"Currency not registered [TransferControllerManager.sol:154]\");\nrequire(!registeredCurrencies[currencyCt].blacklisted, \"Currency blacklisted [TransferControllerManager.sol:155]\");\n\naddress controllerAddress = registeredTransferControllers[registeredCurrencies[currencyCt].standard];\nrequire(controllerAddress != address(0), \"No matching transfer controller [TransferControllerManager.sol:158]\");\n\nreturn TransferController(controllerAddress);\n}","contract":"TransferControllerManager","time":0},{"type":"external-function ","before":"function receiveTokens(string memory, int256 amount, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\nreceiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n}","after":"function receiveTokens(string calldata, int256 amount, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\nreceiveTokensTo(msg.sender, \"\", amount, currencyCt, currencyId, standard);\n}","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function claimAndTransferToBeneficiary(Beneficiary beneficiary, string memory balanceType, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\n\nint256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n\ndeposited.sub(claimedAmount, currencyCt, currencyId);\n\n\nif (address(0) == currencyCt && 0 == currencyId)\nbeneficiary.receiveEthersTo.value(uint256(claimedAmount))(msg.sender, balanceType);\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\n)\n);\nrequire(success, \"Approval by controller failed [SecurityBond.sol:350]\");\nbeneficiary.receiveTokensTo(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}\n\n\nemit ClaimAndTransferToBeneficiaryEvent(msg.sender, beneficiary, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}","after":"function claimAndTransferToBeneficiary(Beneficiary beneficiary, string calldata balanceType, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\n\nint256 claimedAmount = _claim(msg.sender, currencyCt, currencyId);\n\n\ndeposited.sub(claimedAmount, currencyCt, currencyId);\n\n\nif (address(0) == currencyCt && 0 == currencyId)\nbeneficiary.receiveEthersTo.value(uint256(claimedAmount))(msg.sender, balanceType);\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(claimedAmount), currencyCt, currencyId\n)\n);\nrequire(success, \"Approval by controller failed [SecurityBond.sol:350]\");\nbeneficiary.receiveTokensTo(msg.sender, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}\n\n\nemit ClaimAndTransferToBeneficiaryEvent(msg.sender, beneficiary, balanceType, claimedAmount, currencyCt, currencyId, standard);\n}","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\n\nrequire(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [SecurityBond.sol:386]\");\n\n\namount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n\nstagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Dispatch by controller failed [SecurityBond.sol:405]\");\n}\n\n\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n}","after":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\n\nrequire(amount.isNonZeroPositiveInt256(), \"Amount not strictly positive [SecurityBond.sol:386]\");\n\n\namount = amount.clampMax(stagedByWallet[msg.sender].get(currencyCt, currencyId));\n\n\nstagedByWallet[msg.sender].sub(amount, currencyCt, currencyId);\n\n\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Dispatch by controller failed [SecurityBond.sol:405]\");\n}\n\n\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId, standard);\n}","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"SecurityBond","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"FraudChallenge","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"FraudChallenge","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"FraudChallenge","time":0},{"type":"struct-data-arrangement ","before":"\naddress wallet\nuint256 nonce\nuint256 referenceBlockNumber\nuint256 definitionBlockNumber\nuint256 expirationTime\nStatus status\nAmounts amounts\nMonetaryTypesLib.Currency currency\nDriip challenged\nbool walletInitiated\nbool terminated\nDisqualification disqualification","after":"uint256 nonce\nuint256 referenceBlockNumber\nuint256 definitionBlockNumber\nuint256 expirationTime\nStatus status\nAmounts amounts\nMonetaryTypesLib.Currency currency\nDriip challenged\nDisqualification disqualification\naddress wallet\nbool walletInitiated\nbool terminated\n","contract":"SettlementChallengeTypesLib","time":0},{"type":"external-function ","before":"function initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\nint256 targetBalanceAmount, MonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated,\nbytes32 challengedHash, string memory challengedKind)\npublic\nonlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n{\n\n_initiateProposal(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\ncurrency, blockNumber, walletInitiated, challengedHash, challengedKind\n);\n\n\nemit InitiateProposalEvent(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\nblockNumber, walletInitiated, challengedHash, challengedKind\n);\n}","after":"function initiateProposal(address wallet, uint256 nonce, int256 cumulativeTransferAmount, int256 stageAmount,\nint256 targetBalanceAmount, MonetaryTypesLib.Currency calldata currency, uint256 blockNumber, bool walletInitiated,\nbytes32 challengedHash, string calldata challengedKind)\npublic\nonlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n{\n\n_initiateProposal(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount,\ncurrency, blockNumber, walletInitiated, challengedHash, challengedKind\n);\n\n\nemit InitiateProposalEvent(\nwallet, nonce, cumulativeTransferAmount, stageAmount, targetBalanceAmount, currency,\nblockNumber, walletInitiated, challengedHash, challengedKind\n);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n\nproposals[index - 1].terminated = true;\n\n\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n}","after":"function terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool clearNonce)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n\nproposals[index - 1].terminated = true;\n\n\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool clearNonce,\nbool walletTerminated)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:165]\");\n\n\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n\nproposals[index - 1].terminated = true;\n\n\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n}","after":"function terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool clearNonce,\nbool walletTerminated)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:165]\");\n\n\nif (clearNonce)\nproposalIndexByWalletNonceCurrency[wallet][proposals[index - 1].nonce][currency.ct][currency.id] = 0;\n\n\nproposals[index - 1].terminated = true;\n\n\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n\n_removeProposal(index);\n}","after":"function removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n\n_removeProposal(index);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:225]\");\n\n\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n\n_removeProposal(index);\n}","after":"function removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [DriipSettlementChallengeState.sol:225]\");\n\n\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].challenged.hash, proposals[index - 1].challenged.kind\n);\n\n\n_removeProposal(index);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\nuint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\npublic\nonlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:255]\");\n\n\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\nproposals[index - 1].disqualification.challenger = challengerWallet;\nproposals[index - 1].disqualification.nonce = candidateNonce;\nproposals[index - 1].disqualification.blockNumber = blockNumber;\nproposals[index - 1].disqualification.candidate.hash = candidateHash;\nproposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n\nemit DisqualifyProposalEvent(\nchallengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\ncurrency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nchallengerWallet, candidateNonce, candidateHash, candidateKind\n);\n}","after":"function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency calldata currency, address challengerWallet,\nuint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string calldata candidateKind)\npublic\nonlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:255]\");\n\n\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\nproposals[index - 1].disqualification.challenger = challengerWallet;\nproposals[index - 1].disqualification.nonce = candidateNonce;\nproposals[index - 1].disqualification.blockNumber = blockNumber;\nproposals[index - 1].disqualification.candidate.hash = candidateHash;\nproposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n\nemit DisqualifyProposalEvent(\nchallengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance,\ncurrency, proposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nchallengerWallet, candidateNonce, candidateHash, candidateKind\n);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function qualifyProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nonlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:284]\");\n\n\nemit QualifyProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].disqualification.challenger,\nproposals[index - 1].disqualification.nonce,\nproposals[index - 1].disqualification.candidate.hash,\nproposals[index - 1].disqualification.candidate.kind\n);\n\n\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\ndelete proposals[index - 1].disqualification;\n}","after":"function qualifyProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nonlyEnabledServiceAction(QUALIFY_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:284]\");\n\n\nemit QualifyProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.cumulativeTransfer,\nproposals[index - 1].amounts.stage, proposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated,\nproposals[index - 1].disqualification.challenger,\nproposals[index - 1].disqualification.nonce,\nproposals[index - 1].disqualification.candidate.hash,\nproposals[index - 1].disqualification.candidate.kind\n);\n\n\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Qualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\ndelete proposals[index - 1].disqualification;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n\nreturn 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];\n}","after":"function hasProposal(address wallet, uint256 nonce, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n\nreturn 0 != proposalIndexByWalletNonceCurrency[wallet][nonce][currency.ct][currency.id];\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n\nreturn 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n}","after":"function hasProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n\nreturn 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:342]\");\nreturn proposals[index - 1].terminated;\n}","after":"function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:342]\");\nreturn proposals[index - 1].terminated;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:357]\");\nreturn block.timestamp >= proposals[index - 1].expirationTime;\n}","after":"function hasProposalExpired(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:357]\");\nreturn block.timestamp >= proposals[index - 1].expirationTime;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:371]\");\nreturn proposals[index - 1].nonce;\n}","after":"function proposalNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:371]\");\nreturn proposals[index - 1].nonce;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:385]\");\nreturn proposals[index - 1].referenceBlockNumber;\n}","after":"function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:385]\");\nreturn proposals[index - 1].referenceBlockNumber;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:399]\");\nreturn proposals[index - 1].definitionBlockNumber;\n}","after":"function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:399]\");\nreturn proposals[index - 1].definitionBlockNumber;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:413]\");\nreturn proposals[index - 1].expirationTime;\n}","after":"function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:413]\");\nreturn proposals[index - 1].expirationTime;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (SettlementChallengeTypesLib.Status)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:427]\");\nreturn proposals[index - 1].status;\n}","after":"function proposalStatus(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (SettlementChallengeTypesLib.Status)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:427]\");\nreturn proposals[index - 1].status;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:441]\");\nreturn proposals[index - 1].amounts.cumulativeTransfer;\n}","after":"function proposalCumulativeTransferAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:441]\");\nreturn proposals[index - 1].amounts.cumulativeTransfer;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:455]\");\nreturn proposals[index - 1].amounts.stage;\n}","after":"function proposalStageAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:455]\");\nreturn proposals[index - 1].amounts.stage;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:469]\");\nreturn proposals[index - 1].amounts.targetBalance;\n}","after":"function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:469]\");\nreturn proposals[index - 1].amounts.targetBalance;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalChallengedHash(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:483]\");\nreturn proposals[index - 1].challenged.hash;\n}","after":"function proposalChallengedHash(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:483]\");\nreturn proposals[index - 1].challenged.hash;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalChallengedKind(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:497]\");\nreturn proposals[index - 1].challenged.kind;\n}","after":"function proposalChallengedKind(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:497]\");\nreturn proposals[index - 1].challenged.kind;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:511]\");\nreturn proposals[index - 1].walletInitiated;\n}","after":"function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:511]\");\nreturn proposals[index - 1].walletInitiated;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (address)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:525]\");\nreturn proposals[index - 1].disqualification.challenger;\n}","after":"function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (address)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:525]\");\nreturn proposals[index - 1].disqualification.challenger;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:539]\");\nreturn proposals[index - 1].disqualification.nonce;\n}","after":"function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:539]\");\nreturn proposals[index - 1].disqualification.nonce;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:553]\");\nreturn proposals[index - 1].disqualification.blockNumber;\n}","after":"function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:553]\");\nreturn proposals[index - 1].disqualification.blockNumber;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:567]\");\nreturn proposals[index - 1].disqualification.candidate.hash;\n}","after":"function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:567]\");\nreturn proposals[index - 1].disqualification.candidate.hash;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:581]\");\nreturn proposals[index - 1].disqualification.candidate.kind;\n}","after":"function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [DriipSettlementChallengeState.sol:581]\");\nreturn proposals[index - 1].disqualification.candidate.kind;\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function upgradeProposal(SettlementChallengeTypesLib.Proposal memory proposal)\npublic\nonlyWhenUpgrading\n{\n\nrequire(\n0 == proposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id],\n\"Proposal exists for wallet, nonce and currency [DriipSettlementChallengeState.sol:592]\"\n);\n\n\nproposals.push(proposal);\n\n\nuint256 index = proposals.length;\n\n\nproposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id] = index;\nproposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id] = index;\n\n\nemit UpgradeProposalEvent(proposal);\n}","after":"function upgradeProposal(SettlementChallengeTypesLib.Proposal calldata proposal)\npublic\nonlyWhenUpgrading\n{\n\nrequire(\n0 == proposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id],\n\"Proposal exists for wallet, nonce and currency [DriipSettlementChallengeState.sol:592]\"\n);\n\n\nproposals.push(proposal);\n\n\nuint256 index = proposals.length;\n\n\nproposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id] = index;\nproposalIndexByWalletNonceCurrency[proposal.wallet][proposal.nonce][proposal.currency.ct][proposal.currency.id] = index;\n\n\nemit UpgradeProposalEvent(proposal);\n}","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"DriipSettlementChallengeState","time":0},{"type":"external-function ","before":"function initiateProposal(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\nMonetaryTypesLib.Currency memory currency, uint256 blockNumber, bool walletInitiated)\npublic\nonlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n{\n\n_initiateProposal(\nwallet, nonce, stageAmount, targetBalanceAmount,\ncurrency, blockNumber, walletInitiated\n);\n\n\nemit InitiateProposalEvent(\nwallet, nonce, stageAmount, targetBalanceAmount, currency,\nblockNumber, walletInitiated\n);\n}","after":"function initiateProposal(address wallet, uint256 nonce, int256 stageAmount, int256 targetBalanceAmount,\nMonetaryTypesLib.Currency calldata currency, uint256 blockNumber, bool walletInitiated)\npublic\nonlyEnabledServiceAction(INITIATE_PROPOSAL_ACTION)\n{\n\n_initiateProposal(\nwallet, nonce, stageAmount, targetBalanceAmount,\ncurrency, blockNumber, walletInitiated\n);\n\n\nemit InitiateProposalEvent(\nwallet, nonce, stageAmount, targetBalanceAmount, currency,\nblockNumber, walletInitiated\n);\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nproposals[index - 1].terminated = true;\n\n\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n}","after":"function terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nproposals[index - 1].terminated = true;\n\n\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function terminateProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:145]\");\n\n\nproposals[index - 1].terminated = true;\n\n\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n}","after":"function terminateProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(TERMINATE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:145]\");\n\n\nproposals[index - 1].terminated = true;\n\n\nemit TerminateProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n\n\n_removeProposal(index);\n}","after":"function removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n\n\n_removeProposal(index);\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function removeProposal(address wallet, MonetaryTypesLib.Currency memory currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:199]\");\n\n\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n\n\n_removeProposal(index);\n}","after":"function removeProposal(address wallet, MonetaryTypesLib.Currency calldata currency, bool walletTerminated)\npublic\nonlyEnabledServiceAction(REMOVE_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n\n\nif (0 == index)\nreturn;\n\n\nrequire(walletTerminated == proposals[index - 1].walletInitiated, \"Wallet initiation and termination mismatch [NullSettlementChallengeState.sol:199]\");\n\n\nemit RemoveProposalEvent(\nwallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency,\nproposals[index - 1].referenceBlockNumber, proposals[index - 1].walletInitiated\n);\n\n\n_removeProposal(index);\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency memory currency, address challengerWallet,\nuint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string memory candidateKind)\npublic\nonlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\nrequire(0 != index, \"No settlement found for wallet and currency [NullSettlementChallengeState.sol:228]\");\n\n\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\nproposals[index - 1].disqualification.challenger = challengerWallet;\nproposals[index - 1].disqualification.nonce = candidateNonce;\nproposals[index - 1].disqualification.blockNumber = blockNumber;\nproposals[index - 1].disqualification.candidate.hash = candidateHash;\nproposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n\nemit DisqualifyProposalEvent(\nchallengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency, proposals[index - 1].referenceBlockNumber,\nproposals[index - 1].walletInitiated, challengerWallet, candidateNonce, candidateHash, candidateKind\n);\n}","after":"function disqualifyProposal(address challengedWallet, MonetaryTypesLib.Currency calldata currency, address challengerWallet,\nuint256 blockNumber, uint256 candidateNonce, bytes32 candidateHash, string calldata candidateKind)\npublic\nonlyEnabledServiceAction(DISQUALIFY_PROPOSAL_ACTION)\n{\n\nuint256 index = proposalIndexByWalletCurrency[challengedWallet][currency.ct][currency.id];\nrequire(0 != index, \"No settlement found for wallet and currency [NullSettlementChallengeState.sol:228]\");\n\n\nproposals[index - 1].status = SettlementChallengeTypesLib.Status.Disqualified;\nproposals[index - 1].expirationTime = block.timestamp.add(configuration.settlementChallengeTimeout());\nproposals[index - 1].disqualification.challenger = challengerWallet;\nproposals[index - 1].disqualification.nonce = candidateNonce;\nproposals[index - 1].disqualification.blockNumber = blockNumber;\nproposals[index - 1].disqualification.candidate.hash = candidateHash;\nproposals[index - 1].disqualification.candidate.kind = candidateKind;\n\n\nemit DisqualifyProposalEvent(\nchallengedWallet, proposals[index - 1].nonce, proposals[index - 1].amounts.stage,\nproposals[index - 1].amounts.targetBalance, currency, proposals[index - 1].referenceBlockNumber,\nproposals[index - 1].walletInitiated, challengerWallet, candidateNonce, candidateHash, candidateKind\n);\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposal(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n\nreturn 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n}","after":"function hasProposal(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n\nreturn 0 != proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:271]\");\nreturn proposals[index - 1].terminated;\n}","after":"function hasProposalTerminated(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:271]\");\nreturn proposals[index - 1].terminated;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function hasProposalExpired(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:286]\");\nreturn block.timestamp >= proposals[index - 1].expirationTime;\n}","after":"function hasProposalExpired(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\n\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:286]\");\nreturn block.timestamp >= proposals[index - 1].expirationTime;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalNonce(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:300]\");\nreturn proposals[index - 1].nonce;\n}","after":"function proposalNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:300]\");\nreturn proposals[index - 1].nonce;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:314]\");\nreturn proposals[index - 1].referenceBlockNumber;\n}","after":"function proposalReferenceBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:314]\");\nreturn proposals[index - 1].referenceBlockNumber;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:328]\");\nreturn proposals[index - 1].definitionBlockNumber;\n}","after":"function proposalDefinitionBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:328]\");\nreturn proposals[index - 1].definitionBlockNumber;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:342]\");\nreturn proposals[index - 1].expirationTime;\n}","after":"function proposalExpirationTime(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:342]\");\nreturn proposals[index - 1].expirationTime;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalStatus(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (SettlementChallengeTypesLib.Status)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:356]\");\nreturn proposals[index - 1].status;\n}","after":"function proposalStatus(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (SettlementChallengeTypesLib.Status)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:356]\");\nreturn proposals[index - 1].status;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalStageAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:370]\");\nreturn proposals[index - 1].amounts.stage;\n}","after":"function proposalStageAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:370]\");\nreturn proposals[index - 1].amounts.stage;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:384]\");\nreturn proposals[index - 1].amounts.targetBalance;\n}","after":"function proposalTargetBalanceAmount(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (int256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:384]\");\nreturn proposals[index - 1].amounts.targetBalance;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bool)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:398]\");\nreturn proposals[index - 1].walletInitiated;\n}","after":"function proposalWalletInitiated(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bool)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:398]\");\nreturn proposals[index - 1].walletInitiated;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (address)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:412]\");\nreturn proposals[index - 1].disqualification.challenger;\n}","after":"function proposalDisqualificationChallenger(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (address)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:412]\");\nreturn proposals[index - 1].disqualification.challenger;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:426]\");\nreturn proposals[index - 1].disqualification.blockNumber;\n}","after":"function proposalDisqualificationBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:426]\");\nreturn proposals[index - 1].disqualification.blockNumber;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:440]\");\nreturn proposals[index - 1].disqualification.nonce;\n}","after":"function proposalDisqualificationNonce(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:440]\");\nreturn proposals[index - 1].disqualification.nonce;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:454]\");\nreturn proposals[index - 1].disqualification.candidate.hash;\n}","after":"function proposalDisqualificationCandidateHash(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (bytes32)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:454]\");\nreturn proposals[index - 1].disqualification.candidate.hash;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:468]\");\nreturn proposals[index - 1].disqualification.candidate.kind;\n}","after":"function proposalDisqualificationCandidateKind(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (string memory)\n{\nuint256 index = proposalIndexByWalletCurrency[wallet][currency.ct][currency.id];\nrequire(0 != index, \"No proposal found for wallet and currency [NullSettlementChallengeState.sol:468]\");\nreturn proposals[index - 1].disqualification.candidate.kind;\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function upgradeProposal(SettlementChallengeTypesLib.Proposal memory proposal)\npublic\nonlyWhenUpgrading\n{\n\nrequire(\n0 == proposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id],\n\"Proposal exists for wallet and currency [NullSettlementChallengeState.sol:479]\"\n);\n\n\nproposals.push(proposal);\n\n\nuint256 index = proposals.length;\n\n\nproposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id] = index;\n\n\nemit UpgradeProposalEvent(proposal);\n}","after":"function upgradeProposal(SettlementChallengeTypesLib.Proposal calldata proposal)\npublic\nonlyWhenUpgrading\n{\n\nrequire(\n0 == proposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id],\n\"Proposal exists for wallet and currency [NullSettlementChallengeState.sol:479]\"\n);\n\n\nproposals.push(proposal);\n\n\nuint256 index = proposals.length;\n\n\nproposalIndexByWalletCurrency[proposal.wallet][proposal.currency.ct][proposal.currency.id] = index;\n\n\nemit UpgradeProposalEvent(proposal);\n}","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"NullSettlementChallengeState","time":0},{"type":"external-function ","before":"function challengeByPayment(address wallet, PaymentTypesLib.Payment memory payment, address challenger)\npublic\nonlyEnabledServiceAction(CHALLENGE_BY_PAYMENT_ACTION)\nonlySealedPayment(payment)\nonlyPaymentSender(payment, wallet)\n{\n\nrequire(\n!fraudChallenge.isFraudulentPaymentHash(payment.seals.operator.hash),\n\"Payment deemed fraudulent [DriipSettlementDisputeByPayment.sol:102]\"\n);\n\n\nrequire(\ndriipSettlementChallengeState.hasProposal(wallet, payment.currency),\n\"No proposal found [DriipSettlementDisputeByPayment.sol:108]\"\n);\n\n\nrequire(\n!driipSettlementChallengeState.hasProposalExpired(wallet, payment.currency),\n\"Proposal found expired [DriipSettlementDisputeByPayment.sol:114]\"\n);\n\n\n\nrequire(\npayment.sender.nonce > driipSettlementChallengeState.proposalNonce(wallet, payment.currency),\n\"Payment nonce not strictly greater than proposal nonce [DriipSettlementDisputeByPayment.sol:121]\"\n);\nrequire(\npayment.sender.nonce > driipSettlementChallengeState.proposalDisqualificationNonce(wallet, payment.currency),\n\"Payment nonce not strictly greater than proposal disqualification nonce [DriipSettlementDisputeByPayment.sol:125]\"\n);\n\n\nrequire(_overrun(wallet, payment), \"No overrun found [DriipSettlementDisputeByPayment.sol:131]\");\n\n\n_settleRewards(wallet, payment.sender.balances.current, payment.currency, challenger);\n\n\ndriipSettlementChallengeState.disqualifyProposal(\nwallet, payment.currency, challenger, payment.blockNumber,\npayment.sender.nonce, payment.seals.operator.hash, PaymentTypesLib.PAYMENT_KIND()\n);\n\n\nnullSettlementChallengeState.terminateProposal(wallet, payment.currency);\n\n\nemit ChallengeByPaymentEvent(\nwallet, driipSettlementChallengeState.proposalNonce(wallet, payment.currency), payment, challenger\n);\n}","after":"function challengeByPayment(address wallet, PaymentTypesLib.Payment calldata payment, address challenger)\npublic\nonlyEnabledServiceAction(CHALLENGE_BY_PAYMENT_ACTION)\nonlySealedPayment(payment)\nonlyPaymentSender(payment, wallet)\n{\n\nrequire(\n!fraudChallenge.isFraudulentPaymentHash(payment.seals.operator.hash),\n\"Payment deemed fraudulent [DriipSettlementDisputeByPayment.sol:102]\"\n);\n\n\nrequire(\ndriipSettlementChallengeState.hasProposal(wallet, payment.currency),\n\"No proposal found [DriipSettlementDisputeByPayment.sol:108]\"\n);\n\n\nrequire(\n!driipSettlementChallengeState.hasProposalExpired(wallet, payment.currency),\n\"Proposal found expired [DriipSettlementDisputeByPayment.sol:114]\"\n);\n\n\n\nrequire(\npayment.sender.nonce > driipSettlementChallengeState.proposalNonce(wallet, payment.currency),\n\"Payment nonce not strictly greater than proposal nonce [DriipSettlementDisputeByPayment.sol:121]\"\n);\nrequire(\npayment.sender.nonce > driipSettlementChallengeState.proposalDisqualificationNonce(wallet, payment.currency),\n\"Payment nonce not strictly greater than proposal disqualification nonce [DriipSettlementDisputeByPayment.sol:125]\"\n);\n\n\nrequire(_overrun(wallet, payment), \"No overrun found [DriipSettlementDisputeByPayment.sol:131]\");\n\n\n_settleRewards(wallet, payment.sender.balances.current, payment.currency, challenger);\n\n\ndriipSettlementChallengeState.disqualifyProposal(\nwallet, payment.currency, challenger, payment.blockNumber,\npayment.sender.nonce, payment.seals.operator.hash, PaymentTypesLib.PAYMENT_KIND()\n);\n\n\nnullSettlementChallengeState.terminateProposal(wallet, payment.currency);\n\n\nemit ChallengeByPaymentEvent(\nwallet, driipSettlementChallengeState.proposalNonce(wallet, payment.currency), payment, challenger\n);\n}","contract":"DriipSettlementDisputeByPayment","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementDisputeByPayment","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementDisputeByPayment","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"DriipSettlementDisputeByPayment","time":0},{"type":"constant-restrict-modification  ","before":"uint256 maxDriipNonce;","after":"uint256 constant maxDriipNonce;","contract":"CommunityVote","time":0},{"type":"constant-restrict-modification  ","before":"uint256 maxNullNonce;","after":"uint256 constant maxNullNonce;","contract":"CommunityVote","time":0},{"type":"immutable-restrict-modification ","before":"bool dataAvailable;","after":"bool immutable dataAvailable;","contract":"CommunityVote","time":0},{"type":"external-function ","before":"function receiveTokens(string memory balanceType, int256 amount, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\nreceiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);\n}","after":"function receiveTokens(string calldata balanceType, int256 amount, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\nreceiveTokensTo(msg.sender, balanceType, amount, currencyCt, currencyId, standard);\n}","contract":"RevenueFund","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory currencies)\npublic\nonlyOperator\n{\nrequire(\nConstantsLib.PARTS_PER() == totalBeneficiaryFraction,\n\"Total beneficiary fraction out of bounds [RevenueFund.sol:236]\"\n);\n\n\nfor (uint256 i = 0; i < currencies.length; i++) {\nMonetaryTypesLib.Currency memory currency = currencies[i];\n\nint256 remaining = periodAccrual.get(currency.ct, currency.id);\n\nif (0 >= remaining)\ncontinue;\n\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\nif (beneficiaryFraction(beneficiary) > 0) {\nint256 transferable = periodAccrual.get(currency.ct, currency.id)\n.mul(beneficiaryFraction(beneficiary))\n.div(ConstantsLib.PARTS_PER());\n\nif (transferable > remaining)\ntransferable = remaining;\n\nif (transferable > 0) {\n\nif (currency.ct == address(0))\nbeneficiary.receiveEthersTo.value(uint256(transferable))(address(0), \"\");\n\n\nelse {\nTransferController controller = transferController(currency.ct, \"\");\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(transferable), currency.ct, currency.id\n)\n);\nrequire(success, \"Approval by controller failed [RevenueFund.sol:274]\");\n\nbeneficiary.receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\n}\n\nremaining = remaining.sub(transferable);\n}\n}\n}\n\n\nperiodAccrual.set(remaining, currency.ct, currency.id);\n}\n\n\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n\nif (0 >= beneficiaryFraction(beneficiary))\ncontinue;\n\n\nbeneficiary.closeAccrualPeriod(currencies);\n}\n\n\nemit CloseAccrualPeriodEvent();\n}","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata currencies)\npublic\nonlyOperator\n{\nrequire(\nConstantsLib.PARTS_PER() == totalBeneficiaryFraction,\n\"Total beneficiary fraction out of bounds [RevenueFund.sol:236]\"\n);\n\n\nfor (uint256 i = 0; i < currencies.length; i++) {\nMonetaryTypesLib.Currency memory currency = currencies[i];\n\nint256 remaining = periodAccrual.get(currency.ct, currency.id);\n\nif (0 >= remaining)\ncontinue;\n\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\nif (beneficiaryFraction(beneficiary) > 0) {\nint256 transferable = periodAccrual.get(currency.ct, currency.id)\n.mul(beneficiaryFraction(beneficiary))\n.div(ConstantsLib.PARTS_PER());\n\nif (transferable > remaining)\ntransferable = remaining;\n\nif (transferable > 0) {\n\nif (currency.ct == address(0))\nbeneficiary.receiveEthersTo.value(uint256(transferable))(address(0), \"\");\n\n\nelse {\nTransferController controller = transferController(currency.ct, \"\");\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getApproveSignature(), address(beneficiary), uint256(transferable), currency.ct, currency.id\n)\n);\nrequire(success, \"Approval by controller failed [RevenueFund.sol:274]\");\n\nbeneficiary.receiveTokensTo(address(0), \"\", transferable, currency.ct, currency.id, \"\");\n}\n\nremaining = remaining.sub(transferable);\n}\n}\n}\n\n\nperiodAccrual.set(remaining, currency.ct, currency.id);\n}\n\n\nfor (uint256 j = 0; j < beneficiaries.length; j++) {\nAccrualBeneficiary beneficiary = AccrualBeneficiary(address(beneficiaries[j]));\n\n\nif (0 >= beneficiaryFraction(beneficiary))\ncontinue;\n\n\nbeneficiary.closeAccrualPeriod(currencies);\n}\n\n\nemit CloseAccrualPeriodEvent();\n}","contract":"RevenueFund","time":0},{"type":"external-function ","before":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] memory)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }","after":"function closeAccrualPeriod(MonetaryTypesLib.Currency[] calldata)\n    public\n    {\n        emit CloseAccrualPeriodEvent();\n    }","contract":"RevenueFund","time":0},{"type":"struct-data-arrangement ","before":"\nbytes32 nameHash\nuint256 fee\naddress wallet\nuint256 index\nbool operatorCanUpdate\nbool partnerCanUpdate\nFungibleBalanceLib.Balance active\nFungibleBalanceLib.Balance staged\nTxHistoryLib.TxHistory txHistory\nFullBalanceHistory[] fullBalanceHistory","after":"bytes32 nameHash\nuint256 fee\nuint256 index\nFungibleBalanceLib.Balance active\nFungibleBalanceLib.Balance staged\nTxHistoryLib.TxHistory txHistory\nFullBalanceHistory[] fullBalanceHistory\naddress wallet\nbool operatorCanUpdate\nbool partnerCanUpdate\n","contract":"PartnerFund","time":1},{"type":"external-function ","before":"function receiveEthersTo(address tag, string memory)\npublic\npayable\n{\n_receiveEthersTo(\nuint256(tag) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\n);\n}","after":"function receiveEthersTo(address tag, string calldata)\npublic\npayable\n{\n_receiveEthersTo(\nuint256(tag) - 1, SafeMathIntLib.toNonZeroInt256(msg.value)\n);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function receiveTokens(string memory, int256 amount, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\n_receiveTokensTo(\nindexByWallet(msg.sender) - 1, amount, currencyCt, currencyId, standard\n);\n}","after":"function receiveTokens(string calldata, int256 amount, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\n_receiveTokensTo(\nindexByWallet(msg.sender) - 1, amount, currencyCt, currencyId, standard\n);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function receiveTokensTo(address tag, string memory, int256 amount, address currencyCt,\nuint256 currencyId, string memory standard)\npublic\n{\n_receiveTokensTo(\nuint256(tag) - 1, amount, currencyCt, currencyId, standard\n);\n}","after":"function receiveTokensTo(address tag, string calldata, int256 amount, address currencyCt,\nuint256 currencyId, string calldata standard)\npublic\n{\n_receiveTokensTo(\nuint256(tag) - 1, amount, currencyCt, currencyId, standard\n);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function depositByName(string memory name, uint depositIndex)\npublic\nview\nreturns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n{\n\nreturn _depositByIndices(indexByName(name) - 1, depositIndex);\n}","after":"function depositByName(string calldata name, uint depositIndex)\npublic\nview\nreturns (int256 balance, uint256 blockNumber, address currencyCt, uint256 currencyId)\n{\n\nreturn _depositByIndices(indexByName(name) - 1, depositIndex);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function depositsCountByName(string memory name)\npublic\nview\nreturns (uint256)\n{\n\nreturn _depositsCountByIndex(indexByName(name) - 1);\n}","after":"function depositsCountByName(string calldata name)\npublic\nview\nreturns (uint256)\n{\n\nreturn _depositsCountByIndex(indexByName(name) - 1);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function activeBalanceByName(string memory name, address currencyCt, uint256 currencyId)\npublic\nview\nreturns (int256)\n{\n\nreturn _activeBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n}","after":"function activeBalanceByName(string calldata name, address currencyCt, uint256 currencyId)\npublic\nview\nreturns (int256)\n{\n\nreturn _activeBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function stagedBalanceByName(string memory name, address currencyCt, uint256 currencyId)\npublic\nview\nreturns (int256)\n{\n\nreturn _stagedBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n}","after":"function stagedBalanceByName(string calldata name, address currencyCt, uint256 currencyId)\npublic\nview\nreturns (int256)\n{\n\nreturn _stagedBalanceByIndex(indexByName(name) - 1, currencyCt, currencyId);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function registerByName(string memory name, uint256 fee, address wallet,\nbool partnerCanUpdate, bool operatorCanUpdate)\npublic\nonlyOperator\n{\n\nrequire(bytes(name).length > 0, \"Some error message when require fails [PartnerFund.sol:392]\");\n\n\nbytes32 nameHash = hashName(name);\n\n\n_registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\n\n\nemit RegisterPartnerByNameEvent(name, fee, wallet);\n}","after":"function registerByName(string calldata name, uint256 fee, address wallet,\nbool partnerCanUpdate, bool operatorCanUpdate)\npublic\nonlyOperator\n{\n\nrequire(bytes(name).length > 0, \"Some error message when require fails [PartnerFund.sol:392]\");\n\n\nbytes32 nameHash = hashName(name);\n\n\n_registerPartnerByNameHash(nameHash, fee, wallet, partnerCanUpdate, operatorCanUpdate);\n\n\nemit RegisterPartnerByNameEvent(name, fee, wallet);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function isRegisteredByName(string memory name)\npublic\nview\nreturns (bool)\n{\nreturn (0 < _indexByNameHash[hashName(name)]);\n}","after":"function isRegisteredByName(string calldata name)\npublic\nview\nreturns (bool)\n{\nreturn (0 < _indexByNameHash[hashName(name)]);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function feeByName(string memory name)\npublic\nview\nreturns (uint256)\n{\n\nreturn _partnerFeeByIndex(indexByName(name) - 1);\n}","after":"function feeByName(string calldata name)\npublic\nview\nreturns (uint256)\n{\n\nreturn _partnerFeeByIndex(indexByName(name) - 1);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function setFeeByName(string memory name, uint256 newFee)\npublic\n{\n\nuint256 oldFee = _setPartnerFeeByIndex(indexByName(name) - 1, newFee);\n\n\nemit SetFeeByNameEvent(name, oldFee, newFee);\n}","after":"function setFeeByName(string calldata name, uint256 newFee)\npublic\n{\n\nuint256 oldFee = _setPartnerFeeByIndex(indexByName(name) - 1, newFee);\n\n\nemit SetFeeByNameEvent(name, oldFee, newFee);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function walletByName(string memory name)\npublic\nview\nreturns (address)\n{\n\nreturn partners[indexByName(name) - 1].wallet;\n}","after":"function walletByName(string calldata name)\npublic\nview\nreturns (address)\n{\n\nreturn partners[indexByName(name) - 1].wallet;\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function setWalletByName(string memory name, address newWallet)\npublic\n{\n\naddress oldWallet = _setPartnerWalletByIndex(indexByName(name) - 1, newWallet);\n\n\nemit SetPartnerWalletByNameEvent(name, oldWallet, newWallet);\n}","after":"function setWalletByName(string calldata name, address newWallet)\npublic\n{\n\naddress oldWallet = _setPartnerWalletByIndex(indexByName(name) - 1, newWallet);\n\n\nemit SetPartnerWalletByNameEvent(name, oldWallet, newWallet);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string memory standard)\npublic\n{\n\nuint256 index = indexByWallet(msg.sender);\n\n\nrequire(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:736]\");\n\n\namount = amount.clampMax(partners[index - 1].staged.get(currencyCt, currencyId));\n\npartners[index - 1].staged.sub(amount, currencyCt, currencyId);\n\n\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Some error message when require fails [PartnerFund.sol:754]\");\n}\n\n\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId);\n}","after":"function withdraw(int256 amount, address currencyCt, uint256 currencyId, string calldata standard)\npublic\n{\n\nuint256 index = indexByWallet(msg.sender);\n\n\nrequire(amount.isPositiveInt256(), \"Some error message when require fails [PartnerFund.sol:736]\");\n\n\namount = amount.clampMax(partners[index - 1].staged.get(currencyCt, currencyId));\n\npartners[index - 1].staged.sub(amount, currencyCt, currencyId);\n\n\nif (address(0) == currencyCt && 0 == currencyId)\nmsg.sender.transfer(uint256(amount));\n\nelse {\nTransferController controller = transferController(currencyCt, standard);\n(bool success,) = address(controller).delegatecall(\nabi.encodeWithSelector(\ncontroller.getDispatchSignature(), address(this), msg.sender, uint256(amount), currencyCt, currencyId\n)\n);\nrequire(success, \"Some error message when require fails [PartnerFund.sol:754]\");\n}\n\n\nemit WithdrawEvent(msg.sender, amount, currencyCt, currencyId);\n}","contract":"PartnerFund","time":0},{"type":"external-function ","before":"function initSettlement(string memory settledKind, bytes32 settledHash, address originWallet,\nuint256 originNonce, address targetWallet, uint256 targetNonce)\npublic\nonlyEnabledServiceAction(INIT_SETTLEMENT_ACTION)\n{\nif (\n0 == walletNonceSettlementIndex[originWallet][originNonce] &&\n0 == walletNonceSettlementIndex[targetWallet][targetNonce]\n) {\n\nsettlements.length++;\n\n\nuint256 index = settlements.length - 1;\n\n\nsettlements[index].settledKind = settledKind;\nsettlements[index].settledHash = settledHash;\nsettlements[index].origin.nonce = originNonce;\nsettlements[index].origin.wallet = originWallet;\nsettlements[index].target.nonce = targetNonce;\nsettlements[index].target.wallet = targetWallet;\n\n\nemit InitSettlementEvent(settlements[index]);\n\n\nindex++;\nwalletSettlementIndices[originWallet].push(index);\nwalletSettlementIndices[targetWallet].push(index);\nwalletNonceSettlementIndex[originWallet][originNonce] = index;\nwalletNonceSettlementIndex[targetWallet][targetNonce] = index;\n}\n}","after":"function initSettlement(string calldata settledKind, bytes32 settledHash, address originWallet,\nuint256 originNonce, address targetWallet, uint256 targetNonce)\npublic\nonlyEnabledServiceAction(INIT_SETTLEMENT_ACTION)\n{\nif (\n0 == walletNonceSettlementIndex[originWallet][originNonce] &&\n0 == walletNonceSettlementIndex[targetWallet][targetNonce]\n) {\n\nsettlements.length++;\n\n\nuint256 index = settlements.length - 1;\n\n\nsettlements[index].settledKind = settledKind;\nsettlements[index].settledHash = settledHash;\nsettlements[index].origin.nonce = originNonce;\nsettlements[index].origin.wallet = originWallet;\nsettlements[index].target.nonce = targetNonce;\nsettlements[index].target.wallet = targetWallet;\n\n\nemit InitSettlementEvent(settlements[index]);\n\n\nindex++;\nwalletSettlementIndices[originWallet].push(index);\nwalletSettlementIndices[targetWallet].push(index);\nwalletNonceSettlementIndex[originWallet][originNonce] = index;\nwalletNonceSettlementIndex[targetWallet][targetNonce] = index;\n}\n}","contract":"DriipSettlementState","time":1},{"type":"external-function ","before":"function maxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (uint256)\n{\nreturn walletCurrencyMaxNonce[wallet][currency.ct][currency.id];\n}","after":"function maxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (uint256)\n{\nreturn walletCurrencyMaxNonce[wallet][currency.ct][currency.id];\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function setMaxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency memory currency,\nuint256 maxNonce)\npublic\nonlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n{\n\nwalletCurrencyMaxNonce[wallet][currency.ct][currency.id] = maxNonce;\n\n\nemit SetMaxNonceByWalletAndCurrencyEvent(wallet, currency, maxNonce);\n}","after":"function setMaxNonceByWalletAndCurrency(address wallet, MonetaryTypesLib.Currency calldata currency,\nuint256 maxNonce)\npublic\nonlyEnabledServiceAction(SET_MAX_NONCE_ACTION)\n{\n\nwalletCurrencyMaxNonce[wallet][currency.ct][currency.id] = maxNonce;\n\n\nemit SetMaxNonceByWalletAndCurrencyEvent(wallet, currency, maxNonce);\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function settledAmountByBlockNumber(address wallet, MonetaryTypesLib.Currency memory currency,\nuint256 blockNumber)\npublic\nview\nreturns (int256)\n{\nuint256 settledBlockNumber = _walletSettledBlockNumber(wallet, currency, blockNumber);\nreturn walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber];\n}","after":"function settledAmountByBlockNumber(address wallet, MonetaryTypesLib.Currency calldata currency,\nuint256 blockNumber)\npublic\nview\nreturns (int256)\n{\nuint256 settledBlockNumber = _walletSettledBlockNumber(wallet, currency, blockNumber);\nreturn walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber];\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function addSettledAmountByBlockNumber(address wallet, int256 amount, MonetaryTypesLib.Currency memory currency,\nuint256 blockNumber)\npublic\nonlyEnabledServiceAction(ADD_SETTLED_AMOUNT_ACTION)\n{\n\nuint256 settledBlockNumber = _walletSettledBlockNumber(wallet, currency, blockNumber);\n\n\nwalletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber] =\nwalletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber].add(amount);\n\n\nwalletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].push(block.number);\n\n\nemit AddSettledAmountEvent(wallet, amount, currency, blockNumber);\n}","after":"function addSettledAmountByBlockNumber(address wallet, int256 amount, MonetaryTypesLib.Currency calldata currency,\nuint256 blockNumber)\npublic\nonlyEnabledServiceAction(ADD_SETTLED_AMOUNT_ACTION)\n{\n\nuint256 settledBlockNumber = _walletSettledBlockNumber(wallet, currency, blockNumber);\n\n\nwalletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber] =\nwalletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][settledBlockNumber].add(amount);\n\n\nwalletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].push(block.number);\n\n\nemit AddSettledAmountEvent(wallet, amount, currency, blockNumber);\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function totalFee(address wallet, Beneficiary beneficiary, address destination,\nMonetaryTypesLib.Currency memory currency)\npublic\nview\nreturns (MonetaryTypesLib.NoncedAmount memory)\n{\nreturn totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id];\n}","after":"function totalFee(address wallet, Beneficiary beneficiary, address destination,\nMonetaryTypesLib.Currency calldata currency)\npublic\nview\nreturns (MonetaryTypesLib.NoncedAmount memory)\n{\nreturn totalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id];\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function setTotalFee(address wallet, Beneficiary beneficiary, address destination,\nMonetaryTypesLib.Currency memory currency, MonetaryTypesLib.NoncedAmount memory _totalFee)\npublic\nonlyEnabledServiceAction(SET_TOTAL_FEE_ACTION)\n{\n\ntotalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id] = _totalFee;\n\n\nemit SetTotalFeeEvent(wallet, beneficiary, destination, currency, _totalFee);\n}","after":"function setTotalFee(address wallet, Beneficiary beneficiary, address destination,\nMonetaryTypesLib.Currency calldata currency, MonetaryTypesLib.NoncedAmount calldata _totalFee)\npublic\nonlyEnabledServiceAction(SET_TOTAL_FEE_ACTION)\n{\n\ntotalFeesMap[wallet][address(beneficiary)][destination][currency.ct][currency.id] = _totalFee;\n\n\nemit SetTotalFeeEvent(wallet, beneficiary, destination, currency, _totalFee);\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function upgradeSettlement(DriipSettlementTypesLib.Settlement memory settlement)\npublic\nonlyWhenUpgrading\n{\n\nrequire(\n0 == walletNonceSettlementIndex[settlement.origin.wallet][settlement.origin.nonce],\n\"Settlement exists for origin wallet and nonce [DriipSettlementState.sol:443]\"\n);\nrequire(\n0 == walletNonceSettlementIndex[settlement.target.wallet][settlement.target.nonce],\n\"Settlement exists for target wallet and nonce [DriipSettlementState.sol:447]\"\n);\n\n\nsettlements.push(settlement);\n\n\nuint256 index = settlements.length;\n\n\nwalletSettlementIndices[settlement.origin.wallet].push(index);\nwalletSettlementIndices[settlement.target.wallet].push(index);\nwalletNonceSettlementIndex[settlement.origin.wallet][settlement.origin.nonce] = index;\nwalletNonceSettlementIndex[settlement.target.wallet][settlement.target.nonce] = index;\n\n\nemit UpgradeSettlementEvent(settlement);\n}","after":"function upgradeSettlement(DriipSettlementTypesLib.Settlement calldata settlement)\npublic\nonlyWhenUpgrading\n{\n\nrequire(\n0 == walletNonceSettlementIndex[settlement.origin.wallet][settlement.origin.nonce],\n\"Settlement exists for origin wallet and nonce [DriipSettlementState.sol:443]\"\n);\nrequire(\n0 == walletNonceSettlementIndex[settlement.target.wallet][settlement.target.nonce],\n\"Settlement exists for target wallet and nonce [DriipSettlementState.sol:447]\"\n);\n\n\nsettlements.push(settlement);\n\n\nuint256 index = settlements.length;\n\n\nwalletSettlementIndices[settlement.origin.wallet].push(index);\nwalletSettlementIndices[settlement.target.wallet].push(index);\nwalletNonceSettlementIndex[settlement.origin.wallet][settlement.origin.nonce] = index;\nwalletNonceSettlementIndex[settlement.target.wallet][settlement.target.nonce] = index;\n\n\nemit UpgradeSettlementEvent(settlement);\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function upgradeSettledAmount(address wallet, int256 amount, MonetaryTypesLib.Currency memory currency,\nuint256 blockNumber)\npublic\nonlyWhenUpgrading\n{\n\nrequire(0 == walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][blockNumber], \"[DriipSettlementState.sol:479]\");\n\n\nwalletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][blockNumber] = amount;\n\n\nwalletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].push(blockNumber);\n\n\nemit UpgradeSettledAmountEvent(wallet, amount, currency, blockNumber);\n}","after":"function upgradeSettledAmount(address wallet, int256 amount, MonetaryTypesLib.Currency calldata currency,\nuint256 blockNumber)\npublic\nonlyWhenUpgrading\n{\n\nrequire(0 == walletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][blockNumber], \"[DriipSettlementState.sol:479]\");\n\n\nwalletCurrencyBlockNumberSettledAmount[wallet][currency.ct][currency.id][blockNumber] = amount;\n\n\nwalletCurrencySettledBlockNumbers[wallet][currency.ct][currency.id].push(blockNumber);\n\n\nemit UpgradeSettledAmountEvent(wallet, amount, currency, blockNumber);\n}","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function enableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","after":"function enableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n\n        emit EnableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function disableServiceAction(address service, string memory action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","after":"function disableServiceAction(address service, string calldata action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n\n        emit DisableServiceActionEvent(service, action);\n    }","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function isEnabledServiceAction(address service, string memory action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","after":"function isEnabledServiceAction(address service, string calldata action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }","contract":"DriipSettlementState","time":0},{"type":"external-function ","before":"function startChallengeFromPayment(PaymentTypesLib.Payment memory payment, int256 stageAmount)\npublic\n{\n\nrequire(!walletLocker.isLocked(msg.sender), \"Wallet found locked [DriipSettlementChallengeByPayment.sol:134]\");\n\n\n_startChallengeFromPayment(msg.sender, payment, stageAmount, true);\n\n\nemit StartChallengeFromPaymentEvent(\nmsg.sender,\ndriipSettlementChallengeState.proposalNonce(msg.sender, payment.currency),\ndriipSettlementChallengeState.proposalCumulativeTransferAmount(msg.sender, payment.currency),\nstageAmount,\ndriipSettlementChallengeState.proposalTargetBalanceAmount(msg.sender, payment.currency),\npayment.currency.ct, payment.currency.id\n);\n}","after":"function startChallengeFromPayment(PaymentTypesLib.Payment calldata payment, int256 stageAmount)\npublic\n{\n\nrequire(!walletLocker.isLocked(msg.sender), \"Wallet found locked [DriipSettlementChallengeByPayment.sol:134]\");\n\n\n_startChallengeFromPayment(msg.sender, payment, stageAmount, true);\n\n\nemit StartChallengeFromPaymentEvent(\nmsg.sender,\ndriipSettlementChallengeState.proposalNonce(msg.sender, payment.currency),\ndriipSettlementChallengeState.proposalCumulativeTransferAmount(msg.sender, payment.currency),\nstageAmount,\ndriipSettlementChallengeState.proposalTargetBalanceAmount(msg.sender, payment.currency),\npayment.currency.ct, payment.currency.id\n);\n}","contract":"DriipSettlementChallengeByPayment","time":0},{"type":"external-function ","before":"function startChallengeFromPaymentByProxy(address wallet, PaymentTypesLib.Payment memory payment, int256 stageAmount)\npublic\nonlyOperator\n{\n\n_startChallengeFromPayment(wallet, payment, stageAmount, false);\n\n\nemit StartChallengeFromPaymentByProxyEvent(\nwallet,\ndriipSettlementChallengeState.proposalNonce(wallet, payment.currency),\ndriipSettlementChallengeState.proposalCumulativeTransferAmount(wallet, payment.currency),\nstageAmount,\ndriipSettlementChallengeState.proposalTargetBalanceAmount(wallet, payment.currency),\npayment.currency.ct, payment.currency.id, msg.sender\n);\n}","after":"function startChallengeFromPaymentByProxy(address wallet, PaymentTypesLib.Payment calldata payment, int256 stageAmount)\npublic\nonlyOperator\n{\n\n_startChallengeFromPayment(wallet, payment, stageAmount, false);\n\n\nemit StartChallengeFromPaymentByProxyEvent(\nwallet,\ndriipSettlementChallengeState.proposalNonce(wallet, payment.currency),\ndriipSettlementChallengeState.proposalCumulativeTransferAmount(wallet, payment.currency),\nstageAmount,\ndriipSettlementChallengeState.proposalTargetBalanceAmount(wallet, payment.currency),\npayment.currency.ct, payment.currency.id, msg.sender\n);\n}","contract":"DriipSettlementChallengeByPayment","time":0},{"type":"external-function ","before":"function challengeByPayment(address wallet, PaymentTypesLib.Payment memory payment)\npublic\nonlyOperationalModeNormal\n{\n\ndriipSettlementDisputeByPayment.challengeByPayment(wallet, payment, msg.sender);\n\n\nemit ChallengeByPaymentEvent(\nwallet,\ndriipSettlementChallengeState.proposalNonce(wallet, payment.currency),\ndriipSettlementChallengeState.proposalCumulativeTransferAmount(wallet, payment.currency),\ndriipSettlementChallengeState.proposalStageAmount(wallet, payment.currency),\ndriipSettlementChallengeState.proposalTargetBalanceAmount(wallet, payment.currency),\npayment.currency.ct, payment.currency.id, msg.sender\n);\n}","after":"function challengeByPayment(address wallet, PaymentTypesLib.Payment calldata payment)\npublic\nonlyOperationalModeNormal\n{\n\ndriipSettlementDisputeByPayment.challengeByPayment(wallet, payment, msg.sender);\n\n\nemit ChallengeByPaymentEvent(\nwallet,\ndriipSettlementChallengeState.proposalNonce(wallet, payment.currency),\ndriipSettlementChallengeState.proposalCumulativeTransferAmount(wallet, payment.currency),\ndriipSettlementChallengeState.proposalStageAmount(wallet, payment.currency),\ndriipSettlementChallengeState.proposalTargetBalanceAmount(wallet, payment.currency),\npayment.currency.ct, payment.currency.id, msg.sender\n);\n}","contract":"DriipSettlementChallengeByPayment","time":0}]}