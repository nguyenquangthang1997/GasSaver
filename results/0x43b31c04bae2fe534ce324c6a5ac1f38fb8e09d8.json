{"time":173,"results":[{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC20","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC20","time":0},{"type":"state-data-arrangement ","before":"\nuint256 constant MAX_NUM_TIERS = 10;\nuint8 currentMaxTier = 4;\naddress public penaltyWallet;\naddress public PKF;\nmapping(address => mapping(address => UserInfo)) public userInfo;\nmapping(address => uint256) public userExternalStaked;\nuint256[MAX_NUM_TIERS] tierPrice;\nuint256[6] public withdrawFeePercent;\nuint256[5] public daysLockLevel;\nmapping(address => ExternalToken) public externalToken;\nbool public canEmergencyWithdraw;","after":"uint256 constant MAX_NUM_TIERS = 10;\nmapping(address => mapping(address => UserInfo)) public userInfo;\nmapping(address => uint256) public userExternalStaked;\nuint256[MAX_NUM_TIERS] tierPrice;\nuint256[6] public withdrawFeePercent;\nuint256[5] public daysLockLevel;\nmapping(address => ExternalToken) public externalToken;\naddress public penaltyWallet;\naddress public PKF;\nuint8 currentMaxTier = 4;\nbool public canEmergencyWithdraw;\n","contract":"RedKiteTiers","time":0},{"type":"struct-data-arrangement ","before":"\naddress contractAddress\nuint256 decimals\nuint256 rate\nbool isERC721\nbool canStake","after":"uint256 decimals\nuint256 rate\naddress contractAddress\nbool isERC721\nbool canStake\n","contract":"RedKiteTiers","time":0},{"type":"external-function ","before":"function depositBatchERC721(address _token, uint128[] memory _tokenIds)\n\n    external\n\n    nonReentrant()\n\n    {\n\n        require(\n\n            externalToken[_token].canStake == true,\n\n            \"TIER::TOKEN_NOT_ACCEPTED\"\n\n        );\n\n        _batchSafeTransferFrom(_token, msg.sender, address(this), _tokenIds);\n\n\n        uint256 amount = _tokenIds.length;\n\n        ExternalToken storage token = externalToken[_token];\n\n        userExternalStaked[msg.sender] = userExternalStaked[msg.sender].add(\n\n            amount.mul(token.rate)\n\n        );\n\n\n        userInfo[msg.sender][_token].staked = userInfo[msg.sender][_token]\n\n        .staked\n\n        .add(amount);\n\n        userInfo[msg.sender][_token].stakedTime = block.timestamp;\n\n\n        emit StakedBatchERC721(msg.sender, _token, _tokenIds);\n\n    }","after":"function depositBatchERC721(address _token, uint128[] calldata _tokenIds)\n\n    external\n\n    nonReentrant()\n\n    {\n\n        require(\n\n            externalToken[_token].canStake == true,\n\n            \"TIER::TOKEN_NOT_ACCEPTED\"\n\n        );\n\n        _batchSafeTransferFrom(_token, msg.sender, address(this), _tokenIds);\n\n\n        uint256 amount = _tokenIds.length;\n\n        ExternalToken storage token = externalToken[_token];\n\n        userExternalStaked[msg.sender] = userExternalStaked[msg.sender].add(\n\n            amount.mul(token.rate)\n\n        );\n\n\n        userInfo[msg.sender][_token].staked = userInfo[msg.sender][_token]\n\n        .staked\n\n        .add(amount);\n\n        userInfo[msg.sender][_token].stakedTime = block.timestamp;\n\n\n        emit StakedBatchERC721(msg.sender, _token, _tokenIds);\n\n    }","contract":"RedKiteTiers","time":0},{"type":"external-function ","before":"function withdrawBatchERC721(address _token, uint128[] memory _tokenIds)\n\n    external\n\n    nonReentrant()\n\n    {\n\n        UserInfo storage user = userInfo[msg.sender][_token];\n\n        uint256 amount = _tokenIds.length;\n\n        require(user.staked >= amount, \"not enough amount to withdraw\");\n\n\n        user.staked = user.staked.sub(amount);\n\n\n        ExternalToken storage token = externalToken[_token];\n\n        userExternalStaked[msg.sender] = userExternalStaked[msg.sender].sub(\n\n            amount.mul(token.rate)\n\n        );\n\n\n        _batchSafeTransferFrom(_token, address(this), msg.sender, _tokenIds);\n\n        emit WithdrawnBatchERC721(\n\n            msg.sender,\n\n            _token,\n\n            _tokenIds,\n\n            user.stakedTime\n\n        );\n\n    }","after":"function withdrawBatchERC721(address _token, uint128[] calldata _tokenIds)\n\n    external\n\n    nonReentrant()\n\n    {\n\n        UserInfo storage user = userInfo[msg.sender][_token];\n\n        uint256 amount = _tokenIds.length;\n\n        require(user.staked >= amount, \"not enough amount to withdraw\");\n\n\n        user.staked = user.staked.sub(amount);\n\n\n        ExternalToken storage token = externalToken[_token];\n\n        userExternalStaked[msg.sender] = userExternalStaked[msg.sender].sub(\n\n            amount.mul(token.rate)\n\n        );\n\n\n        _batchSafeTransferFrom(_token, address(this), msg.sender, _tokenIds);\n\n        emit WithdrawnBatchERC721(\n\n            msg.sender,\n\n            _token,\n\n            _tokenIds,\n\n            user.stakedTime\n\n        );\n\n    }","contract":"RedKiteTiers","time":0},{"type":"external-function ","before":"function emergencyWithdrawERC721(address _token, uint128[] memory _tokenIds)\n\n    external\n\n    {\n\n        require(canEmergencyWithdraw, \"function disabled\");\n\n        UserInfo storage user = userInfo[msg.sender][_token];\n\n        require(user.staked > 0, \"nothing to withdraw\");\n\n\n        uint256 _amount = user.staked;\n\n        user.staked = 0;\n\n\n        ExternalToken storage token = externalToken[_token];\n\n        userExternalStaked[msg.sender] = userExternalStaked[msg.sender].sub(\n\n            _amount.mul(token.rate).div(10 ** token.decimals)\n\n        );\n\n\n        if (_amount == 1) {\n\n            IERC721(_token).safeTransferFrom(\n\n                address(this),\n\n                msg.sender,\n\n                _tokenIds[0]\n\n            );\n\n        } else {\n\n            _batchSafeTransferFrom(\n\n                _token,\n\n                address(this),\n\n                msg.sender,\n\n                _tokenIds\n\n            );\n\n        }\n\n        emit EmergencyWithdrawnERC721(\n\n            msg.sender,\n\n            _token,\n\n            _tokenIds,\n\n            user.stakedTime\n\n        );\n\n    }","after":"function emergencyWithdrawERC721(address _token, uint128[] calldata _tokenIds)\n\n    external\n\n    {\n\n        require(canEmergencyWithdraw, \"function disabled\");\n\n        UserInfo storage user = userInfo[msg.sender][_token];\n\n        require(user.staked > 0, \"nothing to withdraw\");\n\n\n        uint256 _amount = user.staked;\n\n        user.staked = 0;\n\n\n        ExternalToken storage token = externalToken[_token];\n\n        userExternalStaked[msg.sender] = userExternalStaked[msg.sender].sub(\n\n            _amount.mul(token.rate).div(10 ** token.decimals)\n\n        );\n\n\n        if (_amount == 1) {\n\n            IERC721(_token).safeTransferFrom(\n\n                address(this),\n\n                msg.sender,\n\n                _tokenIds[0]\n\n            );\n\n        } else {\n\n            _batchSafeTransferFrom(\n\n                _token,\n\n                address(this),\n\n                msg.sender,\n\n                _tokenIds\n\n            );\n\n        }\n\n        emit EmergencyWithdrawnERC721(\n\n            msg.sender,\n\n            _token,\n\n            _tokenIds,\n\n            user.stakedTime\n\n        );\n\n    }","contract":"RedKiteTiers","time":0},{"type":"external-function ","before":"function onERC721Received(\n\n        address,\n\n        address,\n\n        uint256,\n\n        bytes memory\n\n    ) public virtual override returns (bytes4) {\n\n        return this.onERC721Received.selector;\n\n    }","after":"function onERC721Received(\n\n        address,\n\n        address,\n\n        uint256,\n\n        bytes calldata\n\n    ) public virtual override returns (bytes4) {\n\n        return this.onERC721Received.selector;\n\n    }","contract":"RedKiteTiers","time":0},{"type":"immutable-restrict-modification ","before":"address public PKF;","after":"address public immutable PKF;","contract":"RedKiteTiers","time":0}]}