{"time":116,"results":[{"type":"immutable-restrict-modification ","before":"address public owner;","after":"address public immutable owner;","contract":"TokenSpender","time":0},{"type":"immutable-restrict-modification ","before":"address public gasTokenOwner;","after":"address public immutable gasTokenOwner;","contract":"TokenSpender","time":0},{"type":"external-function ","before":"function swap(\n\n        IERC20 fromToken,\n\n        IERC20 toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        uint256 guaranteedAmount,\n\n        address payable referrer,\n\n        address[] memory callAddresses,\n\n        bytes memory callDataConcat,\n\n        uint256[] memory starts,\n\n        uint256[] memory gasLimitsAndValues\n\n    )\n\n    public\n\n    payable\n\n    notShutdown\n\n    returns (uint256 returnAmount)\n\n    {\n\n        uint256 gasProvided = gasleft();\n\n\n        require(minReturnAmount > 0, \"Min return should be bigger then 0.\");\n\n        require(callAddresses.length > 0, \"Call data should exists.\");\n\n\n        if (fromToken != ETH_ADDRESS) {\n\n            spender.claimTokens(fromToken, msg.sender, address(this), fromTokenAmount);\n\n        }\n\n\n        for (uint i = 0; i < callAddresses.length; i++) {\n\n            require(callAddresses[i] != address(spender), \"Access denied\");\n\n            require(callAddresses[i].externalCall(\n\n                    gasLimitsAndValues[i] & ((1 << 128) - 1),\n\n                    callDataConcat,\n\n                    starts[i],\n\n                    starts[i + 1] - starts[i],\n\n                    gasLimitsAndValues[i] >> 128\n\n                ));\n\n        }\n\n\n        // Return back all unswapped\n\n        fromToken.universalTransfer(msg.sender, fromToken.universalBalanceOf(address(this)));\n\n\n        returnAmount = toToken.universalBalanceOf(address(this));\n\n        (uint256 toTokenAmount, uint256 referrerFee) = _handleFees(toToken, referrer, returnAmount, guaranteedAmount);\n\n\n        require(toTokenAmount >= minReturnAmount, \"Return amount is not enough\");\n\n        toToken.universalTransfer(msg.sender, toTokenAmount);\n\n\n        emit History(\n\n            msg.sender,\n\n            fromToken,\n\n            toToken,\n\n            fromTokenAmount,\n\n            toTokenAmount\n\n        );\n\n\n        emit Swapped(\n\n            fromToken,\n\n            toToken,\n\n            referrer,\n\n            fromTokenAmount,\n\n            toTokenAmount,\n\n            referrerFee,\n\n            returnAmount.sub(toTokenAmount)\n\n        );\n\n\n        spender.burnGasToken(gasProvided.sub(gasleft()));\n\n    }","after":"function swap(\n\n        IERC20 fromToken,\n\n        IERC20 toToken,\n\n        uint256 fromTokenAmount,\n\n        uint256 minReturnAmount,\n\n        uint256 guaranteedAmount,\n\n        address payable referrer,\n\n        address[] calldata callAddresses,\n\n        bytes calldata callDataConcat,\n\n        uint256[] calldata starts,\n\n        uint256[] calldata gasLimitsAndValues\n\n    )\n\n    public\n\n    payable\n\n    notShutdown\n\n    returns (uint256 returnAmount)\n\n    {\n\n        uint256 gasProvided = gasleft();\n\n\n        require(minReturnAmount > 0, \"Min return should be bigger then 0.\");\n\n        require(callAddresses.length > 0, \"Call data should exists.\");\n\n\n        if (fromToken != ETH_ADDRESS) {\n\n            spender.claimTokens(fromToken, msg.sender, address(this), fromTokenAmount);\n\n        }\n\n\n        for (uint i = 0; i < callAddresses.length; i++) {\n\n            require(callAddresses[i] != address(spender), \"Access denied\");\n\n            require(callAddresses[i].externalCall(\n\n                    gasLimitsAndValues[i] & ((1 << 128) - 1),\n\n                    callDataConcat,\n\n                    starts[i],\n\n                    starts[i + 1] - starts[i],\n\n                    gasLimitsAndValues[i] >> 128\n\n                ));\n\n        }\n\n\n        // Return back all unswapped\n\n        fromToken.universalTransfer(msg.sender, fromToken.universalBalanceOf(address(this)));\n\n\n        returnAmount = toToken.universalBalanceOf(address(this));\n\n        (uint256 toTokenAmount, uint256 referrerFee) = _handleFees(toToken, referrer, returnAmount, guaranteedAmount);\n\n\n        require(toTokenAmount >= minReturnAmount, \"Return amount is not enough\");\n\n        toToken.universalTransfer(msg.sender, toTokenAmount);\n\n\n        emit History(\n\n            msg.sender,\n\n            fromToken,\n\n            toToken,\n\n            fromTokenAmount,\n\n            toTokenAmount\n\n        );\n\n\n        emit Swapped(\n\n            fromToken,\n\n            toToken,\n\n            referrer,\n\n            fromTokenAmount,\n\n            toTokenAmount,\n\n            referrerFee,\n\n            returnAmount.sub(toTokenAmount)\n\n        );\n\n\n        spender.burnGasToken(gasProvided.sub(gasleft()));\n\n    }","contract":"OneInchExchange","time":0},{"type":"external-function ","before":"function getOrdersInfoRespectingBalancesAndAllowances(\n\n        IERC20 token,\n\n        IZrxExchange zrx,\n\n        address zrxTokenProxy,\n\n        IZrxExchange.Order[] memory orders\n\n    )\n\n    public\n\n    view\n\n    returns (IZrxExchange.OrderInfo[] memory ordersInfo)\n\n    {\n\n        ordersInfo = zrx.getOrdersInfo(orders);\n\n\n        for (uint i = 0; i < ordersInfo.length; i++) {\n\n\n            uint256 balance = token.balanceOf(orders[i].makerAddress);\n\n            uint256 allowance = token.allowance(orders[i].makerAddress, zrxTokenProxy);\n\n            uint256 availableMakerAmount = (allowance < balance) ? allowance : balance;\n\n            uint256 availableTakerAmount = availableMakerAmount.mul(orders[i].takerAssetAmount).div(orders[i].makerAssetAmount);\n\n\n            for (uint j = 0; j < i; j++) {\n\n\n                if (orders[j].makerAddress == orders[i].makerAddress) {\n\n\n                    uint256 orderTakerAssetRemainigAmount = orders[j].takerAssetAmount.sub(\n\n                        ordersInfo[j].orderTakerAssetFilledAmount\n\n                    );\n\n\n                    if (availableTakerAmount > orderTakerAssetRemainigAmount) {\n\n\n                        availableTakerAmount = availableTakerAmount.sub(orderTakerAssetRemainigAmount);\n\n                    } else {\n\n\n                        availableTakerAmount = 0;\n\n                        break;\n\n                    }\n\n                }\n\n            }\n\n\n            uint256 remainingTakerAmount = orders[i].takerAssetAmount.sub(\n\n                ordersInfo[i].orderTakerAssetFilledAmount\n\n            );\n\n\n            if (availableTakerAmount < remainingTakerAmount) {\n\n\n                ordersInfo[i].orderTakerAssetFilledAmount = orders[i].takerAssetAmount.sub(availableTakerAmount);\n\n            }\n\n        }\n\n    }","after":"function getOrdersInfoRespectingBalancesAndAllowances(\n\n        IERC20 token,\n\n        IZrxExchange zrx,\n\n        address zrxTokenProxy,\n\n        IZrxExchange.Order[] calldata orders\n\n    )\n\n    public\n\n    view\n\n    returns (IZrxExchange.OrderInfo[] memory ordersInfo)\n\n    {\n\n        ordersInfo = zrx.getOrdersInfo(orders);\n\n\n        for (uint i = 0; i < ordersInfo.length; i++) {\n\n\n            uint256 balance = token.balanceOf(orders[i].makerAddress);\n\n            uint256 allowance = token.allowance(orders[i].makerAddress, zrxTokenProxy);\n\n            uint256 availableMakerAmount = (allowance < balance) ? allowance : balance;\n\n            uint256 availableTakerAmount = availableMakerAmount.mul(orders[i].takerAssetAmount).div(orders[i].makerAssetAmount);\n\n\n            for (uint j = 0; j < i; j++) {\n\n\n                if (orders[j].makerAddress == orders[i].makerAddress) {\n\n\n                    uint256 orderTakerAssetRemainigAmount = orders[j].takerAssetAmount.sub(\n\n                        ordersInfo[j].orderTakerAssetFilledAmount\n\n                    );\n\n\n                    if (availableTakerAmount > orderTakerAssetRemainigAmount) {\n\n\n                        availableTakerAmount = availableTakerAmount.sub(orderTakerAssetRemainigAmount);\n\n                    } else {\n\n\n                        availableTakerAmount = 0;\n\n                        break;\n\n                    }\n\n                }\n\n            }\n\n\n            uint256 remainingTakerAmount = orders[i].takerAssetAmount.sub(\n\n                ordersInfo[i].orderTakerAssetFilledAmount\n\n            );\n\n\n            if (availableTakerAmount < remainingTakerAmount) {\n\n\n                ordersInfo[i].orderTakerAssetFilledAmount = orders[i].takerAssetAmount.sub(availableTakerAmount);\n\n            }\n\n        }\n\n    }","contract":"OneInchExchange","time":0},{"type":"immutable-restrict-modification ","before":"uint fee;","after":"uint immutable fee;","contract":"OneInchExchange","time":0}]}