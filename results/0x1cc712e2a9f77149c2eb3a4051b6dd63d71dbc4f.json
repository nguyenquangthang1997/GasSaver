{"time":2103,"results":[{"type":"loop-calculation","before":"uint pendingTime;","after":"// move outside for loop\nuint pendingTime;","loc":{"start":{"line":571,"column":12},"end":{"line":571,"column":28}},"contract":"Claims","time":0},{"type":"struct-data-arrangement ","before":"\naddress voter\nuint tokens\nuint claimId\nint8 verdict\nbool rewardClaimed","after":"uint tokens\nuint claimId\naddress voter\nint8 verdict\nbool rewardClaimed\n","contract":"ClaimsData","time":1},{"type":"loop-duplication","before":"\nstart line 4102 column 8, end line 4143 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n\n            voteid = cd.getVoteAddressCA(msg.sender, i);\n\n            (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\n\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n\n                lastClaimed = i;\n\n            }\n\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n\n            if (perc > 0 && !claimed) {\n\n                counter++;\n\n                cd.setRewardClaimed(voteid, true);\n\n            } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\n\n                (perc,,) = cd.getClaimRewardDetail(claimId);\n\n                if (perc == 0) {\n\n                    counter++;\n\n                }\n\n                cd.setRewardClaimed(voteid, true);\n\n            }\n\n            if (tokenForVoteId > 0) {\n\n                total = tokenForVoteId.add(total);\n\n            }\n\n        }\nstart line 4175 column 8, end line 4203 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n\n            voteid = cd.getVoteAddressMember(msg.sender, i);\n\n            (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\n\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n\n                lastClaimed = i;\n\n            }\n\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n            if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\n\n                cd.setRewardClaimed(voteid, true);\n\n                counter++;\n\n            }\n\n            if (tokenForVoteId > 0) {\n\n                total = tokenForVoteId.add(total);\n\n            }\n\n        }","after":"// merge loop\n\nstart line 4102 column 8, end line 4143 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n\n            voteid = cd.getVoteAddressCA(msg.sender, i);\n\n            (tokenForVoteId, lastClaimedCheck, , perc) = getRewardToBeGiven(1, voteid, 0);\n\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n\n                lastClaimed = i;\n\n            }\n\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n\n            if (perc > 0 && !claimed) {\n\n                counter++;\n\n                cd.setRewardClaimed(voteid, true);\n\n            } else if (perc == 0 && cd.getFinalVerdict(claimId) != 0 && !claimed) {\n\n                (perc,,) = cd.getClaimRewardDetail(claimId);\n\n                if (perc == 0) {\n\n                    counter++;\n\n                }\n\n                cd.setRewardClaimed(voteid, true);\n\n            }\n\n            if (tokenForVoteId > 0) {\n\n                total = tokenForVoteId.add(total);\n\n            }\n\n        }\nstart line 4175 column 8, end line 4203 column 8\nfor (i = lastIndex; i < lengthVote && counter < _records; i++) {\n\n            voteid = cd.getVoteAddressMember(msg.sender, i);\n\n            (tokenForVoteId, lastClaimedCheck,,) = getRewardToBeGiven(0, voteid, 0);\n\n            if (lastClaimed == lengthVote && lastClaimedCheck == true) {\n\n                lastClaimed = i;\n\n            }\n\n            (, claimId, , claimed) = cd.getVoteDetails(voteid);\n\n            if (claimed == false && cd.getFinalVerdict(claimId) != 0) {\n\n                cd.setRewardClaimed(voteid, true);\n\n                counter++;\n\n            }\n\n            if (tokenForVoteId > 0) {\n\n                total = tokenForVoteId.add(total);\n\n            }\n\n        }","contract":"ClaimsReward","time":0},{"type":"state-data-arrangement ","before":"\nProposalVote[] internal allVotes;\nDelegateVote[] public allDelegation;\nmapping(uint => ProposalData) internal allProposalData;\nmapping(uint => bytes[]) internal allProposalSolutions;\nmapping(address => uint[]) internal allVotesByMember;\nmapping(uint => mapping(address => bool)) public rewardClaimed;\nmapping(address => mapping(uint => uint)) public memberProposalVote;\nmapping(address => uint) public followerDelegation;\nmapping(address => uint) internal followerCount;\nmapping(address => uint[]) internal leaderDelegation;\nmapping(uint => VoteTally) public proposalVoteTally;\nmapping(address => bool) public isOpenForDelegation;\nmapping(address => uint) public lastRewardClaimed;\nbool internal constructorCheck;\nuint public tokenHoldingTime;\nuint internal roleIdAllowedToCatgorize;\nuint internal maxVoteWeigthPer;\nuint internal specialResolutionMajPerc;\nuint internal maxFollowers;\nuint internal totalProposals;\nuint internal maxDraftTime;\nMemberRoles internal memberRole;\nProposalCategory internal proposalCategory;\nTokenController internal tokenInstance;\nmapping(uint => uint) public proposalActionStatus;\nmapping(uint => uint) internal proposalExecutionTime;\nmapping(uint => mapping(address => bool)) public proposalRejectedByAB;\nmapping(uint => uint) internal actionRejectedCount;\nbool internal actionParamsInitialised;\nuint internal actionWaitingTime;\nuint constant internal AB_MAJ_TO_REJECT_ACTION = 3;","after":"ProposalVote[] internal allVotes;\nDelegateVote[] public allDelegation;\nmapping(uint => ProposalData) internal allProposalData;\nmapping(uint => bytes[]) internal allProposalSolutions;\nmapping(address => uint[]) internal allVotesByMember;\nmapping(uint => mapping(address => bool)) public rewardClaimed;\nmapping(address => mapping(uint => uint)) public memberProposalVote;\nmapping(address => uint) public followerDelegation;\nmapping(address => uint) internal followerCount;\nmapping(address => uint[]) internal leaderDelegation;\nmapping(uint => VoteTally) public proposalVoteTally;\nmapping(address => bool) public isOpenForDelegation;\nmapping(address => uint) public lastRewardClaimed;\nuint public tokenHoldingTime;\nuint internal roleIdAllowedToCatgorize;\nuint internal maxVoteWeigthPer;\nuint internal specialResolutionMajPerc;\nuint internal maxFollowers;\nuint internal totalProposals;\nuint internal maxDraftTime;\nMemberRoles internal memberRole;\nProposalCategory internal proposalCategory;\nTokenController internal tokenInstance;\nmapping(uint => uint) public proposalActionStatus;\nmapping(uint => uint) internal proposalExecutionTime;\nmapping(uint => mapping(address => bool)) public proposalRejectedByAB;\nmapping(uint => uint) internal actionRejectedCount;\nuint internal actionWaitingTime;\nuint constant internal AB_MAJ_TO_REJECT_ACTION = 3;\nbool internal constructorCheck;\nbool internal actionParamsInitialised;\n","contract":"Governance","time":0},{"type":"constant-restrict-modification  ","before":"bool internal constructorCheck;","after":"bool internal constant constructorCheck;","contract":"Governance","time":1},{"type":"constant-restrict-modification  ","before":"uint internal roleIdAllowedToCatgorize;","after":"uint internal constant roleIdAllowedToCatgorize;","contract":"Governance","time":1},{"type":"constant-restrict-modification  ","before":"uint internal maxVoteWeigthPer;","after":"uint internal constant maxVoteWeigthPer;","contract":"Governance","time":1},{"type":"constant-restrict-modification  ","before":"uint internal specialResolutionMajPerc;","after":"uint internal constant specialResolutionMajPerc;","contract":"Governance","time":1},{"type":"constant-restrict-modification  ","before":"address public tokenAddress;","after":"address public constant tokenAddress;","contract":"INXMMaster","time":0},{"type":"constant-restrict-modification  ","before":"address public owner;","after":"address public constant owner;","contract":"INXMMaster","time":0},{"type":"constant-restrict-modification  ","before":"uint public pauseTime;","after":"uint public constant pauseTime;","contract":"INXMMaster","time":0},{"type":"state-data-arrangement ","before":"\nTokenController public dAppToken;\nTokenData internal td;\nQuotationData internal qd;\nClaimsReward internal cr;\nGovernance internal gv;\nTokenFunctions internal tf;\nNXMToken public tk;\nMemberRoleDetails[] internal memberRoleData;\nbool internal constructorCheck;\nuint public maxABCount;\nbool public launched;\nuint public launchedOn;","after":"TokenController public dAppToken;\nTokenData internal td;\nQuotationData internal qd;\nClaimsReward internal cr;\nGovernance internal gv;\nTokenFunctions internal tf;\nNXMToken public tk;\nMemberRoleDetails[] internal memberRoleData;\nuint public maxABCount;\nuint public launchedOn;\nbool internal constructorCheck;\nbool public launched;\n","contract":"MemberRoles","time":0},{"type":"external-function ","before":"function addRole(//solhint-disable-line\n\n        bytes32 _roleName,\n\n        string memory _roleDescription,\n\n        address _authorized\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern {\n\n        _addRole(_roleName, _roleDescription, _authorized);\n\n    }","after":"function addRole(//solhint-disable-line\n\n        bytes32 _roleName,\n\n        string calldata _roleDescription,\n\n        address _authorized\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern {\n\n        _addRole(_roleName, _roleDescription, _authorized);\n\n    }","contract":"MemberRoles","time":0},{"type":"external-function ","before":"function addMembersBeforeLaunch(address[] memory userArray, uint[] memory tokens) public onlyOwner {\n\n        require(!launched);\n\n\n        for (uint i = 0; i < userArray.length; i++) {\n\n            require(!ms.isMember(userArray[i]));\n\n            dAppToken.addToWhitelist(userArray[i]);\n\n            _updateRole(userArray[i], uint(Role.Member), true);\n\n            dAppToken.mint(userArray[i], tokens[i]);\n\n        }\n\n        launched = true;\n\n        launchedOn = now;\n\n\n    }","after":"function addMembersBeforeLaunch(address[] calldata userArray, uint[] calldata tokens) public onlyOwner {\n\n        require(!launched);\n\n\n        for (uint i = 0; i < userArray.length; i++) {\n\n            require(!ms.isMember(userArray[i]));\n\n            dAppToken.addToWhitelist(userArray[i]);\n\n            _updateRole(userArray[i], uint(Role.Member), true);\n\n            dAppToken.mint(userArray[i], tokens[i]);\n\n        }\n\n        launched = true;\n\n        launchedOn = now;\n\n\n    }","contract":"MemberRoles","time":0},{"type":"constant-restrict-modification  ","before":"string public name = \"NXM\";","after":"string public constant name = \"NXM\";","contract":"NXMToken","time":1},{"type":"constant-restrict-modification  ","before":"string public symbol = \"NXM\";","after":"string public constant symbol = \"NXM\";","contract":"NXMToken","time":1},{"type":"constant-restrict-modification  ","before":"uint8 public decimals = 18;","after":"uint8 public constant decimals = 18;","contract":"NXMToken","time":1},{"type":"state-data-arrangement ","before":"\nEmergencyPause[] public emergencyPaused;\nbytes2[] internal allContractNames;\nmapping(address => bool) public contractsActive;\nmapping(bytes2 => address payable) internal allContractVersions;\nmapping(bytes2 => bool) public isProxy;\nmapping(bytes2 => bool) public isUpgradable;\naddress public tokenAddress;\nbool internal reentrancyLock;\nbool public masterInitialized;\naddress public owner;\nuint public pauseTime;\nbool constructorCheck;","after":"EmergencyPause[] public emergencyPaused;\nbytes2[] internal allContractNames;\nmapping(address => bool) public contractsActive;\nmapping(bytes2 => address payable) internal allContractVersions;\nmapping(bytes2 => bool) public isProxy;\nmapping(bytes2 => bool) public isUpgradable;\nuint public pauseTime;\naddress public tokenAddress;\naddress public owner;\nbool internal reentrancyLock;\nbool public masterInitialized;\nbool constructorCheck;\n","contract":"NXMaster","time":0},{"type":"struct-data-arrangement ","before":"\nbool pause\nuint time\nbytes4 by","after":"uint time\nbytes4 by\nbool pause\n","contract":"NXMaster","time":0},{"type":"external-function ","before":"function upgradeMultipleContracts(\n\n        bytes2[] memory _contractsName,\n\n        address payable[] memory _contractsAddress\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern\n\n    {\n\n        require(_contractsName.length == _contractsAddress.length, \"Array length should be equal.\");\n\n\n        for (uint i = 0; i < _contractsName.length; i++) {\n\n            address payable newAddress = _contractsAddress[i];\n\n            require(newAddress != address(0), \"NULL address is not allowed.\");\n\n            require(isUpgradable[_contractsName[i]], \"Contract should be upgradable.\");\n\n            if (_contractsName[i] == \"QT\") {\n\n                Quotation qt = Quotation(allContractVersions[\"QT\"]);\n\n                qt.transferAssetsToNewContract(newAddress);\n\n\n            } else if (_contractsName[i] == \"CR\") {\n\n                TokenController tc = TokenController(getLatestAddress(\"TC\"));\n\n                tc.addToWhitelist(newAddress);\n\n                tc.removeFromWhitelist(allContractVersions[\"CR\"]);\n\n                ClaimsReward cr = ClaimsReward(allContractVersions[\"CR\"]);\n\n                cr.upgrade(newAddress);\n\n\n            } else if (_contractsName[i] == \"P1\") {\n\n                Pool1 p1 = Pool1(allContractVersions[\"P1\"]);\n\n                p1.upgradeCapitalPool(newAddress);\n\n\n            } else if (_contractsName[i] == \"P2\") {\n\n                Pool2 p2 = Pool2(allContractVersions[\"P2\"]);\n\n                p2.upgradeInvestmentPool(newAddress);\n\n\n            }\n\n\n            address payable oldAddress = allContractVersions[_contractsName[i]];\n\n            contractsActive[oldAddress] = false;\n\n            allContractVersions[_contractsName[i]] = newAddress;\n\n            contractsActive[newAddress] = true;\n\n\n            Iupgradable up = Iupgradable(allContractVersions[_contractsName[i]]);\n\n            up.changeMasterAddress(address(this));\n\n        }\n\n\n        _changeAllAddress();\n\n    }","after":"function upgradeMultipleContracts(\n\n        bytes2[] calldata _contractsName,\n\n        address payable[] calldata _contractsAddress\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern\n\n    {\n\n        require(_contractsName.length == _contractsAddress.length, \"Array length should be equal.\");\n\n\n        for (uint i = 0; i < _contractsName.length; i++) {\n\n            address payable newAddress = _contractsAddress[i];\n\n            require(newAddress != address(0), \"NULL address is not allowed.\");\n\n            require(isUpgradable[_contractsName[i]], \"Contract should be upgradable.\");\n\n            if (_contractsName[i] == \"QT\") {\n\n                Quotation qt = Quotation(allContractVersions[\"QT\"]);\n\n                qt.transferAssetsToNewContract(newAddress);\n\n\n            } else if (_contractsName[i] == \"CR\") {\n\n                TokenController tc = TokenController(getLatestAddress(\"TC\"));\n\n                tc.addToWhitelist(newAddress);\n\n                tc.removeFromWhitelist(allContractVersions[\"CR\"]);\n\n                ClaimsReward cr = ClaimsReward(allContractVersions[\"CR\"]);\n\n                cr.upgrade(newAddress);\n\n\n            } else if (_contractsName[i] == \"P1\") {\n\n                Pool1 p1 = Pool1(allContractVersions[\"P1\"]);\n\n                p1.upgradeCapitalPool(newAddress);\n\n\n            } else if (_contractsName[i] == \"P2\") {\n\n                Pool2 p2 = Pool2(allContractVersions[\"P2\"]);\n\n                p2.upgradeInvestmentPool(newAddress);\n\n\n            }\n\n\n            address payable oldAddress = allContractVersions[_contractsName[i]];\n\n            contractsActive[oldAddress] = false;\n\n            allContractVersions[_contractsName[i]] = newAddress;\n\n            contractsActive[newAddress] = true;\n\n\n            Iupgradable up = Iupgradable(allContractVersions[_contractsName[i]]);\n\n            up.changeMasterAddress(address(this));\n\n        }\n\n\n        _changeAllAddress();\n\n    }","contract":"NXMaster","time":0},{"type":"external-function ","before":"function addNewVersion(address payable[] memory _contractAddresses) public {\n\n\n        require(msg.sender == owner && !masterInitialized, \"Caller should be owner and should only be called once.\");\n\n        require(_contractAddresses.length == allContractNames.length, \"array length not same\");\n\n        masterInitialized = true;\n\n\n        MemberRoles mr = MemberRoles(_contractAddresses[14]);\n\n        // shoud send proxy address for proxy contracts (if not 1st time deploying) \n\n        // bool isMasterUpgrade = mr.nxMasterAddress() != address(0);\n\n\n\n        for (uint i = 0; i < allContractNames.length; i++) {\n\n            require(_contractAddresses[i] != address(0), \"NULL address is not allowed.\");\n\n            allContractVersions[allContractNames[i]] = _contractAddresses[i];\n\n            contractsActive[_contractAddresses[i]] = true;\n\n\n        }\n\n\n        // Need to override owner as owner in MR to avoid inconsistency as owner in MR is some other address.\n\n        (, address[] memory mrOwner) = mr.members(uint(MemberRoles.Role.Owner));\n\n        owner = mrOwner[0];\n\n    }","after":"function addNewVersion(address payable[] calldata _contractAddresses) public {\n\n\n        require(msg.sender == owner && !masterInitialized, \"Caller should be owner and should only be called once.\");\n\n        require(_contractAddresses.length == allContractNames.length, \"array length not same\");\n\n        masterInitialized = true;\n\n\n        MemberRoles mr = MemberRoles(_contractAddresses[14]);\n\n        // shoud send proxy address for proxy contracts (if not 1st time deploying) \n\n        // bool isMasterUpgrade = mr.nxMasterAddress() != address(0);\n\n\n\n        for (uint i = 0; i < allContractNames.length; i++) {\n\n            require(_contractAddresses[i] != address(0), \"NULL address is not allowed.\");\n\n            allContractVersions[allContractNames[i]] = _contractAddresses[i];\n\n            contractsActive[_contractAddresses[i]] = true;\n\n\n        }\n\n\n        // Need to override owner as owner in MR to avoid inconsistency as owner in MR is some other address.\n\n        (, address[] memory mrOwner) = mr.members(uint(MemberRoles.Role.Owner));\n\n        owner = mrOwner[0];\n\n    }","contract":"NXMaster","time":0},{"type":"external-function ","before":"function makeCoverBegin(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] memory coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    isMember\n\n    checkPause\n\n    payable\n\n    {\n\n        require(msg.value == coverDetails[1]);\n\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","after":"function makeCoverBegin(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] calldata coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    isMember\n\n    checkPause\n\n    payable\n\n    {\n\n        require(msg.value == coverDetails[1]);\n\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","contract":"Pool1","time":0},{"type":"external-function ","before":"function makeCoverUsingCA(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] memory coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    isMember\n\n    checkPause\n\n    {\n\n        IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n\n        require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]), \"Transfer failed\");\n\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","after":"function makeCoverUsingCA(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] calldata coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    isMember\n\n    checkPause\n\n    {\n\n        IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n\n        require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]), \"Transfer failed\");\n\n        q2.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","contract":"Pool1","time":0},{"type":"state-data-arrangement ","before":"\nMCR internal m1;\nPool1 internal p1;\nPoolData internal pd;\nFactory internal factory;\naddress public uniswapFactoryAddress;\nuint internal constant DECIMAL1E18 = uint(10) ** 18;\nbool internal locked;","after":"MCR internal m1;\nPool1 internal p1;\nPoolData internal pd;\nFactory internal factory;\nuint internal constant DECIMAL1E18 = uint(10) ** 18;\naddress public uniswapFactoryAddress;\nbool internal locked;\n","contract":"Pool2","time":0},{"type":"state-data-arrangement ","before":"\nIARankDetails[] internal allIARankDetails;\nMcrData[] public allMCRData;\nbytes4[] internal allInvestmentCurrencies;\nbytes4[] internal allCurrencies;\nbytes32[] public allAPIcall;\nmapping(bytes32 => ApiId) public allAPIid;\nmapping(uint64 => uint) internal datewiseId;\nmapping(bytes16 => uint) internal currencyLastIndex;\nmapping(bytes4 => CurrencyAssets) internal allCurrencyAssets;\nmapping(bytes4 => InvestmentAssets) internal allInvestmentAssets;\nmapping(bytes4 => uint) internal caAvgRate;\nmapping(bytes4 => uint) internal iaAvgRate;\naddress public notariseMCR;\naddress public daiFeedAddress;\nuint private constant DECIMAL1E18 = uint(10) ** 18;\nuint public uniswapDeadline;\nuint public liquidityTradeCallbackTime;\nuint public lastLiquidityTradeTrigger;\nuint64 internal lastDate;\nuint public variationPercX100;\nuint public iaRatesTime;\nuint public minCap;\nuint public mcrTime;\nuint public a;\nuint public shockParameter;\nuint public c;\nuint public mcrFailTime;\nuint public ethVolumeLimit;\nuint public capReached;\nuint public capacityLimit;","after":"IARankDetails[] internal allIARankDetails;\nMcrData[] public allMCRData;\nbytes4[] internal allInvestmentCurrencies;\nbytes4[] internal allCurrencies;\nbytes32[] public allAPIcall;\nmapping(bytes32 => ApiId) public allAPIid;\nmapping(uint64 => uint) internal datewiseId;\nmapping(bytes16 => uint) internal currencyLastIndex;\nmapping(bytes4 => CurrencyAssets) internal allCurrencyAssets;\nmapping(bytes4 => InvestmentAssets) internal allInvestmentAssets;\nmapping(bytes4 => uint) internal caAvgRate;\nmapping(bytes4 => uint) internal iaAvgRate;\nuint private constant DECIMAL1E18 = uint(10) ** 18;\nuint public uniswapDeadline;\nuint public liquidityTradeCallbackTime;\nuint public lastLiquidityTradeTrigger;\nuint public variationPercX100;\nuint public iaRatesTime;\nuint public minCap;\nuint public mcrTime;\nuint public a;\nuint public shockParameter;\nuint public c;\nuint public mcrFailTime;\nuint public ethVolumeLimit;\nuint public capReached;\nuint public capacityLimit;\naddress public notariseMCR;\naddress public daiFeedAddress;\nuint64 internal lastDate;\n","contract":"PoolData","time":0},{"type":"struct-data-arrangement ","before":"\nbytes4 typeOf\nbytes4 currency\nuint id\nuint64 dateAdd\nuint64 dateUpd","after":"uint id\nuint64 dateAdd\nuint64 dateUpd\nbytes4 typeOf\nbytes4 currency\n","contract":"PoolData","time":0},{"type":"state-data-arrangement ","before":"\nbool public constructorCheck;\nMemberRoles internal mr;\nCategoryStruct[] internal allCategory;\nmapping(uint => CategoryAction) internal categoryActionData;\nmapping(uint => uint) public categoryABReq;\nmapping(uint => uint) public isSpecialResolution;\nmapping(uint => bytes) public categoryActionHashes;\nbool public categoryActionHashUpdated;","after":"MemberRoles internal mr;\nCategoryStruct[] internal allCategory;\nmapping(uint => CategoryAction) internal categoryActionData;\nmapping(uint => uint) public categoryABReq;\nmapping(uint => uint) public isSpecialResolution;\nmapping(uint => bytes) public categoryActionHashes;\nbool public constructorCheck;\nbool public categoryActionHashUpdated;\n","contract":"ProposalCategory","time":0},{"type":"external-function ","before":"function newCategory(\n\n        string memory _name,\n\n        uint _memberRoleToVote,\n\n        uint _majorityVotePerc,\n\n        uint _quorumPerc,\n\n        uint[] memory _allowedToCreateProposal,\n\n        uint _closingTime,\n\n        string memory _actionHash,\n\n        address _contractAddress,\n\n        bytes2 _contractName,\n\n        uint[] memory _incentives,\n\n        string memory _functionHash\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern\n\n    {\n\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n\n        //If category is special resolution role authorized should be member\n\n        if (_incentives[3] == 1) {\n\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n\n            _majorityVotePerc = 0;\n\n            _quorumPerc = 0;\n\n        }\n\n\n        _addCategory(\n\n            _name,\n\n            _memberRoleToVote,\n\n            _majorityVotePerc,\n\n            _quorumPerc,\n\n            _allowedToCreateProposal,\n\n            _closingTime,\n\n            _actionHash,\n\n            _contractAddress,\n\n            _contractName,\n\n            _incentives\n\n        );\n\n\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n\n            categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);\n\n        }\n\n    }","after":"function newCategory(\n\n        string calldata _name,\n\n        uint _memberRoleToVote,\n\n        uint _majorityVotePerc,\n\n        uint _quorumPerc,\n\n        uint[] calldata _allowedToCreateProposal,\n\n        uint _closingTime,\n\n        string calldata _actionHash,\n\n        address _contractAddress,\n\n        bytes2 _contractName,\n\n        uint[] calldata _incentives,\n\n        string calldata _functionHash\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern\n\n    {\n\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n\n        //If category is special resolution role authorized should be member\n\n        if (_incentives[3] == 1) {\n\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n\n            _majorityVotePerc = 0;\n\n            _quorumPerc = 0;\n\n        }\n\n\n        _addCategory(\n\n            _name,\n\n            _memberRoleToVote,\n\n            _majorityVotePerc,\n\n            _quorumPerc,\n\n            _allowedToCreateProposal,\n\n            _closingTime,\n\n            _actionHash,\n\n            _contractAddress,\n\n            _contractName,\n\n            _incentives\n\n        );\n\n\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n\n            categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);\n\n        }\n\n    }","contract":"ProposalCategory","time":0},{"type":"external-function ","before":"function editCategory(\n\n        uint _categoryId,\n\n        string memory _name,\n\n        uint _memberRoleToVote,\n\n        uint _majorityVotePerc,\n\n        uint _quorumPerc,\n\n        uint[] memory _allowedToCreateProposal,\n\n        uint _closingTime,\n\n        string memory _actionHash,\n\n        address _contractAddress,\n\n        bytes2 _contractName,\n\n        uint[] memory _incentives,\n\n        string memory _functionHash\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern\n\n    {\n\n        require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\n\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n\n        //If category is special resolution role authorized should be member\n\n        if (_incentives[3] == 1) {\n\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n\n            _majorityVotePerc = 0;\n\n            _quorumPerc = 0;\n\n        }\n\n\n        delete categoryActionHashes[_categoryId];\n\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n\n            categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\n\n        }\n\n        allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\n\n        allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\n\n        allCategory[_categoryId].closingTime = _closingTime;\n\n        allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\n\n        allCategory[_categoryId].minStake = _incentives[0];\n\n        allCategory[_categoryId].quorumPerc = _quorumPerc;\n\n        categoryActionData[_categoryId].defaultIncentive = _incentives[1];\n\n        categoryActionData[_categoryId].contractName = _contractName;\n\n        categoryActionData[_categoryId].contractAddress = _contractAddress;\n\n        categoryABReq[_categoryId] = _incentives[2];\n\n        isSpecialResolution[_categoryId] = _incentives[3];\n\n        emit Category(_categoryId, _name, _actionHash);\n\n    }","after":"function editCategory(\n\n        uint _categoryId,\n\n        string calldata _name,\n\n        uint _memberRoleToVote,\n\n        uint _majorityVotePerc,\n\n        uint _quorumPerc,\n\n        uint[] calldata _allowedToCreateProposal,\n\n        uint _closingTime,\n\n        string calldata _actionHash,\n\n        address _contractAddress,\n\n        bytes2 _contractName,\n\n        uint[] calldata _incentives,\n\n        string calldata _functionHash\n\n    )\n\n    public\n\n    onlyAuthorizedToGovern\n\n    {\n\n        require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\n\n\n        require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n\n        require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n\n        require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n\n        //If category is special resolution role authorized should be member\n\n        if (_incentives[3] == 1) {\n\n            require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n\n            _majorityVotePerc = 0;\n\n            _quorumPerc = 0;\n\n        }\n\n\n        delete categoryActionHashes[_categoryId];\n\n        if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n\n            categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\n\n        }\n\n        allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\n\n        allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\n\n        allCategory[_categoryId].closingTime = _closingTime;\n\n        allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\n\n        allCategory[_categoryId].minStake = _incentives[0];\n\n        allCategory[_categoryId].quorumPerc = _quorumPerc;\n\n        categoryActionData[_categoryId].defaultIncentive = _incentives[1];\n\n        categoryActionData[_categoryId].contractName = _contractName;\n\n        categoryActionData[_categoryId].contractAddress = _contractAddress;\n\n        categoryABReq[_categoryId] = _incentives[2];\n\n        isSpecialResolution[_categoryId] = _incentives[3];\n\n        emit Category(_categoryId, _name, _actionHash);\n\n    }","contract":"ProposalCategory","time":0},{"type":"constant-restrict-modification  ","before":"bool public constructorCheck;","after":"bool public constant constructorCheck;","contract":"ProposalCategory","time":0},{"type":"external-function ","before":"function makeCoverUsingNXMTokens(\n\n        uint[] memory coverDetails,\n\n        uint16 coverPeriod,\n\n        bytes4 coverCurr,\n\n        address smartCAdd,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    isMemberAndcheckPause\n\n    {\n\n\n        tc.burnFrom(msg.sender, coverDetails[2]);\n        //need burn allowance\n\n        _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","after":"function makeCoverUsingNXMTokens(\n\n        uint[] calldata coverDetails,\n\n        uint16 coverPeriod,\n\n        bytes4 coverCurr,\n\n        address smartCAdd,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    isMemberAndcheckPause\n\n    {\n\n\n        tc.burnFrom(msg.sender, coverDetails[2]);\n        //need burn allowance\n\n        _verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n\n    }","contract":"Quotation","time":0},{"type":"external-function ","before":"function verifyCoverDetails(\n\n        address payable from,\n\n        address scAddress,\n\n        bytes4 coverCurr,\n\n        uint[] memory coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    onlyInternal\n\n    {\n\n        _verifyCoverDetails(\n\n            from,\n\n            scAddress,\n\n            coverCurr,\n\n            coverDetails,\n\n            coverPeriod,\n\n            _v,\n\n            _r,\n\n            _s\n\n        );\n\n    }","after":"function verifyCoverDetails(\n\n        address payable from,\n\n        address scAddress,\n\n        bytes4 coverCurr,\n\n        uint[] calldata coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    onlyInternal\n\n    {\n\n        _verifyCoverDetails(\n\n            from,\n\n            scAddress,\n\n            coverCurr,\n\n            coverDetails,\n\n            coverPeriod,\n\n            _v,\n\n            _r,\n\n            _s\n\n        );\n\n    }","contract":"Quotation","time":0},{"type":"external-function ","before":"function initiateMembershipAndCover(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] memory coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    payable\n\n    checkPause\n\n    {\n\n        require(coverDetails[3] > now);\n\n        require(!qd.timestampRepeated(coverDetails[4]));\n\n        qd.setTimestampRepeated(coverDetails[4]);\n\n        require(!ms.isMember(msg.sender));\n\n        require(qd.refundEligible(msg.sender) == false);\n\n        uint joinFee = td.joiningFee();\n\n        uint totalFee = joinFee;\n\n        if (coverCurr == \"ETH\") {\n\n            totalFee = joinFee.add(coverDetails[1]);\n\n        } else {\n\n            IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n\n            require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]));\n\n        }\n\n        require(msg.value == totalFee);\n\n        require(verifySign(coverDetails, coverPeriod, coverCurr, smartCAdd, _v, _r, _s));\n\n        qd.addHoldCover(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod);\n\n        qd.setRefundEligible(msg.sender, true);\n\n    }","after":"function initiateMembershipAndCover(\n\n        address smartCAdd,\n\n        bytes4 coverCurr,\n\n        uint[] calldata coverDetails,\n\n        uint16 coverPeriod,\n\n        uint8 _v,\n\n        bytes32 _r,\n\n        bytes32 _s\n\n    )\n\n    public\n\n    payable\n\n    checkPause\n\n    {\n\n        require(coverDetails[3] > now);\n\n        require(!qd.timestampRepeated(coverDetails[4]));\n\n        qd.setTimestampRepeated(coverDetails[4]);\n\n        require(!ms.isMember(msg.sender));\n\n        require(qd.refundEligible(msg.sender) == false);\n\n        uint joinFee = td.joiningFee();\n\n        uint totalFee = joinFee;\n\n        if (coverCurr == \"ETH\") {\n\n            totalFee = joinFee.add(coverDetails[1]);\n\n        } else {\n\n            IERC20 erc20 = IERC20(pd.getCurrencyAssetAddress(coverCurr));\n\n            require(erc20.transferFrom(msg.sender, address(this), coverDetails[1]));\n\n        }\n\n        require(msg.value == totalFee);\n\n        require(verifySign(coverDetails, coverPeriod, coverCurr, smartCAdd, _v, _r, _s));\n\n        qd.addHoldCover(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod);\n\n        qd.setRefundEligible(msg.sender, true);\n\n    }","contract":"Quotation","time":0},{"type":"struct-data-arrangement ","before":"\naddress payable memberAddress\nbytes4 currencyCode\nuint sumAssured\nuint16 coverPeriod\nuint validUntil\naddress scAddress\nuint premiumNXM","after":"uint sumAssured\nuint validUntil\nuint premiumNXM\naddress payable memberAddress\naddress scAddress\nbytes4 currencyCode\nuint16 coverPeriod\n","contract":"QuotationData","time":0},{"type":"struct-data-arrangement ","before":"\nuint holdCoverId\naddress payable userAddress\naddress scAddress\nbytes4 coverCurr\nuint[] coverDetails\nuint16 coverPeriod","after":"uint holdCoverId\nuint[] coverDetails\naddress payable userAddress\naddress scAddress\nbytes4 coverCurr\nuint16 coverPeriod\n","contract":"QuotationData","time":0},{"type":"constant-restrict-modification  ","before":"address public cbAddress;","after":"address public constant cbAddress;","contract":"OraclizeI","time":0},{"type":"state-data-arrangement ","before":"\nOraclizeI oraclize;\nOraclizeAddrResolverI OAR;\nuint constant day = 60 * 60 * 24;\nuint constant week = 60 * 60 * 24 * 7;\nuint constant month = 60 * 60 * 24 * 30;\nbyte constant proofType_NONE = 0x00;\nbyte constant proofType_Ledger = 0x30;\nbyte constant proofType_Native = 0xF0;\nbyte constant proofStorage_IPFS = 0x01;\nbyte constant proofType_Android = 0x40;\nbyte constant proofType_TLSNotary = 0x10;\nstring oraclize_network_name;\nuint8 constant networkID_auto = 0;\nuint8 constant networkID_morden = 2;\nuint8 constant networkID_mainnet = 1;\nuint8 constant networkID_testnet = 2;\nuint8 constant networkID_consensys = 161;\nmapping(bytes32 => bytes32) oraclize_randomDS_args;\nmapping(bytes32 => bool) oraclize_randomDS_sessionKeysHashVerified;","after":"OraclizeI oraclize;\nOraclizeAddrResolverI OAR;\nuint constant day = 60 * 60 * 24;\nuint constant week = 60 * 60 * 24 * 7;\nuint constant month = 60 * 60 * 24 * 30;\nstring oraclize_network_name;\nmapping(bytes32 => bytes32) oraclize_randomDS_args;\nmapping(bytes32 => bool) oraclize_randomDS_sessionKeysHashVerified;\nbyte constant proofType_NONE = 0x00;\nbyte constant proofType_Ledger = 0x30;\nbyte constant proofType_Native = 0xF0;\nbyte constant proofStorage_IPFS = 0x01;\nbyte constant proofType_Android = 0x40;\nbyte constant proofType_TLSNotary = 0x10;\nuint8 constant networkID_auto = 0;\nuint8 constant networkID_morden = 2;\nuint8 constant networkID_mainnet = 1;\nuint8 constant networkID_testnet = 2;\nuint8 constant networkID_consensys = 161;\n","contract":"usingOraclize","time":0}]}