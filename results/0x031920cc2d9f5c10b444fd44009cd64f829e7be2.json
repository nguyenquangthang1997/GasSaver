{"time":757,"results":[{"type":"loop-duplication","before":"\nstart line 919 column 8, end line 931 column 8\nfor (uint256 i = 0; i < probabilitiesLength; i++) {\n            string memory rerollCandidate = rerollCandidates[i];\n            // can't give any attribute already off limits, if it makes a zunk/punk, or their current attribute\n            if (\n                attributeProbabilities[i] == 0 ||\n                isInvalidZunk(rerollCandidate) ||\n                i == attribute\n            ) {\n                invalidProbabilitiesToDistribute += attributeProbabilities[i];\n            } else {\n                validAttribute[i] = true;\n            }\n        }\nstart line 933 column 8, end line 945 column 8\nfor (uint256 i = 0; i < probabilitiesLength; i++) {\n            if (validAttribute[i]) {\n                // the math here is to calculate how much of the invalidProbabilitiesToDistribute to\n                // give to each validProbability. If we are removing 2000 from the pool and giving\n                // 1000 its share, the additional probability for 1000 is 1000/8000 * 2000\n                adjustedProbabilities[i] =\n                ((attributeProbabilities[i] * invalidProbabilitiesToDistribute) /\n                (10000 - invalidProbabilitiesToDistribute)) +\n                attributeProbabilities[i];\n            } else {\n                adjustedProbabilities[i] = 0;\n            }\n        }","after":"// merge loop\n\nstart line 919 column 8, end line 931 column 8\nfor (uint256 i = 0; i < probabilitiesLength; i++) {\n            string memory rerollCandidate = rerollCandidates[i];\n            // can't give any attribute already off limits, if it makes a zunk/punk, or their current attribute\n            if (\n                attributeProbabilities[i] == 0 ||\n                isInvalidZunk(rerollCandidate) ||\n                i == attribute\n            ) {\n                invalidProbabilitiesToDistribute += attributeProbabilities[i];\n            } else {\n                validAttribute[i] = true;\n            }\n        }\nstart line 933 column 8, end line 945 column 8\nfor (uint256 i = 0; i < probabilitiesLength; i++) {\n            if (validAttribute[i]) {\n                // the math here is to calculate how much of the invalidProbabilitiesToDistribute to\n                // give to each validProbability. If we are removing 2000 from the pool and giving\n                // 1000 its share, the additional probability for 1000 is 1000/8000 * 2000\n                adjustedProbabilities[i] =\n                ((attributeProbabilities[i] * invalidProbabilitiesToDistribute) /\n                (10000 - invalidProbabilitiesToDistribute)) +\n                attributeProbabilities[i];\n            } else {\n                adjustedProbabilities[i] = 0;\n            }\n        }","contract":"CryptoZunks","time":0},{"type":"loop-calculation","before":"string memory zunk = serialIdToZunk[serialId];","after":"// move outside for loop\nstring memory zunk = serialIdToZunk[serialId];","loc":{"start":{"line":1359,"column":16},"end":{"line":1359,"column":61}},"contract":"CryptoZunks","time":0},{"type":"external-function ","before":"function getSerialIdTokenRepresentations(uint256[] memory serialIds)\n    external\n    view\n    returns (string[] memory)\n    {\n        string[] memory tokenRepresentations = new string[](serialIds.length);\n        for (uint256 i = 0; i < serialIds.length; i++) {\n            tokenRepresentations[i] = serialIdToZunk[serialIds[i]];\n        }\n        return tokenRepresentations;\n    }","after":"function getSerialIdTokenRepresentations(uint256[] calldata serialIds)\n    external\n    view\n    returns (string[] memory)\n    {\n        string[] memory tokenRepresentations = new string[](serialIds.length);\n        for (uint256 i = 0; i < serialIds.length; i++) {\n            tokenRepresentations[i] = serialIdToZunk[serialIds[i]];\n        }\n        return tokenRepresentations;\n    }","contract":"CryptoZunks","time":0},{"type":"external-function ","before":"function seedPunks(string[] memory punks) public onlyOwner {\n        for (uint256 i = 0; i < punks.length; i++) {\n            unavailableZunks[punks[i]] = true;\n        }\n    }","after":"function seedPunks(string[] calldata punks) public onlyOwner {\n        for (uint256 i = 0; i < punks.length; i++) {\n            unavailableZunks[punks[i]] = true;\n        }\n    }","contract":"CryptoZunks","time":0},{"type":"external-function ","before":"function addFreeMintsAllocatedByDevs(\n        address[] memory addresses,\n        uint256[] memory numOfFreeMints\n    ) public onlyOwner {\n        require(\n            addresses.length == numOfFreeMints.length,\n            \"tokenOwners does not match numOfFreeRolls length\"\n        );\n        uint256 freeMintsFromThisSeed = 0;\n        for (uint256 i = 0; i < addresses.length; i++) {\n            freeMintsAllocatedByDevs[addresses[i]] =\n            freeMintsAllocatedByDevs[addresses[i]] +\n            numOfFreeMints[i];\n            freeMintsFromThisSeed += numOfFreeMints[i];\n        }\n        require(\n            freeMintsFromThisSeed < freeMintsAllocatedByDevsCap,\n            \"too many freemints allocated by devs\"\n        );\n    }","after":"function addFreeMintsAllocatedByDevs(\n        address[] calldata addresses,\n        uint256[] calldata numOfFreeMints\n    ) public onlyOwner {\n        require(\n            addresses.length == numOfFreeMints.length,\n            \"tokenOwners does not match numOfFreeRolls length\"\n        );\n        uint256 freeMintsFromThisSeed = 0;\n        for (uint256 i = 0; i < addresses.length; i++) {\n            freeMintsAllocatedByDevs[addresses[i]] =\n            freeMintsAllocatedByDevs[addresses[i]] +\n            numOfFreeMints[i];\n            freeMintsFromThisSeed += numOfFreeMints[i];\n        }\n        require(\n            freeMintsFromThisSeed < freeMintsAllocatedByDevsCap,\n            \"too many freemints allocated by devs\"\n        );\n    }","contract":"CryptoZunks","time":0},{"type":"constant-restrict-modification  ","before":"string NO_OPTIONS = \"no options\";","after":"string constant NO_OPTIONS = \"no options\";","contract":"CryptoZunks","time":1},{"type":"constant-restrict-modification  ","before":"uint256 NO_REROLL_OPTIONS = 99999;","after":"uint256 constant NO_REROLL_OPTIONS = 99999;","contract":"CryptoZunks","time":1},{"type":"constant-restrict-modification  ","before":"uint256 private MAX_SUPPLY = 10000;","after":"uint256 private constant MAX_SUPPLY = 10000;","contract":"CryptoZunks","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public freeMintsAllocatedByDevsCap = 300;","after":"uint256 public constant freeMintsAllocatedByDevsCap = 300;","contract":"CryptoZunks","time":1},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"CryptoZunks","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"CryptoZunks","time":1}]}