{"time":171,"results":[{"type":"loop-duplication","before":"\nstart line 514 column 8, end line 516 column 8\nfor (uint256 i = 0; i < amounts.length; i++) {\n            totalAmount = totalAmount.add(amounts[i]);\n        }\nstart line 523 column 8, end line 525 column 8\nfor (uint256 i = 0; i < amounts.length; i++) {\n            creditDesk.pay(creditLines[i], amounts[i]);\n        }","after":"// merge loop\n\nstart line 514 column 8, end line 516 column 8\nfor (uint256 i = 0; i < amounts.length; i++) {\n            totalAmount = totalAmount.add(amounts[i]);\n        }\nstart line 523 column 8, end line 525 column 8\nfor (uint256 i = 0; i < amounts.length; i++) {\n            creditDesk.pay(creditLines[i], amounts[i]);\n        }","contract":"Borrower","time":0},{"type":"loop-duplication","before":"\nstart line 560 column 8, end line 562 column 8\nfor (uint256 i = 0; i < minAmounts.length; i++) {\n            totalMinAmount = totalMinAmount.add(minAmounts[i]);\n        }\nstart line 570 column 8, end line 572 column 8\nfor (uint256 i = 0; i < minAmounts.length; i++) {\n            creditDesk.pay(creditLines[i], minAmounts[i]);\n        }","after":"// merge loop\n\nstart line 560 column 8, end line 562 column 8\nfor (uint256 i = 0; i < minAmounts.length; i++) {\n            totalMinAmount = totalMinAmount.add(minAmounts[i]);\n        }\nstart line 570 column 8, end line 572 column 8\nfor (uint256 i = 0; i < minAmounts.length; i++) {\n            creditDesk.pay(creditLines[i], minAmounts[i]);\n        }","contract":"Borrower","time":0},{"type":"external-function ","before":"function payWithSwapOnOneInch(\n        address creditLineAddress,\n        uint256 originAmount,\n        address fromToken,\n        uint256 minTargetAmount,\n        uint256[] memory exchangeDistribution\n    ) external onlyAdmin {\n        transferFrom(fromToken, _msgSender(), address(this), originAmount);\n        IERC20withDec usdc = config.getUSDC();\n        swapOnOneInch(fromToken, address(usdc), originAmount, minTargetAmount, exchangeDistribution);\n        uint256 usdcBalance = usdc.balanceOf(address(this));\n        config.getCreditDesk().pay(creditLineAddress, usdcBalance);\n    }","after":"function payWithSwapOnOneInch(\n        address creditLineAddress,\n        uint256 originAmount,\n        address fromToken,\n        uint256 minTargetAmount,\n        uint256[] calldata exchangeDistribution\n    ) external onlyAdmin {\n        transferFrom(fromToken, _msgSender(), address(this), originAmount);\n        IERC20withDec usdc = config.getUSDC();\n        swapOnOneInch(fromToken, address(usdc), originAmount, minTargetAmount, exchangeDistribution);\n        uint256 usdcBalance = usdc.balanceOf(address(this));\n        config.getCreditDesk().pay(creditLineAddress, usdcBalance);\n    }","contract":"Borrower","time":0},{"type":"external-function ","before":"function payMultipleWithSwapOnOneInch(\n        address[] memory creditLines,\n        uint256[] memory minAmounts,\n        uint256 originAmount,\n        address fromToken,\n        uint256[] memory exchangeDistribution\n    ) external onlyAdmin {\n        require(creditLines.length == minAmounts.length, \"Creditlines and amounts must be the same length\");\n\n        uint256 totalMinAmount = 0;\n        for (uint256 i = 0; i < minAmounts.length; i++) {\n            totalMinAmount = totalMinAmount.add(minAmounts[i]);\n        }\n\n        transferFrom(fromToken, _msgSender(), address(this), originAmount);\n\n        IERC20withDec usdc = config.getUSDC();\n        swapOnOneInch(fromToken, address(usdc), originAmount, totalMinAmount, exchangeDistribution);\n\n        ICreditDesk creditDesk = config.getCreditDesk();\n        for (uint256 i = 0; i < minAmounts.length; i++) {\n            creditDesk.pay(creditLines[i], minAmounts[i]);\n        }\n\n        uint256 remainingUSDC = usdc.balanceOf(address(this));\n        if (remainingUSDC > 0) {\n            bool success = usdc.transfer(creditLines[0], remainingUSDC);\n            require(success, \"Failed to transfer USDC\");\n        }\n    }","after":"function payMultipleWithSwapOnOneInch(\n        address[] calldata creditLines,\n        uint256[] calldata minAmounts,\n        uint256 originAmount,\n        address fromToken,\n        uint256[] calldata exchangeDistribution\n    ) external onlyAdmin {\n        require(creditLines.length == minAmounts.length, \"Creditlines and amounts must be the same length\");\n\n        uint256 totalMinAmount = 0;\n        for (uint256 i = 0; i < minAmounts.length; i++) {\n            totalMinAmount = totalMinAmount.add(minAmounts[i]);\n        }\n\n        transferFrom(fromToken, _msgSender(), address(this), originAmount);\n\n        IERC20withDec usdc = config.getUSDC();\n        swapOnOneInch(fromToken, address(usdc), originAmount, totalMinAmount, exchangeDistribution);\n\n        ICreditDesk creditDesk = config.getCreditDesk();\n        for (uint256 i = 0; i < minAmounts.length; i++) {\n            creditDesk.pay(creditLines[i], minAmounts[i]);\n        }\n\n        uint256 remainingUSDC = usdc.balanceOf(address(this));\n        if (remainingUSDC > 0) {\n            bool success = usdc.transfer(creditLines[0], remainingUSDC);\n            require(success, \"Failed to transfer USDC\");\n        }\n    }","contract":"Borrower","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public totalWritedowns;","after":"uint256 public constant totalWritedowns;","contract":"ICreditDesk","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public totalLoansOutstanding;","after":"uint256 public constant totalLoansOutstanding;","contract":"ICreditDesk","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public sharePrice;","after":"uint256 public constant sharePrice;","contract":"IPool","time":0}]}