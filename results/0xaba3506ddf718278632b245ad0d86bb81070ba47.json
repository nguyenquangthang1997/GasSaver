{"time":103,"results":[{"type":"external-function ","before":"function initialize(\n        address _marketWrapper,\n        address _nftContract,\n        uint256 _tokenId,\n        uint256 _auctionId,\n        address _splitRecipient,\n        uint256 _splitBasisPoints,\n        string memory _name,\n        string memory _symbol\n    ) external initializer {\n        // initialize ReentrancyGuard and ERC721Holder\n        __ReentrancyGuard_init();\n        __ERC721Holder_init();\n        // set storage variables\n        marketWrapper = IMarketWrapper(_marketWrapper);\n        nftContract = IERC721Metadata(_nftContract);\n        tokenId = _tokenId;\n        auctionId = _auctionId;\n        name = _name;\n        symbol = _symbol;\n        // validate that party split won't retain the total token supply\n        uint256 _remainingBasisPoints = 10000 - TOKEN_FEE_BASIS_POINTS;\n        require(_splitBasisPoints < _remainingBasisPoints, \"PartyBid::initialize: basis points can't take 100%\");\n        // validate that a portion of the token supply is not being burned\n        if (_splitRecipient == address(0)) {\n            require(_splitBasisPoints == 0, \"PartyBid::initialize: can't send tokens to burn addr\");\n        }\n        splitBasisPoints = _splitBasisPoints;\n        splitRecipient = _splitRecipient;\n        // validate token exists\n        require(_getOwner() != address(0), \"PartyBid::initialize: NFT getOwner failed\");\n        // validate auction exists\n        require(\n            marketWrapper.auctionIdMatchesToken(\n                _auctionId,\n                _nftContract,\n                _tokenId\n            ),\n            \"PartyBid::initialize: auctionId doesn't match token\"\n        );\n    }","after":"function initialize(\n        address _marketWrapper,\n        address _nftContract,\n        uint256 _tokenId,\n        uint256 _auctionId,\n        address _splitRecipient,\n        uint256 _splitBasisPoints,\n        string calldata _name,\n        string calldata _symbol\n    ) external initializer {\n        // initialize ReentrancyGuard and ERC721Holder\n        __ReentrancyGuard_init();\n        __ERC721Holder_init();\n        // set storage variables\n        marketWrapper = IMarketWrapper(_marketWrapper);\n        nftContract = IERC721Metadata(_nftContract);\n        tokenId = _tokenId;\n        auctionId = _auctionId;\n        name = _name;\n        symbol = _symbol;\n        // validate that party split won't retain the total token supply\n        uint256 _remainingBasisPoints = 10000 - TOKEN_FEE_BASIS_POINTS;\n        require(_splitBasisPoints < _remainingBasisPoints, \"PartyBid::initialize: basis points can't take 100%\");\n        // validate that a portion of the token supply is not being burned\n        if (_splitRecipient == address(0)) {\n            require(_splitBasisPoints == 0, \"PartyBid::initialize: can't send tokens to burn addr\");\n        }\n        splitBasisPoints = _splitBasisPoints;\n        splitRecipient = _splitRecipient;\n        // validate token exists\n        require(_getOwner() != address(0), \"PartyBid::initialize: NFT getOwner failed\");\n        // validate auction exists\n        require(\n            marketWrapper.auctionIdMatchesToken(\n                _auctionId,\n                _nftContract,\n                _tokenId\n            ),\n            \"PartyBid::initialize: auctionId doesn't match token\"\n        );\n    }","contract":"PartyBid","time":0},{"type":"external-function ","before":"function emergencyCall(address _contract, bytes memory _calldata)\n    external\n    onlyPartyDAO\n    returns (bool _success, bytes memory _returnData)\n    {\n        (_success, _returnData) = _contract.call(_calldata);\n        require(_success, string(_returnData));\n    }","after":"function emergencyCall(address _contract, bytes calldata _calldata)\n    external\n    onlyPartyDAO\n    returns (bool _success, bytes memory _returnData)\n    {\n        (_success, _returnData) = _contract.call(_calldata);\n        require(_success, string(_returnData));\n    }","contract":"PartyBid","time":0},{"type":"external-function ","before":"function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }","after":"function onERC721Received(address, address, uint256, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }","contract":"PartyBid","time":0},{"type":"external-function ","before":"function startParty(\n        address _marketWrapper,\n        address _nftContract,\n        uint256 _tokenId,\n        uint256 _auctionId,\n        address _splitRecipient,\n        uint256 _splitBasisPoints,\n        string memory _name,\n        string memory _symbol\n    ) external returns (address partyBidProxy) {\n        bytes memory _initializationCalldata =\n        abi.encodeWithSignature(\n            \"initialize(address,address,uint256,uint256,address,uint256,string,string)\",\n            _marketWrapper,\n            _nftContract,\n            _tokenId,\n            _auctionId,\n            _splitRecipient,\n            _splitBasisPoints,\n            _name,\n            _symbol\n        );\n\n        partyBidProxy = address(\n            new InitializedProxy(\n                logic,\n                _initializationCalldata\n            )\n        );\n\n        deployedAt[partyBidProxy] = block.number;\n\n        emit PartyBidDeployed(\n            partyBidProxy,\n            msg.sender,\n            _nftContract,\n            _tokenId,\n            _marketWrapper,\n            _auctionId,\n            _splitRecipient,\n            _splitBasisPoints,\n            _name,\n            _symbol\n        );\n    }","after":"function startParty(\n        address _marketWrapper,\n        address _nftContract,\n        uint256 _tokenId,\n        uint256 _auctionId,\n        address _splitRecipient,\n        uint256 _splitBasisPoints,\n        string calldata _name,\n        string calldata _symbol\n    ) external returns (address partyBidProxy) {\n        bytes memory _initializationCalldata =\n        abi.encodeWithSignature(\n            \"initialize(address,address,uint256,uint256,address,uint256,string,string)\",\n            _marketWrapper,\n            _nftContract,\n            _tokenId,\n            _auctionId,\n            _splitRecipient,\n            _splitBasisPoints,\n            _name,\n            _symbol\n        );\n\n        partyBidProxy = address(\n            new InitializedProxy(\n                logic,\n                _initializationCalldata\n            )\n        );\n\n        deployedAt[partyBidProxy] = block.number;\n\n        emit PartyBidDeployed(\n            partyBidProxy,\n            msg.sender,\n            _nftContract,\n            _tokenId,\n            _marketWrapper,\n            _auctionId,\n            _splitRecipient,\n            _splitBasisPoints,\n            _name,\n            _symbol\n        );\n    }","contract":"PartyBidFactory","time":0}]}