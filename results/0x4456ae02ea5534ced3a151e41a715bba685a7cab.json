{"time":205,"results":[{"type":"external-function ","before":"   function safeMint(address to, string memory _tokenURI)\n    public\n    onlyOwner\n    returns (uint256)\n    {\n        uint256 tokenId = _tokenIdCounter.current();\n        _safeMint(to, tokenId);\n        _tokenURIs[tokenId] = _tokenURI;\n        _tokenIdCounter.increment();\n        return tokenId;\n  ","after":"   function safeMint(address to, string calldata _tokenURI)\n    public\n    onlyOwner\n    returns (uint256)\n    {\n        uint256 tokenId = _tokenIdCounter.current();\n        _safeMint(to, tokenId);\n        _tokenURIs[tokenId] = _tokenURI;\n        _tokenIdCounter.increment();\n        return tokenId;\n  ","contract":"NOIZDNFT","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"NOIZDNFT","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"NOIZDNFT","time":1},{"type":"external-function ","before":"   function withdrawInstant(\n\n        Withdrawal calldata withdrawal,\n\n        bytes memory signature\n\n    )\n\n    external\n\n    nonReentrant\n\n    whenNotPaused\n\n    {\n\n        require(withdrawal.staker == msg.sender, \"The signature must be for the calling account\");\n\n        bytes32 digest = _hashTypedDataV4(\n\n            keccak256(\n\n                abi.encode(\n\n                    WITHDRAWAL_TYPEHASH,\n\n                    withdrawal.amount,\n\n                    withdrawal.deadline,\n\n                    withdrawal.nonce,\n\n                    withdrawal.staker\n\n                )\n\n            ));\n\n        address signer = ECDSA.recover(digest, signature);\n\n        require(\n\n            signer == owner(),\n\n            \"The signature must be signed by the owner of the contract.\"\n\n        );\n\n\n        _withdrawInstant(\n\n            withdrawal.nonce,\n\n            withdrawal.staker,\n\n            withdrawal.amount,\n\n            withdrawal.deadline\n\n        );\n\n  ","after":"   function withdrawInstant(\n\n        Withdrawal calldata withdrawal,\n\n        bytes calldata signature\n\n    )\n\n    external\n\n    nonReentrant\n\n    whenNotPaused\n\n    {\n\n        require(withdrawal.staker == msg.sender, \"The signature must be for the calling account\");\n\n        bytes32 digest = _hashTypedDataV4(\n\n            keccak256(\n\n                abi.encode(\n\n                    WITHDRAWAL_TYPEHASH,\n\n                    withdrawal.amount,\n\n                    withdrawal.deadline,\n\n                    withdrawal.nonce,\n\n                    withdrawal.staker\n\n                )\n\n            ));\n\n        address signer = ECDSA.recover(digest, signature);\n\n        require(\n\n            signer == owner(),\n\n            \"The signature must be signed by the owner of the contract.\"\n\n        );\n\n\n        _withdrawInstant(\n\n            withdrawal.nonce,\n\n            withdrawal.staker,\n\n            withdrawal.amount,\n\n            withdrawal.deadline\n\n        );\n\n  ","contract":"NOIZDStaking","time":0},{"type":"external-function ","before":"   function complete(\n\n        Bid calldata bid,\n\n        string memory _tokenURI,\n\n        bytes memory signature\n\n    )\n\n    external\n\n    onlyOwner\n\n    nonReentrant\n\n    whenNotPaused\n\n    {\n\n        require(!listings[bid.listing], \"The listing has already been minted.\");\n\n\n        bytes32 digest = _hashTypedDataV4(\n\n            keccak256(\n\n                abi.encode(\n\n                    BID_TYPEHASH,\n\n                    bid.listing,\n\n                    bid.staker,\n\n                    bid.target,\n\n                    bid.amount\n\n                )\n\n            )\n\n        );\n\n        address signer = ECDSA.recover(digest, signature);\n\n\n        require(\n\n            signer == bid.staker,\n\n            \"The signature must be signed by the staker.\"\n\n        );\n\n\n        _transfer(\n\n            nonces[bid.staker],\n\n            bid.listing,\n\n            bid.staker,\n\n            bid.target,\n\n            bid.amount\n\n        );\n\n\n        nft.safeMint(bid.staker, _tokenURI);\n\n  ","after":"   function complete(\n\n        Bid calldata bid,\n\n        string calldata _tokenURI,\n\n        bytes calldata signature\n\n    )\n\n    external\n\n    onlyOwner\n\n    nonReentrant\n\n    whenNotPaused\n\n    {\n\n        require(!listings[bid.listing], \"The listing has already been minted.\");\n\n\n        bytes32 digest = _hashTypedDataV4(\n\n            keccak256(\n\n                abi.encode(\n\n                    BID_TYPEHASH,\n\n                    bid.listing,\n\n                    bid.staker,\n\n                    bid.target,\n\n                    bid.amount\n\n                )\n\n            )\n\n        );\n\n        address signer = ECDSA.recover(digest, signature);\n\n\n        require(\n\n            signer == bid.staker,\n\n            \"The signature must be signed by the staker.\"\n\n        );\n\n\n        _transfer(\n\n            nonces[bid.staker],\n\n            bid.listing,\n\n            bid.staker,\n\n            bid.target,\n\n            bid.amount\n\n        );\n\n\n        nft.safeMint(bid.staker, _tokenURI);\n\n  ","contract":"NOIZDStaking","time":0},{"type":"constant-restrict-modification  ","before":"   uint32 public expectedTransferGasCost = 2443","after":"   uint32 public constant expectedTransferGasCost = 2443","contract":"NOIZDStaking","time":0}]}