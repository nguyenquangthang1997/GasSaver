{"time":205,"results":[{"type":"external-function ","before":"function tokenFallback(address _from, uint _value, bytes memory _data) mutex public override returns (bool ok) {\n\n        // block transfers if the recipient only allows kyc input, check other factors\n\n        require(onlyAcceptsKycInput[_from] == false);\n\n\n        IShyftKycContractRegistry contractRegistry = IShyftKycContractRegistry(shyftKycContractRegistryAddress);\n\n\n        // if kyc registry exists, check if only using a known kyc contract communication cycle, then verify the message\n\n        // sender is a kyc contract.\n\n        if (shyftKycContractRegistryAddress != address(0) && contractRegistry.isShyftKycContract(address(msg.sender)) == true) {\n\n            revert(\"cannot process fallback from Shyft Kyc Contract in this version of Shyft Core\");\n\n        }\n\n\n        uint256 bip32X_type;\n\n\n        bytes4 tokenSig;\n\n\n        //make sure we have enough bytes to determine a signature\n\n        if (_data.length >= 4) {\n\n            tokenSig = bytes4(uint32(bytes4(bytes1(_data[3])) >> 24) + uint32(bytes4(bytes1(_data[2])) >> 16) + uint32(bytes4(bytes1(_data[1])) >> 8) + uint32(bytes4(bytes1(_data[0]))));\n\n        }\n\n\n        //@note: for token indexing, we use higher range addressable space (256 bit integer).\n\n        // this guarantees practically infinite indexes.\n\n        //@note: using msg.sender in the keccak hash since msg.sender in this case (should) be the\n\n        // contract itself (and allowing this to be passed in, instead of using msg.sender, does not\n\n        // suffice as any contract could then call this fallback.)\n\n        //\n\n        // thus, this fallback will not function properly with abstracted synthetics.\n\n        bip32X_type = uint256(keccak256(abi.encodePacked(nativeBip32X_type, msg.sender)));\n\n        balances[_from][bip32X_type] = balances[_from][bip32X_type].add(_value);\n\n\n        emit EVT_Bip32X_TypeTokenFallback(msg.sender, _from, _value, nativeBip32X_type, bip32X_type);\n\n        emit EVT_TransferAndMintBip32X_type(msg.sender, _from, _value, bip32X_type);\n\n\n        ok = true;\n\n\n        if (ok == true) {\n\n            emit EVT_Erc223TokenFallback(_from, _value, _data);\n\n        }\n\n    }","after":"function tokenFallback(address _from, uint _value, bytes calldata _data) mutex public override returns (bool ok) {\n\n        // block transfers if the recipient only allows kyc input, check other factors\n\n        require(onlyAcceptsKycInput[_from] == false);\n\n\n        IShyftKycContractRegistry contractRegistry = IShyftKycContractRegistry(shyftKycContractRegistryAddress);\n\n\n        // if kyc registry exists, check if only using a known kyc contract communication cycle, then verify the message\n\n        // sender is a kyc contract.\n\n        if (shyftKycContractRegistryAddress != address(0) && contractRegistry.isShyftKycContract(address(msg.sender)) == true) {\n\n            revert(\"cannot process fallback from Shyft Kyc Contract in this version of Shyft Core\");\n\n        }\n\n\n        uint256 bip32X_type;\n\n\n        bytes4 tokenSig;\n\n\n        //make sure we have enough bytes to determine a signature\n\n        if (_data.length >= 4) {\n\n            tokenSig = bytes4(uint32(bytes4(bytes1(_data[3])) >> 24) + uint32(bytes4(bytes1(_data[2])) >> 16) + uint32(bytes4(bytes1(_data[1])) >> 8) + uint32(bytes4(bytes1(_data[0]))));\n\n        }\n\n\n        //@note: for token indexing, we use higher range addressable space (256 bit integer).\n\n        // this guarantees practically infinite indexes.\n\n        //@note: using msg.sender in the keccak hash since msg.sender in this case (should) be the\n\n        // contract itself (and allowing this to be passed in, instead of using msg.sender, does not\n\n        // suffice as any contract could then call this fallback.)\n\n        //\n\n        // thus, this fallback will not function properly with abstracted synthetics.\n\n        bip32X_type = uint256(keccak256(abi.encodePacked(nativeBip32X_type, msg.sender)));\n\n        balances[_from][bip32X_type] = balances[_from][bip32X_type].add(_value);\n\n\n        emit EVT_Bip32X_TypeTokenFallback(msg.sender, _from, _value, nativeBip32X_type, bip32X_type);\n\n        emit EVT_TransferAndMintBip32X_type(msg.sender, _from, _value, bip32X_type);\n\n\n        ok = true;\n\n\n        if (ok == true) {\n\n            emit EVT_Erc223TokenFallback(_from, _value, _data);\n\n        }\n\n    }","contract":"ShyftKycContract","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) mutex public override returns (bool ok) {\n\n        // block transfers if the recipient only allows kyc input, check other factors\n\n        if (onlyAcceptsKycInput[_to] == false && balances[msg.sender][ShyftTokenType] >= _value) {\n\n            uint codeLength;\n\n\n            //retrieve the size of the code on target address, this needs assembly\n\n            assembly {\n\n                codeLength := extcodesize(_to)\n\n            }\n\n\n            balances[msg.sender][ShyftTokenType] = balances[msg.sender][ShyftTokenType].sub(_value);\n\n\n            balances[_to][ShyftTokenType] = balances[_to][ShyftTokenType].add(_value);\n\n\n            if (codeLength > 0) {\n\n                IErc223ReceivingContract receiver = IErc223ReceivingContract(_to);\n\n                if (receiver.tokenFallback(msg.sender, _value, _data) == true) {\n\n                    ok = true;\n\n                } else {\n\n                    //@note: must revert() due to asset transactions already having occurred.\n\n                    revert();\n\n                }\n\n            } else {\n\n                ok = true;\n\n            }\n\n        }\n\n\n        if (ok == true) {\n\n            emit Transfer(msg.sender, _to, _value, _data);\n\n        }\n\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) mutex public override returns (bool ok) {\n\n        // block transfers if the recipient only allows kyc input, check other factors\n\n        if (onlyAcceptsKycInput[_to] == false && balances[msg.sender][ShyftTokenType] >= _value) {\n\n            uint codeLength;\n\n\n            //retrieve the size of the code on target address, this needs assembly\n\n            assembly {\n\n                codeLength := extcodesize(_to)\n\n            }\n\n\n            balances[msg.sender][ShyftTokenType] = balances[msg.sender][ShyftTokenType].sub(_value);\n\n\n            balances[_to][ShyftTokenType] = balances[_to][ShyftTokenType].add(_value);\n\n\n            if (codeLength > 0) {\n\n                IErc223ReceivingContract receiver = IErc223ReceivingContract(_to);\n\n                if (receiver.tokenFallback(msg.sender, _value, _data) == true) {\n\n                    ok = true;\n\n                } else {\n\n                    //@note: must revert() due to asset transactions already having occurred.\n\n                    revert();\n\n                }\n\n            } else {\n\n                ok = true;\n\n            }\n\n        }\n\n\n        if (ok == true) {\n\n            emit Transfer(msg.sender, _to, _value, _data);\n\n        }\n\n    }","contract":"ShyftKycContract","time":0},{"type":"constant-restrict-modification  ","before":"bytes4 shyftKycContractTokenUpgradeSig = bytes4(keccak256(\"updateShyftToken(address,uint256,uint256)\"));","after":"bytes4 constant shyftKycContractTokenUpgradeSig = bytes4(keccak256(\"updateShyftToken(address,uint256,uint256)\"));","contract":"ShyftKycContract","time":1},{"type":"immutable-restrict-modification ","before":"uint256 nativeBip32X_type;","after":"uint256 immutable nativeBip32X_type;","contract":"ShyftKycContract","time":1}]}