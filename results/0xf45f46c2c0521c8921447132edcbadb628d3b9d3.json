{"time":873,"results":[{"type":"struct-data-arrangement ","before":"\naddress collateralAsset\naddress borrowAsset\nuint64 collateralID\nuint64 borrowID","after":"address collateralAsset\naddress borrowAsset\nuint64 collateralID\nuint64 borrowID\n","contract":"IVaultExt","time":1},{"type":"constant-restrict-modification  ","before":"address private immutable _aaveLendingPool = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;","after":"address private immutable constant _aaveLendingPool = 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9;","contract":"Flasher","time":0},{"type":"constant-restrict-modification  ","before":"address private immutable _dydxSoloMargin = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;","after":"address private immutable constant _dydxSoloMargin = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;","contract":"Flasher","time":0},{"type":"struct-data-arrangement ","before":"\naddress collateralAsset\naddress borrowAsset\nuint64 collateralID\nuint64 borrowID","after":"address collateralAsset\naddress borrowAsset\nuint64 collateralID\nuint64 borrowID\n","contract":"IVaultExt","time":0},{"type":"loop-duplication","before":"\nstart line 1303 column 8, end line 1328 column 8\nfor (uint256 i = 0; i < formattedUserAddrs.length; i += 2) {\n\n            // Compute Amount of Minimum Collateral Required including factors\n\n            neededCollateral = IVault(_vault).getNeededCollateralFor(usrsBals[i + 1], true);\n\n\n            // Check if User is liquidatable\n\n            if (usrsBals[i] < neededCollateral) {\n\n                // If true, add User debt balance to the total balance to be liquidated\n\n                debtBalanceTotal = debtBalanceTotal.add(usrsBals[i + 1]);\n\n            } else {\n\n                // Replace User that is not liquidatable by Zero Address\n\n                formattedUserAddrs[i] = address(0);\n\n                formattedUserAddrs[i + 1] = address(0);\n\n            }\n\n        }\nstart line 1403 column 8, end line 1413 column 8\nfor (uint256 i = 0; i < formattedUserAddrs.length; i += 2) {\n\n            if (formattedUserAddrs[i] != address(0)) {\n\n                f1155.burn(formattedUserAddrs[i], vAssets.borrowID, usrsBals[i + 1]);\n\n                emit Liquidate(formattedUserAddrs[i], msg.sender, vAssets.borrowAsset, usrsBals[i + 1]);\n\n            }\n\n        }","after":"// merge loop\n\nstart line 1303 column 8, end line 1328 column 8\nfor (uint256 i = 0; i < formattedUserAddrs.length; i += 2) {\n\n            // Compute Amount of Minimum Collateral Required including factors\n\n            neededCollateral = IVault(_vault).getNeededCollateralFor(usrsBals[i + 1], true);\n\n\n            // Check if User is liquidatable\n\n            if (usrsBals[i] < neededCollateral) {\n\n                // If true, add User debt balance to the total balance to be liquidated\n\n                debtBalanceTotal = debtBalanceTotal.add(usrsBals[i + 1]);\n\n            } else {\n\n                // Replace User that is not liquidatable by Zero Address\n\n                formattedUserAddrs[i] = address(0);\n\n                formattedUserAddrs[i + 1] = address(0);\n\n            }\n\n        }\nstart line 1403 column 8, end line 1413 column 8\nfor (uint256 i = 0; i < formattedUserAddrs.length; i += 2) {\n\n            if (formattedUserAddrs[i] != address(0)) {\n\n                f1155.burn(formattedUserAddrs[i], vAssets.borrowID, usrsBals[i + 1]);\n\n                emit Liquidate(formattedUserAddrs[i], msg.sender, vAssets.borrowAsset, usrsBals[i + 1]);\n\n            }\n\n        }","contract":"Fliquidator","time":0},{"type":"external-function ","before":"function mint(\n        address _account,\n        uint256 _id,\n        uint256 _amount,\n        bytes memory _data\n    ) external override onlyPermit {\n        require(_account != address(0), Errors.VL_ZERO_ADDR_1155);\n\n        address operator = _msgSender();\n\n        uint256 accountBalance = _balances[_id][_account];\n        uint256 assetTotalBalance = _totalSupply[_id];\n        uint256 amountScaled = _amount.rayDiv(indexes[_id]);\n\n        require(amountScaled != 0, Errors.VL_INVALID_MINT_AMOUNT);\n\n        _balances[_id][_account] = accountBalance.add(amountScaled);\n        _totalSupply[_id] = assetTotalBalance.add(amountScaled);\n\n        emit TransferSingle(operator, address(0), _account, _id, _amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), _account, _id, _amount, _data);\n    }","after":"function mint(\n        address _account,\n        uint256 _id,\n        uint256 _amount,\n        bytes calldata _data\n    ) external override onlyPermit {\n        require(_account != address(0), Errors.VL_ZERO_ADDR_1155);\n\n        address operator = _msgSender();\n\n        uint256 accountBalance = _balances[_id][_account];\n        uint256 assetTotalBalance = _totalSupply[_id];\n        uint256 amountScaled = _amount.rayDiv(indexes[_id]);\n\n        require(amountScaled != 0, Errors.VL_INVALID_MINT_AMOUNT);\n\n        _balances[_id][_account] = accountBalance.add(amountScaled);\n        _totalSupply[_id] = assetTotalBalance.add(amountScaled);\n\n        emit TransferSingle(operator, address(0), _account, _id, _amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), _account, _id, _amount, _data);\n    }","contract":"FujiERC1155","time":0},{"type":"external-function ","before":"function mintBatch(\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _amounts,\n        bytes memory _data\n    ) external onlyPermit {\n        require(_to != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(_ids.length == _amounts.length, Errors.VL_INPUT_ERROR);\n\n        address operator = _msgSender();\n\n        uint256 accountBalance;\n        uint256 assetTotalBalance;\n        uint256 amountScaled;\n\n        for (uint256 i = 0; i < _ids.length; i++) {\n            accountBalance = _balances[_ids[i]][_to];\n            assetTotalBalance = _totalSupply[_ids[i]];\n\n            amountScaled = _amounts[i].rayDiv(indexes[_ids[i]]);\n\n            require(amountScaled != 0, Errors.VL_INVALID_MINT_AMOUNT);\n\n            _balances[_ids[i]][_to] = accountBalance.add(amountScaled);\n            _totalSupply[_ids[i]] = assetTotalBalance.add(amountScaled);\n        }\n\n        emit TransferBatch(operator, address(0), _to, _ids, _amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), _to, _ids, _amounts, _data);\n    }","after":"function mintBatch(\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts,\n        bytes calldata _data\n    ) external onlyPermit {\n        require(_to != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(_ids.length == _amounts.length, Errors.VL_INPUT_ERROR);\n\n        address operator = _msgSender();\n\n        uint256 accountBalance;\n        uint256 assetTotalBalance;\n        uint256 amountScaled;\n\n        for (uint256 i = 0; i < _ids.length; i++) {\n            accountBalance = _balances[_ids[i]][_to];\n            assetTotalBalance = _totalSupply[_ids[i]];\n\n            amountScaled = _amounts[i].rayDiv(indexes[_ids[i]]);\n\n            require(amountScaled != 0, Errors.VL_INVALID_MINT_AMOUNT);\n\n            _balances[_ids[i]][_to] = accountBalance.add(amountScaled);\n            _totalSupply[_ids[i]] = assetTotalBalance.add(amountScaled);\n        }\n\n        emit TransferBatch(operator, address(0), _to, _ids, _amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), _to, _ids, _amounts, _data);\n    }","contract":"FujiERC1155","time":0},{"type":"external-function ","before":"function burnBatch(\n        address _account,\n        uint256[] memory _ids,\n        uint256[] memory _amounts\n    ) external onlyPermit {\n        require(_account != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(_ids.length == _amounts.length, Errors.VL_INPUT_ERROR);\n\n        address operator = _msgSender();\n\n        uint256 accountBalance;\n        uint256 assetTotalBalance;\n        uint256 amountScaled;\n\n        for (uint256 i = 0; i < _ids.length; i++) {\n            uint256 amount = _amounts[i];\n\n            accountBalance = _balances[_ids[i]][_account];\n            assetTotalBalance = _totalSupply[_ids[i]];\n\n            amountScaled = _amounts[i].rayDiv(indexes[_ids[i]]);\n\n            require(amountScaled != 0 && accountBalance >= amountScaled, Errors.VL_INVALID_BURN_AMOUNT);\n\n            _balances[_ids[i]][_account] = accountBalance.sub(amount);\n            _totalSupply[_ids[i]] = assetTotalBalance.sub(amount);\n        }\n\n        emit TransferBatch(operator, _account, address(0), _ids, _amounts);\n    }","after":"function burnBatch(\n        address _account,\n        uint256[] calldata _ids,\n        uint256[] calldata _amounts\n    ) external onlyPermit {\n        require(_account != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(_ids.length == _amounts.length, Errors.VL_INPUT_ERROR);\n\n        address operator = _msgSender();\n\n        uint256 accountBalance;\n        uint256 assetTotalBalance;\n        uint256 amountScaled;\n\n        for (uint256 i = 0; i < _ids.length; i++) {\n            uint256 amount = _amounts[i];\n\n            accountBalance = _balances[_ids[i]][_account];\n            assetTotalBalance = _totalSupply[_ids[i]];\n\n            amountScaled = _amounts[i].rayDiv(indexes[_ids[i]]);\n\n            require(amountScaled != 0 && accountBalance >= amountScaled, Errors.VL_INVALID_BURN_AMOUNT);\n\n            _balances[_ids[i]][_account] = accountBalance.sub(amount);\n            _totalSupply[_ids[i]] = assetTotalBalance.sub(amount);\n        }\n\n        emit TransferBatch(operator, _account, address(0), _ids, _amounts);\n    }","contract":"FujiERC1155","time":0},{"type":"external-function ","before":"function setURI(string memory _newUri) public onlyOwner {\n        _uri = _newUri;\n    }","after":"function setURI(string calldata _newUri) public onlyOwner {\n        _uri = _newUri;\n    }","contract":"FujiERC1155","time":0},{"type":"external-function ","before":"function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n    public\n    view\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, Errors.VL_INPUT_ERROR);\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","after":"function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n    public\n    view\n    override\n    returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, Errors.VL_INPUT_ERROR);\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }","contract":"FujiERC1155","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override isTransferActive {\n        require(to != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            Errors.VL_MISSING_ERC1155_APPROVAL\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            from,\n            to,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, Errors.VL_NO_ERC1155_BALANCE);\n\n        _balances[id][from] = fromBalance.sub(amount);\n        _balances[id][to] = uint256(_balances[id][to]).add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override isTransferActive {\n        require(to != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            Errors.VL_MISSING_ERC1155_APPROVAL\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            from,\n            to,\n            _asSingletonArray(id),\n            _asSingletonArray(amount),\n            data\n        );\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, Errors.VL_NO_ERC1155_BALANCE);\n\n        _balances[id][from] = fromBalance.sub(amount);\n        _balances[id][to] = uint256(_balances[id][to]).add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"FujiERC1155","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override isTransferActive {\n        require(ids.length == amounts.length, Errors.VL_INPUT_ERROR);\n        require(to != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            Errors.VL_MISSING_ERC1155_APPROVAL\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, Errors.VL_NO_ERC1155_BALANCE);\n            _balances[id][from] = fromBalance.sub(amount);\n            _balances[id][to] = uint256(_balances[id][to]).add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override isTransferActive {\n        require(ids.length == amounts.length, Errors.VL_INPUT_ERROR);\n        require(to != address(0), Errors.VL_ZERO_ADDR_1155);\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            Errors.VL_MISSING_ERC1155_APPROVAL\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, Errors.VL_NO_ERC1155_BALANCE);\n            _balances[id][from] = fromBalance.sub(amount);\n            _balances[id][to] = uint256(_balances[id][to]).add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"FujiERC1155","time":0},{"type":"constant-restrict-modification  ","before":"bool public transfersActive;","after":"bool public constant transfersActive;","contract":"FujiERC1155","time":1},{"type":"constant-restrict-modification  ","before":"bool public donothing = true;","after":"bool public constant donothing = true;","contract":"ProviderDYDX","time":0},{"type":"struct-data-arrangement ","before":"\naddress collateralAsset\naddress borrowAsset\nuint64 collateralID\nuint64 borrowID","after":"address collateralAsset\naddress borrowAsset\nuint64 collateralID\nuint64 borrowID\n","contract":"VaultControl","time":0},{"type":"loop-duplication","before":"\nstart line 6015 column 8, end line 6017 column 8\nfor (uint256 i = 0; i < length; i++) {\n            borrowBals = borrowBals.add(IProvider(providers[i]).getBorrowBalance(vAssets.borrowAsset));\n        }\nstart line 6018 column 8, end line 6022 column 8\nfor (uint256 i = 0; i < length; i++) {\n            depositBals = depositBals.add(\n                IProvider(providers[i]).getDepositBalance(vAssets.collateralAsset)\n            );\n        }","after":"// merge loop\n\nstart line 6015 column 8, end line 6017 column 8\nfor (uint256 i = 0; i < length; i++) {\n            borrowBals = borrowBals.add(IProvider(providers[i]).getBorrowBalance(vAssets.borrowAsset));\n        }\nstart line 6018 column 8, end line 6022 column 8\nfor (uint256 i = 0; i < length; i++) {\n            depositBals = depositBals.add(\n                IProvider(providers[i]).getDepositBalance(vAssets.collateralAsset)\n            );\n        }","contract":"VaultETHDAI","time":0},{"type":"loop-duplication","before":"\nstart line 6492 column 8, end line 6494 column 8\nfor (uint256 i = 0; i < length; i++) {\n            borrowBals = borrowBals.add(IProvider(providers[i]).getBorrowBalance(vAssets.borrowAsset));\n        }\nstart line 6495 column 8, end line 6499 column 8\nfor (uint256 i = 0; i < length; i++) {\n            depositBals = depositBals.add(\n                IProvider(providers[i]).getDepositBalance(vAssets.collateralAsset)\n            );\n        }","after":"// merge loop\n\nstart line 6492 column 8, end line 6494 column 8\nfor (uint256 i = 0; i < length; i++) {\n            borrowBals = borrowBals.add(IProvider(providers[i]).getBorrowBalance(vAssets.borrowAsset));\n        }\nstart line 6495 column 8, end line 6499 column 8\nfor (uint256 i = 0; i < length; i++) {\n            depositBals = depositBals.add(\n                IProvider(providers[i]).getDepositBalance(vAssets.collateralAsset)\n            );\n        }","contract":"VaultETHUSDC","time":0},{"type":"loop-duplication","before":"\nstart line 6969 column 8, end line 6971 column 8\nfor (uint256 i = 0; i < length; i++) {\n            borrowBals = borrowBals.add(IProvider(providers[i]).getBorrowBalance(vAssets.borrowAsset));\n        }\nstart line 6972 column 8, end line 6976 column 8\nfor (uint256 i = 0; i < length; i++) {\n            depositBals = depositBals.add(\n                IProvider(providers[i]).getDepositBalance(vAssets.collateralAsset)\n            );\n        }","after":"// merge loop\n\nstart line 6969 column 8, end line 6971 column 8\nfor (uint256 i = 0; i < length; i++) {\n            borrowBals = borrowBals.add(IProvider(providers[i]).getBorrowBalance(vAssets.borrowAsset));\n        }\nstart line 6972 column 8, end line 6976 column 8\nfor (uint256 i = 0; i < length; i++) {\n            depositBals = depositBals.add(\n                IProvider(providers[i]).getDepositBalance(vAssets.collateralAsset)\n            );\n        }","contract":"VaultETHUSDT","time":0}]}