{"time":404,"results":[{"type":"external-function ","before":"function setAddress(\n        string memory _name,\n        address _address\n    )\n    external\n    onlyOwner\n    {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(\n            _name,\n            _address,\n            oldAddress\n        );\n    }","after":"function setAddress(\n        string calldata _name,\n        address _address\n    )\n    external\n    onlyOwner\n    {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(\n            _name,\n            _address,\n            oldAddress\n        );\n    }","contract":"Lib_AddressManager","time":0},{"type":"external-function ","before":"function getAddress(\n        string memory _name\n    )\n    external\n    view\n    returns (\n        address\n    )\n    {\n        return addresses[_getNameHash(_name)];\n    }","after":"function getAddress(\n        string calldata _name\n    )\n    external\n    view\n    returns (\n        address\n    )\n    {\n        return addresses[_getNameHash(_name)];\n    }","contract":"Lib_AddressManager","time":0},{"type":"loop-calculation","before":"uint256 listPtr;","after":"// move outside for loop\nuint256 listPtr;","loc":{"start":{"line":2169,"column":12},"end":{"line":2169,"column":27}},"contract":"Lib_RLPWriter","time":0},{"type":"loop-calculation","before":"uint256 txDataLength;","after":"// move outside for loop\nuint256 txDataLength;","loc":{"start":{"line":2689,"column":16},"end":{"line":2689,"column":36}},"contract":"OVM_CanonicalTransactionChain","time":0},{"type":"external-function ","before":"function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    )\n    override\n    public\n    {\n        require(\n            _data.length <= MAX_ROLLUP_TX_SIZE,\n            \"Transaction data size exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit <= maxTransactionGasLimit,\n            \"Transaction gas limit exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit >= MIN_ROLLUP_TX_GAS,\n            \"Transaction gas limit too low to enqueue.\"\n        );\n\n        // We need to consume some amount of L1 gas in order to rate limit transactions going into\n        // L2. However, L2 is cheaper than L1 so we only need to burn some small proportion of the\n        // provided L1 gas.\n        uint256 gasToConsume = _gasLimit / L2_GAS_DISCOUNT_DIVISOR;\n        uint256 startingGas = gasleft();\n\n        // Although this check is not necessary (burn below will run out of gas if not true), it\n        // gives the user an explicit reason as to why the enqueue attempt failed.\n        require(\n            startingGas > gasToConsume,\n            \"Insufficient gas for L2 rate limiting burn.\"\n        );\n\n        // Here we do some \"dumb\" work in order to burn gas, although we should probably replace\n        // this with something like minting gas token later on.\n        uint256 i;\n        while (startingGas - gasleft() < gasToConsume) {\n            i++;\n        }\n\n        bytes32 transactionHash = keccak256(\n            abi.encode(\n                msg.sender,\n                _target,\n                _gasLimit,\n                _data\n            )\n        );\n\n        bytes32 timestampAndBlockNumber;\n        assembly {\n            timestampAndBlockNumber := timestamp()\n            timestampAndBlockNumber := or(timestampAndBlockNumber, shl(40, number()))\n        }\n\n        iOVM_ChainStorageContainer queueRef = queue();\n\n        queueRef.push(transactionHash);\n        queueRef.push(timestampAndBlockNumber);\n\n        // The underlying queue data structure stores 2 elements\n        // per insertion, so to get the real queue length we need\n        // to divide by 2 and subtract 1.\n        uint256 queueIndex = queueRef.length() / 2 - 1;\n        emit TransactionEnqueued(\n            msg.sender,\n            _target,\n            _gasLimit,\n            _data,\n            queueIndex,\n            block.timestamp\n        );\n    }","after":"function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes calldata _data\n    )\n    override\n    public\n    {\n        require(\n            _data.length <= MAX_ROLLUP_TX_SIZE,\n            \"Transaction data size exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit <= maxTransactionGasLimit,\n            \"Transaction gas limit exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit >= MIN_ROLLUP_TX_GAS,\n            \"Transaction gas limit too low to enqueue.\"\n        );\n\n        // We need to consume some amount of L1 gas in order to rate limit transactions going into\n        // L2. However, L2 is cheaper than L1 so we only need to burn some small proportion of the\n        // provided L1 gas.\n        uint256 gasToConsume = _gasLimit / L2_GAS_DISCOUNT_DIVISOR;\n        uint256 startingGas = gasleft();\n\n        // Although this check is not necessary (burn below will run out of gas if not true), it\n        // gives the user an explicit reason as to why the enqueue attempt failed.\n        require(\n            startingGas > gasToConsume,\n            \"Insufficient gas for L2 rate limiting burn.\"\n        );\n\n        // Here we do some \"dumb\" work in order to burn gas, although we should probably replace\n        // this with something like minting gas token later on.\n        uint256 i;\n        while (startingGas - gasleft() < gasToConsume) {\n            i++;\n        }\n\n        bytes32 transactionHash = keccak256(\n            abi.encode(\n                msg.sender,\n                _target,\n                _gasLimit,\n                _data\n            )\n        );\n\n        bytes32 timestampAndBlockNumber;\n        assembly {\n            timestampAndBlockNumber := timestamp()\n            timestampAndBlockNumber := or(timestampAndBlockNumber, shl(40, number()))\n        }\n\n        iOVM_ChainStorageContainer queueRef = queue();\n\n        queueRef.push(transactionHash);\n        queueRef.push(timestampAndBlockNumber);\n\n        // The underlying queue data structure stores 2 elements\n        // per insertion, so to get the real queue length we need\n        // to divide by 2 and subtract 1.\n        uint256 queueIndex = queueRef.length() / 2 - 1;\n        emit TransactionEnqueued(\n            msg.sender,\n            _target,\n            _gasLimit,\n            _data,\n            queueIndex,\n            block.timestamp\n        );\n    }","contract":"OVM_CanonicalTransactionChain","time":0},{"type":"external-function ","before":"function verifyTransaction(\n        Lib_OVMCodec.Transaction memory _transaction,\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _inclusionProof\n    )\n    override\n    public\n    view\n    returns (\n        bool\n    )\n    {\n        if (_txChainElement.isSequenced == true) {\n            return _verifySequencerTransaction(\n                _transaction,\n                _txChainElement,\n                _batchHeader,\n                _inclusionProof\n            );\n        } else {\n            return _verifyQueueTransaction(\n                _transaction,\n                _txChainElement.queueIndex,\n                _batchHeader,\n                _inclusionProof\n            );\n        }\n    }","after":"function verifyTransaction(\n        Lib_OVMCodec.Transaction calldata _transaction,\n        Lib_OVMCodec.TransactionChainElement calldata _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader calldata _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof calldata _inclusionProof\n    )\n    override\n    public\n    view\n    returns (\n        bool\n    )\n    {\n        if (_txChainElement.isSequenced == true) {\n            return _verifySequencerTransaction(\n                _transaction,\n                _txChainElement,\n                _batchHeader,\n                _inclusionProof\n            );\n        } else {\n            return _verifyQueueTransaction(\n                _transaction,\n                _txChainElement.queueIndex,\n                _batchHeader,\n                _inclusionProof\n            );\n        }\n    }","contract":"OVM_CanonicalTransactionChain","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public forceInclusionPeriodSeconds;","after":"uint256 public immutable forceInclusionPeriodSeconds;","contract":"OVM_CanonicalTransactionChain","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public forceInclusionPeriodBlocks;","after":"uint256 public immutable forceInclusionPeriodBlocks;","contract":"OVM_CanonicalTransactionChain","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public maxTransactionGasLimit;","after":"uint256 public immutable maxTransactionGasLimit;","contract":"OVM_CanonicalTransactionChain","time":1},{"type":"de-morgan-condition ","before":"!isAllowed || !success","after":"!(isAllowed || success)","loc":{"start":{"line":4566,"column":12},"end":{"line":4566,"column":27}},"contract":"OVM_ExecutionManager","time":0},{"type":"external-function ","before":"function run(\n        Lib_OVMCodec.Transaction memory _transaction,\n        address _ovmStateManager\n    )\n    override\n    external\n    returns (\n        bytes memory\n    )\n    {\n        // Make sure that run() is not re-enterable.  This condition should always be satisfied\n        // Once run has been called once, due to the behavior of _isValidInput().\n        if (transactionContext.ovmNUMBER != DEFAULT_UINT256) {\n            return bytes(\"\");\n        }\n\n        // Store our OVM_StateManager instance (significantly easier than attempting to pass the\n        // address around in calldata).\n        ovmStateManager = iOVM_StateManager(_ovmStateManager);\n\n        // Make sure this function can't be called by anyone except the owner of the\n        // OVM_StateManager (expected to be an OVM_StateTransitioner). We can revert here because\n        // this would make the `run` itself invalid.\n        require(\n        // This method may return false during fraud proofs, but always returns true in L2 nodes' State Manager precompile.\n            ovmStateManager.isAuthenticated(msg.sender),\n            \"Only authenticated addresses in ovmStateManager can call this function\"\n        );\n\n        // Initialize the execution context, must be initialized before we perform any gas metering\n        // or we'll throw a nuisance gas error.\n        _initContext(_transaction);\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Check whether we need to start a new epoch, do so if necessary.\n        // _checkNeedsNewEpoch(_transaction.timestamp);\n\n        // Make sure the transaction's gas limit is valid. We don't revert here because we reserve\n        // reverts for INVALID_STATE_ACCESS.\n        if (_isValidInput(_transaction) == false) {\n            _resetContext();\n            return bytes(\"\");\n        }\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Check gas right before the call to get total gas consumed by OVM transaction.\n        // uint256 gasProvided = gasleft();\n\n        // Run the transaction, make sure to meter the gas usage.\n        (, bytes memory returndata) = ovmCALL(\n            _transaction.gasLimit - gasMeterConfig.minTransactionGasLimit,\n            _transaction.entrypoint,\n            0,\n            _transaction.data\n        );\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Update the cumulative gas based on the amount of gas used.\n        // uint256 gasUsed = gasProvided - gasleft();\n        // _updateCumulativeGas(gasUsed, _transaction.l1QueueOrigin);\n\n        // Wipe the execution context.\n        _resetContext();\n\n        return returndata;\n    }","after":"function run(\n        Lib_OVMCodec.Transaction calldata _transaction,\n        address _ovmStateManager\n    )\n    override\n    external\n    returns (\n        bytes memory\n    )\n    {\n        // Make sure that run() is not re-enterable.  This condition should always be satisfied\n        // Once run has been called once, due to the behavior of _isValidInput().\n        if (transactionContext.ovmNUMBER != DEFAULT_UINT256) {\n            return bytes(\"\");\n        }\n\n        // Store our OVM_StateManager instance (significantly easier than attempting to pass the\n        // address around in calldata).\n        ovmStateManager = iOVM_StateManager(_ovmStateManager);\n\n        // Make sure this function can't be called by anyone except the owner of the\n        // OVM_StateManager (expected to be an OVM_StateTransitioner). We can revert here because\n        // this would make the `run` itself invalid.\n        require(\n        // This method may return false during fraud proofs, but always returns true in L2 nodes' State Manager precompile.\n            ovmStateManager.isAuthenticated(msg.sender),\n            \"Only authenticated addresses in ovmStateManager can call this function\"\n        );\n\n        // Initialize the execution context, must be initialized before we perform any gas metering\n        // or we'll throw a nuisance gas error.\n        _initContext(_transaction);\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Check whether we need to start a new epoch, do so if necessary.\n        // _checkNeedsNewEpoch(_transaction.timestamp);\n\n        // Make sure the transaction's gas limit is valid. We don't revert here because we reserve\n        // reverts for INVALID_STATE_ACCESS.\n        if (_isValidInput(_transaction) == false) {\n            _resetContext();\n            return bytes(\"\");\n        }\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Check gas right before the call to get total gas consumed by OVM transaction.\n        // uint256 gasProvided = gasleft();\n\n        // Run the transaction, make sure to meter the gas usage.\n        (, bytes memory returndata) = ovmCALL(\n            _transaction.gasLimit - gasMeterConfig.minTransactionGasLimit,\n            _transaction.entrypoint,\n            0,\n            _transaction.data\n        );\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Update the cumulative gas based on the amount of gas used.\n        // uint256 gasUsed = gasProvided - gasleft();\n        // _updateCumulativeGas(gasUsed, _transaction.l1QueueOrigin);\n\n        // Wipe the execution context.\n        _resetContext();\n\n        return returndata;\n    }","contract":"OVM_ExecutionManager","time":0},{"type":"external-function ","before":"function ovmCREATE2(\n        bytes memory _bytecode,\n        bytes32 _salt\n    )\n    override\n    external\n    notStatic\n    fixedGasDiscount(40000)\n    returns (\n        address,\n        bytes memory\n    )\n    {\n        // Creator is always the current ADDRESS.\n        address creator = ovmADDRESS();\n\n        // Check that the deployer is whitelisted, or\n        // that arbitrary contract deployment has been enabled.\n        _checkDeployerAllowed(creator);\n\n        // Generate the correct CREATE2 address.\n        address contractAddress = Lib_EthUtils.getAddressForCREATE2(\n            creator,\n            _bytecode,\n            _salt\n        );\n\n        return _createContract(\n            contractAddress,\n            _bytecode,\n            MessageType.ovmCREATE2\n        );\n    }","after":"function ovmCREATE2(\n        bytes calldata _bytecode,\n        bytes32 _salt\n    )\n    override\n    external\n    notStatic\n    fixedGasDiscount(40000)\n    returns (\n        address,\n        bytes memory\n    )\n    {\n        // Creator is always the current ADDRESS.\n        address creator = ovmADDRESS();\n\n        // Check that the deployer is whitelisted, or\n        // that arbitrary contract deployment has been enabled.\n        _checkDeployerAllowed(creator);\n\n        // Generate the correct CREATE2 address.\n        address contractAddress = Lib_EthUtils.getAddressForCREATE2(\n            creator,\n            _bytecode,\n            _salt\n        );\n\n        return _createContract(\n            contractAddress,\n            _bytecode,\n            MessageType.ovmCREATE2\n        );\n    }","contract":"OVM_ExecutionManager","time":0},{"type":"external-function ","before":"function ovmDELEGATECALL(\n        uint256 _gasLimit,\n        address _address,\n        bytes memory _calldata\n    )\n    override\n    public\n    fixedGasDiscount(40000)\n    returns (\n        bool _success,\n        bytes memory _returndata\n    )\n    {\n        // DELEGATECALL does not change anything about the message context.\n        MessageContext memory nextMessageContext = messageContext;\n\n        return _callContract(\n            nextMessageContext,\n            _gasLimit,\n            _address,\n            _calldata,\n            MessageType.ovmDELEGATECALL\n        );\n    }","after":"function ovmDELEGATECALL(\n        uint256 _gasLimit,\n        address _address,\n        bytes calldata _calldata\n    )\n    override\n    public\n    fixedGasDiscount(40000)\n    returns (\n        bool _success,\n        bytes memory _returndata\n    )\n    {\n        // DELEGATECALL does not change anything about the message context.\n        MessageContext memory nextMessageContext = messageContext;\n\n        return _callContract(\n            nextMessageContext,\n            _gasLimit,\n            _address,\n            _calldata,\n            MessageType.ovmDELEGATECALL\n        );\n    }","contract":"OVM_ExecutionManager","time":0},{"type":"external-function ","before":"function safeCREATE(\n        bytes memory _creationCode,\n        address _address\n    )\n    external\n    {\n        // The only way this should callable is from within _createContract(),\n        // and it should DEFINITELY not be callable by a non-EM code contract.\n        if (msg.sender != address(this)) {\n            return;\n        }\n        // Check that there is not already code at this address.\n        if (_hasEmptyAccount(_address) == false) {\n            // Note: in the EVM, this case burns all allotted gas.  For improved\n            // developer experience, we do return the remaining gas.\n            _revertWithFlag(\n                RevertFlag.CREATE_COLLISION\n            );\n        }\n\n        // Check the creation bytecode against the OVM_SafetyChecker.\n        if (ovmSafetyChecker.isBytecodeSafe(_creationCode) == false) {\n            // Note: in the EVM, this case burns all allotted gas.  For improved\n            // developer experience, we do return the remaining gas.\n            _revertWithFlag(\n                RevertFlag.UNSAFE_BYTECODE,\n                Lib_ErrorUtils.encodeRevertString(\"Contract creation code contains unsafe opcodes. Did you use the right compiler or pass an unsafe constructor argument?\")\n            );\n        }\n\n        // We always need to initialize the contract with the default account values.\n        _initPendingAccount(_address);\n\n        // Actually execute the EVM create message.\n        // NOTE: The inline assembly below means we can NOT make any evm calls between here and then.\n        address ethAddress = Lib_EthUtils.createContract(_creationCode);\n\n        if (ethAddress == address(0)) {\n            // If the creation fails, the EVM lets us grab its revert data. This may contain a revert flag\n            // to be used above in _handleExternalMessage, so we pass the revert data back up unmodified.\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // Again simply checking that the deployed code is safe too. Contracts can generate\n        // arbitrary deployment code, so there's no easy way to analyze this beforehand.\n        bytes memory deployedCode = Lib_EthUtils.getCode(ethAddress);\n        if (ovmSafetyChecker.isBytecodeSafe(deployedCode) == false) {\n            _revertWithFlag(\n                RevertFlag.UNSAFE_BYTECODE,\n                Lib_ErrorUtils.encodeRevertString(\"Constructor attempted to deploy unsafe bytecode.\")\n            );\n        }\n\n        // Contract creation didn't need to be reverted and the bytecode is safe. We finish up by\n        // associating the desired address with the newly created contract's code hash and address.\n        _commitPendingAccount(\n            _address,\n            ethAddress,\n            Lib_EthUtils.getCodeHash(ethAddress)\n        );\n    }","after":"function safeCREATE(\n        bytes calldata _creationCode,\n        address _address\n    )\n    external\n    {\n        // The only way this should callable is from within _createContract(),\n        // and it should DEFINITELY not be callable by a non-EM code contract.\n        if (msg.sender != address(this)) {\n            return;\n        }\n        // Check that there is not already code at this address.\n        if (_hasEmptyAccount(_address) == false) {\n            // Note: in the EVM, this case burns all allotted gas.  For improved\n            // developer experience, we do return the remaining gas.\n            _revertWithFlag(\n                RevertFlag.CREATE_COLLISION\n            );\n        }\n\n        // Check the creation bytecode against the OVM_SafetyChecker.\n        if (ovmSafetyChecker.isBytecodeSafe(_creationCode) == false) {\n            // Note: in the EVM, this case burns all allotted gas.  For improved\n            // developer experience, we do return the remaining gas.\n            _revertWithFlag(\n                RevertFlag.UNSAFE_BYTECODE,\n                Lib_ErrorUtils.encodeRevertString(\"Contract creation code contains unsafe opcodes. Did you use the right compiler or pass an unsafe constructor argument?\")\n            );\n        }\n\n        // We always need to initialize the contract with the default account values.\n        _initPendingAccount(_address);\n\n        // Actually execute the EVM create message.\n        // NOTE: The inline assembly below means we can NOT make any evm calls between here and then.\n        address ethAddress = Lib_EthUtils.createContract(_creationCode);\n\n        if (ethAddress == address(0)) {\n            // If the creation fails, the EVM lets us grab its revert data. This may contain a revert flag\n            // to be used above in _handleExternalMessage, so we pass the revert data back up unmodified.\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // Again simply checking that the deployed code is safe too. Contracts can generate\n        // arbitrary deployment code, so there's no easy way to analyze this beforehand.\n        bytes memory deployedCode = Lib_EthUtils.getCode(ethAddress);\n        if (ovmSafetyChecker.isBytecodeSafe(deployedCode) == false) {\n            _revertWithFlag(\n                RevertFlag.UNSAFE_BYTECODE,\n                Lib_ErrorUtils.encodeRevertString(\"Constructor attempted to deploy unsafe bytecode.\")\n            );\n        }\n\n        // Contract creation didn't need to be reverted and the bytecode is safe. We finish up by\n        // associating the desired address with the newly created contract's code hash and address.\n        _commitPendingAccount(\n            _address,\n            ethAddress,\n            Lib_EthUtils.getCodeHash(ethAddress)\n        );\n    }","contract":"OVM_ExecutionManager","time":0},{"type":"external-function ","before":"function simulateMessage(\n        Lib_OVMCodec.Transaction memory _transaction,\n        address _from,\n        uint256 _value,\n        iOVM_StateManager _ovmStateManager\n    )\n    external\n    returns (\n        bytes memory\n    )\n    {\n        // Prevent this call from having any effect unless in a custom-set VM frame\n        require(msg.sender == address(0));\n\n        // Initialize the EM's internal state, ignoring nuisance gas.\n        ovmStateManager = _ovmStateManager;\n        _initContext(_transaction);\n        messageRecord.nuisanceGasLeft = uint(- 1);\n\n        // Set the ovmADDRESS to the _from so that the subsequent call frame \"comes from\" them.\n        messageContext.ovmADDRESS = _from;\n\n        // Execute the desired message.\n        bool isCreate = _transaction.entrypoint == address(0);\n        if (isCreate) {\n            (address created, bytes memory revertData) = ovmCREATE(_transaction.data);\n            if (created == address(0)) {\n                return abi.encode(false, revertData);\n            } else {\n                // The eth_call RPC endpoint for to = undefined will return the deployed bytecode\n                // in the success case, differing from standard create messages.\n                return abi.encode(true, Lib_EthUtils.getCode(created));\n            }\n        } else {\n            (bool success, bytes memory returndata) = ovmCALL(\n                _transaction.gasLimit,\n                _transaction.entrypoint,\n                _value,\n                _transaction.data\n            );\n            return abi.encode(success, returndata);\n        }\n    }","after":"function simulateMessage(\n        Lib_OVMCodec.Transaction calldata _transaction,\n        address _from,\n        uint256 _value,\n        iOVM_StateManager _ovmStateManager\n    )\n    external\n    returns (\n        bytes memory\n    )\n    {\n        // Prevent this call from having any effect unless in a custom-set VM frame\n        require(msg.sender == address(0));\n\n        // Initialize the EM's internal state, ignoring nuisance gas.\n        ovmStateManager = _ovmStateManager;\n        _initContext(_transaction);\n        messageRecord.nuisanceGasLeft = uint(- 1);\n\n        // Set the ovmADDRESS to the _from so that the subsequent call frame \"comes from\" them.\n        messageContext.ovmADDRESS = _from;\n\n        // Execute the desired message.\n        bool isCreate = _transaction.entrypoint == address(0);\n        if (isCreate) {\n            (address created, bytes memory revertData) = ovmCREATE(_transaction.data);\n            if (created == address(0)) {\n                return abi.encode(false, revertData);\n            } else {\n                // The eth_call RPC endpoint for to = undefined will return the deployed bytecode\n                // in the success case, differing from standard create messages.\n                return abi.encode(true, Lib_EthUtils.getCode(created));\n            }\n        } else {\n            (bool success, bytes memory returndata) = ovmCALL(\n                _transaction.gasLimit,\n                _transaction.entrypoint,\n                _value,\n                _transaction.data\n            );\n            return abi.encode(success, returndata);\n        }\n    }","contract":"OVM_ExecutionManager","time":0},{"type":"struct-data-arrangement ","before":"\naddress ovmCALLER\naddress ovmADDRESS\nuint256 ovmCALLVALUE\nbool isStatic","after":"uint256 ovmCALLVALUE\naddress ovmCALLER\naddress ovmADDRESS\nbool isStatic\n","contract":"iOVM_ExecutionManager","time":0}]}