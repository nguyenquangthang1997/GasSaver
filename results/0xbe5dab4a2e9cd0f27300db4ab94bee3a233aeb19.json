{"time":372,"results":[{"type":"external-function ","before":"function setAddress(string memory _name, address _address) external onlyOwner {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(_name, _address, oldAddress);\n    }","after":"function setAddress(string calldata _name, address _address) external onlyOwner {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(_name, _address, oldAddress);\n    }","contract":"Lib_AddressManager","time":0},{"type":"external-function ","before":"function getAddress(string memory _name) external view returns (address) {\n        return addresses[_getNameHash(_name)];\n    }","after":"function getAddress(string calldata _name) external view returns (address) {\n        return addresses[_getNameHash(_name)];\n    }","contract":"Lib_AddressManager","time":0},{"type":"loop-calculation","before":"uint256 listPtr;","after":"// move outside for loop\nuint256 listPtr;","loc":{"start":{"line":1526,"column":12},"end":{"line":1526,"column":27}},"contract":"Lib_RLPWriter","time":0},{"type":"external-function ","before":"function appendStateBatch(bytes32[] memory _batch, uint256 _shouldStartAtElement) public {\n        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\n        // publication of batches by some other user.\n        require(\n            _shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );\n\n        // Proposers must have previously staked at the BondManager\n        require(\n            IBondManager(resolve(\"BondManager\")).isCollateralized(msg.sender),\n            \"Proposer does not have enough collateral posted\"\n        );\n\n        require(_batch.length > 0, \"Cannot submit an empty state batch.\");\n\n        require(\n            getTotalElements() + _batch.length <=\n            ICanonicalTransactionChain(resolve(\"CanonicalTransactionChain\")).getTotalElements(),\n            \"Number of state roots cannot exceed the number of canonical transactions.\"\n        );\n\n        // Pass the block's timestamp and the publisher of the data\n        // to be used in the fraud proofs\n        _appendBatch(_batch, abi.encode(block.timestamp, msg.sender));\n    }","after":"function appendStateBatch(bytes32[] calldata _batch, uint256 _shouldStartAtElement) public {\n        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\n        // publication of batches by some other user.\n        require(\n            _shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );\n\n        // Proposers must have previously staked at the BondManager\n        require(\n            IBondManager(resolve(\"BondManager\")).isCollateralized(msg.sender),\n            \"Proposer does not have enough collateral posted\"\n        );\n\n        require(_batch.length > 0, \"Cannot submit an empty state batch.\");\n\n        require(\n            getTotalElements() + _batch.length <=\n            ICanonicalTransactionChain(resolve(\"CanonicalTransactionChain\")).getTotalElements(),\n            \"Number of state roots cannot exceed the number of canonical transactions.\"\n        );\n\n        // Pass the block's timestamp and the publisher of the data\n        // to be used in the fraud proofs\n        _appendBatch(_batch, abi.encode(block.timestamp, msg.sender));\n    }","contract":"StateCommitmentChain","time":0},{"type":"external-function ","before":"function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) public {\n        require(\n            msg.sender == resolve(\"OVM_FraudVerifier\"),\n            \"State batches can only be deleted by the OVM_FraudVerifier.\"\n        );\n\n        require(_isValidBatchHeader(_batchHeader), \"Invalid batch header.\");\n\n        require(\n            insideFraudProofWindow(_batchHeader),\n            \"State batches can only be deleted within the fraud proof window.\"\n        );\n\n        _deleteBatch(_batchHeader);\n    }","after":"function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader calldata _batchHeader) public {\n        require(\n            msg.sender == resolve(\"OVM_FraudVerifier\"),\n            \"State batches can only be deleted by the OVM_FraudVerifier.\"\n        );\n\n        require(_isValidBatchHeader(_batchHeader), \"Invalid batch header.\");\n\n        require(\n            insideFraudProofWindow(_batchHeader),\n            \"State batches can only be deleted within the fraud proof window.\"\n        );\n\n        _deleteBatch(_batchHeader);\n    }","contract":"StateCommitmentChain","time":0},{"type":"external-function ","before":"function verifyStateCommitment(\n        bytes32 _element,\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _proof\n    ) public view returns (bool) {\n        require(_isValidBatchHeader(_batchHeader), \"Invalid batch header.\");\n\n        require(\n            Lib_MerkleTree.verify(\n                _batchHeader.batchRoot,\n                _element,\n                _proof.index,\n                _proof.siblings,\n                _batchHeader.batchSize\n            ),\n            \"Invalid inclusion proof.\"\n        );\n\n        return true;\n    }","after":"function verifyStateCommitment(\n        bytes32 _element,\n        Lib_OVMCodec.ChainBatchHeader calldata _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof calldata _proof\n    ) public view returns (bool) {\n        require(_isValidBatchHeader(_batchHeader), \"Invalid batch header.\");\n\n        require(\n            Lib_MerkleTree.verify(\n                _batchHeader.batchRoot,\n                _element,\n                _proof.index,\n                _proof.siblings,\n                _batchHeader.batchSize\n            ),\n            \"Invalid inclusion proof.\"\n        );\n\n        return true;\n    }","contract":"StateCommitmentChain","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public FRAUD_PROOF_WINDOW;","after":"uint256 public immutable FRAUD_PROOF_WINDOW;","contract":"StateCommitmentChain","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public SEQUENCER_PUBLISH_WINDOW;","after":"uint256 public immutable SEQUENCER_PUBLISH_WINDOW;","contract":"StateCommitmentChain","time":0}]}