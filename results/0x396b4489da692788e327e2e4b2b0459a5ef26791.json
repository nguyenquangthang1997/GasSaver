{"time":293,"results":[{"type":"external-function ","before":"function initialize(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        TokenControllerInterface _controller\n    )\n    public\n    virtual\n    initializer\n    {\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(\"PoolTogether ControlledToken\");\n        controller = _controller;\n        _setupDecimals(_decimals);\n    }","after":"function initialize(\n        string calldata _name,\n        string calldata _symbol,\n        uint8 _decimals,\n        TokenControllerInterface _controller\n    )\n    public\n    virtual\n    initializer\n    {\n        __ERC20_init(_name, _symbol);\n        __ERC20Permit_init(\"PoolTogether ControlledToken\");\n        controller = _controller;\n        _setupDecimals(_decimals);\n    }","contract":"ControlledToken","time":0},{"type":"loop-duplication","before":"\nstart line 2514 column 8, end line 2521 column 8\n   for (i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (_unlockTimestamps[user] <= _currentTime()) {\n                totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);\n                balances[i] = _timelockBalances[user];\n                delete _timelockBalances[user];\n            }\n      \nstart line 2534 column 8, end line 2542 column 8\n   for (i = 0; i < users.length; i++) {\n            if (balances[i] > 0) {\n                delete _unlockTimestamps[users[i]];\n                uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);\n                uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);\n                underlyingToken.safeTransfer(users[i], transferAmount);\n                emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);\n            }\n      ","after":"// merge loop\n\nstart line 2514 column 8, end line 2521 column 8\n   for (i = 0; i < users.length; i++) {\n            address user = users[i];\n            if (_unlockTimestamps[user] <= _currentTime()) {\n                totalWithdrawal = totalWithdrawal.add(_timelockBalances[user]);\n                balances[i] = _timelockBalances[user];\n                delete _timelockBalances[user];\n            }\n      \nstart line 2534 column 8, end line 2542 column 8\n   for (i = 0; i < users.length; i++) {\n            if (balances[i] > 0) {\n                delete _unlockTimestamps[users[i]];\n                uint256 shareMantissa = FixedPoint.calculateMantissa(balances[i], totalWithdrawal);\n                uint256 transferAmount = FixedPoint.multiplyUintByMantissa(redeemed, shareMantissa);\n                underlyingToken.safeTransfer(users[i], transferAmount);\n                emit TimelockedWithdrawalSwept(operator, users[i], balances[i], transferAmount);\n            }\n      ","contract":"PrizePool","time":0},{"type":"external-function ","before":"   function initialize(\n        RegistryInterface _reserveRegistry,\n        ControlledTokenInterface[] memory _controlledTokens,\n        uint256 _maxExitFeeMantissa,\n        uint256 _maxTimelockDuration,\n        IERC20Upgradeable _stakeToken\n    )\n    public\n    initializer\n    {\n        PrizePool.initialize(\n            _reserveRegistry,\n            _controlledTokens,\n            _maxExitFeeMantissa,\n            _maxTimelockDuration\n        );\n        stakeToken = _stakeToken;\n\n        emit StakePrizePoolInitialized(address(stakeToken));\n  ","after":"   function initialize(\n        RegistryInterface _reserveRegistry,\n        ControlledTokenInterface[] calldata _controlledTokens,\n        uint256 _maxExitFeeMantissa,\n        uint256 _maxTimelockDuration,\n        IERC20Upgradeable _stakeToken\n    )\n    public\n    initializer\n    {\n        PrizePool.initialize(\n            _reserveRegistry,\n            _controlledTokens,\n            _maxExitFeeMantissa,\n            _maxTimelockDuration\n        );\n        stakeToken = _stakeToken;\n\n        emit StakePrizePoolInitialized(address(stakeToken));\n  ","contract":"StakePrizePool","time":0},{"type":"external-function ","before":"   function initialize(\n        RegistryInterface _reserveRegistry,\n        ControlledTokenInterface[] memory _controlledTokens,\n        uint256 _maxExitFeeMantissa,\n        uint256 _maxTimelockDuration\n    )\n    public\n    initializer\n    {\n        require(address(_reserveRegistry) != address(0), \"PrizePool/reserveRegistry-not-zero\");\n        _tokens.initialize();\n        for (uint256 i = 0; i < _controlledTokens.length; i++) {\n            _addControlledToken(_controlledTokens[i]);\n        }\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        _setLiquidityCap(uint256(- 1));\n\n        reserveRegistry = _reserveRegistry;\n        maxExitFeeMantissa = _maxExitFeeMantissa;\n        maxTimelockDuration = _maxTimelockDuration;\n\n        emit Initialized(\n            address(_reserveRegistry),\n            maxExitFeeMantissa,\n            maxTimelockDuration\n        );\n  ","after":"   function initialize(\n        RegistryInterface _reserveRegistry,\n        ControlledTokenInterface[] calldata _controlledTokens,\n        uint256 _maxExitFeeMantissa,\n        uint256 _maxTimelockDuration\n    )\n    public\n    initializer\n    {\n        require(address(_reserveRegistry) != address(0), \"PrizePool/reserveRegistry-not-zero\");\n        _tokens.initialize();\n        for (uint256 i = 0; i < _controlledTokens.length; i++) {\n            _addControlledToken(_controlledTokens[i]);\n        }\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        _setLiquidityCap(uint256(- 1));\n\n        reserveRegistry = _reserveRegistry;\n        maxExitFeeMantissa = _maxExitFeeMantissa;\n        maxTimelockDuration = _maxTimelockDuration;\n\n        emit Initialized(\n            address(_reserveRegistry),\n            maxExitFeeMantissa,\n            maxTimelockDuration\n        );\n  ","contract":"StakePrizePool","time":0}]}