{"time":856,"results":[{"type":"external-function ","before":"the contract uses delegated authority,\n    /// returns the original source of the delegated authority.\n    /// If the contract doesn't use delegated authority,\n    /// returns the contract itself.\n    /// Authorize `getAuthoritySource(operatorContract)`\n    /// to grant `operatorContract","after":"the contract uses delegated authority,\n    /// returns the original source of the delegated authority.\n    /// If the contract doesn't use delegated authority,\n    /// returns the contract itself.\n    /// Authorize `getAuthoritySource(operatorContract)`\n    /// to grant `operatorContract","contract":"BLS","time":0},{"type":"external-function ","before":"al(p_2);\n    }\n\n    /**\n     * @dev Verify performs the pairing operation to check if the signature\n     * is correct for the provided message and the corresponding public key.\n     * Public key must be a valid point on G2 curve in an uncompressed format.\n     * Message must be a valid point on G1 curve in an uncompressed format.\n     * Signature must b","after":"al(p_2);\n    }\n\n    /**\n     * @dev Verify performs the pairing operation to check if the signature\n     * is correct for the provided message and the corresponding public key.\n     * Public key must be a valid point on G2 curve in an uncompressed format.\n     * Message must be a valid point on G1 curve in an uncompressed format.\n     * Signature must b","contract":"BLS","time":0},{"type":"external-function ","before":"rewards pool,\n/// to be allocated for future intervals. Intervals past the initially defined\n/// schedule have a weight of 100%, meaning that all remaining unallocated\n/// rewards will be allocated to the interval.\n///\n/// Keeps of the appropriate type can receive rewards once the interval they\n/// were created in is over, and the keep has closed happily.\n/// There is no time limit to receiving rewards, nor is there need to wait for\n/// all keeps from the interval to close.\n/// Calling `receiveReward` automatically allocates the rewards for the interval\n/// the specified keep was created in and all previous intervals.\n///\n/// If a keep is terminated, that fact can b","after":"rewards pool,\n/// to be allocated for future intervals. Intervals past the initially defined\n/// schedule have a weight of 100%, meaning that all remaining unallocated\n/// rewards will be allocated to the interval.\n///\n/// Keeps of the appropriate type can receive rewards once the interval they\n/// were created in is over, and the keep has closed happily.\n/// There is no time limit to receiving rewards, nor is there need to wait for\n/// all keeps from the interval to close.\n/// Calling `receiveReward` automatically allocates the rewards for the interval\n/// the specified keep was created in and all previous intervals.\n///\n/// If a keep is terminated, that fact can b","contract":"BeaconBackportRewards","time":0},{"type":"external-function ","before":"ewards is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for KeepToken;\n\n    KeepToken public token;\n\n    // Array representing the percentage of unallocated rewards\n    // avai","after":"ewards is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for KeepToken;\n\n    KeepToken public token;\n\n    // Array representing the percentage of unallocated rewards\n    // avai","contract":"BeaconBackportRewards","time":0},{"type":"external-function ","before":"ct as signer rewards.\n    // `token.balanceOf(address(this))` should always equal\n    // `totalRewards.sub(dispensedRewards)`\n    uint256 public dispensedRewards;\n    // The following invariant should","after":"ct as signer rewards.\n    // `token.balanceOf(address(this))` should always equal\n    // `totalRewards.sub(dispensedRewards)`\n    uint256 public dispensedRewards;\n    // The following invariant should","contract":"BeaconBackportRewards","time":0},{"type":"immutable-restrict-modification ","before":"plusRecipientData.toAddres","after":"plusRecipientData.toAddres","contract":"BeaconBackportRewards","time":1},{"type":"immutable-restrict-modification ","before":"          // Reimburse submitter with t","after":"          // Reimburse submitter with t","contract":"BeaconBackportRewards","time":1},{"type":"immutable-restrict-modification ","before":"▓▓▓▓▓▄▄▓▓▓▓�","after":"▓▓▓▓▓▄▄▓▓▓▓�","contract":"BeaconBackportRewards","time":1},{"type":"external-function ","before":"hereum/solidity/issues/2691\n        return msg.data;\n    }\n}\npragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\nimport \"../../utils/BytesLib.sol\";\nimport \"./GroupSelection.sol\";\n\nlibrary DKGResultVerification {\n    using BytesLib for bytes;\n    using ECDSA for bytes32;\n    using GroupSelection for GroupSelection.Storage;\n\n    struct Storage {\n        // Time in blocks after which DKG result is complete and ready to be\n        // published by clients.\n        uint256 timeDKG;\n\n        // Time in blocks after which the next group member is eligible\n        // to submit DKG result.\n        uint256 resultPublicationBlockStep;\n\n        // Size of a group in the threshold relay.\n        uint256 groupSize;\n\n        // The minimum number of signatures required to support DKG result.\n        // This number needs to be at least the same as the signing threshold\n        // and it is recommended to make it higher than the signing threshold\n        // to keep a safety margin for misbehaving members.\n        uint256 signatureThreshold;\n    }\n\n    /// @notice Verifies the submitted DKG result against supporting member\n    /// signatures and if the submitter is eligible to submit at the current\n    /// block. Every signature supporting the result has to be from a unique\n    /// group member.\n    ///\n    /// @param submitterMemberIndex Claimed submitter candidate group member index\n    /// @param groupPubKey Generated candidate group public key\n    /// @param misbehaved Bytes array of misbehaved (disqualified or inactive)\n    /// group members indexes; Indexes reflect positions of members in the group,\n    /// as outputted by the group selection protocol.\n    /// @param signatures Concatenation of signatures from members supporting the\n    /// result.\n    /// @param signingMemberIndices Indices of members corresponding to each\n    /// signature. Indices have to be unique.\n    /// @param members Addresses of candidate group members as outputted by the\n    /// group selection protocol.\n    /// @param groupSelectionEndBlock Block height at which the group selection\n    /// protocol ended.\n    function verify(\n        Storage storage self,\n        uint256 submitterMemberIndex,\n        bytes memory groupPubKey,\n        bytes memory misbeh","after":"hereum/solidity/issues/2691\n        return msg.data;\n    }\n}\npragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/cryptography/ECDSA.sol\";\nimport \"../../utils/BytesLib.sol\";\nimport \"./GroupSelection.sol\";\n\nlibrary DKGResultVerification {\n    using BytesLib for bytes;\n    using ECDSA for bytes32;\n    using GroupSelection for GroupSelection.Storage;\n\n    struct Storage {\n        // Time in blocks after which DKG result is complete and ready to be\n        // published by clients.\n        uint256 timeDKG;\n\n        // Time in blocks after which the next group member is eligible\n        // to submit DKG result.\n        uint256 resultPublicationBlockStep;\n\n        // Size of a group in the threshold relay.\n        uint256 groupSize;\n\n        // The minimum number of signatures required to support DKG result.\n        // This number needs to be at least the same as the signing threshold\n        // and it is recommended to make it higher than the signing threshold\n        // to keep a safety margin for misbehaving members.\n        uint256 signatureThreshold;\n    }\n\n    /// @notice Verifies the submitted DKG result against supporting member\n    /// signatures and if the submitter is eligible to submit at the current\n    /// block. Every signature supporting the result has to be from a unique\n    /// group member.\n    ///\n    /// @param submitterMemberIndex Claimed submitter candidate group member index\n    /// @param groupPubKey Generated candidate group public key\n    /// @param misbehaved Bytes array of misbehaved (disqualified or inactive)\n    /// group members indexes; Indexes reflect positions of members in the group,\n    /// as outputted by the group selection protocol.\n    /// @param signatures Concatenation of signatures from members supporting the\n    /// result.\n    /// @param signingMemberIndices Indices of members corresponding to each\n    /// signature. Indices have to be unique.\n    /// @param members Addresses of candidate group members as outputted by the\n    /// group selection protocol.\n    /// @param groupSelectionEndBlock Block height at which the group selection\n    /// protocol ended.\n    function verify(\n        Storage storage self,\n        uint256 submitterMemberIndex,\n        bytes memory groupPubKey,\n        bytes memory misbeh","contract":"DKGResultVerification","time":0},{"type":"external-function ","before":"a new consumer contract to the oracle. Consumer contract is\n    /// expected to implement GasPriceOracleConsumer interface and receives\n    /// a notifcation every time gas price update is finalized.\n    /// @param consumerContract The new consumer contract to add to the oracle.\n    function addConsumerContract(address consumerContract) public onlyOwner {\n        consumerContracts.push(consumerContract);\n    }\n\n    /// @notice Removes consumer contract from the oracle by its index.\n    /// @param index Index of the consumer contract to be removed.\n    function removeConsumerContract(uint256 inde","after":"a new consumer contract to the oracle. Consumer contract is\n    /// expected to implement GasPriceOracleConsumer interface and receives\n    /// a notifcation every time gas price update is finalized.\n    /// @param consumerContract The new consumer contract to add to the oracle.\n    function addConsumerContract(address consumerContract) public onlyOwner {\n        consumerContracts.push(consumerContract);\n    }\n\n    /// @notice Removes consumer contract from the oracle by its index.\n    /// @param index Index of the consumer contract to be removed.\n    function removeConsumerContract(uint256 inde","contract":"GrantStaking","time":0},{"type":"external-function ","before":"ength - 1; i > 0; i--) {\n            ticketIndex = previousTicketIndex[ticketIndex];\n            selected[i - 1] = self.candidate[self.tickets[ticketIndex]];\n        }\n\n        return selected;\n    }\n\n    /// @notice Clears up data of the group selection tickets.\n    function ","after":"ength - 1; i > 0; i--) {\n            ticketIndex = previousTicketIndex[ticketIndex];\n            selected[i - 1] = self.candidate[self.tickets[ticketIndex]];\n        }\n\n        return selected;\n    }\n\n    /// @notice Clears up data of the group selection tickets.\n    function ","contract":"Groups","time":0},{"type":"external-function ","before":"idity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"../../utils/BytesLib.sol\";\nimport \"../../utils/PercentUtils.sol\";\nimport \"../../cryptography/AltBn128.sol\";\nimport \"../../cryptography/BLS.sol\";\nimport \"../../TokenStaking.sol\";\n\n\nlibrary Groups {\n    using SafeMath for uint256;\n    using PercentUtils for uint256;\n    using BytesLib for bytes;\n\n    // The index of a group is flagged with the most significant bit set,\n    // to distinguish the group `0` from null.\n    // The flag is toggled with bitwise XOR (`^`)\n    // which keeps all other bits intact but flips the flag bit.\n    // The flag should be set before writing to `groupIndices`,\n    // and unset after reading from `groupIndices`\n    // before using the value.\n    uint256 constant GROUP_INDEX_F","after":"idity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"../../utils/BytesLib.sol\";\nimport \"../../utils/PercentUtils.sol\";\nimport \"../../cryptography/AltBn128.sol\";\nimport \"../../cryptography/BLS.sol\";\nimport \"../../TokenStaking.sol\";\n\n\nlibrary Groups {\n    using SafeMath for uint256;\n    using PercentUtils for uint256;\n    using BytesLib for bytes;\n\n    // The index of a group is flagged with the most significant bit set,\n    // to distinguish the group `0` from null.\n    // The flag is toggled with bitwise XOR (`^`)\n    // which keeps all other bits intact but flips the flag bit.\n    // The flag should be set before writing to `groupIndices`,\n    // and unset after reading from `groupIndices`\n    // before using the value.\n    uint256 constant GROUP_INDEX_F","contract":"Groups","time":0},{"type":"external-function ","before":"n shiftByTerminatedGroups(\n        Storage storage self,\n        uint256 selectedIndex\n    ) internal view returns (uint256) {\n        uint256 shiftedIndex = selectedIndex;\n        for (uint i = 0; i < self.activeTerminatedGroups.length; i++) {\n            if (self.activeTerminatedGroups[i] <= shiftedIndex) {\n                shiftedIndex++;\n            }\n        }\n\n        return shiftedIndex;\n    }\n\n    /// @notice Withdraws accumulated group member rewards for operator\n    /// using the provided group index.\n    /// Once the accumulated reward is withdrawn from the selected group,\n    /// the operator is flagged as withdrawn.\n    /// Rewards can be withdrawn only from stal","after":"n shiftByTerminatedGroups(\n        Storage storage self,\n        uint256 selectedIndex\n    ) internal view returns (uint256) {\n        uint256 shiftedIndex = selectedIndex;\n        for (uint i = 0; i < self.activeTerminatedGroups.length; i++) {\n            if (self.activeTerminatedGroups[i] <= shiftedIndex) {\n                shiftedIndex++;\n            }\n        }\n\n        return shiftedIndex;\n    }\n\n    /// @notice Withdraws accumulated group member rewards for operator\n    /// using the provided group index.\n    /// Once the accumulated reward is withdrawn from the selected group,\n    /// the operator is flagged as withdrawn.\n    /// Rewards can be withdrawn only from stal","contract":"Groups","time":0},{"type":"external-function ","before":"t = ServiceContract(msg.sender);\n        startGroupSelection(_newEntry, msg.value.sub(groupSelectionStartFee));\n\n        // reimbursing a submitter that triggered group selection\n        (bool success,) = stakingContract.beneficiaryOf(submitter).call.value(groupSelectionStartFee)(\"\");\n        require(success, \"Group selection reimbursement failed\");\n    }\n\n    function startGroupSelection(uint256 _newEntry, uint256 _payment) internal {\n        require(\n            _payment >= gasPriceCeiling.mul(dkgGasEstimate),\n            \"Insufficient DKG fee\"\n        );\n\n        require(isGroupSelectionPossible(), \"Group selection in progress\");\n\n        // If previous group selection failed and there is reimbursement left\n        // return it to the DKG fee pool.\n        if (dkgSubmitterReimbursementFee > 0) {\n            uint256 surplus = dkgSubmitterReimbursemen","after":"t = ServiceContract(msg.sender);\n        startGroupSelection(_newEntry, msg.value.sub(groupSelectionStartFee));\n\n        // reimbursing a submitter that triggered group selection\n        (bool success,) = stakingContract.beneficiaryOf(submitter).call.value(groupSelectionStartFee)(\"\");\n        require(success, \"Group selection reimbursement failed\");\n    }\n\n    function startGroupSelection(uint256 _newEntry, uint256 _payment) internal {\n        require(\n            _payment >= gasPriceCeiling.mul(dkgGasEstimate),\n            \"Insufficient DKG fee\"\n        );\n\n        require(isGroupSelectionPossible(), \"Group selection in progress\");\n\n        // If previous group selection failed and there is reimbursement left\n        // return it to the DKG fee pool.\n        if (dkgSubmitterReimbursementFee > 0) {\n            uint256 surplus = dkgSubmitterReimbursemen","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"ingContract.eligibleStake(\n            msg.sender, address(this)\n        ).div(groupSelection.minimumStake);\n        groupSelection.submitTicket(ticket, stakingWeight);\n    }\n\n    /// @notice Gets the timeout in blocks after which group candidate ticket\n    /// submission is finished.\n    function ticketSubmissionTimeout() public view returns (uint256) {\n        return groupSelection.ticketSubmissionTimeout;\n    }\n\n    /// @notice Gets the submitted group candidate tickets so far.\n    function submittedTickets() public view returns (uint64[] memory) {\n        return groupSele","after":"ingContract.eligibleStake(\n            msg.sender, address(this)\n        ).div(groupSelection.minimumStake);\n        groupSelection.submitTicket(ticket, stakingWeight);\n    }\n\n    /// @notice Gets the timeout in blocks after which group candidate ticket\n    /// submission is finished.\n    function ticketSubmissionTimeout() public view returns (uint256) {\n        return groupSelection.ticketSubmissionTimeout;\n    }\n\n    /// @notice Gets the submitted group candidate tickets so far.\n    function submittedTickets() public view returns (uint64[] memory) {\n        return groupSele","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"        uint[] memory signingMembersIndexes\n    ) public nonReentrant {\n        address[] memory members = selectedParticipants();\n\n        dkgResultVerification.verify(\n            submitterMemberIndex,\n            groupPubKey,\n            misbehaved,\n            signatures,\n            signingMembersIndexes,\n            members,\n            groupSelection.ticketSubmissionStartBlock + groupSelection.ticketSubmissionTimeout\n        );\n\n        groups.setGroupMembers(groupPubKey, members, misbehaved);\n        groups.addGroup(groupPubKey);\n        reimburseDkgSubmitter();\n        emit DkgResultSubmittedEvent(submitterMemberIndex, groupPubKey, misbehaved);\n        groupSelection.finish();\n    }\n\n    /// @notice Compare the reimbursement fee calculated based on the current\n    /// transaction gas price and the current price feed estimate with the DKG\n    /// reimbursement fee calculated and paid at the moment when the DKG was\n    /// requested. If there is any surplus, it will be returned to the DKG fee\n    /// pool of the service contract which triggered the DKG.\n    function reimburseDkgSubmitter() internal {\n        uint256 gasPrice = gasPriceCeiling;\n        // We need to check if tx.gasprice is non-zero as a workaround to a bug\n        // in go-ethereum:\n        // https://github.com/ethereum/go-ethereum/pull/20189\n        if (tx.gasprice > 0 && tx.gasprice < gasPriceCeiling) {\n            gasPrice = tx.gasprice;\n        }\n\n        uint256 reimbursementFee = dkgGasEstimate.mul(gasPrice);\n        address payable beneficiary = stakingContract.beneficiaryOf(msg.sender);\n\n        if (r","after":"        uint[] calldata signingMembersIndexes\n    ) public nonReentrant {\n        address[] memory members = selectedParticipants();\n\n        dkgResultVerification.verify(\n            submitterMemberIndex,\n            groupPubKey,\n            misbehaved,\n            signatures,\n            signingMembersIndexes,\n            members,\n            groupSelection.ticketSubmissionStartBlock + groupSelection.ticketSubmissionTimeout\n        );\n\n        groups.setGroupMembers(groupPubKey, members, misbehaved);\n        groups.addGroup(groupPubKey);\n        reimburseDkgSubmitter();\n        emit DkgResultSubmittedEvent(submitterMemberIndex, groupPubKey, misbehaved);\n        groupSelection.finish();\n    }\n\n    /// @notice Compare the reimbursement fee calculated based on the current\n    /// transaction gas price and the current price feed estimate with the DKG\n    /// reimbursement fee calculated and paid at the moment when the DKG was\n    /// requested. If there is any surplus, it will be returned to the DKG fee\n    /// pool of the service contract which triggered the DKG.\n    function reimburseDkgSubmitter() internal {\n        uint256 gasPrice = gasPriceCeiling;\n        // We need to check if tx.gasprice is non-zero as a workaround to a bug\n        // in go-ethereum:\n        // https://github.com/ethereum/go-ethereum/pull/20189\n        if (tx.gasprice > 0 && tx.gasprice < gasPriceCeiling) {\n            gasPrice = tx.gasprice;\n        }\n\n        uint256 reimbursementFee = dkgGasEstimate.mul(gasPrice);\n        address payable beneficiary = stakingContract.beneficiaryOf(msg.sender);\n\n        if (r","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"rReward,\n        uint256 submitterReward,\n        uint256 subsidy\n    ) {\n        uint256 decimals = 1e16;\n        // Adding 16 decimals to p","after":"rReward,\n        uint256 submitterReward,\n        uint256 subsidy\n    ) {\n        uint256 decimals = 1e16;\n        // Adding 16 decimals to p","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":" by the service contract)\n        // The entry verification fee to cover the cost of verifying the submission,\n        // paid rega","after":" by the service contract)\n        // The entry verification fee to cover the cost of verifying the submission,\n        // paid rega","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"ns true if the currently ongoing new relay entry generation\n    /// operation timed out. There is a certain timeout for a new relay entry\n    /// to ","after":"ns true if the currently ongoing new relay entry generation\n    /// operation timed out. There is a certain timeout for a new relay entry\n    /// to ","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"for work selection.\n    ///\n    /// @param staker Staker's address\n    /// @return True if has enough active stake to participate in the network,\n    /// fal","after":"for work selection.\n    ///\n    /// @param staker Staker's address\n    /// @return True if has enough active stake to participate in the network,\n    /// fal","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"on isStaleGroup(bytes memory groupPubKey) public view returns (bool) {\n        return groups.isStaleGroup(groupPubKey);\n    }\n\n    /// @notice Gets the number of active groups as currently marked in the\n    /// contract. This is the state from when the expired groups were last updated\n    /// without accounting for recent ","after":"on isStaleGroup(bytes calldata groupPubKey) public view returns (bool) {\n        return groups.isStaleGroup(groupPubKey);\n    }\n\n    /// @notice Gets the number of active groups as currently marked in the\n    /// contract. This is the state from when the expired groups were last updated\n    /// without accounting for recent ","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓�","after":"▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓�","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"▓▓▓▄▄▓▓▓▓▓","after":"▓▓▓▄▄▓▓▓▓▓","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"��▓▓▓\n  ▓▓▓▓▓▓▓","after":"��▓▓▓\n  ▓▓▓▓▓▓▓","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"  ▐▓▓▓▓▓▓▓▓▓▓▓▓▓�","after":"  ▐▓▓▓▓▓▓▓▓▓▓▓▓▓�","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"█▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓�","after":"█▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓�","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"�▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓","after":"�▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"      Trust math, not hardware.\n*/\n\nprag","after":"      Trust math, not hardware.\n*/\n\nprag","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"sol\";\nimport \"openzeppelin-solidity/contracts/util","after":"sol\";\nimport \"openzeppelin-solidity/contracts/util","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"            panicButtons[_operatorContract] != address(0),\n            \"Disabled panic button cannot be updated\"\n        );\n        require(\n            _panicButton != address(0),\n            \"Panic button must be non-zero address\"\n        );\n\n        panicButtons[_operatorContract] = _panicButton;\n\n        emit OperatorContractPanicBut","after":"            panicButtons[_operatorContract] != address(0),\n            \"Disabled panic button cannot be updated\"\n        );\n        require(\n            _panicButton != address(0),\n            \"Panic button must be non-zero address\"\n        );\n\n        panicButtons[_operatorContract] = _panicButton;\n\n        emit OperatorContractPanicBut","contract":"KeepToken","time":0},{"type":"immutable-restrict-modification ","before":"ub(amount, \"ERC20: bu","after":"ub(amount, \"ERC20: bu","contract":"KeepToken","time":1},{"type":"immutable-restrict-modification ","before":"ount exceeds balance\");","after":"ount exceeds balance\");","contract":"KeepToken","time":1},{"type":"immutable-restrict-modification ","before":"    _totalSupply = _tota","after":"    _totalSupply = _tota","contract":"KeepToken","time":1},{"type":"external-function ","before":"s as the grantee towards the token grant contract,\n/// proxying instructions from the actual grantee.\n/// The address used by the actual grantee\n/// to issue instructions and withdraw tokens\n/// can be reassigned ","after":"s as the grantee towards the token grant contract,\n/// proxying instructions from the actual grantee.\n/// The address used by the actual grantee\n/// to issue instructions and withdraw tokens\n/// can be reassigned ","contract":"ManagedGrant","time":0},{"type":"immutable-restrict-modification ","before":"ddress lockCreator);\n\n    ui","after":"ddress lockCreator);\n\n    ui","contract":"ManagedGrant","time":0},{"type":"immutable-restrict-modification ","before":" public constant maximu","after":" public constant maximu","contract":"ManagedGrant","time":0},{"type":"external-function ","before":"     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\npragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nlibrary PercentUtils {\n    using SafeMath for uint256;\n\n    // Return `b`% of `a`\n    // 200.percent(40) == 80\n    // Commutative, works both ways\n    function percent(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(b).div(100);\n    }\n\n    // Return `a` as percentage of `b`:\n    // 80.asPercentOf(200) == 40\n    function asPercentOf(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(100).div(b);\n    }\n}\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonRee","after":"     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\npragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nlibrary PercentUtils {\n    using SafeMath for uint256;\n\n    // Return `b`% of `a`\n    // 200.percent(40) == 80\n    // Commutative, works both ways\n    function percent(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(b).div(100);\n    }\n\n    // Return `a` as percentage of `b`:\n    // 80.asPercentOf(200) == 40\n    function asPercentOf(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(100).div(b);\n    }\n}\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonRee","contract":"Reimbursements","time":0},{"type":"state-data-arrangement ","before":"\nkFee)(\"\");\n\n           \n           if (callbackSurplusRec\nplusRecipientData.toAddres\n          // Reimburse submitter with t\n/**\n▓▓▌ ▓▓ ▐▓�\n�▓▓▓▓▓▓▓ ▓▓▓�\n▓▓▓▓▓▓▓▓▓▓�\n▓▓▓▓▓▄▄▓▓▓▓�\n▄▄▄▄         ▐▓▓▓▓▓\n�▓▓▓▓         ▓▓▓▓▓▓�\n��▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓�\n�   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓    \n▓▓▓▓▓▓▓ ▓�\nagma solidity ^0.5.17;\n\nimport \"openzeppe\nolidity/contracts/ownership/Ownable.sol\";\nrt \"openzeppelin-solidity/contract","after":"kFee)(\"\");\n\n           \n           if (callbackSurplusRec\nplusRecipientData.toAddres\n          // Reimburse submitter with t\n/**\n▓▓▌ ▓▓ ▐▓�\n�▓▓▓▓▓▓▓ ▓▓▓�\n▓▓▓▓▓▓▓▓▓▓�\n▓▓▓▓▓▄▄▓▓▓▓�\n▄▄▄▄         ▐▓▓▓▓▓\n�▓▓▓▓         ▓▓▓▓▓▓�\n��▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓�\n�   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓    \nagma solidity ^0.5.17;\n\nimport \"openzeppe\nolidity/contracts/ownership/Ownable.sol\";\nrt \"openzeppelin-solidity/contract\n▓▓▓▓▓▓▓ ▓�\n","contract":"Rewards","time":0},{"type":"struct-data-arrangement ","before":"\n* Requirements:\n    \n    *\n     * _A\ntring memory erro\nomatically asserts wh\n   uint256 c = a / b;\n  \n this doesn't \ns the remainde\nd integer modulo\nrator. This f\nd) while Soli\nining gas).\n     \nero.\n     */\n \nreturns (uint256) {\n        retu","after":"tring memory erro\nomatically asserts wh\n   uint256 c = a / b;\n  \ns the remainde\nd integer modulo\nrator. This f\nd) while Soli\nining gas).\n     \nero.\n     */\n \nreturns (uint256) {\n        retu\n* Requirements:\n    \n    *\n     * _A\n this doesn't \n","contract":"TokenGrant","time":0},{"type":"external-function ","before":"rator addresses per particular grantee address.\n    mapping(address => address[]) public granteesToOperators;\n\n    /// @notice Creates a token grant contract for a provided Standard ERC20Burnable token.\n    /// @param _tokenAddress address of a token that will be linked to this contract.\n    constructor(address _tokenAddress) public {\n        require(_tokenAddress != address(0x0), \"Token address can't be zero.\");\n        token = ERC20Burnable(_tokenAddress);\n    }\n\n    /// @notice Used by grant manager to authorize staking contract with the given\n    /// address.\n    function authorizeStakingContract(address _stakingContract) public {\n        require(\n            _stakingContract != address(0x0),\n            \"Staking contract address can't be zero\"\n        );\n        stakingContracts[msg.sender][_stakingContract] = true;\n        emit StakingContractAuthorized(msg.sender, _stakingContract);\n    }\n\n    /// @notice Gets the amount of granted tokens to the specified address.\n    /// @param _owner The address to query the grants balance of.\n    /// @return An uint256 representing the grants balance owned by the passed address.\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    /// @notice Gets the stake balance of the specified address.\n    /// @param _address The address to query the balance of.\n    /// @return An uint256 representing the amount staked by the passed address.\n    function stakeBalanceOf(address _address) public view returns (uint256 balance) {\n        for (uint i = 0; i < grantIndices[_address].length; i++) {\n            uint256 id = grantIndices[_address][i];\n            balance += grants[id].staked;\n        }\n        ret","after":"rator addresses per particular grantee address.\n    mapping(address => address[]) public granteesToOperators;\n\n    /// @notice Creates a token grant contract for a provided Standard ERC20Burnable token.\n    /// @param _tokenAddress address of a token that will be linked to this contract.\n    constructor(address _tokenAddress) public {\n        require(_tokenAddress != address(0x0), \"Token address can't be zero.\");\n        token = ERC20Burnable(_tokenAddress);\n    }\n\n    /// @notice Used by grant manager to authorize staking contract with the given\n    /// address.\n    function authorizeStakingContract(address _stakingContract) public {\n        require(\n            _stakingContract != address(0x0),\n            \"Staking contract address can't be zero\"\n        );\n        stakingContracts[msg.sender][_stakingContract] = true;\n        emit StakingContractAuthorized(msg.sender, _stakingContract);\n    }\n\n    /// @notice Gets the amount of granted tokens to the specified address.\n    /// @param _owner The address to query the grants balance of.\n    /// @return An uint256 representing the grants balance owned by the passed address.\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    /// @notice Gets the stake balance of the specified address.\n    /// @param _address The address to query the balance of.\n    /// @return An uint256 representing the amount staked by the passed address.\n    function stakeBalanceOf(address _address) public view returns (uint256 balance) {\n        for (uint i = 0; i < grantIndices[_address].length; i++) {\n            uint256 id = grantIndices[_address][i];\n            balance += grants[id].staked;\n        }\n        ret","contract":"TokenGrant","time":0},{"type":"external-function ","before":"       bool _revocable,\n        address _stakingPolicy) = abi.decode(\n            _extraData,\n            (address, address, uint256, uint256, uint256, bool, address)\n        );\n\n        require(_grantee != address(0), \"Grantee address can't be zero.\");\n        require(\n            _cliffDuration <= _duration,\n            \"Unlocking cliff duration must be less or equal total unlocking duration.\"\n        );\n\n        require(_stakingPolicy != address(0), \"Staking policy can't be zero.\");\n\n        uint256 id = numGrants++;\n        grants[id] = Grant(\n            _grantManager,\n            _grantee,\n            0, 0, 0,\n            _revocable,\n            _amount,\n            _duration,\n            _start,\n            _start.add(_cliffDuration),\n            0, 0,\n            GrantStakingPolicy(_stakingPolicy)\n        );\n\n        // Maintain a record to make it easier to query grants by grant manager.\n        grantIndices[_from].push(id);\n\n        // Maintain a record to make it easier to query grants by grantee.\n        grantIndices[_grantee].push(id);\n\n        token.safeTransferFrom(_from, address(this), _amount);\n\n        // Maintain a record of the unlocked amount\n        balances[_grantee] = balances[_grantee].add(_amount);\n        emit TokenGrantCreated(id);\n    }\n\n    /// @notice Withdraws Token grant amount to grantee.\n    /// @dev Transfers unlocked tokens of the token grant to grantee.\n    /// @param _id Grant ID.\n    function withdraw(uint256 _id) public {\n     ","after":"       bool _revocable,\n        address _stakingPolicy) = abi.decode(\n            _extraData,\n            (address, address, uint256, uint256, uint256, bool, address)\n        );\n\n        require(_grantee != address(0), \"Grantee address can't be zero.\");\n        require(\n            _cliffDuration <= _duration,\n            \"Unlocking cliff duration must be less or equal total unlocking duration.\"\n        );\n\n        require(_stakingPolicy != address(0), \"Staking policy can't be zero.\");\n\n        uint256 id = numGrants++;\n        grants[id] = Grant(\n            _grantManager,\n            _grantee,\n            0, 0, 0,\n            _revocable,\n            _amount,\n            _duration,\n            _start,\n            _start.add(_cliffDuration),\n            0, 0,\n            GrantStakingPolicy(_stakingPolicy)\n        );\n\n        // Maintain a record to make it easier to query grants by grant manager.\n        grantIndices[_from].push(id);\n\n        // Maintain a record to make it easier to query grants by grantee.\n        grantIndices[_grantee].push(id);\n\n        token.safeTransferFrom(_from, address(this), _amount);\n\n        // Maintain a record of the unlocked amount\n        balances[_grantee] = balances[_grantee].add(_amount);\n        emit TokenGrantCreated(id);\n    }\n\n    /// @notice Withdraws Token grant amount to grantee.\n    /// @dev Transfers unlocked tokens of the token grant to grantee.\n    /// @param _id Grant ID.\n    function withdraw(uint256 _id) public {\n     ","contract":"TokenGrant","time":0},{"type":"external-function ","before":"), _amount);\n\n        // Staking contract expects 40 bytes _extraData for stake delegation.\n        // 20 bytes beneficiary's address + 20 bytes operator's address.\n        grantStake.stake(_amount, _extraData);\n        emit TokenGrantStaked(_id, _amount, operator);\n    }\n\n    ///  @notice Returns the amount of tok","after":"), _amount);\n\n        // Staking contract expects 40 bytes _extraData for stake delegation.\n        // 20 bytes beneficiary's address + 20 bytes operator's address.\n        grantStake.stake(_amount, _extraData);\n        emit TokenGrantStaked(_id, _amount, operator);\n    }\n\n    ///  @notice Returns the amount of tok","contract":"TokenGrantStake","time":0},{"type":"immutable-restrict-modification ","before":"raData for stake de","after":"raData for stake de","contract":"TokenGrantStake","time":0},{"type":"immutable-restrict-modification ","before":"60, \"Stake deleg","after":"60, \"Stake deleg","contract":"TokenGrantStake","time":0},{"type":"external-function ","before":"�▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓�","after":"�▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄       ▐▓▓▓▓▓▓▀▀▀▀         ▓▓▓▓▓▓▀▀▀▀         ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▀\n  ▓▓▓▓▓▓   ▀▓▓▓▓▓▓▄     ▐▓▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌\n▓▓▓▓▓▓▓▓▓▓ █▓▓▓▓▓▓▓▓▓ ▐▓▓▓▓▓▓▓▓�","contract":"TokenStaking","time":0},{"type":"external-function ","before":"!_isInitialized(operatorParams),\n            \"Initialized stake\"\n        );\n\n        uint256 amount = operatorParams.getAmount();\n        operators[_operator].packedParams = operatorParams.setAmount(0);\n\n        transferOrDeposit(owner, _operator, amount);\n    }\n\n    /// @notice Undelegates staked tokens. You will be able to recover your stake by calling\n    /// `recoverStake()` with operator address once undelegation period is over.\n    /// @param _operator Address of the stake operator.\n    function undelegate(address _operator) public {\n        undelegateAt(_operator, block.timestamp);\n    }\n\n    /// @notice Set an undelegation time for staked tokens.\n    /// Undelegation will begin at the specified timestamp.\n    /// You will be able to recover your stake by calling\n    /// `recoverStake()` with operator address once undelegation period is over.\n    /// @param _operator Address of the stake operator.\n    /// @param _undelegationTimestamp The timestamp undelegation is to start at.\n    function undelegateAt(\n        address _operator,\n        uint256 _undelegationTimestamp\n    ) public {\n        require(\n            msg.sender == _operator ||\n            msg.sender == operators[_operator].owner ||\n            grantStaking.canUndelegate(_operator, tokenGrant),\n            \"Not authorized\"\n        );\n        uint256 oldParams = operators[_operator].packedParams;\n        require(\n            _undelegationTimestamp >= block.timestamp &&\n            _unde","after":"!_isInitialized(operatorParams),\n            \"Initialized stake\"\n        );\n\n        uint256 amount = operatorParams.getAmount();\n        operators[_operator].packedParams = operatorParams.setAmount(0);\n\n        transferOrDeposit(owner, _operator, amount);\n    }\n\n    /// @notice Undelegates staked tokens. You will be able to recover your stake by calling\n    /// `recoverStake()` with operator address once undelegation period is over.\n    /// @param _operator Address of the stake operator.\n    function undelegate(address _operator) public {\n        undelegateAt(_operator, block.timestamp);\n    }\n\n    /// @notice Set an undelegation time for staked tokens.\n    /// Undelegation will begin at the specified timestamp.\n    /// You will be able to recover your stake by calling\n    /// `recoverStake()` with operator address once undelegation period is over.\n    /// @param _operator Address of the stake operator.\n    /// @param _undelegationTimestamp The timestamp undelegation is to start at.\n    function undelegateAt(\n        address _operator,\n        uint256 _undelegationTimestamp\n    ) public {\n        require(\n            msg.sender == _operator ||\n            msg.sender == operators[_operator].owner ||\n            grantStaking.canUndelegate(_operator, tokenGrant),\n            \"Not authorized\"\n        );\n        uint256 oldParams = operators[_operator].packedParams;\n        require(\n            _undelegationTimestamp >= block.timestamp &&\n            _unde","contract":"TokenStaking","time":0},{"type":"external-function ","before":"Only owner and grantee are eligible to postpone the\n            // delegation so it is enough if we exclude operator here.\n            msg.sender != _operator,\n            \"Operator may not postpone\"\n        );\n        operators[_operator].packedParams = oldParams.setUndelegationTimestamp(\n            _undelegationTimestamp\n        );\n        emit Undelegated(_operator, _undelegationTimestamp);\n    }\n\n    /// @notice Recovers staked tokens and transfers them back to the owner.\n    /// Recovering tokens can only be performed when the operator finished\n    /// undelegating.\n    /// @param _operator Operator address.\n    function recoverStake(address _operator) public {\n        uint256 operatorParams = operators[_operator].packedParams;\n        require(\n            operatorParams.getUndelegationTimestamp() != 0,\n            \"Not undelegated\"\n        );\n        require(\n            _isUndelegatingFinished(operatorParams),\n            \"Still undelegating\"\n        );\n        require(\n            !isStakeLocked(_operator),\n            \"Locked stake\"\n        );\n\n        uint256 amount = operatorParams.getAmount();\n\n        // If there is a pending top-up, force-commit it before returning tokens.\n        amount = amount.add(topUps.cancel(_operator));\n\n        operators[_operator].packedParams = operatorParams.setAmount(0);\n        transferOrDeposit(operators[_operator].owner, _operator, amount);\n\n        emit RecoveredStake(_operator);\n    }\n\n    /// @notice Gets stake delegation info for the given operator.\n    /// @param _operator Operator address.\n    /// @return amount The amount of tokens the given operator delegated.\n    /// @return createdAt The time when the stake has been delegated.\n    /// @re","after":"Only owner and grantee are eligible to postpone the\n            // delegation so it is enough if we exclude operator here.\n            msg.sender != _operator,\n            \"Operator may not postpone\"\n        );\n        operators[_operator].packedParams = oldParams.setUndelegationTimestamp(\n            _undelegationTimestamp\n        );\n        emit Undelegated(_operator, _undelegationTimestamp);\n    }\n\n    /// @notice Recovers staked tokens and transfers them back to the owner.\n    /// Recovering tokens can only be performed when the operator finished\n    /// undelegating.\n    /// @param _operator Operator address.\n    function recoverStake(address _operator) public {\n        uint256 operatorParams = operators[_operator].packedParams;\n        require(\n            operatorParams.getUndelegationTimestamp() != 0,\n            \"Not undelegated\"\n        );\n        require(\n            _isUndelegatingFinished(operatorParams),\n            \"Still undelegating\"\n        );\n        require(\n            !isStakeLocked(_operator),\n            \"Locked stake\"\n        );\n\n        uint256 amount = operatorParams.getAmount();\n\n        // If there is a pending top-up, force-commit it before returning tokens.\n        amount = amount.add(topUps.cancel(_operator));\n\n        operators[_operator].packedParams = operatorParams.setAmount(0);\n        transferOrDeposit(operators[_operator].owner, _operator, amount);\n\n        emit RecoveredStake(_operator);\n    }\n\n    /// @notice Gets stake delegation info for the given operator.\n    /// @param _operator Operator address.\n    /// @return amount The amount of tokens the given operator delegated.\n    /// @return createdAt The time when the stake has been delegated.\n    /// @re","contract":"TokenStaking","time":0},{"type":"immutable-restrict-modification ","before":"_operator];\n        uint25","after":"_operator];\n        uint25","contract":"TokenStaking","time":1},{"type":"immutable-restrict-modification ","before":"urned = grantStake.recoverStake();\n ","after":"urned = grantStake.recoverStake();\n ","contract":"TokenStaking","time":1},{"type":"external-function ","before":"eratorContract\n    ) public view returns (uint256 balance) {\n        uint256 operatorParams = operators[_operator].packedParams;\n        if (\n            isAuthorizedForOperator(_operator, _operatorContract) &&\n            _isInitialized(operatorParams) &&\n            !_isStakeReleased(\n                _operator,\n                operatorParams,\n                _operatorContract\n            )\n        ) {\n            balance = operatorParams.getAmount();\n        }\n    }\n\n    /// @notice Checks if the specified a","after":"eratorContract\n    ) public view returns (uint256 balance) {\n        uint256 operatorParams = operators[_operator].packedParams;\n        if (\n            isAuthorizedForOperator(_operator, _operatorContract) &&\n            _isInitialized(operatorParams) &&\n            !_isStakeReleased(\n                _operator,\n                operatorParams,\n                _operatorContract\n            )\n        ) {\n            balance = operatorParams.getAmount();\n        }\n    }\n\n    /// @notice Checks if the specified a","contract":"TokenStakingEscrow","time":0},{"type":"external-function ","before":"l) {\n        return activeStake(staker, operatorContract) >= minimumStake();\n    }\n\n    /// @notice Is the operator with the given params initialized\n    function _isInitialized(uint256 _operatorParams)\n    internal view returns (bool) {\n        return block.timestamp > _operatorParams.getCreationTimestamp().add(initializationPeriod);\n    }\n\n    /// @notice Is the operator with the given params undelegating\n    function _isUndelegating(uint256 _operatorParams)\n    internal view returns (bool) {\n        uint256 undelegatedAt = _operatorParams.getUndelegationTimestamp();\n        return (undelegatedAt != 0) && (block.timestamp > undelegatedAt);\n    }\n\n    /// @notice Has the operator with the given params finished undelegating\n    function _isUndelegatingFinished(uint256 _operatorParams)\n    internal view returns (bool) {\n        uint256 undelegatedAt = _operatorParams.getUndelegationTimestamp();\n        return (undelegatedAt != 0) && (block.timestamp > undelegatedAt.add(undelegationPeriod()));\n    }\n\n    /// @notice Get whether the operator's stake is released\n    /// as far as the operator contract is concerned.\n    /// If the operator contract has a lock on the ope","after":"l) {\n        return activeStake(staker, operatorContract) >= minimumStake();\n    }\n\n    /// @notice Is the operator with the given params initialized\n    function _isInitialized(uint256 _operatorParams)\n    internal view returns (bool) {\n        return block.timestamp > _operatorParams.getCreationTimestamp().add(initializationPeriod);\n    }\n\n    /// @notice Is the operator with the given params undelegating\n    function _isUndelegating(uint256 _operatorParams)\n    internal view returns (bool) {\n        uint256 undelegatedAt = _operatorParams.getUndelegationTimestamp();\n        return (undelegatedAt != 0) && (block.timestamp > undelegatedAt);\n    }\n\n    /// @notice Has the operator with the given params finished undelegating\n    function _isUndelegatingFinished(uint256 _operatorParams)\n    internal view returns (bool) {\n        uint256 undelegatedAt = _operatorParams.getUndelegationTimestamp();\n        return (undelegatedAt != 0) && (block.timestamp > undelegatedAt.add(undelegationPeriod()));\n    }\n\n    /// @notice Get whether the operator's stake is released\n    /// as far as the operator contract is concerned.\n    /// If the operator contract has a lock on the ope","contract":"TokenStakingEscrow","time":0}]}