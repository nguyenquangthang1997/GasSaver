{"time":1329,"results":[{"type":"external-function ","before":"   function setAddress(\n        string memory _name,\n        address _address\n    )\n    external\n    onlyOwner\n    {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(\n            _name,\n            _address,\n            oldAddress\n        );\n  ","after":"   function setAddress(\n        string calldata _name,\n        address _address\n    )\n    external\n    onlyOwner\n    {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(\n            _name,\n            _address,\n            oldAddress\n        );\n  ","contract":"Lib_AddressManager","time":0},{"type":"external-function ","before":"   function getAddress(\n        string memory _name\n    )\n    external\n    view\n    returns (\n        address\n    )\n    {\n        return addresses[_getNameHash(_name)];\n  ","after":"   function getAddress(\n        string calldata _name\n    )\n    external\n    view\n    returns (\n        address\n    )\n    {\n        return addresses[_getNameHash(_name)];\n  ","contract":"Lib_AddressManager","time":0},{"type":"struct-data-arrangement ","before":"\n   uint256 no\n   uint256 gasPr\n   uint256 gasLi\n   address\n   uint256 va\n   bytes d\n   uint\n   bytes3\n   bytes3\n   uint256 chai\n   uint8 recoveryPa\n   bool isCre","after":"   uint256 no\n   uint256 gasPr\n   uint256 gasLi\n   uint256 va\n   bytes d\n   bytes3\n   bytes3\n   uint256 chai\n   address\n   uint\n   uint8 recoveryPa\n   bool isCre\n","contract":"Lib_EIP155Tx","time":0},{"type":"loop-calculation","before":"   uint256 listP","after":"// move outside for loop\n   uint256 listP","loc":{"start":{"line":5117,"column":12},"end":{"line":5117,"column":27}},"contract":"Lib_RLPWriter","time":0},{"type":"loop-calculation","before":"   uint256 txDataLeng","after":"// move outside for loop\n   uint256 txDataLeng","loc":{"start":{"line":6098,"column":16},"end":{"line":6098,"column":36}},"contract":"OVM_CanonicalTransactionChain","time":0},{"type":"external-function ","before":"   function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    )\n    override\n    public\n    {\n        require(\n            _data.length <= MAX_ROLLUP_TX_SIZE,\n            \"Transaction data size exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit <= maxTransactionGasLimit,\n            \"Transaction gas limit exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit >= MIN_ROLLUP_TX_GAS,\n            \"Transaction gas limit too low to enqueue.\"\n        );\n\n        // We need to consume some amount of L1 gas in order to rate limit transactions going into\n        // L2. However, L2 is cheaper than L1 so we only need to burn some small proportion of the\n        // provided L1 gas.\n        uint256 gasToConsume = _gasLimit / L2_GAS_DISCOUNT_DIVISOR;\n        uint256 startingGas = gasleft();\n\n        // Although this check is not necessary (burn below will run out of gas if not true), it\n        // gives the user an explicit reason as to why the enqueue attempt failed.\n        require(\n            startingGas > gasToConsume,\n            \"Insufficient gas for L2 rate limiting burn.\"\n        );\n\n        // Here we do some \"dumb\" work in order to burn gas, although we should probably replace\n        // this with something like minting gas token later on.\n        uint256 i;\n        while (startingGas - gasleft() < gasToConsume) {\n            i++;\n        }\n\n        bytes32 transactionHash = keccak256(\n            abi.encode(\n                msg.sender,\n                _target,\n                _gasLimit,\n                _data\n            )\n        );\n\n        bytes32 timestampAndBlockNumber;\n        assembly {\n            timestampAndBlockNumber := timestamp()\n            timestampAndBlockNumber := or(timestampAndBlockNumber, shl(40, number()))\n        }\n\n        iOVM_ChainStorageContainer queueRef = queue();\n\n        queueRef.push(transactionHash);\n        queueRef.push(timestampAndBlockNumber);\n\n        // The underlying queue data structure stores 2 elements\n        // per insertion, so to get the real queue length we need\n        // to divide by 2 and subtract 1.\n        uint256 queueIndex = queueRef.length() / 2 - 1;\n        emit TransactionEnqueued(\n            msg.sender,\n            _target,\n            _gasLimit,\n            _data,\n            queueIndex,\n            block.timestamp\n        );\n  ","after":"   function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes calldata _data\n    )\n    override\n    public\n    {\n        require(\n            _data.length <= MAX_ROLLUP_TX_SIZE,\n            \"Transaction data size exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit <= maxTransactionGasLimit,\n            \"Transaction gas limit exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit >= MIN_ROLLUP_TX_GAS,\n            \"Transaction gas limit too low to enqueue.\"\n        );\n\n        // We need to consume some amount of L1 gas in order to rate limit transactions going into\n        // L2. However, L2 is cheaper than L1 so we only need to burn some small proportion of the\n        // provided L1 gas.\n        uint256 gasToConsume = _gasLimit / L2_GAS_DISCOUNT_DIVISOR;\n        uint256 startingGas = gasleft();\n\n        // Although this check is not necessary (burn below will run out of gas if not true), it\n        // gives the user an explicit reason as to why the enqueue attempt failed.\n        require(\n            startingGas > gasToConsume,\n            \"Insufficient gas for L2 rate limiting burn.\"\n        );\n\n        // Here we do some \"dumb\" work in order to burn gas, although we should probably replace\n        // this with something like minting gas token later on.\n        uint256 i;\n        while (startingGas - gasleft() < gasToConsume) {\n            i++;\n        }\n\n        bytes32 transactionHash = keccak256(\n            abi.encode(\n                msg.sender,\n                _target,\n                _gasLimit,\n                _data\n            )\n        );\n\n        bytes32 timestampAndBlockNumber;\n        assembly {\n            timestampAndBlockNumber := timestamp()\n            timestampAndBlockNumber := or(timestampAndBlockNumber, shl(40, number()))\n        }\n\n        iOVM_ChainStorageContainer queueRef = queue();\n\n        queueRef.push(transactionHash);\n        queueRef.push(timestampAndBlockNumber);\n\n        // The underlying queue data structure stores 2 elements\n        // per insertion, so to get the real queue length we need\n        // to divide by 2 and subtract 1.\n        uint256 queueIndex = queueRef.length() / 2 - 1;\n        emit TransactionEnqueued(\n            msg.sender,\n            _target,\n            _gasLimit,\n            _data,\n            queueIndex,\n            block.timestamp\n        );\n  ","contract":"OVM_CanonicalTransactionChain","time":0},{"type":"external-function ","before":"   function verifyTransaction(\n        Lib_OVMCodec.Transaction memory _transaction,\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _inclusionProof\n    )\n    override\n    public\n    view\n    returns (\n        bool\n    )\n    {\n        if (_txChainElement.isSequenced == true) {\n            return _verifySequencerTransaction(\n                _transaction,\n                _txChainElement,\n                _batchHeader,\n                _inclusionProof\n            );\n        } else {\n            return _verifyQueueTransaction(\n                _transaction,\n                _txChainElement.queueIndex,\n                _batchHeader,\n                _inclusionProof\n            );\n        }\n  ","after":"   function verifyTransaction(\n        Lib_OVMCodec.Transaction calldata _transaction,\n        Lib_OVMCodec.TransactionChainElement calldata _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader calldata _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof calldata _inclusionProof\n    )\n    override\n    public\n    view\n    returns (\n        bool\n    )\n    {\n        if (_txChainElement.isSequenced == true) {\n            return _verifySequencerTransaction(\n                _transaction,\n                _txChainElement,\n                _batchHeader,\n                _inclusionProof\n            );\n        } else {\n            return _verifyQueueTransaction(\n                _transaction,\n                _txChainElement.queueIndex,\n                _batchHeader,\n                _inclusionProof\n            );\n        }\n  ","contract":"OVM_CanonicalTransactionChain","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public forceInclusionPeriodSecon","after":"   uint256 public forceInclusionPeriodSecon","contract":"OVM_CanonicalTransactionChain","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 public forceInclusionPeriodBloc","after":"   uint256 public forceInclusionPeriodBloc","contract":"OVM_CanonicalTransactionChain","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 public maxTransactionGasLim","after":"   uint256 public maxTransactionGasLim","contract":"OVM_CanonicalTransactionChain","time":1},{"type":"external-function ","before":"   function resolve(\n        string memory _name\n    )\n    public\n    view\n    returns (\n        address\n    )\n    {\n        return libAddressManager.getAddress(_name);\n  ","after":"   function resolve(\n        string calldata _name\n    )\n    public\n    view\n    returns (\n        address\n    )\n    {\n        return libAddressManager.getAddress(_name);\n  ","contract":"OVM_ChainStorageContainer","time":0},{"type":"immutable-restrict-modification ","before":"   string public own","after":"   string public own","contract":"OVM_ChainStorageContainer","time":0},{"type":"external-function ","before":"   function isValidSignature(\n        bytes32 hash,\n        bytes memory signature\n    )\n    public\n    view\n    returns (\n        bytes4 magicValue\n    )\n    {\n        return ECDSA.recover(hash, signature) == address(this) ?\n        this.isValidSignature.selector :\n        bytes4(0);\n  ","after":"   function isValidSignature(\n        bytes32 hash,\n        bytes calldata signature\n    )\n    public\n    view\n    returns (\n        bytes4 magicValue\n    )\n    {\n        return ECDSA.recover(hash, signature) == address(this) ?\n        this.isValidSignature.selector :\n        bytes4(0);\n  ","contract":"OVM_ECDSAContractAccount","time":0},{"type":"external-function ","before":"   function execute(\n        Lib_EIP155Tx.EIP155Tx memory _transaction\n    )\n    override\n    public\n    returns (\n        bool,\n        bytes memory\n    )\n    {\n        // Address of this contract within the ovm (ovmADDRESS) should be the same as the\n        // recovered address of the user who signed this message. This is how we manage to shim\n        // account abstraction even though the user isn't a contract.\n        require(\n            _transaction.sender() == Lib_ExecutionManagerWrapper.ovmADDRESS(),\n            \"Signature provided for EOA transaction execution is invalid.\"\n        );\n\n        require(\n            _transaction.chainId == Lib_ExecutionManagerWrapper.ovmCHAINID(),\n            \"Transaction signed with wrong chain ID\"\n        );\n\n        // Need to make sure that the transaction nonce is right.\n        require(\n            _transaction.nonce == Lib_ExecutionManagerWrapper.ovmGETNONCE(),\n            \"Transaction nonce does not match the expected nonce.\"\n        );\n\n        // TEMPORARY: Disable gas checks for mainnet.\n        // // Need to make sure that the gas is sufficient to execute the transaction.\n        // require(\n        //    gasleft() >= SafeMath.add(transaction.gasLimit, EXECUTION_VALIDATION_GAS_OVERHEAD),\n        //    \"Gas is not sufficient to execute the transaction.\"\n        // );\n\n        // Transfer fee to relayer.\n        require(\n            OVM_ETH(Lib_PredeployAddresses.OVM_ETH).transfer(\n                Lib_PredeployAddresses.SEQUENCER_FEE_WALLET,\n                SafeMath.mul(_transaction.gasLimit, _transaction.gasPrice)\n            ),\n            \"Fee was not transferred to relayer.\"\n        );\n\n        if (_transaction.isCreate) {\n            // TEMPORARY: Disable value transfer for contract creations.\n            require(\n                _transaction.value == 0,\n                \"Value transfer in contract creation not supported.\"\n            );\n\n            (address created, bytes memory revertdata) = Lib_ExecutionManagerWrapper.ovmCREATE(\n                _transaction.data\n            );\n\n            // Return true if the contract creation succeeded, false w/ revertdata otherwise.\n            if (created != address(0)) {\n                return (true, abi.encode(created));\n            } else {\n                return (false, revertdata);\n            }\n        } else {\n            // We only want to bump the nonce for `ovmCALL` because `ovmCREATE` automatically bumps\n            // the nonce of the calling account. Normally an EOA would bump the nonce for both\n            // cases, but since this is a contract we'd end up bumping the nonce twice.\n            Lib_ExecutionManagerWrapper.ovmINCREMENTNONCE();\n\n            // NOTE: Upgrades are temporarily disabled because users can, in theory, modify their\n            // EOA so that they don't have to pay any fees to the sequencer. Function will remain\n            // disabled until a robust solution is in place.\n            require(\n                _transaction.to != Lib_ExecutionManagerWrapper.ovmADDRESS(),\n                \"Calls to self are disabled until upgradability is re-enabled.\"\n            );\n\n            return _transaction.to.call{value : _transaction.value}(_transaction.data);\n        }\n  ","after":"   function execute(\n        Lib_EIP155Tx.EIP155Tx calldata _transaction\n    )\n    override\n    public\n    returns (\n        bool,\n        bytes memory\n    )\n    {\n        // Address of this contract within the ovm (ovmADDRESS) should be the same as the\n        // recovered address of the user who signed this message. This is how we manage to shim\n        // account abstraction even though the user isn't a contract.\n        require(\n            _transaction.sender() == Lib_ExecutionManagerWrapper.ovmADDRESS(),\n            \"Signature provided for EOA transaction execution is invalid.\"\n        );\n\n        require(\n            _transaction.chainId == Lib_ExecutionManagerWrapper.ovmCHAINID(),\n            \"Transaction signed with wrong chain ID\"\n        );\n\n        // Need to make sure that the transaction nonce is right.\n        require(\n            _transaction.nonce == Lib_ExecutionManagerWrapper.ovmGETNONCE(),\n            \"Transaction nonce does not match the expected nonce.\"\n        );\n\n        // TEMPORARY: Disable gas checks for mainnet.\n        // // Need to make sure that the gas is sufficient to execute the transaction.\n        // require(\n        //    gasleft() >= SafeMath.add(transaction.gasLimit, EXECUTION_VALIDATION_GAS_OVERHEAD),\n        //    \"Gas is not sufficient to execute the transaction.\"\n        // );\n\n        // Transfer fee to relayer.\n        require(\n            OVM_ETH(Lib_PredeployAddresses.OVM_ETH).transfer(\n                Lib_PredeployAddresses.SEQUENCER_FEE_WALLET,\n                SafeMath.mul(_transaction.gasLimit, _transaction.gasPrice)\n            ),\n            \"Fee was not transferred to relayer.\"\n        );\n\n        if (_transaction.isCreate) {\n            // TEMPORARY: Disable value transfer for contract creations.\n            require(\n                _transaction.value == 0,\n                \"Value transfer in contract creation not supported.\"\n            );\n\n            (address created, bytes memory revertdata) = Lib_ExecutionManagerWrapper.ovmCREATE(\n                _transaction.data\n            );\n\n            // Return true if the contract creation succeeded, false w/ revertdata otherwise.\n            if (created != address(0)) {\n                return (true, abi.encode(created));\n            } else {\n                return (false, revertdata);\n            }\n        } else {\n            // We only want to bump the nonce for `ovmCALL` because `ovmCREATE` automatically bumps\n            // the nonce of the calling account. Normally an EOA would bump the nonce for both\n            // cases, but since this is a contract we'd end up bumping the nonce twice.\n            Lib_ExecutionManagerWrapper.ovmINCREMENTNONCE();\n\n            // NOTE: Upgrades are temporarily disabled because users can, in theory, modify their\n            // EOA so that they don't have to pay any fees to the sequencer. Function will remain\n            // disabled until a robust solution is in place.\n            require(\n                _transaction.to != Lib_ExecutionManagerWrapper.ovmADDRESS(),\n                \"Calls to self are disabled until upgradability is re-enabled.\"\n            );\n\n            return _transaction.to.call{value : _transaction.value}(_transaction.data);\n        }\n  ","contract":"OVM_ECDSAContractAccount","time":0},{"type":"immutable-restrict-modification ","before":"   address public override l1Tok","after":"   address public override l1Tok","contract":"OVM_ETH","time":1},{"type":"immutable-restrict-modification ","before":"   address public l2Brid","after":"   address public l2Brid","contract":"OVM_ETH","time":1},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"OVM_ETH","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"OVM_ETH","time":1},{"type":"de-morgan-condition ","before":"f (!isAllowed || !succ","after":"!(f (isAllowed || succ)","loc":{"start":{"line":8542,"column":12},"end":{"line":8542,"column":27}},"contract":"OVM_ExecutionManager","time":0},{"type":"external-function ","before":"   function run(\n        Lib_OVMCodec.Transaction memory _transaction,\n        address _ovmStateManager\n    )\n    override\n    external\n    returns (\n        bytes memory\n    )\n    {\n        // Make sure that run() is not re-enterable.  This condition should always be satisfied\n        // Once run has been called once, due to the behavior of _isValidInput().\n        if (transactionContext.ovmNUMBER != DEFAULT_UINT256) {\n            return bytes(\"\");\n        }\n\n        // Store our OVM_StateManager instance (significantly easier than attempting to pass the\n        // address around in calldata).\n        ovmStateManager = iOVM_StateManager(_ovmStateManager);\n\n        // Make sure this function can't be called by anyone except the owner of the\n        // OVM_StateManager (expected to be an OVM_StateTransitioner). We can revert here because\n        // this would make the `run` itself invalid.\n        require(\n        // This method may return false during fraud proofs, but always returns true in\n        // L2 nodes' State Manager precompile.\n            ovmStateManager.isAuthenticated(msg.sender),\n            \"Only authenticated addresses in ovmStateManager can call this function\"\n        );\n\n        // Initialize the execution context, must be initialized before we perform any gas metering\n        // or we'll throw a nuisance gas error.\n        _initContext(_transaction);\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Check whether we need to start a new epoch, do so if necessary.\n        // _checkNeedsNewEpoch(_transaction.timestamp);\n\n        // Make sure the transaction's gas limit is valid. We don't revert here because we reserve\n        // reverts for INVALID_STATE_ACCESS.\n        if (_isValidInput(_transaction) == false) {\n            _resetContext();\n            return bytes(\"\");\n        }\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Check gas right before the call to get total gas consumed by OVM transaction.\n        // uint256 gasProvided = gasleft();\n\n        // Run the transaction, make sure to meter the gas usage.\n        (, bytes memory returndata) = ovmCALL(\n            _transaction.gasLimit - gasMeterConfig.minTransactionGasLimit,\n            _transaction.entrypoint,\n            0,\n            _transaction.data\n        );\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Update the cumulative gas based on the amount of gas used.\n        // uint256 gasUsed = gasProvided - gasleft();\n        // _updateCumulativeGas(gasUsed, _transaction.l1QueueOrigin);\n\n        // Wipe the execution context.\n        _resetContext();\n\n        return returndata;\n  ","after":"   function run(\n        Lib_OVMCodec.Transaction calldata _transaction,\n        address _ovmStateManager\n    )\n    override\n    external\n    returns (\n        bytes memory\n    )\n    {\n        // Make sure that run() is not re-enterable.  This condition should always be satisfied\n        // Once run has been called once, due to the behavior of _isValidInput().\n        if (transactionContext.ovmNUMBER != DEFAULT_UINT256) {\n            return bytes(\"\");\n        }\n\n        // Store our OVM_StateManager instance (significantly easier than attempting to pass the\n        // address around in calldata).\n        ovmStateManager = iOVM_StateManager(_ovmStateManager);\n\n        // Make sure this function can't be called by anyone except the owner of the\n        // OVM_StateManager (expected to be an OVM_StateTransitioner). We can revert here because\n        // this would make the `run` itself invalid.\n        require(\n        // This method may return false during fraud proofs, but always returns true in\n        // L2 nodes' State Manager precompile.\n            ovmStateManager.isAuthenticated(msg.sender),\n            \"Only authenticated addresses in ovmStateManager can call this function\"\n        );\n\n        // Initialize the execution context, must be initialized before we perform any gas metering\n        // or we'll throw a nuisance gas error.\n        _initContext(_transaction);\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Check whether we need to start a new epoch, do so if necessary.\n        // _checkNeedsNewEpoch(_transaction.timestamp);\n\n        // Make sure the transaction's gas limit is valid. We don't revert here because we reserve\n        // reverts for INVALID_STATE_ACCESS.\n        if (_isValidInput(_transaction) == false) {\n            _resetContext();\n            return bytes(\"\");\n        }\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Check gas right before the call to get total gas consumed by OVM transaction.\n        // uint256 gasProvided = gasleft();\n\n        // Run the transaction, make sure to meter the gas usage.\n        (, bytes memory returndata) = ovmCALL(\n            _transaction.gasLimit - gasMeterConfig.minTransactionGasLimit,\n            _transaction.entrypoint,\n            0,\n            _transaction.data\n        );\n\n        // TEMPORARY: Gas metering is disabled for minnet.\n        // // Update the cumulative gas based on the amount of gas used.\n        // uint256 gasUsed = gasProvided - gasleft();\n        // _updateCumulativeGas(gasUsed, _transaction.l1QueueOrigin);\n\n        // Wipe the execution context.\n        _resetContext();\n\n        return returndata;\n  ","contract":"OVM_ExecutionManager","time":0},{"type":"external-function ","before":"   function ovmCREATE2(\n        bytes memory _bytecode,\n        bytes32 _salt\n    )\n    override\n    external\n    notStatic\n    fixedGasDiscount(40000)\n    returns (\n        address,\n        bytes memory\n    )\n    {\n        // Creator is always the current ADDRESS.\n        address creator = ovmADDRESS();\n\n        // Check that the deployer is whitelisted, or\n        // that arbitrary contract deployment has been enabled.\n        _checkDeployerAllowed(creator);\n\n        // Generate the correct CREATE2 address.\n        address contractAddress = Lib_EthUtils.getAddressForCREATE2(\n            creator,\n            _bytecode,\n            _salt\n        );\n\n        return _createContract(\n            contractAddress,\n            _bytecode,\n            MessageType.ovmCREATE2\n        );\n  ","after":"   function ovmCREATE2(\n        bytes calldata _bytecode,\n        bytes32 _salt\n    )\n    override\n    external\n    notStatic\n    fixedGasDiscount(40000)\n    returns (\n        address,\n        bytes memory\n    )\n    {\n        // Creator is always the current ADDRESS.\n        address creator = ovmADDRESS();\n\n        // Check that the deployer is whitelisted, or\n        // that arbitrary contract deployment has been enabled.\n        _checkDeployerAllowed(creator);\n\n        // Generate the correct CREATE2 address.\n        address contractAddress = Lib_EthUtils.getAddressForCREATE2(\n            creator,\n            _bytecode,\n            _salt\n        );\n\n        return _createContract(\n            contractAddress,\n            _bytecode,\n            MessageType.ovmCREATE2\n        );\n  ","contract":"OVM_ExecutionManager","time":0},{"type":"external-function ","before":"   function ovmDELEGATECALL(\n        uint256 _gasLimit,\n        address _address,\n        bytes memory _calldata\n    )\n    override\n    public\n    fixedGasDiscount(40000)\n    returns (\n        bool _success,\n        bytes memory _returndata\n    )\n    {\n        // DELEGATECALL does not change anything about the message context.\n        MessageContext memory nextMessageContext = messageContext;\n\n        return _callContract(\n            nextMessageContext,\n            _gasLimit,\n            _address,\n            _calldata,\n            MessageType.ovmDELEGATECALL\n        );\n  ","after":"   function ovmDELEGATECALL(\n        uint256 _gasLimit,\n        address _address,\n        bytes calldata _calldata\n    )\n    override\n    public\n    fixedGasDiscount(40000)\n    returns (\n        bool _success,\n        bytes memory _returndata\n    )\n    {\n        // DELEGATECALL does not change anything about the message context.\n        MessageContext memory nextMessageContext = messageContext;\n\n        return _callContract(\n            nextMessageContext,\n            _gasLimit,\n            _address,\n            _calldata,\n            MessageType.ovmDELEGATECALL\n        );\n  ","contract":"OVM_ExecutionManager","time":0},{"type":"external-function ","before":"   function safeCREATE(\n        bytes memory _creationCode,\n        address _address\n    )\n    external\n    {\n        // The only way this should callable is from within _createContract(),\n        // and it should DEFINITELY not be callable by a non-EM code contract.\n        if (msg.sender != address(this)) {\n            return;\n        }\n        // Check that there is not already code at this address.\n        if (_hasEmptyAccount(_address) == false) {\n            // Note: in the EVM, this case burns all allotted gas.  For improved\n            // developer experience, we do return the remaining gas.\n            _revertWithFlag(\n                RevertFlag.CREATE_COLLISION\n            );\n        }\n\n        // Check the creation bytecode against the OVM_SafetyChecker.\n        if (ovmSafetyChecker.isBytecodeSafe(_creationCode) == false) {\n            // Note: in the EVM, this case burns all allotted gas.  For improved\n            // developer experience, we do return the remaining gas.\n            _revertWithFlag(\n                RevertFlag.UNSAFE_BYTECODE,\n            // solhint-disable-next-line max-line-length\n                Lib_ErrorUtils.encodeRevertString(\"Contract creation code contains unsafe opcodes. Did you use the right compiler or pass an unsafe constructor argument?\")\n            );\n        }\n\n        // We always need to initialize the contract with the default account values.\n        _initPendingAccount(_address);\n\n        // Actually execute the EVM create message.\n        // NOTE: The inline assembly below means we can NOT make any evm calls between here and then\n        address ethAddress = Lib_EthUtils.createContract(_creationCode);\n\n        if (ethAddress == address(0)) {\n            // If the creation fails, the EVM lets us grab its revert data. This may contain a\n            // revert flag to be used above in _handleExternalMessage, so we pass the revert data\n            // back up unmodified.\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // Again simply checking that the deployed code is safe too. Contracts can generate\n        // arbitrary deployment code, so there's no easy way to analyze this beforehand.\n        bytes memory deployedCode = Lib_EthUtils.getCode(ethAddress);\n        if (ovmSafetyChecker.isBytecodeSafe(deployedCode) == false) {\n            _revertWithFlag(\n                RevertFlag.UNSAFE_BYTECODE,\n            // solhint-disable-next-line max-line-length\n                Lib_ErrorUtils.encodeRevertString(\"Constructor attempted to deploy unsafe bytecode.\")\n            );\n        }\n\n        // Contract creation didn't need to be reverted and the bytecode is safe. We finish up by\n        // associating the desired address with the newly created contract's code hash and address.\n        _commitPendingAccount(\n            _address,\n            ethAddress,\n            Lib_EthUtils.getCodeHash(ethAddress)\n        );\n  ","after":"   function safeCREATE(\n        bytes calldata _creationCode,\n        address _address\n    )\n    external\n    {\n        // The only way this should callable is from within _createContract(),\n        // and it should DEFINITELY not be callable by a non-EM code contract.\n        if (msg.sender != address(this)) {\n            return;\n        }\n        // Check that there is not already code at this address.\n        if (_hasEmptyAccount(_address) == false) {\n            // Note: in the EVM, this case burns all allotted gas.  For improved\n            // developer experience, we do return the remaining gas.\n            _revertWithFlag(\n                RevertFlag.CREATE_COLLISION\n            );\n        }\n\n        // Check the creation bytecode against the OVM_SafetyChecker.\n        if (ovmSafetyChecker.isBytecodeSafe(_creationCode) == false) {\n            // Note: in the EVM, this case burns all allotted gas.  For improved\n            // developer experience, we do return the remaining gas.\n            _revertWithFlag(\n                RevertFlag.UNSAFE_BYTECODE,\n            // solhint-disable-next-line max-line-length\n                Lib_ErrorUtils.encodeRevertString(\"Contract creation code contains unsafe opcodes. Did you use the right compiler or pass an unsafe constructor argument?\")\n            );\n        }\n\n        // We always need to initialize the contract with the default account values.\n        _initPendingAccount(_address);\n\n        // Actually execute the EVM create message.\n        // NOTE: The inline assembly below means we can NOT make any evm calls between here and then\n        address ethAddress = Lib_EthUtils.createContract(_creationCode);\n\n        if (ethAddress == address(0)) {\n            // If the creation fails, the EVM lets us grab its revert data. This may contain a\n            // revert flag to be used above in _handleExternalMessage, so we pass the revert data\n            // back up unmodified.\n            assembly {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n\n        // Again simply checking that the deployed code is safe too. Contracts can generate\n        // arbitrary deployment code, so there's no easy way to analyze this beforehand.\n        bytes memory deployedCode = Lib_EthUtils.getCode(ethAddress);\n        if (ovmSafetyChecker.isBytecodeSafe(deployedCode) == false) {\n            _revertWithFlag(\n                RevertFlag.UNSAFE_BYTECODE,\n            // solhint-disable-next-line max-line-length\n                Lib_ErrorUtils.encodeRevertString(\"Constructor attempted to deploy unsafe bytecode.\")\n            );\n        }\n\n        // Contract creation didn't need to be reverted and the bytecode is safe. We finish up by\n        // associating the desired address with the newly created contract's code hash and address.\n        _commitPendingAccount(\n            _address,\n            ethAddress,\n            Lib_EthUtils.getCodeHash(ethAddress)\n        );\n  ","contract":"OVM_ExecutionManager","time":0},{"type":"external-function ","before":"   function simulateMessage(\n        Lib_OVMCodec.Transaction memory _transaction,\n        address _from,\n        uint256 _value,\n        iOVM_StateManager _ovmStateManager\n    )\n    external\n    returns (\n        bytes memory\n    )\n    {\n        // Prevent this call from having any effect unless in a custom-set VM frame\n        require(msg.sender == address(0));\n\n        // Initialize the EM's internal state, ignoring nuisance gas.\n        ovmStateManager = _ovmStateManager;\n        _initContext(_transaction);\n        messageRecord.nuisanceGasLeft = uint(- 1);\n\n        // Set the ovmADDRESS to the _from so that the subsequent call frame \"comes from\" them.\n        messageContext.ovmADDRESS = _from;\n\n        // Execute the desired message.\n        bool isCreate = _transaction.entrypoint == address(0);\n        if (isCreate) {\n            (address created, bytes memory revertData) = ovmCREATE(_transaction.data);\n            if (created == address(0)) {\n                return abi.encode(false, revertData);\n            } else {\n                // The eth_call RPC endpoint for to = undefined will return the deployed bytecode\n                // in the success case, differing from standard create messages.\n                return abi.encode(true, Lib_EthUtils.getCode(created));\n            }\n        } else {\n            (bool success, bytes memory returndata) = ovmCALL(\n                _transaction.gasLimit,\n                _transaction.entrypoint,\n                _value,\n                _transaction.data\n            );\n            return abi.encode(success, returndata);\n        }\n  ","after":"   function simulateMessage(\n        Lib_OVMCodec.Transaction calldata _transaction,\n        address _from,\n        uint256 _value,\n        iOVM_StateManager _ovmStateManager\n    )\n    external\n    returns (\n        bytes memory\n    )\n    {\n        // Prevent this call from having any effect unless in a custom-set VM frame\n        require(msg.sender == address(0));\n\n        // Initialize the EM's internal state, ignoring nuisance gas.\n        ovmStateManager = _ovmStateManager;\n        _initContext(_transaction);\n        messageRecord.nuisanceGasLeft = uint(- 1);\n\n        // Set the ovmADDRESS to the _from so that the subsequent call frame \"comes from\" them.\n        messageContext.ovmADDRESS = _from;\n\n        // Execute the desired message.\n        bool isCreate = _transaction.entrypoint == address(0);\n        if (isCreate) {\n            (address created, bytes memory revertData) = ovmCREATE(_transaction.data);\n            if (created == address(0)) {\n                return abi.encode(false, revertData);\n            } else {\n                // The eth_call RPC endpoint for to = undefined will return the deployed bytecode\n                // in the success case, differing from standard create messages.\n                return abi.encode(true, Lib_EthUtils.getCode(created));\n            }\n        } else {\n            (bool success, bytes memory returndata) = ovmCALL(\n                _transaction.gasLimit,\n                _transaction.entrypoint,\n                _value,\n                _transaction.data\n            );\n            return abi.encode(success, returndata);\n        }\n  ","contract":"OVM_ExecutionManager","time":0},{"type":"external-function ","before":"   function initializeFraudVerification(\n        bytes32 _preStateRoot,\n        Lib_OVMCodec.ChainBatchHeader memory _preStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _preStateRootProof,\n        Lib_OVMCodec.Transaction memory _transaction,\n        Lib_OVMCodec.TransactionChainElement memory _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader memory _transactionBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _transactionProof\n    )\n    override\n    public\n    contributesToFraudProof(_preStateRoot, Lib_OVMCodec.hashTransaction(_transaction))\n    {\n        bytes32 _txHash = Lib_OVMCodec.hashTransaction(_transaction);\n\n        if (_hasStateTransitioner(_preStateRoot, _txHash)) {\n            return;\n        }\n\n        iOVM_StateCommitmentChain ovmStateCommitmentChain =\n        iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n        iOVM_CanonicalTransactionChain ovmCanonicalTransactionChain =\n        iOVM_CanonicalTransactionChain(resolve(\"OVM_CanonicalTransactionChain\"));\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _preStateRoot,\n                _preStateRootBatchHeader,\n                _preStateRootProof\n            ),\n            \"Invalid pre-state root inclusion proof.\"\n        );\n\n        require(\n            ovmCanonicalTransactionChain.verifyTransaction(\n                _transaction,\n                _txChainElement,\n                _transactionBatchHeader,\n                _transactionProof\n            ),\n            \"Invalid transaction inclusion proof.\"\n        );\n\n        require(\n        // solhint-disable-next-line max-line-length\n            _preStateRootBatchHeader.prevTotalElements + _preStateRootProof.index + 1 == _transactionBatchHeader.prevTotalElements + _transactionProof.index,\n            \"Pre-state root global index must equal to the transaction root global index.\"\n        );\n\n        _deployTransitioner(_preStateRoot, _txHash, _preStateRootProof.index);\n\n        emit FraudProofInitialized(\n            _preStateRoot,\n            _preStateRootProof.index,\n            _txHash,\n            msg.sender\n        );\n  ","after":"   function initializeFraudVerification(\n        bytes32 _preStateRoot,\n        Lib_OVMCodec.ChainBatchHeader calldata _preStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof calldata _preStateRootProof,\n        Lib_OVMCodec.Transaction calldata _transaction,\n        Lib_OVMCodec.TransactionChainElement calldata _txChainElement,\n        Lib_OVMCodec.ChainBatchHeader calldata _transactionBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof calldata _transactionProof\n    )\n    override\n    public\n    contributesToFraudProof(_preStateRoot, Lib_OVMCodec.hashTransaction(_transaction))\n    {\n        bytes32 _txHash = Lib_OVMCodec.hashTransaction(_transaction);\n\n        if (_hasStateTransitioner(_preStateRoot, _txHash)) {\n            return;\n        }\n\n        iOVM_StateCommitmentChain ovmStateCommitmentChain =\n        iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n        iOVM_CanonicalTransactionChain ovmCanonicalTransactionChain =\n        iOVM_CanonicalTransactionChain(resolve(\"OVM_CanonicalTransactionChain\"));\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _preStateRoot,\n                _preStateRootBatchHeader,\n                _preStateRootProof\n            ),\n            \"Invalid pre-state root inclusion proof.\"\n        );\n\n        require(\n            ovmCanonicalTransactionChain.verifyTransaction(\n                _transaction,\n                _txChainElement,\n                _transactionBatchHeader,\n                _transactionProof\n            ),\n            \"Invalid transaction inclusion proof.\"\n        );\n\n        require(\n        // solhint-disable-next-line max-line-length\n            _preStateRootBatchHeader.prevTotalElements + _preStateRootProof.index + 1 == _transactionBatchHeader.prevTotalElements + _transactionProof.index,\n            \"Pre-state root global index must equal to the transaction root global index.\"\n        );\n\n        _deployTransitioner(_preStateRoot, _txHash, _preStateRootProof.index);\n\n        emit FraudProofInitialized(\n            _preStateRoot,\n            _preStateRootProof.index,\n            _txHash,\n            msg.sender\n        );\n  ","contract":"OVM_FraudVerifier","time":0},{"type":"external-function ","before":"   function finalizeFraudVerification(\n        bytes32 _preStateRoot,\n        Lib_OVMCodec.ChainBatchHeader memory _preStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _preStateRootProof,\n        bytes32 _txHash,\n        bytes32 _postStateRoot,\n        Lib_OVMCodec.ChainBatchHeader memory _postStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _postStateRootProof\n    )\n    override\n    public\n    contributesToFraudProof(_preStateRoot, _txHash)\n    {\n        iOVM_StateTransitioner transitioner = getStateTransitioner(_preStateRoot, _txHash);\n        iOVM_StateCommitmentChain ovmStateCommitmentChain =\n        iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n\n        require(\n            transitioner.isComplete() == true,\n            \"State transition process must be completed prior to finalization.\"\n        );\n\n        require(\n        // solhint-disable-next-line max-line-length\n            _postStateRootBatchHeader.prevTotalElements + _postStateRootProof.index == _preStateRootBatchHeader.prevTotalElements + _preStateRootProof.index + 1,\n            \"Post-state root global index must equal to the pre state root global index plus one.\"\n        );\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _preStateRoot,\n                _preStateRootBatchHeader,\n                _preStateRootProof\n            ),\n            \"Invalid pre-state root inclusion proof.\"\n        );\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _postStateRoot,\n                _postStateRootBatchHeader,\n                _postStateRootProof\n            ),\n            \"Invalid post-state root inclusion proof.\"\n        );\n\n        // If the post state root did not match, then there was fraud and we should delete the batch\n        require(\n            _postStateRoot != transitioner.getPostStateRoot(),\n            \"State transition has not been proven fraudulent.\"\n        );\n\n        _cancelStateTransition(_postStateRootBatchHeader, _preStateRoot);\n\n        // TEMPORARY: Remove the transitioner; for minnet.\n        transitioners[keccak256(abi.encodePacked(_preStateRoot, _txHash))] =\n        iOVM_StateTransitioner(0x0000000000000000000000000000000000000000);\n\n        emit FraudProofFinalized(\n            _preStateRoot,\n            _preStateRootProof.index,\n            _txHash,\n            msg.sender\n        );\n  ","after":"   function finalizeFraudVerification(\n        bytes32 _preStateRoot,\n        Lib_OVMCodec.ChainBatchHeader calldata _preStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof calldata _preStateRootProof,\n        bytes32 _txHash,\n        bytes32 _postStateRoot,\n        Lib_OVMCodec.ChainBatchHeader calldata _postStateRootBatchHeader,\n        Lib_OVMCodec.ChainInclusionProof calldata _postStateRootProof\n    )\n    override\n    public\n    contributesToFraudProof(_preStateRoot, _txHash)\n    {\n        iOVM_StateTransitioner transitioner = getStateTransitioner(_preStateRoot, _txHash);\n        iOVM_StateCommitmentChain ovmStateCommitmentChain =\n        iOVM_StateCommitmentChain(resolve(\"OVM_StateCommitmentChain\"));\n\n        require(\n            transitioner.isComplete() == true,\n            \"State transition process must be completed prior to finalization.\"\n        );\n\n        require(\n        // solhint-disable-next-line max-line-length\n            _postStateRootBatchHeader.prevTotalElements + _postStateRootProof.index == _preStateRootBatchHeader.prevTotalElements + _preStateRootProof.index + 1,\n            \"Post-state root global index must equal to the pre state root global index plus one.\"\n        );\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _preStateRoot,\n                _preStateRootBatchHeader,\n                _preStateRootProof\n            ),\n            \"Invalid pre-state root inclusion proof.\"\n        );\n\n        require(\n            ovmStateCommitmentChain.verifyStateCommitment(\n                _postStateRoot,\n                _postStateRootBatchHeader,\n                _postStateRootProof\n            ),\n            \"Invalid post-state root inclusion proof.\"\n        );\n\n        // If the post state root did not match, then there was fraud and we should delete the batch\n        require(\n            _postStateRoot != transitioner.getPostStateRoot(),\n            \"State transition has not been proven fraudulent.\"\n        );\n\n        _cancelStateTransition(_postStateRootBatchHeader, _preStateRoot);\n\n        // TEMPORARY: Remove the transitioner; for minnet.\n        transitioners[keccak256(abi.encodePacked(_preStateRoot, _txHash))] =\n        iOVM_StateTransitioner(0x0000000000000000000000000000000000000000);\n\n        emit FraudProofFinalized(\n            _preStateRoot,\n            _preStateRootProof.index,\n            _txHash,\n            msg.sender\n        );\n  ","contract":"OVM_FraudVerifier","time":0},{"type":"external-function ","before":"   function sendMessage(\n        address _target,\n        bytes memory _message,\n        uint32 _gasLimit\n    )\n    override\n    public\n    {\n        address ovmCanonicalTransactionChain = resolve(\"OVM_CanonicalTransactionChain\");\n        // Use the CTC queue length as nonce\n        uint40 nonce =\n        iOVM_CanonicalTransactionChain(ovmCanonicalTransactionChain).getQueueLength();\n\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            msg.sender,\n            _message,\n            nonce\n        );\n\n        address l2CrossDomainMessenger = resolve(\"OVM_L2CrossDomainMessenger\");\n        _sendXDomainMessage(\n            ovmCanonicalTransactionChain,\n            l2CrossDomainMessenger,\n            xDomainCalldata,\n            _gasLimit\n        );\n        emit SentMessage(xDomainCalldata);\n  ","after":"   function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    )\n    override\n    public\n    {\n        address ovmCanonicalTransactionChain = resolve(\"OVM_CanonicalTransactionChain\");\n        // Use the CTC queue length as nonce\n        uint40 nonce =\n        iOVM_CanonicalTransactionChain(ovmCanonicalTransactionChain).getQueueLength();\n\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            msg.sender,\n            _message,\n            nonce\n        );\n\n        address l2CrossDomainMessenger = resolve(\"OVM_L2CrossDomainMessenger\");\n        _sendXDomainMessage(\n            ovmCanonicalTransactionChain,\n            l2CrossDomainMessenger,\n            xDomainCalldata,\n            _gasLimit\n        );\n        emit SentMessage(xDomainCalldata);\n  ","contract":"OVM_L1CrossDomainMessenger","time":0},{"type":"external-function ","before":"   function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce,\n        L2MessageInclusionProof memory _proof\n    )\n    override\n    public\n    nonReentrant\n    onlyRelayer\n    whenNotPaused\n    {\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            _sender,\n            _message,\n            _messageNonce\n        );\n\n        require(\n            _verifyXDomainMessage(\n                xDomainCalldata,\n                _proof\n            ) == true,\n            \"Provided message could not be verified.\"\n        );\n\n        bytes32 xDomainCalldataHash = keccak256(xDomainCalldata);\n\n        require(\n            successfulMessages[xDomainCalldataHash] == false,\n            \"Provided message has already been received.\"\n        );\n\n        require(\n            blockedMessages[xDomainCalldataHash] == false,\n            \"Provided message has been blocked.\"\n        );\n\n        require(\n            _target != resolve(\"OVM_CanonicalTransactionChain\"),\n            \"Cannot send L2->L1 messages to L1 system contracts.\"\n        );\n\n        xDomainMsgSender = _sender;\n        (bool success,) = _target.call(_message);\n        xDomainMsgSender = DEFAULT_XDOMAIN_SENDER;\n\n        // Mark the message as received if the call was successful. Ensures that a message can be\n        // relayed multiple times in the case that the call reverted.\n        if (success == true) {\n            successfulMessages[xDomainCalldataHash] = true;\n            emit RelayedMessage(xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(xDomainCalldataHash);\n        }\n\n        // Store an identifier that can be used to prove that the given message was relayed by some\n        // user. Gives us an easy way to pay relayers for their work.\n        bytes32 relayId = keccak256(\n            abi.encodePacked(\n                xDomainCalldata,\n                msg.sender,\n                block.number\n            )\n        );\n        relayedMessages[relayId] = true;\n  ","after":"   function relayMessage(\n        address _target,\n        address _sender,\n        bytes calldata _message,\n        uint256 _messageNonce,\n        L2MessageInclusionProof calldata _proof\n    )\n    override\n    public\n    nonReentrant\n    onlyRelayer\n    whenNotPaused\n    {\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            _sender,\n            _message,\n            _messageNonce\n        );\n\n        require(\n            _verifyXDomainMessage(\n                xDomainCalldata,\n                _proof\n            ) == true,\n            \"Provided message could not be verified.\"\n        );\n\n        bytes32 xDomainCalldataHash = keccak256(xDomainCalldata);\n\n        require(\n            successfulMessages[xDomainCalldataHash] == false,\n            \"Provided message has already been received.\"\n        );\n\n        require(\n            blockedMessages[xDomainCalldataHash] == false,\n            \"Provided message has been blocked.\"\n        );\n\n        require(\n            _target != resolve(\"OVM_CanonicalTransactionChain\"),\n            \"Cannot send L2->L1 messages to L1 system contracts.\"\n        );\n\n        xDomainMsgSender = _sender;\n        (bool success,) = _target.call(_message);\n        xDomainMsgSender = DEFAULT_XDOMAIN_SENDER;\n\n        // Mark the message as received if the call was successful. Ensures that a message can be\n        // relayed multiple times in the case that the call reverted.\n        if (success == true) {\n            successfulMessages[xDomainCalldataHash] = true;\n            emit RelayedMessage(xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(xDomainCalldataHash);\n        }\n\n        // Store an identifier that can be used to prove that the given message was relayed by some\n        // user. Gives us an easy way to pay relayers for their work.\n        bytes32 relayId = keccak256(\n            abi.encodePacked(\n                xDomainCalldata,\n                msg.sender,\n                block.number\n            )\n        );\n        relayedMessages[relayId] = true;\n  ","contract":"OVM_L1CrossDomainMessenger","time":0},{"type":"external-function ","before":"   function replayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _queueIndex,\n        uint32 _gasLimit\n    )\n    override\n    public\n    {\n        // Verify that the message is in the queue:\n        address canonicalTransactionChain = resolve(\"OVM_CanonicalTransactionChain\");\n        Lib_OVMCodec.QueueElement memory element =\n        iOVM_CanonicalTransactionChain(canonicalTransactionChain).getQueueElement(_queueIndex);\n\n        address l2CrossDomainMessenger = resolve(\"OVM_L2CrossDomainMessenger\");\n        // Compute the transactionHash\n        bytes32 transactionHash = keccak256(\n            abi.encode(\n                address(this),\n                l2CrossDomainMessenger,\n                _gasLimit,\n                _message\n            )\n        );\n\n        require(\n            transactionHash == element.transactionHash,\n            \"Provided message has not been enqueued.\"\n        );\n\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            _sender,\n            _message,\n            _queueIndex\n        );\n\n        _sendXDomainMessage(\n            canonicalTransactionChain,\n            l2CrossDomainMessenger,\n            xDomainCalldata,\n            _gasLimit\n        );\n  ","after":"   function replayMessage(\n        address _target,\n        address _sender,\n        bytes calldata _message,\n        uint256 _queueIndex,\n        uint32 _gasLimit\n    )\n    override\n    public\n    {\n        // Verify that the message is in the queue:\n        address canonicalTransactionChain = resolve(\"OVM_CanonicalTransactionChain\");\n        Lib_OVMCodec.QueueElement memory element =\n        iOVM_CanonicalTransactionChain(canonicalTransactionChain).getQueueElement(_queueIndex);\n\n        address l2CrossDomainMessenger = resolve(\"OVM_L2CrossDomainMessenger\");\n        // Compute the transactionHash\n        bytes32 transactionHash = keccak256(\n            abi.encode(\n                address(this),\n                l2CrossDomainMessenger,\n                _gasLimit,\n                _message\n            )\n        );\n\n        require(\n            transactionHash == element.transactionHash,\n            \"Provided message has not been enqueued.\"\n        );\n\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            _sender,\n            _message,\n            _queueIndex\n        );\n\n        _sendXDomainMessage(\n            canonicalTransactionChain,\n            l2CrossDomainMessenger,\n            xDomainCalldata,\n            _gasLimit\n        );\n  ","contract":"OVM_L1CrossDomainMessenger","time":0},{"type":"external-function ","before":"   function sendMessage(\n        address _target,\n        bytes memory _message,\n        uint32 _gasLimit\n    )\n    override\n    public\n    {\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            msg.sender,\n            _message,\n            messageNonce\n        );\n\n        messageNonce += 1;\n        sentMessages[keccak256(xDomainCalldata)] = true;\n\n        _sendXDomainMessage(xDomainCalldata, _gasLimit);\n        emit SentMessage(xDomainCalldata);\n  ","after":"   function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    )\n    override\n    public\n    {\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            msg.sender,\n            _message,\n            messageNonce\n        );\n\n        messageNonce += 1;\n        sentMessages[keccak256(xDomainCalldata)] = true;\n\n        _sendXDomainMessage(xDomainCalldata, _gasLimit);\n        emit SentMessage(xDomainCalldata);\n  ","contract":"OVM_L2CrossDomainMessenger","time":0},{"type":"external-function ","before":"   function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    )\n    override\n    nonReentrant\n    public\n    {\n        require(\n            _verifyXDomainMessage() == true,\n            \"Provided message could not be verified.\"\n        );\n\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            _sender,\n            _message,\n            _messageNonce\n        );\n\n        bytes32 xDomainCalldataHash = keccak256(xDomainCalldata);\n\n        require(\n            successfulMessages[xDomainCalldataHash] == false,\n            \"Provided message has already been received.\"\n        );\n\n        // Prevent calls to OVM_L2ToL1MessagePasser, which would enable\n        // an attacker to maliciously craft the _message to spoof\n        // a call from any L2 account.\n        if (_target == resolve(\"OVM_L2ToL1MessagePasser\")) {\n            // Write to the successfulMessages mapping and return immediately.\n            successfulMessages[xDomainCalldataHash] = true;\n            return;\n        }\n\n        xDomainMsgSender = _sender;\n        (bool success,) = _target.call(_message);\n        xDomainMsgSender = DEFAULT_XDOMAIN_SENDER;\n\n        // Mark the message as received if the call was successful. Ensures that a message can be\n        // relayed multiple times in the case that the call reverted.\n        if (success == true) {\n            successfulMessages[xDomainCalldataHash] = true;\n            emit RelayedMessage(xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(xDomainCalldataHash);\n        }\n\n        // Store an identifier that can be used to prove that the given message was relayed by some\n        // user. Gives us an easy way to pay relayers for their work.\n        bytes32 relayId = keccak256(\n            abi.encodePacked(\n                xDomainCalldata,\n                msg.sender,\n                block.number\n            )\n        );\n\n        relayedMessages[relayId] = true;\n  ","after":"   function relayMessage(\n        address _target,\n        address _sender,\n        bytes calldata _message,\n        uint256 _messageNonce\n    )\n    override\n    nonReentrant\n    public\n    {\n        require(\n            _verifyXDomainMessage() == true,\n            \"Provided message could not be verified.\"\n        );\n\n        bytes memory xDomainCalldata = Lib_CrossDomainUtils.encodeXDomainCalldata(\n            _target,\n            _sender,\n            _message,\n            _messageNonce\n        );\n\n        bytes32 xDomainCalldataHash = keccak256(xDomainCalldata);\n\n        require(\n            successfulMessages[xDomainCalldataHash] == false,\n            \"Provided message has already been received.\"\n        );\n\n        // Prevent calls to OVM_L2ToL1MessagePasser, which would enable\n        // an attacker to maliciously craft the _message to spoof\n        // a call from any L2 account.\n        if (_target == resolve(\"OVM_L2ToL1MessagePasser\")) {\n            // Write to the successfulMessages mapping and return immediately.\n            successfulMessages[xDomainCalldataHash] = true;\n            return;\n        }\n\n        xDomainMsgSender = _sender;\n        (bool success,) = _target.call(_message);\n        xDomainMsgSender = DEFAULT_XDOMAIN_SENDER;\n\n        // Mark the message as received if the call was successful. Ensures that a message can be\n        // relayed multiple times in the case that the call reverted.\n        if (success == true) {\n            successfulMessages[xDomainCalldataHash] = true;\n            emit RelayedMessage(xDomainCalldataHash);\n        } else {\n            emit FailedRelayedMessage(xDomainCalldataHash);\n        }\n\n        // Store an identifier that can be used to prove that the given message was relayed by some\n        // user. Gives us an easy way to pay relayers for their work.\n        bytes32 relayId = keccak256(\n            abi.encodePacked(\n                xDomainCalldata,\n                msg.sender,\n                block.number\n            )\n        );\n\n        relayedMessages[relayId] = true;\n  ","contract":"OVM_L2CrossDomainMessenger","time":0},{"type":"immutable-restrict-modification ","before":"   address public l1TokenBrid","after":"   address public l1TokenBrid","contract":"OVM_L2StandardBridge","time":0},{"type":"immutable-restrict-modification ","before":"   address public messeng","after":"   address public messeng","contract":"OVM_L2StandardBridge","time":0},{"type":"external-function ","before":"   function createStandardL2Token(\n        address _l1Token,\n        string memory _name,\n        string memory _symbol\n    )\n    external\n    {\n        require(_l1Token != address(0), \"Must provide L1 token address\");\n\n        L2StandardERC20 l2Token = new L2StandardERC20(\n            Lib_PredeployAddresses.L2_STANDARD_BRIDGE,\n            _l1Token,\n            _name,\n            _symbol\n        );\n\n        emit StandardL2TokenCreated(_l1Token, address(l2Token));\n  ","after":"   function createStandardL2Token(\n        address _l1Token,\n        string calldata _name,\n        string calldata _symbol\n    )\n    external\n    {\n        require(_l1Token != address(0), \"Must provide L1 token address\");\n\n        L2StandardERC20 l2Token = new L2StandardERC20(\n            Lib_PredeployAddresses.L2_STANDARD_BRIDGE,\n            _l1Token,\n            _name,\n            _symbol\n        );\n\n        emit StandardL2TokenCreated(_l1Token, address(l2Token));\n  ","contract":"OVM_L2StandardTokenFactory","time":0},{"type":"external-function ","before":"   function passMessageToL1(\n        bytes memory _message\n    )\n    override\n    public\n    {\n        // Note: although this function is public, only messages sent from the\n        // OVM_L2CrossDomainMessenger will be relayed by the OVM_L1CrossDomainMessenger.\n        // This is enforced by a check in OVM_L1CrossDomainMessenger._verifyStorageProof().\n        sentMessages[keccak256(\n            abi.encodePacked(\n                _message,\n                msg.sender\n            )\n        )] = true;\n  ","after":"   function passMessageToL1(\n        bytes calldata _message\n    )\n    override\n    public\n    {\n        // Note: although this function is public, only messages sent from the\n        // OVM_L2CrossDomainMessenger will be relayed by the OVM_L1CrossDomainMessenger.\n        // This is enforced by a check in OVM_L1CrossDomainMessenger._verifyStorageProof().\n        sentMessages[keccak256(\n            abi.encodePacked(\n                _message,\n                msg.sender\n            )\n        )] = true;\n  ","contract":"OVM_L2ToL1MessagePasser","time":0},{"type":"external-function ","before":"   function isBytecodeSafe(\n        bytes memory _bytecode\n    )\n    override\n    external\n    pure\n    returns (\n        bool\n    )\n    {\n        // autogenerated by gen_safety_checker_constants.py\n        // number of bytes to skip for each opcode\n        uint256[8] memory opcodeSkippableBytes = [\n        uint256(0x0001010101010101010101010000000001010101010101010101010101010000),\n        uint256(0x0100000000000000000000000000000000000000010101010101000000010100),\n        uint256(0x0000000000000000000000000000000001010101000000010101010100000000),\n        uint256(0x0203040500000000000000000000000000000000000000000000000000000000),\n        uint256(0x0101010101010101010101010101010101010101010101010101010101010101),\n        uint256(0x0101010101000000000000000000000000000000000000000000000000000000),\n        uint256(0x0000000000000000000000000000000000000000000000000000000000000000),\n        uint256(0x0000000000000000000000000000000000000000000000000000000000000000)\n        ];\n        // Mask to gate opcode specific cases\n        // solhint-disable-next-line max-line-length\n        uint256 opcodeGateMask = ~uint256(0xffffffffffffffffffffffe000000000fffffffff070ffff9c0ffffec000f001);\n        // Halting opcodes\n        // solhint-disable-next-line max-line-length\n        uint256 opcodeHaltingMask = ~uint256(0x4008000000000000000000000000000000000000004000000000000000000001);\n        // PUSH opcodes\n        uint256 opcodePushMask = ~uint256(0xffffffff000000000000000000000000);\n\n        uint256 codeLength;\n        uint256 _pc;\n        assembly {\n            _pc := add(_bytecode, 0x20)\n        }\n        codeLength = _pc + _bytecode.length;\n        do {\n            // current opcode: 0x00...0xff\n            uint256 opNum;\n\n            /* solhint-disable max-line-length */\n            // inline assembly removes the extra add + bounds check\n            assembly {\n                let word := mload(_pc) //load the next 32 bytes at pc into word\n\n            // Look up number of bytes to skip from opcodeSkippableBytes and then update indexInWord\n            // E.g. the 02030405 in opcodeSkippableBytes is the number of bytes to skip for PUSH1->4\n            // We repeat this 6 times, thus we can only skip bytes for up to PUSH4 ((1+4) * 6 = 30 < 32).\n            // If we see an opcode that is listed as 0 skippable bytes e.g. PUSH5,\n            // then we will get stuck on that indexInWord and then opNum will be set to the PUSH5 opcode.\n                let indexInWord := byte(0, mload(add(opcodeSkippableBytes, byte(0, word))))\n                indexInWord := add(indexInWord, byte(0, mload(add(opcodeSkippableBytes, byte(indexInWord, word)))))\n                indexInWord := add(indexInWord, byte(0, mload(add(opcodeSkippableBytes, byte(indexInWord, word)))))\n                indexInWord := add(indexInWord, byte(0, mload(add(opcodeSkippableBytes, byte(indexInWord, word)))))\n                indexInWord := add(indexInWord, byte(0, mload(add(opcodeSkippableBytes, byte(indexInWord, word)))))\n                indexInWord := add(indexInWord, byte(0, mload(add(opcodeSkippableBytes, byte(indexInWord, word)))))\n                _pc := add(_pc, indexInWord)\n\n                opNum := byte(indexInWord, word)\n            }\n            /* solhint-enable max-line-length */\n\n            // + push opcodes\n            // + stop opcodes [STOP(0x00),JUMP(0x56),RETURN(0xf3),INVALID(0xfe)]\n            // + caller opcode CALLER(0x33)\n            // + blacklisted opcodes\n            uint256 opBit = 1 << opNum;\n            if (opBit & opcodeGateMask == 0) {\n                if (opBit & opcodePushMask == 0) {\n                    // all pushes are valid opcodes\n                    // subsequent bytes are not opcodes. Skip them.\n                    _pc += (opNum - 0x5e);\n                    // PUSH1 is 0x60, so opNum-0x5f = PUSHed bytes and we\n                    // +1 to skip the _pc++; line below in order to save gas ((-0x5f + 1) = -0x5e)\n                    continue;\n                } else if (opBit & opcodeHaltingMask == 0) {\n                    // STOP or JUMP or RETURN or INVALID (Note: REVERT is blacklisted, so not\n                    // included here)\n                    // We are now inside unreachable code until we hit a JUMPDEST!\n                    do {\n                        _pc++;\n                        assembly {\n                            opNum := byte(0, mload(_pc))\n                        }\n                        // encountered a JUMPDEST\n                        if (opNum == 0x5b) break;\n                        // skip PUSHed bytes\n                        // opNum-0x5f = PUSHed bytes (PUSH1 is 0x60)\n                        if ((1 << opNum) & opcodePushMask == 0) _pc += (opNum - 0x5f);\n                    }\n                    while (_pc < codeLength);\n                    // opNum is 0x5b, so we don't continue here since the pc++ is fine\n                } else if (opNum == 0x33) {// Caller opcode\n                    uint256 firstOps;\n                    // next 32 bytes of bytecode\n                    uint256 secondOps;\n                    // following 32 bytes of bytecode\n\n                    assembly {\n                        firstOps := mload(_pc)\n                    // 37 bytes total, 5 left over --> 32 - 5 bytes = 27 bytes = 216 bits\n                        secondOps := shr(216, mload(add(_pc, 0x20)))\n                    }\n\n                    // Call identity precompile\n                    // CALLER POP PUSH1 0x00 PUSH1 0x04 GAS CALL\n                    // 32 - 8 bytes = 24 bytes = 192\n                    if ((firstOps >> 192) == 0x3350600060045af1) {\n                        _pc += 8;\n                        // Call EM and abort execution if instructed\n                        // CALLER PUSH1 0x00 SWAP1 GAS CALL PC PUSH1 0x0E ADD JUMPI RETURNDATASIZE\n                        // PUSH1 0x00 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x00 REVERT JUMPDEST\n                        // RETURNDATASIZE PUSH1 0x01 EQ ISZERO PC PUSH1 0x0a ADD JUMPI PUSH1 0x01 PUSH1\n                        // 0x00 RETURN JUMPDEST\n                        // solhint-disable-next-line max-line-length\n                    } else if (firstOps == 0x336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760 && secondOps == 0x016000f35b) {\n                        _pc += 37;\n                    } else {\n                        return false;\n                    }\n                    continue;\n                } else {\n                    // encountered a non-whitelisted opcode!\n                    return false;\n                }\n            }\n            _pc++;\n        }\n        while (_pc < codeLength);\n        return true;\n  ","after":"   function isBytecodeSafe(\n        bytes calldata _bytecode\n    )\n    override\n    external\n    pure\n    returns (\n        bool\n    )\n    {\n        // autogenerated by gen_safety_checker_constants.py\n        // number of bytes to skip for each opcode\n        uint256[8] memory opcodeSkippableBytes = [\n        uint256(0x0001010101010101010101010000000001010101010101010101010101010000),\n        uint256(0x0100000000000000000000000000000000000000010101010101000000010100),\n        uint256(0x0000000000000000000000000000000001010101000000010101010100000000),\n        uint256(0x0203040500000000000000000000000000000000000000000000000000000000),\n        uint256(0x0101010101010101010101010101010101010101010101010101010101010101),\n        uint256(0x0101010101000000000000000000000000000000000000000000000000000000),\n        uint256(0x0000000000000000000000000000000000000000000000000000000000000000),\n        uint256(0x0000000000000000000000000000000000000000000000000000000000000000)\n        ];\n        // Mask to gate opcode specific cases\n        // solhint-disable-next-line max-line-length\n        uint256 opcodeGateMask = ~uint256(0xffffffffffffffffffffffe000000000fffffffff070ffff9c0ffffec000f001);\n        // Halting opcodes\n        // solhint-disable-next-line max-line-length\n        uint256 opcodeHaltingMask = ~uint256(0x4008000000000000000000000000000000000000004000000000000000000001);\n        // PUSH opcodes\n        uint256 opcodePushMask = ~uint256(0xffffffff000000000000000000000000);\n\n        uint256 codeLength;\n        uint256 _pc;\n        assembly {\n            _pc := add(_bytecode, 0x20)\n        }\n        codeLength = _pc + _bytecode.length;\n        do {\n            // current opcode: 0x00...0xff\n            uint256 opNum;\n\n            /* solhint-disable max-line-length */\n            // inline assembly removes the extra add + bounds check\n            assembly {\n                let word := mload(_pc) //load the next 32 bytes at pc into word\n\n            // Look up number of bytes to skip from opcodeSkippableBytes and then update indexInWord\n            // E.g. the 02030405 in opcodeSkippableBytes is the number of bytes to skip for PUSH1->4\n            // We repeat this 6 times, thus we can only skip bytes for up to PUSH4 ((1+4) * 6 = 30 < 32).\n            // If we see an opcode that is listed as 0 skippable bytes e.g. PUSH5,\n            // then we will get stuck on that indexInWord and then opNum will be set to the PUSH5 opcode.\n                let indexInWord := byte(0, mload(add(opcodeSkippableBytes, byte(0, word))))\n                indexInWord := add(indexInWord, byte(0, mload(add(opcodeSkippableBytes, byte(indexInWord, word)))))\n                indexInWord := add(indexInWord, byte(0, mload(add(opcodeSkippableBytes, byte(indexInWord, word)))))\n                indexInWord := add(indexInWord, byte(0, mload(add(opcodeSkippableBytes, byte(indexInWord, word)))))\n                indexInWord := add(indexInWord, byte(0, mload(add(opcodeSkippableBytes, byte(indexInWord, word)))))\n                indexInWord := add(indexInWord, byte(0, mload(add(opcodeSkippableBytes, byte(indexInWord, word)))))\n                _pc := add(_pc, indexInWord)\n\n                opNum := byte(indexInWord, word)\n            }\n            /* solhint-enable max-line-length */\n\n            // + push opcodes\n            // + stop opcodes [STOP(0x00),JUMP(0x56),RETURN(0xf3),INVALID(0xfe)]\n            // + caller opcode CALLER(0x33)\n            // + blacklisted opcodes\n            uint256 opBit = 1 << opNum;\n            if (opBit & opcodeGateMask == 0) {\n                if (opBit & opcodePushMask == 0) {\n                    // all pushes are valid opcodes\n                    // subsequent bytes are not opcodes. Skip them.\n                    _pc += (opNum - 0x5e);\n                    // PUSH1 is 0x60, so opNum-0x5f = PUSHed bytes and we\n                    // +1 to skip the _pc++; line below in order to save gas ((-0x5f + 1) = -0x5e)\n                    continue;\n                } else if (opBit & opcodeHaltingMask == 0) {\n                    // STOP or JUMP or RETURN or INVALID (Note: REVERT is blacklisted, so not\n                    // included here)\n                    // We are now inside unreachable code until we hit a JUMPDEST!\n                    do {\n                        _pc++;\n                        assembly {\n                            opNum := byte(0, mload(_pc))\n                        }\n                        // encountered a JUMPDEST\n                        if (opNum == 0x5b) break;\n                        // skip PUSHed bytes\n                        // opNum-0x5f = PUSHed bytes (PUSH1 is 0x60)\n                        if ((1 << opNum) & opcodePushMask == 0) _pc += (opNum - 0x5f);\n                    }\n                    while (_pc < codeLength);\n                    // opNum is 0x5b, so we don't continue here since the pc++ is fine\n                } else if (opNum == 0x33) {// Caller opcode\n                    uint256 firstOps;\n                    // next 32 bytes of bytecode\n                    uint256 secondOps;\n                    // following 32 bytes of bytecode\n\n                    assembly {\n                        firstOps := mload(_pc)\n                    // 37 bytes total, 5 left over --> 32 - 5 bytes = 27 bytes = 216 bits\n                        secondOps := shr(216, mload(add(_pc, 0x20)))\n                    }\n\n                    // Call identity precompile\n                    // CALLER POP PUSH1 0x00 PUSH1 0x04 GAS CALL\n                    // 32 - 8 bytes = 24 bytes = 192\n                    if ((firstOps >> 192) == 0x3350600060045af1) {\n                        _pc += 8;\n                        // Call EM and abort execution if instructed\n                        // CALLER PUSH1 0x00 SWAP1 GAS CALL PC PUSH1 0x0E ADD JUMPI RETURNDATASIZE\n                        // PUSH1 0x00 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x00 REVERT JUMPDEST\n                        // RETURNDATASIZE PUSH1 0x01 EQ ISZERO PC PUSH1 0x0a ADD JUMPI PUSH1 0x01 PUSH1\n                        // 0x00 RETURN JUMPDEST\n                        // solhint-disable-next-line max-line-length\n                    } else if (firstOps == 0x336000905af158600e01573d6000803e3d6000fd5b3d6001141558600a015760 && secondOps == 0x016000f35b) {\n                        _pc += 37;\n                    } else {\n                        return false;\n                    }\n                    continue;\n                } else {\n                    // encountered a non-whitelisted opcode!\n                    return false;\n                }\n            }\n            _pc++;\n        }\n        while (_pc < codeLength);\n        return true;\n  ","contract":"OVM_SafetyChecker","time":0},{"type":"immutable-restrict-modification ","before":"   address public l1FeeWall","after":"   address public l1FeeWall","contract":"OVM_SequencerFeeVault","time":0},{"type":"external-function ","before":"   function appendStateBatch(\n        bytes32[] memory _batch,\n        uint256 _shouldStartAtElement\n    )\n    override\n    public\n    {\n        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\n        // publication of batches by some other user.\n        require(\n            _shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );\n\n        // Proposers must have previously staked at the BondManager\n        require(\n            iOVM_BondManager(resolve(\"OVM_BondManager\")).isCollateralized(msg.sender),\n            \"Proposer does not have enough collateral posted\"\n        );\n\n        require(\n            _batch.length > 0,\n            \"Cannot submit an empty state batch.\"\n        );\n\n        require(\n            getTotalElements() + _batch.length <=\n            iOVM_CanonicalTransactionChain(resolve(\"OVM_CanonicalTransactionChain\"))\n            .getTotalElements(),\n            \"Number of state roots cannot exceed the number of canonical transactions.\"\n        );\n\n        // Pass the block's timestamp and the publisher of the data\n        // to be used in the fraud proofs\n        _appendBatch(\n            _batch,\n            abi.encode(block.timestamp, msg.sender)\n        );\n  ","after":"   function appendStateBatch(\n        bytes32[] calldata _batch,\n        uint256 _shouldStartAtElement\n    )\n    override\n    public\n    {\n        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\n        // publication of batches by some other user.\n        require(\n            _shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );\n\n        // Proposers must have previously staked at the BondManager\n        require(\n            iOVM_BondManager(resolve(\"OVM_BondManager\")).isCollateralized(msg.sender),\n            \"Proposer does not have enough collateral posted\"\n        );\n\n        require(\n            _batch.length > 0,\n            \"Cannot submit an empty state batch.\"\n        );\n\n        require(\n            getTotalElements() + _batch.length <=\n            iOVM_CanonicalTransactionChain(resolve(\"OVM_CanonicalTransactionChain\"))\n            .getTotalElements(),\n            \"Number of state roots cannot exceed the number of canonical transactions.\"\n        );\n\n        // Pass the block's timestamp and the publisher of the data\n        // to be used in the fraud proofs\n        _appendBatch(\n            _batch,\n            abi.encode(block.timestamp, msg.sender)\n        );\n  ","contract":"OVM_StateCommitmentChain","time":0},{"type":"external-function ","before":"   function deleteStateBatch(\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader\n    )\n    override\n    public\n    {\n        require(\n            msg.sender == resolve(\"OVM_FraudVerifier\"),\n            \"State batches can only be deleted by the OVM_FraudVerifier.\"\n        );\n\n        require(\n            _isValidBatchHeader(_batchHeader),\n            \"Invalid batch header.\"\n        );\n\n        require(\n            insideFraudProofWindow(_batchHeader),\n            \"State batches can only be deleted within the fraud proof window.\"\n        );\n\n        _deleteBatch(_batchHeader);\n  ","after":"   function deleteStateBatch(\n        Lib_OVMCodec.ChainBatchHeader calldata _batchHeader\n    )\n    override\n    public\n    {\n        require(\n            msg.sender == resolve(\"OVM_FraudVerifier\"),\n            \"State batches can only be deleted by the OVM_FraudVerifier.\"\n        );\n\n        require(\n            _isValidBatchHeader(_batchHeader),\n            \"Invalid batch header.\"\n        );\n\n        require(\n            insideFraudProofWindow(_batchHeader),\n            \"State batches can only be deleted within the fraud proof window.\"\n        );\n\n        _deleteBatch(_batchHeader);\n  ","contract":"OVM_StateCommitmentChain","time":0},{"type":"external-function ","before":"   function verifyStateCommitment(\n        bytes32 _element,\n        Lib_OVMCodec.ChainBatchHeader memory _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof memory _proof\n    )\n    override\n    public\n    view\n    returns (\n        bool\n    )\n    {\n        require(\n            _isValidBatchHeader(_batchHeader),\n            \"Invalid batch header.\"\n        );\n\n        require(\n            Lib_MerkleTree.verify(\n                _batchHeader.batchRoot,\n                _element,\n                _proof.index,\n                _proof.siblings,\n                _batchHeader.batchSize\n            ),\n            \"Invalid inclusion proof.\"\n        );\n\n        return true;\n  ","after":"   function verifyStateCommitment(\n        bytes32 _element,\n        Lib_OVMCodec.ChainBatchHeader calldata _batchHeader,\n        Lib_OVMCodec.ChainInclusionProof calldata _proof\n    )\n    override\n    public\n    view\n    returns (\n        bool\n    )\n    {\n        require(\n            _isValidBatchHeader(_batchHeader),\n            \"Invalid batch header.\"\n        );\n\n        require(\n            Lib_MerkleTree.verify(\n                _batchHeader.batchRoot,\n                _element,\n                _proof.index,\n                _proof.siblings,\n                _batchHeader.batchSize\n            ),\n            \"Invalid inclusion proof.\"\n        );\n\n        return true;\n  ","contract":"OVM_StateCommitmentChain","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public FRAUD_PROOF_WIND","after":"   uint256 public FRAUD_PROOF_WIND","contract":"OVM_StateCommitmentChain","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 public SEQUENCER_PUBLISH_WIND","after":"   uint256 public SEQUENCER_PUBLISH_WIND","contract":"OVM_StateCommitmentChain","time":1},{"type":"external-function ","before":"*/\nfunction putAccount(\naddress _address,\nLib_OVMCodec.Account memory _account\n)\noverride\npublic\nauthenticated\n{\naccounts[_address] = _account","after":"*/\nfunction putAccount(\naddress _address,\nLib_OVMCodec.Account calldata _account\n)\noverride\npublic\nauthenticated\n{\naccounts[_address] = _account","contract":"OVM_StateManager","time":0},{"type":"immutable-restrict-modification ","before":"/\n\naddress override public own","after":"/\n\naddress override public own","contract":"OVM_StateManager","time":0},{"type":"external-function ","before":"   function proveContractState(\n        address _ovmContractAddress,\n        address _ethContractAddress,\n        bytes memory _stateTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        // Exit quickly to avoid unnecessary work.\n        require(\n            (\n            ovmStateManager.hasAccount(_ovmContractAddress) == false\n            && ovmStateManager.hasEmptyAccount(_ovmContractAddress) == false\n            ),\n            \"Account state has already been proven.\"\n        );\n\n        // Function will fail if the proof is not a valid inclusion or exclusion proof.\n        (\n        bool exists,\n        bytes memory encodedAccount\n        ) = Lib_SecureMerkleTrie.get(\n            abi.encodePacked(_ovmContractAddress),\n            _stateTrieWitness,\n            preStateRoot\n        );\n\n        if (exists == true) {\n            // Account exists, this was an inclusion proof.\n            Lib_OVMCodec.EVMAccount memory account = Lib_OVMCodec.decodeEVMAccount(\n                encodedAccount\n            );\n\n            address ethContractAddress = _ethContractAddress;\n            if (account.codeHash == EMPTY_ACCOUNT_CODE_HASH) {\n                // Use a known empty contract to prevent an attack in which a user provides a\n                // contract address here and then later deploys code to it.\n                ethContractAddress = 0x0000000000000000000000000000000000000000;\n            } else {\n                // Otherwise, make sure that the code at the provided eth address matches the hash\n                // of the code stored on L2.\n                require(\n                    Lib_EthUtils.getCodeHash(ethContractAddress) == account.codeHash,\n                // solhint-disable-next-line max-line-length\n                    \"OVM_StateTransitioner: Provided L1 contract code hash does not match L2 contract code hash.\"\n                );\n            }\n\n            ovmStateManager.putAccount(\n                _ovmContractAddress,\n                Lib_OVMCodec.Account({\n            nonce : account.nonce,\n            balance : account.balance,\n            storageRoot : account.storageRoot,\n            codeHash : account.codeHash,\n            ethAddress : ethContractAddress,\n            isFresh : false\n            })\n            );\n        } else {\n            // Account does not exist, this was an exclusion proof.\n            ovmStateManager.putEmptyAccount(_ovmContractAddress);\n        }\n  ","after":"   function proveContractState(\n        address _ovmContractAddress,\n        address _ethContractAddress,\n        bytes calldata _stateTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        // Exit quickly to avoid unnecessary work.\n        require(\n            (\n            ovmStateManager.hasAccount(_ovmContractAddress) == false\n            && ovmStateManager.hasEmptyAccount(_ovmContractAddress) == false\n            ),\n            \"Account state has already been proven.\"\n        );\n\n        // Function will fail if the proof is not a valid inclusion or exclusion proof.\n        (\n        bool exists,\n        bytes memory encodedAccount\n        ) = Lib_SecureMerkleTrie.get(\n            abi.encodePacked(_ovmContractAddress),\n            _stateTrieWitness,\n            preStateRoot\n        );\n\n        if (exists == true) {\n            // Account exists, this was an inclusion proof.\n            Lib_OVMCodec.EVMAccount memory account = Lib_OVMCodec.decodeEVMAccount(\n                encodedAccount\n            );\n\n            address ethContractAddress = _ethContractAddress;\n            if (account.codeHash == EMPTY_ACCOUNT_CODE_HASH) {\n                // Use a known empty contract to prevent an attack in which a user provides a\n                // contract address here and then later deploys code to it.\n                ethContractAddress = 0x0000000000000000000000000000000000000000;\n            } else {\n                // Otherwise, make sure that the code at the provided eth address matches the hash\n                // of the code stored on L2.\n                require(\n                    Lib_EthUtils.getCodeHash(ethContractAddress) == account.codeHash,\n                // solhint-disable-next-line max-line-length\n                    \"OVM_StateTransitioner: Provided L1 contract code hash does not match L2 contract code hash.\"\n                );\n            }\n\n            ovmStateManager.putAccount(\n                _ovmContractAddress,\n                Lib_OVMCodec.Account({\n            nonce : account.nonce,\n            balance : account.balance,\n            storageRoot : account.storageRoot,\n            codeHash : account.codeHash,\n            ethAddress : ethContractAddress,\n            isFresh : false\n            })\n            );\n        } else {\n            // Account does not exist, this was an exclusion proof.\n            ovmStateManager.putEmptyAccount(_ovmContractAddress);\n        }\n  ","contract":"OVM_StateTransitioner","time":0},{"type":"external-function ","before":"   function proveStorageSlot(\n        address _ovmContractAddress,\n        bytes32 _key,\n        bytes memory _storageTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        // Exit quickly to avoid unnecessary work.\n        require(\n            ovmStateManager.hasContractStorage(_ovmContractAddress, _key) == false,\n            \"Storage slot has already been proven.\"\n        );\n\n        require(\n            ovmStateManager.hasAccount(_ovmContractAddress) == true,\n            \"Contract must be verified before proving a storage slot.\"\n        );\n\n        bytes32 storageRoot = ovmStateManager.getAccountStorageRoot(_ovmContractAddress);\n        bytes32 value;\n\n        if (storageRoot == EMPTY_ACCOUNT_STORAGE_ROOT) {\n            // Storage trie was empty, so the user is always allowed to insert zero-byte values.\n            value = bytes32(0);\n        } else {\n            // Function will fail if the proof is not a valid inclusion or exclusion proof.\n            (\n            bool exists,\n            bytes memory encodedValue\n            ) = Lib_SecureMerkleTrie.get(\n                abi.encodePacked(_key),\n                _storageTrieWitness,\n                storageRoot\n            );\n\n            if (exists == true) {\n                // Inclusion proof.\n                // Stored values are RLP encoded, with leading zeros removed.\n                value = Lib_BytesUtils.toBytes32PadLeft(\n                    Lib_RLPReader.readBytes(encodedValue)\n                );\n            } else {\n                // Exclusion proof, can only be zero bytes.\n                value = bytes32(0);\n            }\n        }\n\n        ovmStateManager.putContractStorage(\n            _ovmContractAddress,\n            _key,\n            value\n        );\n  ","after":"   function proveStorageSlot(\n        address _ovmContractAddress,\n        bytes32 _key,\n        bytes calldata _storageTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        // Exit quickly to avoid unnecessary work.\n        require(\n            ovmStateManager.hasContractStorage(_ovmContractAddress, _key) == false,\n            \"Storage slot has already been proven.\"\n        );\n\n        require(\n            ovmStateManager.hasAccount(_ovmContractAddress) == true,\n            \"Contract must be verified before proving a storage slot.\"\n        );\n\n        bytes32 storageRoot = ovmStateManager.getAccountStorageRoot(_ovmContractAddress);\n        bytes32 value;\n\n        if (storageRoot == EMPTY_ACCOUNT_STORAGE_ROOT) {\n            // Storage trie was empty, so the user is always allowed to insert zero-byte values.\n            value = bytes32(0);\n        } else {\n            // Function will fail if the proof is not a valid inclusion or exclusion proof.\n            (\n            bool exists,\n            bytes memory encodedValue\n            ) = Lib_SecureMerkleTrie.get(\n                abi.encodePacked(_key),\n                _storageTrieWitness,\n                storageRoot\n            );\n\n            if (exists == true) {\n                // Inclusion proof.\n                // Stored values are RLP encoded, with leading zeros removed.\n                value = Lib_BytesUtils.toBytes32PadLeft(\n                    Lib_RLPReader.readBytes(encodedValue)\n                );\n            } else {\n                // Exclusion proof, can only be zero bytes.\n                value = bytes32(0);\n            }\n        }\n\n        ovmStateManager.putContractStorage(\n            _ovmContractAddress,\n            _key,\n            value\n        );\n  ","contract":"OVM_StateTransitioner","time":0},{"type":"external-function ","before":"   function applyTransaction(\n        Lib_OVMCodec.Transaction memory _transaction\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            Lib_OVMCodec.hashTransaction(_transaction) == transactionHash,\n            \"Invalid transaction provided.\"\n        );\n\n        // We require gas to complete the logic here in run() before/after execution,\n        // But must ensure the full _tx.gasLimit can be given to the ovmCALL (determinism)\n        // This includes 1/64 of the gas getting lost because of EIP-150 (lost twice--first\n        // going into EM, then going into the code contract).\n        require(\n        // 1032/1000 = 1.032 = (64/63)^2 rounded up\n            gasleft() >= 100000 + _transaction.gasLimit * 1032 / 1000,\n            \"Not enough gas to execute transaction deterministically.\"\n        );\n\n        iOVM_ExecutionManager ovmExecutionManager =\n        iOVM_ExecutionManager(resolve(\"OVM_ExecutionManager\"));\n\n        // We call `setExecutionManager` right before `run` (and not earlier) just in case the\n        // OVM_ExecutionManager address was updated between the time when this contract was created\n        // and when `applyTransaction` was called.\n        ovmStateManager.setExecutionManager(address(ovmExecutionManager));\n\n        // `run` always succeeds *unless* the user hasn't provided enough gas to `applyTransaction`\n        // or an INVALID_STATE_ACCESS flag was triggered. Either way, we won't get beyond this line\n        // if that's the case.\n        ovmExecutionManager.run(_transaction, address(ovmStateManager));\n\n        // Prevent the Execution Manager from calling this SM again.\n        ovmStateManager.setExecutionManager(address(0));\n        phase = TransitionPhase.POST_EXECUTION;\n  ","after":"   function applyTransaction(\n        Lib_OVMCodec.Transaction calldata _transaction\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.PRE_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            Lib_OVMCodec.hashTransaction(_transaction) == transactionHash,\n            \"Invalid transaction provided.\"\n        );\n\n        // We require gas to complete the logic here in run() before/after execution,\n        // But must ensure the full _tx.gasLimit can be given to the ovmCALL (determinism)\n        // This includes 1/64 of the gas getting lost because of EIP-150 (lost twice--first\n        // going into EM, then going into the code contract).\n        require(\n        // 1032/1000 = 1.032 = (64/63)^2 rounded up\n            gasleft() >= 100000 + _transaction.gasLimit * 1032 / 1000,\n            \"Not enough gas to execute transaction deterministically.\"\n        );\n\n        iOVM_ExecutionManager ovmExecutionManager =\n        iOVM_ExecutionManager(resolve(\"OVM_ExecutionManager\"));\n\n        // We call `setExecutionManager` right before `run` (and not earlier) just in case the\n        // OVM_ExecutionManager address was updated between the time when this contract was created\n        // and when `applyTransaction` was called.\n        ovmStateManager.setExecutionManager(address(ovmExecutionManager));\n\n        // `run` always succeeds *unless* the user hasn't provided enough gas to `applyTransaction`\n        // or an INVALID_STATE_ACCESS flag was triggered. Either way, we won't get beyond this line\n        // if that's the case.\n        ovmExecutionManager.run(_transaction, address(ovmStateManager));\n\n        // Prevent the Execution Manager from calling this SM again.\n        ovmStateManager.setExecutionManager(address(0));\n        phase = TransitionPhase.POST_EXECUTION;\n  ","contract":"OVM_StateTransitioner","time":0},{"type":"external-function ","before":"   function commitContractState(\n        address _ovmContractAddress,\n        bytes memory _stateTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.POST_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            ovmStateManager.getTotalUncommittedContractStorage() == 0,\n            \"All storage must be committed before committing account states.\"\n        );\n\n        require(\n            ovmStateManager.commitAccount(_ovmContractAddress) == true,\n            \"Account state wasn't changed or has already been committed.\"\n        );\n\n        Lib_OVMCodec.Account memory account = ovmStateManager.getAccount(_ovmContractAddress);\n\n        postStateRoot = Lib_SecureMerkleTrie.update(\n            abi.encodePacked(_ovmContractAddress),\n            Lib_OVMCodec.encodeEVMAccount(\n                Lib_OVMCodec.toEVMAccount(account)\n            ),\n            _stateTrieWitness,\n            postStateRoot\n        );\n\n        // Emit an event to help clients figure out the proof ordering.\n        emit AccountCommitted(\n            _ovmContractAddress\n        );\n  ","after":"   function commitContractState(\n        address _ovmContractAddress,\n        bytes calldata _stateTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.POST_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            ovmStateManager.getTotalUncommittedContractStorage() == 0,\n            \"All storage must be committed before committing account states.\"\n        );\n\n        require(\n            ovmStateManager.commitAccount(_ovmContractAddress) == true,\n            \"Account state wasn't changed or has already been committed.\"\n        );\n\n        Lib_OVMCodec.Account memory account = ovmStateManager.getAccount(_ovmContractAddress);\n\n        postStateRoot = Lib_SecureMerkleTrie.update(\n            abi.encodePacked(_ovmContractAddress),\n            Lib_OVMCodec.encodeEVMAccount(\n                Lib_OVMCodec.toEVMAccount(account)\n            ),\n            _stateTrieWitness,\n            postStateRoot\n        );\n\n        // Emit an event to help clients figure out the proof ordering.\n        emit AccountCommitted(\n            _ovmContractAddress\n        );\n  ","contract":"OVM_StateTransitioner","time":0},{"type":"external-function ","before":"   function commitStorageSlot(\n        address _ovmContractAddress,\n        bytes32 _key,\n        bytes memory _storageTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.POST_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            ovmStateManager.commitContractStorage(_ovmContractAddress, _key) == true,\n            \"Storage slot value wasn't changed or has already been committed.\"\n        );\n\n        Lib_OVMCodec.Account memory account = ovmStateManager.getAccount(_ovmContractAddress);\n        bytes32 value = ovmStateManager.getContractStorage(_ovmContractAddress, _key);\n\n        account.storageRoot = Lib_SecureMerkleTrie.update(\n            abi.encodePacked(_key),\n            Lib_RLPWriter.writeBytes(\n                Lib_Bytes32Utils.removeLeadingZeros(value)\n            ),\n            _storageTrieWitness,\n            account.storageRoot\n        );\n\n        ovmStateManager.putAccount(_ovmContractAddress, account);\n\n        // Emit an event to help clients figure out the proof ordering.\n        emit ContractStorageCommitted(\n            _ovmContractAddress,\n            _key\n        );\n  ","after":"   function commitStorageSlot(\n        address _ovmContractAddress,\n        bytes32 _key,\n        bytes calldata _storageTrieWitness\n    )\n    override\n    external\n    onlyDuringPhase(TransitionPhase.POST_EXECUTION)\n    contributesToFraudProof(preStateRoot, transactionHash)\n    {\n        require(\n            ovmStateManager.commitContractStorage(_ovmContractAddress, _key) == true,\n            \"Storage slot value wasn't changed or has already been committed.\"\n        );\n\n        Lib_OVMCodec.Account memory account = ovmStateManager.getAccount(_ovmContractAddress);\n        bytes32 value = ovmStateManager.getContractStorage(_ovmContractAddress, _key);\n\n        account.storageRoot = Lib_SecureMerkleTrie.update(\n            abi.encodePacked(_key),\n            Lib_RLPWriter.writeBytes(\n                Lib_Bytes32Utils.removeLeadingZeros(value)\n            ),\n            _storageTrieWitness,\n            account.storageRoot\n        );\n\n        ovmStateManager.putAccount(_ovmContractAddress, account);\n\n        // Emit an event to help clients figure out the proof ordering.\n        emit ContractStorageCommitted(\n            _ovmContractAddress,\n            _key\n        );\n  ","contract":"OVM_StateTransitioner","time":0},{"type":"immutable-restrict-modification ","before":"   bytes32 internal preStateRo","after":"   bytes32 internal preStateRo","contract":"OVM_StateTransitioner","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 internal stateTransitionInd","after":"   uint256 internal stateTransitionInd","contract":"OVM_StateTransitioner","time":1},{"type":"immutable-restrict-modification ","before":"   bytes32 internal transactionHa","after":"   bytes32 internal transactionHa","contract":"OVM_StateTransitioner","time":1},{"type":"external-function ","before":"   function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n    public\n    pure\n    returns (bytes memory)\n    {\n        return abi.encodePacked(\n            _preBytes,\n            _postBytes\n        );\n  ","after":"   function concat(\n        bytes calldata _preBytes,\n        bytes calldata _postBytes\n    )\n    public\n    pure\n    returns (bytes memory)\n    {\n        return abi.encodePacked(\n            _preBytes,\n            _postBytes\n        );\n  ","contract":"TestLib_BytesUtils","time":0},{"type":"external-function ","before":"   function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    public\n    pure\n    returns (bytes memory)\n    {\n        return Lib_BytesUtils.slice(\n            _bytes,\n            _start,\n            _length\n        );\n  ","after":"   function slice(\n        bytes calldata _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    public\n    pure\n    returns (bytes memory)\n    {\n        return Lib_BytesUtils.slice(\n            _bytes,\n            _start,\n            _length\n        );\n  ","contract":"TestLib_BytesUtils","time":0},{"type":"external-function ","before":"   function toBytes32(\n        bytes memory _bytes\n    )\n    public\n    pure\n    returns (bytes32)\n    {\n        return Lib_BytesUtils.toBytes32(\n            _bytes\n        );\n  ","after":"   function toBytes32(\n        bytes calldata _bytes\n    )\n    public\n    pure\n    returns (bytes32)\n    {\n        return Lib_BytesUtils.toBytes32(\n            _bytes\n        );\n  ","contract":"TestLib_BytesUtils","time":0},{"type":"external-function ","before":"   function toUint256(\n        bytes memory _bytes\n    )\n    public\n    pure\n    returns (uint256)\n    {\n        return Lib_BytesUtils.toUint256(\n            _bytes\n        );\n  ","after":"   function toUint256(\n        bytes calldata _bytes\n    )\n    public\n    pure\n    returns (uint256)\n    {\n        return Lib_BytesUtils.toUint256(\n            _bytes\n        );\n  ","contract":"TestLib_BytesUtils","time":0},{"type":"external-function ","before":"   function toNibbles(\n        bytes memory _bytes\n    )\n    public\n    pure\n    returns (bytes memory)\n    {\n        return Lib_BytesUtils.toNibbles(\n            _bytes\n        );\n  ","after":"   function toNibbles(\n        bytes calldata _bytes\n    )\n    public\n    pure\n    returns (bytes memory)\n    {\n        return Lib_BytesUtils.toNibbles(\n            _bytes\n        );\n  ","contract":"TestLib_BytesUtils","time":0},{"type":"external-function ","before":"   function fromNibbles(\n        bytes memory _bytes\n    )\n    public\n    pure\n    returns (bytes memory)\n    {\n        return Lib_BytesUtils.fromNibbles(\n            _bytes\n        );\n  ","after":"   function fromNibbles(\n        bytes calldata _bytes\n    )\n    public\n    pure\n    returns (bytes memory)\n    {\n        return Lib_BytesUtils.fromNibbles(\n            _bytes\n        );\n  ","contract":"TestLib_BytesUtils","time":0},{"type":"external-function ","before":"   function equal(\n        bytes memory _bytes,\n        bytes memory _other\n    )\n    public\n    pure\n    returns (bool)\n    {\n        return Lib_BytesUtils.equal(\n            _bytes,\n            _other\n        );\n  ","after":"   function equal(\n        bytes calldata _bytes,\n        bytes calldata _other\n    )\n    public\n    pure\n    returns (bool)\n    {\n        return Lib_BytesUtils.equal(\n            _bytes,\n            _other\n        );\n  ","contract":"TestLib_BytesUtils","time":0},{"type":"external-function ","before":"   function sliceWithTaintedMemory(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    public\n    returns (bytes memory)\n    {\n        new TestERC20();\n        return Lib_BytesUtils.slice(\n            _bytes,\n            _start,\n            _length\n        );\n  ","after":"   function sliceWithTaintedMemory(\n        bytes calldata _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n    public\n    returns (bytes memory)\n    {\n        new TestERC20();\n        return Lib_BytesUtils.slice(\n            _bytes,\n            _start,\n            _length\n        );\n  ","contract":"TestLib_BytesUtils","time":0},{"type":"external-function ","before":"   function decode(\n        bytes memory _encoded,\n        uint256 _chainId\n    )\n    public\n    pure\n    returns (\n        Lib_EIP155Tx.EIP155Tx memory\n    )\n    {\n        return Lib_EIP155Tx.decode(\n            _encoded,\n            _chainId\n        );\n  ","after":"   function decode(\n        bytes calldata _encoded,\n        uint256 _chainId\n    )\n    public\n    pure\n    returns (\n        Lib_EIP155Tx.EIP155Tx memory\n    )\n    {\n        return Lib_EIP155Tx.decode(\n            _encoded,\n            _chainId\n        );\n  ","contract":"TestLib_EIP155Tx","time":0},{"type":"external-function ","before":"   function encode(\n        Lib_EIP155Tx.EIP155Tx memory _transaction,\n        bool _includeSignature\n    )\n    public\n    pure\n    returns (\n        bytes memory\n    )\n    {\n        return Lib_EIP155Tx.encode(\n            _transaction,\n            _includeSignature\n        );\n  ","after":"   function encode(\n        Lib_EIP155Tx.EIP155Tx calldata _transaction,\n        bool _includeSignature\n    )\n    public\n    pure\n    returns (\n        bytes memory\n    )\n    {\n        return Lib_EIP155Tx.encode(\n            _transaction,\n            _includeSignature\n        );\n  ","contract":"TestLib_EIP155Tx","time":0},{"type":"external-function ","before":"   function hash(\n        Lib_EIP155Tx.EIP155Tx memory _transaction\n    )\n    public\n    pure\n    returns (\n        bytes32\n    )\n    {\n        return Lib_EIP155Tx.hash(\n            _transaction\n        );\n  ","after":"   function hash(\n        Lib_EIP155Tx.EIP155Tx calldata _transaction\n    )\n    public\n    pure\n    returns (\n        bytes32\n    )\n    {\n        return Lib_EIP155Tx.hash(\n            _transaction\n        );\n  ","contract":"TestLib_EIP155Tx","time":0},{"type":"external-function ","before":"   function sender(\n        Lib_EIP155Tx.EIP155Tx memory _transaction\n    )\n    public\n    pure\n    returns (\n        address\n    )\n    {\n        return Lib_EIP155Tx.sender(\n            _transaction\n        );\n  ","after":"   function sender(\n        Lib_EIP155Tx.EIP155Tx calldata _transaction\n    )\n    public\n    pure\n    returns (\n        address\n    )\n    {\n        return Lib_EIP155Tx.sender(\n            _transaction\n        );\n  ","contract":"TestLib_EIP155Tx","time":0},{"type":"external-function ","before":"   function createContract(\n        bytes memory _code\n    )\n    public\n    returns (\n        address _created\n    )\n    {\n        return Lib_EthUtils.createContract(\n            _code\n        );\n  ","after":"   function createContract(\n        bytes calldata _code\n    )\n    public\n    returns (\n        address _created\n    )\n    {\n        return Lib_EthUtils.createContract(\n            _code\n        );\n  ","contract":"TestLib_EthUtils","time":0},{"type":"external-function ","before":"   function getAddressForCREATE2(\n        address _creator,\n        bytes memory _bytecode,\n        bytes32 _salt\n    )\n    public\n    pure\n    returns (address _address)\n    {\n        return Lib_EthUtils.getAddressForCREATE2(\n            _creator,\n            _bytecode,\n            _salt\n        );\n  ","after":"   function getAddressForCREATE2(\n        address _creator,\n        bytes calldata _bytecode,\n        bytes32 _salt\n    )\n    public\n    pure\n    returns (address _address)\n    {\n        return Lib_EthUtils.getAddressForCREATE2(\n            _creator,\n            _bytecode,\n            _salt\n        );\n  ","contract":"TestLib_EthUtils","time":0},{"type":"external-function ","before":"   function getMerkleRoot(\n        bytes32[] memory _elements\n    )\n    public\n    pure\n    returns (\n        bytes32\n    )\n    {\n        return Lib_MerkleTree.getMerkleRoot(\n            _elements\n        );\n  ","after":"   function getMerkleRoot(\n        bytes32[] calldata _elements\n    )\n    public\n    pure\n    returns (\n        bytes32\n    )\n    {\n        return Lib_MerkleTree.getMerkleRoot(\n            _elements\n        );\n  ","contract":"TestLib_MerkleTree","time":0},{"type":"external-function ","before":"   function verify(\n        bytes32 _root,\n        bytes32 _leaf,\n        uint256 _index,\n        bytes32[] memory _siblings,\n        uint256 _totalLeaves\n    )\n    public\n    pure\n    returns (\n        bool\n    )\n    {\n        return Lib_MerkleTree.verify(\n            _root,\n            _leaf,\n            _index,\n            _siblings,\n            _totalLeaves\n        );\n  ","after":"   function verify(\n        bytes32 _root,\n        bytes32 _leaf,\n        uint256 _index,\n        bytes32[] calldata _siblings,\n        uint256 _totalLeaves\n    )\n    public\n    pure\n    returns (\n        bool\n    )\n    {\n        return Lib_MerkleTree.verify(\n            _root,\n            _leaf,\n            _index,\n            _siblings,\n            _totalLeaves\n        );\n  ","contract":"TestLib_MerkleTree","time":0},{"type":"external-function ","before":"   function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    )\n    public\n    pure\n    returns (\n        bool\n    )\n    {\n        return Lib_MerkleTrie.verifyInclusionProof(\n            _key,\n            _value,\n            _proof,\n            _root\n        );\n  ","after":"   function verifyInclusionProof(\n        bytes calldata _key,\n        bytes calldata _value,\n        bytes calldata _proof,\n        bytes32 _root\n    )\n    public\n    pure\n    returns (\n        bool\n    )\n    {\n        return Lib_MerkleTrie.verifyInclusionProof(\n            _key,\n            _value,\n            _proof,\n            _root\n        );\n  ","contract":"TestLib_MerkleTrie","time":0},{"type":"external-function ","before":"   function update(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    )\n    public\n    pure\n    returns (\n        bytes32\n    )\n    {\n        return Lib_MerkleTrie.update(\n            _key,\n            _value,\n            _proof,\n            _root\n        );\n  ","after":"   function update(\n        bytes calldata _key,\n        bytes calldata _value,\n        bytes calldata _proof,\n        bytes32 _root\n    )\n    public\n    pure\n    returns (\n        bytes32\n    )\n    {\n        return Lib_MerkleTrie.update(\n            _key,\n            _value,\n            _proof,\n            _root\n        );\n  ","contract":"TestLib_MerkleTrie","time":0},{"type":"external-function ","before":"   function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    )\n    public\n    pure\n    returns (\n        bool,\n        bytes memory\n    )\n    {\n        return Lib_MerkleTrie.get(\n            _key,\n            _proof,\n            _root\n        );\n  ","after":"   function get(\n        bytes calldata _key,\n        bytes calldata _proof,\n        bytes32 _root\n    )\n    public\n    pure\n    returns (\n        bool,\n        bytes memory\n    )\n    {\n        return Lib_MerkleTrie.get(\n            _key,\n            _proof,\n            _root\n        );\n  ","contract":"TestLib_MerkleTrie","time":0},{"type":"external-function ","before":"   function getSingleNodeRootHash(\n        bytes memory _key,\n        bytes memory _value\n    )\n    public\n    pure\n    returns (\n        bytes32\n    )\n    {\n        return Lib_MerkleTrie.getSingleNodeRootHash(\n            _key,\n            _value\n        );\n  ","after":"   function getSingleNodeRootHash(\n        bytes calldata _key,\n        bytes calldata _value\n    )\n    public\n    pure\n    returns (\n        bytes32\n    )\n    {\n        return Lib_MerkleTrie.getSingleNodeRootHash(\n            _key,\n            _value\n        );\n  ","contract":"TestLib_MerkleTrie","time":0},{"type":"external-function ","before":"   function encodeTransaction(\n        Lib_OVMCodec.Transaction memory _transaction\n    )\n    public\n    pure\n    returns (\n        bytes memory _encoded\n    )\n    {\n        return Lib_OVMCodec.encodeTransaction(_transaction);\n  ","after":"   function encodeTransaction(\n        Lib_OVMCodec.Transaction calldata _transaction\n    )\n    public\n    pure\n    returns (\n        bytes memory _encoded\n    )\n    {\n        return Lib_OVMCodec.encodeTransaction(_transaction);\n  ","contract":"TestLib_OVMCodec","time":0},{"type":"external-function ","before":"   function hashTransaction(\n        Lib_OVMCodec.Transaction memory _transaction\n    )\n    public\n    pure\n    returns (\n        bytes32 _hash\n    )\n    {\n        return Lib_OVMCodec.hashTransaction(_transaction);\n  ","after":"   function hashTransaction(\n        Lib_OVMCodec.Transaction calldata _transaction\n    )\n    public\n    pure\n    returns (\n        bytes32 _hash\n    )\n    {\n        return Lib_OVMCodec.hashTransaction(_transaction);\n  ","contract":"TestLib_OVMCodec","time":0},{"type":"external-function ","before":"   function readList(\n        bytes memory _in\n    )\n    public\n    pure\n    returns (\n        bytes[] memory\n    )\n    {\n        Lib_RLPReader.RLPItem[] memory decoded = Lib_RLPReader.readList(_in);\n        bytes[] memory out = new bytes[](decoded.length);\n        for (uint256 i = 0; i < out.length; i++) {\n            out[i] = Lib_RLPReader.readRawBytes(decoded[i]);\n        }\n        return out;\n  ","after":"   function readList(\n        bytes calldata _in\n    )\n    public\n    pure\n    returns (\n        bytes[] memory\n    )\n    {\n        Lib_RLPReader.RLPItem[] memory decoded = Lib_RLPReader.readList(_in);\n        bytes[] memory out = new bytes[](decoded.length);\n        for (uint256 i = 0; i < out.length; i++) {\n            out[i] = Lib_RLPReader.readRawBytes(decoded[i]);\n        }\n        return out;\n  ","contract":"TestLib_RLPReader","time":0},{"type":"external-function ","before":"   function readString(\n        bytes memory _in\n    )\n    public\n    pure\n    returns (\n        string memory\n    )\n    {\n        return Lib_RLPReader.readString(_in);\n  ","after":"   function readString(\n        bytes calldata _in\n    )\n    public\n    pure\n    returns (\n        string memory\n    )\n    {\n        return Lib_RLPReader.readString(_in);\n  ","contract":"TestLib_RLPReader","time":0},{"type":"external-function ","before":"   function readBytes(\n        bytes memory _in\n    )\n    public\n    pure\n    returns (\n        bytes memory\n    )\n    {\n        return Lib_RLPReader.readBytes(_in);\n  ","after":"   function readBytes(\n        bytes calldata _in\n    )\n    public\n    pure\n    returns (\n        bytes memory\n    )\n    {\n        return Lib_RLPReader.readBytes(_in);\n  ","contract":"TestLib_RLPReader","time":0},{"type":"external-function ","before":"   function readBytes32(\n        bytes memory _in\n    )\n    public\n    pure\n    returns (\n        bytes32\n    )\n    {\n        return Lib_RLPReader.readBytes32(_in);\n  ","after":"   function readBytes32(\n        bytes calldata _in\n    )\n    public\n    pure\n    returns (\n        bytes32\n    )\n    {\n        return Lib_RLPReader.readBytes32(_in);\n  ","contract":"TestLib_RLPReader","time":0},{"type":"external-function ","before":"   function readUint256(\n        bytes memory _in\n    )\n    public\n    pure\n    returns (\n        uint256\n    )\n    {\n        return Lib_RLPReader.readUint256(_in);\n  ","after":"   function readUint256(\n        bytes calldata _in\n    )\n    public\n    pure\n    returns (\n        uint256\n    )\n    {\n        return Lib_RLPReader.readUint256(_in);\n  ","contract":"TestLib_RLPReader","time":0},{"type":"external-function ","before":"   function readBool(\n        bytes memory _in\n    )\n    public\n    pure\n    returns (\n        bool\n    )\n    {\n        return Lib_RLPReader.readBool(_in);\n  ","after":"   function readBool(\n        bytes calldata _in\n    )\n    public\n    pure\n    returns (\n        bool\n    )\n    {\n        return Lib_RLPReader.readBool(_in);\n  ","contract":"TestLib_RLPReader","time":0},{"type":"external-function ","before":"   function readAddress(\n        bytes memory _in\n    )\n    public\n    pure\n    returns (\n        address\n    )\n    {\n        return Lib_RLPReader.readAddress(_in);\n  ","after":"   function readAddress(\n        bytes calldata _in\n    )\n    public\n    pure\n    returns (\n        address\n    )\n    {\n        return Lib_RLPReader.readAddress(_in);\n  ","contract":"TestLib_RLPReader","time":0},{"type":"external-function ","before":"   function writeBytes(\n        bytes memory _in\n    )\n    public\n    pure\n    returns (\n        bytes memory _out\n    )\n    {\n        return Lib_RLPWriter.writeBytes(_in);\n  ","after":"   function writeBytes(\n        bytes calldata _in\n    )\n    public\n    pure\n    returns (\n        bytes memory _out\n    )\n    {\n        return Lib_RLPWriter.writeBytes(_in);\n  ","contract":"TestLib_RLPWriter","time":0},{"type":"external-function ","before":"   function writeList(\n        bytes[] memory _in\n    )\n    public\n    pure\n    returns (\n        bytes memory _out\n    )\n    {\n        return Lib_RLPWriter.writeList(_in);\n  ","after":"   function writeList(\n        bytes[] calldata _in\n    )\n    public\n    pure\n    returns (\n        bytes memory _out\n    )\n    {\n        return Lib_RLPWriter.writeList(_in);\n  ","contract":"TestLib_RLPWriter","time":0},{"type":"external-function ","before":"   function writeString(\n        string memory _in\n    )\n    public\n    pure\n    returns (\n        bytes memory _out\n    )\n    {\n        return Lib_RLPWriter.writeString(_in);\n  ","after":"   function writeString(\n        string calldata _in\n    )\n    public\n    pure\n    returns (\n        bytes memory _out\n    )\n    {\n        return Lib_RLPWriter.writeString(_in);\n  ","contract":"TestLib_RLPWriter","time":0},{"type":"external-function ","before":"   function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    )\n    public\n    pure\n    returns (\n        bool\n    )\n    {\n        return Lib_SecureMerkleTrie.verifyInclusionProof(\n            _key,\n            _value,\n            _proof,\n            _root\n        );\n  ","after":"   function verifyInclusionProof(\n        bytes calldata _key,\n        bytes calldata _value,\n        bytes calldata _proof,\n        bytes32 _root\n    )\n    public\n    pure\n    returns (\n        bool\n    )\n    {\n        return Lib_SecureMerkleTrie.verifyInclusionProof(\n            _key,\n            _value,\n            _proof,\n            _root\n        );\n  ","contract":"TestLib_SecureMerkleTrie","time":0},{"type":"external-function ","before":"   function update(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    )\n    public\n    pure\n    returns (\n        bytes32\n    )\n    {\n        return Lib_SecureMerkleTrie.update(\n            _key,\n            _value,\n            _proof,\n            _root\n        );\n  ","after":"   function update(\n        bytes calldata _key,\n        bytes calldata _value,\n        bytes calldata _proof,\n        bytes32 _root\n    )\n    public\n    pure\n    returns (\n        bytes32\n    )\n    {\n        return Lib_SecureMerkleTrie.update(\n            _key,\n            _value,\n            _proof,\n            _root\n        );\n  ","contract":"TestLib_SecureMerkleTrie","time":0},{"type":"external-function ","before":"   function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    )\n    public\n    pure\n    returns (\n        bool,\n        bytes memory\n    )\n    {\n        return Lib_SecureMerkleTrie.get(\n            _key,\n            _proof,\n            _root\n        );\n  ","after":"   function get(\n        bytes calldata _key,\n        bytes calldata _proof,\n        bytes32 _root\n    )\n    public\n    pure\n    returns (\n        bool,\n        bytes memory\n    )\n    {\n        return Lib_SecureMerkleTrie.get(\n            _key,\n            _proof,\n            _root\n        );\n  ","contract":"TestLib_SecureMerkleTrie","time":0},{"type":"external-function ","before":"   function getSingleNodeRootHash(\n        bytes memory _key,\n        bytes memory _value\n    )\n    public\n    pure\n    returns (\n        bytes32\n    )\n    {\n        return Lib_SecureMerkleTrie.getSingleNodeRootHash(\n            _key,\n            _value\n        );\n  ","after":"   function getSingleNodeRootHash(\n        bytes calldata _key,\n        bytes calldata _value\n    )\n    public\n    pure\n    returns (\n        bytes32\n    )\n    {\n        return Lib_SecureMerkleTrie.getSingleNodeRootHash(\n            _key,\n            _value\n        );\n  ","contract":"TestLib_SecureMerkleTrie","time":0},{"type":"struct-data-arrangement ","before":"\n   address ovmCAL\n   address ovmADDR\n   uint256 ovmCALLVA\n   bool isSta","after":"   uint256 ovmCALLVA\n   address ovmCAL\n   address ovmADDR\n   bool isSta\n","contract":"iOVM_ExecutionManager","time":0}]}