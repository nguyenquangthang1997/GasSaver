{"time":2329,"results":[{"type":"loop-duplication","before":"\nstart line 128 column 8, end line 132 column 8\nfor (uint256 i = 0; i < whitelistIndices.length; i++) {\n            if (whitelist[whitelistIndices[i]] == Status.In) {\n                activeCount++;\n            }\n        }\nstart line 137 column 8, end line 143 column 8\nfor (uint256 i = 0; i < whitelistIndices.length; i++) {\n            address addr = whitelistIndices[i];\n            if (whitelist[addr] == Status.In) {\n                activeWhitelist[activeCount] = addr;\n                activeCount++;\n            }\n        }","after":"// merge loop\n\nstart line 128 column 8, end line 132 column 8\nfor (uint256 i = 0; i < whitelistIndices.length; i++) {\n            if (whitelist[whitelistIndices[i]] == Status.In) {\n                activeCount++;\n            }\n        }\nstart line 137 column 8, end line 143 column 8\nfor (uint256 i = 0; i < whitelistIndices.length; i++) {\n            address addr = whitelistIndices[i];\n            if (whitelist[addr] == Status.In) {\n                activeWhitelist[activeCount] = addr;\n                activeCount++;\n            }\n        }","contract":"AddressWhitelist","time":0},{"type":"immutable-restrict-modification ","before":"uint256 private _totalSupply;","after":"uint256 private immutable _totalSupply;","contract":"BasicERC20","time":1},{"type":"external-function ","before":"function proposeNewConfig(ConfigSettings memory newConfig) external onlyOwner() nonReentrant() updateConfig() {\n        _validateConfig(newConfig);\n\n        // Warning: This overwrites a pending proposal!\n        pendingConfig = newConfig;\n\n        // Use current config's liveness period to timelock this proposal.\n        pendingPassedTimestamp = getCurrentTime().add(currentConfig.timelockLiveness);\n\n        emit ProposedNewConfigSettings(\n            msg.sender,\n            newConfig.rewardRatePerSecond.rawValue,\n            newConfig.proposerBondPercentage.rawValue,\n            newConfig.timelockLiveness,\n            newConfig.maxFundingRate.rawValue,\n            newConfig.minFundingRate.rawValue,\n            newConfig.proposalTimePastLimit,\n            pendingPassedTimestamp\n        );\n    }","after":"function proposeNewConfig(ConfigSettings calldata newConfig) external onlyOwner() nonReentrant() updateConfig() {\n        _validateConfig(newConfig);\n\n        // Warning: This overwrites a pending proposal!\n        pendingConfig = newConfig;\n\n        // Use current config's liveness period to timelock this proposal.\n        pendingPassedTimestamp = getCurrentTime().add(currentConfig.timelockLiveness);\n\n        emit ProposedNewConfigSettings(\n            msg.sender,\n            newConfig.rewardRatePerSecond.rawValue,\n            newConfig.proposerBondPercentage.rawValue,\n            newConfig.timelockLiveness,\n            newConfig.maxFundingRate.rawValue,\n            newConfig.minFundingRate.rawValue,\n            newConfig.proposalTimePastLimit,\n            pendingPassedTimestamp\n        );\n    }","contract":"ConfigStore","time":0},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"ConfigStore","time":1},{"type":"external-function ","before":"function deposit(FixedPoint.Unsigned memory collateralAmount) public isInitialized() fees() nonReentrant() {\n        require(collateralAmount.isGreaterThan(0), \"Invalid collateral amount\");\n        DepositBoxData storage depositBoxData = depositBoxes[msg.sender];\n        if (_getFeeAdjustedCollateral(depositBoxData.rawCollateral).isEqual(0)) {\n            emit NewDepositBox(msg.sender);\n        }\n\n        // Increase the individual deposit box and global collateral balance by collateral amount.\n        _incrementCollateralBalances(depositBoxData, collateralAmount);\n\n        emit Deposit(msg.sender, collateralAmount.rawValue);\n\n        // Move collateral currency from sender to contract.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n    }","after":"function deposit(FixedPoint.Unsigned calldata collateralAmount) public isInitialized() fees() nonReentrant() {\n        require(collateralAmount.isGreaterThan(0), \"Invalid collateral amount\");\n        DepositBoxData storage depositBoxData = depositBoxes[msg.sender];\n        if (_getFeeAdjustedCollateral(depositBoxData.rawCollateral).isEqual(0)) {\n            emit NewDepositBox(msg.sender);\n        }\n\n        // Increase the individual deposit box and global collateral balance by collateral amount.\n        _incrementCollateralBalances(depositBoxData, collateralAmount);\n\n        emit Deposit(msg.sender, collateralAmount.rawValue);\n\n        // Move collateral currency from sender to contract.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n    }","contract":"DepositBox","time":0},{"type":"external-function ","before":"function requestWithdrawal(FixedPoint.Unsigned memory denominatedCollateralAmount)\n    public\n    isInitialized()\n    noPendingWithdrawal(msg.sender)\n    nonReentrant()\n    {\n        DepositBoxData storage depositBoxData = depositBoxes[msg.sender];\n        require(denominatedCollateralAmount.isGreaterThan(0), \"Invalid collateral amount\");\n\n        // Update the position object for the user.\n        depositBoxData.withdrawalRequestAmount = denominatedCollateralAmount;\n        depositBoxData.requestPassTimestamp = getCurrentTime();\n\n        emit RequestWithdrawal(msg.sender, denominatedCollateralAmount.rawValue, depositBoxData.requestPassTimestamp);\n\n        // Every price request costs a fixed fee. Check that this user has enough deposited to cover the final fee.\n        FixedPoint.Unsigned memory finalFee = _computeFinalFees();\n        require(\n            _getFeeAdjustedCollateral(depositBoxData.rawCollateral).isGreaterThanOrEqual(finalFee),\n            \"Cannot pay final fee\"\n        );\n        _payFinalFees(address(this), finalFee);\n        // A price request is sent for the current timestamp.\n        _requestOraclePrice(depositBoxData.requestPassTimestamp);\n    }","after":"function requestWithdrawal(FixedPoint.Unsigned calldata denominatedCollateralAmount)\n    public\n    isInitialized()\n    noPendingWithdrawal(msg.sender)\n    nonReentrant()\n    {\n        DepositBoxData storage depositBoxData = depositBoxes[msg.sender];\n        require(denominatedCollateralAmount.isGreaterThan(0), \"Invalid collateral amount\");\n\n        // Update the position object for the user.\n        depositBoxData.withdrawalRequestAmount = denominatedCollateralAmount;\n        depositBoxData.requestPassTimestamp = getCurrentTime();\n\n        emit RequestWithdrawal(msg.sender, denominatedCollateralAmount.rawValue, depositBoxData.requestPassTimestamp);\n\n        // Every price request costs a fixed fee. Check that this user has enough deposited to cover the final fee.\n        FixedPoint.Unsigned memory finalFee = _computeFinalFees();\n        require(\n            _getFeeAdjustedCollateral(depositBoxData.rawCollateral).isGreaterThanOrEqual(finalFee),\n            \"Cannot pay final fee\"\n        );\n        _payFinalFees(address(this), finalFee);\n        // A price request is sent for the current timestamp.\n        _requestOraclePrice(depositBoxData.requestPassTimestamp);\n    }","contract":"DepositBox","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 private priceIdentifier;","after":"bytes32 private immutable priceIdentifier;","contract":"DepositBox","time":2},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"DepositBox","time":2},{"type":"immutable-restrict-modification ","before":"address internal finderAddress;","after":"address internal immutable finderAddress;","contract":"DepositBox","time":2},{"type":"external-function ","before":"function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        bytes32 hash\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingAddress().commitVote(identifier, time, ancillaryData, hash);\n    }","after":"function commitVote(\n        bytes32 identifier,\n        uint256 time,\n        bytes calldata ancillaryData,\n        bytes32 hash\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingAddress().commitVote(identifier, time, ancillaryData, hash);\n    }","contract":"DesignatedVoting","time":0},{"type":"external-function ","before":"function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        bytes memory ancillaryData,\n        int256 salt\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingAddress().revealVote(identifier, time, price, ancillaryData, salt);\n    }","after":"function revealVote(\n        bytes32 identifier,\n        uint256 time,\n        int256 price,\n        bytes calldata ancillaryData,\n        int256 salt\n    ) external onlyRoleHolder(uint256(Roles.Voter)) {\n        _getVotingAddress().revealVote(identifier, time, price, ancillaryData, salt);\n    }","contract":"DesignatedVoting","time":0},{"type":"external-function ","before":"function retrieveRewards(uint256 roundId, VotingAncillaryInterface.PendingRequestAncillary[] memory toRetrieve)\n    public\n    onlyRoleHolder(uint256(Roles.Voter))\n    returns (FixedPoint.Unsigned memory)\n    {\n        return _getVotingAddress().retrieveRewards(address(this), roundId, toRetrieve);\n    }","after":"function retrieveRewards(uint256 roundId, VotingAncillaryInterface.PendingRequestAncillary[] calldata toRetrieve)\n    public\n    onlyRoleHolder(uint256(Roles.Voter))\n    returns (FixedPoint.Unsigned memory)\n    {\n        return _getVotingAddress().retrieveRewards(address(this), roundId, toRetrieve);\n    }","contract":"DesignatedVoting","time":0},{"type":"immutable-restrict-modification ","before":"address private finder;","after":"address private immutable finder;","contract":"DesignatedVotingFactory","time":1},{"type":"external-function ","before":"   function transformCollateralRequirement(FixedPoint.Unsigned memory price)\n    public\n    view\n    nonReentrantView()\n    returns (FixedPoint.Unsigned memory)\n    {\n        return _transformCollateralRequirement(price);\n  ","after":"   function transformCollateralRequirement(FixedPoint.Unsigned calldata price)\n    public\n    view\n    nonReentrantView()\n    returns (FixedPoint.Unsigned memory)\n    {\n        return _transformCollateralRequirement(price);\n  ","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"   function deposit(FixedPoint.Unsigned memory collateralAmount) public {\n        // This is just a thin wrapper over depositTo that specified the sender as the sponsor.\n        depositTo(msg.sender, collateralAmount);\n  ","after":"   function deposit(FixedPoint.Unsigned calldata collateralAmount) public {\n        // This is just a thin wrapper over depositTo that specified the sender as the sponsor.\n        depositTo(msg.sender, collateralAmount);\n  ","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"   function withdraw(FixedPoint.Unsigned memory collateralAmount)\n    public\n    onlyPreExpiration()\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        require(collateralAmount.isGreaterThan(0));\n        PositionData storage positionData = _getPositionData(msg.sender);\n\n        // Decrement the sponsor's collateral and global collateral amounts. Check the GCR between decrement to ensure\n        // position remains above the GCR within the withdrawal. If this is not the case the caller must submit a request.\n        amountWithdrawn = _decrementCollateralBalancesCheckGCR(positionData, collateralAmount);\n\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n\n        // Move collateral currency from contract to sender.\n        // Note: that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n        // instead of the user requested amount. This eliminates precision loss that could occur\n        // where the user withdraws more collateral than rawCollateral is decremented by.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n  ","after":"   function withdraw(FixedPoint.Unsigned calldata collateralAmount)\n    public\n    onlyPreExpiration()\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        require(collateralAmount.isGreaterThan(0));\n        PositionData storage positionData = _getPositionData(msg.sender);\n\n        // Decrement the sponsor's collateral and global collateral amounts. Check the GCR between decrement to ensure\n        // position remains above the GCR within the withdrawal. If this is not the case the caller must submit a request.\n        amountWithdrawn = _decrementCollateralBalancesCheckGCR(positionData, collateralAmount);\n\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n\n        // Move collateral currency from contract to sender.\n        // Note: that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n        // instead of the user requested amount. This eliminates precision loss that could occur\n        // where the user withdraws more collateral than rawCollateral is decremented by.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n  ","contract":"ExpiringMultiParty","time":1},{"type":"external-function ","before":"   function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\n    public\n    onlyPreExpiration()\n    noPendingWithdrawal(msg.sender)\n    nonReentrant()\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(\n            collateralAmount.isGreaterThan(0) &&\n            collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral))\n        );\n\n        // Make sure the proposed expiration of this request is not post-expiry.\n        uint256 requestPassTime = getCurrentTime().add(withdrawalLiveness);\n        require(requestPassTime < expirationTimestamp);\n\n        // Update the position object for the user.\n        positionData.withdrawalRequestPassTimestamp = requestPassTime;\n        positionData.withdrawalRequestAmount = collateralAmount;\n\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n  ","after":"   function requestWithdrawal(FixedPoint.Unsigned calldata collateralAmount)\n    public\n    onlyPreExpiration()\n    noPendingWithdrawal(msg.sender)\n    nonReentrant()\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(\n            collateralAmount.isGreaterThan(0) &&\n            collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral))\n        );\n\n        // Make sure the proposed expiration of this request is not post-expiry.\n        uint256 requestPassTime = getCurrentTime().add(withdrawalLiveness);\n        require(requestPassTime < expirationTimestamp);\n\n        // Update the position object for the user.\n        positionData.withdrawalRequestPassTimestamp = requestPassTime;\n        positionData.withdrawalRequestAmount = collateralAmount;\n\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n  ","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"   function create(FixedPoint.Unsigned memory collateralAmount, FixedPoint.Unsigned memory numTokens)\n    public\n    onlyPreExpiration()\n    fees()\n    nonReentrant()\n    {\n        PositionData storage positionData = positions[msg.sender];\n\n        // Either the new create ratio or the resultant position CR must be above the current GCR.\n        require(\n            (_checkCollateralization(\n            _getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),\n            positionData.tokensOutstanding.add(numTokens)\n        ) || _checkCollateralization(collateralAmount, numTokens)),\n            \"Insufficient collateral\"\n        );\n\n        require(positionData.withdrawalRequestPassTimestamp == 0, \"Pending withdrawal\");\n        if (positionData.tokensOutstanding.isEqual(0)) {\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\n            emit NewSponsor(msg.sender);\n        }\n\n        // Increase the position and global collateral balance by collateral amount.\n        _incrementCollateralBalances(positionData, collateralAmount);\n\n        // Add the number of tokens created to the position's outstanding tokens.\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n\n        // Transfer tokens into the contract from caller and mint corresponding synthetic tokens to the caller's address.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue));\n  ","after":"   function create(FixedPoint.Unsigned calldata collateralAmount, FixedPoint.Unsigned calldata numTokens)\n    public\n    onlyPreExpiration()\n    fees()\n    nonReentrant()\n    {\n        PositionData storage positionData = positions[msg.sender];\n\n        // Either the new create ratio or the resultant position CR must be above the current GCR.\n        require(\n            (_checkCollateralization(\n            _getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),\n            positionData.tokensOutstanding.add(numTokens)\n        ) || _checkCollateralization(collateralAmount, numTokens)),\n            \"Insufficient collateral\"\n        );\n\n        require(positionData.withdrawalRequestPassTimestamp == 0, \"Pending withdrawal\");\n        if (positionData.tokensOutstanding.isEqual(0)) {\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\n            emit NewSponsor(msg.sender);\n        }\n\n        // Increase the position and global collateral balance by collateral amount.\n        _incrementCollateralBalances(positionData, collateralAmount);\n\n        // Add the number of tokens created to the position's outstanding tokens.\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n\n        // Transfer tokens into the contract from caller and mint corresponding synthetic tokens to the caller's address.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue));\n  ","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"   function repay(FixedPoint.Unsigned memory numTokens)\n    public\n    onlyPreExpiration()\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(numTokens.isLessThanOrEqual(positionData.tokensOutstanding));\n\n        // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n        FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n        require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n        positionData.tokensOutstanding = newTokenCount;\n\n        // Update the totalTokensOutstanding after redemption.\n        totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n\n        emit Repay(msg.sender, numTokens.rawValue, newTokenCount.rawValue);\n\n        // Transfer the tokens back from the sponsor and burn them.\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n  ","after":"   function repay(FixedPoint.Unsigned calldata numTokens)\n    public\n    onlyPreExpiration()\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(numTokens.isLessThanOrEqual(positionData.tokensOutstanding));\n\n        // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n        FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n        require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n        positionData.tokensOutstanding = newTokenCount;\n\n        // Update the totalTokensOutstanding after redemption.\n        totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n\n        emit Repay(msg.sender, numTokens.rawValue, newTokenCount.rawValue);\n\n        // Transfer the tokens back from the sponsor and burn them.\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n  ","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"   function redeem(FixedPoint.Unsigned memory numTokens)\n    public\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(!numTokens.isGreaterThan(positionData.tokensOutstanding));\n\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n        FixedPoint.Unsigned memory collateralRedeemed =\n        fractionRedeemed.mul(_getFeeAdjustedCollateral(positionData.rawCollateral));\n\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n        } else {\n            // Decrement the sponsor's collateral and global collateral amounts.\n            amountWithdrawn = _decrementCollateralBalances(positionData, collateralRedeemed);\n\n            // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\n            positionData.tokensOutstanding = newTokenCount;\n\n            // Update the totalTokensOutstanding after redemption.\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n        }\n\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n  ","after":"   function redeem(FixedPoint.Unsigned calldata numTokens)\n    public\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(!numTokens.isGreaterThan(positionData.tokensOutstanding));\n\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n        FixedPoint.Unsigned memory collateralRedeemed =\n        fractionRedeemed.mul(_getFeeAdjustedCollateral(positionData.rawCollateral));\n\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n        } else {\n            // Decrement the sponsor's collateral and global collateral amounts.\n            amountWithdrawn = _decrementCollateralBalances(positionData, collateralRedeemed);\n\n            // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens), \"Below minimum sponsor position\");\n            positionData.tokensOutstanding = newTokenCount;\n\n            // Update the totalTokensOutstanding after redemption.\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n        }\n\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n  ","contract":"ExpiringMultiParty","time":0},{"type":"external-function ","before":"   function transformPrice(FixedPoint.Unsigned memory price, uint256 requestTime)\n    public\n    view\n    nonReentrantView()\n    returns (FixedPoint.Unsigned memory)\n    {\n        return _transformPrice(price, requestTime);\n  ","after":"   function transformPrice(FixedPoint.Unsigned calldata price, uint256 requestTime)\n    public\n    view\n    nonReentrantView()\n    returns (FixedPoint.Unsigned memory)\n    {\n        return _transformPrice(price, requestTime);\n  ","contract":"ExpiringMultiParty","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public liquidationLivene","after":"   uint256 public liquidationLivene","contract":"ExpiringMultiParty","time":3},{"type":"immutable-restrict-modification ","before":"   bytes32 public priceIdentifi","after":"   bytes32 public priceIdentifi","contract":"ExpiringMultiParty","time":3},{"type":"immutable-restrict-modification ","before":"   uint256 public withdrawalLivene","after":"   uint256 public withdrawalLivene","contract":"ExpiringMultiParty","time":3},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"ExpiringMultiParty","time":3},{"type":"external-function ","before":"   function createExpiringMultiParty(Params memory params) public nonReentrant() returns (address) {\n        // Create a new synthetic token using the params.\n        require(bytes(params.syntheticName).length != 0, \"Missing synthetic name\");\n        require(bytes(params.syntheticSymbol).length != 0, \"Missing synthetic symbol\");\n        TokenFactory tf = TokenFactory(tokenFactoryAddress);\n\n        // If the collateral token does not have a `decimals()` method, then a default precision of 18 will be\n        // applied to the newly created synthetic token.\n        uint8 syntheticDecimals = _getSyntheticDecimals(params.collateralAddress);\n        ExpandedIERC20 tokenCurrency = tf.createToken(params.syntheticName, params.syntheticSymbol, syntheticDecimals);\n        address derivative = ExpiringMultiPartyLib.deploy(_convertParams(params, tokenCurrency));\n\n        // Give permissions to new derivative contract and then hand over ownership.\n        tokenCurrency.addMinter(derivative);\n        tokenCurrency.addBurner(derivative);\n        tokenCurrency.resetOwner(derivative);\n\n        _registerContract(new address[](0), derivative);\n\n        emit CreatedExpiringMultiParty(derivative, msg.sender);\n\n        return derivative;\n  ","after":"   function createExpiringMultiParty(Params calldata params) public nonReentrant() returns (address) {\n        // Create a new synthetic token using the params.\n        require(bytes(params.syntheticName).length != 0, \"Missing synthetic name\");\n        require(bytes(params.syntheticSymbol).length != 0, \"Missing synthetic symbol\");\n        TokenFactory tf = TokenFactory(tokenFactoryAddress);\n\n        // If the collateral token does not have a `decimals()` method, then a default precision of 18 will be\n        // applied to the newly created synthetic token.\n        uint8 syntheticDecimals = _getSyntheticDecimals(params.collateralAddress);\n        ExpandedIERC20 tokenCurrency = tf.createToken(params.syntheticName, params.syntheticSymbol, syntheticDecimals);\n        address derivative = ExpiringMultiPartyLib.deploy(_convertParams(params, tokenCurrency));\n\n        // Give permissions to new derivative contract and then hand over ownership.\n        tokenCurrency.addMinter(derivative);\n        tokenCurrency.addBurner(derivative);\n        tokenCurrency.resetOwner(derivative);\n\n        _registerContract(new address[](0), derivative);\n\n        emit CreatedExpiringMultiParty(derivative, msg.sender);\n\n        return derivative;\n  ","contract":"ExpiringMultiPartyCreator","time":0},{"type":"immutable-restrict-modification ","before":"   address public tokenFactoryAddre","after":"   address public tokenFactoryAddre","contract":"ExpiringMultiPartyCreator","time":2},{"type":"immutable-restrict-modification ","before":"address internal finderAddress;","after":"address internal immutable finderAddress;","contract":"ExpiringMultiPartyCreator","time":2},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"ExpiringMultiPartyCreator","time":2},{"type":"external-function ","before":"   function deploy(ExpiringMultiParty.ConstructorParams memory params) public returns (address) {\n        ExpiringMultiParty derivative = new ExpiringMultiParty(params);\n        return address(derivative);\n  ","after":"   function deploy(ExpiringMultiParty.ConstructorParams calldata params) public returns (address) {\n        ExpiringMultiParty derivative = new ExpiringMultiParty(params);\n        return address(derivative);\n  ","contract":"ExpiringMultiPartyLib","time":0},{"type":"external-function ","before":"   function transformPrice(FixedPoint.Unsigned memory price, uint256 requestTime)\n    public\n    view\n    returns (FixedPoint.Unsigned memory)\n    {\n        if (address(financialProductLibrary) == address(0)) return price;\n        try financialProductLibrary.transformPrice(price, requestTime) returns (\n            FixedPoint.Unsigned memory transformedPrice\n        ) {\n            return transformedPrice;\n        } catch {\n            return price;\n        }\n  ","after":"   function transformPrice(FixedPoint.Unsigned calldata price, uint256 requestTime)\n    public\n    view\n    returns (FixedPoint.Unsigned memory)\n    {\n        if (address(financialProductLibrary) == address(0)) return price;\n        try financialProductLibrary.transformPrice(price, requestTime) returns (\n            FixedPoint.Unsigned memory transformedPrice\n        ) {\n            return transformedPrice;\n        } catch {\n            return price;\n        }\n  ","contract":"ExpiringMultiPartyMock","time":0},{"type":"external-function ","before":"   function transformCollateralRequirement(FixedPoint.Unsigned memory price)\n    public\n    view\n    returns (FixedPoint.Unsigned memory)\n    {\n        if (address(financialProductLibrary) == address(0)) return collateralRequirement;\n        try financialProductLibrary.transformCollateralRequirement(price, collateralRequirement) returns (\n            FixedPoint.Unsigned memory transformedCollateralRequirement\n        ) {\n            return transformedCollateralRequirement;\n        } catch {\n            return collateralRequirement;\n        }\n  ","after":"   function transformCollateralRequirement(FixedPoint.Unsigned calldata price)\n    public\n    view\n    returns (FixedPoint.Unsigned memory)\n    {\n        if (address(financialProductLibrary) == address(0)) return collateralRequirement;\n        try financialProductLibrary.transformCollateralRequirement(price, collateralRequirement) returns (\n            FixedPoint.Unsigned memory transformedCollateralRequirement\n        ) {\n            return transformedCollateralRequirement;\n        } catch {\n            return collateralRequirement;\n        }\n  ","contract":"ExpiringMultiPartyMock","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public expirationTimesta","after":"   uint256 public expirationTimesta","contract":"ExpiringMultiPartyMock","time":1},{"type":"immutable-restrict-modification ","before":"   bytes32 public priceIdentifi","after":"   bytes32 public priceIdentifi","contract":"ExpiringMultiPartyMock","time":1},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"ExpiringMultiPartyMock","time":1},{"type":"external-function ","before":"   function transformPrice(FixedPoint.Unsigned memory oraclePrice, uint256 requestTime)\n    public\n    view\n    override\n    returns (FixedPoint.Unsigned memory)\n    {\n        require(!shouldRevert, \"set to always reverts\");\n        return oraclePrice.mul(priceTransformationScalar);\n  ","after":"   function transformPrice(FixedPoint.Unsigned calldata oraclePrice, uint256 requestTime)\n    public\n    view\n    override\n    returns (FixedPoint.Unsigned memory)\n    {\n        require(!shouldRevert, \"set to always reverts\");\n        return oraclePrice.mul(priceTransformationScalar);\n  ","contract":"FinancialProductLibraryTest","time":0},{"type":"external-function ","before":"   function transformCollateralRequirement(\n        FixedPoint.Unsigned memory price,\n        FixedPoint.Unsigned memory collateralRequirement\n    ) public view override returns (FixedPoint.Unsigned memory) {\n        require(!shouldRevert, \"set to always reverts\");\n        return collateralRequirement.mul(collateralRequirementTransformationScalar);\n  ","after":"   function transformCollateralRequirement(\n        FixedPoint.Unsigned calldata price,\n        FixedPoint.Unsigned calldata collateralRequirement\n    ) public view override returns (FixedPoint.Unsigned memory) {\n        require(!shouldRevert, \"set to always reverts\");\n        return collateralRequirement.mul(collateralRequirementTransformationScalar);\n  ","contract":"FinancialProductLibraryTest","time":0},{"type":"external-function ","before":"   function transformPrice(FixedPoint.Unsigned memory oraclePrice, uint256 requestTime)\n    public\n    view\n    virtual\n    returns (FixedPoint.Unsigned memory)\n    {\n        return oraclePrice;\n  ","after":"   function transformPrice(FixedPoint.Unsigned calldata oraclePrice, uint256 requestTime)\n    public\n    view\n    virtual\n    returns (FixedPoint.Unsigned memory)\n    {\n        return oraclePrice;\n  ","contract":"FinancialProductLibraryTest","time":0},{"type":"external-function ","before":"   function transformCollateralRequirement(\n        FixedPoint.Unsigned memory oraclePrice,\n        FixedPoint.Unsigned memory collateralRequirement\n    ) public view virtual returns (FixedPoint.Unsigned memory) {\n        return collateralRequirement;\n  ","after":"   function transformCollateralRequirement(\n        FixedPoint.Unsigned calldata oraclePrice,\n        FixedPoint.Unsigned calldata collateralRequirement\n    ) public view virtual returns (FixedPoint.Unsigned memory) {\n        return collateralRequirement;\n  ","contract":"FinancialProductLibraryTest","time":0},{"type":"immutable-restrict-modification ","before":"   bytes32 public transformedPriceIdentifi","after":"   bytes32 public transformedPriceIdentifi","contract":"FinancialProductLibraryTest","time":0},{"type":"external-function ","before":"   function calculateEffectiveFundingRate(\n        uint256 paymentPeriodSeconds,\n        FixedPoint.Signed memory fundingRatePerSecond,\n        FixedPoint.Unsigned memory currentCumulativeFundingRateMultiplier\n    ) public pure returns (FixedPoint.Unsigned memory) {\n        return\n        _calculateEffectiveFundingRate(\n            paymentPeriodSeconds,\n            fundingRatePerSecond,\n            currentCumulativeFundingRateMultiplier\n        );\n  ","after":"   function calculateEffectiveFundingRate(\n        uint256 paymentPeriodSeconds,\n        FixedPoint.Signed calldata fundingRatePerSecond,\n        FixedPoint.Unsigned calldata currentCumulativeFundingRateMultiplier\n    ) public pure returns (FixedPoint.Unsigned memory) {\n        return\n        _calculateEffectiveFundingRate(\n            paymentPeriodSeconds,\n            fundingRatePerSecond,\n            currentCumulativeFundingRateMultiplier\n        );\n  ","contract":"FundingRateApplierTest","time":0},{"type":"external-function ","before":"   function proposeFundingRate(FixedPoint.Signed memory rate, uint256 timestamp)\n    external\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory totalBond)\n    {\n        require(fundingRate.proposalTime == 0, \"Proposal in progress\");\n        _validateFundingRate(rate);\n\n        // Timestamp must be after the last funding rate update time, within the last 30 minutes.\n        uint256 currentTime = getCurrentTime();\n        uint256 updateTime = fundingRate.updateTime;\n        require(\n            timestamp > updateTime && timestamp >= currentTime.sub(_getConfig().proposalTimePastLimit),\n            \"Invalid proposal time\"\n        );\n\n        // Set the proposal time in order to allow this contract to track this request.\n        fundingRate.proposalTime = timestamp;\n\n        OptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\n\n        // Set up optimistic oracle.\n        bytes32 identifier = fundingRate.identifier;\n        bytes memory ancillaryData = _getAncillaryData();\n        // Note: requestPrice will revert if `timestamp` is less than the current block timestamp.\n        optimisticOracle.requestPrice(identifier, timestamp, ancillaryData, collateralCurrency, 0);\n        totalBond = FixedPoint.Unsigned(\n            optimisticOracle.setBond(\n                identifier,\n                timestamp,\n                ancillaryData,\n                _pfc().mul(_getConfig().proposerBondPercentage).rawValue\n            )\n        );\n\n        // Pull bond from caller and send to optimistic oracle.\n        if (totalBond.isGreaterThan(0)) {\n            collateralCurrency.safeTransferFrom(msg.sender, address(this), totalBond.rawValue);\n            collateralCurrency.safeIncreaseAllowance(address(optimisticOracle), totalBond.rawValue);\n        }\n\n        optimisticOracle.proposePriceFor(\n            msg.sender,\n            address(this),\n            identifier,\n            timestamp,\n            ancillaryData,\n            rate.rawValue\n        );\n  ","after":"   function proposeFundingRate(FixedPoint.Signed calldata rate, uint256 timestamp)\n    external\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory totalBond)\n    {\n        require(fundingRate.proposalTime == 0, \"Proposal in progress\");\n        _validateFundingRate(rate);\n\n        // Timestamp must be after the last funding rate update time, within the last 30 minutes.\n        uint256 currentTime = getCurrentTime();\n        uint256 updateTime = fundingRate.updateTime;\n        require(\n            timestamp > updateTime && timestamp >= currentTime.sub(_getConfig().proposalTimePastLimit),\n            \"Invalid proposal time\"\n        );\n\n        // Set the proposal time in order to allow this contract to track this request.\n        fundingRate.proposalTime = timestamp;\n\n        OptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\n\n        // Set up optimistic oracle.\n        bytes32 identifier = fundingRate.identifier;\n        bytes memory ancillaryData = _getAncillaryData();\n        // Note: requestPrice will revert if `timestamp` is less than the current block timestamp.\n        optimisticOracle.requestPrice(identifier, timestamp, ancillaryData, collateralCurrency, 0);\n        totalBond = FixedPoint.Unsigned(\n            optimisticOracle.setBond(\n                identifier,\n                timestamp,\n                ancillaryData,\n                _pfc().mul(_getConfig().proposerBondPercentage).rawValue\n            )\n        );\n\n        // Pull bond from caller and send to optimistic oracle.\n        if (totalBond.isGreaterThan(0)) {\n            collateralCurrency.safeTransferFrom(msg.sender, address(this), totalBond.rawValue);\n            collateralCurrency.safeIncreaseAllowance(address(optimisticOracle), totalBond.rawValue);\n        }\n\n        optimisticOracle.proposePriceFor(\n            msg.sender,\n            address(this),\n            identifier,\n            timestamp,\n            ancillaryData,\n            rate.rawValue\n        );\n  ","contract":"FundingRateApplierTest","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public emergencyShutdownTimesta","after":"   uint256 public emergencyShutdownTimesta","contract":"FundingRateApplierTest","time":1},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"FundingRateApplierTest","time":1},{"type":"external-function ","before":"   function propose(Transaction[] memory transactions) public onlyRoleHolder(uint256(Roles.Proposer)) {\n        uint256 id = proposals.length;\n        uint256 time = getCurrentTime();\n\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\n\n        // Add a zero-initialized element to the proposals array.\n        proposals.push();\n\n        // Initialize the new proposal.\n        Proposal storage proposal = proposals[id];\n        proposal.requestTime = time;\n\n        // Initialize the transaction array.\n        for (uint256 i = 0; i < transactions.length; i++) {\n            require(transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\n            if (transactions[i].data.length > 0) {\n                require(transactions[i].to.isContract(), \"EOA can't accept tx with data\");\n            }\n            proposal.transactions.push(transactions[i]);\n        }\n\n        bytes32 identifier = _constructIdentifier(id);\n\n        // Request a vote on this proposal in the DVM.\n        OracleInterface oracle = _getOracle();\n        IdentifierWhitelistInterface supportedIdentifiers = _getIdentifierWhitelist();\n        supportedIdentifiers.addSupportedIdentifier(identifier);\n\n        oracle.requestPrice(identifier, time);\n        supportedIdentifiers.removeSupportedIdentifier(identifier);\n\n        emit NewProposal(id, transactions);\n  ","after":"   function propose(Transaction[] calldata transactions) public onlyRoleHolder(uint256(Roles.Proposer)) {\n        uint256 id = proposals.length;\n        uint256 time = getCurrentTime();\n\n        // Note: doing all of this array manipulation manually is necessary because directly setting an array of\n        // structs in storage to an an array of structs in memory is currently not implemented in solidity :/.\n\n        // Add a zero-initialized element to the proposals array.\n        proposals.push();\n\n        // Initialize the new proposal.\n        Proposal storage proposal = proposals[id];\n        proposal.requestTime = time;\n\n        // Initialize the transaction array.\n        for (uint256 i = 0; i < transactions.length; i++) {\n            require(transactions[i].to != address(0), \"The `to` address cannot be 0x0\");\n            // If the transaction has any data with it the recipient must be a contract, not an EOA.\n            if (transactions[i].data.length > 0) {\n                require(transactions[i].to.isContract(), \"EOA can't accept tx with data\");\n            }\n            proposal.transactions.push(transactions[i]);\n        }\n\n        bytes32 identifier = _constructIdentifier(id);\n\n        // Request a vote on this proposal in the DVM.\n        OracleInterface oracle = _getOracle();\n        IdentifierWhitelistInterface supportedIdentifiers = _getIdentifierWhitelist();\n        supportedIdentifiers.addSupportedIdentifier(identifier);\n\n        oracle.requestPrice(identifier, time);\n        supportedIdentifiers.removeSupportedIdentifier(identifier);\n\n        emit NewProposal(id, transactions);\n  ","contract":"GovernorTest","time":0},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"GovernorTest","time":1},{"type":"de-morgan-condition ","before":"f (!lookup.isAvailable && !queryIndices[identifier][time].isVa","after":"!(f (lookup.isAvailable && queryIndices[identifier][time].isVa)","loc":{"start":{"line":5168,"column":12},"end":{"line":5168,"column":67}},"contract":"MockOracle","time":0},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"MockOracle","time":0},{"type":"de-morgan-condition ","before":"f (!lookup.isAvailable && !queryIndices[identifier][time][ancillaryData].isVa","after":"!(f (lookup.isAvailable && queryIndices[identifier][time][ancillaryData].isVa)","loc":{"start":{"line":5280,"column":12},"end":{"line":5280,"column":82}},"contract":"MockOracleAncillary","time":0},{"type":"external-function ","before":"   function requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public override {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time][ancillaryData];\n        if (!lookup.isAvailable && !queryIndices[identifier][time][ancillaryData].isValid) {\n            // New query, enqueue it for review.\n            queryIndices[identifier][time][ancillaryData] = QueryIndex(true, requestedPrices.length);\n            requestedPrices.push(QueryPoint(identifier, time, ancillaryData));\n        }\n  ","after":"   function requestPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes calldata ancillaryData\n    ) public override {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time][ancillaryData];\n        if (!lookup.isAvailable && !queryIndices[identifier][time][ancillaryData].isValid) {\n            // New query, enqueue it for review.\n            queryIndices[identifier][time][ancillaryData] = QueryIndex(true, requestedPrices.length);\n            requestedPrices.push(QueryPoint(identifier, time, ancillaryData));\n        }\n  ","contract":"MockOracleAncillary","time":0},{"type":"external-function ","before":"   function pushPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData,\n        int256 price\n    ) external {\n        verifiedPrices[identifier][time][ancillaryData] = Price(true, price, getCurrentTime());\n\n        QueryIndex storage queryIndex = queryIndices[identifier][time][ancillaryData];\n        require(queryIndex.isValid, \"Can't push prices that haven't been requested\");\n        // Delete from the array. Instead of shifting the queries over, replace the contents of `indexToReplace` with\n        // the contents of the last index (unless it is the last index).\n        uint256 indexToReplace = queryIndex.index;\n        delete queryIndices[identifier][time][ancillaryData];\n        uint256 lastIndex = requestedPrices.length - 1;\n        if (lastIndex != indexToReplace) {\n            QueryPoint storage queryToCopy = requestedPrices[lastIndex];\n            queryIndices[queryToCopy.identifier][queryToCopy.time][queryToCopy.ancillaryData].index = indexToReplace;\n            requestedPrices[indexToReplace] = queryToCopy;\n        }\n  ","after":"   function pushPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes calldata ancillaryData,\n        int256 price\n    ) external {\n        verifiedPrices[identifier][time][ancillaryData] = Price(true, price, getCurrentTime());\n\n        QueryIndex storage queryIndex = queryIndices[identifier][time][ancillaryData];\n        require(queryIndex.isValid, \"Can't push prices that haven't been requested\");\n        // Delete from the array. Instead of shifting the queries over, replace the contents of `indexToReplace` with\n        // the contents of the last index (unless it is the last index).\n        uint256 indexToReplace = queryIndex.index;\n        delete queryIndices[identifier][time][ancillaryData];\n        uint256 lastIndex = requestedPrices.length - 1;\n        if (lastIndex != indexToReplace) {\n            QueryPoint storage queryToCopy = requestedPrices[lastIndex];\n            queryIndices[queryToCopy.identifier][queryToCopy.time][queryToCopy.ancillaryData].index = indexToReplace;\n            requestedPrices[indexToReplace] = queryToCopy;\n        }\n  ","contract":"MockOracleAncillary","time":0},{"type":"external-function ","before":"   function hasPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override returns (bool) {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time][ancillaryData];\n        return lookup.isAvailable;\n  ","after":"   function hasPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes calldata ancillaryData\n    ) public view override returns (bool) {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time][ancillaryData];\n        return lookup.isAvailable;\n  ","contract":"MockOracleAncillary","time":0},{"type":"external-function ","before":"   function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes memory ancillaryData\n    ) public view override returns (int256) {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time][ancillaryData];\n        require(lookup.isAvailable);\n        return lookup.price;\n  ","after":"   function getPrice(\n        bytes32 identifier,\n        uint256 time,\n        bytes calldata ancillaryData\n    ) public view override returns (int256) {\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier));\n        Price storage lookup = verifiedPrices[identifier][time][ancillaryData];\n        require(lookup.isAvailable);\n        return lookup.price;\n  ","contract":"MockOracleAncillary","time":0},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"MockOracleAncillary","time":1},{"type":"external-function ","before":"   function swap(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] memory distribution,\n        uint256 flags\n    ) public payable override returns (uint256 returnAmount) {\n        uint256 amountReturn = prices[keccak256(abi.encodePacked(fromToken, destToken))] * amount;\n\n        require(amountReturn >= minReturn, \"Min Amount not reached\");\n\n        if (destToken == ETH_ADDRESS) {\n            msg.sender.transfer(amountReturn);\n        } else {\n            require(IERC20(destToken).transfer(msg.sender, amountReturn), \"erc20-send-failed\");\n        }\n  ","after":"   function swap(\n        address fromToken,\n        address destToken,\n        uint256 amount,\n        uint256 minReturn,\n        uint256[] calldata distribution,\n        uint256 flags\n    ) public payable override returns (uint256 returnAmount) {\n        uint256 amountReturn = prices[keccak256(abi.encodePacked(fromToken, destToken))] * amount;\n\n        require(amountReturn >= minReturn, \"Min Amount not reached\");\n\n        if (destToken == ETH_ADDRESS) {\n            msg.sender.transfer(amountReturn);\n        } else {\n            require(IERC20(destToken).transfer(msg.sender, amountReturn), \"erc20-send-failed\");\n        }\n  ","contract":"OneSplitMock","time":0},{"type":"external-function ","before":"   function requestPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        IERC20 currency,\n        uint256 reward\n    ) external override nonReentrant() returns (uint256 totalBond) {\n        require(getState(msg.sender, identifier, timestamp, ancillaryData) == State.Invalid, \"requestPrice: Invalid\");\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\n        require(timestamp <= getCurrentTime(), \"Timestamp in future\");\n        require(ancillaryData.length <= ancillaryBytesLimit, \"Invalid ancillary data\");\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\n        requests[_getId(msg.sender, identifier, timestamp, ancillaryData)] = Request({\n        proposer : address(0),\n        disputer : address(0),\n        currency : currency,\n        settled : false,\n        refundOnDispute : false,\n        proposedPrice : 0,\n        resolvedPrice : 0,\n        expirationTime : 0,\n        reward : reward,\n        finalFee : finalFee,\n        bond : finalFee,\n        customLiveness : 0\n        });\n\n        if (reward > 0) {\n            currency.safeTransferFrom(msg.sender, address(this), reward);\n        }\n\n        emit RequestPrice(msg.sender, identifier, timestamp, ancillaryData, address(currency), reward, finalFee);\n\n        // This function returns the initial proposal bond for this request, which can be customized by calling\n        // setBond() with the same identifier and timestamp.\n        return finalFee.mul(2);\n  ","after":"   function requestPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes calldata ancillaryData,\n        IERC20 currency,\n        uint256 reward\n    ) external override nonReentrant() returns (uint256 totalBond) {\n        require(getState(msg.sender, identifier, timestamp, ancillaryData) == State.Invalid, \"requestPrice: Invalid\");\n        require(_getIdentifierWhitelist().isIdentifierSupported(identifier), \"Unsupported identifier\");\n        require(_getCollateralWhitelist().isOnWhitelist(address(currency)), \"Unsupported currency\");\n        require(timestamp <= getCurrentTime(), \"Timestamp in future\");\n        require(ancillaryData.length <= ancillaryBytesLimit, \"Invalid ancillary data\");\n        uint256 finalFee = _getStore().computeFinalFee(address(currency)).rawValue;\n        requests[_getId(msg.sender, identifier, timestamp, ancillaryData)] = Request({\n        proposer : address(0),\n        disputer : address(0),\n        currency : currency,\n        settled : false,\n        refundOnDispute : false,\n        proposedPrice : 0,\n        resolvedPrice : 0,\n        expirationTime : 0,\n        reward : reward,\n        finalFee : finalFee,\n        bond : finalFee,\n        customLiveness : 0\n        });\n\n        if (reward > 0) {\n            currency.safeTransferFrom(msg.sender, address(this), reward);\n        }\n\n        emit RequestPrice(msg.sender, identifier, timestamp, ancillaryData, address(currency), reward, finalFee);\n\n        // This function returns the initial proposal bond for this request, which can be customized by calling\n        // setBond() with the same identifier and timestamp.\n        return finalFee.mul(2);\n  ","contract":"OptimisticOracle","time":0},{"type":"external-function ","before":"   function setBond(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 bond\n    ) external override nonReentrant() returns (uint256 totalBond) {\n        require(getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested, \"setBond: Requested\");\n        Request storage request = _getRequest(msg.sender, identifier, timestamp, ancillaryData);\n        request.bond = bond;\n\n        // Total bond is the final fee + the newly set bond.\n        return bond.add(request.finalFee);\n  ","after":"   function setBond(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes calldata ancillaryData,\n        uint256 bond\n    ) external override nonReentrant() returns (uint256 totalBond) {\n        require(getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested, \"setBond: Requested\");\n        Request storage request = _getRequest(msg.sender, identifier, timestamp, ancillaryData);\n        request.bond = bond;\n\n        // Total bond is the final fee + the newly set bond.\n        return bond.add(request.finalFee);\n  ","contract":"OptimisticOracle","time":0},{"type":"external-function ","before":"   function setRefundOnDispute(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external override nonReentrant() {\n        require(\n            getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\n            \"setRefundOnDispute: Requested\"\n        );\n        _getRequest(msg.sender, identifier, timestamp, ancillaryData).refundOnDispute = true;\n  ","after":"   function setRefundOnDispute(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes calldata ancillaryData\n    ) external override nonReentrant() {\n        require(\n            getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\n            \"setRefundOnDispute: Requested\"\n        );\n        _getRequest(msg.sender, identifier, timestamp, ancillaryData).refundOnDispute = true;\n  ","contract":"OptimisticOracle","time":0},{"type":"external-function ","before":"   function setCustomLiveness(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        uint256 customLiveness\n    ) external override nonReentrant() {\n        require(\n            getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\n            \"setCustomLiveness: Requested\"\n        );\n        _validateLiveness(customLiveness);\n        _getRequest(msg.sender, identifier, timestamp, ancillaryData).customLiveness = customLiveness;\n  ","after":"   function setCustomLiveness(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes calldata ancillaryData,\n        uint256 customLiveness\n    ) external override nonReentrant() {\n        require(\n            getState(msg.sender, identifier, timestamp, ancillaryData) == State.Requested,\n            \"setCustomLiveness: Requested\"\n        );\n        _validateLiveness(customLiveness);\n        _getRequest(msg.sender, identifier, timestamp, ancillaryData).customLiveness = customLiveness;\n  ","contract":"OptimisticOracle","time":0},{"type":"external-function ","before":"   function proposePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData,\n        int256 proposedPrice\n    ) external override returns (uint256 totalBond) {\n        // Note: re-entrancy guard is done in the inner call.\n        return proposePriceFor(msg.sender, requester, identifier, timestamp, ancillaryData, proposedPrice);\n  ","after":"   function proposePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes calldata ancillaryData,\n        int256 proposedPrice\n    ) external override returns (uint256 totalBond) {\n        // Note: re-entrancy guard is done in the inner call.\n        return proposePriceFor(msg.sender, requester, identifier, timestamp, ancillaryData, proposedPrice);\n  ","contract":"OptimisticOracle","time":0},{"type":"external-function ","before":"   function disputePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external override returns (uint256 totalBond) {\n        // Note: re-entrancy guard is done in the inner call.\n        return disputePriceFor(msg.sender, requester, identifier, timestamp, ancillaryData);\n  ","after":"   function disputePrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes calldata ancillaryData\n    ) external override returns (uint256 totalBond) {\n        // Note: re-entrancy guard is done in the inner call.\n        return disputePriceFor(msg.sender, requester, identifier, timestamp, ancillaryData);\n  ","contract":"OptimisticOracle","time":0},{"type":"external-function ","before":"   function settleAndGetPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external override nonReentrant() returns (int256) {\n        if (getState(msg.sender, identifier, timestamp, ancillaryData) != State.Settled) {\n            _settle(msg.sender, identifier, timestamp, ancillaryData);\n        }\n\n        return _getRequest(msg.sender, identifier, timestamp, ancillaryData).resolvedPrice;\n  ","after":"   function settleAndGetPrice(\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes calldata ancillaryData\n    ) external override nonReentrant() returns (int256) {\n        if (getState(msg.sender, identifier, timestamp, ancillaryData) != State.Settled) {\n            _settle(msg.sender, identifier, timestamp, ancillaryData);\n        }\n\n        return _getRequest(msg.sender, identifier, timestamp, ancillaryData).resolvedPrice;\n  ","contract":"OptimisticOracle","time":0},{"type":"external-function ","before":"   function settle(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) external override nonReentrant() returns (uint256 payout) {\n        return _settle(requester, identifier, timestamp, ancillaryData);\n  ","after":"   function settle(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes calldata ancillaryData\n    ) external override nonReentrant() returns (uint256 payout) {\n        return _settle(requester, identifier, timestamp, ancillaryData);\n  ","contract":"OptimisticOracle","time":0},{"type":"external-function ","before":"   function getRequest(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view override returns (Request memory) {\n        return _getRequest(requester, identifier, timestamp, ancillaryData);\n  ","after":"   function getRequest(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes calldata ancillaryData\n    ) public view override returns (Request memory) {\n        return _getRequest(requester, identifier, timestamp, ancillaryData);\n  ","contract":"OptimisticOracle","time":0},{"type":"external-function ","before":"   function hasPrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes memory ancillaryData\n    ) public view override returns (bool) {\n        State state = getState(requester, identifier, timestamp, ancillaryData);\n        return state == State.Settled || state == State.Resolved || state == State.Expired;\n  ","after":"   function hasPrice(\n        address requester,\n        bytes32 identifier,\n        uint256 timestamp,\n        bytes calldata ancillaryData\n    ) public view override returns (bool) {\n        State state = getState(requester, identifier, timestamp, ancillaryData);\n        return state == State.Settled || state == State.Resolved || state == State.Expired;\n  ","contract":"OptimisticOracle","time":0},{"type":"external-function ","before":"   function stampAncillaryData(bytes memory ancillaryData, address requester) public pure returns (bytes memory) {\n        return _stampAncillaryData(ancillaryData, requester);\n  ","after":"   function stampAncillaryData(bytes calldata ancillaryData, address requester) public pure returns (bytes memory) {\n        return _stampAncillaryData(ancillaryData, requester);\n  ","contract":"OptimisticOracle","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public defaultLivene","after":"   uint256 public defaultLivene","contract":"OptimisticOracle","time":3},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"OptimisticOracle","time":3},{"type":"struct-data-arrangement ","before":"\n   address propo\n   address dispu\n   IERC20 curre\n   bool sett\n   bool refundOnDisp\n   int256 proposedPr\n   int256 resolvedPr\n   uint256 expirationT\n   uint256 rew\n   uint256 final\n   uint256 b\n   uint256 customLiven","after":"   IERC20 curre\n   int256 proposedPr\n   int256 resolvedPr\n   uint256 expirationT\n   uint256 rew\n   uint256 final\n   uint256 b\n   uint256 customLiven\n   address propo\n   address dispu\n   bool sett\n   bool refundOnDisp\n","contract":"OptimisticOracleInterface","time":1},{"type":"external-function ","before":"   function requestPrice(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData,\n        IERC20 currency,\n        uint256 reward\n    ) external {\n        currency.approve(address(optimisticOracle), reward);\n        optimisticOracle.requestPrice(_identifier, _timestamp, _ancillaryData, currency, reward);\n  ","after":"   function requestPrice(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes calldata _ancillaryData,\n        IERC20 currency,\n        uint256 reward\n    ) external {\n        currency.approve(address(optimisticOracle), reward);\n        optimisticOracle.requestPrice(_identifier, _timestamp, _ancillaryData, currency, reward);\n  ","contract":"OptimisticRequesterTest","time":0},{"type":"external-function ","before":"   function settleAndGetPrice(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData\n    ) external returns (int256) {\n        return optimisticOracle.settleAndGetPrice(_identifier, _timestamp, _ancillaryData);\n  ","after":"   function settleAndGetPrice(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes calldata _ancillaryData\n    ) external returns (int256) {\n        return optimisticOracle.settleAndGetPrice(_identifier, _timestamp, _ancillaryData);\n  ","contract":"OptimisticRequesterTest","time":0},{"type":"external-function ","before":"   function setBond(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData,\n        uint256 bond\n    ) external {\n        optimisticOracle.setBond(_identifier, _timestamp, _ancillaryData, bond);\n  ","after":"   function setBond(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes calldata _ancillaryData,\n        uint256 bond\n    ) external {\n        optimisticOracle.setBond(_identifier, _timestamp, _ancillaryData, bond);\n  ","contract":"OptimisticRequesterTest","time":0},{"type":"external-function ","before":"   function setRefundOnDispute(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData\n    ) external {\n        optimisticOracle.setRefundOnDispute(_identifier, _timestamp, _ancillaryData);\n  ","after":"   function setRefundOnDispute(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes calldata _ancillaryData\n    ) external {\n        optimisticOracle.setRefundOnDispute(_identifier, _timestamp, _ancillaryData);\n  ","contract":"OptimisticRequesterTest","time":0},{"type":"external-function ","before":"   function setCustomLiveness(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData,\n        uint256 customLiveness\n    ) external {\n        optimisticOracle.setCustomLiveness(_identifier, _timestamp, _ancillaryData, customLiveness);\n  ","after":"   function setCustomLiveness(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes calldata _ancillaryData,\n        uint256 customLiveness\n    ) external {\n        optimisticOracle.setCustomLiveness(_identifier, _timestamp, _ancillaryData, customLiveness);\n  ","contract":"OptimisticRequesterTest","time":0},{"type":"external-function ","before":"   function priceProposed(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData\n    ) external override {\n        require(!shouldRevert);\n        identifier = _identifier;\n        timestamp = _timestamp;\n        ancillaryData = _ancillaryData;\n  ","after":"   function priceProposed(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes calldata _ancillaryData\n    ) external override {\n        require(!shouldRevert);\n        identifier = _identifier;\n        timestamp = _timestamp;\n        ancillaryData = _ancillaryData;\n  ","contract":"OptimisticRequesterTest","time":0},{"type":"external-function ","before":"   function priceDisputed(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData,\n        uint256 _refund\n    ) external override {\n        require(!shouldRevert);\n        identifier = _identifier;\n        timestamp = _timestamp;\n        ancillaryData = _ancillaryData;\n        refund = _refund;\n  ","after":"   function priceDisputed(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes calldata _ancillaryData,\n        uint256 _refund\n    ) external override {\n        require(!shouldRevert);\n        identifier = _identifier;\n        timestamp = _timestamp;\n        ancillaryData = _ancillaryData;\n        refund = _refund;\n  ","contract":"OptimisticRequesterTest","time":0},{"type":"external-function ","before":"   function priceSettled(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes memory _ancillaryData,\n        int256 _price\n    ) external override {\n        require(!shouldRevert);\n        identifier = _identifier;\n        timestamp = _timestamp;\n        ancillaryData = _ancillaryData;\n        price = _price;\n  ","after":"   function priceSettled(\n        bytes32 _identifier,\n        uint256 _timestamp,\n        bytes calldata _ancillaryData,\n        int256 _price\n    ) external override {\n        require(!shouldRevert);\n        identifier = _identifier;\n        timestamp = _timestamp;\n        ancillaryData = _ancillaryData;\n        price = _price;\n  ","contract":"OptimisticRequesterTest","time":0},{"type":"external-function ","before":"   function deposit(FixedPoint.Unsigned memory collateralAmount) public {\n        // This is just a thin wrapper over depositTo that specified the sender as the sponsor.\n        depositTo(msg.sender, collateralAmount);\n  ","after":"   function deposit(FixedPoint.Unsigned calldata collateralAmount) public {\n        // This is just a thin wrapper over depositTo that specified the sender as the sponsor.\n        depositTo(msg.sender, collateralAmount);\n  ","contract":"Perpetual","time":0},{"type":"external-function ","before":"   function withdraw(FixedPoint.Unsigned memory collateralAmount)\n    public\n    notEmergencyShutdown()\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        require(collateralAmount.isGreaterThan(0));\n        PositionData storage positionData = _getPositionData(msg.sender);\n\n        // Decrement the sponsor's collateral and global collateral amounts. Check the GCR between decrement to ensure\n        // position remains above the GCR within the withdrawal. If this is not the case the caller must submit a request.\n        amountWithdrawn = _decrementCollateralBalancesCheckGCR(positionData, collateralAmount);\n\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n\n        // Move collateral currency from contract to sender.\n        // Note: that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n        // instead of the user requested amount. This eliminates precision loss that could occur\n        // where the user withdraws more collateral than rawCollateral is decremented by.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n  ","after":"   function withdraw(FixedPoint.Unsigned calldata collateralAmount)\n    public\n    notEmergencyShutdown()\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        require(collateralAmount.isGreaterThan(0));\n        PositionData storage positionData = _getPositionData(msg.sender);\n\n        // Decrement the sponsor's collateral and global collateral amounts. Check the GCR between decrement to ensure\n        // position remains above the GCR within the withdrawal. If this is not the case the caller must submit a request.\n        amountWithdrawn = _decrementCollateralBalancesCheckGCR(positionData, collateralAmount);\n\n        emit Withdrawal(msg.sender, amountWithdrawn.rawValue);\n\n        // Move collateral currency from contract to sender.\n        // Note: that we move the amount of collateral that is decreased from rawCollateral (inclusive of fees)\n        // instead of the user requested amount. This eliminates precision loss that could occur\n        // where the user withdraws more collateral than rawCollateral is decremented by.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n  ","contract":"Perpetual","time":0},{"type":"external-function ","before":"   function requestWithdrawal(FixedPoint.Unsigned memory collateralAmount)\n    public\n    notEmergencyShutdown()\n    noPendingWithdrawal(msg.sender)\n    nonReentrant()\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(\n            collateralAmount.isGreaterThan(0) &&\n            collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral))\n        );\n\n        // Update the position object for the user.\n        positionData.withdrawalRequestPassTimestamp = getCurrentTime().add(withdrawalLiveness);\n        positionData.withdrawalRequestAmount = collateralAmount;\n\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n  ","after":"   function requestWithdrawal(FixedPoint.Unsigned calldata collateralAmount)\n    public\n    notEmergencyShutdown()\n    noPendingWithdrawal(msg.sender)\n    nonReentrant()\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(\n            collateralAmount.isGreaterThan(0) &&\n            collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral))\n        );\n\n        // Update the position object for the user.\n        positionData.withdrawalRequestPassTimestamp = getCurrentTime().add(withdrawalLiveness);\n        positionData.withdrawalRequestAmount = collateralAmount;\n\n        emit RequestWithdrawal(msg.sender, collateralAmount.rawValue);\n  ","contract":"Perpetual","time":0},{"type":"external-function ","before":"   function create(FixedPoint.Unsigned memory collateralAmount, FixedPoint.Unsigned memory numTokens)\n    public\n    notEmergencyShutdown()\n    fees()\n    nonReentrant()\n    {\n        PositionData storage positionData = positions[msg.sender];\n\n        // Either the new create ratio or the resultant position CR must be above the current GCR.\n        require(\n            (_checkCollateralization(\n            _getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),\n            positionData.tokensOutstanding.add(numTokens)\n        ) || _checkCollateralization(collateralAmount, numTokens)),\n            \"Insufficient collateral\"\n        );\n\n        require(positionData.withdrawalRequestPassTimestamp == 0);\n        if (positionData.tokensOutstanding.isEqual(0)) {\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens));\n            emit NewSponsor(msg.sender);\n        }\n\n        // Increase the position and global collateral balance by collateral amount.\n        _incrementCollateralBalances(positionData, collateralAmount);\n\n        // Add the number of tokens created to the position's outstanding tokens.\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n\n        // Transfer tokens into the contract from caller and mint corresponding synthetic tokens to the caller's address.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n\n        // Note: revert reason removed to save bytecode.\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue));\n  ","after":"   function create(FixedPoint.Unsigned calldata collateralAmount, FixedPoint.Unsigned calldata numTokens)\n    public\n    notEmergencyShutdown()\n    fees()\n    nonReentrant()\n    {\n        PositionData storage positionData = positions[msg.sender];\n\n        // Either the new create ratio or the resultant position CR must be above the current GCR.\n        require(\n            (_checkCollateralization(\n            _getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),\n            positionData.tokensOutstanding.add(numTokens)\n        ) || _checkCollateralization(collateralAmount, numTokens)),\n            \"Insufficient collateral\"\n        );\n\n        require(positionData.withdrawalRequestPassTimestamp == 0);\n        if (positionData.tokensOutstanding.isEqual(0)) {\n            require(numTokens.isGreaterThanOrEqual(minSponsorTokens));\n            emit NewSponsor(msg.sender);\n        }\n\n        // Increase the position and global collateral balance by collateral amount.\n        _incrementCollateralBalances(positionData, collateralAmount);\n\n        // Add the number of tokens created to the position's outstanding tokens.\n        positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens);\n\n        totalTokensOutstanding = totalTokensOutstanding.add(numTokens);\n\n        emit PositionCreated(msg.sender, collateralAmount.rawValue, numTokens.rawValue);\n\n        // Transfer tokens into the contract from caller and mint corresponding synthetic tokens to the caller's address.\n        collateralCurrency.safeTransferFrom(msg.sender, address(this), collateralAmount.rawValue);\n\n        // Note: revert reason removed to save bytecode.\n        require(tokenCurrency.mint(msg.sender, numTokens.rawValue));\n  ","contract":"Perpetual","time":0},{"type":"external-function ","before":"   function redeem(FixedPoint.Unsigned memory numTokens)\n    public\n    notEmergencyShutdown()\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(numTokens.isLessThanOrEqual(positionData.tokensOutstanding));\n\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n        FixedPoint.Unsigned memory collateralRedeemed =\n        fractionRedeemed.mul(_getFeeAdjustedCollateral(positionData.rawCollateral));\n\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n        } else {\n            // Decrement the sponsor's collateral and global collateral amounts.\n            amountWithdrawn = _decrementCollateralBalances(positionData, collateralRedeemed);\n\n            // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n            positionData.tokensOutstanding = newTokenCount;\n\n            // Update the totalTokensOutstanding after redemption.\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n        }\n\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n  ","after":"   function redeem(FixedPoint.Unsigned calldata numTokens)\n    public\n    notEmergencyShutdown()\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory amountWithdrawn)\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(numTokens.isLessThanOrEqual(positionData.tokensOutstanding));\n\n        FixedPoint.Unsigned memory fractionRedeemed = numTokens.div(positionData.tokensOutstanding);\n        FixedPoint.Unsigned memory collateralRedeemed =\n        fractionRedeemed.mul(_getFeeAdjustedCollateral(positionData.rawCollateral));\n\n        // If redemption returns all tokens the sponsor has then we can delete their position. Else, downsize.\n        if (positionData.tokensOutstanding.isEqual(numTokens)) {\n            amountWithdrawn = _deleteSponsorPosition(msg.sender);\n        } else {\n            // Decrement the sponsor's collateral and global collateral amounts.\n            amountWithdrawn = _decrementCollateralBalances(positionData, collateralRedeemed);\n\n            // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n            FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n            require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n            positionData.tokensOutstanding = newTokenCount;\n\n            // Update the totalTokensOutstanding after redemption.\n            totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n        }\n\n        emit Redeem(msg.sender, amountWithdrawn.rawValue, numTokens.rawValue);\n\n        // Transfer collateral from contract to caller and burn callers synthetic tokens.\n        collateralCurrency.safeTransfer(msg.sender, amountWithdrawn.rawValue);\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n  ","contract":"Perpetual","time":0},{"type":"external-function ","before":"   function repay(FixedPoint.Unsigned memory numTokens)\n    public\n    notEmergencyShutdown()\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(numTokens.isLessThanOrEqual(positionData.tokensOutstanding));\n\n        // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n        FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n        require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n        positionData.tokensOutstanding = newTokenCount;\n\n        // Update the totalTokensOutstanding after redemption.\n        totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n\n        emit Repay(msg.sender, numTokens.rawValue, newTokenCount.rawValue);\n\n        // Transfer the tokens back from the sponsor and burn them.\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n  ","after":"   function repay(FixedPoint.Unsigned calldata numTokens)\n    public\n    notEmergencyShutdown()\n    noPendingWithdrawal(msg.sender)\n    fees()\n    nonReentrant()\n    {\n        PositionData storage positionData = _getPositionData(msg.sender);\n        require(numTokens.isLessThanOrEqual(positionData.tokensOutstanding));\n\n        // Decrease the sponsors position tokens size. Ensure it is above the min sponsor size.\n        FixedPoint.Unsigned memory newTokenCount = positionData.tokensOutstanding.sub(numTokens);\n        require(newTokenCount.isGreaterThanOrEqual(minSponsorTokens));\n        positionData.tokensOutstanding = newTokenCount;\n\n        // Update the totalTokensOutstanding after redemption.\n        totalTokensOutstanding = totalTokensOutstanding.sub(numTokens);\n\n        emit Repay(msg.sender, numTokens.rawValue, newTokenCount.rawValue);\n\n        // Transfer the tokens back from the sponsor and burn them.\n        tokenCurrency.safeTransferFrom(msg.sender, address(this), numTokens.rawValue);\n        tokenCurrency.burn(numTokens.rawValue);\n  ","contract":"Perpetual","time":0},{"type":"external-function ","before":"   function getFundingRateAppliedTokenDebt(FixedPoint.Unsigned memory rawTokenDebt)\n    external\n    view\n    nonReentrantView()\n    returns (FixedPoint.Unsigned memory totalCollateral)\n    {\n        return _getFundingRateAppliedTokenDebt(rawTokenDebt);\n  ","after":"   function getFundingRateAppliedTokenDebt(FixedPoint.Unsigned calldata rawTokenDebt)\n    external\n    view\n    nonReentrantView()\n    returns (FixedPoint.Unsigned memory totalCollateral)\n    {\n        return _getFundingRateAppliedTokenDebt(rawTokenDebt);\n  ","contract":"Perpetual","time":0},{"type":"external-function ","before":"   function proposeFundingRate(FixedPoint.Signed memory rate, uint256 timestamp)\n    external\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory totalBond)\n    {\n        require(fundingRate.proposalTime == 0, \"Proposal in progress\");\n        _validateFundingRate(rate);\n\n        // Timestamp must be after the last funding rate update time, within the last 30 minutes.\n        uint256 currentTime = getCurrentTime();\n        uint256 updateTime = fundingRate.updateTime;\n        require(\n            timestamp > updateTime && timestamp >= currentTime.sub(_getConfig().proposalTimePastLimit),\n            \"Invalid proposal time\"\n        );\n\n        // Set the proposal time in order to allow this contract to track this request.\n        fundingRate.proposalTime = timestamp;\n\n        OptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\n\n        // Set up optimistic oracle.\n        bytes32 identifier = fundingRate.identifier;\n        bytes memory ancillaryData = _getAncillaryData();\n        // Note: requestPrice will revert if `timestamp` is less than the current block timestamp.\n        optimisticOracle.requestPrice(identifier, timestamp, ancillaryData, collateralCurrency, 0);\n        totalBond = FixedPoint.Unsigned(\n            optimisticOracle.setBond(\n                identifier,\n                timestamp,\n                ancillaryData,\n                _pfc().mul(_getConfig().proposerBondPercentage).rawValue\n            )\n        );\n\n        // Pull bond from caller and send to optimistic oracle.\n        if (totalBond.isGreaterThan(0)) {\n            collateralCurrency.safeTransferFrom(msg.sender, address(this), totalBond.rawValue);\n            collateralCurrency.safeIncreaseAllowance(address(optimisticOracle), totalBond.rawValue);\n        }\n\n        optimisticOracle.proposePriceFor(\n            msg.sender,\n            address(this),\n            identifier,\n            timestamp,\n            ancillaryData,\n            rate.rawValue\n        );\n  ","after":"   function proposeFundingRate(FixedPoint.Signed calldata rate, uint256 timestamp)\n    external\n    fees()\n    nonReentrant()\n    returns (FixedPoint.Unsigned memory totalBond)\n    {\n        require(fundingRate.proposalTime == 0, \"Proposal in progress\");\n        _validateFundingRate(rate);\n\n        // Timestamp must be after the last funding rate update time, within the last 30 minutes.\n        uint256 currentTime = getCurrentTime();\n        uint256 updateTime = fundingRate.updateTime;\n        require(\n            timestamp > updateTime && timestamp >= currentTime.sub(_getConfig().proposalTimePastLimit),\n            \"Invalid proposal time\"\n        );\n\n        // Set the proposal time in order to allow this contract to track this request.\n        fundingRate.proposalTime = timestamp;\n\n        OptimisticOracleInterface optimisticOracle = _getOptimisticOracle();\n\n        // Set up optimistic oracle.\n        bytes32 identifier = fundingRate.identifier;\n        bytes memory ancillaryData = _getAncillaryData();\n        // Note: requestPrice will revert if `timestamp` is less than the current block timestamp.\n        optimisticOracle.requestPrice(identifier, timestamp, ancillaryData, collateralCurrency, 0);\n        totalBond = FixedPoint.Unsigned(\n            optimisticOracle.setBond(\n                identifier,\n                timestamp,\n                ancillaryData,\n                _pfc().mul(_getConfig().proposerBondPercentage).rawValue\n            )\n        );\n\n        // Pull bond from caller and send to optimistic oracle.\n        if (totalBond.isGreaterThan(0)) {\n            collateralCurrency.safeTransferFrom(msg.sender, address(this), totalBond.rawValue);\n            collateralCurrency.safeIncreaseAllowance(address(optimisticOracle), totalBond.rawValue);\n        }\n\n        optimisticOracle.proposePriceFor(\n            msg.sender,\n            address(this),\n            identifier,\n            timestamp,\n            ancillaryData,\n            rate.rawValue\n        );\n  ","contract":"Perpetual","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public liquidationLivene","after":"   uint256 public liquidationLivene","contract":"Perpetual","time":2},{"type":"immutable-restrict-modification ","before":"   bytes32 public priceIdentifi","after":"   bytes32 public priceIdentifi","contract":"Perpetual","time":2},{"type":"immutable-restrict-modification ","before":"   uint256 public withdrawalLivene","after":"   uint256 public withdrawalLivene","contract":"Perpetual","time":2},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"Perpetual","time":2},{"type":"external-function ","before":"   function createPerpetual(Params memory params, ConfigStore.ConfigSettings memory configSettings)\n    public\n    nonReentrant()\n    returns (address)\n    {\n        require(bytes(params.syntheticName).length != 0, \"Missing synthetic name\");\n        require(bytes(params.syntheticSymbol).length != 0, \"Missing synthetic symbol\");\n\n        // Create new config settings store for this contract and reset ownership to the deployer.\n        ConfigStore configStore = new ConfigStore(configSettings, timerAddress);\n        configStore.transferOwnership(msg.sender);\n        emit CreatedConfigStore(address(configStore), configStore.owner());\n\n        // Create a new synthetic token using the params.\n        TokenFactory tf = TokenFactory(tokenFactoryAddress);\n\n        // If the collateral token does not have a `decimals()` method,\n        // then a default precision of 18 will be applied to the newly created synthetic token.\n        uint8 syntheticDecimals = _getSyntheticDecimals(params.collateralAddress);\n        ExpandedIERC20 tokenCurrency = tf.createToken(params.syntheticName, params.syntheticSymbol, syntheticDecimals);\n        address derivative = PerpetualLib.deploy(_convertParams(params, tokenCurrency, address(configStore)));\n\n        // Give permissions to new derivative contract and then hand over ownership.\n        tokenCurrency.addMinter(derivative);\n        tokenCurrency.addBurner(derivative);\n        tokenCurrency.resetOwner(derivative);\n\n        _registerContract(new address[](0), derivative);\n\n        emit CreatedPerpetual(derivative, msg.sender);\n\n        return derivative;\n  ","after":"   function createPerpetual(Params calldata params, ConfigStore.ConfigSettings calldata configSettings)\n    public\n    nonReentrant()\n    returns (address)\n    {\n        require(bytes(params.syntheticName).length != 0, \"Missing synthetic name\");\n        require(bytes(params.syntheticSymbol).length != 0, \"Missing synthetic symbol\");\n\n        // Create new config settings store for this contract and reset ownership to the deployer.\n        ConfigStore configStore = new ConfigStore(configSettings, timerAddress);\n        configStore.transferOwnership(msg.sender);\n        emit CreatedConfigStore(address(configStore), configStore.owner());\n\n        // Create a new synthetic token using the params.\n        TokenFactory tf = TokenFactory(tokenFactoryAddress);\n\n        // If the collateral token does not have a `decimals()` method,\n        // then a default precision of 18 will be applied to the newly created synthetic token.\n        uint8 syntheticDecimals = _getSyntheticDecimals(params.collateralAddress);\n        ExpandedIERC20 tokenCurrency = tf.createToken(params.syntheticName, params.syntheticSymbol, syntheticDecimals);\n        address derivative = PerpetualLib.deploy(_convertParams(params, tokenCurrency, address(configStore)));\n\n        // Give permissions to new derivative contract and then hand over ownership.\n        tokenCurrency.addMinter(derivative);\n        tokenCurrency.addBurner(derivative);\n        tokenCurrency.resetOwner(derivative);\n\n        _registerContract(new address[](0), derivative);\n\n        emit CreatedPerpetual(derivative, msg.sender);\n\n        return derivative;\n  ","contract":"PerpetualCreator","time":0},{"type":"immutable-restrict-modification ","before":"   address public tokenFactoryAddre","after":"   address public tokenFactoryAddre","contract":"PerpetualCreator","time":0},{"type":"immutable-restrict-modification ","before":"address internal finderAddress;","after":"address internal immutable finderAddress;","contract":"PerpetualCreator","time":0},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"PerpetualCreator","time":0},{"type":"external-function ","before":"   function deploy(Perpetual.ConstructorParams memory params) public returns (address) {\n        Perpetual derivative = new Perpetual(params);\n        return address(derivative);\n  ","after":"   function deploy(Perpetual.ConstructorParams calldata params) public returns (address) {\n        Perpetual derivative = new Perpetual(params);\n        return address(derivative);\n  ","contract":"PerpetualLib","time":0},{"type":"external-function ","before":"   function transformPrice(FixedPoint.Unsigned memory oraclePrice, uint256 requestTime)\n    public\n    view\n    virtual\n    returns (FixedPoint.Unsigned memory)\n    {\n        return oraclePrice;\n  ","after":"   function transformPrice(FixedPoint.Unsigned calldata oraclePrice, uint256 requestTime)\n    public\n    view\n    virtual\n    returns (FixedPoint.Unsigned memory)\n    {\n        return oraclePrice;\n  ","contract":"PreExpirationIdentifierTransformationFinancialProductLibrary","time":0},{"type":"external-function ","before":"   function transformCollateralRequirement(\n        FixedPoint.Unsigned memory oraclePrice,\n        FixedPoint.Unsigned memory collateralRequirement\n    ) public view virtual returns (FixedPoint.Unsigned memory) {\n        return collateralRequirement;\n  ","after":"   function transformCollateralRequirement(\n        FixedPoint.Unsigned calldata oraclePrice,\n        FixedPoint.Unsigned calldata collateralRequirement\n    ) public view virtual returns (FixedPoint.Unsigned memory) {\n        return collateralRequirement;\n  ","contract":"PreExpirationIdentifierTransformationFinancialProductLibrary","time":0},{"type":"external-function ","before":"   function setFinalFee(address currency, FixedPoint.Unsigned memory newFinalFee)\n    public\n    onlyRoleHolder(uint256(Roles.Owner))\n    {\n        finalFees[currency] = newFinalFee;\n        emit NewFinalFee(newFinalFee);\n  ","after":"   function setFinalFee(address currency, FixedPoint.Unsigned calldata newFinalFee)\n    public\n    onlyRoleHolder(uint256(Roles.Owner))\n    {\n        finalFees[currency] = newFinalFee;\n        emit NewFinalFee(newFinalFee);\n  ","contract":"Store","time":0},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"Store","time":1},{"type":"external-function ","before":"   function setFinancialProductStrike(address financialProduct, FixedPoint.Unsigned memory strikePrice)\n    public\n    onlyOwner\n    nonReentrant()\n    {\n        require(strikePrice.isGreaterThan(0), \"Cant set 0 strike\");\n        require(financialProductStrikes[financialProduct].isEqual(0), \"Strike already set\");\n        require(ExpiringContractInterface(financialProduct).expirationTimestamp() != 0, \"Invalid EMP contract\");\n        financialProductStrikes[financialProduct] = strikePrice;\n  ","after":"   function setFinancialProductStrike(address financialProduct, FixedPoint.Unsigned calldata strikePrice)\n    public\n    onlyOwner\n    nonReentrant()\n    {\n        require(strikePrice.isGreaterThan(0), \"Cant set 0 strike\");\n        require(financialProductStrikes[financialProduct].isEqual(0), \"Strike already set\");\n        require(ExpiringContractInterface(financialProduct).expirationTimestamp() != 0, \"Invalid EMP contract\");\n        financialProductStrikes[financialProduct] = strikePrice;\n  ","contract":"StructuredNoteFinancialProductLibrary","time":0},{"type":"external-function ","before":"   function transformPrice(FixedPoint.Unsigned memory oraclePrice, uint256 requestTime)\n    public\n    view\n    override\n    nonReentrantView()\n    returns (FixedPoint.Unsigned memory)\n    {\n        FixedPoint.Unsigned memory strike = financialProductStrikes[msg.sender];\n        require(strike.isGreaterThan(0), \"Caller has no strike\");\n        // If price request is made before expiry, return 1. Thus we can keep the contract 100% collateralized with\n        // each token backed 1:1 by collateral currency.\n        if (requestTime < ExpiringContractInterface(msg.sender).expirationTimestamp()) {\n            return FixedPoint.fromUnscaledUint(1);\n        }\n        if (oraclePrice.isLessThan(strike)) {\n            return FixedPoint.fromUnscaledUint(1);\n        } else {\n            // Token expires to be worth strike $ worth of collateral.\n            // eg if ETHUSD is $500 and strike is $400, token is redeemable for 400/500 = 0.8 WETH.\n            return strike.div(oraclePrice);\n        }\n  ","after":"   function transformPrice(FixedPoint.Unsigned calldata oraclePrice, uint256 requestTime)\n    public\n    view\n    override\n    nonReentrantView()\n    returns (FixedPoint.Unsigned memory)\n    {\n        FixedPoint.Unsigned memory strike = financialProductStrikes[msg.sender];\n        require(strike.isGreaterThan(0), \"Caller has no strike\");\n        // If price request is made before expiry, return 1. Thus we can keep the contract 100% collateralized with\n        // each token backed 1:1 by collateral currency.\n        if (requestTime < ExpiringContractInterface(msg.sender).expirationTimestamp()) {\n            return FixedPoint.fromUnscaledUint(1);\n        }\n        if (oraclePrice.isLessThan(strike)) {\n            return FixedPoint.fromUnscaledUint(1);\n        } else {\n            // Token expires to be worth strike $ worth of collateral.\n            // eg if ETHUSD is $500 and strike is $400, token is redeemable for 400/500 = 0.8 WETH.\n            return strike.div(oraclePrice);\n        }\n  ","contract":"StructuredNoteFinancialProductLibrary","time":0},{"type":"external-function ","before":"   function transformCollateralRequirement(\n        FixedPoint.Unsigned memory oraclePrice,\n        FixedPoint.Unsigned memory collateralRequirement\n    ) public view override nonReentrantView() returns (FixedPoint.Unsigned memory) {\n        FixedPoint.Unsigned memory strike = financialProductStrikes[msg.sender];\n        require(strike.isGreaterThan(0), \"Caller has no strike\");\n        // If the price is less than the strike than the original collateral requirement is used.\n        if (oraclePrice.isLessThan(strike)) {\n            return collateralRequirement;\n        } else {\n            // If the price is more than the strike then the collateral requirement is scaled by the strike. For example\n            // a strike of $400 and a CR of 1.2 would yield:\n            // ETHUSD = $350, payout is 1 WETH. CR is multiplied by 1. resulting CR = 1.2\n            // ETHUSD = $400, payout is 1 WETH. CR is multiplied by 1. resulting CR = 1.2\n            // ETHUSD = $425, payout is 0.941 WETH (worth $400). CR is multiplied by 0.941. resulting CR = 1.1292\n            // ETHUSD = $500, payout is 0.8 WETH (worth $400). CR multiplied by 0.8. resulting CR = 0.96\n            return collateralRequirement.mul(strike.div(oraclePrice));\n        }\n  ","after":"   function transformCollateralRequirement(\n        FixedPoint.Unsigned calldata oraclePrice,\n        FixedPoint.Unsigned calldata collateralRequirement\n    ) public view override nonReentrantView() returns (FixedPoint.Unsigned memory) {\n        FixedPoint.Unsigned memory strike = financialProductStrikes[msg.sender];\n        require(strike.isGreaterThan(0), \"Caller has no strike\");\n        // If the price is less than the strike than the original collateral requirement is used.\n        if (oraclePrice.isLessThan(strike)) {\n            return collateralRequirement;\n        } else {\n            // If the price is more than the strike then the collateral requirement is scaled by the strike. For example\n            // a strike of $400 and a CR of 1.2 would yield:\n            // ETHUSD = $350, payout is 1 WETH. CR is multiplied by 1. resulting CR = 1.2\n            // ETHUSD = $400, payout is 1 WETH. CR is multiplied by 1. resulting CR = 1.2\n            // ETHUSD = $425, payout is 0.941 WETH (worth $400). CR is multiplied by 0.941. resulting CR = 1.1292\n            // ETHUSD = $500, payout is 0.8 WETH (worth $400). CR multiplied by 0.8. resulting CR = 0.96\n            return collateralRequirement.mul(strike.div(oraclePrice));\n        }\n  ","contract":"StructuredNoteFinancialProductLibrary","time":0},{"type":"external-function ","before":"   function transformPrice(FixedPoint.Unsigned memory oraclePrice, uint256 requestTime)\n    public\n    view\n    virtual\n    returns (FixedPoint.Unsigned memory)\n    {\n        return oraclePrice;\n  ","after":"   function transformPrice(FixedPoint.Unsigned calldata oraclePrice, uint256 requestTime)\n    public\n    view\n    virtual\n    returns (FixedPoint.Unsigned memory)\n    {\n        return oraclePrice;\n  ","contract":"StructuredNoteFinancialProductLibrary","time":0},{"type":"external-function ","before":"   function transformCollateralRequirement(\n        FixedPoint.Unsigned memory oraclePrice,\n        FixedPoint.Unsigned memory collateralRequirement\n    ) public view virtual returns (FixedPoint.Unsigned memory) {\n        return collateralRequirement;\n  ","after":"   function transformCollateralRequirement(\n        FixedPoint.Unsigned calldata oraclePrice,\n        FixedPoint.Unsigned calldata collateralRequirement\n    ) public view virtual returns (FixedPoint.Unsigned memory) {\n        return collateralRequirement;\n  ","contract":"StructuredNoteFinancialProductLibrary","time":1},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"SyntheticToken","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"SyntheticToken","time":1},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"TestableTest","time":0},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"TestnetERC20","time":1},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"TestnetERC20","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 public snapshot","after":"   uint256 public snapshot","contract":"TokenMigrator","time":1},{"type":"immutable-restrict-modification ","before":"ade.\n    address public existing","after":"ade.\n    address public existing","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"der.\n    address public new","after":"der.\n    address public new","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"ade.\n    address publi","after":"ade.\n    address publi","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"ing;\n    address public identifierW","after":"ing;\n    address public identifierW","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"ist;\n    address publ","after":"ist;\n    address publ","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"ore;\n    address public financialContra","after":"ore;\n    address public financialContra","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"min;\n    address public ","after":"min;\n    address public ","contract":"Umip3Upgrader","time":0},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"VotingAncillaryInterfaceTesting","time":1},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"VotingInterfaceTesting","time":0},{"type":"external-function ","before":"    */\n    function setInflationRate(FixedPoint.Unsigned memory newInflationRate)\n    public\n    override(VotingInterface, VotingAncillaryInterface)\n    onlyOwner\n    {\n        inflationRate = newInflation","after":"    */\n    function setInflationRate(FixedPoint.Unsigned calldata newInflationRate)\n    public\n    override(VotingInterface, VotingAncillaryInterface)\n    onlyOwner\n    {\n        inflationRate = newInflation","contract":"VotingTest","time":0},{"type":"external-function ","before":"    */\n    function setGatPercentage(FixedPoint.Unsigned memory newGatPercentage)\n    public\n    override(VotingInterface, VotingAncillaryInterface)\n    onlyOwner\n    {\n        require(newGatPercentage.isLessThan(1), \"GAT percentage must be < 100%\");\n        gatPercentage = newGatPercen","after":"    */\n    function setGatPercentage(FixedPoint.Unsigned calldata newGatPercentage)\n    public\n    override(VotingInterface, VotingAncillaryInterface)\n    onlyOwner\n    {\n        require(newGatPercentage.isLessThan(1), \"GAT percentage must be < 100%\");\n        gatPercentage = newGatPercen","contract":"VotingTest","time":0},{"type":"constant-restrict-modification  ","before":"92;\n\n    bytes32 public snapshotMessageHash = ECDSA.toEthSignedMessageHash(keccak256(bytes(\"Sign For Snap","after":"92;\n\n    bytes32 public constant snapshotMessageHash = ECDSA.toEthSignedMessageHash(keccak256(bytes(\"Sign For Snap","contract":"VotingTest","time":1},{"type":"immutable-restrict-modification ","before":"   address public timerAddre","after":"   address public timerAddre","contract":"VotingTest","time":1},{"type":"immutable-restrict-modification ","before":"   string private _na","after":"   string private _na","contract":"VotingToken","time":0},{"type":"immutable-restrict-modification ","before":"   string private _symb","after":"   string private _symb","contract":"VotingToken","time":0},{"type":"immutable-restrict-modification ","before":"e upgrade.\n    address p","after":"e upgrade.\n    address p","contract":"VotingUpgrader","time":0},{"type":"immutable-restrict-modification ","before":"o upgrade.\n    address pu","after":"o upgrade.\n    address pu","contract":"VotingUpgrader","time":0},{"type":"immutable-restrict-modification ","before":" contract.\n    address public setM","after":" contract.\n    address public setM","contract":"VotingUpgrader","time":0}]}