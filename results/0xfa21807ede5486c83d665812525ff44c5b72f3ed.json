{"time":266,"results":[{"type":"external-function ","before":"function addPairs(\n        uint256[] memory tokenIdA,\n        uint256[] memory tokenIdB,\n        bool[] memory enabled\n    ) external onlyOwner {\n        _addPairs(tokenIdA, tokenIdB, enabled);\n    }","after":"function addPairs(\n        uint256[] calldata tokenIdA,\n        uint256[] calldata tokenIdB,\n        bool[] calldata enabled\n    ) external onlyOwner {\n        _addPairs(tokenIdA, tokenIdB, enabled);\n    }","contract":"EulerBeatsPairStaking","time":0},{"type":"external-function ","before":"function enablePairs(uint256[] memory pairIds, bool[] memory enabled) external onlyOwner {\n        _enablePairs(pairIds, enabled);\n    }","after":"function enablePairs(uint256[] calldata pairIds, bool[] calldata enabled) external onlyOwner {\n        _enablePairs(pairIds, enabled);\n    }","contract":"EulerBeatsPairStaking","time":0},{"type":"external-function ","before":"function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","after":"function onERC1155Received(address, address, uint256, uint256, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","contract":"EulerBeatsPairStaking","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","after":"function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","contract":"EulerBeatsPairStaking","time":0},{"type":"external-function ","before":"function balanceOfBatch(\n        address account,\n        address[] memory contractAddresses,\n        uint256[] memory tokenIds\n    ) public view returns (uint256[] memory batchBalances) {\n        require(contractAddresses.length == tokenIds.length, \"Length mismatch\");\n\n        batchBalances = new uint256[](tokenIds.length);\n\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\n            batchBalances[i] = balanceOf(account, contractAddresses[i], tokenIds[i]);\n        }\n    }","after":"function balanceOfBatch(\n        address account,\n        address[] calldata contractAddresses,\n        uint256[] calldata tokenIds\n    ) public view returns (uint256[] memory batchBalances) {\n        require(contractAddresses.length == tokenIds.length, \"Length mismatch\");\n\n        batchBalances = new uint256[](tokenIds.length);\n\n        for (uint256 i = 0; i < tokenIds.length; ++i) {\n            batchBalances[i] = balanceOf(account, contractAddresses[i], tokenIds[i]);\n        }\n    }","contract":"EulerBeatsPairStaking","time":0},{"type":"immutable-restrict-modification ","before":"address public tokenA;","after":"address public immutable tokenA;","contract":"EulerBeatsPairStaking","time":1},{"type":"immutable-restrict-modification ","before":"address public tokenB;","after":"address public immutable tokenB;","contract":"EulerBeatsPairStaking","time":1}]}