{"time":175,"results":[{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping(address => EnumerableSet.UintSet) private _holderTokens;\nEnumerableMap.UintToAddressMap private _tokenOwners;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nstring private _name;\nstring private _symbol;\nmapping(uint256 => string) private _tokenURIs;\nstring private _baseURI;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\nbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;","after":"mapping(address => EnumerableSet.UintSet) private _holderTokens;\nEnumerableMap.UintToAddressMap private _tokenOwners;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nstring private _name;\nstring private _symbol;\nmapping(uint256 => string) private _tokenURIs;\nstring private _baseURI;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\nbytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n","contract":"ERC721","time":0},{"type":"external-function ","before":"function initialize(\n        string memory baseURI,\n        address payable _vault,\n        address _uriSigner,\n        IERC20 _solos,\n        address _timelock\n    ) public onlyOwner onlyInitializeOnce {\n        // Vote Token\n        solos = _solos;\n\n        // Set the base uri\n        _setBaseURI(baseURI);\n\n        uriSigner = _uriSigner;\n\n        // Set minting status\n        paused = false;\n\n        // Set the vault\n        vault = _vault;\n\n        // Address of the timelock\n        timelock = _timelock;\n    }","after":"function initialize(\n        string calldata baseURI,\n        address payable _vault,\n        address _uriSigner,\n        IERC20 _solos,\n        address _timelock\n    ) public onlyOwner onlyInitializeOnce {\n        // Vote Token\n        solos = _solos;\n\n        // Set the base uri\n        _setBaseURI(baseURI);\n\n        uriSigner = _uriSigner;\n\n        // Set minting status\n        paused = false;\n\n        // Set the vault\n        vault = _vault;\n\n        // Address of the timelock\n        timelock = _timelock;\n    }","contract":"NFT","time":0},{"type":"external-function ","before":"function createPermanentURI(\n        bytes memory signature,\n        string memory arweaveHash,\n        uint16 tokenId\n    ) public nonReentrant {\n        // Note on Underlow for TokenID\n        // This does not seem to be a danger, because we WANT tokens to be claimed. Only the onwer can claim in 24 hours, so it's fine if a underflow happens.\n        // in any case that should not pass the signature check.\n\n        // check to be sure this tokenID has not been claimed\n        require(\n            keccak256(abi.encodePacked(permanentURIArweave[tokenId])) == keccak256(abi.encodePacked(\"\")),\n            \"Error: TokenId already claimed\"\n        );\n\n        // Check to make sure this tokenID is inbounds:\n        require(tokenId <= maxTokenCount, \"Error: Maximum number of tokens have been minted\");\n\n        // Give the minter a 3 day lead time to claim these tokens\n        if (msg.sender != minterLog[tokenId].minter) {\n            require(\n                block.timestamp > minterLog[tokenId].timestamp + 3 days,\n                \"Error: Minters 1 day delay not yet expired\"\n            );\n        }\n\n        // Check the signature\n        require(_isValidData(tokenId, arweaveHash, signature), \"Error: signature did not match\");\n\n        // Update the token URI\n        permanentURIArweave[tokenId] = arweaveHash;\n\n        // Give users community Solos for this\n        solos.transfer(msg.sender, baseSolosPerUri);\n\n        // Make the Data permanently availible\n        emit PermanentURIAdded(tokenId, arweaveHash);\n    }","after":"function createPermanentURI(\n        bytes calldata signature,\n        string calldata arweaveHash,\n        uint16 tokenId\n    ) public nonReentrant {\n        // Note on Underlow for TokenID\n        // This does not seem to be a danger, because we WANT tokens to be claimed. Only the onwer can claim in 24 hours, so it's fine if a underflow happens.\n        // in any case that should not pass the signature check.\n\n        // check to be sure this tokenID has not been claimed\n        require(\n            keccak256(abi.encodePacked(permanentURIArweave[tokenId])) == keccak256(abi.encodePacked(\"\")),\n            \"Error: TokenId already claimed\"\n        );\n\n        // Check to make sure this tokenID is inbounds:\n        require(tokenId <= maxTokenCount, \"Error: Maximum number of tokens have been minted\");\n\n        // Give the minter a 3 day lead time to claim these tokens\n        if (msg.sender != minterLog[tokenId].minter) {\n            require(\n                block.timestamp > minterLog[tokenId].timestamp + 3 days,\n                \"Error: Minters 1 day delay not yet expired\"\n            );\n        }\n\n        // Check the signature\n        require(_isValidData(tokenId, arweaveHash, signature), \"Error: signature did not match\");\n\n        // Update the token URI\n        permanentURIArweave[tokenId] = arweaveHash;\n\n        // Give users community Solos for this\n        solos.transfer(msg.sender, baseSolosPerUri);\n\n        // Make the Data permanently availible\n        emit PermanentURIAdded(tokenId, arweaveHash);\n    }","contract":"NFT","time":0},{"type":"external-function ","before":"function updateBaseURI(string memory baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }","after":"function updateBaseURI(string calldata baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }","contract":"NFT","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"NFT","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"NFT","time":1}]}