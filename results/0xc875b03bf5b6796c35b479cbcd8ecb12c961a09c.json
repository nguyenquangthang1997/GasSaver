{"time":122,"results":[{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"ERC20","time":1},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"ERC20","time":1},{"type":"external-function ","before":"function swapToETHAndSend(address[] memory tokens, address payable _to) external onlyOwner {\n        for (uint256 index = 0; index < tokens.length; index++) {\n            address token = tokens[index];\n            uint256 balance = IERC20(token).balanceOf(address(this));\n\n            // USDT approve doesn’t comply with the ERC20 standard\n            IERC20(token).safeApprove(uniswapRouterAddress, balance);\n\n            // can not use swapExactTokensForETH if token is WETH\n            if (token == IUniswapV2Router02(uniswapRouterAddress).WETH()) {\n                // unwrap WETH\n                IWETH9(token).withdraw(IERC20(token).balanceOf(address(this)));\n                // transfer ETH to Fee Storage\n                IERC20(token).transfer(\n                    address(this),\n                    IERC20(token).balanceOf(address(this))\n                );\n\n                continue;\n            }\n\n            address[] memory path = new address[](2);\n            path[0] = token;\n            path[1] = IUniswapV2Router02(uniswapRouterAddress).WETH();\n\n            uint256[] memory amounts =\n            IUniswapV2Router02(uniswapRouterAddress).getAmountsOut(balance, path);\n\n            uint256 amountOutMin = amounts[1];\n            IUniswapV2Router02(uniswapRouterAddress).swapExactTokensForETH(\n                balance,\n                amountOutMin,\n                path,\n                address(this),\n                block.timestamp\n            );\n        }\n\n        sendFeeETH(_to);\n   ","after":"function swapToETHAndSend(address[] calldata tokens, address payable _to) external onlyOwner {\n        for (uint256 index = 0; index < tokens.length; index++) {\n            address token = tokens[index];\n            uint256 balance = IERC20(token).balanceOf(address(this));\n\n            // USDT approve doesn’t comply with the ERC20 standard\n            IERC20(token).safeApprove(uniswapRouterAddress, balance);\n\n            // can not use swapExactTokensForETH if token is WETH\n            if (token == IUniswapV2Router02(uniswapRouterAddress).WETH()) {\n                // unwrap WETH\n                IWETH9(token).withdraw(IERC20(token).balanceOf(address(this)));\n                // transfer ETH to Fee Storage\n                IERC20(token).transfer(\n                    address(this),\n                    IERC20(token).balanceOf(address(this))\n                );\n\n                continue;\n            }\n\n            address[] memory path = new address[](2);\n            path[0] = token;\n            path[1] = IUniswapV2Router02(uniswapRouterAddress).WETH();\n\n            uint256[] memory amounts =\n            IUniswapV2Router02(uniswapRouterAddress).getAmountsOut(balance, path);\n\n            uint256 amountOutMin = amounts[1];\n            IUniswapV2Router02(uniswapRouterAddress).swapExactTokensForETH(\n                balance,\n                amountOutMin,\n                path,\n                address(this),\n                block.timestamp\n            );\n        }\n\n        sendFeeETH(_to);\n   ","contract":"FeeStorage","time":0},{"type":"external-function ","before":"  function getAmountsOut(uint256 amountIn, address[] memory path)\n    external\n    view\n    returns (uint256)\n    {\n        address tokenIn = path[0];\n        uint256 tokenInDecimals = ERC20(tokenIn).decimals();\n        uint256 feeAmount =\n        calculateFee(feeQuota, feeQuotaDecimals, tokenInDecimals, amountIn);\n        uint256 amountInWoFee = amountIn.sub(feeAmount);\n        uint256[] memory amountsOut = uniswap.getAmountsOut(amountInWoFee, path);\n        return amountsOut[amountsOut.length - 1];\n   ","after":"  function getAmountsOut(uint256 amountIn, address[] calldata path)\n    external\n    view\n    returns (uint256)\n    {\n        address tokenIn = path[0];\n        uint256 tokenInDecimals = ERC20(tokenIn).decimals();\n        uint256 feeAmount =\n        calculateFee(feeQuota, feeQuotaDecimals, tokenInDecimals, amountIn);\n        uint256 amountInWoFee = amountIn.sub(feeAmount);\n        uint256[] memory amountsOut = uniswap.getAmountsOut(amountInWoFee, path);\n        return amountsOut[amountsOut.length - 1];\n   ","contract":"ManualTrade","time":0},{"type":"immutable-restrict-modification ","before":"  address payable private feeStorag","after":"  address payable private feeStorag","contract":"ManualTrade","time":0}]}