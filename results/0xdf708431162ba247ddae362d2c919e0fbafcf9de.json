{"time":836,"results":[{"type":"external-function ","before":"the contract uses delegated authority,\n    /// returns the original source of the delegated authority.\n    /// If the contract doesn't use delegated authority,\n    /// returns the contract itself.\n    /// Authorize `getAuthoritySource(operatorContract)`\n    /// to grant `operatorContract","after":"the contract uses delegated authority,\n    /// returns the original source of the delegated authority.\n    /// If the contract doesn't use delegated authority,\n    /// returns the contract itself.\n    /// Authorize `getAuthoritySource(operatorContract)`\n    /// to grant `operatorContract","contract":"BLS","time":0},{"type":"external-function ","before":"al(p_2);\n    }\n\n    /**\n     * @dev Verify performs the pairing operation to check if the signature\n     * is correct for the provided message and the corresponding public key.\n     * Public key must be a valid point on G2 curve in an uncompressed format.\n     * Message must be a valid point on G1 curve in an uncompressed format.\n     * Signature must b","after":"al(p_2);\n    }\n\n    /**\n     * @dev Verify performs the pairing operation to check if the signature\n     * is correct for the provided message and the corresponding public key.\n     * Public key must be a valid point on G2 curve in an uncompressed format.\n     * Message must be a valid point on G1 curve in an uncompressed format.\n     * Signature must b","contract":"BLS","time":0},{"type":"external-function ","before":"d;\n    }\n\n    /// @notice Verifies the submitted DKG result against supporting member\n    /// signatures and if the submitter is eligible to submit at the current\n    /// block. Every signature supporting the result has to be from a unique\n    /// group member.\n    ///\n    /// @param submitterMemberIndex Claimed submitter candidate group member index\n    /// @param groupPubKey Generated candidate group public key\n    /// @param misbehaved Bytes array of misbehaved (disqualified or inactive)\n    /// group members indexes; Indexes reflect positions of members in the group,\n    /// as outputted by the group selection protocol.\n    /// @param signatures Concatenation of signatures from members supporting the\n    /// result.\n    /// @param signingMemberIndices Indices of members corresponding to each\n    /// signature. Indices have to be unique.\n    /// @param members Addresses of candidate group members as outputted by the\n    /// group selection protocol.\n    /// @param groupSelectionEndBlock Block height at which the group selection\n    /// protocol ended.\n    function verify(\n        Storage storage self,\n        uint256 submitterMemberIndex,\n        bytes memory groupPubKey,\n        bytes memory misbehaved,\n        bytes memory signatures,\n        uint256[] memory signingMemberIndices,\n        address[] memory members,\n        uint256 groupSelectionEndBlock\n    ) public view {\n        require(submitterMemberIndex > 0, \"Invalid submitter index\");\n        require(\n            members[submitterMemberIndex - 1] == msg.sender,\n            \"Unexpected submitter index\"\n        );\n\n        uint T_init = groupSelectionEndBlock + self.timeDKG;\n        require(\n            block.number >= (T_init + (submitterMemberIndex - 1) * self.resultPublicationBlockStep),\n            \"Submitter not eligible\"\n        );\n\n        require(groupPubKey.length == 128, \"Malformed group public key\");\n\n        require(\n            misbehaved.length <= self.groupSize - self.signatureThreshold,\n            \"Malformed misbehaved bytes\"\n        );\n\n        uint256 signaturesCount = signatures.length / 65;\n        require(signatures.length >= 65, \"Too short signatures array\");\n        require(signatures.length % 65 == 0, \"Malformed signatures array\");\n        require(signaturesCount == signi","after":"d;\n    }\n\n    /// @notice Verifies the submitted DKG result against supporting member\n    /// signatures and if the submitter is eligible to submit at the current\n    /// block. Every signature supporting the result has to be from a unique\n    /// group member.\n    ///\n    /// @param submitterMemberIndex Claimed submitter candidate group member index\n    /// @param groupPubKey Generated candidate group public key\n    /// @param misbehaved Bytes array of misbehaved (disqualified or inactive)\n    /// group members indexes; Indexes reflect positions of members in the group,\n    /// as outputted by the group selection protocol.\n    /// @param signatures Concatenation of signatures from members supporting the\n    /// result.\n    /// @param signingMemberIndices Indices of members corresponding to each\n    /// signature. Indices have to be unique.\n    /// @param members Addresses of candidate group members as outputted by the\n    /// group selection protocol.\n    /// @param groupSelectionEndBlock Block height at which the group selection\n    /// protocol ended.\n    function verify(\n        Storage storage self,\n        uint256 submitterMemberIndex,\n        bytes memory groupPubKey,\n        bytes memory misbehaved,\n        bytes memory signatures,\n        uint256[] memory signingMemberIndices,\n        address[] memory members,\n        uint256 groupSelectionEndBlock\n    ) public view {\n        require(submitterMemberIndex > 0, \"Invalid submitter index\");\n        require(\n            members[submitterMemberIndex - 1] == msg.sender,\n            \"Unexpected submitter index\"\n        );\n\n        uint T_init = groupSelectionEndBlock + self.timeDKG;\n        require(\n            block.number >= (T_init + (submitterMemberIndex - 1) * self.resultPublicationBlockStep),\n            \"Submitter not eligible\"\n        );\n\n        require(groupPubKey.length == 128, \"Malformed group public key\");\n\n        require(\n            misbehaved.length <= self.groupSize - self.signatureThreshold,\n            \"Malformed misbehaved bytes\"\n        );\n\n        uint256 signaturesCount = signatures.length / 65;\n        require(signatures.length >= 65, \"Too short signatures array\");\n        require(signatures.length % 65 == 0, \"Malformed signatures array\");\n        require(signaturesCount == signi","contract":"DKGResultVerification","time":0},{"type":"external-function ","before":"ant.sol\";\nimport \"../../TokenStakingEscrow.sol\";\nimport \"../..//utils/BytesLib.sol\";\nimport \"../RolesLookup.sol\";\n\n/// @notice TokenStaking contract library allowing to capture the details of\n/// delegated grants and offering functions allowing to check grantee\n/// authentication for stake delegation management.\nlibrary GrantStaking {\n    using BytesLib for bytes;\n    using RolesLookup for address payable;\n\n    /// @dev Grant ID is flagged with the most significant bit set, to\n    /// distinguish the grant ID `0` from default (null) value. The flag is\n    /// toggled with bitwise XOR (`^`) which","after":"ant.sol\";\nimport \"../../TokenStakingEscrow.sol\";\nimport \"../..//utils/BytesLib.sol\";\nimport \"../RolesLookup.sol\";\n\n/// @notice TokenStaking contract library allowing to capture the details of\n/// delegated grants and offering functions allowing to check grantee\n/// authentication for stake delegation management.\nlibrary GrantStaking {\n    using BytesLib for bytes;\n    using RolesLookup for address payable;\n\n    /// @dev Grant ID is flagged with the most significant bit set, to\n    /// distinguish the grant ID `0` from default (null) value. The flag is\n    /// toggled with bitwise XOR (`^`) which","contract":"GrantStaking","time":0},{"type":"external-function ","before":"LS.sol\";\nimport \"../../TokenStaking.sol\";\n\n\nlibrary Groups {\n    using SafeMath for uint256;\n    using PercentUtils for uint256;\n    using BytesLib for bytes;\n\n    // The index of a group is flagged with the most significant bit set,\n    // to distinguish the group `0` from nu","after":"LS.sol\";\nimport \"../../TokenStaking.sol\";\n\n\nlibrary Groups {\n    using SafeMath for uint256;\n    using PercentUtils for uint256;\n    using BytesLib for bytes;\n\n    // The index of a group is flagged with the most significant bit set,\n    // to distinguish the group `0` from nu","contract":"Groups","time":0},{"type":"external-function ","before":"    uint248 registrationTime;\n    }\n\n    struct Storage {\n        // Time in blocks after which a group expires.\n        uint256 groupActiveTime;\n\n        // Duplicated constant from operator contract to avoid extra call.\n        // The value is set when the operator contract is added.\n        uint256 relayEntryTimeout;\n\n        // Mapping of `groupPubKey` to flagged `groupIndex`\n        mapping(bytes => uint256) groupIndices;\n        Group[] groups;\n        uint256[] activeTerminatedGroups;\n        mapping(bytes => address[]) groupMembers;\n\n        // Sum of all group member rewards earned so far. The value is the same for\n        // all group members. Submitter reward and reimbursement is paid immediately\n        // and is not included here. Each group member can withdraw no more th","after":"    uint248 registrationTime;\n    }\n\n    struct Storage {\n        // Time in blocks after which a group expires.\n        uint256 groupActiveTime;\n\n        // Duplicated constant from operator contract to avoid extra call.\n        // The value is set when the operator contract is added.\n        uint256 relayEntryTimeout;\n\n        // Mapping of `groupPubKey` to flagged `groupIndex`\n        mapping(bytes => uint256) groupIndices;\n        Group[] groups;\n        uint256[] activeTerminatedGroups;\n        mapping(bytes => address[]) groupMembers;\n\n        // Sum of all group member rewards earned so far. The value is the same for\n        // all group members. Submitter reward and reimbursement is paid immediately\n        // and is not included here. Each group member can withdraw no more th","contract":"Groups","time":0},{"type":"external-function ","before":"& isStale, \"Group must be expired and stale\");\n        bytes memory groupPublicKey = getGroupPublicKey(self, groupIndex);\n        require(\n            !(self.withdrawn[groupPublicKey][operator]),\n            \"Rewards already withdrawn\"\n        );\n        self.withdrawn[groupPublicKey][operator] = true;\n        for (uint i = 0; i < self.groupMembers[groupPublicKey].length; i++) {\n            if (operator == self.groupMembers[groupPublicKey][i]) {\n                rewards = rewards.add(self.groupMemberRewards[groupPublicKey]);\n            }\n        }\n    }\n\n    /// @notice Returns members of the given group by group public key.\n    /// @param groupPubKey Group public key.\n    f","after":"& isStale, \"Group must be expired and stale\");\n        bytes calldata groupPublicKey = getGroupPublicKey(self, groupIndex);\n        require(\n            !(self.withdrawn[groupPublicKey][operator]),\n            \"Rewards already withdrawn\"\n        );\n        self.withdrawn[groupPublicKey][operator] = true;\n        for (uint i = 0; i < self.groupMembers[groupPublicKey].length; i++) {\n            if (operator == self.groupMembers[groupPublicKey][i]) {\n                rewards = rewards.add(self.groupMemberRewards[groupPublicKey]);\n            }\n        }\n    }\n\n    /// @notice Returns members of the given group by group public key.\n    /// @param groupPubKey Group public key.\n    f","contract":"Groups","time":0},{"type":"external-function ","before":"inimumStake();\n        groupSelection.start(_newEntry);\n        emit GroupSelectionStarted(_newEntry);\n        dkgSubmitterReimbursementFee = _payment;\n    }\n\n    /// @notice Checks if it is possible to fire a new group selection.\n    /// Triggering new group selection is only possible when there is no\n    /// pending group selection or when the pending group selection timed out.\n    function isGroupSelectionPossible() public view returns (bool) {\n        if (!groupSelection.inProgress) {\n            return true;\n        }\n\n        // dkgTimeout is the time after key generation protocol is expected to\n        // be complete plus the expected time to submit the result.\n        uint256 dkgTimeout = groupSelection.ticketSubmissionStartBlock +\n        groupSelection.ticketSubmissionTimeout +\n        dkgResultVerification.timeDKG +\n        groupSize * resul","after":"inimumStake();\n        groupSelection.start(_newEntry);\n        emit GroupSelectionStarted(_newEntry);\n        dkgSubmitterReimbursementFee = _payment;\n    }\n\n    /// @notice Checks if it is possible to fire a new group selection.\n    /// Triggering new group selection is only possible when there is no\n    /// pending group selection or when the pending group selection timed out.\n    function isGroupSelectionPossible() public view returns (bool) {\n        if (!groupSelection.inProgress) {\n            return true;\n        }\n\n        // dkgTimeout is the time after key generation protocol is expected to\n        // be complete plus the expected time to submit the result.\n        uint256 dkgTimeout = groupSelection.ticketSubmissionStartBlock +\n        groupSelection.ticketSubmissionTimeout +\n        dkgResultVerification.timeDKG +\n        groupSize * resul","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"    /// @param misbehaved Bytes array of misbehaved (disqualified or inactive)\n    /// group members indexes in ascending order; Indexes reflect positions of\n    /// members in the group as outputted by the group selection protocol.\n    /// @param signatures Concatenation of signatures from members supporting the\n    /// result.\n    /// @param signingMembersIndexes Indices of members corresponding to each\n    /// signature.\n    function submitDkgResult(\n        uint256 submitterMemberIndex,\n        bytes memory groupPubKey,\n        bytes memory misbehaved,\n        bytes memor","after":"    /// @param misbehaved Bytes array of misbehaved (disqualified or inactive)\n    /// group members indexes in ascending order; Indexes reflect positions of\n    /// members in the group as outputted by the group selection protocol.\n    /// @param signatures Concatenation of signatures from members supporting the\n    /// result.\n    /// @param signingMembersIndexes Indices of members corresponding to each\n    /// signature.\n    function submitDkgResult(\n        uint256 submitterMemberIndex,\n        bytes memory groupPubKey,\n        bytes memory misbehaved,\n        bytes memor","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"G.\n    function reimburseDkgSubmitter() internal {\n        uint256 gasPrice = gasPriceCeiling;\n        // We need to check if tx.gasprice is non-zero as a workaround to a bug\n        // in go-ethereum:\n        // https://github.com/ethereum/go-ethereum/pull/20189\n        if (tx.gasprice > 0 && tx.gasprice < gasPriceCeiling) {\n            gasPrice = tx.gasprice;\n        }\n\n        uint256 reimbursementFee = dkgGasEstimate.mul(gasPrice);\n        address payable beneficiary = stakingContract.beneficiaryOf(msg.sender);\n\n        if (reimbursementFee < dkgSubmitterReimbursementFee) {\n            uint256 surplus = dkgSubmitterReimbursementFee.sub(reimbursementFee);\n            dkgSubmitterReimbursementFee = 0;\n            // Reimburse submitter with actual DKG cost.\n            beneficiary.call.value(reimbursementFee)(\"\");\n\n            // Return surplus to the contract that started DKG.\n            groupSelectionStarterContract.fundDkgFeePool.value(surplus)();\n        } else {\n            // If submitter used higher gas price reimburse only\n            // dkgSubmitterReimbursementFee max.\n            reimbursementFee = dkgSubmitterReimbursementFee;\n            dkgSubmitterReimbursementFee = 0;\n            beneficiary.call.value(reimbursementFee)(\"\");\n        }\n    }\n\n    /// @notice Creates a request to generate a new relay entry, which will include\n    /// a random number (by signing the previous entry's random number).\n    /// @param requestId Request Id trackable by service contract\n    /// @param previousEntry Previous relay entry\n    function sign(\n        uint256 requestId,\n        b","after":"G.\n    function reimburseDkgSubmitter() internal {\n        uint256 gasPrice = gasPriceCeiling;\n        // We need to check if tx.gasprice is non-zero as a workaround to a bug\n        // in go-ethereum:\n        // https://github.com/ethereum/go-ethereum/pull/20189\n        if (tx.gasprice > 0 && tx.gasprice < gasPriceCeiling) {\n            gasPrice = tx.gasprice;\n        }\n\n        uint256 reimbursementFee = dkgGasEstimate.mul(gasPrice);\n        address payable beneficiary = stakingContract.beneficiaryOf(msg.sender);\n\n        if (reimbursementFee < dkgSubmitterReimbursementFee) {\n            uint256 surplus = dkgSubmitterReimbursementFee.sub(reimbursementFee);\n            dkgSubmitterReimbursementFee = 0;\n            // Reimburse submitter with actual DKG cost.\n            beneficiary.call.value(reimbursementFee)(\"\");\n\n            // Return surplus to the contract that started DKG.\n            groupSelectionStarterContract.fundDkgFeePool.value(surplus)();\n        } else {\n            // If submitter used higher gas price reimburse only\n            // dkgSubmitterReimbursementFee max.\n            reimbursementFee = dkgSubmitterReimbursementFee;\n            dkgSubmitterReimbursementFee = 0;\n            beneficiary.call.value(reimbursementFee)(\"\");\n        }\n    }\n\n    /// @notice Creates a request to generate a new relay entry, which will include\n    /// a random number (by signing the previous entry's random number).\n    /// @param requestId Request Id trackable by service contract\n    /// @param previousEntry Previous relay entry\n    function sign(\n        uint256 requestId,\n        b","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"ProfitFee());\n        submitterReward = entryVerificationFee.add(submitterExtraReward);\n\n        // Rewards not paid out to the operators are","after":"ProfitFee());\n        submitterReward = entryVerificationFee.add(submitterExtraReward);\n\n        // Rewards not paid out to the operators are","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"certain timeout for a new relay entry\n    /// to be produced, see `relayEntryTimeout` value.\n    function hasEntryTimedOut() intern","after":"certain timeout for a new relay entry\n    /// to be produced, see `relayEntryTimeout` value.\n    function hasEntryTimedOut() intern","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"ntryTimeout(currentRequestGroupIndex, groupSize);\n        currentRequestStartBlock = 0;\n\n        // We could terminate the last active group. If that","after":"ntryTimeout(currentRequestGroupIndex, groupSize);\n        currentRequestStartBlock = 0;\n\n        // We could terminate the last active group. If that","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"ubKey) public view returns (bool) {\n        return groups.isStaleGroup(groupPubKey);\n    }\n\n    /// @notice Gets the number of active groups as currently mar","after":"ubKey) public view returns (bool) {\n        return groups.isStaleGroup(groupPubKey);\n    }\n\n    /// @notice Gets the number of active groups as currently mar","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"oups.groupMemberRewards[groupPubKey];\n    }\n\n    /// @notice Return whether the given operator has withdrawn their rewards\n    /// from the given group.\n    function hasWithdrawnRewards(address operator, uint256 groupIndex)\n    public view returns (bool) {\n        return groups.hasWithdrawnRewards(operator, groupIndex);\n  ","after":"oups.groupMemberRewards[groupPubKey];\n    }\n\n    /// @notice Return whether the given operator has withdrawn their rewards\n    /// from the given group.\n    function hasWithdrawnRewards(address operator, uint256 groupIndex)\n    public view returns (bool) {\n        return groups.hasWithdrawnRewards(operator, groupIndex);\n  ","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"�▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓�","after":"�▓▓▓▓▓     ▓▓▓▓▓   ▓▓▓▓�","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"▓▓▓  ▓▓▓▓▓▓�","after":"▓▓▓  ▓▓▓▓▓▓�","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"acts/math/SafeMath.sol\";\nimport \"op","after":"acts/math/SafeMath.sol\";\nimport \"op","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"sol\";\nimport \"./GasPriceOracle.sol\";\nimport \".","after":"sol\";\nimport \"./GasPriceOracle.sol\";\nimport \".","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"tion entryCreated(uint256 requestId, bytes calldata entry, address payable su","after":"tion entryCreated(uint256 requestId, bytes calldata entry, address payable su","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"tId) external view returns (address payable);\n}\n\n/// ","after":"tId) external view returns (address payable);\n}\n\n/// ","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":"rity-critical operations.\n/// Handles gr","after":"rity-critical operations.\n/// Handles gr","contract":"KeepRandomBeaconOperator","time":0},{"type":"constant-restrict-modification  ","before":" The contract is not upgradeable. New functionalit","after":" The contract is not upgradeable. New functionalit","contract":"KeepRandomBeaconOperator","time":0},{"type":"external-function ","before":"\n        emit OperatorContractUpgraderUpdated(\n            _serviceContract,\n            _operatorContractUpgrader\n        );\n    }\n\n    function setServiceContractUpgrader(\n        address _operatorContract,\n        address _serviceContractUpgrader\n    ) public onlyGovernance {\n        serviceContractUpgraders[_operatorContract] = _serv","after":"\n        emit OperatorContractUpgraderUpdated(\n            _serviceContract,\n            _operatorContractUpgrader\n        );\n    }\n\n    function setServiceContractUpgrader(\n        address _operatorContract,\n        address _serviceContractUpgrader\n    ) public onlyGovernance {\n        serviceContractUpgraders[_operatorContract] = _serv","contract":"KeepToken","time":0},{"type":"immutable-restrict-modification ","before":"ve}.\n     */\n    func","after":"ve}.\n     */\n    func","contract":"KeepToken","time":0},{"type":"immutable-restrict-modification ","before":"_burnFrom(address accou","after":"_burnFrom(address accou","contract":"KeepToken","time":0},{"type":"immutable-restrict-modification ","before":"int256 amount) internal ","after":"int256 amount) internal ","contract":"KeepToken","time":0},{"type":"external-function ","before":"address _grantManager,\n        uint256 _grantId,\n        address _grantee\n    ) public {\n        token = ERC20Burnable(_tokenAddress);\n        tokenGrant = TokenGrant(_tokenGrant);\n        grantManager = _grantMan","after":"address _grantManager,\n        uint256 _grantId,\n        address _grantee\n    ) public {\n        token = ERC20Burnable(_tokenAddress);\n        tokenGrant = TokenGrant(_tokenGrant);\n        grantManager = _grantMan","contract":"ManagedGrant","time":0},{"type":"immutable-restrict-modification ","before":"storage self,\n        addres","after":"storage self,\n        addres","contract":"ManagedGrant","time":0},{"type":"immutable-restrict-modification ","before":"rator,\n        address ","after":"rator,\n        address ","contract":"ManagedGrant","time":0},{"type":"external-function ","before":"(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\npragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nlibrary PercentUtils {\n    using SafeMath for uint256;\n\n    // Return `b`% of `a`\n    // 200.percent(40) == 80\n    // Commutative, works both ways\n    function percent(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(b).div(100);\n    }\n\n    // Return `a` as percentage of `b`:\n    // 80.asPercentOf(200) == 40\n    function asPercentOf(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(100).div(b);\n    }\n}\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    // counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the a","after":"(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\npragma solidity 0.5.17;\n\nimport \"openzeppelin-solidity/contracts/math/SafeMath.sol\";\n\nlibrary PercentUtils {\n    using SafeMath for uint256;\n\n    // Return `b`% of `a`\n    // 200.percent(40) == 80\n    // Commutative, works both ways\n    function percent(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(b).div(100);\n    }\n\n    // Return `a` as percentage of `b`:\n    // 80.asPercentOf(200) == 40\n    function asPercentOf(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a.mul(100).div(b);\n    }\n}\npragma solidity ^0.5.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n */\ncontract ReentrancyGuard {\n    // counter to allow mutex lock with only one SSTORE operation\n    uint256 private _guardCounter;\n\n    constructor () internal {\n        // The counter starts at one to prevent changing it from zero to a non-zero\n        // value, which is a more expensive operation.\n        _guardCounter = 1;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the a","contract":"Reimbursements","time":0},{"type":"struct-data-arrangement ","before":"\n▓\n  ▓▓▓▓�\n  ▐▓▓▓�\n  ▐▓▓▓▓\n▓▓▀      ▐▓\n▄▄         ▐▓▓\n�▓▓▓▓�\n�▓▓▓▓�\n�▓▓▓▓▓\n▀▀▀▀ \n▓▓▓▓�\n▓▓▓▓▓�\n�▓▓   ▐�\n▓▓▓▓▓▓▓▓▓ ▐�","after":"  ▐▓▓▓▓\n▓▓▀      ▐▓\n▄▄         ▐▓▓\n�▓▓▓▓�\n�▓▓▓▓▓\n▀▀▀▀ \n▓▓▓▓�\n▓▓▓▓▓�\n�▓▓   ▐�\n▓▓▓▓▓▓▓▓▓ ▐�\n▓\n  ▓▓▓▓�\n  ▐▓▓▓�\n�▓▓▓▓�\n","contract":"TokenGrant","time":0},{"type":"external-function ","before":"amount The amount of tokens the grant provides.\n    /// @return withdrawn The amount of tokens that have already been withdrawn\n    ///                   from the grant.\n    /// @return staked The amount of tokens that have been staked from the grant.\n    /// @return revoked A boolean indicating whether the grant has been revoked,\n    ///                 which is to say that it is no longer unlocking.\n    /// @return grantee The grantee of grant.\n    function getGrant(uint256 _id) public view returns (\n        uint256 amount,\n        uint256 withdrawn,\n        uint256 staked,\n        uint256 revokedAmount,\n        uint256 revokedAt,\n        address grantee\n    ) {\n        return (\n        grants[_id].amount,\n        grants[_id].withdrawn,\n        grants[_id].staked,\n        grants[_id].revokedAmount,\n        grants[_id].revokedAt,\n        grants[_id].grantee\n        );\n    }\n\n    /// @notice Gets grant unlocking schedule by grant ID.\n    /// @param _id ID of the token grant.\n    /// @return grantManager The address designated as the manager of the grant,\n    ///                      which is the only address that can revoke this grant.\n    /// @return duration The duration, in seconds, during which the tokens will\n    ///                  unlocking linearly.\n    /// @return start The start time, as a timestamp comparing to `now`.\n    /// @return cliff The timestamp, before which none of the tokens in the grant\n    ///               will be unlocked, and after which a linear amount based on\n    ///               the time elapsed since the start will be unlocked.\n    /// @return policy The address of the grant's staking policy.\n    function getGrantUnlockingSchedule(\n        uint256 _id\n    ) public view re","after":"amount The amount of tokens the grant provides.\n    /// @return withdrawn The amount of tokens that have already been withdrawn\n    ///                   from the grant.\n    /// @return staked The amount of tokens that have been staked from the grant.\n    /// @return revoked A boolean indicating whether the grant has been revoked,\n    ///                 which is to say that it is no longer unlocking.\n    /// @return grantee The grantee of grant.\n    function getGrant(uint256 _id) public view returns (\n        uint256 amount,\n        uint256 withdrawn,\n        uint256 staked,\n        uint256 revokedAmount,\n        uint256 revokedAt,\n        address grantee\n    ) {\n        return (\n        grants[_id].amount,\n        grants[_id].withdrawn,\n        grants[_id].staked,\n        grants[_id].revokedAmount,\n        grants[_id].revokedAt,\n        grants[_id].grantee\n        );\n    }\n\n    /// @notice Gets grant unlocking schedule by grant ID.\n    /// @param _id ID of the token grant.\n    /// @return grantManager The address designated as the manager of the grant,\n    ///                      which is the only address that can revoke this grant.\n    /// @return duration The duration, in seconds, during which the tokens will\n    ///                  unlocking linearly.\n    /// @return start The start time, as a timestamp comparing to `now`.\n    /// @return cliff The timestamp, before which none of the tokens in the grant\n    ///               will be unlocked, and after which a linear amount based on\n    ///               the time elapsed since the start will be unlocked.\n    /// @return policy The address of the grant's staking policy.\n    function getGrantUnlockingSchedule(\n        uint256 _id\n    ) public view re","contract":"TokenGrant","time":0},{"type":"external-function ","before":"ant amount that has already unlocked,\n    /// including any tokens that have already been withdrawn by the grantee as well\n    /// as any tokens that are available to withdraw but have not yet been withdrawn.\n    /// @param _id Grant ID.\n    function unlockedAmount(uint256 _id) public view returns (uint256) {\n        Grant storage grant = grants[_id];\n        return (grant.revokedAt != 0)\n        // Grant revoked -> return what is remaining\n        ? grant.amount.sub(grant.revokedAmount)\n        // Not revoked -> calculate the unlocked amount normally\n        : now.getUnlockedAmount(\n            grant.amount,\n            grant.duration,\n            grant.start,\n            grant.cliff\n        );\n    }\n\n    /// @notice Calculates withdrawable granted amount.\n    /// @dev Calculates the amount that has already unlocked but hasn't been withdrawn yet.\n    /// @param _id Grant ID.\n    function withdrawable(uint256 _id) public view returns (uint256) {\n        uint256 unlocked = unlockedAmount(_id);\n        uint256 withdrawn = grants[_id].withdrawn;\n        uint256 staked = grants[_id].staked;\n\n        if (withdrawn.add(staked) >= unlocked) {\n            return 0;\n        } else {\n            return unlocked.sub(withdrawn).sub(staked);\n        }\n    }\n\n    /// @notice Allows the grant manager to revoke the grant.\n    /// @dev Granted tokens that are already unlocked (releasable amount)\n    /// remain in the grant so grantee can still withdraw them\n    /// the rest are revoke","after":"ant amount that has already unlocked,\n    /// including any tokens that have already been withdrawn by the grantee as well\n    /// as any tokens that are available to withdraw but have not yet been withdrawn.\n    /// @param _id Grant ID.\n    function unlockedAmount(uint256 _id) public view returns (uint256) {\n        Grant storage grant = grants[_id];\n        return (grant.revokedAt != 0)\n        // Grant revoked -> return what is remaining\n        ? grant.amount.sub(grant.revokedAmount)\n        // Not revoked -> calculate the unlocked amount normally\n        : now.getUnlockedAmount(\n            grant.amount,\n            grant.duration,\n            grant.start,\n            grant.cliff\n        );\n    }\n\n    /// @notice Calculates withdrawable granted amount.\n    /// @dev Calculates the amount that has already unlocked but hasn't been withdrawn yet.\n    /// @param _id Grant ID.\n    function withdrawable(uint256 _id) public view returns (uint256) {\n        uint256 unlocked = unlockedAmount(_id);\n        uint256 withdrawn = grants[_id].withdrawn;\n        uint256 staked = grants[_id].staked;\n\n        if (withdrawn.add(staked) >= unlocked) {\n            return 0;\n        } else {\n            return unlocked.sub(withdrawn).sub(staked);\n        }\n    }\n\n    /// @notice Allows the grant manager to revoke the grant.\n    /// @dev Granted tokens that are already unlocked (releasable amount)\n    /// remain in the grant so grantee can still withdraw them\n    /// the rest are revoke","contract":"TokenGrant","time":0},{"type":"external-function ","before":"rator or grantee can cancel the delegation.\"\n        );\n\n        uint256 returned = grantStake.cancelStake();\n        grants[grantId].staked = grants[grantId].staked.sub(returned);\n    }\n\n    /// @notice Undelegate the token grant.\n    /// @param _operator Operator of the stake.\n    function undelegate(address _ope","after":"rator or grantee can cancel the delegation.\"\n        );\n\n        uint256 returned = grantStake.cancelStake();\n        grants[grantId].staked = grants[grantId].staked.sub(returned);\n    }\n\n    /// @notice Undelegate the token grant.\n    /// @param _operator Operator of the stake.\n    function undelegate(address _ope","contract":"TokenGrantStake","time":0},{"type":"immutable-restrict-modification ","before":"malfunctioning stak","after":"malfunctioning stak","contract":"TokenGrantStake","time":0},{"type":"immutable-restrict-modification ","before":"{\n            st","after":"{\n            st","contract":"TokenGrantStake","time":0},{"type":"external-function ","before":"after undelegation period is over.\ncontract TokenStaking is Authorizations, StakeDelegatable {\n    using BytesLib for bytes;\n    using SafeMath for uint256;\n    using PercentUtils for uint256;\n    using SafeERC20 for ERC20Burnable;\n    using GrantStaking for GrantStaking.Storage;\n    using Locks for Locks.Storage;\n    using TopUps for TopUps.Storage;\n\n    event StakeDelegated(\n        address indexed owner,\n        address indexed operator\n    );\n    event OperatorStaked(\n        address indexed operator,\n        address indexed beneficiary,\n        address indexed authorizer,\n        uint256 value\n    );\n    event StakeOwnershipTransferred(\n        address indexed operator,\n        address indexed newOwner\n    );\n    event TopUpInitiated(address indexed operator, uint256 topUp);\n    event TopUpCompleted(address indexed operator, uint256 newAmount);\n    event Undelegated(address indexed operator, uint256 undelegatedAt);\n    event Reco","after":"after undelegation period is over.\ncontract TokenStaking is Authorizations, StakeDelegatable {\n    using BytesLib for bytes;\n    using SafeMath for uint256;\n    using PercentUtils for uint256;\n    using SafeERC20 for ERC20Burnable;\n    using GrantStaking for GrantStaking.Storage;\n    using Locks for Locks.Storage;\n    using TopUps for TopUps.Storage;\n\n    event StakeDelegated(\n        address indexed owner,\n        address indexed operator\n    );\n    event OperatorStaked(\n        address indexed operator,\n        address indexed beneficiary,\n        address indexed authorizer,\n        uint256 value\n    );\n    event StakeOwnershipTransferred(\n        address indexed operator,\n        address indexed newOwner\n    );\n    event TopUpInitiated(address indexed operator, uint256 topUp);\n    event TopUpCompleted(address indexed operator, uint256 newAmount);\n    event Undelegated(address indexed operator, uint256 undelegatedAt);\n    event Reco","contract":"TokenStaking","time":0},{"type":"external-function ","before":"ator here.\n            msg.sender != _operator,\n            \"Operator may not postpone\"\n        );\n        operators[_operator].packedParams = oldParams.setUndelegationTimestamp(\n            _undelegationTimestamp\n        );\n        emit Undelegated(_operator, _undelegationTimestamp);\n    }\n\n    /// @notice Recovers staked tokens and transfers them back to the owner.\n    /// Recovering tokens can only be performed when the operator finished\n    /// undelegating.\n    /// @param _operator Operator address.\n    function recoverStake(address _operator) public {\n        uint256 operatorParams = operators[_operator].packedParams;\n        require(\n            operatorParams.getUndelegationTimestamp() != 0,\n            \"Not undelegated\"\n        );\n        require(\n            _isUndelegatingFinished(operatorParams),\n            \"Still undelegating\"\n        );\n        require(\n            !isStakeLocked(_operator),\n            \"Locked stake\"\n        );\n\n        uint256 amount = operatorParams.getAmount();\n\n        // If there is a pending top-up, force-commit it before returning tokens.\n        amount = amount.add(topUps.cancel(_operator));\n\n        operators[_operator].packedParams = operatorParams.setAmount(0);\n        transferOrDeposit(operators[_operator].owner, _operator, amount);\n\n        emit RecoveredStake(_operator);\n    }\n\n    /// @notice Gets stake delegation info for the given operator.\n    /// @param _operator Operator address.\n    /// @return amou","after":"ator here.\n            msg.sender != _operator,\n            \"Operator may not postpone\"\n        );\n        operators[_operator].packedParams = oldParams.setUndelegationTimestamp(\n            _undelegationTimestamp\n        );\n        emit Undelegated(_operator, _undelegationTimestamp);\n    }\n\n    /// @notice Recovers staked tokens and transfers them back to the owner.\n    /// Recovering tokens can only be performed when the operator finished\n    /// undelegating.\n    /// @param _operator Operator address.\n    function recoverStake(address _operator) public {\n        uint256 operatorParams = operators[_operator].packedParams;\n        require(\n            operatorParams.getUndelegationTimestamp() != 0,\n            \"Not undelegated\"\n        );\n        require(\n            _isUndelegatingFinished(operatorParams),\n            \"Still undelegating\"\n        );\n        require(\n            !isStakeLocked(_operator),\n            \"Locked stake\"\n        );\n\n        uint256 amount = operatorParams.getAmount();\n\n        // If there is a pending top-up, force-commit it before returning tokens.\n        amount = amount.add(topUps.cancel(_operator));\n\n        operators[_operator].packedParams = operatorParams.setAmount(0);\n        transferOrDeposit(operators[_operator].owner, _operator, amount);\n\n        emit RecoveredStake(_operator);\n    }\n\n    /// @notice Gets stake delegation info for the given operator.\n    /// @param _operator Operator address.\n    /// @return amou","contract":"TokenStaking","time":0},{"type":"external-function ","before":" not be recovered until the lock expires or is released,\n    /// even if the normal undelegation period has passed.\n    /// Only previously authorized operator contract can lock the stake.\n    /// @param operator Operator address.\n    /// @param duration Lock duration in seconds.\n    function lockStake(\n        address operator,\n        uint256 duration\n    ) public onlyApprovedOperatorContract(msg.sender) {\n        require(\n            isAuthorizedForOperator(operator, msg.sender),\n            \"Not authorized\"\n        );\n\n        uint256 operatorParams = operators[operator].packedParams;\n\n        require(\n            _isInitialized(operatorParams),\n            \"Inactive stake\"\n        );\n        require(\n            !_isUndelegating(operatorParams),\n            \"Undelegating stake\"\n        );\n\n        locks.lockStake(operator, duration);\n    }\n\n    /// @notice Removes a lock the caller had previously placed on the operator.\n    /// @dev Only for operator contracts.\n    /// To remove expired or disabled locks, use `releaseExpiredLocks`.\n    /// The authorization check ensures that the caller must have been able\n    /// to place a lock on the operator sometime in the past.\n    /// We don't need to check for current approval status of the caller\n    /// because unlocking stake cannot harm the operator\n    /// nor interfere with other operator contracts.\n    /// Therefore even disabled operator contracts may freely unlock stake.\n    /// @param operator Operator address.\n    function unlockStake(\n        address operator\n    ) public {\n        require(\n            isAuthorizedForOperator(operator, msg.sender),\n            \"Not authorized\"\n        );\n        locks.releaseLock(operator);\n    }\n\n    /","after":" not be recovered until the lock expires or is released,\n    /// even if the normal undelegation period has passed.\n    /// Only previously authorized operator contract can lock the stake.\n    /// @param operator Operator address.\n    /// @param duration Lock duration in seconds.\n    function lockStake(\n        address operator,\n        uint256 duration\n    ) public onlyApprovedOperatorContract(msg.sender) {\n        require(\n            isAuthorizedForOperator(operator, msg.sender),\n            \"Not authorized\"\n        );\n\n        uint256 operatorParams = operators[operator].packedParams;\n\n        require(\n            _isInitialized(operatorParams),\n            \"Inactive stake\"\n        );\n        require(\n            !_isUndelegating(operatorParams),\n            \"Undelegating stake\"\n        );\n\n        locks.lockStake(operator, duration);\n    }\n\n    /// @notice Removes a lock the caller had previously placed on the operator.\n    /// @dev Only for operator contracts.\n    /// To remove expired or disabled locks, use `releaseExpiredLocks`.\n    /// The authorization check ensures that the caller must have been able\n    /// to place a lock on the operator sometime in the past.\n    /// We don't need to check for current approval status of the caller\n    /// because unlocking stake cannot harm the operator\n    /// nor interfere with other operator contracts.\n    /// Therefore even disabled operator contracts may freely unlock stake.\n    /// @param operator Operator address.\n    function unlockStake(\n        address operator\n    ) public {\n        require(\n            isAuthorizedForOperator(operator, msg.sender),\n            \"Not authorized\"\n        );\n        locks.releaseLock(operator);\n    }\n\n    /","contract":"TokenStaking","time":0},{"type":"immutable-restrict-modification ","before":"}\n\n    function getStaking","after":"}\n\n    function getStaking","contract":"TokenStaking","time":0},{"type":"immutable-restrict-modification ","before":"act() public view onlyGrant returns ","after":"act() public view onlyGrant returns ","contract":"TokenStaking","time":0},{"type":"external-function ","before":"ndelegatedAt != 0) && (block.timestamp > undelegatedAt.add(undelegationPeriod()));\n    }\n\n    /// @notice Get whether the operator's stake is released\n    /// as far as the operator contract is concerned.\n    /// If the operator contract has a lock on the operator,\n    /// the operator's stake is be released when the lock expires.\n    /// Otherwise the stake is released when the operator finishes undelegating.\n    function _isStakeReleased(\n        address _operator,\n        uint256 _operatorParams,\n        ad","after":"ndelegatedAt != 0) && (block.timestamp > undelegatedAt.add(undelegationPeriod()));\n    }\n\n    /// @notice Get whether the operator's stake is released\n    /// as far as the operator contract is concerned.\n    /// If the operator contract has a lock on the operator,\n    /// the operator's stake is be released when the lock expires.\n    /// Otherwise the stake is released when the operator finishes undelegating.\n    function _isStakeReleased(\n        address _operator,\n        uint256 _operatorParams,\n        ad","contract":"TokenStakingEscrow","time":0},{"type":"external-function ","before":"aked, transfer them straight to the owner.\n            token.safeTransfer(_owner, _amount);\n        }\n    }\n}\n/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄    ","after":"aked, transfer them straight to the owner.\n            token.safeTransfer(_owner, _amount);\n        }\n    }\n}\n/**\n▓▓▌ ▓▓ ▐▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▄\n▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▌▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓    ▓▓▓▓▓▓▓▀    ▐▓▓▓▓▓▓    ▐▓▓▓▓▓   ▓▓▓▓▓▓     ▓▓▓▓▓   ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▄▄▓▓▓▓▓▓▓▀      ▐▓▓▓▓▓▓▄▄▄▄         ▓▓▓▓▓▓▄▄▄▄         ▐▓▓▓▓▓▌   ▐▓▓▓▓▓▓\n  ▓▓▓▓▓▓▓▓▓▓▓▓▓▀        ▐▓▓▓▓▓▓▓▓▓▓         ▓▓▓▓▓▓▓▓▓▓▌        ▐▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓\n  ▓▓▓▓▓▓▀▀▓▓▓▓▓▓▄    ","contract":"TokenStakingEscrow","time":0}]}