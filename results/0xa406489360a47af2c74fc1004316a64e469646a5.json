{"time":115,"results":[{"type":"external-function ","before":"   function mint(bytes32 hash, bytes memory signature, bytes32 nonce, uint256 amount) external payable {\n\n        require(amount != 0, \"INVALID_AMOUNT\");\n\n        require(isSaleOpen(), \"SALE_CLOSED\");\n\n        require(hash.recover(signature) == _signer, \"INVALID_SIGNATURE\");\n\n        require(!_usedNonces[nonce], \"NONCE_USED\");\n\n        require(_hashMatches(hash, msg.sender, nonce, amount), \"INVALID_HASH\");\n\n        require(amount <= MAX_PER_CALL, \"AMOUNT_EXCEEDS_MAX_PER_CALL\");\n\n        require(amount * MINT_PRICE == msg.value, \"WRONG_ETH_AMOUNT\");\n\n\n        uint256 newSupply = totalSupply + amount;\n\n        require(newSupply <= MAX_SUPPLY, \"MAX_SUPPLY_EXCEEDED\");\n\n\n        for (uint256 i = 0; i < amount; i++) {\n\n            _mint(msg.sender, totalSupply + i);\n\n        }\n\n\n        totalSupply = newSupply;\n\n        _usedNonces[nonce] = true;\n\n  ","after":"   function mint(bytes32 hash, bytes calldata signature, bytes32 nonce, uint256 amount) external payable {\n\n        require(amount != 0, \"INVALID_AMOUNT\");\n\n        require(isSaleOpen(), \"SALE_CLOSED\");\n\n        require(hash.recover(signature) == _signer, \"INVALID_SIGNATURE\");\n\n        require(!_usedNonces[nonce], \"NONCE_USED\");\n\n        require(_hashMatches(hash, msg.sender, nonce, amount), \"INVALID_HASH\");\n\n        require(amount <= MAX_PER_CALL, \"AMOUNT_EXCEEDS_MAX_PER_CALL\");\n\n        require(amount * MINT_PRICE == msg.value, \"WRONG_ETH_AMOUNT\");\n\n\n        uint256 newSupply = totalSupply + amount;\n\n        require(newSupply <= MAX_SUPPLY, \"MAX_SUPPLY_EXCEEDED\");\n\n\n        for (uint256 i = 0; i < amount; i++) {\n\n            _mint(msg.sender, totalSupply + i);\n\n        }\n\n\n        totalSupply = newSupply;\n\n        _usedNonces[nonce] = true;\n\n  ","contract":"Surreals","time":0},{"type":"external-function ","before":"   function addToWhitelist(address[] memory toWhitelist) external onlyOwner {\n\n        for (uint256 i = 0; i < toWhitelist.length; i++) {\n\n            isWhitelisted[toWhitelist[i]] = true;\n\n        }\n\n  ","after":"   function addToWhitelist(address[] calldata toWhitelist) external onlyOwner {\n\n        for (uint256 i = 0; i < toWhitelist.length; i++) {\n\n            isWhitelisted[toWhitelist[i]] = true;\n\n        }\n\n  ","contract":"Surreals","time":0},{"type":"external-function ","before":"   function removeFromWhitelist(address[] memory toRemove) external onlyOwner {\n\n        for (uint256 i = 0; i < toRemove.length; i++) {\n\n            isWhitelisted[toRemove[i]] = false;\n\n        }\n\n  ","after":"   function removeFromWhitelist(address[] calldata toRemove) external onlyOwner {\n\n        for (uint256 i = 0; i < toRemove.length; i++) {\n\n            isWhitelisted[toRemove[i]] = false;\n\n        }\n\n  ","contract":"Surreals","time":0},{"type":"external-function ","before":"   function setBaseURI(string memory uri) external onlyOwner {\n\n        _baseUri = uri;\n\n  ","after":"   function setBaseURI(string calldata uri) external onlyOwner {\n\n        _baseUri = uri;\n\n  ","contract":"Surreals","time":0},{"type":"immutable-restrict-modification ","before":"string private _name;","after":"string private immutable _name;","contract":"Surreals","time":0},{"type":"immutable-restrict-modification ","before":"string private _symbol;","after":"string private immutable _symbol;","contract":"Surreals","time":0}]}