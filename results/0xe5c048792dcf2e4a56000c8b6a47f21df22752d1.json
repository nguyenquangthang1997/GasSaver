{"time":165,"results":[{"type":"external-function ","before":"function initialize(\n\n        string memory _name,\n\n        string memory _symbol,\n\n        uint8 _decimals,\n\n        address _owner,\n\n        address _factory,\n\n        address _redeemToken,\n\n        uint256 _activationTimestamp,\n\n        uint256 _redeemTimestamp,\n\n        AddType _type\n\n    ) external override initializer {\n\n        __Ownable_init();\n\n        transferOwnership(_owner);\n\n\n        __ERC20_init(_name, _symbol);\n\n\n        uint256 chainId;\n\n        assembly {\n\n            chainId := chainid()\n\n        }\n\n        domainSeparator = keccak256(\n\n            abi.encode(\n\n                keccak256(\n\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n\n                ),\n\n                keccak256(bytes(_name)),\n\n                keccak256(bytes(\"1\")),\n\n                chainId,\n\n                address(this)\n\n            )\n\n        );\n\n\n        _setupDecimals(_decimals);\n\n        factory = _factory;\n\n        redeemToken = IERC20(_redeemToken);\n\n        addRecipientsType = _type;\n\n        activationTimestamp = _activationTimestamp;\n\n        redeemTimestamp = _redeemTimestamp;\n\n    }","after":"function initialize(\n\n        string calldata _name,\n\n        string calldata _symbol,\n\n        uint8 _decimals,\n\n        address _owner,\n\n        address _factory,\n\n        address _redeemToken,\n\n        uint256 _activationTimestamp,\n\n        uint256 _redeemTimestamp,\n\n        AddType _type\n\n    ) external override initializer {\n\n        __Ownable_init();\n\n        transferOwnership(_owner);\n\n\n        __ERC20_init(_name, _symbol);\n\n\n        uint256 chainId;\n\n        assembly {\n\n            chainId := chainid()\n\n        }\n\n        domainSeparator = keccak256(\n\n            abi.encode(\n\n                keccak256(\n\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n\n                ),\n\n                keccak256(bytes(_name)),\n\n                keccak256(bytes(\"1\")),\n\n                chainId,\n\n                address(this)\n\n            )\n\n        );\n\n\n        _setupDecimals(_decimals);\n\n        factory = _factory;\n\n        redeemToken = IERC20(_redeemToken);\n\n        addRecipientsType = _type;\n\n        activationTimestamp = _activationTimestamp;\n\n        redeemTimestamp = _redeemTimestamp;\n\n    }","contract":"LiquidVestingToken","time":0},{"type":"external-function ","before":"function addRecipients(\n\n        address[] memory _recipients,\n\n        uint256[] memory _amounts\n\n    ) external override onlyOwner inType(AddType.Airdrop) {\n\n        require(\n\n            _recipients.length == _amounts.length,\n\n            \"Recipients should be the same length with amounts\"\n\n        );\n\n        uint256 totalAmount;\n\n\n        for (uint256 i = 0; i < _recipients.length; i++) {\n\n            totalAmount = totalAmount.add(_amounts[i]);\n\n            mintTokens(_recipients[i], _amounts[i]);\n\n        }\n\n        redeemToken.safeTransferFrom(_msgSender(), address(this), totalAmount);\n\n    }","after":"function addRecipients(\n\n        address[] calldata _recipients,\n\n        uint256[] calldata _amounts\n\n    ) external override onlyOwner inType(AddType.Airdrop) {\n\n        require(\n\n            _recipients.length == _amounts.length,\n\n            \"Recipients should be the same length with amounts\"\n\n        );\n\n        uint256 totalAmount;\n\n\n        for (uint256 i = 0; i < _recipients.length; i++) {\n\n            totalAmount = totalAmount.add(_amounts[i]);\n\n            mintTokens(_recipients[i], _amounts[i]);\n\n        }\n\n        redeemToken.safeTransferFrom(_msgSender(), address(this), totalAmount);\n\n    }","contract":"LiquidVestingToken","time":0},{"type":"external-function ","before":"function claimTokensByMerkleProof(\n\n        bytes32[] memory _proof,\n\n        uint256 _rootId,\n\n        address _recipient,\n\n        uint256 _amount\n\n    ) external override inType(AddType.MerkleTree) {\n\n        require(_recipient != address(0), \"Recipient cannot be zero address\");\n\n        require(\n\n            _rootId < merkleRoots.length,\n\n            \"Merkle root with this index does not exists\"\n\n        );\n\n        bytes32 root = merkleRoots[_rootId];\n\n        require(\n\n            merkleRootSpent[root][_recipient] != true,\n\n            \"User can claim tokens only once\"\n\n        );\n\n\n        require(\n\n            checkProof(\n\n                _proof,\n\n                leafFromAddressAndNumTokens(_recipient, _amount),\n\n                root\n\n            ),\n\n            \"Invalid proof\"\n\n        );\n\n\n        mintTokens(_recipient, _amount);\n\n\n        merkleRootSpent[root][_recipient] = true;\n\n\n        if (block.timestamp >= redeemTimestamp) {\n\n            redeem(_recipient, _amount);\n\n        }\n\n    }","after":"function claimTokensByMerkleProof(\n\n        bytes32[] calldata _proof,\n\n        uint256 _rootId,\n\n        address _recipient,\n\n        uint256 _amount\n\n    ) external override inType(AddType.MerkleTree) {\n\n        require(_recipient != address(0), \"Recipient cannot be zero address\");\n\n        require(\n\n            _rootId < merkleRoots.length,\n\n            \"Merkle root with this index does not exists\"\n\n        );\n\n        bytes32 root = merkleRoots[_rootId];\n\n        require(\n\n            merkleRootSpent[root][_recipient] != true,\n\n            \"User can claim tokens only once\"\n\n        );\n\n\n        require(\n\n            checkProof(\n\n                _proof,\n\n                leafFromAddressAndNumTokens(_recipient, _amount),\n\n                root\n\n            ),\n\n            \"Invalid proof\"\n\n        );\n\n\n        mintTokens(_recipient, _amount);\n\n\n        merkleRootSpent[root][_recipient] = true;\n\n\n        if (block.timestamp >= redeemTimestamp) {\n\n            redeem(_recipient, _amount);\n\n        }\n\n    }","contract":"LiquidVestingToken","time":0}]}