{"time":632,"results":[{"type":"state-data-arrangement ","before":"\nbytes4 private constant ERC20_ASSET_PROXY_ID = 0xf47261b0;\nuint256 private constant MAX_UINT256 = uint256(- 1);\nIExchange public immutable exchange;\naddress public immutable erc20Proxy;","after":"uint256 private constant MAX_UINT256 = uint256(- 1);\nIExchange public immutable exchange;\naddress public immutable erc20Proxy;\nbytes4 private constant ERC20_ASSET_PROXY_ID = 0xf47261b0;\n","contract":"FillQuoteTransformer","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public immutable override FEATURE_VERSION = _encodeVersion(1, 0, 0);","after":"uint256 public immutable override constant FEATURE_VERSION = _encodeVersion(1, 0, 0);","contract":"Ownable","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public immutable override FEATURE_VERSION = _encodeVersion(1, 0, 0);","after":"uint256 public immutable override constant FEATURE_VERSION = _encodeVersion(1, 0, 0);","contract":"SimpleFunctionRegistry","time":0},{"type":"external-function ","before":"function deploy(\n        address payable owner,\n        Features memory features,\n        MigrateOpts memory migrateOpts\n    )\n    public\n    returns (ZeroEx zeroEx)\n    {\n        require(msg.sender == deployer, \"FullMigration/INVALID_SENDER\");\n\n        // Perform the initial migration with the owner set to this contract.\n        zeroEx = _initialMigration.deploy(\n            address(uint160(address(this))),\n            InitialMigration.BootstrapFeatures({\n        registry : features.registry,\n        ownable : features.ownable\n        })\n        );\n\n        // Add features.\n        _addFeatures(zeroEx, owner, features, migrateOpts);\n\n        // Transfer ownership to the real owner.\n        IOwnable(address(zeroEx)).transferOwnership(owner);\n\n        // Self-destruct.\n        this.die(owner);\n    }","after":"function deploy(\n        address payable owner,\n        Features calldata features,\n        MigrateOpts calldata migrateOpts\n    )\n    public\n    returns (ZeroEx zeroEx)\n    {\n        require(msg.sender == deployer, \"FullMigration/INVALID_SENDER\");\n\n        // Perform the initial migration with the owner set to this contract.\n        zeroEx = _initialMigration.deploy(\n            address(uint160(address(this))),\n            InitialMigration.BootstrapFeatures({\n        registry : features.registry,\n        ownable : features.ownable\n        })\n        );\n\n        // Add features.\n        _addFeatures(zeroEx, owner, features, migrateOpts);\n\n        // Transfer ownership to the real owner.\n        IOwnable(address(zeroEx)).transferOwnership(owner);\n\n        // Self-destruct.\n        this.die(owner);\n    }","contract":"TestFullMigration","time":0},{"type":"external-function ","before":"function bootstrap(address owner, BootstrapFeatures memory features)\n    public\n    override\n    returns (bytes4 success)\n    {\n        success = InitialMigration.bootstrap(owner, features);\n        // Snoop the bootstrap feature contract.\n        bootstrapFeature = ZeroEx(address(uint160(address(this))))\n        .getFunctionImplementation(IBootstrap.bootstrap.selector);\n    }","after":"function bootstrap(address owner, BootstrapFeatures calldata features)\n    public\n    override\n    returns (bytes4 success)\n    {\n        success = InitialMigration.bootstrap(owner, features);\n        // Snoop the bootstrap feature contract.\n        bootstrapFeature = ZeroEx(address(uint160(address(this))))\n        .getFunctionImplementation(IBootstrap.bootstrap.selector);\n    }","contract":"TestInitialMigration","time":0},{"type":"external-function ","before":"function deploy(address payable owner, BootstrapFeatures memory features)\n    public\n    virtual\n    returns (ZeroEx zeroEx)\n    {\n        // Must be called by the allowed deployer.\n        require(msg.sender == deployer, \"InitialMigration/INVALID_SENDER\");\n\n        // Deploy the ZeroEx contract, setting ourselves as the bootstrapper.\n        zeroEx = new ZeroEx();\n\n        // Bootstrap the initial feature set.\n        IBootstrap(address(zeroEx)).bootstrap(\n            address(this),\n            abi.encodeWithSelector(this.bootstrap.selector, owner, features)\n        );\n\n        // Self-destruct. This contract should not hold any funds but we send\n        // them to the owner just in case.\n        this.die(owner);\n    }","after":"function deploy(address payable owner, BootstrapFeatures calldata features)\n    public\n    virtual\n    returns (ZeroEx zeroEx)\n    {\n        // Must be called by the allowed deployer.\n        require(msg.sender == deployer, \"InitialMigration/INVALID_SENDER\");\n\n        // Deploy the ZeroEx contract, setting ourselves as the bootstrapper.\n        zeroEx = new ZeroEx();\n\n        // Bootstrap the initial feature set.\n        IBootstrap(address(zeroEx)).bootstrap(\n            address(this),\n            abi.encodeWithSelector(this.bootstrap.selector, owner, features)\n        );\n\n        // Self-destruct. This contract should not hold any funds but we send\n        // them to the owner just in case.\n        this.die(owner);\n    }","contract":"TestInitialMigration","time":0},{"type":"external-function ","before":"function bootstrap(address owner, BootstrapFeatures memory features)\n    public\n    virtual\n    returns (bytes4 success)\n    {\n        // Deploy and migrate the initial features.\n        // Order matters here.\n\n        // Initialize Registry.\n        LibBootstrap.delegatecallBootstrapFunction(\n            address(features.registry),\n            abi.encodeWithSelector(\n                SimpleFunctionRegistry.bootstrap.selector\n            )\n        );\n\n        // Initialize Ownable.\n        LibBootstrap.delegatecallBootstrapFunction(\n            address(features.ownable),\n            abi.encodeWithSelector(\n                Ownable.bootstrap.selector\n            )\n        );\n\n        // De-register `SimpleFunctionRegistry._extendSelf`.\n        SimpleFunctionRegistry(address(this)).rollback(\n            SimpleFunctionRegistry._extendSelf.selector,\n            address(0)\n        );\n\n        // Transfer ownership to the real owner.\n        Ownable(address(this)).transferOwnership(owner);\n\n        success = LibBootstrap.BOOTSTRAP_SUCCESS;\n    }","after":"function bootstrap(address owner, BootstrapFeatures calldata features)\n    public\n    virtual\n    returns (bytes4 success)\n    {\n        // Deploy and migrate the initial features.\n        // Order matters here.\n\n        // Initialize Registry.\n        LibBootstrap.delegatecallBootstrapFunction(\n            address(features.registry),\n            abi.encodeWithSelector(\n                SimpleFunctionRegistry.bootstrap.selector\n            )\n        );\n\n        // Initialize Ownable.\n        LibBootstrap.delegatecallBootstrapFunction(\n            address(features.ownable),\n            abi.encodeWithSelector(\n                Ownable.bootstrap.selector\n            )\n        );\n\n        // De-register `SimpleFunctionRegistry._extendSelf`.\n        SimpleFunctionRegistry(address(this)).rollback(\n            SimpleFunctionRegistry._extendSelf.selector,\n            address(0)\n        );\n\n        // Transfer ownership to the real owner.\n        Ownable(address(this)).transferOwnership(owner);\n\n        success = LibBootstrap.BOOTSTRAP_SUCCESS;\n    }","contract":"TestInitialMigration","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public immutable override FEATURE_VERSION = _encodeVersion(1, 0, 0);","after":"uint256 public immutable override constant FEATURE_VERSION = _encodeVersion(1, 0, 0);","contract":"TestTokenSpender","time":0},{"type":"external-function ","before":"function transformERC20(\n        IERC20TokenV06 inputToken,\n        IERC20TokenV06 outputToken,\n        uint256 inputTokenAmount,\n        uint256 minOutputTokenAmount,\n        Transformation[] memory transformations\n    )\n    public\n    override\n    payable\n    returns (uint256 outputTokenAmount)\n    {\n        return _transformERC20Private(\n            keccak256(msg.data),\n            msg.sender,\n            inputToken,\n            outputToken,\n            inputTokenAmount,\n            minOutputTokenAmount,\n            transformations\n        );\n    }","after":"function transformERC20(\n        IERC20TokenV06 inputToken,\n        IERC20TokenV06 outputToken,\n        uint256 inputTokenAmount,\n        uint256 minOutputTokenAmount,\n        Transformation[] calldata transformations\n    )\n    public\n    override\n    payable\n    returns (uint256 outputTokenAmount)\n    {\n        return _transformERC20Private(\n            keccak256(msg.data),\n            msg.sender,\n            inputToken,\n            outputToken,\n            inputTokenAmount,\n            minOutputTokenAmount,\n            transformations\n        );\n    }","contract":"TestTransformERC20","time":0},{"type":"external-function ","before":"function _transformERC20(\n        bytes32 callDataHash,\n        address payable taker,\n        IERC20TokenV06 inputToken,\n        IERC20TokenV06 outputToken,\n        uint256 inputTokenAmount,\n        uint256 minOutputTokenAmount,\n        Transformation[] memory transformations\n    )\n    public\n    override\n    payable\n    onlySelf\n    returns (uint256 outputTokenAmount)\n    {\n        return _transformERC20Private(\n            callDataHash,\n            taker,\n            inputToken,\n            outputToken,\n            inputTokenAmount,\n            minOutputTokenAmount,\n            transformations\n        );\n    }","after":"function _transformERC20(\n        bytes32 callDataHash,\n        address payable taker,\n        IERC20TokenV06 inputToken,\n        IERC20TokenV06 outputToken,\n        uint256 inputTokenAmount,\n        uint256 minOutputTokenAmount,\n        Transformation[] calldata transformations\n    )\n    public\n    override\n    payable\n    onlySelf\n    returns (uint256 outputTokenAmount)\n    {\n        return _transformERC20Private(\n            callDataHash,\n            taker,\n            inputToken,\n            outputToken,\n            inputTokenAmount,\n            minOutputTokenAmount,\n            transformations\n        );\n    }","contract":"TestTransformERC20","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public immutable override FEATURE_VERSION = _encodeVersion(1, 0, 0);","after":"uint256 public immutable override constant FEATURE_VERSION = _encodeVersion(1, 0, 0);","contract":"TestTransformERC20","time":0},{"type":"de-morgan-condition ","before":"!didSucceed || !LibERC20TokenV06.isSuccessfulResult(resultData)","after":"!(didSucceed || LibERC20TokenV06.isSuccessfulResult(resultData))","loc":{"start":{"line":6466,"column":12},"end":{"line":6466,"column":74}},"contract":"TokenSpender","time":0},{"type":"external-function ","before":"function deploy(bytes memory bytecode)\n    public\n    payable\n    onlyAuthorized\n    returns (address deployedAddress)\n    {\n        uint256 deploymentNonce = nonce;\n        nonce += 1;\n        assembly {\n            deployedAddress := create(callvalue(), add(bytecode, 32), mload(bytecode))\n        }\n        toDeploymentNonce[deployedAddress] = deploymentNonce;\n        emit Deployed(deployedAddress, deploymentNonce, msg.sender);\n    }","after":"function deploy(bytes calldata bytecode)\n    public\n    payable\n    onlyAuthorized\n    returns (address deployedAddress)\n    {\n        uint256 deploymentNonce = nonce;\n        nonce += 1;\n        assembly {\n            deployedAddress := create(callvalue(), add(bytecode, 32), mload(bytecode))\n        }\n        toDeploymentNonce[deployedAddress] = deploymentNonce;\n        emit Deployed(deployedAddress, deploymentNonce, msg.sender);\n    }","contract":"TransformerDeployer","time":0}]}