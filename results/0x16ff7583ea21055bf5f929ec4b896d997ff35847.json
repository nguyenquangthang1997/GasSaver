{"time":195,"results":[{"type":"external-function ","before":"function create(\n        IExecutorWithTimelock executor,\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        bool[] memory withDelegatecalls,\n        bytes32 ipfsHash\n    ) external override returns (uint256) {\n        require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\n        require(\n            targets.length == values.length &&\n            targets.length == signatures.length &&\n            targets.length == calldatas.length &&\n            targets.length == withDelegatecalls.length,\n            'INCONSISTENT_PARAMS_LENGTH'\n        );\n\n        require(isExecutorAuthorized(address(executor)), 'EXECUTOR_NOT_AUTHORIZED');\n\n        require(\n            IProposalValidator(address(executor)).validateCreatorOfProposal(\n                this,\n                msg.sender,\n                block.number - 1\n            ),\n            'PROPOSITION_CREATION_INVALID'\n        );\n\n        CreateVars memory vars;\n\n        vars.startBlock = block.number.add(_votingDelay);\n        vars.endBlock = vars.startBlock.add(IProposalValidator(address(executor)).VOTING_DURATION());\n\n        vars.previousProposalsCount = _proposalsCount;\n\n        Proposal storage newProposal = _proposals[vars.previousProposalsCount];\n        newProposal.id = vars.previousProposalsCount;\n        newProposal.creator = msg.sender;\n        newProposal.executor = executor;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.withDelegatecalls = withDelegatecalls;\n        newProposal.startBlock = vars.startBlock;\n        newProposal.endBlock = vars.endBlock;\n        newProposal.strategy = _governanceStrategy;\n        newProposal.ipfsHash = ipfsHash;\n        _proposalsCount++;\n\n        emit ProposalCreated(\n            vars.previousProposalsCount,\n            msg.sender,\n            executor,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            withDelegatecalls,\n            vars.startBlock,\n            vars.endBlock,\n            _governanceStrategy,\n            ipfsHash\n        );\n\n        return newProposal.id;\n    }","after":"function create(\n        IExecutorWithTimelock executor,\n        address[] calldata targets,\n        uint256[] calldata values,\n        string[] calldata signatures,\n        bytes[] calldata calldatas,\n        bool[] calldata withDelegatecalls,\n        bytes32 ipfsHash\n    ) external override returns (uint256) {\n        require(targets.length != 0, 'INVALID_EMPTY_TARGETS');\n        require(\n            targets.length == values.length &&\n            targets.length == signatures.length &&\n            targets.length == calldatas.length &&\n            targets.length == withDelegatecalls.length,\n            'INCONSISTENT_PARAMS_LENGTH'\n        );\n\n        require(isExecutorAuthorized(address(executor)), 'EXECUTOR_NOT_AUTHORIZED');\n\n        require(\n            IProposalValidator(address(executor)).validateCreatorOfProposal(\n                this,\n                msg.sender,\n                block.number - 1\n            ),\n            'PROPOSITION_CREATION_INVALID'\n        );\n\n        CreateVars memory vars;\n\n        vars.startBlock = block.number.add(_votingDelay);\n        vars.endBlock = vars.startBlock.add(IProposalValidator(address(executor)).VOTING_DURATION());\n\n        vars.previousProposalsCount = _proposalsCount;\n\n        Proposal storage newProposal = _proposals[vars.previousProposalsCount];\n        newProposal.id = vars.previousProposalsCount;\n        newProposal.creator = msg.sender;\n        newProposal.executor = executor;\n        newProposal.targets = targets;\n        newProposal.values = values;\n        newProposal.signatures = signatures;\n        newProposal.calldatas = calldatas;\n        newProposal.withDelegatecalls = withDelegatecalls;\n        newProposal.startBlock = vars.startBlock;\n        newProposal.endBlock = vars.endBlock;\n        newProposal.strategy = _governanceStrategy;\n        newProposal.ipfsHash = ipfsHash;\n        _proposalsCount++;\n\n        emit ProposalCreated(\n            vars.previousProposalsCount,\n            msg.sender,\n            executor,\n            targets,\n            values,\n            signatures,\n            calldatas,\n            withDelegatecalls,\n            vars.startBlock,\n            vars.endBlock,\n            _governanceStrategy,\n            ipfsHash\n        );\n\n        return newProposal.id;\n    }","contract":"AaveGovernanceV2","time":0},{"type":"external-function ","before":"function unauthorizeExecutors(address[] memory executors) public override onlyOwner {\n        for (uint256 i = 0; i < executors.length; i++) {\n            _unauthorizeExecutor(executors[i]);\n        }\n    }","after":"function unauthorizeExecutors(address[] calldata executors) public override onlyOwner {\n        for (uint256 i = 0; i < executors.length; i++) {\n            _unauthorizeExecutor(executors[i]);\n        }\n    }","contract":"AaveGovernanceV2","time":0},{"type":"external-function ","before":"function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 executionTime,\n        bool withDelegatecall\n    ) public override onlyAdmin returns (bytes32) {\n        require(executionTime >= block.timestamp.add(_delay), 'EXECUTION_TIME_UNDERESTIMATED');\n\n        bytes32 actionHash = keccak256(\n            abi.encode(target, value, signature, data, executionTime, withDelegatecall)\n        );\n        _queuedTransactions[actionHash] = true;\n\n        emit QueuedAction(actionHash, target, value, signature, data, executionTime, withDelegatecall);\n        return actionHash;\n    }","after":"function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 executionTime,\n        bool withDelegatecall\n    ) public override onlyAdmin returns (bytes32) {\n        require(executionTime >= block.timestamp.add(_delay), 'EXECUTION_TIME_UNDERESTIMATED');\n\n        bytes32 actionHash = keccak256(\n            abi.encode(target, value, signature, data, executionTime, withDelegatecall)\n        );\n        _queuedTransactions[actionHash] = true;\n\n        emit QueuedAction(actionHash, target, value, signature, data, executionTime, withDelegatecall);\n        return actionHash;\n    }","contract":"Executor","time":0},{"type":"external-function ","before":"function cancelTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 executionTime,\n        bool withDelegatecall\n    ) public override onlyAdmin returns (bytes32) {\n        bytes32 actionHash = keccak256(\n            abi.encode(target, value, signature, data, executionTime, withDelegatecall)\n        );\n        _queuedTransactions[actionHash] = false;\n\n        emit CancelledAction(\n            actionHash,\n            target,\n            value,\n            signature,\n            data,\n            executionTime,\n            withDelegatecall\n        );\n        return actionHash;\n    }","after":"function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 executionTime,\n        bool withDelegatecall\n    ) public override onlyAdmin returns (bytes32) {\n        bytes32 actionHash = keccak256(\n            abi.encode(target, value, signature, data, executionTime, withDelegatecall)\n        );\n        _queuedTransactions[actionHash] = false;\n\n        emit CancelledAction(\n            actionHash,\n            target,\n            value,\n            signature,\n            data,\n            executionTime,\n            withDelegatecall\n        );\n        return actionHash;\n    }","contract":"Executor","time":0},{"type":"external-function ","before":"function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 executionTime,\n        bool withDelegatecall\n    ) public payable override onlyAdmin returns (bytes memory) {\n        bytes32 actionHash = keccak256(\n            abi.encode(target, value, signature, data, executionTime, withDelegatecall)\n        );\n        require(_queuedTransactions[actionHash], 'ACTION_NOT_QUEUED');\n        require(block.timestamp >= executionTime, 'TIMELOCK_NOT_FINISHED');\n        require(block.timestamp <= executionTime.add(GRACE_PERIOD), 'GRACE_PERIOD_FINISHED');\n\n        _queuedTransactions[actionHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        bool success;\n        bytes memory resultData;\n        if (withDelegatecall) {\n            require(msg.value >= value, \"NOT_ENOUGH_MSG_VALUE\");\n            // solium-disable-next-line security/no-call-value\n            (success, resultData) = target.delegatecall(callData);\n        } else {\n            // solium-disable-next-line security/no-call-value\n            (success, resultData) = target.call{value : value}(callData);\n        }\n\n        require(success, 'FAILED_ACTION_EXECUTION');\n\n        emit ExecutedAction(\n            actionHash,\n            target,\n            value,\n            signature,\n            data,\n            executionTime,\n            withDelegatecall,\n            resultData\n        );\n\n        return resultData;\n    }","after":"function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 executionTime,\n        bool withDelegatecall\n    ) public payable override onlyAdmin returns (bytes memory) {\n        bytes32 actionHash = keccak256(\n            abi.encode(target, value, signature, data, executionTime, withDelegatecall)\n        );\n        require(_queuedTransactions[actionHash], 'ACTION_NOT_QUEUED');\n        require(block.timestamp >= executionTime, 'TIMELOCK_NOT_FINISHED');\n        require(block.timestamp <= executionTime.add(GRACE_PERIOD), 'GRACE_PERIOD_FINISHED');\n\n        _queuedTransactions[actionHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        bool success;\n        bytes memory resultData;\n        if (withDelegatecall) {\n            require(msg.value >= value, \"NOT_ENOUGH_MSG_VALUE\");\n            // solium-disable-next-line security/no-call-value\n            (success, resultData) = target.delegatecall(callData);\n        } else {\n            // solium-disable-next-line security/no-call-value\n            (success, resultData) = target.call{value : value}(callData);\n        }\n\n        require(success, 'FAILED_ACTION_EXECUTION');\n\n        emit ExecutedAction(\n            actionHash,\n            target,\n            value,\n            signature,\n            data,\n            executionTime,\n            withDelegatecall,\n            resultData\n        );\n\n        return resultData;\n    }","contract":"Executor","time":0},{"type":"external-function ","before":"function flashProposal(uint256 proposalPower, IExecutorWithTimelock executor,\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        bool[] memory withDelegatecalls,\n        bytes32 ipfsHash) external {\n        TOKEN.transferFrom(MINTER, address(this), proposalPower);\n        GOV.create(executor, targets, values, signatures, calldatas, withDelegatecalls, ipfsHash);\n        TOKEN.transfer(MINTER, proposalPower);\n    }","after":"function flashProposal(uint256 proposalPower, IExecutorWithTimelock executor,\n        address[] calldata targets,\n        uint256[] calldata values,\n        string[] calldata signatures,\n        bytes[] calldata calldatas,\n        bool[] calldata withDelegatecalls,\n        bytes32 ipfsHash) external {\n        TOKEN.transferFrom(MINTER, address(this), proposalPower);\n        GOV.create(executor, targets, values, signatures, calldatas, withDelegatecalls, ipfsHash);\n        TOKEN.transfer(MINTER, proposalPower);\n    }","contract":"FlashAttacks","time":0},{"type":"external-function ","before":"function getTokensPower(address user, address[] memory tokens)\n    external\n    view\n    override\n    returns (Power[] memory power)\n    {\n        power = new Power[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IGovernancePowerDelegationToken delegation = IGovernancePowerDelegationToken(tokens[i]);\n            uint256 currentVotingPower = delegation.getPowerCurrent(user, IGovernancePowerDelegationToken.DelegationType.VOTING_POWER);\n            uint256 currentPropositionPower = delegation.getPowerCurrent(user, IGovernancePowerDelegationToken.DelegationType.PROPOSITION_POWER);\n            address delegatedAddressVotingPower = delegation.getDelegateeByType(user, IGovernancePowerDelegationToken.DelegationType.VOTING_POWER);\n            address delegatedAddressPropositionPower = delegation.getDelegateeByType(user, IGovernancePowerDelegationToken.DelegationType.PROPOSITION_POWER);\n\n            power[i] = Power(\n                currentVotingPower,\n                delegatedAddressVotingPower,\n                currentPropositionPower,\n                delegatedAddressPropositionPower\n            );\n\n        }\n\n        return power;\n    }","after":"function getTokensPower(address user, address[] calldata tokens)\n    external\n    view\n    override\n    returns (Power[] memory power)\n    {\n        power = new Power[](tokens.length);\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IGovernancePowerDelegationToken delegation = IGovernancePowerDelegationToken(tokens[i]);\n            uint256 currentVotingPower = delegation.getPowerCurrent(user, IGovernancePowerDelegationToken.DelegationType.VOTING_POWER);\n            uint256 currentPropositionPower = delegation.getPowerCurrent(user, IGovernancePowerDelegationToken.DelegationType.PROPOSITION_POWER);\n            address delegatedAddressVotingPower = delegation.getDelegateeByType(user, IGovernancePowerDelegationToken.DelegationType.VOTING_POWER);\n            address delegatedAddressPropositionPower = delegation.getDelegateeByType(user, IGovernancePowerDelegationToken.DelegationType.PROPOSITION_POWER);\n\n            power[i] = Power(\n                currentVotingPower,\n                delegatedAddressVotingPower,\n                currentPropositionPower,\n                delegatedAddressPropositionPower\n            );\n\n        }\n\n        return power;\n    }","contract":"GovernanceV2Helper","time":0}]}