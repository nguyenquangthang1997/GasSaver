{"time":148,"results":[{"type":"external-function ","before":"function setProvenanceHash(string memory _provenanceHash) public onlyOwner {\n        PROVENANCE = _provenanceHash;\n    }","after":"function setProvenanceHash(string calldata _provenanceHash) public onlyOwner {\n        PROVENANCE = _provenanceHash;\n    }","contract":"TenaciousTigers","time":0},{"type":"external-function ","before":"function claimPresale(\n        bytes32[] memory proof,\n        uint256 _amountToMint\n    ) public payable {\n\n        require( block.timestamp >= presaleStartTime,                               \"Presale window is not opened\" );\n        require( block.timestamp < presaleStartTime + 1 days,                       \"Presale window is closed\" );\n        require( totalSupply() + _amountToMint - reserveSent < maxPublicSupply,     \"Exceeds supply\" );\n        require( msg.value >= mintCost.mul(_amountToMint),                          \"Insufficient Ether\" );\n        require( presaleLimit[msg.sender] + _amountToMint <= MAX_PURCHASEABLE,                     \"Maximum 20 Tigers per Address for presale\");\n\n        // Verify that address belongs in MerkleTree\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        bool merkleProof = MerkleProof.verify(proof, merkleRoot, leaf);\n        require(merkleProof, 'Account ineligible');\n        \n        // Verify that amount is 20 or less\n        require(_amountToMint <= MAX_PURCHASEABLE, \"Max 20\");\n        for(uint256 i; i < _amountToMint; i++) {\n            uint256 supply = totalSupply();\n            _safeMint( msg.sender, supply );\n        }\n        presaleLimit[msg.sender] = presaleLimit[msg.sender] + _amountToMint;\n    }","after":"function claimPresale(\n        bytes32[] calldata proof,\n        uint256 _amountToMint\n    ) public payable {\n\n        require( block.timestamp >= presaleStartTime,                               \"Presale window is not opened\" );\n        require( block.timestamp < presaleStartTime + 1 days,                       \"Presale window is closed\" );\n        require( totalSupply() + _amountToMint - reserveSent < maxPublicSupply,     \"Exceeds supply\" );\n        require( msg.value >= mintCost.mul(_amountToMint),                          \"Insufficient Ether\" );\n        require( presaleLimit[msg.sender] + _amountToMint <= MAX_PURCHASEABLE,                     \"Maximum 20 Tigers per Address for presale\");\n\n        // Verify that address belongs in MerkleTree\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        bool merkleProof = MerkleProof.verify(proof, merkleRoot, leaf);\n        require(merkleProof, 'Account ineligible');\n        \n        // Verify that amount is 20 or less\n        require(_amountToMint <= MAX_PURCHASEABLE, \"Max 20\");\n        for(uint256 i; i < _amountToMint; i++) {\n            uint256 supply = totalSupply();\n            _safeMint( msg.sender, supply );\n        }\n        presaleLimit[msg.sender] = presaleLimit[msg.sender] + _amountToMint;\n    }","contract":"TenaciousTigers","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public mintCost = 0.06 ether;","after":"uint256 public constant mintCost = 0.06 ether;","contract":"TenaciousTigers","time":0},{"type":"constant-restrict-modification  ","before":"uint256 private maxPublicSupply = 10000;","after":"uint256 private constant maxPublicSupply = 10000;","contract":"TenaciousTigers","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public MAX_PURCHASEABLE = 20;","after":"uint256 public constant MAX_PURCHASEABLE = 20;","contract":"TenaciousTigers","time":0}]}