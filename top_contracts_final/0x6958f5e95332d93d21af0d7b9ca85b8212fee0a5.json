{"time":438,"results":[{"type":"external-function ","before":"function marketSellOrdersWithEth(\n        LibOrder.Order[] memory orders,\n        bytes[] memory signatures,\n        uint256[] memory ethFeeAmounts,\n        address payable[] memory feeRecipients\n    )\n        public\n        payable\n        returns (\n            uint256 wethSpentAmount,\n            uint256 makerAssetAcquiredAmount\n        )\n    {\n        // Pay ETH affiliate fees to all feeRecipient addresses\n        uint256 wethRemaining = _transferEthFeesAndWrapRemaining(\n            ethFeeAmounts,\n            feeRecipients\n        );\n        // Spends up to wethRemaining to fill orders, transfers purchased assets to msg.sender,\n        // and pays WETH order fees.\n        (\n            wethSpentAmount,\n            makerAssetAcquiredAmount\n        ) = _marketSellNoThrow(\n            orders,\n            wethRemaining,\n            signatures\n        );\n\n        // Ensure that no extra WETH owned by this contract has been spent.\n        if (wethSpentAmount > wethRemaining) {\n            LibRichErrors.rrevert(LibForwarderRichErrors.OverspentWethError(\n                wethSpentAmount,\n                msg.value\n            ));\n        }\n\n        // Calculate amount of WETH that hasn't been spent.\n        wethRemaining = wethRemaining.safeSub(wethSpentAmount);\n\n        // Refund remaining ETH to msg.sender.\n        _unwrapAndTransferEth(wethRemaining);\n    }","after":"function marketSellOrdersWithEth(\n        LibOrder.Order[] calldata orders,\n        bytes[] calldata signatures,\n        uint256[] calldata ethFeeAmounts,\n        address payable[] calldata feeRecipients\n    )\n        public\n        payable\n        returns (\n            uint256 wethSpentAmount,\n            uint256 makerAssetAcquiredAmount\n        )\n    {\n        // Pay ETH affiliate fees to all feeRecipient addresses\n        uint256 wethRemaining = _transferEthFeesAndWrapRemaining(\n            ethFeeAmounts,\n            feeRecipients\n        );\n        // Spends up to wethRemaining to fill orders, transfers purchased assets to msg.sender,\n        // and pays WETH order fees.\n        (\n            wethSpentAmount,\n            makerAssetAcquiredAmount\n        ) = _marketSellNoThrow(\n            orders,\n            wethRemaining,\n            signatures\n        );\n\n        // Ensure that no extra WETH owned by this contract has been spent.\n        if (wethSpentAmount > wethRemaining) {\n            LibRichErrors.rrevert(LibForwarderRichErrors.OverspentWethError(\n                wethSpentAmount,\n                msg.value\n            ));\n        }\n\n        // Calculate amount of WETH that hasn't been spent.\n        wethRemaining = wethRemaining.safeSub(wethSpentAmount);\n\n        // Refund remaining ETH to msg.sender.\n        _unwrapAndTransferEth(wethRemaining);\n    }","contract":"Forwarder","time":0},{"type":"external-function ","before":"function marketSellAmountWithEth(\n        LibOrder.Order[] memory orders,\n        uint256 ethSellAmount,\n        bytes[] memory signatures,\n        uint256[] memory ethFeeAmounts,\n        address payable[] memory feeRecipients\n    )\n        public\n        payable\n        returns (\n            uint256 wethSpentAmount,\n            uint256 makerAssetAcquiredAmount\n        )\n    {\n        if (ethSellAmount > msg.value) {\n            LibRichErrors.rrevert(LibForwarderRichErrors.CompleteSellFailedError(\n                ethSellAmount,\n                msg.value\n            ));\n        }\n        // Pay ETH affiliate fees to all feeRecipient addresses\n        uint256 wethRemaining = _transferEthFeesAndWrapRemaining(\n            ethFeeAmounts,\n            feeRecipients\n        );\n        // Need enough remaining to ensure we can sell ethSellAmount\n        if (wethRemaining < ethSellAmount) {\n            LibRichErrors.rrevert(LibForwarderRichErrors.OverspentWethError(\n                wethRemaining,\n                ethSellAmount\n            ));\n        }\n        // Spends up to ethSellAmount to fill orders, transfers purchased assets to msg.sender,\n        // and pays WETH order fees.\n        (\n            wethSpentAmount,\n            makerAssetAcquiredAmount\n        ) = _marketSellExactAmountNoThrow(\n            orders,\n            ethSellAmount,\n            signatures\n        );\n        // Ensure we sold the specified amount (note: wethSpentAmount includes fees)\n        if (wethSpentAmount < ethSellAmount) {\n            LibRichErrors.rrevert(LibForwarderRichErrors.CompleteSellFailedError(\n                ethSellAmount,\n                wethSpentAmount\n            ));\n        }\n\n        // Calculate amount of WETH that hasn't been spent.\n        wethRemaining = wethRemaining.safeSub(wethSpentAmount);\n\n        // Refund remaining ETH to msg.sender.\n        _unwrapAndTransferEth(wethRemaining);\n    }","after":"function marketSellAmountWithEth(\n        LibOrder.Order[] calldata orders,\n        uint256 ethSellAmount,\n        bytes[] calldata signatures,\n        uint256[] calldata ethFeeAmounts,\n        address payable[] calldata feeRecipients\n    )\n        public\n        payable\n        returns (\n            uint256 wethSpentAmount,\n            uint256 makerAssetAcquiredAmount\n        )\n    {\n        if (ethSellAmount > msg.value) {\n            LibRichErrors.rrevert(LibForwarderRichErrors.CompleteSellFailedError(\n                ethSellAmount,\n                msg.value\n            ));\n        }\n        // Pay ETH affiliate fees to all feeRecipient addresses\n        uint256 wethRemaining = _transferEthFeesAndWrapRemaining(\n            ethFeeAmounts,\n            feeRecipients\n        );\n        // Need enough remaining to ensure we can sell ethSellAmount\n        if (wethRemaining < ethSellAmount) {\n            LibRichErrors.rrevert(LibForwarderRichErrors.OverspentWethError(\n                wethRemaining,\n                ethSellAmount\n            ));\n        }\n        // Spends up to ethSellAmount to fill orders, transfers purchased assets to msg.sender,\n        // and pays WETH order fees.\n        (\n            wethSpentAmount,\n            makerAssetAcquiredAmount\n        ) = _marketSellExactAmountNoThrow(\n            orders,\n            ethSellAmount,\n            signatures\n        );\n        // Ensure we sold the specified amount (note: wethSpentAmount includes fees)\n        if (wethSpentAmount < ethSellAmount) {\n            LibRichErrors.rrevert(LibForwarderRichErrors.CompleteSellFailedError(\n                ethSellAmount,\n                wethSpentAmount\n            ));\n        }\n\n        // Calculate amount of WETH that hasn't been spent.\n        wethRemaining = wethRemaining.safeSub(wethSpentAmount);\n\n        // Refund remaining ETH to msg.sender.\n        _unwrapAndTransferEth(wethRemaining);\n    }","contract":"Forwarder","time":0},{"type":"external-function ","before":"function marketBuyOrdersWithEth(\n        LibOrder.Order[] memory orders,\n        uint256 makerAssetBuyAmount,\n        bytes[] memory signatures,\n        uint256[] memory ethFeeAmounts,\n        address payable[] memory feeRecipients\n    )\n        public\n        payable\n        returns (\n            uint256 wethSpentAmount,\n            uint256 makerAssetAcquiredAmount\n        )\n    {\n        // Pay ETH affiliate fees to all feeRecipient addresses\n        uint256 wethRemaining = _transferEthFeesAndWrapRemaining(\n            ethFeeAmounts,\n            feeRecipients\n        );\n\n        // Attempts to fill the desired amount of makerAsset and trasnfer purchased assets to msg.sender.\n        (\n            wethSpentAmount,\n            makerAssetAcquiredAmount\n        ) = _marketBuyFillOrKill(\n            orders,\n            makerAssetBuyAmount,\n            signatures\n        );\n\n        // Ensure that no extra WETH owned by this contract has been spent.\n        if (wethSpentAmount > wethRemaining) {\n            LibRichErrors.rrevert(LibForwarderRichErrors.OverspentWethError(\n                wethSpentAmount,\n                msg.value\n            ));\n        }\n\n        // Calculate amount of WETH that hasn't been spent.\n        wethRemaining = wethRemaining.safeSub(wethSpentAmount);\n\n        // Refund remaining ETH to msg.sender.\n        _unwrapAndTransferEth(wethRemaining);\n    }","after":"function marketBuyOrdersWithEth(\n        LibOrder.Order[] calldata orders,\n        uint256 makerAssetBuyAmount,\n        bytes[] calldata signatures,\n        uint256[] calldata ethFeeAmounts,\n        address payable[] calldata feeRecipients\n    )\n        public\n        payable\n        returns (\n            uint256 wethSpentAmount,\n            uint256 makerAssetAcquiredAmount\n        )\n    {\n        // Pay ETH affiliate fees to all feeRecipient addresses\n        uint256 wethRemaining = _transferEthFeesAndWrapRemaining(\n            ethFeeAmounts,\n            feeRecipients\n        );\n\n        // Attempts to fill the desired amount of makerAsset and trasnfer purchased assets to msg.sender.\n        (\n            wethSpentAmount,\n            makerAssetAcquiredAmount\n        ) = _marketBuyFillOrKill(\n            orders,\n            makerAssetBuyAmount,\n            signatures\n        );\n\n        // Ensure that no extra WETH owned by this contract has been spent.\n        if (wethSpentAmount > wethRemaining) {\n            LibRichErrors.rrevert(LibForwarderRichErrors.OverspentWethError(\n                wethSpentAmount,\n                msg.value\n            ));\n        }\n\n        // Calculate amount of WETH that hasn't been spent.\n        wethRemaining = wethRemaining.safeSub(wethSpentAmount);\n\n        // Refund remaining ETH to msg.sender.\n        _unwrapAndTransferEth(wethRemaining);\n    }","contract":"Forwarder","time":0}]}