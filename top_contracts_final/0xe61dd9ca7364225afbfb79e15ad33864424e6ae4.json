{"time":178,"results":[{"type":"immutable-restrict-modification ","before":"address private caller;","after":"address private immutable caller;","contract":"BridgeStorage","time":1},{"type":"constant-restrict-modification  ","before":"uint256 MaxItemAddressNum = 255;","after":"uint256 constant MaxItemAddressNum = 255;","contract":"BridgeStorage","time":1},{"type":"immutable-restrict-modification ","before":"address private caller;","after":"address private immutable caller;","contract":"BridgeLogic","time":0},{"type":"external-function ","before":"function depositNative(string memory _targetAddress, string memory chain) public payable {\n        require(msg.value >= swapFee, \"Bridge:insufficient swap fee\");\n        if (swapFee != 0) {\n            payable(feeTo).transfer(swapFee);\n        }\n        emit DepositNative(msg.sender, msg.value - swapFee, _targetAddress, chain, swapFee);\n    }","after":"function depositNative(string calldata _targetAddress, string calldata chain) public payable {\n        require(msg.value >= swapFee, \"Bridge:insufficient swap fee\");\n        if (swapFee != 0) {\n            payable(feeTo).transfer(swapFee);\n        }\n        emit DepositNative(msg.sender, msg.value - swapFee, _targetAddress, chain, swapFee);\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function depositToken(address _token, uint value, string memory _targetAddress, string memory chain) public payable returns (bool) {\n        require(msg.value == swapFee, \"Bridge:swap fee not equal\");\n        if (swapFee != 0) {\n            payable(feeTo).transfer(swapFee);\n        }\n\n        bool res = depositTokenLogic(_token, msg.sender, value);\n        emit DepositToken(msg.sender, value, _token, _targetAddress, chain, swapFee);\n        return res;\n    }","after":"function depositToken(address _token, uint value, string calldata _targetAddress, string calldata chain) public payable returns (bool) {\n        require(msg.value == swapFee, \"Bridge:swap fee not equal\");\n        if (swapFee != 0) {\n            payable(feeTo).transfer(swapFee);\n        }\n\n        bool res = depositTokenLogic(_token, msg.sender, value);\n        emit DepositToken(msg.sender, value, _token, _targetAddress, chain, swapFee);\n        return res;\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function withdrawNative(address payable to, uint value, string memory proof, bytes32 taskHash) public\n    onlyOperator\n    whenNotPaused\n    positiveValue(value)\n    returns (bool)\n    {\n        require(address(this).balance >= value, \"Bridge:not enough native token\");\n        require(taskHash == keccak256((abi.encodePacked(to, value, proof))), \"Bridge:taskHash is wrong\");\n        require(!filledTx[taskHash], \"Bridge:tx filled already\");\n        uint256 status = logic.supportTask(logic.WITHDRAWTASK(), taskHash, msg.sender, operatorRequireNum);\n\n        if (status == logic.TASKPROCESSING()) {\n            emit WithdrawingNative(to, value, proof);\n        } else if (status == logic.TASKDONE()) {\n            emit WithdrawingNative(to, value, proof);\n            emit WithdrawDoneNative(to, value, proof);\n            to.transfer(value);\n            filledTx[taskHash] = true;\n            logic.removeTask(taskHash);\n        }\n        return true;\n    }","after":"function withdrawNative(address payable to, uint value, string calldata proof, bytes32 taskHash) public\n    onlyOperator\n    whenNotPaused\n    positiveValue(value)\n    returns (bool)\n    {\n        require(address(this).balance >= value, \"Bridge:not enough native token\");\n        require(taskHash == keccak256((abi.encodePacked(to, value, proof))), \"Bridge:taskHash is wrong\");\n        require(!filledTx[taskHash], \"Bridge:tx filled already\");\n        uint256 status = logic.supportTask(logic.WITHDRAWTASK(), taskHash, msg.sender, operatorRequireNum);\n\n        if (status == logic.TASKPROCESSING()) {\n            emit WithdrawingNative(to, value, proof);\n        } else if (status == logic.TASKDONE()) {\n            emit WithdrawingNative(to, value, proof);\n            emit WithdrawDoneNative(to, value, proof);\n            to.transfer(value);\n            filledTx[taskHash] = true;\n            logic.removeTask(taskHash);\n        }\n        return true;\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function withdrawToken(address _token, address to, uint value, string memory proof, bytes32 taskHash) public\n    onlyOperator\n    whenNotPaused\n    positiveValue(value)\n    returns (bool)\n    {\n        require(taskHash == keccak256((abi.encodePacked(to, value, proof))), \"Bridge:taskHash is wrong\");\n        require(!filledTx[taskHash], \"Bridge:tx filled already\");\n        uint256 status = logic.supportTask(logic.WITHDRAWTASK(), taskHash, msg.sender, operatorRequireNum);\n\n        if (status == logic.TASKPROCESSING()) {\n            emit WithdrawingToken(to, _token, value, proof);\n        } else if (status == logic.TASKDONE()) {\n            bool res = withdrawTokenLogic(_token, to, value);\n\n            emit WithdrawingToken(to, _token, value, proof);\n            emit WithdrawDoneToken(to, _token, value, proof);\n            filledTx[taskHash] = true;\n            logic.removeTask(taskHash);\n            return res;\n        }\n        return true;\n    }","after":"function withdrawToken(address _token, address to, uint value, string calldata proof, bytes32 taskHash) public\n    onlyOperator\n    whenNotPaused\n    positiveValue(value)\n    returns (bool)\n    {\n        require(taskHash == keccak256((abi.encodePacked(to, value, proof))), \"Bridge:taskHash is wrong\");\n        require(!filledTx[taskHash], \"Bridge:tx filled already\");\n        uint256 status = logic.supportTask(logic.WITHDRAWTASK(), taskHash, msg.sender, operatorRequireNum);\n\n        if (status == logic.TASKPROCESSING()) {\n            emit WithdrawingToken(to, _token, value, proof);\n        } else if (status == logic.TASKDONE()) {\n            bool res = withdrawTokenLogic(_token, to, value);\n\n            emit WithdrawingToken(to, _token, value, proof);\n            emit WithdrawDoneToken(to, _token, value, proof);\n            filledTx[taskHash] = true;\n            logic.removeTask(taskHash);\n            return res;\n        }\n        return true;\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function modifyAdminAddress(string memory class, address oldAddress, address newAddress) public whenPaused {\n        require(newAddress != address(0x0), \"Bridge:wrong address\");\n        bool flag = modifyAddress(class, oldAddress, newAddress);\n        if (flag) {\n            bytes32 classHash = keccak256(abi.encodePacked(class));\n            if (classHash == LOGICHASH) {\n                logic = BridgeLogic(newAddress);\n            } else if (classHash == STOREHASH) {\n                logic.resetStoreLogic(newAddress);\n            }\n        }\n    }","after":"function modifyAdminAddress(string calldata class, address oldAddress, address newAddress) public whenPaused {\n        require(newAddress != address(0x0), \"Bridge:wrong address\");\n        bool flag = modifyAddress(class, oldAddress, newAddress);\n        if (flag) {\n            bytes32 classHash = keccak256(abi.encodePacked(class));\n            if (classHash == LOGICHASH) {\n                logic = BridgeLogic(newAddress);\n            } else if (classHash == STOREHASH) {\n                logic.resetStoreLogic(newAddress);\n            }\n        }\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function setDepositSelector(address token, string memory method, bool _isValueFirst) onlyOperator external {\n        depositSelector[token] = assetSelector(method, _isValueFirst);\n    }","after":"function setDepositSelector(address token, string calldata method, bool _isValueFirst) onlyOperator external {\n        depositSelector[token] = assetSelector(method, _isValueFirst);\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function setWithdrawSelector(address token, string memory method, bool _isValueFirst) onlyOperator external {\n        withdrawSelector[token] = assetSelector(method, _isValueFirst);\n    }","after":"function setWithdrawSelector(address token, string calldata method, bool _isValueFirst) onlyOperator external {\n        withdrawSelector[token] = assetSelector(method, _isValueFirst);\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function resetRequiredNum(string memory class, uint256 requiredNum) public onlyOwner returns (bool) {\n        bytes32 classHash = getClassHash(class);\n        require((classHash == OPERATORHASH) || (classHash == OWNERHASH), \"BridgeAdmin:wrong class\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"resetRequiredNum\", class, requiredNum));\n        addItemAddress(taskHash, msg.sender);\n\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            removeItem(taskHash);\n            uint256 previousNum = 0;\n            if (classHash == OWNERHASH) {\n                require(getItemAddressCount(classHash) >= requiredNum, \"BridgeAdmin:insufficiency addresses\");\n                previousNum = ownerRequireNum;\n                ownerRequireNum = requiredNum;\n            }\n            else if (classHash == OPERATORHASH) {\n                previousNum = operatorRequireNum;\n                operatorRequireNum = requiredNum;\n            } else {\n                revert(\"BridgeAdmin:wrong class\");\n            }\n            emit AdminRequiredNumChanged(\"resetRequiredNum\", class, previousNum, requiredNum);\n        }\n        return true;\n    }","after":"function resetRequiredNum(string calldata class, uint256 requiredNum) public onlyOwner returns (bool) {\n        bytes32 classHash = getClassHash(class);\n        require((classHash == OPERATORHASH) || (classHash == OWNERHASH), \"BridgeAdmin:wrong class\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"resetRequiredNum\", class, requiredNum));\n        addItemAddress(taskHash, msg.sender);\n\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            removeItem(taskHash);\n            uint256 previousNum = 0;\n            if (classHash == OWNERHASH) {\n                require(getItemAddressCount(classHash) >= requiredNum, \"BridgeAdmin:insufficiency addresses\");\n                previousNum = ownerRequireNum;\n                ownerRequireNum = requiredNum;\n            }\n            else if (classHash == OPERATORHASH) {\n                previousNum = operatorRequireNum;\n                operatorRequireNum = requiredNum;\n            } else {\n                revert(\"BridgeAdmin:wrong class\");\n            }\n            emit AdminRequiredNumChanged(\"resetRequiredNum\", class, previousNum, requiredNum);\n        }\n        return true;\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function dropAddress(string memory class, address oneAddress) public onlyOwner returns (bool) {\n        bytes32 classHash = getClassHash(class);\n        require(classHash != STOREHASH && classHash != LOGICHASH, \"BridgeAdmin:wrong class\");\n        require(itemAddressExists(classHash, oneAddress), \"BridgeAdmin:no such address exists\");\n\n        if (classHash == OWNERHASH)\n            require(getItemAddressCount(classHash) > ownerRequireNum, \"BridgeAdmin:insufficiency addresses\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"dropAddress\", class, oneAddress));\n        addItemAddress(taskHash, msg.sender);\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            removeOneItemAddress(classHash, oneAddress);\n            emit AdminChanged(\"dropAddress\", class, oneAddress, oneAddress);\n            removeItem(taskHash);\n            return true;\n        }\n        return false;\n    }","after":"function dropAddress(string calldata class, address oneAddress) public onlyOwner returns (bool) {\n        bytes32 classHash = getClassHash(class);\n        require(classHash != STOREHASH && classHash != LOGICHASH, \"BridgeAdmin:wrong class\");\n        require(itemAddressExists(classHash, oneAddress), \"BridgeAdmin:no such address exists\");\n\n        if (classHash == OWNERHASH)\n            require(getItemAddressCount(classHash) > ownerRequireNum, \"BridgeAdmin:insufficiency addresses\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"dropAddress\", class, oneAddress));\n        addItemAddress(taskHash, msg.sender);\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            removeOneItemAddress(classHash, oneAddress);\n            emit AdminChanged(\"dropAddress\", class, oneAddress, oneAddress);\n            removeItem(taskHash);\n            return true;\n        }\n        return false;\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function addAddress(string memory class, address oneAddress) public onlyOwner returns (bool) {\n        bytes32 classHash = getClassHash(class);\n        require(classHash != STOREHASH && classHash != LOGICHASH, \"BridgeAdmin:wrong class\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"addAddress\", class, oneAddress));\n        addItemAddress(taskHash, msg.sender);\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            addItemAddress(classHash, oneAddress);\n            emit AdminChanged(\"addAddress\", class, oneAddress, oneAddress);\n            removeItem(taskHash);\n            return true;\n        }\n        return false;\n    }","after":"function addAddress(string calldata class, address oneAddress) public onlyOwner returns (bool) {\n        bytes32 classHash = getClassHash(class);\n        require(classHash != STOREHASH && classHash != LOGICHASH, \"BridgeAdmin:wrong class\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"addAddress\", class, oneAddress));\n        addItemAddress(taskHash, msg.sender);\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            addItemAddress(classHash, oneAddress);\n            emit AdminChanged(\"addAddress\", class, oneAddress, oneAddress);\n            removeItem(taskHash);\n            return true;\n        }\n        return false;\n    }","contract":"Bridge","time":0},{"type":"constant-restrict-modification  ","before":"uint256 MaxItemAddressNum = 255;","after":"uint256 constant MaxItemAddressNum = 255;","contract":"Bridge","time":0}]}