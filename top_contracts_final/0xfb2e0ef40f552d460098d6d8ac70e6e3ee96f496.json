{"time":236,"results":[{"type":"state-data-arrangement ","before":"\nbytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\nbytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\naddress public nftStakingPoolAddress;\nstring public baseUri;\nbytes1 public contractChar;\nstring public contractURIString;\nmapping(address => mapping(uint256 => uint256)) public numberMintedByAddress;\nmapping(address => bool) public rainbowPools;\nmapping(address => bool) public unicornPools;\nuint256 public maxTokenId;\nuint256 public maxCardId;\naddress private contractOwner;\nmapping(uint256 => Card) public cards;\nmapping(uint256 => string) public cardPathUri;\nmapping(uint256 => CardLevel[]) public cardLevels;\nmapping(uint256 => uint256) public mergeFees;\nuint256 public mintingFeeBasisPoints;\nmapping(uint256 => TokenVars) public tokenVars;","after":"bytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\nbytes32 public constant BURNER_ROLE = keccak256(\"BURNER_ROLE\");\nstring public baseUri;\nstring public contractURIString;\nmapping(address => mapping(uint256 => uint256)) public numberMintedByAddress;\nmapping(address => bool) public rainbowPools;\nmapping(address => bool) public unicornPools;\nuint256 public maxTokenId;\nuint256 public maxCardId;\nmapping(uint256 => Card) public cards;\nmapping(uint256 => string) public cardPathUri;\nmapping(uint256 => CardLevel[]) public cardLevels;\nmapping(uint256 => uint256) public mergeFees;\nuint256 public mintingFeeBasisPoints;\nmapping(uint256 => TokenVars) public tokenVars;\naddress public nftStakingPoolAddress;\naddress private contractOwner;\nbytes1 public contractChar;\n","contract":"RainiNFT1155v2","time":1},{"type":"external-function ","before":"function setcontractURI(string memory _contractURIString)\n    external onlyOwner {\n      contractURIString = _contractURIString;\n  }","after":"function setcontractURI(string calldata _contractURIString)\n    external onlyOwner {\n      contractURIString = _contractURIString;\n  }","contract":"RainiNFT1155v2","time":0},{"type":"external-function ","before":"function setFees(uint256 _mintingFeeBasisPoints, uint256[] memory _mergeFees) \n    external onlyOwner {\n      mintingFeeBasisPoints =_mintingFeeBasisPoints;\n      for (uint256 i = 1; i < _mergeFees.length; i++) {\n        mergeFees[i] = _mergeFees[i];\n      }\n  }","after":"function setFees(uint256 _mintingFeeBasisPoints, uint256[] calldata _mergeFees) \n    external onlyOwner {\n      mintingFeeBasisPoints =_mintingFeeBasisPoints;\n      for (uint256 i = 1; i < _mergeFees.length; i++) {\n        mergeFees[i] = _mergeFees[i];\n      }\n  }","contract":"RainiNFT1155v2","time":0},{"type":"external-function ","before":"function initCards(uint256[] memory _costInUnicorns, uint256[] memory _costInRainbows, uint256[] memory _maxMintsPerAddress,  uint16[] memory _maxSupply, uint256[] memory _allocation, string[] memory _pathUri, address[] memory _subContract, uint32[] memory _mintTimeStart, uint16[][] memory _conversionRates, bool[][] memory _isGrouped, uint256[][] memory _maxStamina)\n    external onlyOwner() {\n\n      uint256 _maxCardId = maxCardId;\n      uint256 _maxTokenId = maxTokenId;\n\n      for (uint256 i; i < _costInUnicorns.length; i++) {\n        require(_conversionRates[i].length == _isGrouped[i].length);\n\n        _maxCardId++;\n        cards[_maxCardId] = Card({\n            costInUnicorns: uint64(_costInUnicorns[i]),\n            costInRainbows: uint64(_costInRainbows[i]),\n            maxMintsPerAddress: uint16(_maxMintsPerAddress[i]),\n            maxSupply: uint32(_maxSupply[i]),\n            allocation: uint32(_allocation[i]),\n            mintTimeStart: uint32(_mintTimeStart[i]),\n            locked: false,\n            subContract: _subContract[i]\n          });\n\n        cardPathUri[_maxCardId] = _pathUri[i];\n        \n        for (uint256 j = 0; j < _conversionRates[i].length; j++) {\n          uint256 _tokenId = 0;\n\n          if (_isGrouped[i][j]) {\n            _maxTokenId++;\n            _tokenId = _maxTokenId;\n            tokenVars[_maxTokenId] = TokenVars({\n              cardId: uint128(_maxCardId),\n              level: uint32(j),\n              number: 0,\n              mintedContractChar: contractChar\n            });\n          }\n\n          cardLevels[_maxCardId].push(CardLevel({\n            conversionRate: uint64(_conversionRates[i][j]),\n            numberMinted: 0,\n            tokenId: uint128(_tokenId),\n            maxStamina: uint32(_maxStamina[i][j])\n          }));\n        }\n        \n      }\n\n      maxTokenId = _maxTokenId;\n      maxCardId = _maxCardId;\n  }","after":"function initCards(uint256[] calldata _costInUnicorns, uint256[] calldata _costInRainbows, uint256[] calldata _maxMintsPerAddress,  uint16[] calldata _maxSupply, uint256[] calldata _allocation, string[] calldata _pathUri, address[] calldata _subContract, uint32[] calldata _mintTimeStart, uint16[][] calldata _conversionRates, bool[][] calldata _isGrouped, uint256[][] calldata _maxStamina)\n    external onlyOwner() {\n\n      uint256 _maxCardId = maxCardId;\n      uint256 _maxTokenId = maxTokenId;\n\n      for (uint256 i; i < _costInUnicorns.length; i++) {\n        require(_conversionRates[i].length == _isGrouped[i].length);\n\n        _maxCardId++;\n        cards[_maxCardId] = Card({\n            costInUnicorns: uint64(_costInUnicorns[i]),\n            costInRainbows: uint64(_costInRainbows[i]),\n            maxMintsPerAddress: uint16(_maxMintsPerAddress[i]),\n            maxSupply: uint32(_maxSupply[i]),\n            allocation: uint32(_allocation[i]),\n            mintTimeStart: uint32(_mintTimeStart[i]),\n            locked: false,\n            subContract: _subContract[i]\n          });\n\n        cardPathUri[_maxCardId] = _pathUri[i];\n        \n        for (uint256 j = 0; j < _conversionRates[i].length; j++) {\n          uint256 _tokenId = 0;\n\n          if (_isGrouped[i][j]) {\n            _maxTokenId++;\n            _tokenId = _maxTokenId;\n            tokenVars[_maxTokenId] = TokenVars({\n              cardId: uint128(_maxCardId),\n              level: uint32(j),\n              number: 0,\n              mintedContractChar: contractChar\n            });\n          }\n\n          cardLevels[_maxCardId].push(CardLevel({\n            conversionRate: uint64(_conversionRates[i][j]),\n            numberMinted: 0,\n            tokenId: uint128(_tokenId),\n            maxStamina: uint32(_maxStamina[i][j])\n          }));\n        }\n        \n      }\n\n      maxTokenId = _maxTokenId;\n      maxCardId = _maxCardId;\n  }","contract":"RainiNFT1155v2","time":1},{"type":"external-function ","before":"function mint(address _to, uint256 _cardId, uint256 _cardLevel, uint256 _amount, bytes1 _mintedContractChar, uint256 _number, uint256[] memory _data) \n    external onlyMinter {\n      _mintToken(_to, _cardId, _cardLevel, _amount, _mintedContractChar, _number, _data);\n  }","after":"function mint(address _to, uint256 _cardId, uint256 _cardLevel, uint256 _amount, bytes1 _mintedContractChar, uint256 _number, uint256[] calldata _data) \n    external onlyMinter {\n      _mintToken(_to, _cardId, _cardLevel, _amount, _mintedContractChar, _number, _data);\n  }","contract":"RainiNFT1155v2","time":0},{"type":"external-function ","before":"function updateCardPathUri(uint256 _cardId, string memory _pathUri) external onlyOwner {\n    require(!cards[_cardId].locked, 'card locked');\n    cardPathUri[_cardId] = _pathUri;\n  }","after":"function updateCardPathUri(uint256 _cardId, string calldata _pathUri) external onlyOwner {\n    require(!cards[_cardId].locked, 'card locked');\n    cardPathUri[_cardId] = _pathUri;\n  }","contract":"RainiNFT1155v2","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"RainiNFT1155v2","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"RainiNFT1155v2","time":0},{"type":"immutable-restrict-modification ","before":"bytes1 public contractChar;","after":"bytes1 public immutable contractChar;","contract":"RainiNFT1155v2","time":0},{"type":"immutable-restrict-modification ","before":"address private contractOwner;","after":"address private immutable contractOwner;","contract":"RainiNFT1155v2","time":0}]}