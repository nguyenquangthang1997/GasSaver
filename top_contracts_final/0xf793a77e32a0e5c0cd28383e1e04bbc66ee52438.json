{"time":142,"results":[{"type":"external-function ","before":"function setBaseURI(string memory _newURI) public onlyOwner {\n        baseURI = _newURI;\n    }","after":"function setBaseURI(string calldata _newURI) public onlyOwner {\n        baseURI = _newURI;\n    }","contract":"ApocalypticApes","time":0},{"type":"external-function ","before":"function whitelist(address[] memory _user, bytes1 _status) public onlyOwner {\n        for (uint256 i = 0; i < _user.length; i++) {\n            manualWhitelist[_user[i]] = _status;\n        }\n    }","after":"function whitelist(address[] calldata _user, bytes1 _status) public onlyOwner {\n        for (uint256 i = 0; i < _user.length; i++) {\n            manualWhitelist[_user[i]] = _status;\n        }\n    }","contract":"ApocalypticApes","time":0},{"type":"external-function ","before":"function mintApe(uint8 _batchCount, uint8 authAmnt, bytes32[] memory proof, bytes32 leaf) payable public {\n        require(saleDetails.phase != 0, \"Sale has not started\");\n        require(_batchCount > 0 && _batchCount <= saleDetails.maxBatch, \"Batch purchase limit exceeded\");\n        require(saleDetails.totalMinted + _batchCount <= saleDetails.totalCount - saleDetails.freeMints, \"Not enough inventory\");\n        require(msg.value == _batchCount * price, \"Invalid value sent\");\n        require(walletBuys[msg.sender] + _batchCount <= saleDetails.maxBuy, \"Buy limit reached\");\n\n        // TODO: Untested verification; need to generate merkle tree with whitelist data\n        if (saleDetails.phase != 0x02 && !verify(proof, leaf, msg.sender, authAmnt))\n            require(manualWhitelist[msg.sender] > 0,\"Not whitelisted!\");\n \n        emit MintApe(_msgSender(), saleDetails.totalMinted+1, _batchCount);\n        for(uint8 i=0; i< _batchCount; i++){\n            _mint(_msgSender(), 1 + saleDetails.totalMinted++);\n        }\n        walletBuys[msg.sender] += _batchCount;\n    }","after":"function mintApe(uint8 _batchCount, uint8 authAmnt, bytes32[] calldata proof, bytes32 leaf) payable public {\n        require(saleDetails.phase != 0, \"Sale has not started\");\n        require(_batchCount > 0 && _batchCount <= saleDetails.maxBatch, \"Batch purchase limit exceeded\");\n        require(saleDetails.totalMinted + _batchCount <= saleDetails.totalCount - saleDetails.freeMints, \"Not enough inventory\");\n        require(msg.value == _batchCount * price, \"Invalid value sent\");\n        require(walletBuys[msg.sender] + _batchCount <= saleDetails.maxBuy, \"Buy limit reached\");\n\n        // TODO: Untested verification; need to generate merkle tree with whitelist data\n        if (saleDetails.phase != 0x02 && !verify(proof, leaf, msg.sender, authAmnt))\n            require(manualWhitelist[msg.sender] > 0,\"Not whitelisted!\");\n \n        emit MintApe(_msgSender(), saleDetails.totalMinted+1, _batchCount);\n        for(uint8 i=0; i< _batchCount; i++){\n            _mint(_msgSender(), 1 + saleDetails.totalMinted++);\n        }\n        walletBuys[msg.sender] += _batchCount;\n    }","contract":"ApocalypticApes","time":0},{"type":"constant-restrict-modification  ","before":"string name_ = 'Apocalyptic Apes';","after":"string constant name_ = 'Apocalyptic Apes';","contract":"ApocalypticApes","time":1},{"type":"constant-restrict-modification  ","before":"string symbol_ = 'AAPES';","after":"string constant symbol_ = 'AAPES';","contract":"ApocalypticApes","time":1},{"type":"constant-restrict-modification  ","before":"string baseURI_ = 'ipfs://QmYMscQ1gu5eCaXpjs3XA6154LwhfZxxb9LjQDC9UL155d/';","after":"string constant baseURI_ = 'ipfs://QmYMscQ1gu5eCaXpjs3XA6154LwhfZxxb9LjQDC9UL155d/';","contract":"ApocalypticApes","time":1}]}