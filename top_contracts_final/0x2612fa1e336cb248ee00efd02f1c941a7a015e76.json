{"time":344,"results":[{"type":"external-function ","before":"function engage(string memory _exchangeName) external onlyOperator {\n        ActionInfo memory engageInfo = _createActionInfo();\n\n        require(engageInfo.setTotalSupply > 0, \"SetToken must have > 0 supply\");\n        require(engageInfo.collateralBalance > 0, \"Collateral balance must be > 0\");\n        require(engageInfo.borrowBalance == 0, \"Debt must be 0\");\n\n        LeverageInfo memory leverageInfo = LeverageInfo({\n            action: engageInfo,\n            currentLeverageRatio: PreciseUnitMath.preciseUnit(), // 1x leverage in precise units\n            slippageTolerance: execution.slippageTolerance,\n            twapMaxTradeSize: exchangeSettings[_exchangeName].twapMaxTradeSize,\n            exchangeName: _exchangeName\n        });\n\n        // Calculate total rebalance units and kick off TWAP if above max borrow or max trade size\n        (\n            uint256 chunkRebalanceNotional,\n            uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, methodology.targetLeverageRatio, true);\n\n        _lever(leverageInfo, chunkRebalanceNotional);\n\n        _updateRebalanceState(\n            chunkRebalanceNotional,\n            totalRebalanceNotional,\n            methodology.targetLeverageRatio,\n            _exchangeName\n        );\n\n        emit Engaged(\n            leverageInfo.currentLeverageRatio,\n            methodology.targetLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","after":"function engage(string calldata _exchangeName) external onlyOperator {\n        ActionInfo memory engageInfo = _createActionInfo();\n\n        require(engageInfo.setTotalSupply > 0, \"SetToken must have > 0 supply\");\n        require(engageInfo.collateralBalance > 0, \"Collateral balance must be > 0\");\n        require(engageInfo.borrowBalance == 0, \"Debt must be 0\");\n\n        LeverageInfo memory leverageInfo = LeverageInfo({\n            action: engageInfo,\n            currentLeverageRatio: PreciseUnitMath.preciseUnit(), // 1x leverage in precise units\n            slippageTolerance: execution.slippageTolerance,\n            twapMaxTradeSize: exchangeSettings[_exchangeName].twapMaxTradeSize,\n            exchangeName: _exchangeName\n        });\n\n        // Calculate total rebalance units and kick off TWAP if above max borrow or max trade size\n        (\n            uint256 chunkRebalanceNotional,\n            uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, methodology.targetLeverageRatio, true);\n\n        _lever(leverageInfo, chunkRebalanceNotional);\n\n        _updateRebalanceState(\n            chunkRebalanceNotional,\n            totalRebalanceNotional,\n            methodology.targetLeverageRatio,\n            _exchangeName\n        );\n\n        emit Engaged(\n            leverageInfo.currentLeverageRatio,\n            methodology.targetLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function rebalance(string memory _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        // use globalLastTradeTimestamps to prevent multiple rebalances being called with different exchanges during the epoch rebalance\n        _validateNormalRebalance(leverageInfo, methodology.rebalanceInterval, globalLastTradeTimestamp);\n        _validateNonTWAP();\n\n        uint256 newLeverageRatio = _calculateNewLeverageRatio(leverageInfo.currentLeverageRatio);\n\n        (\n            uint256 chunkRebalanceNotional,\n            uint256 totalRebalanceNotional\n        ) = _handleRebalance(leverageInfo, newLeverageRatio);\n\n        _updateRebalanceState(chunkRebalanceNotional, totalRebalanceNotional, newLeverageRatio, _exchangeName);\n\n        emit Rebalanced(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","after":"function rebalance(string calldata _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        // use globalLastTradeTimestamps to prevent multiple rebalances being called with different exchanges during the epoch rebalance\n        _validateNormalRebalance(leverageInfo, methodology.rebalanceInterval, globalLastTradeTimestamp);\n        _validateNonTWAP();\n\n        uint256 newLeverageRatio = _calculateNewLeverageRatio(leverageInfo.currentLeverageRatio);\n\n        (\n            uint256 chunkRebalanceNotional,\n            uint256 totalRebalanceNotional\n        ) = _handleRebalance(leverageInfo, newLeverageRatio);\n\n        _updateRebalanceState(chunkRebalanceNotional, totalRebalanceNotional, newLeverageRatio, _exchangeName);\n\n        emit Rebalanced(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function iterateRebalance(string memory _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        // Use the exchangeLastTradeTimestamp since cooldown periods are measured on a per-exchange basis, allowing it to rebalance multiple time in quick \n        // succession with different exchanges\n        _validateNormalRebalance(leverageInfo, execution.twapCooldownPeriod, exchangeSettings[_exchangeName].exchangeLastTradeTimestamp);\n        _validateTWAP();\n\n        uint256 chunkRebalanceNotional;\n        uint256 totalRebalanceNotional;\n        if (!_isAdvantageousTWAP(leverageInfo.currentLeverageRatio)) {\n            (chunkRebalanceNotional, totalRebalanceNotional) = _handleRebalance(leverageInfo, twapLeverageRatio);\n        }\n\n        // If not advantageous, then rebalance is skipped and chunk and total rebalance notional are both 0, which means TWAP state is\n        // cleared\n        _updateIterateState(chunkRebalanceNotional, totalRebalanceNotional, _exchangeName);\n\n        emit RebalanceIterated(\n            leverageInfo.currentLeverageRatio,\n            twapLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","after":"function iterateRebalance(string calldata _exchangeName) external onlyEOA onlyAllowedCaller(msg.sender) {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        // Use the exchangeLastTradeTimestamp since cooldown periods are measured on a per-exchange basis, allowing it to rebalance multiple time in quick \n        // succession with different exchanges\n        _validateNormalRebalance(leverageInfo, execution.twapCooldownPeriod, exchangeSettings[_exchangeName].exchangeLastTradeTimestamp);\n        _validateTWAP();\n\n        uint256 chunkRebalanceNotional;\n        uint256 totalRebalanceNotional;\n        if (!_isAdvantageousTWAP(leverageInfo.currentLeverageRatio)) {\n            (chunkRebalanceNotional, totalRebalanceNotional) = _handleRebalance(leverageInfo, twapLeverageRatio);\n        }\n\n        // If not advantageous, then rebalance is skipped and chunk and total rebalance notional are both 0, which means TWAP state is\n        // cleared\n        _updateIterateState(chunkRebalanceNotional, totalRebalanceNotional, _exchangeName);\n\n        emit RebalanceIterated(\n            leverageInfo.currentLeverageRatio,\n            twapLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function ripcord(string memory _exchangeName) external onlyEOA {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            incentive.incentivizedSlippageTolerance, \n            exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize,\n            _exchangeName\n        );\n\n        // Use the exchangeLastTradeTimestamp so it can ripcord quickly with multiple exchanges\n        _validateRipcord(leverageInfo, exchangeSettings[_exchangeName].exchangeLastTradeTimestamp);\n\n        ( uint256 chunkRebalanceNotional, ) = _calculateChunkRebalanceNotional(leverageInfo, methodology.maxLeverageRatio, false);\n\n        _delever(leverageInfo, chunkRebalanceNotional);\n\n        _updateRipcordState(_exchangeName);\n\n        uint256 etherTransferred = _transferEtherRewardToCaller(incentive.etherReward);\n\n        emit RipcordCalled(\n            leverageInfo.currentLeverageRatio,\n            methodology.maxLeverageRatio,\n            chunkRebalanceNotional,\n            etherTransferred\n        );\n    }","after":"function ripcord(string calldata _exchangeName) external onlyEOA {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            incentive.incentivizedSlippageTolerance, \n            exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize,\n            _exchangeName\n        );\n\n        // Use the exchangeLastTradeTimestamp so it can ripcord quickly with multiple exchanges\n        _validateRipcord(leverageInfo, exchangeSettings[_exchangeName].exchangeLastTradeTimestamp);\n\n        ( uint256 chunkRebalanceNotional, ) = _calculateChunkRebalanceNotional(leverageInfo, methodology.maxLeverageRatio, false);\n\n        _delever(leverageInfo, chunkRebalanceNotional);\n\n        _updateRipcordState(_exchangeName);\n\n        uint256 etherTransferred = _transferEtherRewardToCaller(incentive.etherReward);\n\n        emit RipcordCalled(\n            leverageInfo.currentLeverageRatio,\n            methodology.maxLeverageRatio,\n            chunkRebalanceNotional,\n            etherTransferred\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function disengage(string memory _exchangeName) external onlyOperator {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        uint256 newLeverageRatio = PreciseUnitMath.preciseUnit();\n\n        (\n            uint256 chunkRebalanceNotional,\n            uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, newLeverageRatio, false);\n\n        if (totalRebalanceNotional > chunkRebalanceNotional) {\n            _delever(leverageInfo, chunkRebalanceNotional);\n        } else {\n            _deleverToZeroBorrowBalance(leverageInfo, totalRebalanceNotional);\n        }\n\n        emit Disengaged(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","after":"function disengage(string calldata _exchangeName) external onlyOperator {\n        LeverageInfo memory leverageInfo = _getAndValidateLeveragedInfo(\n            execution.slippageTolerance,\n            exchangeSettings[_exchangeName].twapMaxTradeSize,\n            _exchangeName\n        );\n\n        uint256 newLeverageRatio = PreciseUnitMath.preciseUnit();\n\n        (\n            uint256 chunkRebalanceNotional,\n            uint256 totalRebalanceNotional\n        ) = _calculateChunkRebalanceNotional(leverageInfo, newLeverageRatio, false);\n\n        if (totalRebalanceNotional > chunkRebalanceNotional) {\n            _delever(leverageInfo, chunkRebalanceNotional);\n        } else {\n            _deleverToZeroBorrowBalance(leverageInfo, totalRebalanceNotional);\n        }\n\n        emit Disengaged(\n            leverageInfo.currentLeverageRatio,\n            newLeverageRatio,\n            chunkRebalanceNotional,\n            totalRebalanceNotional\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function setMethodologySettings(MethodologySettings memory _newMethodologySettings) external onlyOperator noRebalanceInProgress {\n        methodology = _newMethodologySettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit MethodologySettingsUpdated(\n            methodology.targetLeverageRatio,\n            methodology.minLeverageRatio,\n            methodology.maxLeverageRatio,\n            methodology.recenteringSpeed,\n            methodology.rebalanceInterval\n        );\n    }","after":"function setMethodologySettings(MethodologySettings calldata _newMethodologySettings) external onlyOperator noRebalanceInProgress {\n        methodology = _newMethodologySettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit MethodologySettingsUpdated(\n            methodology.targetLeverageRatio,\n            methodology.minLeverageRatio,\n            methodology.maxLeverageRatio,\n            methodology.recenteringSpeed,\n            methodology.rebalanceInterval\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function setExecutionSettings(ExecutionSettings memory _newExecutionSettings) external onlyOperator noRebalanceInProgress {\n        execution = _newExecutionSettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit ExecutionSettingsUpdated(\n            execution.unutilizedLeveragePercentage,\n            execution.twapCooldownPeriod,\n            execution.slippageTolerance\n        );\n    }","after":"function setExecutionSettings(ExecutionSettings calldata _newExecutionSettings) external onlyOperator noRebalanceInProgress {\n        execution = _newExecutionSettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit ExecutionSettingsUpdated(\n            execution.unutilizedLeveragePercentage,\n            execution.twapCooldownPeriod,\n            execution.slippageTolerance\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function setIncentiveSettings(IncentiveSettings memory _newIncentiveSettings) external onlyOperator noRebalanceInProgress {\n        incentive = _newIncentiveSettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit IncentiveSettingsUpdated(\n            incentive.etherReward,\n            incentive.incentivizedLeverageRatio,\n            incentive.incentivizedSlippageTolerance,\n            incentive.incentivizedTwapCooldownPeriod\n        );\n    }","after":"function setIncentiveSettings(IncentiveSettings calldata _newIncentiveSettings) external onlyOperator noRebalanceInProgress {\n        incentive = _newIncentiveSettings;\n\n        _validateNonExchangeSettings(methodology, execution, incentive);\n\n        emit IncentiveSettingsUpdated(\n            incentive.etherReward,\n            incentive.incentivizedLeverageRatio,\n            incentive.incentivizedSlippageTolerance,\n            incentive.incentivizedTwapCooldownPeriod\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function addEnabledExchange(\n        string memory _exchangeName,\n        ExchangeSettings memory _exchangeSettings\n    )\n        external \n        onlyOperator \n    {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize == 0, \"Exchange already enabled\");\n        _validateExchangeSettings(_exchangeSettings);\n\n        exchangeSettings[_exchangeName].twapMaxTradeSize = _exchangeSettings.twapMaxTradeSize;\n        exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize = _exchangeSettings.incentivizedTwapMaxTradeSize;\n        exchangeSettings[_exchangeName].leverExchangeData = _exchangeSettings.leverExchangeData;\n        exchangeSettings[_exchangeName].deleverExchangeData = _exchangeSettings.deleverExchangeData;\n        exchangeSettings[_exchangeName].exchangeLastTradeTimestamp = 0;\n        \n        enabledExchanges.push(_exchangeName);\n\n        emit ExchangeAdded(\n            _exchangeName,\n            _exchangeSettings.twapMaxTradeSize,\n            _exchangeSettings.exchangeLastTradeTimestamp,\n            _exchangeSettings.incentivizedTwapMaxTradeSize,\n            _exchangeSettings.leverExchangeData,\n            _exchangeSettings.deleverExchangeData\n        );\n    }","after":"function addEnabledExchange(\n        string calldata _exchangeName,\n        ExchangeSettings calldata _exchangeSettings\n    )\n        external \n        onlyOperator \n    {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize == 0, \"Exchange already enabled\");\n        _validateExchangeSettings(_exchangeSettings);\n\n        exchangeSettings[_exchangeName].twapMaxTradeSize = _exchangeSettings.twapMaxTradeSize;\n        exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize = _exchangeSettings.incentivizedTwapMaxTradeSize;\n        exchangeSettings[_exchangeName].leverExchangeData = _exchangeSettings.leverExchangeData;\n        exchangeSettings[_exchangeName].deleverExchangeData = _exchangeSettings.deleverExchangeData;\n        exchangeSettings[_exchangeName].exchangeLastTradeTimestamp = 0;\n        \n        enabledExchanges.push(_exchangeName);\n\n        emit ExchangeAdded(\n            _exchangeName,\n            _exchangeSettings.twapMaxTradeSize,\n            _exchangeSettings.exchangeLastTradeTimestamp,\n            _exchangeSettings.incentivizedTwapMaxTradeSize,\n            _exchangeSettings.leverExchangeData,\n            _exchangeSettings.deleverExchangeData\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function removeEnabledExchange(string memory _exchangeName) external onlyOperator {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize != 0, \"Exchange not enabled\");\n\n        delete exchangeSettings[_exchangeName];\n        enabledExchanges.removeStorage(_exchangeName);\n\n        emit ExchangeRemoved(_exchangeName);\n    }","after":"function removeEnabledExchange(string calldata _exchangeName) external onlyOperator {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize != 0, \"Exchange not enabled\");\n\n        delete exchangeSettings[_exchangeName];\n        enabledExchanges.removeStorage(_exchangeName);\n\n        emit ExchangeRemoved(_exchangeName);\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"external-function ","before":"function updateEnabledExchange(\n        string memory _exchangeName,\n        ExchangeSettings memory _exchangeSettings\n    )\n        external\n        onlyOperator\n    {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize != 0, \"Exchange not enabled\");\n        _validateExchangeSettings(_exchangeSettings);\n\n        exchangeSettings[_exchangeName].twapMaxTradeSize = _exchangeSettings.twapMaxTradeSize;\n        exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize = _exchangeSettings.incentivizedTwapMaxTradeSize;\n        exchangeSettings[_exchangeName].leverExchangeData = _exchangeSettings.leverExchangeData;\n        exchangeSettings[_exchangeName].deleverExchangeData = _exchangeSettings.deleverExchangeData;\n\n        emit ExchangeUpdated(\n            _exchangeName,\n            _exchangeSettings.twapMaxTradeSize,\n            _exchangeSettings.exchangeLastTradeTimestamp,\n            _exchangeSettings.incentivizedTwapMaxTradeSize,\n            _exchangeSettings.leverExchangeData,\n            _exchangeSettings.deleverExchangeData\n        );\n    }","after":"function updateEnabledExchange(\n        string calldata _exchangeName,\n        ExchangeSettings calldata _exchangeSettings\n    )\n        external\n        onlyOperator\n    {\n        require(exchangeSettings[_exchangeName].twapMaxTradeSize != 0, \"Exchange not enabled\");\n        _validateExchangeSettings(_exchangeSettings);\n\n        exchangeSettings[_exchangeName].twapMaxTradeSize = _exchangeSettings.twapMaxTradeSize;\n        exchangeSettings[_exchangeName].incentivizedTwapMaxTradeSize = _exchangeSettings.incentivizedTwapMaxTradeSize;\n        exchangeSettings[_exchangeName].leverExchangeData = _exchangeSettings.leverExchangeData;\n        exchangeSettings[_exchangeName].deleverExchangeData = _exchangeSettings.deleverExchangeData;\n\n        emit ExchangeUpdated(\n            _exchangeName,\n            _exchangeSettings.twapMaxTradeSize,\n            _exchangeSettings.exchangeLastTradeTimestamp,\n            _exchangeSettings.incentivizedTwapMaxTradeSize,\n            _exchangeSettings.leverExchangeData,\n            _exchangeSettings.deleverExchangeData\n        );\n    }","contract":"FlexibleLeverageStrategyExtension","time":0},{"type":"struct-data-arrangement ","before":"\naddress component\naddress module\nint256 unit\nuint8 positionState\nbytes data","after":"int256 unit\nbytes data\naddress component\naddress module\nuint8 positionState\n","contract":"ISetToken","time":0}]}