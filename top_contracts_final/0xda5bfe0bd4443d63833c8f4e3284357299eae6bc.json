{"time":325,"results":[{"type":"external-function ","before":"function createToken(string memory _name, string memory _symbol, string memory baseURI, string memory contractURI, uint salt) external {        \n        address beaconProxy = deployProxy(getData(_name, _symbol, baseURI, contractURI), salt);\n\n        ERC1155Rarible token = ERC1155Rarible(beaconProxy);\n        token.transferOwnership(_msgSender());\n        emit Create1155RaribleProxy(beaconProxy);\n    }","after":"function createToken(string calldata _name, string calldata _symbol, string calldata baseURI, string calldata contractURI, uint salt) external {        \n        address beaconProxy = deployProxy(getData(_name, _symbol, baseURI, contractURI), salt);\n\n        ERC1155Rarible token = ERC1155Rarible(beaconProxy);\n        token.transferOwnership(_msgSender());\n        emit Create1155RaribleProxy(beaconProxy);\n    }","contract":"ERC1155RaribleFactoryC2","time":0},{"type":"external-function ","before":"function createToken(string memory _name, string memory _symbol, string memory baseURI, string memory contractURI, address[] memory operators, uint salt) external {\n        address beaconProxy = deployProxy(getData(_name, _symbol, baseURI, contractURI, operators), salt);\n\n        ERC1155Rarible token = ERC1155Rarible(address(beaconProxy));\n        token.transferOwnership(_msgSender());\n        emit Create1155RaribleUserProxy(beaconProxy);\n    }","after":"function createToken(string calldata _name, string calldata _symbol, string calldata baseURI, string calldata contractURI, address[] calldata operators, uint salt) external {\n        address beaconProxy = deployProxy(getData(_name, _symbol, baseURI, contractURI, operators), salt);\n\n        ERC1155Rarible token = ERC1155Rarible(address(beaconProxy));\n        token.transferOwnership(_msgSender());\n        emit Create1155RaribleUserProxy(beaconProxy);\n    }","contract":"ERC1155RaribleFactoryC2","time":0},{"type":"immutable-restrict-modification ","before":"address public beacon;","after":"address public immutable beacon;","contract":"ERC1155RaribleFactoryC2","time":0},{"type":"immutable-restrict-modification ","before":"address transferProxy;","after":"address immutable transferProxy;","contract":"ERC1155RaribleFactoryC2","time":0},{"type":"immutable-restrict-modification ","before":"address lazyTransferProxy;","after":"address immutable lazyTransferProxy;","contract":"ERC1155RaribleFactoryC2","time":0},{"type":"external-function ","before":"function __ERC1155RaribleUser_init(string memory _name, string memory _symbol, string memory baseURI, string memory contractURI, address[] memory operators, address transferProxy, address lazyTransferProxy) external initializer {\n        __ERC1155Rarible_init_unchained(_name, _symbol, baseURI, contractURI, transferProxy, lazyTransferProxy);\n        for(uint i = 0; i < operators.length; i++) {\n            setApprovalForAll(operators[i], true);\n        }\n\n        isPrivate = true;\n        emit CreateERC1155RaribleUser(_msgSender(), _name, _symbol);\n    }","after":"function __ERC1155RaribleUser_init(string calldata _name, string calldata _symbol, string calldata baseURI, string calldata contractURI, address[] calldata operators, address transferProxy, address lazyTransferProxy) external initializer {\n        __ERC1155Rarible_init_unchained(_name, _symbol, baseURI, contractURI, transferProxy, lazyTransferProxy);\n        for(uint i = 0; i < operators.length; i++) {\n            setApprovalForAll(operators[i], true);\n        }\n\n        isPrivate = true;\n        emit CreateERC1155RaribleUser(_msgSender(), _name, _symbol);\n    }","contract":"ERC1155Rarible","time":0},{"type":"external-function ","before":"function __ERC1155Rarible_init(string memory _name, string memory _symbol, string memory baseURI, string memory contractURI, address transferProxy, address lazyTransferProxy) external initializer {\n        __ERC1155Rarible_init_unchained(_name, _symbol, baseURI, contractURI, transferProxy, lazyTransferProxy);\n\n        isPrivate = false;\n        emit CreateERC1155Rarible(_msgSender(), _name, _symbol);\n    }","after":"function __ERC1155Rarible_init(string calldata _name, string calldata _symbol, string calldata baseURI, string calldata contractURI, address transferProxy, address lazyTransferProxy) external initializer {\n        __ERC1155Rarible_init_unchained(_name, _symbol, baseURI, contractURI, transferProxy, lazyTransferProxy);\n\n        isPrivate = false;\n        emit CreateERC1155Rarible(_msgSender(), _name, _symbol);\n    }","contract":"ERC1155Rarible","time":0},{"type":"external-function ","before":"function burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) public virtual override {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        uint256[] memory leftToBurns = new uint256[](ids.length);\n        uint256[] memory lazyToBurns = new uint256[](ids.length);\n        for (uint i = 0; i < ids.length; i++) {\n            (leftToBurns[i], lazyToBurns[i]) = _burnLazy(ids[i], amounts[i]);\n        }\n        ERC1155BurnableUpgradeable.burnBatch(account, ids, leftToBurns);\n        emit BurnLazyBatch(_msgSender(), account, ids, lazyToBurns);\n    }","after":"function burnBatch(address account, uint256[] calldata ids, uint256[] calldata amounts) public virtual override {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        uint256[] memory leftToBurns = new uint256[](ids.length);\n        uint256[] memory lazyToBurns = new uint256[](ids.length);\n        for (uint i = 0; i < ids.length; i++) {\n            (leftToBurns[i], lazyToBurns[i]) = _burnLazy(ids[i], amounts[i]);\n        }\n        ERC1155BurnableUpgradeable.burnBatch(account, ids, leftToBurns);\n        emit BurnLazyBatch(_msgSender(), account, ids, lazyToBurns);\n    }","contract":"ERC1155Rarible","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"ERC1155Rarible","time":0},{"type":"external-function ","before":"function burnBatch(address account, uint256[] memory ids, uint256[] memory values) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }","after":"function burnBatch(address account, uint256[] calldata ids, uint256[] calldata values) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }","contract":"ERC1155Rarible","time":0},{"type":"external-function ","before":"function transferFromOrMint(\n        LibERC1155LazyMint.Mint1155Data memory data,\n        address from,\n        address to,\n        uint256 amount\n    ) override external {\n        uint balance = balanceOf(from, data.tokenId);\n        uint left = amount;\n        if (balance != 0) {\n            uint transfer = amount;\n            if (balance < amount) {\n                transfer = balance;\n            }\n            safeTransferFrom(from, to, data.tokenId, transfer, \"\");\n            left = amount - transfer;\n        }\n        if (left > 0) {\n            mintAndTransfer(data, to, left);\n        }\n    }","after":"function transferFromOrMint(\n        LibERC1155LazyMint.Mint1155Data calldata data,\n        address from,\n        address to,\n        uint256 amount\n    ) override external {\n        uint balance = balanceOf(from, data.tokenId);\n        uint left = amount;\n        if (balance != 0) {\n            uint transfer = amount;\n            if (balance < amount) {\n                transfer = balance;\n            }\n            safeTransferFrom(from, to, data.tokenId, transfer, \"\");\n            left = amount - transfer;\n        }\n        if (left > 0) {\n            mintAndTransfer(data, to, left);\n        }\n    }","contract":"ERC1155Rarible","time":0}]}