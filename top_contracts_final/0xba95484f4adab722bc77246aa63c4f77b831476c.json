{"time":83,"results":[{"type":"external-function ","before":"function purchaseRarity(bytes32[] memory proof) external payable nonReentrant {\n    require(block.timestamp <= salesEndPeriod, \"Rarity sale period have ended\");\n    require(msg.value >= rarityPrice, \"Price must be greather than or equal to the rarity price\");\n\n    require(token.balanceOf(msg.sender, UNKNOWN) != MAX_NFTS_PER_ACCOUNT, \"Receiver have reached the allocated limit\");\n\n    if (whitelistingEnabled) {\n      require(proof.length > 0, \"Proof length can not be zero\");\n      bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n      bool iswhitelisted = verifyProof(leaf, proof);\n      require(iswhitelisted, \"User not whitelisted\");\n    } \n\n    uint256 numOfRarityPerPrice = msg.value / rarityPrice;\n\n    uint256 numOfEligibleRarityToPurchase = MAX_NFTS_PER_ACCOUNT - token.balanceOf(msg.sender, UNKNOWN);\n    uint256 numOfRarityPurchased = numOfRarityPerPrice > numOfEligibleRarityToPurchase ? numOfEligibleRarityToPurchase : numOfRarityPerPrice;\n        \n    require((token.balanceOf(msg.sender, UNKNOWN) + numOfRarityPurchased) <= MAX_NFTS_PER_ACCOUNT, \"Receiver total rarity plus the rarity you want to purchase exceed your limit\");\n    require((totalUnknownRarityMinted + numOfRarityPurchased) <= MAX_TOTAL_UNKNOWN, \"The amount of rarity you want to purchase plus the total rarity minted exceed the total unknown rarity\");\n\n    uint256 totalEtherUsed = numOfRarityPurchased * rarityPrice;\n\n    // calculate and send the remaining ether balance\n    uint256 etherToRefund = _transferBalance(msg.value, payable(msg.sender), totalEtherUsed);\n\n    totalUnknownRarityMinted += numOfRarityPurchased;\n\n    // MINT NFT;\n    token.mint(msg.sender, UNKNOWN, numOfRarityPurchased, \"0x0\");\n\n    emit PurchaseRarity(msg.sender, UNKNOWN, etherToRefund, totalEtherUsed, msg.value, block.timestamp);\n  }","after":"function purchaseRarity(bytes32[] calldata proof) external payable nonReentrant {\n    require(block.timestamp <= salesEndPeriod, \"Rarity sale period have ended\");\n    require(msg.value >= rarityPrice, \"Price must be greather than or equal to the rarity price\");\n\n    require(token.balanceOf(msg.sender, UNKNOWN) != MAX_NFTS_PER_ACCOUNT, \"Receiver have reached the allocated limit\");\n\n    if (whitelistingEnabled) {\n      require(proof.length > 0, \"Proof length can not be zero\");\n      bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n      bool iswhitelisted = verifyProof(leaf, proof);\n      require(iswhitelisted, \"User not whitelisted\");\n    } \n\n    uint256 numOfRarityPerPrice = msg.value / rarityPrice;\n\n    uint256 numOfEligibleRarityToPurchase = MAX_NFTS_PER_ACCOUNT - token.balanceOf(msg.sender, UNKNOWN);\n    uint256 numOfRarityPurchased = numOfRarityPerPrice > numOfEligibleRarityToPurchase ? numOfEligibleRarityToPurchase : numOfRarityPerPrice;\n        \n    require((token.balanceOf(msg.sender, UNKNOWN) + numOfRarityPurchased) <= MAX_NFTS_PER_ACCOUNT, \"Receiver total rarity plus the rarity you want to purchase exceed your limit\");\n    require((totalUnknownRarityMinted + numOfRarityPurchased) <= MAX_TOTAL_UNKNOWN, \"The amount of rarity you want to purchase plus the total rarity minted exceed the total unknown rarity\");\n\n    uint256 totalEtherUsed = numOfRarityPurchased * rarityPrice;\n\n    // calculate and send the remaining ether balance\n    uint256 etherToRefund = _transferBalance(msg.value, payable(msg.sender), totalEtherUsed);\n\n    totalUnknownRarityMinted += numOfRarityPurchased;\n\n    // MINT NFT;\n    token.mint(msg.sender, UNKNOWN, numOfRarityPurchased, \"0x0\");\n\n    emit PurchaseRarity(msg.sender, UNKNOWN, etherToRefund, totalEtherUsed, msg.value, block.timestamp);\n  }","contract":"GaiminICO","time":0},{"type":"external-function ","before":"function delegatePurchase(address[] memory newUsers, uint256[] memory amounts) external onlyOwner nonReentrant{\n    require(newUsers.length == amounts.length, \"newUsers and amounts length mismatch\");\n\n    uint256 _totalUnknownRarityMinted = totalUnknownRarityMinted;\n\n    for (uint256 i = 0; i < newUsers.length; i++) {\n\n      address newUser = newUsers[i];\n      uint256 amount = amounts[i];\n\n      require(newUser != address(0), \"Not a valid address\");\n      require(amount != 0, \"Rarity mint amount can not be zero\");\n      require((_totalUnknownRarityMinted + amount) <= MAX_TOTAL_UNKNOWN, \"Rarity to be minted will exceed maximum total UNKNOWN rarity\");\n\n      _totalUnknownRarityMinted += amount;\n      // MINT NFT;\n      token.mint(newUser, UNKNOWN, amount, \"0x0\");\n \n    }\n    totalUnknownRarityMinted = _totalUnknownRarityMinted;\n    emit DelegatePurchase(newUsers, amounts, block.timestamp);\n\n  }","after":"function delegatePurchase(address[] calldata newUsers, uint256[] calldata amounts) external onlyOwner nonReentrant{\n    require(newUsers.length == amounts.length, \"newUsers and amounts length mismatch\");\n\n    uint256 _totalUnknownRarityMinted = totalUnknownRarityMinted;\n\n    for (uint256 i = 0; i < newUsers.length; i++) {\n\n      address newUser = newUsers[i];\n      uint256 amount = amounts[i];\n\n      require(newUser != address(0), \"Not a valid address\");\n      require(amount != 0, \"Rarity mint amount can not be zero\");\n      require((_totalUnknownRarityMinted + amount) <= MAX_TOTAL_UNKNOWN, \"Rarity to be minted will exceed maximum total UNKNOWN rarity\");\n\n      _totalUnknownRarityMinted += amount;\n      // MINT NFT;\n      token.mint(newUser, UNKNOWN, amount, \"0x0\");\n \n    }\n    totalUnknownRarityMinted = _totalUnknownRarityMinted;\n    emit DelegatePurchase(newUsers, amounts, block.timestamp);\n\n  }","contract":"GaiminICO","time":0},{"type":"external-function ","before":"function allocateRarity(uint256[] memory amounts, address[] memory receivers) external onlyOwner nonReentrant {\n\n    require(amounts.length == receivers.length, \"amounts and receivers length mismatch\");\n    require(block.timestamp > salesEndPeriod, \"Rarity can not be distributed now\");\n\n    uint256 randomNumber = uint256(blockhash(block.number - 1) ^ blockhash(block.number - 2) ^ blockhash(block.number - 3));\n\n    for (uint256 i = 0; i < receivers.length; i++) {\n      \n      address receiver = receivers[i];\n      uint256 amount = amounts[i];\n\n      uint256[] memory purchasedRarity = new uint[](amount);\n      uint256[] memory amountPerRarity = new uint[](amount);\n\n      require(receiver != address(0), \"Not a valid address\");\n      require(amount != 0, \"Rarity mint amount can not be zero\");\n\n      for (uint256 j = 0; j < amount; j++) {\n\n        // There will be mathemtical overflow below, which is fine we want it.\n        unchecked {\n          randomNumber += uint256(blockhash(block.number - 4));  \n        }\n\n        uint256 remainingSilver = (MAX_TOTAL_SILVER - mintedRarity[SILVER]);\n        uint256 remainingGold = (MAX_TOTAL_GOLD - mintedRarity[GOLD]);\n        uint256 remainingBlackgold = (MAX_TOTAL_BLACKGOLD - mintedRarity[BLACKGOLD]);\n\n        uint256 remainingSupply = remainingSilver + remainingGold + remainingBlackgold;\n\n        uint256 raritySlot = (randomNumber % remainingSupply);\n\n        uint256 rarity;\n        \n        if (raritySlot < remainingSilver) {\n          rarity = SILVER;\n        } else if (raritySlot < (remainingSilver + remainingGold)) {\n          rarity = GOLD;\n        } else {\n          rarity = BLACKGOLD;\n        }\n\n        purchasedRarity[j] = rarity;\n        amountPerRarity[j] = 1; \n        mintedRarity[rarity]++;\n\n      }\n\n      // BURN UNKNOWN NFT;\n      token.burn(receiver, UNKNOWN, amount);\n\n      // MINT NFT in Batch;\n      token.mintBatch(receiver, purchasedRarity, amountPerRarity, \"0x0\");\n\n    }\n\n    emit AllocateRarity(receivers, amounts, block.timestamp);\n\n  }","after":"function allocateRarity(uint256[] calldata amounts, address[] calldata receivers) external onlyOwner nonReentrant {\n\n    require(amounts.length == receivers.length, \"amounts and receivers length mismatch\");\n    require(block.timestamp > salesEndPeriod, \"Rarity can not be distributed now\");\n\n    uint256 randomNumber = uint256(blockhash(block.number - 1) ^ blockhash(block.number - 2) ^ blockhash(block.number - 3));\n\n    for (uint256 i = 0; i < receivers.length; i++) {\n      \n      address receiver = receivers[i];\n      uint256 amount = amounts[i];\n\n      uint256[] memory purchasedRarity = new uint[](amount);\n      uint256[] memory amountPerRarity = new uint[](amount);\n\n      require(receiver != address(0), \"Not a valid address\");\n      require(amount != 0, \"Rarity mint amount can not be zero\");\n\n      for (uint256 j = 0; j < amount; j++) {\n\n        // There will be mathemtical overflow below, which is fine we want it.\n        unchecked {\n          randomNumber += uint256(blockhash(block.number - 4));  \n        }\n\n        uint256 remainingSilver = (MAX_TOTAL_SILVER - mintedRarity[SILVER]);\n        uint256 remainingGold = (MAX_TOTAL_GOLD - mintedRarity[GOLD]);\n        uint256 remainingBlackgold = (MAX_TOTAL_BLACKGOLD - mintedRarity[BLACKGOLD]);\n\n        uint256 remainingSupply = remainingSilver + remainingGold + remainingBlackgold;\n\n        uint256 raritySlot = (randomNumber % remainingSupply);\n\n        uint256 rarity;\n        \n        if (raritySlot < remainingSilver) {\n          rarity = SILVER;\n        } else if (raritySlot < (remainingSilver + remainingGold)) {\n          rarity = GOLD;\n        } else {\n          rarity = BLACKGOLD;\n        }\n\n        purchasedRarity[j] = rarity;\n        amountPerRarity[j] = 1; \n        mintedRarity[rarity]++;\n\n      }\n\n      // BURN UNKNOWN NFT;\n      token.burn(receiver, UNKNOWN, amount);\n\n      // MINT NFT in Batch;\n      token.mintBatch(receiver, purchasedRarity, amountPerRarity, \"0x0\");\n\n    }\n\n    emit AllocateRarity(receivers, amounts, block.timestamp);\n\n  }","contract":"GaiminICO","time":0},{"type":"external-function ","before":"function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","after":"function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","contract":"GaiminICO","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","after":"function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","contract":"GaiminICO","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public rarityPrice;","after":"uint256 public immutable rarityPrice;","contract":"GaiminICO","time":0}]}