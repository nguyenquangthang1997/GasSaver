{"time":143,"results":[{"type":"de-morgan-condition ","before":"!collectionIsPaused(_collectionId) && !pauseAllCollection","after":"!(collectionIsPaused(_collectionId) && pauseAllCollection)","loc":{"start":{"line":96,"column":16},"end":{"line":96,"column":55}},"contract":"MekaVerseAirdrop","time":0},{"type":"external-function ","before":"function addCollection(ClaimCollection memory _collection) external onlyOwner {\r\n        collectionIndex += 1;\r\n        collections[collectionIndex] = _collection;\r\n    }","after":"function addCollection(ClaimCollection calldata _collection) external onlyOwner {\r\n        collectionIndex += 1;\r\n        collections[collectionIndex] = _collection;\r\n    }","contract":"MekaVerseAirdrop","time":0},{"type":"external-function ","before":"function editCollection(uint256 _collectionId, ClaimCollection memory _collection) external onlyOwner {\r\n        require(_collectionId <= collectionIndex, \"Collection does not exist\");\r\n        collections[_collectionId] = _collection;\r\n    }","after":"function editCollection(uint256 _collectionId, ClaimCollection calldata _collection) external onlyOwner {\r\n        require(_collectionId <= collectionIndex, \"Collection does not exist\");\r\n        collections[_collectionId] = _collection;\r\n    }","contract":"MekaVerseAirdrop","time":0},{"type":"external-function ","before":"function claim(address _to, uint256 _collectionId, uint256[] memory _tokensId) public collectionIsOpen(_collectionId) {\r\n        require(!collections[_collectionId].canExternal, \"Reserve MekaVerse Holder\");\r\n\r\n        for (uint256 i = 0; i < _tokensId.length; i++) {\r\n            uint256 _tokenId = _tokensId[i];\r\n            require(canClaim(_collectionId, _tokenId), \"Token already used\");\r\n            require(mekaverse.ownerOf(_tokenId) == _msgSender(), \"Bad owner!\");\r\n            tokenIsUsed[_collectionId][_tokenId] = true;\r\n        }\r\n\r\n        _mintToken(_to, collections[_collectionId].tokenId, _tokensId.length);\r\n    }","after":"function claim(address _to, uint256 _collectionId, uint256[] calldata _tokensId) public collectionIsOpen(_collectionId) {\r\n        require(!collections[_collectionId].canExternal, \"Reserve MekaVerse Holder\");\r\n\r\n        for (uint256 i = 0; i < _tokensId.length; i++) {\r\n            uint256 _tokenId = _tokensId[i];\r\n            require(canClaim(_collectionId, _tokenId), \"Token already used\");\r\n            require(mekaverse.ownerOf(_tokenId) == _msgSender(), \"Bad owner!\");\r\n            tokenIsUsed[_collectionId][_tokenId] = true;\r\n        }\r\n\r\n        _mintToken(_to, collections[_collectionId].tokenId, _tokensId.length);\r\n    }","contract":"MekaVerseAirdrop","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"MekaVerseAirdrop","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"MekaVerseAirdrop","time":0},{"type":"external-function ","before":"function setAllowedContract(address _contract, uint256[] memory _collectionIds, bool _allowed) public onlyOwner {\r\n        for(uint256 i = 0; i < _collectionIds.length; i++){\r\n            allowedContracts[_contract][ _collectionIds[i] ] = _allowed;\r\n        }\r\n    }","after":"function setAllowedContract(address _contract, uint256[] calldata _collectionIds, bool _allowed) public onlyOwner {\r\n        for(uint256 i = 0; i < _collectionIds.length; i++){\r\n            allowedContracts[_contract][ _collectionIds[i] ] = _allowed;\r\n        }\r\n    }","contract":"MekaVerseAirdrop","time":0}]}