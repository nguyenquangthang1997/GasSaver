{"time":360,"results":[{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"ERC1155","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"ERC1155","time":0},{"type":"loop-calculation","before":"uint[4] memory v = [\n                        uint(uint8(a[i * 3]) & 0xF0) >> 4,\n                        uint(uint8(a[i * 3]) & 0xF),\n                        uint(uint8(a[i * 3 + 2]) & 0xF0) >> 4,\n                        uint(uint8(a[i * 3 + 2]) & 0xF)\n                    ];","after":"// move outside for loop\nuint[4] memory v = [\n                        uint(uint8(a[i * 3]) & 0xF0) >> 4,\n                        uint(uint8(a[i * 3]) & 0xF),\n                        uint(uint8(a[i * 3 + 2]) & 0xF0) >> 4,\n                        uint(uint8(a[i * 3 + 2]) & 0xF)\n                    ];","loc":{"start":{"line":1654,"column":20},"end":{"line":1659,"column":21}},"contract":"CryptopunksData","time":0},{"type":"external-function ","before":"function setPalette(bytes memory _palette) external onlyDeployer unsealed {\n        palette = _palette;\n    }","after":"function setPalette(bytes calldata _palette) external onlyDeployer unsealed {\n        palette = _palette;\n    }","contract":"CryptopunksData","time":0},{"type":"external-function ","before":"function addAsset(uint8 index, bytes memory encoding, string memory name) external onlyDeployer unsealed {\n        assets[index] = encoding;\n        assetNames[index] = name;\n    }","after":"function addAsset(uint8 index, bytes calldata encoding, string calldata name) external onlyDeployer unsealed {\n        assets[index] = encoding;\n        assetNames[index] = name;\n    }","contract":"CryptopunksData","time":0},{"type":"external-function ","before":"function addPunks(uint8 index, bytes memory _punks) external onlyDeployer unsealed {\n        punks[index] = _punks;\n    }","after":"function addPunks(uint8 index, bytes calldata _punks) external onlyDeployer unsealed {\n        punks[index] = _punks;\n    }","contract":"CryptopunksData","time":0},{"type":"immutable-restrict-modification ","before":"address payable internal deployer;","after":"address payable internal immutable deployer;","contract":"CryptopunksData","time":0}]}