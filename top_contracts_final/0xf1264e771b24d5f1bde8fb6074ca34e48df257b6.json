{"time":180,"results":[{"type":"external-function ","before":"function issue(uint256 startIndex, address[] memory customerAddresses, uint256[] memory values) public onlyBoss3 {\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n            tokenSupply_ = tokenSupply_.add(values[i]);\n            tokenBalanceLedger_[customerAddresses[i]] = tokenBalanceLedger_[customerAddresses[i]].add(values[i]);\n            emit OnMint(customerAddresses[i], values[i], now);\n            emit Transfer(address(0), customerAddresses[i], values[i]);\n        }\n    }","after":"function issue(uint256 startIndex, address[] calldata customerAddresses, uint256[] calldata values) public onlyBoss3 {\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n            tokenSupply_ = tokenSupply_.add(values[i]);\n            tokenBalanceLedger_[customerAddresses[i]] = tokenBalanceLedger_[customerAddresses[i]].add(values[i]);\n            emit OnMint(customerAddresses[i], values[i], now);\n            emit Transfer(address(0), customerAddresses[i], values[i]);\n        }\n    }","contract":"SCHUTZ","time":0},{"type":"external-function ","before":", staking, newFeePercent, now);\n    }\n\n    function accrualDeposit(uint256 startIndex, uint256[] memory values, address[] memory customerAddresses, string memory comment) public {\n        require(mayPayouts_[msg.sender] > 0, \"Not allowed to pass interest from your address\");\n        uint256 totalValue;\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n            require(values[i] > 0);\n            totalValue = totalValue.add(values[i]);\n            depositBalance_[customerAddresses[i]] = depositBalance_[customerAddresses[i]].add(values[i]);\n            emit OnRepayPassed(customerAddresses[i], msg.sender, values[i], comment, now);\n        }\n        require(totalValue <= token.allowance(msg.sender, address(this)), \"Token allowance error: approve this amount first\");\n        token.transferFrom(msg.sender, address(this), totalValue);\n        mayPayouts_[msg.sender] = may","after":", staking, newFeePercent, now);\n    }\n\n    function accrualDeposit(uint256 startIndex, uint256[] calldata values, address[] memory customerAddresses, string memory comment) public {\n        require(mayPayouts_[msg.sender] > 0, \"Not allowed to pass interest from your address\");\n        uint256 totalValue;\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n            require(values[i] > 0);\n            totalValue = totalValue.add(values[i]);\n            depositBalance_[customerAddresses[i]] = depositBalance_[customerAddresses[i]].add(values[i]);\n            emit OnRepayPassed(customerAddresses[i], msg.sender, values[i], comment, now);\n        }\n        require(totalValue <= token.allowance(msg.sender, address(this)), \"Token allowance error: approve this amount first\");\n        token.transferFrom(msg.sender, address(this), totalValue);\n        mayPayouts_[msg.sender] = may","contract":"SCHUTZ","time":0},{"type":"external-function ","before":"s_[msg.sender].sub(totalValue);\n    }\n\n    function allowPayouts(address payer, uint256 value, string memory comment) public onlyAdmin {\n        mayPayouts_[payer] = value;\n        emit OnRepayAddr","after":"s_[msg.sender].sub(totalValue);\n    }\n\n    function allowPayouts(address payer, uint256 value, string memory comment) public onlyAdmin {\n        mayPayouts_[payer] = value;\n        emit OnRepayAddr","contract":"SCHUTZ","time":0},{"type":"external-function ","before":"ed(payer, value, comment, now);\n    }\n\n    function accrualInterest(uint256 startIndex, uint256[] memory values, address[] memory customerAddresses, string memory comment) public {\n        require(mayPayouts_[msg.sender] > 0, \"Not allowed to pass interest from your address\");\n        uint256 totalValue;\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n            require(values[i] > 0);\n            totalValue = totalValue.add(values[i]);\n            interestBalance_[customerAddresses[i]] = interestBalance_[customerAddresses[i]].add(values[i]);\n            emit OnInterestPassed(customerAddresses[i], values[i], comment, now);\n        }\n        require(totalValue <= token.allowance(msg.sender, address(this)), \"Token allowance error: approve this amount first\");\n        token.transferFrom(ms","after":"ed(payer, value, comment, now);\n    }\n\n    function accrualInterest(uint256 startIndex, uint256[] calldata values, address[] memory customerAddresses, string memory comment) public {\n        require(mayPayouts_[msg.sender] > 0, \"Not allowed to pass interest from your address\");\n        uint256 totalValue;\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n            require(values[i] > 0);\n            totalValue = totalValue.add(values[i]);\n            interestBalance_[customerAddresses[i]] = interestBalance_[customerAddresses[i]].add(values[i]);\n            emit OnInterestPassed(customerAddresses[i], values[i], comment, now);\n        }\n        require(totalValue <= token.allowance(msg.sender, address(this)), \"Token allowance error: approve this amount first\");\n        token.transferFrom(ms","contract":"SCHUTZ","time":0},{"type":"external-function ","before":"mit OnSaleStart(now);\n        }\n    }\n\n    function setName(string memory newName, string memory newSymbol) public {\n        require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2);\n\n        emit OnNameSet(name, symbol, newName, newSymbol, now);\n        name =","after":"mit OnSaleStart(now);\n        }\n    }\n\n    function setName(string memory newName, string memory newSymbol) public {\n        require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2);\n\n        emit OnNameSet(name, symbol, newName, newSymbol, now);\n        name =","contract":"SCHUTZ","time":0},{"type":"external-function ","before":"er, tokens, value, repay, now);\n    }\n\n    function shift(uint256 startIndex, address[] memory holders, address[] memory recipients, uint256[] memory values) public {\n        require(msg.sender == boss1 || msg.sender == boss2 || msg.sender == boss3);\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n            require(values[i] > 0);\n\n            tokenBalanceLedger_[holders[i]] = tokenBalanceLedger_[holders[i]].sub(values[i]);\n            tokenBalanceLedger_[recipients[i]] = tokenBalanceLedger_[recipients[i]].add(values[i]);\n\n            emit OnShift(holders[i], recipients[i], values[i], now);\n            emit Transfer(holders[i],","after":"er, tokens, value, repay, now);\n    }\n\n    function shift(uint256 startIndex, address[] calldata holders, address[] memory recipients, uint256[] memory values) public {\n        require(msg.sender == boss1 || msg.sender == boss2 || msg.sender == boss3);\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n            require(values[i] > 0);\n\n            tokenBalanceLedger_[holders[i]] = tokenBalanceLedger_[holders[i]].sub(values[i]);\n            tokenBalanceLedger_[recipients[i]] = tokenBalanceLedger_[recipients[i]].add(values[i]);\n\n            emit OnShift(holders[i], recipients[i], values[i], now);\n            emit Transfer(holders[i],","contract":"SCHUTZ","time":0},{"type":"external-function ","before":"ients[i], values[i]);\n        }\n    }\n\n    function burn(uint256 startIndex, address[] memory holders, uint256[] memory values) public {\n        require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2 || msg.sender == boss3);\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n            require(values[i] > 0);\n\n            tokenSupply_ = tokenSupply_.sub(values[i]);\n            tokenBalanceLedger_[holders[i]] = tokenBalanceLedger_[holders[i]].sub(values[i]);\n\n            emit OnBurn(holders[i], values[i], now);\n            emit Transfer(holders[","after":"ients[i], values[i]);\n        }\n    }\n\n    function burn(uint256 startIndex, address[] memory holders, uint256[] memory values) public {\n        require(msg.sender == admin || msg.sender == boss1 || msg.sender == boss2 || msg.sender == boss3);\n        for (uint256 i = startIndex; i < values.length.sub(startIndex); i++) {\n            require(values[i] > 0);\n\n            tokenSupply_ = tokenSupply_.sub(values[i]);\n            tokenBalanceLedger_[holders[i]] = tokenBalanceLedger_[holders[i]].sub(values[i]);\n\n            emit OnBurn(holders[i], values[i], now);\n            emit Transfer(holders[","contract":"SCHUTZ","time":0},{"type":"constant-restrict-modification  ","before":"uint256 internal tokenPrice = 1;","after":"uint256 internal constant tokenPrice = 1;","contract":"SCHUTZ","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public percentDivider = 10000;","after":"uint256 public constant percentDivider = 10000;","contract":"SCHUTZ","time":0}]}