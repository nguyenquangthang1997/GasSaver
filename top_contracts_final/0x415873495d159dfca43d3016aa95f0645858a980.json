{"time":233,"results":[{"type":"external-function ","before":"   function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public returns (bool) {\n        bytes32 _tradeId = parseBytes(_extraData);\n        Trade memory trade = trades[_tradeId];\n        require(tradeCoins[trade.coinIndex].tokenAddress == _token, \"Invalid coin\");\n        require(trade.active == true, \"Trade not available\");\n        require(_value == trade.price, \"Invalid price\");\n        if (verifyTrade(_tradeId, trade.seller, trade.nftAddress, trade.assetId, trade.end)) {\n            uint256 tradeFee = feesContract.calcByToken(trade.seller, tradeCoins[trade.coinIndex].tokenAddress , _value); \n            executeTrade(_tradeId, _from, trade.seller, trade.nftAddress, trade.assetId);\n            IERC20 erc20Token = IERC20(_token); \n            if (tradeFee > 0) {\n                erc20Token.safeTransferFrom(_from, walletAddress, (tradeFee));\n                erc20Token.safeTransferFrom(_from, trade.seller, (trade.price-tradeFee));\n            } else {\n                erc20Token.safeTransferFrom(_from, trade.seller, (trade.price));\n            }\n            transferAsset(_from, trade.seller, trade.nftAddress, trade.assetId);\n            return (true);\n        } else {\n            return (false);\n        }\n\n  ","after":"   function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) public returns (bool) {\n        bytes32 _tradeId = parseBytes(_extraData);\n        Trade memory trade = trades[_tradeId];\n        require(tradeCoins[trade.coinIndex].tokenAddress == _token, \"Invalid coin\");\n        require(trade.active == true, \"Trade not available\");\n        require(_value == trade.price, \"Invalid price\");\n        if (verifyTrade(_tradeId, trade.seller, trade.nftAddress, trade.assetId, trade.end)) {\n            uint256 tradeFee = feesContract.calcByToken(trade.seller, tradeCoins[trade.coinIndex].tokenAddress , _value); \n            executeTrade(_tradeId, _from, trade.seller, trade.nftAddress, trade.assetId);\n            IERC20 erc20Token = IERC20(_token); \n            if (tradeFee > 0) {\n                erc20Token.safeTransferFrom(_from, walletAddress, (tradeFee));\n                erc20Token.safeTransferFrom(_from, trade.seller, (trade.price-tradeFee));\n            } else {\n                erc20Token.safeTransferFrom(_from, trade.seller, (trade.price));\n            }\n            transferAsset(_from, trade.seller, trade.nftAddress, trade.assetId);\n            return (true);\n        } else {\n            return (false);\n        }\n\n  ","contract":"Market","time":0},{"type":"external-function ","before":"   function adminCancelTrade(bytes32 _tradeId, bytes memory _sig) public isManager {\n        uint8 mId = 1;\n        bytes32 taskHash = keccak256(abi.encode(_tradeId, taskIndex, mId));\n        verifyApproval(taskHash, _sig);\n        Trade memory trade = trades[_tradeId];\n        trades[_tradeId].active = false;\n        userTrades[trade.seller].remove(_tradeId);\n        tradesMap.remove(trade.indexedBy);\n        tradingCheck[keccak256(abi.encode(trade.nftAddress, trade.assetId, trade.seller))] = false;\n  ","after":"   function adminCancelTrade(bytes32 _tradeId, bytes calldata _sig) public isManager {\n        uint8 mId = 1;\n        bytes32 taskHash = keccak256(abi.encode(_tradeId, taskIndex, mId));\n        verifyApproval(taskHash, _sig);\n        Trade memory trade = trades[_tradeId];\n        trades[_tradeId].active = false;\n        userTrades[trade.seller].remove(_tradeId);\n        tradesMap.remove(trade.indexedBy);\n        tradingCheck[keccak256(abi.encode(trade.nftAddress, trade.assetId, trade.seller))] = false;\n  ","contract":"Market","time":0},{"type":"external-function ","before":"   function addCoin(uint256 _coinIndex, address _tokenAddress, string memory _tokenSymbol, string memory _tokenName, bool _active, bytes memory _sig) public isManager {\n        uint8 mId = 2;\n        bytes32 taskHash = keccak256(abi.encode(_coinIndex, _tokenAddress, _tokenSymbol, _tokenName, _active, taskIndex, mId));\n        verifyApproval(taskHash, _sig);\n        tradeCoins[_coinIndex].tokenAddress = _tokenAddress;\n        tradeCoins[_coinIndex].symbol = _tokenSymbol;\n        tradeCoins[_coinIndex].name = _tokenName;\n        tradeCoins[_coinIndex].active = _active;\n  ","after":"   function addCoin(uint256 _coinIndex, address _tokenAddress, string calldata _tokenSymbol, string calldata _tokenName, bool _active, bytes calldata _sig) public isManager {\n        uint8 mId = 2;\n        bytes32 taskHash = keccak256(abi.encode(_coinIndex, _tokenAddress, _tokenSymbol, _tokenName, _active, taskIndex, mId));\n        verifyApproval(taskHash, _sig);\n        tradeCoins[_coinIndex].tokenAddress = _tokenAddress;\n        tradeCoins[_coinIndex].symbol = _tokenSymbol;\n        tradeCoins[_coinIndex].name = _tokenName;\n        tradeCoins[_coinIndex].active = _active;\n  ","contract":"Market","time":0},{"type":"external-function ","before":"   function authorizeNFT(address _nftAddress, bytes memory _sig) public isManager {\n        uint8 mId = 3;\n        bytes32 taskHash = keccak256(abi.encode(_nftAddress, taskIndex, mId));\n        verifyApproval(taskHash, _sig);\n        authorizedERC721[_nftAddress] = true;\n  ","after":"   function authorizeNFT(address _nftAddress, bytes calldata _sig) public isManager {\n        uint8 mId = 3;\n        bytes32 taskHash = keccak256(abi.encode(_nftAddress, taskIndex, mId));\n        verifyApproval(taskHash, _sig);\n        authorizedERC721[_nftAddress] = true;\n  ","contract":"Market","time":0},{"type":"external-function ","before":"   function deauthorizeNFT(address _nftAddress, bytes memory _sig) public isManager {\n        uint8 mId = 4;\n        bytes32 taskHash = keccak256(abi.encode(_nftAddress, taskIndex, mId));\n        verifyApproval(taskHash, _sig);\n        authorizedERC721[_nftAddress] = false;\n  ","after":"   function deauthorizeNFT(address _nftAddress, bytes calldata _sig) public isManager {\n        uint8 mId = 4;\n        bytes32 taskHash = keccak256(abi.encode(_nftAddress, taskIndex, mId));\n        verifyApproval(taskHash, _sig);\n        authorizedERC721[_nftAddress] = false;\n  ","contract":"Market","time":0},{"type":"external-function ","before":"   function setFeesContract(address _contract, bytes memory _sig) public isManager {\n        uint8 mId = 5;\n        bytes32 taskHash = keccak256(abi.encode(_contract, taskIndex, mId));\n        verifyApproval(taskHash, _sig);\n        feesContract = FeesContract(_contract);\n  ","after":"   function setFeesContract(address _contract, bytes calldata _sig) public isManager {\n        uint8 mId = 5;\n        bytes32 taskHash = keccak256(abi.encode(_contract, taskIndex, mId));\n        verifyApproval(taskHash, _sig);\n        feesContract = FeesContract(_contract);\n  ","contract":"Market","time":0},{"type":"external-function ","before":"   function setWallet(address _wallet, bytes memory _sig) public isManager  {\n        uint8 mId = 6;\n        bytes32 taskHash = keccak256(abi.encode(_wallet, taskIndex, mId));\n        verifyApproval(taskHash, _sig);\n        walletAddress = payable(_wallet);\n  ","after":"   function setWallet(address _wallet, bytes calldata _sig) public isManager  {\n        uint8 mId = 6;\n        bytes32 taskHash = keccak256(abi.encode(_wallet, taskIndex, mId));\n        verifyApproval(taskHash, _sig);\n        walletAddress = payable(_wallet);\n  ","contract":"Market","time":0},{"type":"external-function ","before":"   function changeManager(address _manager, uint8 _index, bytes memory _sig) public isManager {\n        require(_index >= 0 && _index <= 2, \"Invalid index\");\n        uint8 mId = 100;\n        bytes32 taskHash = keccak256(abi.encode(_manager, taskIndex, mId));\n        verifyApproval(taskHash, _sig);\n        managers[_index] = _manager;\n  ","after":"   function changeManager(address _manager, uint8 _index, bytes calldata _sig) public isManager {\n        require(_index >= 0 && _index <= 2, \"Invalid index\");\n        uint8 mId = 100;\n        bytes32 taskHash = keccak256(abi.encode(_manager, taskIndex, mId));\n        verifyApproval(taskHash, _sig);\n        managers[_index] = _manager;\n  ","contract":"Market","time":0}]}