{"time":100,"results":[{"type":"external-function ","before":"function sendMultiSig(\n        address toAddress,\n        uint256 value,\n        bytes memory data,\n        uint256 expireTime,\n        uint256 salt,\n        bytes memory signature1,\n        bytes memory signature2\n    ) external underLimit notInSafeMode {\n        // Verify that the transaction has not expired\n        require(expireTime > block.timestamp, \"transaction expired\");\n\n        // Verify the other signer\n        bytes32 operationHash = keccak256(abi.encodePacked(\"ETHER\", address(this), block.chainid, toAddress, value, data, expireTime, salt));\n\n        address[2] memory signerSet;\n        signerSet[0] = verifyMultiSig(operationHash, signature1);\n        signerSet[1] = verifyMultiSig(operationHash, signature2);\n\n        require(signerSet[0] != signerSet[1], \"can't sign by same signer\");\n\n        require(!historyTransactions[operationHash], \"Transaction has been executed\");\n        // Try to insert operationHash\n        historyTransactions[operationHash] = true;\n\n        // Success, send the transaction\n        if (!external_call(toAddress, value, data)) {\n            // Failed executing transaction\n            revert(\"execution failed\");\n        }\n        emit Transacted(msg.sender, signerSet, operationHash, toAddress, value, data);\n    }","after":"function sendMultiSig(\n        address toAddress,\n        uint256 value,\n        bytes calldata data,\n        uint256 expireTime,\n        uint256 salt,\n        bytes calldata signature1,\n        bytes calldata signature2\n    ) external underLimit notInSafeMode {\n        // Verify that the transaction has not expired\n        require(expireTime > block.timestamp, \"transaction expired\");\n\n        // Verify the other signer\n        bytes32 operationHash = keccak256(abi.encodePacked(\"ETHER\", address(this), block.chainid, toAddress, value, data, expireTime, salt));\n\n        address[2] memory signerSet;\n        signerSet[0] = verifyMultiSig(operationHash, signature1);\n        signerSet[1] = verifyMultiSig(operationHash, signature2);\n\n        require(signerSet[0] != signerSet[1], \"can't sign by same signer\");\n\n        require(!historyTransactions[operationHash], \"Transaction has been executed\");\n        // Try to insert operationHash\n        historyTransactions[operationHash] = true;\n\n        // Success, send the transaction\n        if (!external_call(toAddress, value, data)) {\n            // Failed executing transaction\n            revert(\"execution failed\");\n        }\n        emit Transacted(msg.sender, signerSet, operationHash, toAddress, value, data);\n    }","contract":"OperatorDoubleSig","time":0},{"type":"external-function ","before":"function sendMultiSigBundle(\n        address[] memory toAddresses,\n        uint256[] memory values,\n        bytes[] memory datas,\n        uint256 expireTime,\n        uint256[] memory salts,\n        bytes memory signature1,\n        bytes memory signature2\n    ) external underLimit notInSafeMode {\n        require(toAddresses.length <= BUNDLE_MAXIMUM && values.length <= BUNDLE_MAXIMUM && datas.length <= BUNDLE_MAXIMUM && salts.length <= BUNDLE_MAXIMUM, \"Exceed limit\");\n        require(toAddresses.length == datas.length && toAddresses.length == values.length && toAddresses.length == salts.length);\n        // Verify that the transaction has not expired\n        require(expireTime > block.timestamp, \"transaction expired\");\n\n        address[2] memory signerSet;\n        bytes32 bundleHash;\n\n        // \"{  }\" for avoid stack too deep errors\n        {\n            bytes memory packedData;\n            bytes memory packedAddress;\n            bytes memory packedValues;\n            bytes memory packedSalt;\n            for (uint256 i = 0; i < datas.length; i++) {\n                packedData = abi.encodePacked(packedData, datas[i]);\n                packedValues = abi.encodePacked(packedValues, values[i]);\n                packedAddress = abi.encodePacked(packedAddress, toAddresses[i]);\n                packedSalt = abi.encodePacked(packedSalt, salts[i]);\n            }\n            bytes32[4] memory hashes = [keccak256(packedAddress), keccak256(packedValues), keccak256(packedData), keccak256(packedSalt)];\n\n            // Verify the other signer\n            bundleHash = keccak256(abi.encodePacked(\"ETHER\", address(this), block.chainid, hashes[0], hashes[1], hashes[2], expireTime, hashes[3]));\n        }\n\n        {\n            signerSet[0] = verifyMultiSig(bundleHash, signature1);\n            signerSet[1] = verifyMultiSig(bundleHash, signature2);\n\n            require(signerSet[0] != signerSet[1], \"can't sign by same signer\");\n\n            // Success, send all transaction\n            for (uint256 i = 0; i < datas.length; i++) {\n                bytes32 operationHash = keccak256(abi.encodePacked(\"ETHER\", address(this), block.chainid, toAddresses[i], values[i], datas[i], expireTime, salts[i]));\n                require(!historyTransactions[operationHash], string(abi.encodePacked(\"[#\", toString(i) ,\"]Transaction has been executed\")));\n                // Try to insert operationHash\n                historyTransactions[operationHash] = true;\n\n                if (!external_call(toAddresses[i], values[i], datas[i])) {\n                    // Failed executing transaction\n                    revert(string(abi.encodePacked(\"[#\", toString(i) ,\"]execution failed\")));\n                }\n                emit Transacted(msg.sender, signerSet, operationHash, toAddresses[i], values[i], datas[i]);\n            }\n        }\n    }","after":"function sendMultiSigBundle(\n        address[] calldata toAddresses,\n        uint256[] calldata values,\n        bytes[] calldata datas,\n        uint256 expireTime,\n        uint256[] calldata salts,\n        bytes calldata signature1,\n        bytes calldata signature2\n    ) external underLimit notInSafeMode {\n        require(toAddresses.length <= BUNDLE_MAXIMUM && values.length <= BUNDLE_MAXIMUM && datas.length <= BUNDLE_MAXIMUM && salts.length <= BUNDLE_MAXIMUM, \"Exceed limit\");\n        require(toAddresses.length == datas.length && toAddresses.length == values.length && toAddresses.length == salts.length);\n        // Verify that the transaction has not expired\n        require(expireTime > block.timestamp, \"transaction expired\");\n\n        address[2] memory signerSet;\n        bytes32 bundleHash;\n\n        // \"{  }\" for avoid stack too deep errors\n        {\n            bytes memory packedData;\n            bytes memory packedAddress;\n            bytes memory packedValues;\n            bytes memory packedSalt;\n            for (uint256 i = 0; i < datas.length; i++) {\n                packedData = abi.encodePacked(packedData, datas[i]);\n                packedValues = abi.encodePacked(packedValues, values[i]);\n                packedAddress = abi.encodePacked(packedAddress, toAddresses[i]);\n                packedSalt = abi.encodePacked(packedSalt, salts[i]);\n            }\n            bytes32[4] memory hashes = [keccak256(packedAddress), keccak256(packedValues), keccak256(packedData), keccak256(packedSalt)];\n\n            // Verify the other signer\n            bundleHash = keccak256(abi.encodePacked(\"ETHER\", address(this), block.chainid, hashes[0], hashes[1], hashes[2], expireTime, hashes[3]));\n        }\n\n        {\n            signerSet[0] = verifyMultiSig(bundleHash, signature1);\n            signerSet[1] = verifyMultiSig(bundleHash, signature2);\n\n            require(signerSet[0] != signerSet[1], \"can't sign by same signer\");\n\n            // Success, send all transaction\n            for (uint256 i = 0; i < datas.length; i++) {\n                bytes32 operationHash = keccak256(abi.encodePacked(\"ETHER\", address(this), block.chainid, toAddresses[i], values[i], datas[i], expireTime, salts[i]));\n                require(!historyTransactions[operationHash], string(abi.encodePacked(\"[#\", toString(i) ,\"]Transaction has been executed\")));\n                // Try to insert operationHash\n                historyTransactions[operationHash] = true;\n\n                if (!external_call(toAddresses[i], values[i], datas[i])) {\n                    // Failed executing transaction\n                    revert(string(abi.encodePacked(\"[#\", toString(i) ,\"]execution failed\")));\n                }\n                emit Transacted(msg.sender, signerSet, operationHash, toAddresses[i], values[i], datas[i]);\n            }\n        }\n    }","contract":"OperatorDoubleSig","time":0}]}