{"time":254,"results":[{"type":"state-data-arrangement ","before":"\n\n\n    uint128 internal PUBLIC_SUPPLY =\n.\n    uint128 internal MAX_SUPPLY = \n;\n    uint128 public PUBLIC_MINT_LIMIT\n;\n    uint128 public PRESALE_MINT_LIMI\n;\n    uint128 public PRESALE_PRICE = 0.08 \n;\n    uint128 public PUBLIC_PRICE = 0.09 \ng\n    bool public publicWalletLimit =\n;\n    bool public isPresale =\n;\n    bool public isRevealed = \n\n\n    string public PROVENANCE\n\n\n    mapping(address => uint256) public mintBal\n\n\n    uint256 public tokenO\n;\n    string internal baseTok\n;\n    address[] internal p\n;\n    address internal _S\ny\n    address private immutable _proxyRegistryAd\nK\n    uint256 internal LIN\n;\n    bytes32 internal LINK_KEY","after":"\n\n    string public PROVENANCE\n\n\n    mapping(address => uint256) public mintBal\n\n\n    uint256 public tokenO\n;\n    string internal baseTok\n;\n    address[] internal p\nK\n    uint256 internal LIN\n;\n    bytes32 internal LINK_KEY\n;\n    address internal _S\ny\n    address private immutable _proxyRegistryAd\n\n\n    uint128 internal PUBLIC_SUPPLY =\n.\n    uint128 internal MAX_SUPPLY = \n;\n    uint128 public PUBLIC_MINT_LIMIT\n;\n    uint128 public PRESALE_MINT_LIMI\n;\n    uint128 public PRESALE_PRICE = 0.08 \n;\n    uint128 public PUBLIC_PRICE = 0.09 \ng\n    bool public publicWalletLimit =\n;\n    bool public isPresale =\n;\n    bool public isRevealed = \n","contract":"Strange","time":32},{"type":"external-function ","before":"\n\n    function presalePurchase(\n        uint256 _quantity,\n        bytes32 _hash,\n        bytes memory _signature\n    ) external payable override nonReentrant whenNotPaused {\n        require(\n            checkHash(_hash, _signature, _SIGNER),\n            \"Address is not on Presale List\"\n        );\n        // @dev Presale always enforces a per-wallet limit\n        require(\n            _quantity + mintBalances[msg.sender] <= PRESALE_MINT_LIMIT,\n            \"Quantity exceeds per-wallet limit\"\n        );\n        require(_quantity * PRESALE_PRICE <= msg.value, \"Not enough minerals\");\n\n        _mint(_quantity);","after":"\n\n    function presalePurchase(\n        uint256 _quantity,\n        bytes32 _hash,\n        bytes calldata _signature\n    ) external payable override nonReentrant whenNotPaused {\n        require(\n            checkHash(_hash, _signature, _SIGNER),\n            \"Address is not on Presale List\"\n        );\n        // @dev Presale always enforces a per-wallet limit\n        require(\n            _quantity + mintBalances[msg.sender] <= PRESALE_MINT_LIMIT,\n            \"Quantity exceeds per-wallet limit\"\n        );\n        require(_quantity * PRESALE_PRICE <= msg.value, \"Not enough minerals\");\n\n        _mint(_quantity);","contract":"Strange","time":0},{"type":"external-function ","before":"\n\n    function setProvenance(string memory _provenance)\n        external\n        override\n        onlyOwner\n    {\n        PROVENANCE_HASH = _provenance;","after":"\n\n    function setProvenance(string calldata _provenance)\n        external\n        override\n        onlyOwner\n    {\n        PROVENANCE_HASH = _provenance;","contract":"Strange","time":0},{"type":"external-function ","before":"\n\n    function setBaseURI(string memory _URI) external override onlyOwner {\n        baseTokenURI = _URI;","after":"\n\n    function setBaseURI(string memory _URI) external override onlyOwner {\n        baseTokenURI = _URI;","contract":"Strange","time":0},{"type":"external-function ","before":"\n\n    function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;","after":"\n\n    function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;","contract":"Strange","time":0},{"type":"constant-restrict-modification  ","before":"\n\n    uint128 internal PUBLIC_SUPPLY =","after":"\n\n    uint128 internal constant PUBLIC_SUPPLY =","contract":"Strange","time":1},{"type":"constant-restrict-modification  ","before":".\n    uint128 internal MAX_SUPPLY = ","after":".\n    uint128 internal constant MAX_SUPPLY = ","contract":"Strange","time":1},{"type":"immutable-restrict-modification ","before":"K\n    uint256 internal LIN","after":"K\n    uint256 internal LIN","contract":"Strange","time":1},{"type":"immutable-restrict-modification ","before":";\n    bytes32 internal LINK_KEY","after":";\n    bytes32 internal LINK_KEY","contract":"Strange","time":1}]}