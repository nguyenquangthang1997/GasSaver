{"time":180,"results":[{"type":"external-function ","before":"function setBaseTokenURI(string memory URI) public onlyOwner {\n        _baseTokenURI = URI;\n    }","after":"function setBaseTokenURI(string calldata URI) public onlyOwner {\n        _baseTokenURI = URI;\n    }","contract":"SparkleMuffinz","time":0},{"type":"external-function ","before":"function setUnrevealedTokenURI(string memory URI) public onlyOwner {\n        unrevealedTokenURI = URI;\n    }","after":"function setUnrevealedTokenURI(string calldata URI) public onlyOwner {\n        unrevealedTokenURI = URI;\n    }","contract":"SparkleMuffinz","time":0},{"type":"external-function ","before":"function reveal(string memory URI) public onlyOwner {\n        require(!revealed, \"NFTs already revealed\");\n        revealed = true;\n        _baseTokenURI = URI;\n    }","after":"function reveal(string calldata URI) public onlyOwner {\n        require(!revealed, \"NFTs already revealed\");\n        revealed = true;\n        _baseTokenURI = URI;\n    }","contract":"SparkleMuffinz","time":0},{"type":"external-function ","before":"function presaleMint(\n        uint256 amount,\n        uint256 totalAllocation,\n        bytes32 leaf,\n        bytes32[] memory proof\n    ) external payable {\n        require(presaleActive, \"Presale not active\");\n\n        // Create storage element tracking user mints if this is the first mint for them\n        if (!whitelistUsed[msg.sender]) {\n            // Verify that (msg.sender, amount) correspond to Merkle leaf\n            require(\n                keccak256(abi.encodePacked(msg.sender, totalAllocation)) == leaf,\n                \"Sender and amount don't match Merkle leaf\"\n            );\n\n            // Verify that (leaf, proof) matches the Merkle root\n            require(verify(merkleRoot, leaf, proof), \"Not a valid leaf in the Merkle tree\");\n\n            whitelistUsed[msg.sender] = true;\n            whitelistRemaining[msg.sender] = totalAllocation;\n        }\n\n        require(amount > 0, \"Invalid mint amount\");\n        require(msg.value >= amount * mintPrice, \"Not enough ETH sent\");\n        require(whitelistRemaining[msg.sender] >= amount, \"Can't mint more than remaining allocation\");\n\n        whitelistRemaining[msg.sender] -= amount;\n        _mintWithoutValidation(msg.sender, amount);\n    }","after":"function presaleMint(\n        uint256 amount,\n        uint256 totalAllocation,\n        bytes32 leaf,\n        bytes32[] calldata proof\n    ) external payable {\n        require(presaleActive, \"Presale not active\");\n\n        // Create storage element tracking user mints if this is the first mint for them\n        if (!whitelistUsed[msg.sender]) {\n            // Verify that (msg.sender, amount) correspond to Merkle leaf\n            require(\n                keccak256(abi.encodePacked(msg.sender, totalAllocation)) == leaf,\n                \"Sender and amount don't match Merkle leaf\"\n            );\n\n            // Verify that (leaf, proof) matches the Merkle root\n            require(verify(merkleRoot, leaf, proof), \"Not a valid leaf in the Merkle tree\");\n\n            whitelistUsed[msg.sender] = true;\n            whitelistRemaining[msg.sender] = totalAllocation;\n        }\n\n        require(amount > 0, \"Invalid mint amount\");\n        require(msg.value >= amount * mintPrice, \"Not enough ETH sent\");\n        require(whitelistRemaining[msg.sender] >= amount, \"Can't mint more than remaining allocation\");\n\n        whitelistRemaining[msg.sender] -= amount;\n        _mintWithoutValidation(msg.sender, amount);\n    }","contract":"SparkleMuffinz","time":0}]}