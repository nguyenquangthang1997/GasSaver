{"time":188,"results":[{"type":"external-function ","before":"function Log(address _contract, address _caller, string memory _logName, bytes memory _data)\n        public\n    {\n        emit LogEvent(_contract, _caller, _logName, _data);\n    }","after":"function Log(address _contract, address _caller, string calldata _logName, bytes calldata _data)\n        public\n    {\n        emit LogEvent(_contract, _caller, _logName, _data);\n    }","contract":"DefisaverLogger","time":0},{"type":"external-function ","before":"function callExecute(address _owner, address _aaveSaverProxy, bytes memory _data) public payable onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute{value: msg.value}(_aaveSaverProxy, _data);\n\n        // return if anything left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }","after":"function callExecute(address _owner, address _aaveSaverProxy, bytes calldata _data) public payable onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute{value: msg.value}(_aaveSaverProxy, _data);\n\n        // return if anything left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }","contract":"AaveMonitorProxyV2","time":0},{"type":"struct-data-arrangement ","before":"\naddress user\nuint128 minRatio\nuint128 maxRatio\nuint128 optimalRatioBoost\nuint128 optimalRatioRepay\nbool boostEnabled","after":"address user\nuint128 minRatio\nuint128 maxRatio\nuint128 optimalRatioBoost\nuint128 optimalRatioRepay\nbool boostEnabled\n","contract":"AaveSubscriptionsV2","time":0},{"type":"external-function ","before":"function write(bytes memory _code) public returns (address target) {\n        assembly {\n            target := create(0, add(_code, 0x20), mload(_code))\n            switch iszero(extcodesize(target))\n                case 1 {\n                    // throw if contract failed to deploy\n                    revert(0, 0)\n                }\n        }\n        bytes32 hash = keccak256(_code);\n        cache[hash] = target;\n    }","after":"function write(bytes calldata _code) public returns (address target) {\n        assembly {\n            target := create(0, add(_code, 0x20), mload(_code))\n            switch iszero(extcodesize(target))\n                case 1 {\n                    // throw if contract failed to deploy\n                    revert(0, 0)\n                }\n        }\n        bytes32 hash = keccak256(_code);\n        cache[hash] = target;\n    }","contract":"DSProxyCache","time":0},{"type":"external-function ","before":"function repayFor(\n        DFSExchangeData.ExchangeData memory _exData,\n        address _user,\n        uint256 _rateMode,\n        uint256 _flAmount\n    ) public payable onlyApproved {\n        string memory errReason;\n        bool isAllowed;\n        uint256 ratioBefore;\n\n        AaveSubscriptionsV2.AaveHolder memory holder = subscriptionsContract.getHolder(_user);\n\n        (isAllowed, ratioBefore, errReason) = checkPreconditions(holder, Method.Repay, _user);\n        require(isAllowed, errReason); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(REPAY_GAS_COST);\n\n        aaveMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            aaveSaverProxy,\n            abi.encodeWithSignature(\n                \"repay(address,(address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256,uint256,uint256)\",\n                AAVE_MARKET_ADDRESS,\n                _exData,\n                _rateMode,\n                gasCost,\n                _flAmount\n            )\n        );\n\n        bool isGoodRatio;\n        uint256 ratioAfter;\n\n        (isGoodRatio, ratioAfter, errReason) = ratioGoodAfter(holder, Method.Repay, _user, ratioBefore);\n        require(isGoodRatio, errReason); // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticAaveRepayV2\", abi.encode(ratioBefore, ratioAfter));\n    }","after":"function repayFor(\n        DFSExchangeData.ExchangeData calldata _exData,\n        address _user,\n        uint256 _rateMode,\n        uint256 _flAmount\n    ) public payable onlyApproved {\n        string memory errReason;\n        bool isAllowed;\n        uint256 ratioBefore;\n\n        AaveSubscriptionsV2.AaveHolder memory holder = subscriptionsContract.getHolder(_user);\n\n        (isAllowed, ratioBefore, errReason) = checkPreconditions(holder, Method.Repay, _user);\n        require(isAllowed, errReason); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(REPAY_GAS_COST);\n\n        aaveMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            aaveSaverProxy,\n            abi.encodeWithSignature(\n                \"repay(address,(address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256,uint256,uint256)\",\n                AAVE_MARKET_ADDRESS,\n                _exData,\n                _rateMode,\n                gasCost,\n                _flAmount\n            )\n        );\n\n        bool isGoodRatio;\n        uint256 ratioAfter;\n\n        (isGoodRatio, ratioAfter, errReason) = ratioGoodAfter(holder, Method.Repay, _user, ratioBefore);\n        require(isGoodRatio, errReason); // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticAaveRepayV2\", abi.encode(ratioBefore, ratioAfter));\n    }","contract":"AaveMonitorV2","time":0},{"type":"external-function ","before":"function boostFor(\n        DFSExchangeData.ExchangeData memory _exData,\n        address _user,\n        uint256 _rateMode,\n        uint256 _flAmount\n    ) public payable onlyApproved {\n        string memory errReason;\n        bool isAllowed;\n        uint256 ratioBefore;\n\n        AaveSubscriptionsV2.AaveHolder memory holder = subscriptionsContract.getHolder(_user);\n\n        (isAllowed, ratioBefore, errReason) = checkPreconditions(holder, Method.Boost, _user);\n        require(isAllowed, errReason); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(BOOST_GAS_COST);\n\n        aaveMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            aaveSaverProxy,\n            abi.encodeWithSignature(\n                \"boost(address,(address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256,uint256,uint256)\",\n                AAVE_MARKET_ADDRESS,\n                _exData,\n                _rateMode,\n                gasCost,\n                _flAmount\n            )\n        );\n\n        bool isGoodRatio;\n        uint256 ratioAfter;\n\n        (isGoodRatio, ratioAfter, errReason) = ratioGoodAfter(holder, Method.Boost, _user, ratioBefore);\n        require(isGoodRatio, errReason);  // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticAaveBoostV2\", abi.encode(ratioBefore, ratioAfter));\n    }","after":"function boostFor(\n        DFSExchangeData.ExchangeData calldata _exData,\n        address _user,\n        uint256 _rateMode,\n        uint256 _flAmount\n    ) public payable onlyApproved {\n        string memory errReason;\n        bool isAllowed;\n        uint256 ratioBefore;\n\n        AaveSubscriptionsV2.AaveHolder memory holder = subscriptionsContract.getHolder(_user);\n\n        (isAllowed, ratioBefore, errReason) = checkPreconditions(holder, Method.Boost, _user);\n        require(isAllowed, errReason); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(BOOST_GAS_COST);\n\n        aaveMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            aaveSaverProxy,\n            abi.encodeWithSignature(\n                \"boost(address,(address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),uint256,uint256,uint256)\",\n                AAVE_MARKET_ADDRESS,\n                _exData,\n                _rateMode,\n                gasCost,\n                _flAmount\n            )\n        );\n\n        bool isGoodRatio;\n        uint256 ratioAfter;\n\n        (isGoodRatio, ratioAfter, errReason) = ratioGoodAfter(holder, Method.Boost, _user, ratioBefore);\n        require(isGoodRatio, errReason);  // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(address(this), _user, \"AutomaticAaveBoostV2\", abi.encode(ratioBefore, ratioAfter));\n    }","contract":"AaveMonitorV2","time":0}]}