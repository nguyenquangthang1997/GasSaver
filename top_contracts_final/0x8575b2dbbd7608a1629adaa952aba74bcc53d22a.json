{"time":138,"results":[{"type":"external-function ","before":"function setBaseURI(string memory URI) external onlyOwner {\n\t\trequire(!metadataIsFrozen, 'Metadata is permanently frozen');\n\t\t_tokenBaseURI = URI;\n\t}","after":"function setBaseURI(string calldata URI) external onlyOwner {\n\t\trequire(!metadataIsFrozen, 'Metadata is permanently frozen');\n\t\t_tokenBaseURI = URI;\n\t}","contract":"Human","time":0},{"type":"external-function ","before":"function disbursePayments(\n\t\taddress[] memory payees_,\n\t\tuint256[] memory amounts_\n\t) external onlyOwner {\n\t\trequire(\n\t\t\tpayees_.length == amounts_.length,\n\t\t\t'Payees and amounts length mismatch'\n\t\t);\n\t\tfor (uint256 i; i < payees_.length; i++) {\n\t\t\tmakePaymentTo(payees_[i], amounts_[i]);\n\t\t}\n\t}","after":"function disbursePayments(\n\t\taddress[] calldata payees_,\n\t\tuint256[] calldata amounts_\n\t) external onlyOwner {\n\t\trequire(\n\t\t\tpayees_.length == amounts_.length,\n\t\t\t'Payees and amounts length mismatch'\n\t\t);\n\t\tfor (uint256 i; i < payees_.length; i++) {\n\t\t\tmakePaymentTo(payees_[i], amounts_[i]);\n\t\t}\n\t}","contract":"Human","time":0},{"type":"external-function ","before":"function claimReservedTokensByIds(\n\t\taddress owner_,\n\t\tuint256[] calldata idxsToClaim,\n\t\tuint256[] calldata idsOfOwner,\n\t\tCoupon memory coupon\n\t) external {\n\t\trequire(claimActive, 'Claim event is not active');\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encode(CouponType.Genesis, idsOfOwner, owner_)\n\t\t);\n\t\trequire(_isVerifiedCoupon(digest, coupon), 'Invalid coupon');\n\n\t\tfor (uint256 i; i < idxsToClaim.length; i++) {\n\t\t\tuint256 tokenId = idsOfOwner[idxsToClaim[i]];\n\t\t\t_claimReservedToken(owner_, tokenId);\n\t\t}\n\t}","after":"function claimReservedTokensByIds(\n\t\taddress owner_,\n\t\tuint256[] calldata idxsToClaim,\n\t\tuint256[] calldata idsOfOwner,\n\t\tCoupon calldata coupon\n\t) external {\n\t\trequire(claimActive, 'Claim event is not active');\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encode(CouponType.Genesis, idsOfOwner, owner_)\n\t\t);\n\t\trequire(_isVerifiedCoupon(digest, coupon), 'Invalid coupon');\n\n\t\tfor (uint256 i; i < idxsToClaim.length; i++) {\n\t\t\tuint256 tokenId = idsOfOwner[idxsToClaim[i]];\n\t\t\t_claimReservedToken(owner_, tokenId);\n\t\t}\n\t}","contract":"Human","time":0},{"type":"external-function ","before":"function claimAuthorTokens(\n\t\tuint256 count,\n\t\tuint256 allotted,\n\t\tCoupon memory coupon\n\t) public ensureAvailabilityFor(count) {\n\t\trequire(claimActive, 'Claim event is not active');\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encode(CouponType.Author, allotted, msg.sender)\n\t\t);\n\t\trequire(_isVerifiedCoupon(digest, coupon), 'Invalid coupon');\n\t\trequire(\n\t\t\tcount + addressToMints[msg.sender]._numberOfAuthorMintsByAddress <=\n\t\t\t\tallotted,\n\t\t\t'Exceeds number of earned Tokens'\n\t\t);\n\t\taddressToMints[msg.sender]._numberOfAuthorMintsByAddress += count;\n\t\tfor (uint256 i; i < count; i++) {\n\t\t\t_mintRandomId(msg.sender);\n\t\t}\n\t}","after":"function claimAuthorTokens(\n\t\tuint256 count,\n\t\tuint256 allotted,\n\t\tCoupon calldata coupon\n\t) public ensureAvailabilityFor(count) {\n\t\trequire(claimActive, 'Claim event is not active');\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encode(CouponType.Author, allotted, msg.sender)\n\t\t);\n\t\trequire(_isVerifiedCoupon(digest, coupon), 'Invalid coupon');\n\t\trequire(\n\t\t\tcount + addressToMints[msg.sender]._numberOfAuthorMintsByAddress <=\n\t\t\t\tallotted,\n\t\t\t'Exceeds number of earned Tokens'\n\t\t);\n\t\taddressToMints[msg.sender]._numberOfAuthorMintsByAddress += count;\n\t\tfor (uint256 i; i < count; i++) {\n\t\t\t_mintRandomId(msg.sender);\n\t\t}\n\t}","contract":"Human","time":0},{"type":"external-function ","before":"function mintPresale(uint256 count, Coupon memory coupon)\n\t\texternal\n\t\tpayable\n\t\tensureAvailabilityFor(count)\n\t\tvalidateEthPayment(count)\n\t{\n\t\trequire(phase == SalePhase.PreSale, 'Presale event is not active');\n\t\trequire(\n\t\t\tcount + addressToMints[msg.sender]._numberOfMintsByAddress <=\n\t\t\t\tMAX_PRESALE_MINTS_PER_ADDRESS,\n\t\t\t'Exceeds number of presale mints allowed'\n\t\t);\n\t\tbytes32 digest = keccak256(abi.encode(CouponType.Presale, msg.sender));\n\t\trequire(_isVerifiedCoupon(digest, coupon), 'Invalid coupon');\n\n\t\taddressToMints[msg.sender]._numberOfMintsByAddress += count;\n\n\t\tfor (uint256 i; i < count; i++) {\n\t\t\t_mintRandomId(msg.sender);\n\t\t}\n\t}","after":"function mintPresale(uint256 count, Coupon calldata coupon)\n\t\texternal\n\t\tpayable\n\t\tensureAvailabilityFor(count)\n\t\tvalidateEthPayment(count)\n\t{\n\t\trequire(phase == SalePhase.PreSale, 'Presale event is not active');\n\t\trequire(\n\t\t\tcount + addressToMints[msg.sender]._numberOfMintsByAddress <=\n\t\t\t\tMAX_PRESALE_MINTS_PER_ADDRESS,\n\t\t\t'Exceeds number of presale mints allowed'\n\t\t);\n\t\tbytes32 digest = keccak256(abi.encode(CouponType.Presale, msg.sender));\n\t\trequire(_isVerifiedCoupon(digest, coupon), 'Invalid coupon');\n\n\t\taddressToMints[msg.sender]._numberOfMintsByAddress += count;\n\n\t\tfor (uint256 i; i < count; i++) {\n\t\t\t_mintRandomId(msg.sender);\n\t\t}\n\t}","contract":"Human","time":0},{"type":"external-function ","before":"function onERC1155Received(\n\t\taddress,\n\t\taddress from,\n\t\tuint256 id,\n\t\tuint256,\n\t\tbytes memory data\n\t) public virtual override returns (bytes4) {\n\t\trequire(\n\t\t\tmsg.sender == _openseaSharedContractAddress,\n\t\t\t'Sender not approved'\n\t\t);\n\t\t(uint256 genesisId, Coupon memory coupon) = abi.decode(\n\t\t\tdata,\n\t\t\t(uint256, Coupon)\n\t\t);\n\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encode(CouponType.Genesis, genesisId, id)\n\t\t);\n\t\trequire(_isVerifiedCoupon(digest, coupon), 'Invalid coupon');\n\t\t_claimReservedToken(from, genesisId);\n\t\treturn this.onERC1155Received.selector;\n\t}","after":"function onERC1155Received(\n\t\taddress,\n\t\taddress from,\n\t\tuint256 id,\n\t\tuint256,\n\t\tbytes calldata data\n\t) public virtual override returns (bytes4) {\n\t\trequire(\n\t\t\tmsg.sender == _openseaSharedContractAddress,\n\t\t\t'Sender not approved'\n\t\t);\n\t\t(uint256 genesisId, Coupon memory coupon) = abi.decode(\n\t\t\tdata,\n\t\t\t(uint256, Coupon)\n\t\t);\n\n\t\tbytes32 digest = keccak256(\n\t\t\tabi.encode(CouponType.Genesis, genesisId, id)\n\t\t);\n\t\trequire(_isVerifiedCoupon(digest, coupon), 'Invalid coupon');\n\t\t_claimReservedToken(from, genesisId);\n\t\treturn this.onERC1155Received.selector;\n\t}","contract":"Human","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(\n\t\taddress,\n\t\taddress,\n\t\tuint256[] memory,\n\t\tuint256[] memory,\n\t\tbytes memory\n\t) public override returns (bytes4) {\n\t\trevert('Batch Receiving not allowed.');\n\t}","after":"function onERC1155BatchReceived(\n\t\taddress,\n\t\taddress,\n\t\tuint256[] calldata,\n\t\tuint256[] calldata,\n\t\tbytes calldata\n\t) public override returns (bytes4) {\n\t\trevert('Batch Receiving not allowed.');\n\t}","contract":"Human","time":0},{"type":"external-function ","before":"function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","after":"function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","contract":"Human","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","after":"function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","contract":"Human","time":0},{"type":"constant-restrict-modification  ","before":"address private immutable _teamAddress =\n\t\t0x5ad0A1eA6d7863c3930a0125bC22770A358Ebee9;","after":"address private immutable constant _teamAddress =\n\t\t0x5ad0A1eA6d7863c3930a0125bC22770A358Ebee9;","contract":"Human","time":0}]}