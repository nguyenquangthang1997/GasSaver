{"time":141,"results":[{"type":"external-function ","before":"function setPresaleAccessList(address[] memory _addressList) public onlyOwner {\r\n        for (uint256 i; i < _addressList.length; i++) {\r\n            presaleAccessList[_addressList[i]] = true;\r\n        }\r\n    }","after":"function setPresaleAccessList(address[] calldata _addressList) public onlyOwner {\r\n        for (uint256 i; i < _addressList.length; i++) {\r\n            presaleAccessList[_addressList[i]] = true;\r\n        }\r\n    }","contract":"CuddleeCrew","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\r\n        address userAddress,\r\n        bytes memory functionSignature,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        uint8 sigV\r\n    ) public payable returns (bytes memory) {\r\n        MetaTransaction memory metaTx = MetaTransaction({\r\n        nonce: nonces[userAddress],\r\n        from: userAddress,\r\n        functionSignature: functionSignature\r\n        });\r\n\r\n        require(\r\n            verify(userAddress, metaTx, sigR, sigS, sigV),\r\n            \"Signer and signature do not match\"\r\n        );\r\n\r\n        // increase nonce for user (to avoid re-use)\r\n        nonces[userAddress] = nonces[userAddress].add(1);\r\n\r\n        emit MetaTransactionExecuted(\r\n            userAddress,\r\n            payable(msg.sender),\r\n            functionSignature\r\n        );\r\n\r\n        // Append userAddress and relayer address at the end to extract it from calling context\r\n        (bool success, bytes memory returnData) = address(this).call(\r\n            abi.encodePacked(functionSignature, userAddress)\r\n        );\r\n        require(success, \"Function call not successful\");\r\n\r\n        return returnData;\r\n    }","after":"function executeMetaTransaction(\r\n        address userAddress,\r\n        bytes calldata functionSignature,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        uint8 sigV\r\n    ) public payable returns (bytes memory) {\r\n        MetaTransaction memory metaTx = MetaTransaction({\r\n        nonce: nonces[userAddress],\r\n        from: userAddress,\r\n        functionSignature: functionSignature\r\n        });\r\n\r\n        require(\r\n            verify(userAddress, metaTx, sigR, sigS, sigV),\r\n            \"Signer and signature do not match\"\r\n        );\r\n\r\n        // increase nonce for user (to avoid re-use)\r\n        nonces[userAddress] = nonces[userAddress].add(1);\r\n\r\n        emit MetaTransactionExecuted(\r\n            userAddress,\r\n            payable(msg.sender),\r\n            functionSignature\r\n        );\r\n\r\n        // Append userAddress and relayer address at the end to extract it from calling context\r\n        (bool success, bytes memory returnData) = address(this).call(\r\n            abi.encodePacked(functionSignature, userAddress)\r\n        );\r\n        require(success, \"Function call not successful\");\r\n\r\n        return returnData;\r\n    }","contract":"CuddleeCrew","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public maxSupply = 20000;","after":"uint256 public constant maxSupply = 20000;","contract":"CuddleeCrew","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public maxMintAmount = 20;","after":"uint256 public constant maxMintAmount = 20;","contract":"CuddleeCrew","time":1},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"CuddleeCrew","time":1}]}