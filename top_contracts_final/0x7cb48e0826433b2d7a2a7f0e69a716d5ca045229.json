{"time":1358,"results":[{"type":"immutable-restrict-modification ","before":"uint256 public startWindow;","after":"uint256 public immutable startWindow;","contract":"MintingCeremonyHarness","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public endWindow;","after":"uint256 public immutable endWindow;","contract":"MintingCeremonyHarness","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public maximumContribution;","after":"uint256 public immutable maximumContribution;","contract":"Phase1Pool","time":2},{"type":"external-function ","before":"function updateWhitelist(bytes32 root_, string memory uri_)\n    public\n    override(IWhitelist)\n  {\n    require(\n      hasRole(WHITELISTER_ROLE, _msgSender()),\n      \"MerkleWhitelist::updateWhitelist: only whitelister may update the whitelist\"\n    );\n\n    merkleRoot = root_;\n    sourceUri = uri_;\n\n    emit UpdatedWhitelist(merkleRoot, sourceUri);\n  }","after":"function updateWhitelist(bytes32 root_, string calldata uri_)\n    public\n    override(IWhitelist)\n  {\n    require(\n      hasRole(WHITELISTER_ROLE, _msgSender()),\n      \"MerkleWhitelist::updateWhitelist: only whitelister may update the whitelist\"\n    );\n\n    merkleRoot = root_;\n    sourceUri = uri_;\n\n    emit UpdatedWhitelist(merkleRoot, sourceUri);\n  }","contract":"MerkleWhitelist","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public startWindow;","after":"uint256 public immutable startWindow;","contract":"Phase4aPool","time":2},{"type":"immutable-restrict-modification ","before":"uint256 public endWindow;","after":"uint256 public immutable endWindow;","contract":"Phase4aPool","time":2},{"type":"external-function ","before":"function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public returns (bytes32) {\n    require(\n      msg.sender == admin,\n      \"TimeLock::queueTransaction: Call must come from admin.\"\n    );\n    require(\n      eta >= getBlockTimestamp().add(delay),\n      \"TimeLock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }","after":"function queueTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) public returns (bytes32) {\n    require(\n      msg.sender == admin,\n      \"TimeLock::queueTransaction: Call must come from admin.\"\n    );\n    require(\n      eta >= getBlockTimestamp().add(delay),\n      \"TimeLock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }","contract":"TimeLockMock","time":0},{"type":"external-function ","before":"function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public {\n    require(\n      msg.sender == admin,\n      \"TimeLock::cancelTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }","after":"function cancelTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) public {\n    require(\n      msg.sender == admin,\n      \"TimeLock::cancelTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }","contract":"TimeLockMock","time":0},{"type":"external-function ","before":"function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public payable returns (bytes memory) {\n    require(\n      msg.sender == admin,\n      \"TimeLock::executeTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(\n      queuedTransactions[txHash],\n      \"TimeLock::executeTransaction: Transaction hasn't been queued.\"\n    );\n    require(\n      getBlockTimestamp() >= eta,\n      \"TimeLock::executeTransaction: Transaction hasn't surpassed time lock.\"\n    );\n    require(\n      getBlockTimestamp() <= eta.add(GRACE_PERIOD),\n      \"TimeLock::executeTransaction: Transaction is stale.\"\n    );\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) =\n      target.call{value: value}(callData);\n    require(\n      success,\n      \"TimeLock::executeTransaction: Transaction execution reverted.\"\n    );\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }","after":"function executeTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) public payable returns (bytes memory) {\n    require(\n      msg.sender == admin,\n      \"TimeLock::executeTransaction: Call must come from admin.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(\n      queuedTransactions[txHash],\n      \"TimeLock::executeTransaction: Transaction hasn't been queued.\"\n    );\n    require(\n      getBlockTimestamp() >= eta,\n      \"TimeLock::executeTransaction: Transaction hasn't surpassed time lock.\"\n    );\n    require(\n      getBlockTimestamp() <= eta.add(GRACE_PERIOD),\n      \"TimeLock::executeTransaction: Transaction is stale.\"\n    );\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) =\n      target.call{value: value}(callData);\n    require(\n      success,\n      \"TimeLock::executeTransaction: Transaction execution reverted.\"\n    );\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }","contract":"TimeLockMock","time":0},{"type":"immutable-restrict-modification ","before":"address public timelock;","after":"address public immutable timelock;","contract":"EarnedAggregator","time":0},{"type":"state-data-arrangement ","before":"\nyour option) any later versi\ne hope that it will be useful,\n// but WITHOUT\n WARRANTY; without even \nLITY or FITNESS FOR A P\n// GNU Affero General Public License for mo\nSPDX-License-Identifier: GPLv2\n\n// Changes:\n// - Conversion to 0.7.6\n// \nughout\n//   - remove revert fallback as now default\n\nimpo\n@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/Safe","after":"e hope that it will be useful,\n// but WITHOUT\n WARRANTY; without even \nLITY or FITNESS FOR A P\n// GNU Affero General Public License for mo\nSPDX-License-Identifier: GPLv2\n\n// Changes:\n// - Conversion to 0.7.6\n// \nughout\n//   - remove revert fallback as now default\n\nimpo\n@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/math/Safe\nyour option) any later versi\n","contract":"ZapBaseV1","time":0},{"type":"state-data-arrangement ","before":"\nmount;\n    }\n\n    if (_fromTokenA\npTarget);\n    }\n\n    uint256 iniBal \nta targets,\n    bool[] calldata isA\nut length\");\n\n    for (uint256 i = 0\nidity =0.7.6;\n\nimport \"@uniswap/v2-core/contracts/interfac","after":"pTarget);\n    }\n\n    uint256 iniBal \nut length\");\n\n    for (uint256 i = 0\nidity =0.7.6;\n\nimport \"@uniswap/v2-core/contracts/interfac\nmount;\n    }\n\n    if (_fromTokenA\nta targets,\n    bool[] calldata isA\n","contract":"Twap","time":0}]}