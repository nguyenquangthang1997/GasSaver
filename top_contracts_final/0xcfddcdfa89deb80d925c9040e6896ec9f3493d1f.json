{"time":255,"results":[{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"ERC1155","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"ERC1155","time":0},{"type":"loop-duplication","before":"\nstart line 1938 column 4, end line 1947 column 4\n   for (uint256 i = 0; i < _cardId.length; i++) {\n      require (packsContact.ownerOf(_packId[i]) == address(_msgSender()), 'not the owner');\n      bytes memory _hashingString = abi.encode(_salt[i], _packId[i]);\n      for (uint256 j = 0; j < _cardId[i].length; j++) {\n        _hashingString = abi.encode(_hashingString, _cardId[i][j], _amount[i][j]);\n      }\n      bytes32 _hash = keccak256(_hashingString);\n      address signer = ECDSA.recover(_hash.toEthSignedMessageHash(), sig[i]);\n      require (signer == verifier, \"Invalid sig\");\n  \nstart line 1949 column 4, end line 1954 column 4\n   for (uint256 i = 0; i < _cardId.length; i++) {\n      packsContact.burn(_packId[i]);\n      for (uint256 j = 0; j < _cardId[i].length; j++) {\n        nftContract.mint(_msgSender(), _cardId[i][j], 0, _amount[i][j], nftContract.contractChar(), 0, new uint256[](0));\n      }\n  ","after":"// merge loop\n\nstart line 1938 column 4, end line 1947 column 4\n   for (uint256 i = 0; i < _cardId.length; i++) {\n      require (packsContact.ownerOf(_packId[i]) == address(_msgSender()), 'not the owner');\n      bytes memory _hashingString = abi.encode(_salt[i], _packId[i]);\n      for (uint256 j = 0; j < _cardId[i].length; j++) {\n        _hashingString = abi.encode(_hashingString, _cardId[i][j], _amount[i][j]);\n      }\n      bytes32 _hash = keccak256(_hashingString);\n      address signer = ECDSA.recover(_hash.toEthSignedMessageHash(), sig[i]);\n      require (signer == verifier, \"Invalid sig\");\n  \nstart line 1949 column 4, end line 1954 column 4\n   for (uint256 i = 0; i < _cardId.length; i++) {\n      packsContact.burn(_packId[i]);\n      for (uint256 j = 0; j < _cardId[i].length; j++) {\n        nftContract.mint(_msgSender(), _cardId[i][j], 0, _amount[i][j], nftContract.contractChar(), 0, new uint256[](0));\n      }\n  ","contract":"RainiCardsFunctions","time":0},{"type":"external-function ","before":"\n  function openPacks(uint256[][] memory _cardId, uint256[][] memory _amount, bytes[] memory sig, uint256[] memory _salt, uint256[] memory _packId)\n    external nonReentrant {\n\n    for (uint256 i = 0; i < _cardId.length; i++) {\n      require (packsContact.ownerOf(_packId[i]) == address(_msgSender()), 'not the owner');\n      bytes memory _hashingString = abi.encode(_salt[i], _packId[i]);\n      for (uint256 j = 0; j < _cardId[i].length; j++) {\n        _hashingString = abi.encode(_hashingString, _cardId[i][j], _amount[i][j]);\n      }\n      bytes32 _hash = keccak256(_hashingString);\n      address signer = ECDSA.recover(_hash.toEthSignedMessageHash(), sig[i]);\n      require (signer == verifier, \"Invalid sig\");\n    }\n\n    for (uint256 i = 0; i < _cardId.length; i++) {\n      packsContact.burn(_packId[i]);\n      for (uint256 j = 0; j < _cardId[i].length; j++) {\n        nftContract.mint(_msgSender(), _cardId[i][j], 0, _amount[i][j], nftContract.contractChar(), 0, new uint256[](0));\n      }\n    }\n","after":"\n  function openPacks(uint256[][] calldata _cardId, uint256[][] calldata _amount, bytes[] calldata sig, uint256[] calldata _salt, uint256[] calldata _packId)\n    external nonReentrant {\n\n    for (uint256 i = 0; i < _cardId.length; i++) {\n      require (packsContact.ownerOf(_packId[i]) == address(_msgSender()), 'not the owner');\n      bytes memory _hashingString = abi.encode(_salt[i], _packId[i]);\n      for (uint256 j = 0; j < _cardId[i].length; j++) {\n        _hashingString = abi.encode(_hashingString, _cardId[i][j], _amount[i][j]);\n      }\n      bytes32 _hash = keccak256(_hashingString);\n      address signer = ECDSA.recover(_hash.toEthSignedMessageHash(), sig[i]);\n      require (signer == verifier, \"Invalid sig\");\n    }\n\n    for (uint256 i = 0; i < _cardId.length; i++) {\n      packsContact.burn(_packId[i]);\n      for (uint256 j = 0; j < _cardId[i].length; j++) {\n        nftContract.mint(_msgSender(), _cardId[i][j], 0, _amount[i][j], nftContract.contractChar(), 0, new uint256[](0));\n      }\n    }\n","contract":"RainiCardsFunctions","time":0},{"type":"external-function ","before":"\n  function buyPacks(uint256[] memory _packType, uint256[] memory _amount, bool[] memory _useUnicorns, uint256[][] memory _data, address[] memory _rainbowPools, address[] memory _unicornPools)\n    external payable nonReentrant {\n\n    BuyPacksData memory _locals = BuyPacksData({\n      totalPriceRainbows: 0,\n      totalPriceUnicorns: 0,\n      minCostRainbows: 0,\n      minCostUnicorns: 0,\n      fee: 0,\n      amountEthToWithdraw: 0,\n      success: false\n    });\n\n    bool[] memory addToMaxMints = new bool[](_packType.length);\n\n    for (uint256 i = 0; i < _packType.length; i++) {\n      IRainiCardPacks.PackType memory packType = packsContact.packTypes(_packType[i]);\n\n      require(block.timestamp >= packType.mintTimeStart || hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), 'too early');\n      require(packType.maxMintsPerAddress == 0 || (packsContact.numberMintedByAddress(_msgSender(), _packType[i]) + _amount[i] <= packType.maxMintsPerAddress), \"Max mints reached for address\");\n      addToMaxMints[i] = packType.maxMintsPerAddress > 0;\n\n      uint256 numberMinted = packsContact.numberOfPackMinted(_packType[i]);\n      if (numberMinted + _amount[i] > packType.supply) {\n        _amount[i] = packType.supply - numberMinted;\n      }\n\n      if (packType.costInUnicorns > 0 || packType.costInRainbows > 0) {\n        if (_useUnicorns[i]) {\n          require(packType.costInUnicorns > 0, \"unicorns not allowed\");\n          uint256 cost = packType.costInUnicorns * _amount[i] * POINT_COST_DECIMALS;\n          _locals.totalPriceUnicorns += cost;\n          if (packType.costInEth > 0) {\n            _locals.minCostUnicorns += cost;\n          }\n        } else {\n          require(packType.costInRainbows > 0, \"rainbows not allowed\");\n          uint256 cost = packType.costInRainbows * _amount[i] * POINT_COST_DECIMALS;\n          _locals.totalPriceRainbows += cost;\n          if (packType.costInEth > 0) {\n            _locals.minCostRainbows += cost;\n          }\n        }\n\n        if (packType.costInEth == 0) {\n          if (packType.costInRainbows > 0) {\n            _locals.fee += (packType.costInRainbows * _amount[i] * POINT_COST_DECIMALS * mintingFeeBasisPoints) / (rainbowToEth * 10000);\n          } else {\n            _locals.fee += (packType.costInUnicorns * _amount[i] * POINT_COST_DECIMALS * mintingFeeBasisPoints) / (unicornToEth * 10000);\n          }\n        }\n      }\n      \n      _locals.amountEthToWithdraw += packType.costInEth * _amount[i];\n    }\n    \n    if (_locals.totalPriceUnicorns > 0 || _locals.totalPriceRainbows > 0 ) {\n      for (uint256 n = 0; n < 2; n++) {\n        bool loopTypeUnicorns = n > 0;\n\n        uint256 totalBalance = 0;\n        uint256 totalPrice = loopTypeUnicorns ? _locals.totalPriceUnicorns : _locals.totalPriceRainbows;\n        uint256 remainingPrice = totalPrice;\n\n        if (totalPrice > 0) {\n          uint256 loopLength = loopTypeUnicorns ? _unicornPools.length : _rainbowPools.length;\n\n          require(loopLength > 0, \"invalid pools\");\n\n          for (uint256 i = 0; i < loopLength; i++) {\n            IStakingPool pool;\n            if (loopTypeUnicorns) {\n              require((unicornPools[_unicornPools[i]]), \"invalid unicorn pool\");\n              pool = IStakingPool(_unicornPools[i]);\n            } else {\n              require((rainbowPools[_rainbowPools[i]]), \"invalid rainbow pool\");\n              pool = IStakingPool(_rainbowPools[i]);\n            }\n            uint256 _balance = pool.balanceOf(_msgSender());\n            totalBalance += _balance;\n\n            if (totalBalance >=  totalPrice) {\n              pool.burn(_msgSender(), remainingPrice);\n              remainingPrice = 0;\n              break;\n            } else {\n              pool.burn(_msgSender(), _balance);\n              remainingPrice -= _balance;\n            }\n          }\n\n          if (remainingPrice > 0) {\n            totalPrice -= loopTypeUnicorns ? _locals.minCostUnicorns : _locals.minCostRainbows;\n            uint256 minPoints = (totalPrice * minPointsPercentToMint) / 100;\n            require(totalPrice - remainingPrice >= minPoints, \"not enough balance\");\n            uint256 pointsToEth = loopTypeUnicorns ? unicornToEth : rainbowToEth;\n            require(msg.value * pointsToEth > remainingPrice, \"not enough balance\");\n            _locals.amountEthToWithdraw += remainingPrice / pointsToEth;\n          }\n        }\n      }\n    }\n\n    // Add minting fees\n    _locals.amountEthToWithdraw += _locals.fee;\n\n    require(_locals.amountEthToWithdraw <= msg.value);\n\n    (_locals.success, ) = _msgSender().call{ value: msg.value - _locals.amountEthToWithdraw }(\"\"); // refund excess Eth\n    require(_locals.success, \"transfer failed\");\n\n    bool _tokenMinted = false;\n    for (uint256 i = 0; i < _packType.length; i++) {\n      if (_amount[i] > 0) {\n        if (addToMaxMints[i]) {\n          packsContact.addToNumberMintedByAddress(_msgSender(), _packType[i], _amount[i]);\n        }\n        packsContact.mint(_msgSender(), _packType[i], _amount[i]);\n        _tokenMinted = true;\n      }\n    }\n    require(_tokenMinted, 'Allocation exhausted');\n","after":"\n  function buyPacks(uint256[] calldata _packType, uint256[] calldata _amount, bool[] calldata _useUnicorns, uint256[][] calldata _data, address[] calldata _rainbowPools, address[] memory _unicornPools)\n    external payable nonReentrant {\n\n    BuyPacksData memory _locals = BuyPacksData({\n      totalPriceRainbows: 0,\n      totalPriceUnicorns: 0,\n      minCostRainbows: 0,\n      minCostUnicorns: 0,\n      fee: 0,\n      amountEthToWithdraw: 0,\n      success: false\n    });\n\n    bool[] memory addToMaxMints = new bool[](_packType.length);\n\n    for (uint256 i = 0; i < _packType.length; i++) {\n      IRainiCardPacks.PackType memory packType = packsContact.packTypes(_packType[i]);\n\n      require(block.timestamp >= packType.mintTimeStart || hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), 'too early');\n      require(packType.maxMintsPerAddress == 0 || (packsContact.numberMintedByAddress(_msgSender(), _packType[i]) + _amount[i] <= packType.maxMintsPerAddress), \"Max mints reached for address\");\n      addToMaxMints[i] = packType.maxMintsPerAddress > 0;\n\n      uint256 numberMinted = packsContact.numberOfPackMinted(_packType[i]);\n      if (numberMinted + _amount[i] > packType.supply) {\n        _amount[i] = packType.supply - numberMinted;\n      }\n\n      if (packType.costInUnicorns > 0 || packType.costInRainbows > 0) {\n        if (_useUnicorns[i]) {\n          require(packType.costInUnicorns > 0, \"unicorns not allowed\");\n          uint256 cost = packType.costInUnicorns * _amount[i] * POINT_COST_DECIMALS;\n          _locals.totalPriceUnicorns += cost;\n          if (packType.costInEth > 0) {\n            _locals.minCostUnicorns += cost;\n          }\n        } else {\n          require(packType.costInRainbows > 0, \"rainbows not allowed\");\n          uint256 cost = packType.costInRainbows * _amount[i] * POINT_COST_DECIMALS;\n          _locals.totalPriceRainbows += cost;\n          if (packType.costInEth > 0) {\n            _locals.minCostRainbows += cost;\n          }\n        }\n\n        if (packType.costInEth == 0) {\n          if (packType.costInRainbows > 0) {\n            _locals.fee += (packType.costInRainbows * _amount[i] * POINT_COST_DECIMALS * mintingFeeBasisPoints) / (rainbowToEth * 10000);\n          } else {\n            _locals.fee += (packType.costInUnicorns * _amount[i] * POINT_COST_DECIMALS * mintingFeeBasisPoints) / (unicornToEth * 10000);\n          }\n        }\n      }\n      \n      _locals.amountEthToWithdraw += packType.costInEth * _amount[i];\n    }\n    \n    if (_locals.totalPriceUnicorns > 0 || _locals.totalPriceRainbows > 0 ) {\n      for (uint256 n = 0; n < 2; n++) {\n        bool loopTypeUnicorns = n > 0;\n\n        uint256 totalBalance = 0;\n        uint256 totalPrice = loopTypeUnicorns ? _locals.totalPriceUnicorns : _locals.totalPriceRainbows;\n        uint256 remainingPrice = totalPrice;\n\n        if (totalPrice > 0) {\n          uint256 loopLength = loopTypeUnicorns ? _unicornPools.length : _rainbowPools.length;\n\n          require(loopLength > 0, \"invalid pools\");\n\n          for (uint256 i = 0; i < loopLength; i++) {\n            IStakingPool pool;\n            if (loopTypeUnicorns) {\n              require((unicornPools[_unicornPools[i]]), \"invalid unicorn pool\");\n              pool = IStakingPool(_unicornPools[i]);\n            } else {\n              require((rainbowPools[_rainbowPools[i]]), \"invalid rainbow pool\");\n              pool = IStakingPool(_rainbowPools[i]);\n            }\n            uint256 _balance = pool.balanceOf(_msgSender());\n            totalBalance += _balance;\n\n            if (totalBalance >=  totalPrice) {\n              pool.burn(_msgSender(), remainingPrice);\n              remainingPrice = 0;\n              break;\n            } else {\n              pool.burn(_msgSender(), _balance);\n              remainingPrice -= _balance;\n            }\n          }\n\n          if (remainingPrice > 0) {\n            totalPrice -= loopTypeUnicorns ? _locals.minCostUnicorns : _locals.minCostRainbows;\n            uint256 minPoints = (totalPrice * minPointsPercentToMint) / 100;\n            require(totalPrice - remainingPrice >= minPoints, \"not enough balance\");\n            uint256 pointsToEth = loopTypeUnicorns ? unicornToEth : rainbowToEth;\n            require(msg.value * pointsToEth > remainingPrice, \"not enough balance\");\n            _locals.amountEthToWithdraw += remainingPrice / pointsToEth;\n          }\n        }\n      }\n    }\n\n    // Add minting fees\n    _locals.amountEthToWithdraw += _locals.fee;\n\n    require(_locals.amountEthToWithdraw <= msg.value);\n\n    (_locals.success, ) = _msgSender().call{ value: msg.value - _locals.amountEthToWithdraw }(\"\"); // refund excess Eth\n    require(_locals.success, \"transfer failed\");\n\n    bool _tokenMinted = false;\n    for (uint256 i = 0; i < _packType.length; i++) {\n      if (_amount[i] > 0) {\n        if (addToMaxMints[i]) {\n          packsContact.addToNumberMintedByAddress(_msgSender(), _packType[i], _amount[i]);\n        }\n        packsContact.mint(_msgSender(), _packType[i], _amount[i]);\n        _tokenMinted = true;\n      }\n    }\n    require(_tokenMinted, 'Allocation exhausted');\n","contract":"RainiCardsFunctions","time":0}]}