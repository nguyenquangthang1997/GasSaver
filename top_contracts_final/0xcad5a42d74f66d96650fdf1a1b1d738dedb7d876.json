{"time":200,"results":[{"type":"external-function ","before":"function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes memory data) public payable onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }","after":"function upgradeAndCall(TransparentUpgradeableProxy proxy, address implementation, bytes calldata data) public payable onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }","contract":"ProxyAdmin","time":0},{"type":"constant-restrict-modification  ","before":"uint256 MAX_UINT = 2**256 - 1;","after":"uint256 constant MAX_UINT = 2**256 - 1;","contract":"SeeleERC20","time":0},{"type":"external-function ","before":"function initialize(\n        // A unique identifier for this bridge instance to use in signatures\n        bytes32 _bridgeId,\n        // How much voting power is needed to approve operations\n        uint256 _powerThreshold,\n        // The validator set, not in valset args format since many of it's\n        // arguments would never be used in this case\n        address[] calldata _validators,\n        uint256[] memory _powers\n    ) external onlyOwner {\n        // CHECKS\n\n        // Check that validators, powers, and signatures (v,r,s) set is well-formed\n        require(\n            _validators.length == _powers.length,\n            \"Malformed current validator set\"\n        );\n\n        // Check cumulative power to ensure the contract has sufficient power to actually\n        // pass a vote\n        uint256 cumulativePower = 0;\n        for (uint256 i = 0; i < _powers.length; i++) {\n            cumulativePower = cumulativePower + _powers[i];\n            if (cumulativePower > _powerThreshold) {\n                break;\n            }\n        }\n\n        require(\n            cumulativePower > _powerThreshold,\n            \"Submitted validator set signatures do not have enough power.\"\n        );\n\n        bytes32 newCheckpoint = makeCheckpoint(\n            _validators,\n            _powers,\n            0,\n            _bridgeId\n        );\n\n        // ACTIONS\n\n        state_bridgeId = _bridgeId;\n        state_powerThreshold = _powerThreshold;\n        state_lastValsetCheckpoint = newCheckpoint;\n        //_ethereumTokenWhiteList[address(0)] = true;\n        // LOGS\n\n        emit ValsetUpdatedEvent(\n            state_lastValsetNonce,\n            state_lastEventNonce,\n            _validators,\n            _powers\n        );\n    }","after":"function initialize(\n        // A unique identifier for this bridge instance to use in signatures\n        bytes32 _bridgeId,\n        // How much voting power is needed to approve operations\n        uint256 _powerThreshold,\n        // The validator set, not in valset args format since many of it's\n        // arguments would never be used in this case\n        address[] calldata _validators,\n        uint256[] calldata _powers\n    ) external onlyOwner {\n        // CHECKS\n\n        // Check that validators, powers, and signatures (v,r,s) set is well-formed\n        require(\n            _validators.length == _powers.length,\n            \"Malformed current validator set\"\n        );\n\n        // Check cumulative power to ensure the contract has sufficient power to actually\n        // pass a vote\n        uint256 cumulativePower = 0;\n        for (uint256 i = 0; i < _powers.length; i++) {\n            cumulativePower = cumulativePower + _powers[i];\n            if (cumulativePower > _powerThreshold) {\n                break;\n            }\n        }\n\n        require(\n            cumulativePower > _powerThreshold,\n            \"Submitted validator set signatures do not have enough power.\"\n        );\n\n        bytes32 newCheckpoint = makeCheckpoint(\n            _validators,\n            _powers,\n            0,\n            _bridgeId\n        );\n\n        // ACTIONS\n\n        state_bridgeId = _bridgeId;\n        state_powerThreshold = _powerThreshold;\n        state_lastValsetCheckpoint = newCheckpoint;\n        //_ethereumTokenWhiteList[address(0)] = true;\n        // LOGS\n\n        emit ValsetUpdatedEvent(\n            state_lastValsetNonce,\n            state_lastEventNonce,\n            _validators,\n            _powers\n        );\n    }","contract":"SeeleBridge","time":0},{"type":"external-function ","before":"function updateValset(\n        // The new version of the validator set\n        address[] memory _newValidators,\n        uint256[] memory _newPowers,\n        uint256 _newValsetNonce,\n        // The current validators that approve the change\n        address[] memory _currentValidators,\n        uint256[] memory _currentPowers,\n        uint256 _currentValsetNonce,\n        // These are arrays of the parts of the current validator's signatures\n        uint8[] memory _v,\n        bytes32[] memory _r,\n        bytes32[] memory _s\n    ) external whenNotPaused nonReentrant {\n        // CHECKS\n\n        // Check that the valset nonce is greater than the old one\n        require(\n            _newValsetNonce > _currentValsetNonce,\n            \"New valset nonce must be greater than the current nonce\"\n        );\n\n        // Check that new validators and powers set is well-formed\n        require(\n            _newValidators.length == _newPowers.length,\n            \"Malformed new validator set\"\n        );\n\n        // Check that current validators, powers, and signatures (v,r,s) set is well-formed\n        require(\n            _currentValidators.length == _currentPowers.length &&\n                _currentValidators.length == _v.length &&\n                _currentValidators.length == _r.length &&\n                _currentValidators.length == _s.length,\n            \"Malformed current validator set\"\n        );\n\n        // Check that the supplied current validator set matches the saved checkpoint\n        require(\n            makeCheckpoint(\n                _currentValidators,\n                _currentPowers,\n                _currentValsetNonce,\n                state_bridgeId\n            ) == state_lastValsetCheckpoint,\n            \"Supplied current validators and powers do not match checkpoint.\"\n        );\n\n        // Check that enough current validators have signed off on the new validator set\n        bytes32 newCheckpoint = makeCheckpoint(\n            _newValidators,\n            _newPowers,\n            _newValsetNonce,\n            state_bridgeId\n        );\n\n        checkValidatorSignatures(\n            _currentValidators,\n            _currentPowers,\n            _v,\n            _r,\n            _s,\n            newCheckpoint,\n            state_powerThreshold\n        );\n\n        // ACTIONS\n\n        // Stored to be used next time to validate that the valset\n        // supplied by the caller is correct.\n        state_lastValsetCheckpoint = newCheckpoint;\n\n        // Store new nonce\n        state_lastValsetNonce = _newValsetNonce;\n\n        // LOGS\n        state_lastEventNonce = state_lastEventNonce.add(1);\n        emit ValsetUpdatedEvent(\n            _newValsetNonce,\n            state_lastEventNonce,\n            _newValidators,\n            _newPowers\n        );\n    }","after":"function updateValset(\n        // The new version of the validator set\n        address[] calldata _newValidators,\n        uint256[] calldata _newPowers,\n        uint256 _newValsetNonce,\n        // The current validators that approve the change\n        address[] calldata _currentValidators,\n        uint256[] calldata _currentPowers,\n        uint256 _currentValsetNonce,\n        // These are arrays of the parts of the current validator's signatures\n        uint8[] calldata _v,\n        bytes32[] calldata _r,\n        bytes32[] calldata _s\n    ) external whenNotPaused nonReentrant {\n        // CHECKS\n\n        // Check that the valset nonce is greater than the old one\n        require(\n            _newValsetNonce > _currentValsetNonce,\n            \"New valset nonce must be greater than the current nonce\"\n        );\n\n        // Check that new validators and powers set is well-formed\n        require(\n            _newValidators.length == _newPowers.length,\n            \"Malformed new validator set\"\n        );\n\n        // Check that current validators, powers, and signatures (v,r,s) set is well-formed\n        require(\n            _currentValidators.length == _currentPowers.length &&\n                _currentValidators.length == _v.length &&\n                _currentValidators.length == _r.length &&\n                _currentValidators.length == _s.length,\n            \"Malformed current validator set\"\n        );\n\n        // Check that the supplied current validator set matches the saved checkpoint\n        require(\n            makeCheckpoint(\n                _currentValidators,\n                _currentPowers,\n                _currentValsetNonce,\n                state_bridgeId\n            ) == state_lastValsetCheckpoint,\n            \"Supplied current validators and powers do not match checkpoint.\"\n        );\n\n        // Check that enough current validators have signed off on the new validator set\n        bytes32 newCheckpoint = makeCheckpoint(\n            _newValidators,\n            _newPowers,\n            _newValsetNonce,\n            state_bridgeId\n        );\n\n        checkValidatorSignatures(\n            _currentValidators,\n            _currentPowers,\n            _v,\n            _r,\n            _s,\n            newCheckpoint,\n            state_powerThreshold\n        );\n\n        // ACTIONS\n\n        // Stored to be used next time to validate that the valset\n        // supplied by the caller is correct.\n        state_lastValsetCheckpoint = newCheckpoint;\n\n        // Store new nonce\n        state_lastValsetNonce = _newValsetNonce;\n\n        // LOGS\n        state_lastEventNonce = state_lastEventNonce.add(1);\n        emit ValsetUpdatedEvent(\n            _newValsetNonce,\n            state_lastEventNonce,\n            _newValidators,\n            _newPowers\n        );\n    }","contract":"SeeleBridge","time":0},{"type":"external-function ","before":"function submitBatch(\n        // The validators that approve the batch\n        address[] memory _currentValidators,\n        uint256[] memory _currentPowers,\n        uint256 _currentValsetNonce,\n        // These are arrays of the parts of the validators signatures\n        uint8[] memory _v,\n        bytes32[] memory _r,\n        bytes32[] memory _s,\n        // The batch of transactions\n        uint256[] memory _amounts,\n        address payable[] memory _destinations,\n        uint256[] memory _fees,\n        uint256 _batchNonce,\n        address _tokenContract,\n        // a block height beyond which this batch is not valid\n        // used to provide a fee-free timeout\n        uint256 _batchTimeout\n    ) external nonReentrant whenNotPaused {\n        // CHECKS scoped to reduce stack depth\n        {\n            // Check that the batch nonce is higher than the last nonce for this token\n            require(\n                state_lastBatchNonces[_tokenContract] < _batchNonce,\n                \"New batch nonce must be greater than the current nonce\"\n            );\n\n            // Check that the block height is less than the timeout height\n            require(\n                block.number < _batchTimeout,\n                \"Batch timeout must be greater than the current block height\"\n            );\n\n            // Check that current validators, powers, and signatures (v,r,s) set is well-formed\n            require(\n                _currentValidators.length == _currentPowers.length &&\n                    _currentValidators.length == _v.length &&\n                    _currentValidators.length == _r.length &&\n                    _currentValidators.length == _s.length,\n                \"Malformed current validator set\"\n            );\n\n            // Check that the supplied current validator set matches the saved checkpoint\n            require(\n                makeCheckpoint(\n                    _currentValidators,\n                    _currentPowers,\n                    _currentValsetNonce,\n                    state_bridgeId\n                ) == state_lastValsetCheckpoint,\n                \"Supplied current validators and powers do not match checkpoint.\"\n            );\n\n            // Check that the transaction batch is well-formed\n            require(\n                _amounts.length == _destinations.length &&\n                    _amounts.length == _fees.length,\n                \"Malformed batch of transactions\"\n            );\n\n            // Check that enough current validators have signed off on the transaction batch and valset\n            checkValidatorSignatures(\n                _currentValidators,\n                _currentPowers,\n                _v,\n                _r,\n                _s,\n                // Get hash of the transaction batch and checkpoint\n                keccak256(\n                    abi.encode(\n                        state_bridgeId,\n                        // bytes32 encoding of \"transactionBatch\"\n                        0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n                        _amounts,\n                        _destinations,\n                        _fees,\n                        _batchNonce,\n                        _tokenContract,\n                        _batchTimeout\n                    )\n                ),\n                state_powerThreshold\n            );\n\n            // ACTIONS\n\n            // Store batch nonce\n            state_lastBatchNonces[_tokenContract] = _batchNonce;\n\n            {\n                // Send transaction amounts to destinations\n                uint256 totalFee;\n                for (uint256 i = 0; i < _amounts.length; i++) {\n                    if (_tokenContract == address(0)) {\n                        (bool success, ) = _destinations[i].call{\n                            value: _amounts[i],\n                            gas: 60000\n                        }(\"\");\n                        require(success, \"error sending ether\");\n                    } else {\n                        IERC20(_tokenContract).safeTransfer(\n                            _destinations[i],\n                            _amounts[i]\n                        );\n                    }\n                    totalFee = totalFee.add(_fees[i]);\n                }\n\n                // Send transaction fees to msg.sender\n                if (totalFee > 0) {\n                    if (_tokenContract == address(0)) {\n                        (bool success, ) = msg.sender.call{\n                            value: totalFee,\n                            gas: 60000\n                        }(\"\");\n                        require(success, \"error sending ether\");\n                    } else {\n                        IERC20(_tokenContract).safeTransfer(\n                            msg.sender,\n                            totalFee\n                        );\n                    }\n                }\n            }\n        }\n\n        // LOGS scoped to reduce stack depth\n        {\n            state_lastEventNonce = state_lastEventNonce.add(1);\n            emit TransactionBatchExecutedEvent(\n                _batchNonce,\n                _tokenContract,\n                state_lastEventNonce\n            );\n        }\n    }","after":"function submitBatch(\n        // The validators that approve the batch\n        address[] calldata _currentValidators,\n        uint256[] calldata _currentPowers,\n        uint256 _currentValsetNonce,\n        // These are arrays of the parts of the validators signatures\n        uint8[] calldata _v,\n        bytes32[] calldata _r,\n        bytes32[] calldata _s,\n        // The batch of transactions\n        uint256[] calldata _amounts,\n        address payable[] calldata _destinations,\n        uint256[] calldata _fees,\n        uint256 _batchNonce,\n        address _tokenContract,\n        // a block height beyond which this batch is not valid\n        // used to provide a fee-free timeout\n        uint256 _batchTimeout\n    ) external nonReentrant whenNotPaused {\n        // CHECKS scoped to reduce stack depth\n        {\n            // Check that the batch nonce is higher than the last nonce for this token\n            require(\n                state_lastBatchNonces[_tokenContract] < _batchNonce,\n                \"New batch nonce must be greater than the current nonce\"\n            );\n\n            // Check that the block height is less than the timeout height\n            require(\n                block.number < _batchTimeout,\n                \"Batch timeout must be greater than the current block height\"\n            );\n\n            // Check that current validators, powers, and signatures (v,r,s) set is well-formed\n            require(\n                _currentValidators.length == _currentPowers.length &&\n                    _currentValidators.length == _v.length &&\n                    _currentValidators.length == _r.length &&\n                    _currentValidators.length == _s.length,\n                \"Malformed current validator set\"\n            );\n\n            // Check that the supplied current validator set matches the saved checkpoint\n            require(\n                makeCheckpoint(\n                    _currentValidators,\n                    _currentPowers,\n                    _currentValsetNonce,\n                    state_bridgeId\n                ) == state_lastValsetCheckpoint,\n                \"Supplied current validators and powers do not match checkpoint.\"\n            );\n\n            // Check that the transaction batch is well-formed\n            require(\n                _amounts.length == _destinations.length &&\n                    _amounts.length == _fees.length,\n                \"Malformed batch of transactions\"\n            );\n\n            // Check that enough current validators have signed off on the transaction batch and valset\n            checkValidatorSignatures(\n                _currentValidators,\n                _currentPowers,\n                _v,\n                _r,\n                _s,\n                // Get hash of the transaction batch and checkpoint\n                keccak256(\n                    abi.encode(\n                        state_bridgeId,\n                        // bytes32 encoding of \"transactionBatch\"\n                        0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n                        _amounts,\n                        _destinations,\n                        _fees,\n                        _batchNonce,\n                        _tokenContract,\n                        _batchTimeout\n                    )\n                ),\n                state_powerThreshold\n            );\n\n            // ACTIONS\n\n            // Store batch nonce\n            state_lastBatchNonces[_tokenContract] = _batchNonce;\n\n            {\n                // Send transaction amounts to destinations\n                uint256 totalFee;\n                for (uint256 i = 0; i < _amounts.length; i++) {\n                    if (_tokenContract == address(0)) {\n                        (bool success, ) = _destinations[i].call{\n                            value: _amounts[i],\n                            gas: 60000\n                        }(\"\");\n                        require(success, \"error sending ether\");\n                    } else {\n                        IERC20(_tokenContract).safeTransfer(\n                            _destinations[i],\n                            _amounts[i]\n                        );\n                    }\n                    totalFee = totalFee.add(_fees[i]);\n                }\n\n                // Send transaction fees to msg.sender\n                if (totalFee > 0) {\n                    if (_tokenContract == address(0)) {\n                        (bool success, ) = msg.sender.call{\n                            value: totalFee,\n                            gas: 60000\n                        }(\"\");\n                        require(success, \"error sending ether\");\n                    } else {\n                        IERC20(_tokenContract).safeTransfer(\n                            msg.sender,\n                            totalFee\n                        );\n                    }\n                }\n            }\n        }\n\n        // LOGS scoped to reduce stack depth\n        {\n            state_lastEventNonce = state_lastEventNonce.add(1);\n            emit TransactionBatchExecutedEvent(\n                _batchNonce,\n                _tokenContract,\n                state_lastEventNonce\n            );\n        }\n    }","contract":"SeeleBridge","time":0},{"type":"external-function ","before":"function submitLogicCall(\n        // The validators that approve the call\n        address[] memory _currentValidators,\n        uint256[] memory _currentPowers,\n        uint256 _currentValsetNonce,\n        // These are arrays of the parts of the validators signatures\n        uint8[] memory _v,\n        bytes32[] memory _r,\n        bytes32[] memory _s,\n        LogicCallArgs memory _args\n    ) public nonReentrant {\n        // CHECKS scoped to reduce stack depth\n        {\n            // Check that the call has not timed out\n            require(block.number < _args.timeOut, \"Timed out\");\n\n            // Check that the invalidation nonce is higher than the last nonce for this invalidation Id\n            require(\n                state_invalidationMapping[_args.invalidationId] <\n                    _args.invalidationNonce,\n                \"New invalidation nonce must be greater than the current nonce\"\n            );\n\n            // Check that current validators, powers, and signatures (v,r,s) set is well-formed\n            require(\n                _currentValidators.length == _currentPowers.length &&\n                    _currentValidators.length == _v.length &&\n                    _currentValidators.length == _r.length &&\n                    _currentValidators.length == _s.length,\n                \"Malformed current validator set\"\n            );\n\n            // Check that the supplied current validator set matches the saved checkpoint\n            require(\n                makeCheckpoint(\n                    _currentValidators,\n                    _currentPowers,\n                    _currentValsetNonce,\n                    state_bridgeId\n                ) == state_lastValsetCheckpoint,\n                \"Supplied current validators and powers do not match checkpoint.\"\n            );\n\n            // Check that the token transfer list is well-formed\n            require(\n                _args.transferAmounts.length ==\n                    _args.transferTokenContracts.length,\n                \"Malformed list of token transfers\"\n            );\n\n            // Check that the fee list is well-formed\n            require(\n                _args.feeAmounts.length == _args.feeTokenContracts.length,\n                \"Malformed list of fees\"\n            );\n        }\n\n        bytes32 argsHash = keccak256(\n            abi.encode(\n                state_bridgeId,\n                // bytes32 encoding of \"logicCall\"\n                0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n                _args.transferAmounts,\n                _args.transferTokenContracts,\n                _args.feeAmounts,\n                _args.feeTokenContracts,\n                _args.logicContractAddress,\n                _args.payload,\n                _args.timeOut,\n                _args.invalidationId,\n                _args.invalidationNonce\n            )\n        );\n\n        {\n            // Check that enough current validators have signed off on the transaction batch and valset\n            checkValidatorSignatures(\n                _currentValidators,\n                _currentPowers,\n                _v,\n                _r,\n                _s,\n                // Get hash of the transaction batch and checkpoint\n                argsHash,\n                state_powerThreshold\n            );\n        }\n\n        // ACTIONS\n\n        // Update invaldiation nonce\n        state_invalidationMapping[_args.invalidationId] = _args\n            .invalidationNonce;\n\n        // Send tokens to the logic contract\n        for (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n            IERC20(_args.transferTokenContracts[i]).safeTransfer(\n                _args.logicContractAddress,\n                _args.transferAmounts[i]\n            );\n        }\n\n        // Make call to logic contract\n        bytes memory returnData = Address.functionCall(\n            _args.logicContractAddress,\n            _args.payload\n        );\n\n        // Send fees to msg.sender\n        for (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n            IERC20(_args.feeTokenContracts[i]).safeTransfer(\n                msg.sender,\n                _args.feeAmounts[i]\n            );\n        }\n\n        // LOGS scoped to reduce stack depth\n        {\n            state_lastEventNonce = state_lastEventNonce.add(1);\n            emit LogicCallEvent(\n                _args.invalidationId,\n                _args.invalidationNonce,\n                returnData,\n                state_lastEventNonce\n            );\n        }\n    }","after":"function submitLogicCall(\n        // The validators that approve the call\n        address[] calldata _currentValidators,\n        uint256[] calldata _currentPowers,\n        uint256 _currentValsetNonce,\n        // These are arrays of the parts of the validators signatures\n        uint8[] calldata _v,\n        bytes32[] calldata _r,\n        bytes32[] calldata _s,\n        LogicCallArgs calldata _args\n    ) public nonReentrant {\n        // CHECKS scoped to reduce stack depth\n        {\n            // Check that the call has not timed out\n            require(block.number < _args.timeOut, \"Timed out\");\n\n            // Check that the invalidation nonce is higher than the last nonce for this invalidation Id\n            require(\n                state_invalidationMapping[_args.invalidationId] <\n                    _args.invalidationNonce,\n                \"New invalidation nonce must be greater than the current nonce\"\n            );\n\n            // Check that current validators, powers, and signatures (v,r,s) set is well-formed\n            require(\n                _currentValidators.length == _currentPowers.length &&\n                    _currentValidators.length == _v.length &&\n                    _currentValidators.length == _r.length &&\n                    _currentValidators.length == _s.length,\n                \"Malformed current validator set\"\n            );\n\n            // Check that the supplied current validator set matches the saved checkpoint\n            require(\n                makeCheckpoint(\n                    _currentValidators,\n                    _currentPowers,\n                    _currentValsetNonce,\n                    state_bridgeId\n                ) == state_lastValsetCheckpoint,\n                \"Supplied current validators and powers do not match checkpoint.\"\n            );\n\n            // Check that the token transfer list is well-formed\n            require(\n                _args.transferAmounts.length ==\n                    _args.transferTokenContracts.length,\n                \"Malformed list of token transfers\"\n            );\n\n            // Check that the fee list is well-formed\n            require(\n                _args.feeAmounts.length == _args.feeTokenContracts.length,\n                \"Malformed list of fees\"\n            );\n        }\n\n        bytes32 argsHash = keccak256(\n            abi.encode(\n                state_bridgeId,\n                // bytes32 encoding of \"logicCall\"\n                0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n                _args.transferAmounts,\n                _args.transferTokenContracts,\n                _args.feeAmounts,\n                _args.feeTokenContracts,\n                _args.logicContractAddress,\n                _args.payload,\n                _args.timeOut,\n                _args.invalidationId,\n                _args.invalidationNonce\n            )\n        );\n\n        {\n            // Check that enough current validators have signed off on the transaction batch and valset\n            checkValidatorSignatures(\n                _currentValidators,\n                _currentPowers,\n                _v,\n                _r,\n                _s,\n                // Get hash of the transaction batch and checkpoint\n                argsHash,\n                state_powerThreshold\n            );\n        }\n\n        // ACTIONS\n\n        // Update invaldiation nonce\n        state_invalidationMapping[_args.invalidationId] = _args\n            .invalidationNonce;\n\n        // Send tokens to the logic contract\n        for (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n            IERC20(_args.transferTokenContracts[i]).safeTransfer(\n                _args.logicContractAddress,\n                _args.transferAmounts[i]\n            );\n        }\n\n        // Make call to logic contract\n        bytes memory returnData = Address.functionCall(\n            _args.logicContractAddress,\n            _args.payload\n        );\n\n        // Send fees to msg.sender\n        for (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n            IERC20(_args.feeTokenContracts[i]).safeTransfer(\n                msg.sender,\n                _args.feeAmounts[i]\n            );\n        }\n\n        // LOGS scoped to reduce stack depth\n        {\n            state_lastEventNonce = state_lastEventNonce.add(1);\n            emit LogicCallEvent(\n                _args.invalidationId,\n                _args.invalidationNonce,\n                returnData,\n                state_lastEventNonce\n            );\n        }\n    }","contract":"SeeleBridge","time":0}]}