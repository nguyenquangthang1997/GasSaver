{"time":140,"results":[{"type":"state-data-arrangement ","before":"\nstring public METAHELMET_PROVENANCE = \"\";\nuint256 public constant PRICE = 101010000000000000;\nuint256 public constant MAX_METAHELMETS = 10101;\nuint256 public constant MAX_PURCHASE = 7;\nbool public saleIsActive = false;\nmapping (address => uint256) public whitelistMinted;\naddress public WHITELIST_SIGNER;","after":"string public METAHELMET_PROVENANCE = \"\";\nuint256 public constant PRICE = 101010000000000000;\nuint256 public constant MAX_METAHELMETS = 10101;\nuint256 public constant MAX_PURCHASE = 7;\nmapping (address => uint256) public whitelistMinted;\naddress public WHITELIST_SIGNER;\nbool public saleIsActive = false;\n","contract":"Metahelmet","time":0},{"type":"external-function ","before":"function preMintMetahelmet(uint256 numberOfTokens, uint max, bytes memory signature) public payable {\n        bytes32 hash;\n        require(WHITELIST_SIGNER != address(0), \"Pre-Mint is not available yet\");\n        require(saleIsActive == false, \"Impossible Pre-Mint a Matahelmet when sale is active\");   \n        require(numberOfTokens <= MAX_PURCHASE, \"Can only mint 7 tokens at a time\");\n        require(totalSupply().add(numberOfTokens) <= MAX_METAHELMETS, \"Purchase would exceed max supply of Metahelmets\");\n        require(PRICE.mul(numberOfTokens) <= msg.value, \"Ether value sent is not correct\");\n\n        /*\n         * keccak256(address,number);\n         */\n        hash = keccak256(abi.encodePacked(_msgSender(), max));\n\n        /*\n         * Check Signature\n         */ \n        require(recover(hash,signature) == WHITELIST_SIGNER, \"Invalid Signature\");\n\n        /*\n         * Check max min reached\n         */ \n        require(whitelistMinted[_msgSender()].add(numberOfTokens) <= max, \"Max mint reached\");\n\n        /*\n         * Update total minted in preMint state\n         */\n        whitelistMinted[_msgSender()] = whitelistMinted[_msgSender()].add(numberOfTokens);\n\n        uint supply = totalSupply();\n        for(uint i = 0; i < numberOfTokens; i++) {\n            _safeMint(_msgSender(), supply+i);\n        }\n    }","after":"function preMintMetahelmet(uint256 numberOfTokens, uint max, bytes calldata signature) public payable {\n        bytes32 hash;\n        require(WHITELIST_SIGNER != address(0), \"Pre-Mint is not available yet\");\n        require(saleIsActive == false, \"Impossible Pre-Mint a Matahelmet when sale is active\");   \n        require(numberOfTokens <= MAX_PURCHASE, \"Can only mint 7 tokens at a time\");\n        require(totalSupply().add(numberOfTokens) <= MAX_METAHELMETS, \"Purchase would exceed max supply of Metahelmets\");\n        require(PRICE.mul(numberOfTokens) <= msg.value, \"Ether value sent is not correct\");\n\n        /*\n         * keccak256(address,number);\n         */\n        hash = keccak256(abi.encodePacked(_msgSender(), max));\n\n        /*\n         * Check Signature\n         */ \n        require(recover(hash,signature) == WHITELIST_SIGNER, \"Invalid Signature\");\n\n        /*\n         * Check max min reached\n         */ \n        require(whitelistMinted[_msgSender()].add(numberOfTokens) <= max, \"Max mint reached\");\n\n        /*\n         * Update total minted in preMint state\n         */\n        whitelistMinted[_msgSender()] = whitelistMinted[_msgSender()].add(numberOfTokens);\n\n        uint supply = totalSupply();\n        for(uint i = 0; i < numberOfTokens; i++) {\n            _safeMint(_msgSender(), supply+i);\n        }\n    }","contract":"Metahelmet","time":0},{"type":"external-function ","before":"function setProvenanceHash(string memory provenanceHash) public onlyOwner {\n        METAHELMET_PROVENANCE = provenanceHash;\n    }","after":"function setProvenanceHash(string calldata provenanceHash) public onlyOwner {\n        METAHELMET_PROVENANCE = provenanceHash;\n    }","contract":"Metahelmet","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }","after":"function setBaseURI(string calldata baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }","contract":"Metahelmet","time":0}]}