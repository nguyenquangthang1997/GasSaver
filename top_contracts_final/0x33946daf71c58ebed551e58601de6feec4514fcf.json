{"time":50,"results":[{"type":"external-function ","before":"function buyToken(\n        uint256[] memory _tokenIds,\n        uint256 _price,\n        address _paymentToken,\n        address _receiver,\n        bytes memory _signature,\n        uint256 _timestamp\n    ) external payable {\n        require(_tokenIds.length == 1, \"More than one token\");\n        require(_timestamp + _transactionOffset >= block.timestamp, \"Transaction timed out\");\n        require(\n            verifySignature(_tokenIds, _price, _paymentToken, _signature, _timestamp),\n            \"Signature mismatch\"\n        );\n        if (_price != 0) {\n            if (_paymentToken == address(0)) {\n                require(msg.value >= _price, \"Not enough ether\");\n                if (_price < msg.value) {\n                    payable(msg.sender).transfer(msg.value - _price);\n                }\n            } else {\n                require(\n                    IERC20(_paymentToken).transferFrom(\n                        msg.sender,\n                        address(this),\n                        _price\n                    )\n                );\n            }\n        }\n        address[] memory receivers = new address[](1);\n        receivers[0] = _receiver;\n        IUniqCollections(_storeAddress).batchMintSelectedIds(\n            _tokenIds,\n            receivers\n        );\n    }","after":"function buyToken(\n        uint256[] calldata _tokenIds,\n        uint256 _price,\n        address _paymentToken,\n        address _receiver,\n        bytes calldata _signature,\n        uint256 _timestamp\n    ) external payable {\n        require(_tokenIds.length == 1, \"More than one token\");\n        require(_timestamp + _transactionOffset >= block.timestamp, \"Transaction timed out\");\n        require(\n            verifySignature(_tokenIds, _price, _paymentToken, _signature, _timestamp),\n            \"Signature mismatch\"\n        );\n        if (_price != 0) {\n            if (_paymentToken == address(0)) {\n                require(msg.value >= _price, \"Not enough ether\");\n                if (_price < msg.value) {\n                    payable(msg.sender).transfer(msg.value - _price);\n                }\n            } else {\n                require(\n                    IERC20(_paymentToken).transferFrom(\n                        msg.sender,\n                        address(this),\n                        _price\n                    )\n                );\n            }\n        }\n        address[] memory receivers = new address[](1);\n        receivers[0] = _receiver;\n        IUniqCollections(_storeAddress).batchMintSelectedIds(\n            _tokenIds,\n            receivers\n        );\n    }","contract":"UniqStoreHelper","time":0},{"type":"external-function ","before":"function buyTokens(\n        uint256[] memory _tokenIds,\n        uint256 _priceForPackage,\n        address _paymentToken,\n        address _receiver,\n        bytes memory _signature,\n        uint256 _timestamp\n    ) external payable {\n        require(_timestamp + _transactionOffset >= block.timestamp, \"Transaction timed out\");\n        require(\n            verifySignature(\n                _tokenIds,\n                _priceForPackage,\n                _paymentToken,\n                _signature,\n                _timestamp\n            ),\n            \"Signature mismatch\"\n        );\n        if (_priceForPackage != 0) {\n            if (_paymentToken == address(0)) {\n                require(msg.value >= _priceForPackage, \"Not enough ether\");\n                if (_priceForPackage < msg.value) {\n                    payable(msg.sender).transfer(msg.value - _priceForPackage);\n                }\n            } else {\n                require(\n                    IERC20(_paymentToken).transferFrom(\n                        msg.sender,\n                        address(this),\n                        _priceForPackage\n                    )\n                );\n            }\n        }\n        address[] memory _receivers = new address[](_tokenIds.length);\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            _receivers[i] = _receiver;\n        }\n        IUniqCollections(_storeAddress).batchMintSelectedIds(\n            _tokenIds,\n            _receivers\n        );\n    }","after":"function buyTokens(\n        uint256[] calldata _tokenIds,\n        uint256 _priceForPackage,\n        address _paymentToken,\n        address _receiver,\n        bytes calldata _signature,\n        uint256 _timestamp\n    ) external payable {\n        require(_timestamp + _transactionOffset >= block.timestamp, \"Transaction timed out\");\n        require(\n            verifySignature(\n                _tokenIds,\n                _priceForPackage,\n                _paymentToken,\n                _signature,\n                _timestamp\n            ),\n            \"Signature mismatch\"\n        );\n        if (_priceForPackage != 0) {\n            if (_paymentToken == address(0)) {\n                require(msg.value >= _priceForPackage, \"Not enough ether\");\n                if (_priceForPackage < msg.value) {\n                    payable(msg.sender).transfer(msg.value - _priceForPackage);\n                }\n            } else {\n                require(\n                    IERC20(_paymentToken).transferFrom(\n                        msg.sender,\n                        address(this),\n                        _priceForPackage\n                    )\n                );\n            }\n        }\n        address[] memory _receivers = new address[](_tokenIds.length);\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            _receivers[i] = _receiver;\n        }\n        IUniqCollections(_storeAddress).batchMintSelectedIds(\n            _tokenIds,\n            _receivers\n        );\n    }","contract":"UniqStoreHelper","time":0},{"type":"external-function ","before":"function pEditTokenUri(string memory _ttokenUri) external onlyOwner {\n        IUniqCollections(_storeAddress).editTokenUri(_ttokenUri);\n    }","after":"function pEditTokenUri(string calldata _ttokenUri) external onlyOwner {\n        IUniqCollections(_storeAddress).editTokenUri(_ttokenUri);\n    }","contract":"UniqStoreHelper","time":0},{"type":"external-function ","before":"function pBatchMintSelectedIds(\n        uint256[] memory _ids,\n        address[] memory _addresses\n    ) external onlyOwner {\n        IUniqCollections(_storeAddress).batchMintSelectedIds(_ids, _addresses);\n    }","after":"function pBatchMintSelectedIds(\n        uint256[] calldata _ids,\n        address[] calldata _addresses\n    ) external onlyOwner {\n        IUniqCollections(_storeAddress).batchMintSelectedIds(_ids, _addresses);\n    }","contract":"UniqStoreHelper","time":0}]}