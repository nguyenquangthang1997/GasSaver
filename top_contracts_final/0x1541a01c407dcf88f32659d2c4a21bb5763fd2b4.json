{"time":263,"results":[{"type":"external-function ","before":"function withdraw(\n    bytes32 transactionHash,\n    address tokenContract,\n    address recipient,\n    uint256 value,\n    uint8[] memory v,\n    bytes32[] memory r,\n    bytes32[] memory s\n  ) external {\n    require(tokenContract != address(0x0), \"should provide a token contract\");\n    require(value > 0, \"should provide value\");\n    require(transactionHash > 0, \"TX hash should be provided\");\n    require(recipient == msg.sender, \"should be the recipient\");\n\n    bytes32 hash = prefixed(keccak256(abi.encodePacked(PREFIX, transactionHash, tokenContract, recipient, value)));\n\n    hashStore.addHash(hash);\n\n    require(v.length > 0, \"should provide signatures at least one signature\");\n    require(v.length == r.length, \"should the same number of inputs for signatures (r)\");\n    require(v.length == s.length, \"should the same number of inputs for signatures (s)\");\n\n    require(checkSignatures(hash, v.length, v, r, s) >= requiredOperators, \"not enough signatures to proceed\");\n\n    ERC721Mintable(tokenContract).transfer(recipient, value);\n\n    LogWithdraw(transactionHash, tokenContract, recipient, value);\n  }","after":"function withdraw(\n    bytes32 transactionHash,\n    address tokenContract,\n    address recipient,\n    uint256 value,\n    uint8[] calldata v,\n    bytes32[] calldata r,\n    bytes32[] calldata s\n  ) external {\n    require(tokenContract != address(0x0), \"should provide a token contract\");\n    require(value > 0, \"should provide value\");\n    require(transactionHash > 0, \"TX hash should be provided\");\n    require(recipient == msg.sender, \"should be the recipient\");\n\n    bytes32 hash = prefixed(keccak256(abi.encodePacked(PREFIX, transactionHash, tokenContract, recipient, value)));\n\n    hashStore.addHash(hash);\n\n    require(v.length > 0, \"should provide signatures at least one signature\");\n    require(v.length == r.length, \"should the same number of inputs for signatures (r)\");\n    require(v.length == s.length, \"should the same number of inputs for signatures (s)\");\n\n    require(checkSignatures(hash, v.length, v, r, s) >= requiredOperators, \"not enough signatures to proceed\");\n\n    ERC721Mintable(tokenContract).transfer(recipient, value);\n\n    LogWithdraw(transactionHash, tokenContract, recipient, value);\n  }","contract":"HomeGate","time":0},{"type":"external-function ","before":"function migrate(address[] memory tokenContracts, address newOwner) public onlyOwner {\n    transferTokens(tokenContracts, newOwner);\n    transferHashStoreOwnership(newOwner);\n  }","after":"function migrate(address[] calldata tokenContracts, address newOwner) public onlyOwner {\n    transferTokens(tokenContracts, newOwner);\n    transferHashStoreOwnership(newOwner);\n  }","contract":"HomeGate","time":0},{"type":"external-function ","before":"function updateLocation(address operator, string memory location) public onlyOwner {\n    require(operators[operator], \"cannot find this operator\");\n\n    operatorLocation[operator] = location;\n\n    emit LocationUpdated(operator, location);\n  }","after":"function updateLocation(address operator, string calldata location) public onlyOwner {\n    require(operators[operator], \"cannot find this operator\");\n\n    operatorLocation[operator] = location;\n\n    emit LocationUpdated(operator, location);\n  }","contract":"HomeGate","time":0}]}