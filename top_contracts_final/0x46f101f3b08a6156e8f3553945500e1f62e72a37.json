{"time":145,"results":[{"type":"external-function ","before":"function mintBySignature(signParams calldata _p, bytes memory _signature) public nonReentrant{\n        require(block.timestamp <= _p.expiration, \"ticket expired\");\n        require(_msgSender() == _p.receiver, \"can't claim by other\");\n        require(!nonceUsed[_p.nonce], \"signature used\");\n        bytes32 message = prefixed(\n            keccak256(abi.encodePacked(\n                _p.nonce,\n                _p.tokenId, \n                _p.amount, \n                _p.receiver,\n                _p.expiration\n            ))\n        );\n        require(\n            verifySignature(message, _signature, owner()),\n            \"verification failed\"\n        );\n        nonceUsed[_p.nonce] = true;\n        _mintUpdateSupply(_msgSender(), _p.tokenId, _p.amount, \"\");\n    }","after":"function mintBySignature(signParams calldata _p, bytes calldata _signature) public nonReentrant{\n        require(block.timestamp <= _p.expiration, \"ticket expired\");\n        require(_msgSender() == _p.receiver, \"can't claim by other\");\n        require(!nonceUsed[_p.nonce], \"signature used\");\n        bytes32 message = prefixed(\n            keccak256(abi.encodePacked(\n                _p.nonce,\n                _p.tokenId, \n                _p.amount, \n                _p.receiver,\n                _p.expiration\n            ))\n        );\n        require(\n            verifySignature(message, _signature, owner()),\n            \"verification failed\"\n        );\n        nonceUsed[_p.nonce] = true;\n        _mintUpdateSupply(_msgSender(), _p.tokenId, _p.amount, \"\");\n    }","contract":"BoredMummyWakingUpCandy","time":0},{"type":"external-function ","before":"function setURI(string memory newuri) public virtual onlyOwner {\n        _setURI(newuri);\n    }","after":"function setURI(string calldata newuri) public virtual onlyOwner {\n        _setURI(newuri);\n    }","contract":"BoredMummyWakingUpCandy","time":0},{"type":"external-function ","before":"function setCustomURI(uint256 _tokenId, string memory _newURI)\n        public\n        virtual\n        onlyOwner\n    {\n        customUri[_tokenId] = _newURI;\n        emit URI(_newURI, _tokenId);\n    }","after":"function setCustomURI(uint256 _tokenId, string calldata _newURI)\n        public\n        virtual\n        onlyOwner\n    {\n        customUri[_tokenId] = _newURI;\n        emit URI(_newURI, _tokenId);\n    }","contract":"BoredMummyWakingUpCandy","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"BoredMummyWakingUpCandy","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"BoredMummyWakingUpCandy","time":0}]}