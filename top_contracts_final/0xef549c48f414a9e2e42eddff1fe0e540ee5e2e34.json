{"time":118,"results":[{"type":"external-function ","before":"function setURI(string memory uri) external onlyOwner {\n        _uri = uri;\n    }","after":"function setURI(string calldata uri) external onlyOwner {\n        _uri = uri;\n    }","contract":"NFT","time":0},{"type":"external-function ","before":"function claim(bytes32[] memory proof) external {\n        require(_root != 0, 'merkle root not set');\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        require(verify(proof, _root, leaf), 'sender not eligible to claim');\n\n        require(!_claimed[msg.sender], 'already claimed');\n        _claimed[msg.sender] = true;\n\n        // We cannot just use balanceOf to create the new tokenId because tokens\n        // can be burned (destroyed), so we need a separate counter.\n        _mint(msg.sender, _nextId.current());\n        _nextId.increment();\n    }","after":"function claim(bytes32[] calldata proof) external {\n        require(_root != 0, 'merkle root not set');\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        require(verify(proof, _root, leaf), 'sender not eligible to claim');\n\n        require(!_claimed[msg.sender], 'already claimed');\n        _claimed[msg.sender] = true;\n\n        // We cannot just use balanceOf to create the new tokenId because tokens\n        // can be burned (destroyed), so we need a separate counter.\n        _mint(msg.sender, _nextId.current());\n        _nextId.increment();\n    }","contract":"NFT","time":0}]}