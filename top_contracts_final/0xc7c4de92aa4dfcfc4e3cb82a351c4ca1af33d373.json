{"time":169,"results":[{"type":"external-function ","before":"function mintPrivateSale(uint8 numTokens, bytes32[] memory proof) public payable {\n        require(!Address.isContract(msg.sender), \"Cannot mint to a contract\");\n\n        require(saleActive && block.timestamp >= saleStartsAt, 'Sale not active');\n        uint256 time = (block.timestamp);\n        require(time > privatesaleStartsAt && time < privatesaleEndsAt, 'Private sale over');\n        \n        // bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        require(MerkleProof.verify(proof, whitelistMerkleRoot, keccak256(abi.encodePacked(msg.sender))), 'Restricted Access');\n\n        require((_tokenIds.current() + numTokens ) <= MAX_TOKENS + RESERVED_GIVEAWAYS, 'Private sale sold');\n\n        require(msg.value >= SALE_PRICE * numTokens, 'Insufficient ETH');\n        require(numTokens <= MINT_BATCH_LIMIT && numTokens > 0, 'Invalid Num Token');\n\n        for (uint256 i = 0; i < numTokens; i++) {\n            _tokenIds.increment();\n            _safeMint(msg.sender, _tokenIds.current() );\n        }\n\n        emit TokenMinted(msg.sender, numTokens);\n    }","after":"function mintPrivateSale(uint8 numTokens, bytes32[] calldata proof) public payable {\n        require(!Address.isContract(msg.sender), \"Cannot mint to a contract\");\n\n        require(saleActive && block.timestamp >= saleStartsAt, 'Sale not active');\n        uint256 time = (block.timestamp);\n        require(time > privatesaleStartsAt && time < privatesaleEndsAt, 'Private sale over');\n        \n        // bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        require(MerkleProof.verify(proof, whitelistMerkleRoot, keccak256(abi.encodePacked(msg.sender))), 'Restricted Access');\n\n        require((_tokenIds.current() + numTokens ) <= MAX_TOKENS + RESERVED_GIVEAWAYS, 'Private sale sold');\n\n        require(msg.value >= SALE_PRICE * numTokens, 'Insufficient ETH');\n        require(numTokens <= MINT_BATCH_LIMIT && numTokens > 0, 'Invalid Num Token');\n\n        for (uint256 i = 0; i < numTokens; i++) {\n            _tokenIds.increment();\n            _safeMint(msg.sender, _tokenIds.current() );\n        }\n\n        emit TokenMinted(msg.sender, numTokens);\n    }","contract":"BillionBuns","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseContractURI) public onlyOwner {\n        baseURI = baseContractURI;\n    }","after":"function setBaseURI(string calldata baseContractURI) public onlyOwner {\n        baseURI = baseContractURI;\n    }","contract":"BillionBuns","time":0},{"type":"external-function ","before":"function setProvenanceHash(string memory provenanceHash) public onlyOwner {\n        emit ProvenanceHashSet(msg.sender,PROVENANCE_HASH,provenanceHash);\n        PROVENANCE_HASH = provenanceHash;\n        \n    }","after":"function setProvenanceHash(string calldata provenanceHash) public onlyOwner {\n        emit ProvenanceHashSet(msg.sender,PROVENANCE_HASH,provenanceHash);\n        PROVENANCE_HASH = provenanceHash;\n        \n    }","contract":"BillionBuns","time":0},{"type":"constant-restrict-modification  ","before":"string private contractMetadata = 'contract.json';","after":"string private constant contractMetadata = 'contract.json';","contract":"BillionBuns","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public saleStartsAt;","after":"uint256 public immutable saleStartsAt;","contract":"BillionBuns","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public publicsaleStartsAt;","after":"uint256 public immutable publicsaleStartsAt;","contract":"BillionBuns","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public privatesaleStartsAt;","after":"uint256 public immutable privatesaleStartsAt;","contract":"BillionBuns","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public privatesaleEndsAt;","after":"uint256 public immutable privatesaleEndsAt;","contract":"BillionBuns","time":1}]}