{"time":146,"results":[{"type":"state-data-arrangement ","before":"\n   string public constant name = \"NOIA Toke\n   string public constant symbol = \"NOI\n   uint8 public constant decimals = uint8(1\n   uint256 public tokensToMint = 1000000000e\n   address public burnAddre\n   mapping(address => bool) public noti\n   mapping(bytes32 => bool) private hashedT\n   bool public etherlessTransferEnabled = tr","after":"   string public constant name = \"NOIA Toke\n   string public constant symbol = \"NOI\n   uint256 public tokensToMint = 1000000000e\n   mapping(address => bool) public noti\n   mapping(bytes32 => bool) private hashedT\n   address public burnAddre\n   uint8 public constant decimals = uint8(1\n   bool public etherlessTransferEnabled = tr\n","contract":"NOIAToken","time":0},{"type":"external-function ","before":"   function transferPreSigned(\n        bytes memory _signature,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        onlyEtherlessTransferEnabled\n        returns (bool)\n    {\n        require(_to != address(0), \"Transfer to the zero address\");\n\n        bytes32 hashedParams = hashForSign(msg.sig, address(this), _to, _value, _fee, _nonce);\n        address from = hashedParams.toEthSignedMessageHash().recover(_signature);\n        require(from != address(0), \"Invalid signature\");\n\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\n        require(hashedTxs[hashedTx] == false, \"Nonce already used\");\n        hashedTxs[hashedTx] = true;\n\n        if (msg.sender == _to) {\n            _transfer(from, _to, _value.add(_fee));\n            _postTransfer(from, _to, _value.add(_fee));\n        } else {\n            _transfer(from, _to, _value);\n            _postTransfer(from, _to, _value);\n            _transfer(from, msg.sender, _fee);\n            _postTransfer(from, msg.sender, _fee);\n        }\n\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\n        return true;\n  ","after":"   function transferPreSigned(\n        bytes calldata _signature,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        onlyEtherlessTransferEnabled\n        returns (bool)\n    {\n        require(_to != address(0), \"Transfer to the zero address\");\n\n        bytes32 hashedParams = hashForSign(msg.sig, address(this), _to, _value, _fee, _nonce);\n        address from = hashedParams.toEthSignedMessageHash().recover(_signature);\n        require(from != address(0), \"Invalid signature\");\n\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\n        require(hashedTxs[hashedTx] == false, \"Nonce already used\");\n        hashedTxs[hashedTx] = true;\n\n        if (msg.sender == _to) {\n            _transfer(from, _to, _value.add(_fee));\n            _postTransfer(from, _to, _value.add(_fee));\n        } else {\n            _transfer(from, _to, _value);\n            _postTransfer(from, _to, _value);\n            _transfer(from, msg.sender, _fee);\n            _postTransfer(from, msg.sender, _fee);\n        }\n\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\n        return true;\n  ","contract":"NOIAToken","time":0}]}