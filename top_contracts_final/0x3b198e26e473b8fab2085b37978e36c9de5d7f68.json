{"time":88,"results":[{"type":"external-function ","before":"function onTokenTransfer(address _sender, uint256 _amount, bytes memory _data) external {\n        require(address(erc20Time) == _msgSender(), \"Sender address does not match expected\");\n        require(_amount > 0, \"The amount of the lock must not be zero\");\n        (uint256 _toChainId) = abi.decode(_data, (uint256));\n        (bool found,) = indexOfChainId(_toChainId);\n        require(found, \"ChainId not allowed\");\n        lastLockId ++;\n        emit Locked(_sender, _toChainId, lastLockId, _amount);\n    }","after":"function onTokenTransfer(address _sender, uint256 _amount, bytes calldata _data) external {\n        require(address(erc20Time) == _msgSender(), \"Sender address does not match expected\");\n        require(_amount > 0, \"The amount of the lock must not be zero\");\n        (uint256 _toChainId) = abi.decode(_data, (uint256));\n        (bool found,) = indexOfChainId(_toChainId);\n        require(found, \"ChainId not allowed\");\n        lastLockId ++;\n        emit Locked(_sender, _toChainId, lastLockId, _amount);\n    }","contract":"TimeLocker","time":0},{"type":"external-function ","before":"function unlock(uint256 _fromChainId, uint256 _burnId, uint256 _amount, bytes[] memory _signatures) external {\n        require(!burnIdsUsed[_fromChainId][_burnId], \"Burn id already used\");\n        bytes32 messageHash = keccak256(abi.encodePacked(_msgSender(), _fromChainId, block.chainid, _burnId, _amount));\n        require(checkSignatures(messageHash, _signatures), \"Incorrect signature(s)\");\n        burnIdsUsed[_fromChainId][_burnId] = true;\n        erc20Time.safeTransfer(_msgSender(), _amount);\n        emit Unlocked(_msgSender(), _fromChainId, _burnId, _amount);\n    }","after":"function unlock(uint256 _fromChainId, uint256 _burnId, uint256 _amount, bytes[] calldata _signatures) external {\n        require(!burnIdsUsed[_fromChainId][_burnId], \"Burn id already used\");\n        bytes32 messageHash = keccak256(abi.encodePacked(_msgSender(), _fromChainId, block.chainid, _burnId, _amount));\n        require(checkSignatures(messageHash, _signatures), \"Incorrect signature(s)\");\n        burnIdsUsed[_fromChainId][_burnId] = true;\n        erc20Time.safeTransfer(_msgSender(), _amount);\n        emit Unlocked(_msgSender(), _fromChainId, _burnId, _amount);\n    }","contract":"TimeLocker","time":0}]}