{"time":500,"results":[{"type":"state-data-arrangement ","before":"\nbool public stopped = false;\nmapping(address => bool) public feeWhitelist;\nuint256 public goodwill;\nuint256 affiliateSplit;\nmapping(address => bool) public affiliates;\nmapping(address => mapping(address => uint256)) public affiliateBalance;\nmapping(address => uint256) public totalAffiliateBalance;\nmapping(address => bool) public approvedTargets;\naddress internal constant ETHAddress =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;","after":"mapping(address => bool) public feeWhitelist;\nuint256 public goodwill;\nuint256 affiliateSplit;\nmapping(address => bool) public affiliates;\nmapping(address => mapping(address => uint256)) public affiliateBalance;\nmapping(address => uint256) public totalAffiliateBalance;\nmapping(address => bool) public approvedTargets;\naddress internal constant ETHAddress =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\nbool public stopped = false;\n","contract":"ZapBaseV2","time":0},{"type":"external-function ","before":"rn tokensRec;\n    }\n\n    /**\n        @notice Zap out in both tokens with permit\n        @param fromPoolAddress Pool from which to remove liquidity\n        @param incomingLP Quantity of LP to remove from pool\n        @param affiliate Affiliate address to share fees\n        @param permitData Encoded permit data, which contains owner, spender, value, deadline, r,s,v values \n        @return amountA Quantity of tokenA received\n        @return amountB Quantity of tokenB received\n    */\n    function ZapOut2PairTokenWithPermit(\n        address fromPoolAddress,\n        uint256 incomingLP,\n        address affiliate,\n        bytes calldata permitData\n    ) external stopInEmergency returns (uint256 amountA, uint256 amountB) {\n        // permit\n        _validatePool(fromPoolAddress);\n       ","after":"rn tokensRec;\n    }\n\n    /**\n        @notice Zap out in both tokens with permit\n        @param fromPoolAddress Pool from which to remove liquidity\n        @param incomingLP Quantity of LP to remove from pool\n        @param affiliate Affiliate address to share fees\n        @param permitData Encoded permit data, which contains owner, spender, value, deadline, r,s,v values \n        @return amountA Quantity of tokenA received\n        @return amountB Quantity of tokenB received\n    */\n    function ZapOut2PairTokenWithPermit(\n        address fromPoolAddress,\n        uint256 incomingLP,\n        address affiliate,\n        bytes calldata permitData\n    ) external stopInEmergency returns (uint256 amountA, uint256 amountB) {\n        // permit\n        _validatePool(fromPoolAddress);\n       ","contract":"UniswapV2_ZapOut_General_V4_0_1","time":0},{"type":"external-function ","before":" toTokens to sender\n        if (toTokenAddress == address(0)) {\n            totalGoodwillPortion = _subtractGoodwill(\n                ETHAddress,\n                tokensRec,\n                affiliate,\n                true\n            );\n\n            payable(msg.sender).transfer(tokensRec - totalGoodwillPortion);\n        } else {\n            totalGoodwillPortion = _subtractGoodwill(\n                toTokenAddress,\n                tokensRec,\n                affiliate,\n                true\n            );\n\n            IERC20(toTokenAddress).safeTransfer(\n                msg.sender,\n                tokensRec - totalGoodwillPortion\n            );\n        }\n\n        tokensRec = tokensRec - totalGoodwillPortion;\n\n        emit zapOut(msg.sender, fromPoolAddress, toTokenAddress, tokensRec)","after":" toTokens to sender\n        if (toTokenAddress == address(0)) {\n            totalGoodwillPortion = _subtractGoodwill(\n                ETHAddress,\n                tokensRec,\n                affiliate,\n                true\n            );\n\n            payable(msg.sender).transfer(tokensRec - totalGoodwillPortion);\n        } else {\n            totalGoodwillPortion = _subtractGoodwill(\n                toTokenAddress,\n                tokensRec,\n                affiliate,\n                true\n            );\n\n            IERC20(toTokenAddress).safeTransfer(\n                msg.sender,\n                tokensRec - totalGoodwillPortion\n            );\n        }\n\n        tokensRec = tokensRec - totalGoodwillPortion;\n\n        emit zapOut(msg.sender, fromPoolAddress, toTokenAddress, tokensRec)","contract":"Sushiswap_ZapOut_General_V3","time":0}]}