{"time":218,"results":[{"type":"struct-data-arrangement ","before":"\nbool isExist\nuint8 decimal\nuint256 userMinStake\nuint256 userMaxStake\nuint256 totalMaxStake\nuint256 lockableDays\nbool optionableStatus","after":"uint256 userMinStake\nuint256 userMaxStake\nuint256 totalMaxStake\nuint256 lockableDays\nbool isExist\nuint8 decimal\nbool optionableStatus\n","contract":"Admin","time":0},{"type":"external-function ","before":"function emergencyUnstake(\n    uint256 stakeId,\n    address userAddress,\n    address[] memory rewardtokens,\n    uint256[] memory amount\n  ) external onlyOwner {\n    // Checks\n    require(\n      stakingDetails[userAddress].stakedAmount[stakeId] > 0 &&\n        stakingDetails[userAddress].isActive[stakeId] == true,\n      \"EMERGENCY : Already Claimed (or) Insufficient Staked\"\n    );\n\n    // Balance check\n    require(\n      IERC20(stakingDetails[userAddress].tokenAddress[stakeId]).balanceOf(\n        address(this)\n      ) >= stakingDetails[userAddress].stakedAmount[stakeId],\n      \"EMERGENCY : Insufficient Balance\"\n    );\n\n    uint256 stakeAmount = stakingDetails[userAddress].stakedAmount[stakeId];\n    stakingDetails[userAddress].isActive[stakeId] = false;\n    stakingDetails[userAddress].stakedAmount[stakeId] = 0;\n\n    IERC20(stakingDetails[userAddress].tokenAddress[stakeId]).transfer(\n      userAddress,\n      stakeAmount\n    );\n\n    for (uint256 i; i < rewardtokens.length; i++) {\n      uint256 rewardsEarned = amount[i];\n\n      if (stakingDetails[userAddress].referrer[stakeId] != address(0)) {\n        uint256 refEarned = (rewardsEarned.mul(refPercentage)).div(100 ether);\n        rewardsEarned = rewardsEarned.sub(refEarned);\n\n        require(\n          IERC20(rewardtokens[i]).transfer(\n            stakingDetails[userAddress].referrer[stakeId],\n            refEarned\n          ),\n          \"EMERGENCY : Transfer Failed\"\n        );\n\n        emit ReferralEarn(\n          stakingDetails[userAddress].referrer[stakeId],\n          userAddress,\n          rewardtokens[i],\n          refEarned,\n          block.timestamp\n        );\n      }\n\n      sendToken(\n        userAddress,\n        stakingDetails[userAddress].tokenAddress[stakeId],\n        rewardtokens[i],\n        rewardsEarned\n      );\n    }\n\n    // Emit state changes\n    emit UnStake(\n      userAddress,\n      stakingDetails[userAddress].tokenAddress[stakeId],\n      stakeAmount,\n      block.timestamp,\n      stakeId\n    );\n  }","after":"function emergencyUnstake(\n    uint256 stakeId,\n    address userAddress,\n    address[] calldata rewardtokens,\n    uint256[] calldata amount\n  ) external onlyOwner {\n    // Checks\n    require(\n      stakingDetails[userAddress].stakedAmount[stakeId] > 0 &&\n        stakingDetails[userAddress].isActive[stakeId] == true,\n      \"EMERGENCY : Already Claimed (or) Insufficient Staked\"\n    );\n\n    // Balance check\n    require(\n      IERC20(stakingDetails[userAddress].tokenAddress[stakeId]).balanceOf(\n        address(this)\n      ) >= stakingDetails[userAddress].stakedAmount[stakeId],\n      \"EMERGENCY : Insufficient Balance\"\n    );\n\n    uint256 stakeAmount = stakingDetails[userAddress].stakedAmount[stakeId];\n    stakingDetails[userAddress].isActive[stakeId] = false;\n    stakingDetails[userAddress].stakedAmount[stakeId] = 0;\n\n    IERC20(stakingDetails[userAddress].tokenAddress[stakeId]).transfer(\n      userAddress,\n      stakeAmount\n    );\n\n    for (uint256 i; i < rewardtokens.length; i++) {\n      uint256 rewardsEarned = amount[i];\n\n      if (stakingDetails[userAddress].referrer[stakeId] != address(0)) {\n        uint256 refEarned = (rewardsEarned.mul(refPercentage)).div(100 ether);\n        rewardsEarned = rewardsEarned.sub(refEarned);\n\n        require(\n          IERC20(rewardtokens[i]).transfer(\n            stakingDetails[userAddress].referrer[stakeId],\n            refEarned\n          ),\n          \"EMERGENCY : Transfer Failed\"\n        );\n\n        emit ReferralEarn(\n          stakingDetails[userAddress].referrer[stakeId],\n          userAddress,\n          rewardtokens[i],\n          refEarned,\n          block.timestamp\n        );\n      }\n\n      sendToken(\n        userAddress,\n        stakingDetails[userAddress].tokenAddress[stakeId],\n        rewardtokens[i],\n        rewardsEarned\n      );\n    }\n\n    // Emit state changes\n    emit UnStake(\n      userAddress,\n      stakingDetails[userAddress].tokenAddress[stakeId],\n      stakeAmount,\n      block.timestamp,\n      stakeId\n    );\n  }","contract":"UnifarmV34","time":0},{"type":"external-function ","before":"function setDailyDistribution(\n    address[] memory stakedToken,\n    address[] memory rewardToken,\n    uint256[] memory dailyDistribution\n  ) public onlyOwner {\n    require(\n      stakedToken.length == rewardToken.length &&\n        rewardToken.length == dailyDistribution.length,\n      \"Invalid Input\"\n    );\n\n    for (uint8 i = 0; i < stakedToken.length; i++) {\n      require(\n        tokenDetails[stakedToken[i]].isExist &&\n          tokenDetails[rewardToken[i]].isExist,\n        \"Token not exist\"\n      );\n      tokenDailyDistribution[stakedToken[i]][\n        rewardToken[i]\n      ] = dailyDistribution[i];\n\n      emit DailyDistributionDetails(\n        stakedToken[i],\n        rewardToken[i],\n        dailyDistribution[i],\n        block.timestamp\n      );\n    }\n  }","after":"function setDailyDistribution(\n    address[] calldata stakedToken,\n    address[] calldata rewardToken,\n    uint256[] calldata dailyDistribution\n  ) public onlyOwner {\n    require(\n      stakedToken.length == rewardToken.length &&\n        rewardToken.length == dailyDistribution.length,\n      \"Invalid Input\"\n    );\n\n    for (uint8 i = 0; i < stakedToken.length; i++) {\n      require(\n        tokenDetails[stakedToken[i]].isExist &&\n          tokenDetails[rewardToken[i]].isExist,\n        \"Token not exist\"\n      );\n      tokenDailyDistribution[stakedToken[i]][\n        rewardToken[i]\n      ] = dailyDistribution[i];\n\n      emit DailyDistributionDetails(\n        stakedToken[i],\n        rewardToken[i],\n        dailyDistribution[i],\n        block.timestamp\n      );\n    }\n  }","contract":"UnifarmV34","time":0},{"type":"external-function ","before":"function updateSequence(\n    address stakedToken,\n    address[] memory rewardTokenSequence\n  ) public onlyOwner {\n    tokensSequenceList[stakedToken] = new address[](0);\n    require(tokenDetails[stakedToken].isExist, \"Staked Token Not Exist\");\n    for (uint8 i = 0; i < rewardTokenSequence.length; i++) {\n      require(rewardTokenSequence.length <= tokens.length, \"Invalid Input\");\n      require(\n        tokenDetails[rewardTokenSequence[i]].isExist,\n        \"Reward Token Not Exist\"\n      );\n      tokensSequenceList[stakedToken].push(rewardTokenSequence[i]);\n    }\n\n    emit SequenceDetails(\n      stakedToken,\n      tokensSequenceList[stakedToken],\n      block.timestamp\n    );\n  }","after":"function updateSequence(\n    address stakedToken,\n    address[] calldata rewardTokenSequence\n  ) public onlyOwner {\n    tokensSequenceList[stakedToken] = new address[](0);\n    require(tokenDetails[stakedToken].isExist, \"Staked Token Not Exist\");\n    for (uint8 i = 0; i < rewardTokenSequence.length; i++) {\n      require(rewardTokenSequence.length <= tokens.length, \"Invalid Input\");\n      require(\n        tokenDetails[rewardTokenSequence[i]].isExist,\n        \"Reward Token Not Exist\"\n      );\n      tokensSequenceList[stakedToken].push(rewardTokenSequence[i]);\n    }\n\n    emit SequenceDetails(\n      stakedToken,\n      tokensSequenceList[stakedToken],\n      block.timestamp\n    );\n  }","contract":"UnifarmV34","time":0},{"type":"external-function ","before":"function updateIntervalDays(uint256[] memory _interval) public onlyOwner {\n    intervalDays = new uint256[](0);\n\n    for (uint8 i = 0; i < _interval.length; i++) {\n      uint256 noD = stakeDuration.div(DAYS);\n      require(noD > _interval[i], \"Invalid Interval Day\");\n      intervalDays.push(_interval[i]);\n    }\n\n    emit IntervalDaysDetails(intervalDays, block.timestamp);\n  }","after":"function updateIntervalDays(uint256[] calldata _interval) public onlyOwner {\n    intervalDays = new uint256[](0);\n\n    for (uint8 i = 0; i < _interval.length; i++) {\n      uint256 noD = stakeDuration.div(DAYS);\n      require(noD > _interval[i], \"Invalid Interval Day\");\n      intervalDays.push(_interval[i]);\n    }\n\n    emit IntervalDaysDetails(intervalDays, block.timestamp);\n  }","contract":"UnifarmV34","time":0},{"type":"external-function ","before":"function setRewardCap(\n    address[] memory tokenAddresses,\n    uint256[] memory rewards\n  ) external onlyOwner returns (bool) {\n    require(tokenAddresses.length == rewards.length, \"Invalid elements\");\n    for (uint8 v = 0; v < tokenAddresses.length; v++) {\n      require(tokenDetails[tokenAddresses[v]].isExist, \"Token is not exist\");\n      require(rewards[v] > 0, \"Invalid Reward Amount\");\n      rewardCap[tokenAddresses[v]] = rewards[v];\n    }\n    return true;\n  }","after":"function setRewardCap(\n    address[] calldata tokenAddresses,\n    uint256[] calldata rewards\n  ) external onlyOwner returns (bool) {\n    require(tokenAddresses.length == rewards.length, \"Invalid elements\");\n    for (uint8 v = 0; v < tokenAddresses.length; v++) {\n      require(tokenDetails[tokenAddresses[v]].isExist, \"Token is not exist\");\n      require(rewards[v] > 0, \"Invalid Reward Amount\");\n      rewardCap[tokenAddresses[v]] = rewards[v];\n    }\n    return true;\n  }","contract":"UnifarmV34","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public poolStartTime;","after":"uint256 public immutable poolStartTime;","contract":"UnifarmV34","time":0},{"type":"immutable-restrict-modification ","before":"address public _admin;","after":"address public immutable _admin;","contract":"UnifarmV34","time":0}]}