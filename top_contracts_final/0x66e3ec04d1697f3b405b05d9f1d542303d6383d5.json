{"time":196,"results":[{"type":"external-function ","before":"function whitelistMint_rhh(uint256 tokenQuant, bytes memory _whitelistToken)\n        public\n        payable\n        virtual\n    {\n        \n        require(\n            (liveStatus == MintPhase.Whitelist) &&\n                (whitelistSigner == recoverSigner_94g(_whitelistToken)),\n            \"Either Whitelist Phase is not live or your Whitelist Code is invalid!\"\n        );\n\n        require(\n            tokenCounter + tokenQuant < maxSupply,\n            \"Would exceed max supply\"\n        );\n\n        require(\n            msg.value == price * tokenQuant,\n            \"Wrong amount of ETH sent - please check price!\"\n        );\n\n        require(\n            addressToNumberOfTokensMinted[msg.sender] + tokenQuant < maxMint,\n            \"Minting this many tokens takes you over your maximum amount!\"\n        );\n\n        // Increasing minted count in dictionary\n        addressToNumberOfTokensMinted[msg.sender] += tokenQuant;\n\n        for (uint256 i; i < tokenQuant; i++) {\n            _mint(msg.sender, tokenCounter);\n            tokenCounter = tokenCounter + 1;\n        }\n    }","after":"function whitelistMint_rhh(uint256 tokenQuant, bytes calldata _whitelistToken)\n        public\n        payable\n        virtual\n    {\n        \n        require(\n            (liveStatus == MintPhase.Whitelist) &&\n                (whitelistSigner == recoverSigner_94g(_whitelistToken)),\n            \"Either Whitelist Phase is not live or your Whitelist Code is invalid!\"\n        );\n\n        require(\n            tokenCounter + tokenQuant < maxSupply,\n            \"Would exceed max supply\"\n        );\n\n        require(\n            msg.value == price * tokenQuant,\n            \"Wrong amount of ETH sent - please check price!\"\n        );\n\n        require(\n            addressToNumberOfTokensMinted[msg.sender] + tokenQuant < maxMint,\n            \"Minting this many tokens takes you over your maximum amount!\"\n        );\n\n        // Increasing minted count in dictionary\n        addressToNumberOfTokensMinted[msg.sender] += tokenQuant;\n\n        for (uint256 i; i < tokenQuant; i++) {\n            _mint(msg.sender, tokenCounter);\n            tokenCounter = tokenCounter + 1;\n        }\n    }","contract":"MechNFT","time":0},{"type":"external-function ","before":"function reveal(string memory base) public onlyOwner {\n        require(\n            mutableMetadata, // Check to make sure the collection hasn't been frozen before allowing the metadata to change\n            \"Metadata is frozen on the blockchain forever\"\n        );\n        baseURI = base;\n        emit executedReveal(tokenCounter - revealedMechs);\n        revealedMechs = tokenCounter;\n    }","after":"function reveal(string calldata base) public onlyOwner {\n        require(\n            mutableMetadata, // Check to make sure the collection hasn't been frozen before allowing the metadata to change\n            \"Metadata is frozen on the blockchain forever\"\n        );\n        baseURI = base;\n        emit executedReveal(tokenCounter - revealedMechs);\n        revealedMechs = tokenCounter;\n    }","contract":"MechNFT","time":0},{"type":"immutable-restrict-modification ","before":"uint256 internal fee;","after":"uint256 internal immutable fee;","contract":"MechNFT","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 internal keyHash;","after":"bytes32 internal immutable keyHash;","contract":"MechNFT","time":0}]}