{"time":194,"results":[{"type":"state-data-arrangement ","before":"\nuint256 public constant TALAW_ID = 0;\nuint256 public constant VESTAL_ID = 1;\nuint256 public constant AZULE_ID = 2;\nuint256 public maxMintPerTransaction;\nuint256 public MINT_SUPPLY_PER_FACTION;\nuint256 public TEAM_SUPPLY_PER_FACTION;\nuint256 public constant MINT_PRICE = 188000000000000000;\nuint256 public talawMintCount = 0;\nuint256 public vestalMintCount = 0;\nuint256 public azuleMintCount = 0;\nbool private _isPresaleActive = false;\nbool private _isSaleActive = false;\nmapping(uint256 => uint256) factionForToken;\nmapping(address => bool) private presaleClaimed;\naddress private signVerifier = 0xf79e8a0d24cF91EE36c8a7e7dB8Aa95fbF7d6a8f;\nstring private _uri;\nbytes32 immutable public root;\nuint256 lastTokenId = 0;\nmapping(uint256 => bool) partnerNonceUsed;\nmapping(address => uint256) basePassNonce;","after":"uint256 public constant TALAW_ID = 0;\nuint256 public constant VESTAL_ID = 1;\nuint256 public constant AZULE_ID = 2;\nuint256 public maxMintPerTransaction;\nuint256 public MINT_SUPPLY_PER_FACTION;\nuint256 public TEAM_SUPPLY_PER_FACTION;\nuint256 public constant MINT_PRICE = 188000000000000000;\nuint256 public talawMintCount = 0;\nuint256 public vestalMintCount = 0;\nuint256 public azuleMintCount = 0;\nmapping(uint256 => uint256) factionForToken;\nmapping(address => bool) private presaleClaimed;\nstring private _uri;\nbytes32 immutable public root;\nuint256 lastTokenId = 0;\nmapping(uint256 => bool) partnerNonceUsed;\nmapping(address => uint256) basePassNonce;\naddress private signVerifier = 0xf79e8a0d24cF91EE36c8a7e7dB8Aa95fbF7d6a8f;\nbool private _isPresaleActive = false;\nbool private _isSaleActive = false;\n","contract":"LegendsOfVenariPass","time":0},{"type":"external-function ","before":"function setBaseURI(string memory uri) external onlyOwner {\n    _uri = uri;\n  }","after":"function setBaseURI(string calldata uri) external onlyOwner {\n    _uri = uri;\n  }","contract":"LegendsOfVenariPass","time":0},{"type":"external-function ","before":"function partnerMint(\n    uint256[] memory factionIds,\n    address[] memory addresses,\n    uint256 nonce,\n    bytes memory sig\n  ) external payable nonReentrant {\n    require(_isPresaleActive, \"Presale not active\");\n    require(\n      (MINT_PRICE * factionIds.length) == msg.value,\n      \"ETH sent does not match required payment\"\n    );\n    require(factionIds.length == addresses.length, \"Faction ids much have the same length as addresses\");\n    require(!partnerNonceUsed[nonce], \"Nonce already used.\");\n\n    // Verify signature\n    bytes32 message = getPartnerSigningHash(\n      msg.sender,\n      factionIds,\n      addresses,\n      nonce\n    ).toEthSignedMessageHash();\n    require(\n      ECDSA.recover(message, sig) == signVerifier,\n      \"Permission to call this function failed\"\n    );\n\n    partnerNonceUsed[nonce] = true;\n\n    // Mint\n    for (uint256 i = 0; i < factionIds.length; i++) {\n        uint256 factionId = factionIds[i];\n        require(_isValidFactionId(factionId), \"Faction is not valid\");\n        _handleFactionMint(1, factionId, addresses[i], MINT_SUPPLY_PER_FACTION);\n    }\n  }","after":"function partnerMint(\n    uint256[] calldata factionIds,\n    address[] calldata addresses,\n    uint256 nonce,\n    bytes calldata sig\n  ) external payable nonReentrant {\n    require(_isPresaleActive, \"Presale not active\");\n    require(\n      (MINT_PRICE * factionIds.length) == msg.value,\n      \"ETH sent does not match required payment\"\n    );\n    require(factionIds.length == addresses.length, \"Faction ids much have the same length as addresses\");\n    require(!partnerNonceUsed[nonce], \"Nonce already used.\");\n\n    // Verify signature\n    bytes32 message = getPartnerSigningHash(\n      msg.sender,\n      factionIds,\n      addresses,\n      nonce\n    ).toEthSignedMessageHash();\n    require(\n      ECDSA.recover(message, sig) == signVerifier,\n      \"Permission to call this function failed\"\n    );\n\n    partnerNonceUsed[nonce] = true;\n\n    // Mint\n    for (uint256 i = 0; i < factionIds.length; i++) {\n        uint256 factionId = factionIds[i];\n        require(_isValidFactionId(factionId), \"Faction is not valid\");\n        _handleFactionMint(1, factionId, addresses[i], MINT_SUPPLY_PER_FACTION);\n    }\n  }","contract":"LegendsOfVenariPass","time":0},{"type":"external-function ","before":"function mintToAddress(\n    address[] memory addresses,\n    uint256[] memory factionIds\n  ) external onlyOwner {\n    require(factionIds.length == addresses.length, \"Faction ids much have the same length as addresses\");\n\n    // Mint\n    for (uint256 i = 0; i < factionIds.length; i++) {\n        uint256 factionId = factionIds[i];\n        require(_isValidFactionId(factionId), \"Faction is not valid\");\n        _handleFactionMint(1, factionId, addresses[i], MINT_SUPPLY_PER_FACTION + TEAM_SUPPLY_PER_FACTION);\n    }\n  }","after":"function mintToAddress(\n    address[] calldata addresses,\n    uint256[] calldata factionIds\n  ) external onlyOwner {\n    require(factionIds.length == addresses.length, \"Faction ids much have the same length as addresses\");\n\n    // Mint\n    for (uint256 i = 0; i < factionIds.length; i++) {\n        uint256 factionId = factionIds[i];\n        require(_isValidFactionId(factionId), \"Faction is not valid\");\n        _handleFactionMint(1, factionId, addresses[i], MINT_SUPPLY_PER_FACTION + TEAM_SUPPLY_PER_FACTION);\n    }\n  }","contract":"LegendsOfVenariPass","time":0},{"type":"external-function ","before":"function redeemBasePass(\n    uint256 factionId,\n    bytes memory sig\n  ) external {\n    require(_isValidFactionId(factionId), \"Faction does not exist\");\n\n    // Verify signature\n    bytes32 message = getBasePassSigningHash(\n      msg.sender,\n      factionId\n    ).toEthSignedMessageHash();\n    require(\n      ECDSA.recover(message, sig) == signVerifier,\n      \"Permission to call this function failed\"\n    );\n\n    basePassNonce[msg.sender]++;\n\n    if (factionId == TALAW_ID) {\n      talawMintCount++;\n    } else if (factionId == VESTAL_ID) {\n      vestalMintCount++;\n    } else if (factionId == AZULE_ID) {\n      azuleMintCount++;\n    }\n\n    _mint(msg.sender, 1, factionId);\n  }","after":"function redeemBasePass(\n    uint256 factionId,\n    bytes calldata sig\n  ) external {\n    require(_isValidFactionId(factionId), \"Faction does not exist\");\n\n    // Verify signature\n    bytes32 message = getBasePassSigningHash(\n      msg.sender,\n      factionId\n    ).toEthSignedMessageHash();\n    require(\n      ECDSA.recover(message, sig) == signVerifier,\n      \"Permission to call this function failed\"\n    );\n\n    basePassNonce[msg.sender]++;\n\n    if (factionId == TALAW_ID) {\n      talawMintCount++;\n    } else if (factionId == VESTAL_ID) {\n      vestalMintCount++;\n    } else if (factionId == AZULE_ID) {\n      azuleMintCount++;\n    }\n\n    _mint(msg.sender, 1, factionId);\n  }","contract":"LegendsOfVenariPass","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public MINT_SUPPLY_PER_FACTION;","after":"uint256 public immutable MINT_SUPPLY_PER_FACTION;","contract":"LegendsOfVenariPass","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public TEAM_SUPPLY_PER_FACTION;","after":"uint256 public immutable TEAM_SUPPLY_PER_FACTION;","contract":"LegendsOfVenariPass","time":1}]}