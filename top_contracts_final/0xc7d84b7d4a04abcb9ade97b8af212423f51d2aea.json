{"time":170,"results":[{"type":"state-data-arrangement ","before":"\nmapping(bytes => uint256) private usedTickets;\nmapping(uint256 => address) private burnedTokens;\nstring public baseTokenURI;\nbool public burnActive;\nuint256 public startPresaleDate = 1642021200;\nuint256 public startMintDate = 1642032000;\nuint256 public constant MAX_SUPPLY = 5000;\nuint256 public constant MINT_PRICE = 0.1 ether;\nuint256 public constant MAX_PURCHASE_COUNT = 20;\nuint256 public constant MINTABLE_PRESALE = 4;\naddress private presaleSigner;","after":"mapping(bytes => uint256) private usedTickets;\nmapping(uint256 => address) private burnedTokens;\nstring public baseTokenURI;\nuint256 public startPresaleDate = 1642021200;\nuint256 public startMintDate = 1642032000;\nuint256 public constant MAX_SUPPLY = 5000;\nuint256 public constant MINT_PRICE = 0.1 ether;\nuint256 public constant MAX_PURCHASE_COUNT = 20;\nuint256 public constant MINTABLE_PRESALE = 4;\naddress private presaleSigner;\nbool public burnActive;\n","contract":"Gemma","time":0},{"type":"external-function ","before":"function mint(uint256 numberOfTokens, bytes memory pass)\n    public\n    payable\n    nonReentrant\n  {\n    if (\n      startPresaleDate <= block.timestamp && startMintDate > block.timestamp\n    ) {\n      uint256 mintablePresale = validateTicket(pass);\n      require(numberOfTokens <= mintablePresale, \"G: Minting Too Many Presale\");\n      useTicket(pass, numberOfTokens);\n    } else {\n      require(startMintDate <= block.timestamp, \"G: Sale Not Started\");\n      require(numberOfTokens <= MAX_PURCHASE_COUNT, \"G: Minting Too Many\");\n    }\n\n    require(totalMinted() + numberOfTokens <= MAX_SUPPLY, \"G: Sold Out\");\n\n    require(\n      msg.value >= numberOfTokens * MINT_PRICE,\n      \"G: Insufficient Payment\"\n    );\n\n    for (uint256 i = 0; i < numberOfTokens; i++) {\n      _safeMint(msg.sender);\n    }\n  }","after":"function mint(uint256 numberOfTokens, bytes calldata pass)\n    public\n    payable\n    nonReentrant\n  {\n    if (\n      startPresaleDate <= block.timestamp && startMintDate > block.timestamp\n    ) {\n      uint256 mintablePresale = validateTicket(pass);\n      require(numberOfTokens <= mintablePresale, \"G: Minting Too Many Presale\");\n      useTicket(pass, numberOfTokens);\n    } else {\n      require(startMintDate <= block.timestamp, \"G: Sale Not Started\");\n      require(numberOfTokens <= MAX_PURCHASE_COUNT, \"G: Minting Too Many\");\n    }\n\n    require(totalMinted() + numberOfTokens <= MAX_SUPPLY, \"G: Sold Out\");\n\n    require(\n      msg.value >= numberOfTokens * MINT_PRICE,\n      \"G: Insufficient Payment\"\n    );\n\n    for (uint256 i = 0; i < numberOfTokens; i++) {\n      _safeMint(msg.sender);\n    }\n  }","contract":"Gemma","time":0},{"type":"external-function ","before":"function setBaseURI(string memory _baseTokenURI) external onlyOwner {\n    baseTokenURI = _baseTokenURI;\n  }","after":"function setBaseURI(string calldata _baseTokenURI) external onlyOwner {\n    baseTokenURI = _baseTokenURI;\n  }","contract":"Gemma","time":0},{"type":"immutable-restrict-modification ","before":"address private presaleSigner;","after":"address private immutable presaleSigner;","contract":"Gemma","time":0}]}