{"time":838,"results":[{"type":"struct-data-arrangement ","before":"\n   address sig\n   address pr\n   address to\n   uint256 toke\n   uint256 amo\n   address strat\n   address curre\n   address recipi\n   uint256 deadl\n   bytes par\n   uint\n   bytes3\n   bytes3","after":"   uint256 toke\n   uint256 amo\n   uint256 deadl\n   bytes par\n   bytes3\n   bytes3\n   address sig\n   address pr\n   address to\n   address strat\n   address curre\n   address recipi\n   uint\n","contract":"Orders","time":1},{"type":"external-function ","before":"   function setTokenURI(uint256 id, string memory newURI) external override onlyOwner {\n        _uris[id] = newURI;\n\n        emit SetTokenURI(id, newURI);\n  ","after":"   function setTokenURI(uint256 id, string calldata newURI) external override onlyOwner {\n        _uris[id] = newURI;\n\n        emit SetTokenURI(id, newURI);\n  ","contract":"NFT721V1","time":0},{"type":"external-function ","before":"   function setBaseURI(string memory uri) external override onlyOwner {\n        __baseURI = uri;\n\n        emit SetBaseURI(uri);\n  ","after":"   function setBaseURI(string calldata uri) external override onlyOwner {\n        __baseURI = uri;\n\n        emit SetBaseURI(uri);\n  ","contract":"NFT721V1","time":0},{"type":"external-function ","before":"   function mint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _safeMint(to, tokenId, data);\n  ","after":"   function mint(\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _safeMint(to, tokenId, data);\n  ","contract":"NFT721V1","time":0},{"type":"external-function ","before":"   function mintBatch(\n        address to,\n        uint256[] memory tokenIds,\n        bytes memory data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _safeMint(to, tokenIds[i], data);\n        }\n  ","after":"   function mintBatch(\n        address to,\n        uint256[] calldata tokenIds,\n        bytes calldata data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _safeMint(to, tokenIds[i], data);\n        }\n  ","contract":"NFT721V1","time":0},{"type":"external-function ","before":"   function burnBatch(uint256[] memory tokenIds) external override {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            require(ownerOf(tokenId) == msg.sender, \"SHOYU: FORBIDDEN\");\n\n            _burn(tokenId);\n        }\n  ","after":"   function burnBatch(uint256[] calldata tokenIds) external override {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            require(ownerOf(tokenId) == msg.sender, \"SHOYU: FORBIDDEN\");\n\n            _burn(tokenId);\n        }\n  ","contract":"NFT721V1","time":0},{"type":"external-function ","before":"function cancel(Orders.Ask memory order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","after":"function cancel(Orders.Ask calldata order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","contract":"NFT721V1","time":0},{"type":"external-function ","before":"function bid(Orders.Ask memory askOrder, Orders.Bid memory bidOrder)\n        external\n        override\n        nonReentrant\n        returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n            _bid(\n                askOrder,\n                askHash,\n                bidOrder.signer,\n                bidOrder.amount,\n                bidOrder.price,\n                bidOrder.recipient,\n                bidOrder.referrer\n            );\n    }","after":"function bid(Orders.Ask calldata askOrder, Orders.Bid calldata bidOrder)\n        external\n        override\n        nonReentrant\n        returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n            _bid(\n                askOrder,\n                askHash,\n                bidOrder.signer,\n                bidOrder.amount,\n                bidOrder.price,\n                bidOrder.recipient,\n                bidOrder.referrer\n            );\n    }","contract":"NFT721V1","time":0},{"type":"external-function ","before":"function bid(\n        Orders.Ask memory askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","after":"function bid(\n        Orders.Ask calldata askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","contract":"NFT721V1","time":0},{"type":"external-function ","before":"function claim(Orders.Ask memory askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","after":"function claim(Orders.Ask calldata askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","contract":"NFT721V1","time":0},{"type":"external-function ","before":"   function setURI(uint256 id, string memory newURI) external override onlyOwner {\n        _uris[id] = newURI;\n\n        emit SetURI(id, newURI);\n  ","after":"   function setURI(uint256 id, string calldata newURI) external override onlyOwner {\n        _uris[id] = newURI;\n\n        emit SetURI(id, newURI);\n  ","contract":"NFT1155V1","time":0},{"type":"external-function ","before":"   function setBaseURI(string memory baseURI) external override onlyOwner {\n        _baseURI = baseURI;\n\n        emit SetBaseURI(baseURI);\n  ","after":"   function setBaseURI(string calldata baseURI) external override onlyOwner {\n        _baseURI = baseURI;\n\n        emit SetBaseURI(baseURI);\n  ","contract":"NFT1155V1","time":0},{"type":"external-function ","before":"   function mint(\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes memory data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _mint(to, tokenId, amount, data);\n  ","after":"   function mint(\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes calldata data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _mint(to, tokenId, amount, data);\n  ","contract":"NFT1155V1","time":0},{"type":"external-function ","before":"   function mintBatch(\n        address to,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _mintBatch(to, tokenIds, amounts, data);\n  ","after":"   function mintBatch(\n        address to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external override {\n        require(owner() == msg.sender || _factory == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _mintBatch(to, tokenIds, amounts, data);\n  ","contract":"NFT1155V1","time":0},{"type":"external-function ","before":"   function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(to != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(from == msg.sender || isApprovedForAll(from, msg.sender), \"SHOYU: FORBIDDEN\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _transfer(from, to, id, amount);\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n  ","after":"   function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(to != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(from == msg.sender || isApprovedForAll(from, msg.sender), \"SHOYU: FORBIDDEN\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _transfer(from, to, id, amount);\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n  ","contract":"NFT1155V1","time":0},{"type":"external-function ","before":"   function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(ids.length == amounts.length, \"SHOYU: LENGTHS_NOT_EQUAL\");\n        require(to != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(from == msg.sender || isApprovedForAll(from, msg.sender), \"SHOYU: FORBIDDEN\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"SHOYU: INSUFFICIENT_BALANCE\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n  ","after":"   function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(ids.length == amounts.length, \"SHOYU: LENGTHS_NOT_EQUAL\");\n        require(to != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(from == msg.sender || isApprovedForAll(from, msg.sender), \"SHOYU: FORBIDDEN\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"SHOYU: INSUFFICIENT_BALANCE\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n  ","contract":"NFT1155V1","time":0},{"type":"external-function ","before":"function cancel(Orders.Ask memory order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","after":"function cancel(Orders.Ask calldata order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","contract":"NFT1155V1","time":0},{"type":"external-function ","before":"function bid(Orders.Ask memory askOrder, Orders.Bid memory bidOrder)\n        external\n        override\n        nonReentrant\n        returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n            _bid(\n                askOrder,\n                askHash,\n                bidOrder.signer,\n                bidOrder.amount,\n                bidOrder.price,\n                bidOrder.recipient,\n                bidOrder.referrer\n            );\n    }","after":"function bid(Orders.Ask calldata askOrder, Orders.Bid calldata bidOrder)\n        external\n        override\n        nonReentrant\n        returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n            _bid(\n                askOrder,\n                askHash,\n                bidOrder.signer,\n                bidOrder.amount,\n                bidOrder.price,\n                bidOrder.recipient,\n                bidOrder.referrer\n            );\n    }","contract":"NFT1155V1","time":0},{"type":"external-function ","before":"function bid(\n        Orders.Ask memory askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","after":"function bid(\n        Orders.Ask calldata askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","contract":"NFT1155V1","time":0},{"type":"external-function ","before":"function claim(Orders.Ask memory askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","after":"function claim(Orders.Ask calldata askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","contract":"NFT1155V1","time":0},{"type":"state-data-arrangement ","before":"\n   uint8 public constant override MAX_ROYALTY_FEE = 2\n   uint8 public constant override MAX_OPERATIONAL_FEE = \n   bytes32 public constant override PARK_TOKEN_IDS_721_TYPEHASH =\n        0x3fddacac0a7d8b05f741f01ff6becadd9986be8631a2af41a675f365dd7409\n   bytes32 public constant override MINT_BATCH_721_TYPEHASH =\n        0x884adba7f4e17962aed36c871036adea39c6d9f81fb25407a78db239e9731e\n   bytes32 public constant override MINT_BATCH_1155_TYPEHASH =\n        0xb47ce0f6456fcc2f16b7d6e7b0255eb73822b401248e672a4543c2b3d71830\n   bytes32 public constant override MINT_SOCIAL_TOKEN_TYPEHASH =\n        0x8f4bf92e5271f5ec2f59dc3fc74368af0064fb84b40a3de9150dd26c08cda1\n   bytes32 internal immutable _DOMAIN_SEPARAT\n   uint256 internal immutable _CACHED_CHAIN_\n   address[] internal _targets7\n   address[] internal _targets11\n   address[] internal _targetsSocialTok\n   address internal _protocolFeeRecipie\n   uint8 internal _protocolF\n   address internal _operationalFeeRecipie\n   uint8 internal _operationalF\n   mapping(address => uint256) public override nonc\n   string public override baseURI7\n   string public override baseURI11\n   address public override erc721Exchan\n   address public override erc1155Exchan\n   mapping(address => bool) public override isDeployerWhitelist\n   mapping(address => bool) public override isStrategyWhitelist","after":"   bytes32 public constant override PARK_TOKEN_IDS_721_TYPEHASH =\n        0x3fddacac0a7d8b05f741f01ff6becadd9986be8631a2af41a675f365dd7409\n   bytes32 public constant override MINT_BATCH_721_TYPEHASH =\n        0x884adba7f4e17962aed36c871036adea39c6d9f81fb25407a78db239e9731e\n   bytes32 public constant override MINT_BATCH_1155_TYPEHASH =\n        0xb47ce0f6456fcc2f16b7d6e7b0255eb73822b401248e672a4543c2b3d71830\n   bytes32 public constant override MINT_SOCIAL_TOKEN_TYPEHASH =\n        0x8f4bf92e5271f5ec2f59dc3fc74368af0064fb84b40a3de9150dd26c08cda1\n   bytes32 internal immutable _DOMAIN_SEPARAT\n   uint256 internal immutable _CACHED_CHAIN_\n   address[] internal _targets7\n   address[] internal _targets11\n   address[] internal _targetsSocialTok\n   mapping(address => uint256) public override nonc\n   string public override baseURI7\n   string public override baseURI11\n   mapping(address => bool) public override isDeployerWhitelist\n   mapping(address => bool) public override isStrategyWhitelist\n   address internal _protocolFeeRecipie\n   address internal _operationalFeeRecipie\n   address public override erc721Exchan\n   address public override erc1155Exchan\n   uint8 public constant override MAX_ROYALTY_FEE = 2\n   uint8 public constant override MAX_OPERATIONAL_FEE = \n   uint8 internal _protocolF\n   uint8 internal _operationalF\n","contract":"TokenFactory","time":1},{"type":"external-function ","before":"   function setBaseURI721(string memory uri) external override onlyOwner {\n        baseURI721 = uri;\n\n        emit SetBaseURI721(uri);\n  ","after":"   function setBaseURI721(string calldata uri) external override onlyOwner {\n        baseURI721 = uri;\n\n        emit SetBaseURI721(uri);\n  ","contract":"TokenFactory","time":0},{"type":"external-function ","before":"   function setBaseURI1155(string memory uri) external override onlyOwner {\n        baseURI1155 = uri;\n\n        emit SetBaseURI1155(uri);\n  ","after":"   function setBaseURI1155(string calldata uri) external override onlyOwner {\n        baseURI1155 = uri;\n\n        emit SetBaseURI1155(uri);\n  ","contract":"TokenFactory","time":0},{"type":"external-function ","before":"   function deployNFT721AndMintBatch(\n        address owner,\n        string calldata name,\n        string calldata symbol,\n        uint256[] memory tokenIds,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external override onlyDeployer returns (address nft) {\n        require(bytes(name).length > 0, \"SHOYU: INVALID_NAME\");\n        require(bytes(symbol).length > 0, \"SHOYU: INVALID_SYMBOL\");\n        require(owner != address(0), \"SHOYU: INVALID_ADDRESS\");\n\n        nft = _createProxy(\n            _targets721[_targets721.length - 1],\n            abi.encodeWithSignature(\n                \"initialize(address,string,string,uint256[],address,uint8)\",\n                owner,\n                name,\n                symbol,\n                tokenIds,\n                royaltyFeeRecipient,\n                royaltyFee\n            )\n        );\n\n        emit DeployNFT721AndMintBatch(nft, owner, name, symbol, tokenIds, royaltyFeeRecipient, royaltyFee);\n  ","after":"   function deployNFT721AndMintBatch(\n        address owner,\n        string calldata name,\n        string calldata symbol,\n        uint256[] calldata tokenIds,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external override onlyDeployer returns (address nft) {\n        require(bytes(name).length > 0, \"SHOYU: INVALID_NAME\");\n        require(bytes(symbol).length > 0, \"SHOYU: INVALID_SYMBOL\");\n        require(owner != address(0), \"SHOYU: INVALID_ADDRESS\");\n\n        nft = _createProxy(\n            _targets721[_targets721.length - 1],\n            abi.encodeWithSignature(\n                \"initialize(address,string,string,uint256[],address,uint8)\",\n                owner,\n                name,\n                symbol,\n                tokenIds,\n                royaltyFeeRecipient,\n                royaltyFee\n            )\n        );\n\n        emit DeployNFT721AndMintBatch(nft, owner, name, symbol, tokenIds, royaltyFeeRecipient, royaltyFee);\n  ","contract":"TokenFactory","time":0},{"type":"external-function ","before":"   function deployNFT1155AndMintBatch(\n        address owner,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external override onlyDeployer returns (address nft) {\n        require(owner != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(tokenIds.length == amounts.length, \"SHOYU: LENGTHS_NOT_EQUAL\");\n        nft = _createProxy(\n            _targets1155[_targets1155.length - 1],\n            abi.encodeWithSignature(\n                \"initialize(address,uint256[],uint256[],address,uint8)\",\n                owner,\n                tokenIds,\n                amounts,\n                royaltyFeeRecipient,\n                royaltyFee\n            )\n        );\n\n        emit DeployNFT1155AndMintBatch(nft, owner, tokenIds, amounts, royaltyFeeRecipient, royaltyFee);\n  ","after":"   function deployNFT1155AndMintBatch(\n        address owner,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external override onlyDeployer returns (address nft) {\n        require(owner != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(tokenIds.length == amounts.length, \"SHOYU: LENGTHS_NOT_EQUAL\");\n        nft = _createProxy(\n            _targets1155[_targets1155.length - 1],\n            abi.encodeWithSignature(\n                \"initialize(address,uint256[],uint256[],address,uint8)\",\n                owner,\n                tokenIds,\n                amounts,\n                royaltyFeeRecipient,\n                royaltyFee\n            )\n        );\n\n        emit DeployNFT1155AndMintBatch(nft, owner, tokenIds, amounts, royaltyFeeRecipient, royaltyFee);\n  ","contract":"TokenFactory","time":0},{"type":"external-function ","before":"   function deploySocialToken(\n        address owner,\n        string memory name,\n        string memory symbol,\n        address dividendToken,\n        uint256 initialSupply\n    ) external override onlyDeployer returns (address proxy) {\n        require(bytes(name).length > 0, \"SHOYU: INVALID_NAME\");\n        require(bytes(symbol).length > 0, \"SHOYU: INVALID_SYMBOL\");\n        require(owner != address(0), \"SHOYU: INVALID_ADDRESS\");\n\n        bytes memory initData =\n            abi.encodeWithSignature(\n                \"initialize(address,string,string,address,uint256)\",\n                owner,\n                name,\n                symbol,\n                dividendToken,\n                initialSupply\n            );\n        proxy = _createProxy(_targetsSocialToken[_targetsSocialToken.length - 1], initData);\n\n        emit DeploySocialToken(proxy, owner, name, symbol, dividendToken, initialSupply);\n  ","after":"   function deploySocialToken(\n        address owner,\n        string calldata name,\n        string calldata symbol,\n        address dividendToken,\n        uint256 initialSupply\n    ) external override onlyDeployer returns (address proxy) {\n        require(bytes(name).length > 0, \"SHOYU: INVALID_NAME\");\n        require(bytes(symbol).length > 0, \"SHOYU: INVALID_SYMBOL\");\n        require(owner != address(0), \"SHOYU: INVALID_ADDRESS\");\n\n        bytes memory initData =\n            abi.encodeWithSignature(\n                \"initialize(address,string,string,address,uint256)\",\n                owner,\n                name,\n                symbol,\n                dividendToken,\n                initialSupply\n            );\n        proxy = _createProxy(_targetsSocialToken[_targetsSocialToken.length - 1], initData);\n\n        emit DeploySocialToken(proxy, owner, name, symbol, dividendToken, initialSupply);\n  ","contract":"TokenFactory","time":0},{"type":"immutable-restrict-modification ","before":"   uint8 internal _protocolF","after":"   uint8 internal _protocolF","contract":"TokenFactory","time":0},{"type":"immutable-restrict-modification ","before":"   address internal _targ","after":"   address internal _targ","contract":"PaymentSplitterFactory","time":0},{"type":"external-function ","before":"   function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external {\n        _safeMint(to, tokenId, data);\n  ","after":"   function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external {\n        _safeMint(to, tokenId, data);\n  ","contract":"ERC721RoyaltyMock","time":0},{"type":"external-function ","before":"   function safeMintBatch0(\n        address[] calldata to,\n        uint256[] calldata tokenId,\n        bytes memory data\n    ) external {\n        require(to.length == tokenId.length);\n        for (uint256 i = 0; i < to.length; i++) {\n            _safeMint(to[i], tokenId[i], data);\n        }\n  ","after":"   function safeMintBatch0(\n        address[] calldata to,\n        uint256[] calldata tokenId,\n        bytes calldata data\n    ) external {\n        require(to.length == tokenId.length);\n        for (uint256 i = 0; i < to.length; i++) {\n            _safeMint(to[i], tokenId[i], data);\n        }\n  ","contract":"ERC721RoyaltyMock","time":0},{"type":"external-function ","before":"   function safeMintBatch1(\n        address to,\n        uint256[] calldata tokenId,\n        bytes memory data\n    ) external {\n        for (uint256 i = 0; i < tokenId.length; i++) {\n            _safeMint(to, tokenId[i], data);\n        }\n  ","after":"   function safeMintBatch1(\n        address to,\n        uint256[] calldata tokenId,\n        bytes calldata data\n    ) external {\n        for (uint256 i = 0; i < tokenId.length; i++) {\n            _safeMint(to, tokenId[i], data);\n        }\n  ","contract":"ERC721RoyaltyMock","time":0},{"type":"immutable-restrict-modification ","before":"   address public own","after":"   address public own","contract":"ERC721RoyaltyMock","time":0},{"type":"external-function ","before":"   function mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external {\n        _mint(account, id, amount, data);\n  ","after":"   function mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external {\n        _mint(account, id, amount, data);\n  ","contract":"ERC1155RoyaltyMock","time":0},{"type":"external-function ","before":"   function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external {\n        _mintBatch(to, ids, amounts, data);\n  ","after":"   function mintBatch(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external {\n        _mintBatch(to, ids, amounts, data);\n  ","contract":"ERC1155RoyaltyMock","time":0},{"type":"external-function ","before":"   function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n  ","after":"   function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n  ","contract":"ERC1155RoyaltyMock","time":0},{"type":"external-function ","before":"   function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n  ","after":"   function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n  ","contract":"ERC1155RoyaltyMock","time":0},{"type":"immutable-restrict-modification ","before":"   address public own","after":"   address public own","contract":"ERC1155RoyaltyMock","time":0},{"type":"external-function ","before":"   function initialize(\n        address _owner,\n        string memory _name,\n        string memory _symbol,\n        address _dividendToken,\n        uint256 initialSupply\n    ) external override initializer {\n        __Ownable_init(_owner);\n        __DividendPayingERC20_init(_name, _symbol, _dividendToken);\n        _factory = msg.sender;\n        _mint(_owner, initialSupply);\n\n        _CACHED_CHAIN_ID = block.chainid;\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                keccak256(bytes(Strings.toHexString(uint160(address(this))))),\n                0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, // keccak256(bytes(\"1\"))\n                block.chainid,\n                address(this)\n            )\n        );\n  ","after":"   function initialize(\n        address _owner,\n        string calldata _name,\n        string calldata _symbol,\n        address _dividendToken,\n        uint256 initialSupply\n    ) external override initializer {\n        __Ownable_init(_owner);\n        __DividendPayingERC20_init(_name, _symbol, _dividendToken);\n        _factory = msg.sender;\n        _mint(_owner, initialSupply);\n\n        _CACHED_CHAIN_ID = block.chainid;\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                keccak256(bytes(Strings.toHexString(uint160(address(this))))),\n                0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, // keccak256(bytes(\"1\"))\n                block.chainid,\n                address(this)\n            )\n        );\n  ","contract":"SocialTokenV0","time":0},{"type":"external-function ","before":"   function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external {\n        _safeMint(to, tokenId, data);\n  ","after":"   function safeMint(\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external {\n        _safeMint(to, tokenId, data);\n  ","contract":"ERC721Mock","time":0},{"type":"external-function ","before":"   function safeMintBatch0(\n        address[] calldata to,\n        uint256[] calldata tokenId,\n        bytes memory data\n    ) external {\n        require(to.length == tokenId.length);\n        for (uint256 i = 0; i < to.length; i++) {\n            _safeMint(to[i], tokenId[i], data);\n        }\n  ","after":"   function safeMintBatch0(\n        address[] calldata to,\n        uint256[] calldata tokenId,\n        bytes calldata data\n    ) external {\n        require(to.length == tokenId.length);\n        for (uint256 i = 0; i < to.length; i++) {\n            _safeMint(to[i], tokenId[i], data);\n        }\n  ","contract":"ERC721Mock","time":0},{"type":"external-function ","before":"   function safeMintBatch1(\n        address to,\n        uint256[] calldata tokenId,\n        bytes memory data\n    ) external {\n        for (uint256 i = 0; i < tokenId.length; i++) {\n            _safeMint(to, tokenId[i], data);\n        }\n  ","after":"   function safeMintBatch1(\n        address to,\n        uint256[] calldata tokenId,\n        bytes calldata data\n    ) external {\n        for (uint256 i = 0; i < tokenId.length; i++) {\n            _safeMint(to, tokenId[i], data);\n        }\n  ","contract":"ERC721Mock","time":0},{"type":"external-function ","before":"function cancel(Orders.Ask memory order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","after":"function cancel(Orders.Ask calldata order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","contract":"ERC721ExchangeV0","time":1},{"type":"external-function ","before":"function bid(Orders.Ask memory askOrder, Orders.Bid memory bidOrder)\n        external\n        override\n        nonReentrant\n        returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n            _bid(\n                askOrder,\n                askHash,\n                bidOrder.signer,\n                bidOrder.amount,\n                bidOrder.price,\n                bidOrder.recipient,\n                bidOrder.referrer\n            );\n    }","after":"function bid(Orders.Ask calldata askOrder, Orders.Bid calldata bidOrder)\n        external\n        override\n        nonReentrant\n        returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n            _bid(\n                askOrder,\n                askHash,\n                bidOrder.signer,\n                bidOrder.amount,\n                bidOrder.price,\n                bidOrder.recipient,\n                bidOrder.referrer\n            );\n    }","contract":"ERC721ExchangeV0","time":0},{"type":"external-function ","before":"function bid(\n        Orders.Ask memory askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","after":"function bid(\n        Orders.Ask calldata askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","contract":"ERC721ExchangeV0","time":0},{"type":"external-function ","before":"function claim(Orders.Ask memory askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","after":"function claim(Orders.Ask calldata askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","contract":"ERC721ExchangeV0","time":0},{"type":"external-function ","before":"   function mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) external {\n        _mint(account, id, amount, data);\n  ","after":"   function mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external {\n        _mint(account, id, amount, data);\n  ","contract":"ERC1155Mock","time":0},{"type":"external-function ","before":"   function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external {\n        _mintBatch(to, ids, amounts, data);\n  ","after":"   function mintBatch(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external {\n        _mintBatch(to, ids, amounts, data);\n  ","contract":"ERC1155Mock","time":0},{"type":"external-function ","before":"   function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n  ","after":"   function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n  ","contract":"ERC1155Mock","time":0},{"type":"external-function ","before":"   function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n  ","after":"   function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n  ","contract":"ERC1155Mock","time":0},{"type":"external-function ","before":"function cancel(Orders.Ask memory order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","after":"function cancel(Orders.Ask calldata order) external override {\n        require(order.signer == msg.sender || order.proxy == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelledOrClaimed[hash] = true;\n\n        emit Cancel(hash);\n    }","contract":"ERC1155ExchangeV0","time":0},{"type":"external-function ","before":"function bid(Orders.Ask memory askOrder, Orders.Bid memory bidOrder)\n        external\n        override\n        nonReentrant\n        returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n            _bid(\n                askOrder,\n                askHash,\n                bidOrder.signer,\n                bidOrder.amount,\n                bidOrder.price,\n                bidOrder.recipient,\n                bidOrder.referrer\n            );\n    }","after":"function bid(Orders.Ask calldata askOrder, Orders.Bid calldata bidOrder)\n        external\n        override\n        nonReentrant\n        returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        bytes32 bidHash = bidOrder.hash();\n        if (askOrder.proxy != address(0)) {\n            require(\n                askOrder.proxy == msg.sender || _bidHashes[askOrder.proxy][askHash][bidOrder.signer] == bidHash,\n                \"SHOYU: FORBIDDEN\"\n            );\n            delete _bidHashes[askOrder.proxy][askHash][bidOrder.signer];\n            emit UpdateApprovedBidHash(askOrder.proxy, askHash, bidOrder.signer, bytes32(0));\n        }\n\n        Signature.verify(bidHash, bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s, DOMAIN_SEPARATOR());\n\n        return\n            _bid(\n                askOrder,\n                askHash,\n                bidOrder.signer,\n                bidOrder.amount,\n                bidOrder.price,\n                bidOrder.recipient,\n                bidOrder.referrer\n            );\n    }","contract":"ERC1155ExchangeV0","time":0},{"type":"external-function ","before":"function bid(\n        Orders.Ask memory askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","after":"function bid(\n        Orders.Ask calldata askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        require(askOrder.proxy == address(0), \"SHOYU: FORBIDDEN\");\n\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }","contract":"ERC1155ExchangeV0","time":0},{"type":"external-function ","before":"function claim(Orders.Ask memory askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","after":"function claim(Orders.Ask calldata askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        Signature.verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s, DOMAIN_SEPARATOR());\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canClaim(\n                askOrder.proxy,\n                askOrder.deadline,\n                askOrder.params,\n                best.bidder,\n                best.price,\n                best.bidder,\n                best.price,\n                best.timestamp\n            ),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        isCancelledOrClaimed[askHash] = true;\n        require(\n            _transferFeesAndFunds(\n                askOrder.token,\n                askOrder.tokenId,\n                askOrder.currency,\n                best.bidder,\n                recipient,\n                best.price * best.amount\n            ),\n            \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n        );\n        amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n        address bidRecipient = best.recipient;\n        if (bidRecipient == address(0)) bidRecipient = best.bidder;\n        _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n        delete bestBid[askHash];\n\n        emit Claim(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n    }","contract":"ERC1155ExchangeV0","time":0}]}