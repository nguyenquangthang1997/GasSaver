{"time":2117,"results":[{"type":"struct-data-arrangement ","before":"\nuint8      blockType\nuint16     blockSize\nuint8      blockVersion\nbytes      data\nuint256[8] proof\nbool storeBlockInfoOnchain\nbytes auxiliaryData\nbytes offchainData","after":"bytes      data\nuint256[8] proof\nbytes auxiliaryData\nbytes offchainData\nuint16     blockSize\nuint8      blockType\nuint8      blockVersion\nbool storeBlockInfoOnchain\n","contract":"ExchangeData","time":0},{"type":"struct-data-arrangement ","before":"\nuint32   accountID\naddress  owner\nuint     pubKeyX\nuint     pubKeyY\nuint32   nonce\nuint     feeBipsAMM","after":"uint     pubKeyX\nuint     pubKeyY\nuint     feeBipsAMM\naddress  owner\nuint32   accountID\nuint32   nonce\n","contract":"ExchangeData","time":1},{"type":"struct-data-arrangement ","before":"\nuint32  fromAccountID\nuint32  toAccountID\naddress from\naddress to\nuint16  tokenID\nuint96  amount\nuint16  feeTokenID\nuint96  maxFee\nuint96  fee\nuint32  validUntil\nuint32  storageID","after":"address from\naddress to\nuint96  amount\nuint96  maxFee\nuint96  fee\nuint32  fromAccountID\nuint32  toAccountID\nuint32  validUntil\nuint32  storageID\nuint16  tokenID\nuint16  feeTokenID\n","contract":"TransferTransaction","time":593},{"type":"external-function ","before":"function withdrawFromApprovedWithdrawals(\n        ExchangeData.State storage S,\n        address[] memory owners,\n        address[] memory tokens\n        )\n        public\n    {\n        require(owners.length == tokens.length, \"INVALID_INPUT_DATA\");\n        for (uint i = 0; i < owners.length; i++) {\n            address owner = owners[i];\n            uint16 tokenID = S.getTokenID(tokens[i]);\n            uint amount = S.amountWithdrawable[owner][tokenID];\n\n            // Make sure this amount can't be withdrawn again\n            delete S.amountWithdrawable[owner][tokenID];\n\n            // Transfer the tokens to the owner\n            transferTokens(\n                S,\n                uint8(WithdrawalCategory.FROM_APPROVED_WITHDRAWAL),\n                owner,\n                owner,\n                tokenID,\n                amount,\n                new bytes(0),\n                gasleft(),\n                false\n            );\n        }\n    }","after":"function withdrawFromApprovedWithdrawals(\n        ExchangeData.State storage S,\n        address[] calldata owners,\n        address[] calldata tokens\n        )\n        public\n    {\n        require(owners.length == tokens.length, \"INVALID_INPUT_DATA\");\n        for (uint i = 0; i < owners.length; i++) {\n            address owner = owners[i];\n            uint16 tokenID = S.getTokenID(tokens[i]);\n            uint amount = S.amountWithdrawable[owner][tokenID];\n\n            // Make sure this amount can't be withdrawn again\n            delete S.amountWithdrawable[owner][tokenID];\n\n            // Transfer the tokens to the owner\n            transferTokens(\n                S,\n                uint8(WithdrawalCategory.FROM_APPROVED_WITHDRAWAL),\n                owner,\n                owner,\n                tokenID,\n                amount,\n                new bytes(0),\n                gasleft(),\n                false\n            );\n        }\n    }","contract":"ExchangeWithdrawals","time":0},{"type":"external-function ","before":"function distributeWithdrawal(\n        ExchangeData.State storage S,\n        address from,\n        address to,\n        uint16  tokenID,\n        uint    amount,\n        bytes   memory extraData,\n        uint    gasLimit\n        )\n        public\n    {\n        // Try to transfer the tokens\n        bool success = transferTokens(\n            S,\n            uint8(WithdrawalCategory.DISTRIBUTION),\n            from,\n            to,\n            tokenID,\n            amount,\n            extraData,\n            gasLimit,\n            true\n        );\n        // If the transfer was successful there's nothing left to do.\n        // However, if the transfer failed the tokens are still in the contract and can be\n        // withdrawn later to `to` by anyone by using `withdrawFromApprovedWithdrawal.\n        if (!success) {\n            S.amountWithdrawable[to][tokenID] = S.amountWithdrawable[to][tokenID].add(amount);\n        }\n    }","after":"function distributeWithdrawal(\n        ExchangeData.State storage S,\n        address from,\n        address to,\n        uint16  tokenID,\n        uint    amount,\n        bytes   calldata extraData,\n        uint    gasLimit\n        )\n        public\n    {\n        // Try to transfer the tokens\n        bool success = transferTokens(\n            S,\n            uint8(WithdrawalCategory.DISTRIBUTION),\n            from,\n            to,\n            tokenID,\n            amount,\n            extraData,\n            gasLimit,\n            true\n        );\n        // If the transfer was successful there's nothing left to do.\n        // However, if the transfer failed the tokens are still in the contract and can be\n        // withdrawn later to `to` by anyone by using `withdrawFromApprovedWithdrawal.\n        if (!success) {\n            S.amountWithdrawable[to][tokenID] = S.amountWithdrawable[to][tokenID].add(amount);\n        }\n    }","contract":"ExchangeWithdrawals","time":0},{"type":"struct-data-arrangement ","before":"\nbool  storeRecipient\nuint  gasLimit\nbytes signature\nuint    minGas\naddress to\nbytes   extraData\nuint96  maxFee\nuint32  validUntil","after":"uint  gasLimit\nbytes signature\nuint    minGas\nbytes   extraData\naddress to\nuint96  maxFee\nuint32  validUntil\nbool  storeRecipient\n","contract":"WithdrawTransaction","time":0},{"type":"struct-data-arrangement ","before":"\naddress   sharedConfig\naddress   exchange\nstring    poolName\nuint32    accountID\naddress[] tokens\nuint96[]  weights\nuint8     feeBips\nstring    tokenSymbol","after":"string    poolName\naddress[] tokens\nuint96[]  weights\nstring    tokenSymbol\naddress   sharedConfig\naddress   exchange\nuint32    accountID\nuint8     feeBips\n","contract":"AmmData","time":0},{"type":"struct-data-arrangement ","before":"\naddress   owner\nuint96    burnAmount\nuint32    burnStorageID\nuint96[]  exitMinAmounts\nuint96    fee\nuint32    validUntil","after":"uint96[]  exitMinAmounts\naddress   owner\nuint96    burnAmount\nuint96    fee\nuint32    burnStorageID\nuint32    validUntil\n","contract":"AmmData","time":0}]}