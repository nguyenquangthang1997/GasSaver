{"time":112,"results":[{"type":"external-function ","before":"function stake(uint256[] memory tokenIds) external nonReentrant whenNotPaused updateReward(msg.sender) {\n        require(tokenIds.length != 0, \"Staking: No tokenIds provided\");\n\n        uint256 amount;\n        for (uint256 i = 0; i < tokenIds.length; i += 1) {\n            // Transfer user's LandWorks NFTs to the staking contract\n            stakingToken.safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n            // Change the consumer of the LandWorks NFT to be the person who staked it\n            stakingToken.changeConsumer(msg.sender, tokenIds[i]);\n            // Compute the amount/weight of the tokenId\n            uint256 computedAmount = computeAmount(tokenIds[i]);\n            // Increment the amount which will be staked\n            amount += computedAmount;\n            // Save the size, to be used on withdraw\n            stakedAssetSizes[tokenIds[i]] = computedAmount;\n            // Save who is the staker/depositor of the token\n            stakedAssets[tokenIds[i]] = msg.sender;\n        }\n        _stake(amount);\n        emit Staked(msg.sender, amount, tokenIds);\n    }","after":"function stake(uint256[] calldata tokenIds) external nonReentrant whenNotPaused updateReward(msg.sender) {\n        require(tokenIds.length != 0, \"Staking: No tokenIds provided\");\n\n        uint256 amount;\n        for (uint256 i = 0; i < tokenIds.length; i += 1) {\n            // Transfer user's LandWorks NFTs to the staking contract\n            stakingToken.safeTransferFrom(msg.sender, address(this), tokenIds[i]);\n            // Change the consumer of the LandWorks NFT to be the person who staked it\n            stakingToken.changeConsumer(msg.sender, tokenIds[i]);\n            // Compute the amount/weight of the tokenId\n            uint256 computedAmount = computeAmount(tokenIds[i]);\n            // Increment the amount which will be staked\n            amount += computedAmount;\n            // Save the size, to be used on withdraw\n            stakedAssetSizes[tokenIds[i]] = computedAmount;\n            // Save who is the staker/depositor of the token\n            stakedAssets[tokenIds[i]] = msg.sender;\n        }\n        _stake(amount);\n        emit Staked(msg.sender, amount, tokenIds);\n    }","contract":"LandWorksDecentralandStaking","time":0},{"type":"external-function ","before":"function exit(uint256[] memory tokenIds) external {\n        withdraw(tokenIds);\n        getReward();\n    }","after":"function exit(uint256[] calldata tokenIds) external {\n        withdraw(tokenIds);\n        getReward();\n    }","contract":"LandWorksDecentralandStaking","time":0},{"type":"external-function ","before":"function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }","after":"function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }","contract":"LandWorksDecentralandStaking","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public metaverseId;","after":"uint256 public immutable metaverseId;","contract":"LandWorksDecentralandStaking","time":1},{"type":"immutable-restrict-modification ","before":"address public landRegistry;","after":"address public immutable landRegistry;","contract":"LandWorksDecentralandStaking","time":1}]}