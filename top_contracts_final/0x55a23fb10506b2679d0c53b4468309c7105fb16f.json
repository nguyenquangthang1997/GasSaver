{"time":307,"results":[{"type":"de-morgan-condition ","before":"!(char >= 0x30 && char <= 0x39) && //9-0\n                !(char >= 0x41 && char <= 0x5A)","after":"!((char >= 0x30 && char <= 0x39) && //9-0\n                (char >= 0x41 && char <= 0x5A))","loc":{"start":{"line":401,"column":16},"end":{"line":402,"column":46}},"contract":"Gleaf","time":0},{"type":"state-data-arrangement ","before":"\naddress nullAddress = 0x0000000000000000000000000000000000000000;\naddress public giraffetowerAddress = 0xb487A91382cD66076fc4C1AF4D7d8CE7f929A9bA;\nmapping(uint256 => uint256) internal tokenIdToTimeStamp;\nmapping(uint256 => uint256) tokenRound;\nmapping(uint256 => string) giraffeName;\nuint256 public nameChangePrice = 10 ether;\nmapping(string => bool) private _nameReserved;\nuint256 public EMISSIONS_RATE = 11574070000000;\nuint256 public STAKED_EMISSIONS_RATE = 5787030000000;\nbool public CLAIM_STATUS = true;\nuint256 public CLAIM_START_TIME;\nuint256 totalDividends = 0;\nuint256 ownerRoyalty = 0;\nuint256 public OgsCount = 100;\naddress pr = 0x044780Ef6d06BF528c03f423bF3D9d8a88837A3f;\nuint256 public MAX_TOKEN = 50;\nbool public STAKING_STATUS = true;\nuint256 public STAKE_CLAIM_START_TIME;\nuint256[] public stakedTokens;\nmapping(uint256 => uint256) internal stakedTokenIdToTimeStamp;\nmapping(uint256 => address) internal stakedTokenIdToStaker;\nmapping(address => uint256[]) internal stakerToTokenIds;\nmapping(uint256 => uint256) public giraffeLendFee;","after":"mapping(uint256 => uint256) internal tokenIdToTimeStamp;\nmapping(uint256 => uint256) tokenRound;\nmapping(uint256 => string) giraffeName;\nuint256 public nameChangePrice = 10 ether;\nmapping(string => bool) private _nameReserved;\nuint256 public EMISSIONS_RATE = 11574070000000;\nuint256 public STAKED_EMISSIONS_RATE = 5787030000000;\nuint256 public CLAIM_START_TIME;\nuint256 totalDividends = 0;\nuint256 ownerRoyalty = 0;\nuint256 public OgsCount = 100;\nuint256 public MAX_TOKEN = 50;\nuint256 public STAKE_CLAIM_START_TIME;\nuint256[] public stakedTokens;\nmapping(uint256 => uint256) internal stakedTokenIdToTimeStamp;\nmapping(uint256 => address) internal stakedTokenIdToStaker;\nmapping(address => uint256[]) internal stakerToTokenIds;\nmapping(uint256 => uint256) public giraffeLendFee;\naddress nullAddress = 0x0000000000000000000000000000000000000000;\naddress public giraffetowerAddress = 0xb487A91382cD66076fc4C1AF4D7d8CE7f929A9bA;\naddress pr = 0x044780Ef6d06BF528c03f423bF3D9d8a88837A3f;\nbool public CLAIM_STATUS = true;\nbool public STAKING_STATUS = true;\n","contract":"Gleaf","time":0},{"type":"external-function ","before":"function stakeByIds(uint256[] memory tokenIds) public {\n        require(STAKING_STATUS == true, \"Staking Closed, try again later\");\n        require(\n            tokenIds.length <= MAX_TOKEN,\n            \"Kindly Use the other function to unstake your giraffe!\"\n        );\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                IERC721(giraffetowerAddress).ownerOf(tokenIds[i]) == msg.sender &&\n                    stakedTokenIdToStaker[tokenIds[i]] == nullAddress,\n                \"Token must be stakable by you!\"\n            );\n\n            IERC721(giraffetowerAddress).transferFrom(\n                msg.sender,\n                address(this),\n                tokenIds[i]\n            );\n\n            stakerToTokenIds[msg.sender].push(tokenIds[i]);\n\n            stakedTokenIdToTimeStamp[tokenIds[i]] = block.timestamp;\n            stakedTokenIdToStaker[tokenIds[i]] = msg.sender;\n        }\n    }","after":"function stakeByIds(uint256[] calldata tokenIds) public {\n        require(STAKING_STATUS == true, \"Staking Closed, try again later\");\n        require(\n            tokenIds.length <= MAX_TOKEN,\n            \"Kindly Use the other function to unstake your giraffe!\"\n        );\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                IERC721(giraffetowerAddress).ownerOf(tokenIds[i]) == msg.sender &&\n                    stakedTokenIdToStaker[tokenIds[i]] == nullAddress,\n                \"Token must be stakable by you!\"\n            );\n\n            IERC721(giraffetowerAddress).transferFrom(\n                msg.sender,\n                address(this),\n                tokenIds[i]\n            );\n\n            stakerToTokenIds[msg.sender].push(tokenIds[i]);\n\n            stakedTokenIdToTimeStamp[tokenIds[i]] = block.timestamp;\n            stakedTokenIdToStaker[tokenIds[i]] = msg.sender;\n        }\n    }","contract":"Gleaf","time":0},{"type":"external-function ","before":"function unstakeByIds(uint256[] memory tokenIds) public {\n        uint256 totalRewards = 0;\n        require(\n            tokenIds.length <= MAX_TOKEN,\n            \"Only unstake 20 per txn!\"\n        );\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                stakedTokenIdToStaker[tokenIds[i]] == msg.sender,\n                \"Message Sender was not original staker!\"\n            );\n\n            IERC721(giraffetowerAddress).transferFrom(\n                address(this),\n                msg.sender,\n                tokenIds[i]\n            );\n            if(stakedTokenIdToTimeStamp[tokenIds[i]] < STAKE_CLAIM_START_TIME){\n                stakedTokenIdToTimeStamp[tokenIds[i]] = STAKE_CLAIM_START_TIME;\n            }\n            totalRewards =\n                totalRewards +\n                ((block.timestamp - stakedTokenIdToTimeStamp[tokenIds[i]]) *\n                    STAKED_EMISSIONS_RATE);\n\n            removeTokenIdFromStaker(msg.sender, tokenIds[i]);\n\n            stakedTokenIdToStaker[tokenIds[i]] = nullAddress;\n        }\n\n        _mint(msg.sender, totalRewards);\n    }","after":"function unstakeByIds(uint256[] calldata tokenIds) public {\n        uint256 totalRewards = 0;\n        require(\n            tokenIds.length <= MAX_TOKEN,\n            \"Only unstake 20 per txn!\"\n        );\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                stakedTokenIdToStaker[tokenIds[i]] == msg.sender,\n                \"Message Sender was not original staker!\"\n            );\n\n            IERC721(giraffetowerAddress).transferFrom(\n                address(this),\n                msg.sender,\n                tokenIds[i]\n            );\n            if(stakedTokenIdToTimeStamp[tokenIds[i]] < STAKE_CLAIM_START_TIME){\n                stakedTokenIdToTimeStamp[tokenIds[i]] = STAKE_CLAIM_START_TIME;\n            }\n            totalRewards =\n                totalRewards +\n                ((block.timestamp - stakedTokenIdToTimeStamp[tokenIds[i]]) *\n                    STAKED_EMISSIONS_RATE);\n\n            removeTokenIdFromStaker(msg.sender, tokenIds[i]);\n\n            stakedTokenIdToStaker[tokenIds[i]] = nullAddress;\n        }\n\n        _mint(msg.sender, totalRewards);\n    }","contract":"Gleaf","time":0},{"type":"external-function ","before":"function stakedclaimByTokenIds(uint256[] memory tokenIds) public {\n        uint256 totalRewards = 0;\n        require(\n            tokenIds.length <= MAX_TOKEN,\n            \"Only claim 50 per txn!\"\n        );\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            if(stakedTokenIdToStaker[tokenIds[i]] != msg.sender){\n                 require(\n            IERC721(giraffetowerAddress).ownerOf(tokenIds[i]) == msg.sender,\n            \"Token is not claimable by you!\"\n        );\n            }\n        \n         if(stakedTokenIdToTimeStamp[tokenIds[i]] < STAKE_CLAIM_START_TIME){\n                stakedTokenIdToTimeStamp[tokenIds[i]] = STAKE_CLAIM_START_TIME;\n            }\n\n        totalRewards = totalRewards + ((block.timestamp - stakedTokenIdToTimeStamp[tokenIds[i]]) * STAKED_EMISSIONS_RATE);\n\n        stakedTokenIdToTimeStamp[tokenIds[i]] = block.timestamp;\n        }\n\n        _mint(msg.sender, totalRewards);\n    }","after":"function stakedclaimByTokenIds(uint256[] calldata tokenIds) public {\n        uint256 totalRewards = 0;\n        require(\n            tokenIds.length <= MAX_TOKEN,\n            \"Only claim 50 per txn!\"\n        );\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            if(stakedTokenIdToStaker[tokenIds[i]] != msg.sender){\n                 require(\n            IERC721(giraffetowerAddress).ownerOf(tokenIds[i]) == msg.sender,\n            \"Token is not claimable by you!\"\n        );\n            }\n        \n         if(stakedTokenIdToTimeStamp[tokenIds[i]] < STAKE_CLAIM_START_TIME){\n                stakedTokenIdToTimeStamp[tokenIds[i]] = STAKE_CLAIM_START_TIME;\n            }\n\n        totalRewards = totalRewards + ((block.timestamp - stakedTokenIdToTimeStamp[tokenIds[i]]) * STAKED_EMISSIONS_RATE);\n\n        stakedTokenIdToTimeStamp[tokenIds[i]] = block.timestamp;\n        }\n\n        _mint(msg.sender, totalRewards);\n    }","contract":"Gleaf","time":0},{"type":"external-function ","before":"function setGiraffeLendFee(uint256[] memory tokenIds, uint256[] memory fees) public {\n         for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                stakedTokenIdToStaker[tokenIds[i]] == msg.sender,\n                \"You cannot set lending fee!\"\n            );\n            giraffeLendFee[tokenIds[i]] = fees[i];\n        }\n        return;\n    }","after":"function setGiraffeLendFee(uint256[] calldata tokenIds, uint256[] calldata fees) public {\n         for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                stakedTokenIdToStaker[tokenIds[i]] == msg.sender,\n                \"You cannot set lending fee!\"\n            );\n            giraffeLendFee[tokenIds[i]] = fees[i];\n        }\n        return;\n    }","contract":"Gleaf","time":0},{"type":"external-function ","before":"function setGiraffeName(uint256 tokenId, string memory name) public {\n        if(stakedTokenIdToStaker[tokenId] != msg.sender){\n            require(\n            IERC721(giraffetowerAddress).ownerOf(tokenId) == msg.sender,\n            \"Token is not nameable by you!\"\n        );\n        }\n        require(validateName(name) == true, \"Not a valid new name\");\n        require(\n            sha256(bytes(name)) != sha256(bytes(giraffeName[tokenId])),\n            \"New name is same as the current one\"\n        );\n        require(isNameReserved(name) == false, \"Name already reserved\");\n        if(stakedTokenIdToStaker[tokenId] != msg.sender){ //Allow Staked Users To change name for free\n        uint256 allowance = allowance(msg.sender, pr);\n        require(allowance >= nameChangePrice, \"Check the token allowance\");\n        transferFrom(msg.sender, pr, nameChangePrice);\n        }\n        if (bytes(giraffeName[tokenId]).length > 0) {\n            toggleReserveName(giraffeName[tokenId], false);\n        }\n        toggleReserveName(name, true);\n        giraffeName[tokenId] = name;\n        emit NameChange(tokenId, name);\n    }","after":"function setGiraffeName(uint256 tokenId, string calldata name) public {\n        if(stakedTokenIdToStaker[tokenId] != msg.sender){\n            require(\n            IERC721(giraffetowerAddress).ownerOf(tokenId) == msg.sender,\n            \"Token is not nameable by you!\"\n        );\n        }\n        require(validateName(name) == true, \"Not a valid new name\");\n        require(\n            sha256(bytes(name)) != sha256(bytes(giraffeName[tokenId])),\n            \"New name is same as the current one\"\n        );\n        require(isNameReserved(name) == false, \"Name already reserved\");\n        if(stakedTokenIdToStaker[tokenId] != msg.sender){ //Allow Staked Users To change name for free\n        uint256 allowance = allowance(msg.sender, pr);\n        require(allowance >= nameChangePrice, \"Check the token allowance\");\n        transferFrom(msg.sender, pr, nameChangePrice);\n        }\n        if (bytes(giraffeName[tokenId]).length > 0) {\n            toggleReserveName(giraffeName[tokenId], false);\n        }\n        toggleReserveName(name, true);\n        giraffeName[tokenId] = name;\n        emit NameChange(tokenId, name);\n    }","contract":"Gleaf","time":0},{"type":"external-function ","before":"function claimByTokenIds(uint256[] memory tokenIds) public {\n        GiraffeTower gt = GiraffeTower(giraffetowerAddress);\n        uint256 totalRewards = 0;\n        require(\n            tokenIds.length <= MAX_TOKEN,\n            \"Only claim 50 per txn!\"\n        );\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            if(stakedTokenIdToStaker[tokenIds[i]] != msg.sender){\n                 require(\n            IERC721(giraffetowerAddress).ownerOf(tokenIds[i]) == msg.sender,\n            \"Token is not claimable by you!\"\n        );\n            }\n         if (tokenIdToTimeStamp[tokenIds[i]] == 0) {\n                uint256 birthday = gt.giraffes(tokenIds[i]);\n                uint256 stime = 0;\n                if (birthday > CLAIM_START_TIME) {\n                    stime = birthday;\n                } else {\n                    stime = CLAIM_START_TIME;\n                }\n                if (gt.getGenesisAddress(tokenIds[i]) == msg.sender && birthday < CLAIM_START_TIME) {\n                    totalRewards += (4320000 * EMISSIONS_RATE);\n                }\n                tokenIdToTimeStamp[tokenIds[i]] = stime;\n            }\n            totalRewards =\n                totalRewards +\n                ((block.timestamp - tokenIdToTimeStamp[tokenIds[i]]) *\n                    EMISSIONS_RATE);\n\n            tokenIdToTimeStamp[tokenIds[i]] = block.timestamp;\n        }\n\n        _mint(msg.sender, totalRewards);\n    }","after":"function claimByTokenIds(uint256[] calldata tokenIds) public {\n        GiraffeTower gt = GiraffeTower(giraffetowerAddress);\n        uint256 totalRewards = 0;\n        require(\n            tokenIds.length <= MAX_TOKEN,\n            \"Only claim 50 per txn!\"\n        );\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            if(stakedTokenIdToStaker[tokenIds[i]] != msg.sender){\n                 require(\n            IERC721(giraffetowerAddress).ownerOf(tokenIds[i]) == msg.sender,\n            \"Token is not claimable by you!\"\n        );\n            }\n         if (tokenIdToTimeStamp[tokenIds[i]] == 0) {\n                uint256 birthday = gt.giraffes(tokenIds[i]);\n                uint256 stime = 0;\n                if (birthday > CLAIM_START_TIME) {\n                    stime = birthday;\n                } else {\n                    stime = CLAIM_START_TIME;\n                }\n                if (gt.getGenesisAddress(tokenIds[i]) == msg.sender && birthday < CLAIM_START_TIME) {\n                    totalRewards += (4320000 * EMISSIONS_RATE);\n                }\n                tokenIdToTimeStamp[tokenIds[i]] = stime;\n            }\n            totalRewards =\n                totalRewards +\n                ((block.timestamp - tokenIdToTimeStamp[tokenIds[i]]) *\n                    EMISSIONS_RATE);\n\n            tokenIdToTimeStamp[tokenIds[i]] = block.timestamp;\n        }\n\n        _mint(msg.sender, totalRewards);\n    }","contract":"Gleaf","time":0},{"type":"constant-restrict-modification  ","before":"address nullAddress = 0x0000000000000000000000000000000000000000;","after":"address constant nullAddress = 0x0000000000000000000000000000000000000000;","contract":"Gleaf","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public CLAIM_START_TIME;","after":"uint256 public immutable CLAIM_START_TIME;","contract":"Gleaf","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public OgsCount = 100;","after":"uint256 public constant OgsCount = 100;","contract":"Gleaf","time":1}]}