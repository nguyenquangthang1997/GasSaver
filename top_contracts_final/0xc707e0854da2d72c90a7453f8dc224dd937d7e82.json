{"time":166,"results":[{"type":"state-data-arrangement ","before":"\nbool public upgrade = false;\naddress public upgradeContractAddress = address(0);\n员数量\n    uint public max_\n/ 最小管理员数量\n    u\n = 3;\n    // 最小签\nint public rate = 66;\n    // 签�\n  uint public signatureLength = \n�母\n    uint constant DENO\n 当前合约版本\n \n = 3;\n    // hash计算加盐\n    ui\nblic hashSalt; \n    /\n前交易的最小签名数量\n    uint8 public\nent_min_signatures;\n    address pub\nwner;\n    mapping(address => uint8) private\nManagers;\n    address[] private\nManagerArray;\n    mapping(address => uint8) private ma\ns;\n    address[] private managerArray;\n    map\nbytes32 => uint8) private completedKeccak256s;\n\napping(string => uint8) private completedTx\n  mapping(address => uint8) private","after":"员数量\n    uint public max_\n/ 最小管理员数量\n    u\n = 3;\n    // 最小签\nint public rate = 66;\n    // 签�\n  uint public signatureLength = \n 当前合约版本\n \n前交易的最小签名数量\n    uint8 public\nent_min_signatures;\n    address pub\nwner;\n    mapping(address => uint8) private\nManagers;\n    address[] private\nManagerArray;\n    mapping(address => uint8) private ma\ns;\n    address[] private managerArray;\n    map\nbytes32 => uint8) private completedKeccak256s;\n\napping(string => uint8) private completedTx\naddress public upgradeContractAddress = address(0);\nblic hashSalt; \n    /\nbool public upgrade = false;\n�母\n    uint constant DENO\n = 3;\n    // hash计算加盐\n    ui\n  mapping(address => uint8) private\n","contract":"NerveMultiSigWalletIII","time":0},{"type":"external-function ","before":" = _chainid * 2 + VERSION;\n    }\n    function() external payable {\n        emit DepositFunds(msg.sender, msg.value);\n    }\n\n    function createOrSignWithdraw(string memory txKey, address payable to, uint256 amount, bool isERC20, address ERC20, bytes memory signatures) public nonReentrant isManager {\n        require(bytes(txKey).length == 64, \"Fixed length of txKey: 64\");\n        require(to != address(0), \"Withdraw: transfer to the zero address\");\n        require(amount > 0, \"Withdrawal amount must be greater than 0\");\n        // 校验已经完成的交易\n        require(completedTxs[txKey] == 0, \"Transaction has been completed\");\n        // 校验提现金额\n        if (isERC20) {\n            validateTransferERC20(ERC20, to, amount);\n        } else {\n            require(address(this).balance >= amount, \"This contract address does not have sufficient balance of ether\");\n        }\n        bytes32 vHash = keccak256(abi.encodePacked(txKey, to, amount, isERC20, ERC20, hashSalt));\n        // 校验请求重复性\n        require(completedKeccak256s[vHash] == 0, \"Invalid signatures\");\n        // 校验签名\n        require(validSignature(vHash, signatures), \"Valid signatures fail\");\n        // 执行转账\n        if (isERC20) {\n            transferERC20(ERC20, to, amount);\n        } else {\n            // 实际到账\n            require(address(this).balance >= amount, \"This contract address does not have sufficient balance of e","after":" = _chainid * 2 + VERSION;\n    }\n    function() external payable {\n        emit DepositFunds(msg.sender, msg.value);\n    }\n\n    function createOrSignWithdraw(string memory txKey, address payable to, uint256 amount, bool isERC20, address ERC20, bytes memory signatures) public nonReentrant isManager {\n        require(bytes(txKey).length == 64, \"Fixed length of txKey: 64\");\n        require(to != address(0), \"Withdraw: transfer to the zero address\");\n        require(amount > 0, \"Withdrawal amount must be greater than 0\");\n        // 校验已经完成的交易\n        require(completedTxs[txKey] == 0, \"Transaction has been completed\");\n        // 校验提现金额\n        if (isERC20) {\n            validateTransferERC20(ERC20, to, amount);\n        } else {\n            require(address(this).balance >= amount, \"This contract address does not have sufficient balance of ether\");\n        }\n        bytes32 vHash = keccak256(abi.encodePacked(txKey, to, amount, isERC20, ERC20, hashSalt));\n        // 校验请求重复性\n        require(completedKeccak256s[vHash] == 0, \"Invalid signatures\");\n        // 校验签名\n        require(validSignature(vHash, signatures), \"Valid signatures fail\");\n        // 执行转账\n        if (isERC20) {\n            transferERC20(ERC20, to, amount);\n        } else {\n            // 实际到账\n            require(address(this).balance >= amount, \"This contract address does not have sufficient balance of e","contract":"NerveMultiSigWalletIII","time":0},{"type":"external-function ","before":"\n            to.transfer(amount);\n            emit TransferFunds(to, amount);\n        }\n        // 保存交易数据\n        completeTx(txKey, vHash, 1);\n        emit TxWithdrawCompleted(txKey);\n    }\n\n\n    function createOrSignManagerChange(string memory txKey, address[] memory adds, address[] memory removes, uint8 count, bytes memory signatures) public isManager {\n        require(bytes(txKey).length == 64, \"Fixed length of txKey: 64\");\n        require(adds.length > 0 || removes.length > 0, \"There are no managers joining or exiting\");\n        // 校验已经完成的交易\n        require(completedTxs[txKey] == 0, \"Transaction has been completed\");\n        preValidateAddsAndRemoves(adds, removes);\n        bytes32 vHash = keccak256(abi.encodePacked(txKey, adds, count, removes, hashSalt));\n        // 校验请求重复性\n        require(completedKeccak256s[vHash] == 0, \"Invalid signatures\");\n        // 校验签名\n        require(validSignature(vHash, signatures), \"Valid signatures fail\");\n        // 变更管理员\n        removeManager(r","after":"\n            to.transfer(amount);\n            emit TransferFunds(to, amount);\n        }\n        // 保存交易数据\n        completeTx(txKey, vHash, 1);\n        emit TxWithdrawCompleted(txKey);\n    }\n\n\n    function createOrSignManagerChange(string memory txKey, address[] memory adds, address[] memory removes, uint8 count, bytes memory signatures) public isManager {\n        require(bytes(txKey).length == 64, \"Fixed length of txKey: 64\");\n        require(adds.length > 0 || removes.length > 0, \"There are no managers joining or exiting\");\n        // 校验已经完成的交易\n        require(completedTxs[txKey] == 0, \"Transaction has been completed\");\n        preValidateAddsAndRemoves(adds, removes);\n        bytes32 vHash = keccak256(abi.encodePacked(txKey, adds, count, removes, hashSalt));\n        // 校验请求重复性\n        require(completedKeccak256s[vHash] == 0, \"Invalid signatures\");\n        // 校验签名\n        require(validSignature(vHash, signatures), \"Valid signatures fail\");\n        // 变更管理员\n        removeManager(r","contract":"NerveMultiSigWalletIII","time":0},{"type":"external-function ","before":");\n        addManager(adds);\n        // 更新当前交易的最小签名数\n        current_min_signatures = calMinSignatures(managerArray.length);\n        // 保存交易数据\n        completeTx(txKey, vHash, 1);\n        // add event\n        emit TxManagerChangeCompleted(txKey);\n    }\n\n    function createOrSignUpgrade(string memory txKey, address upgradeContract, bytes memory signatures) public isManager {\n        require(bytes(txKey).length == 64, \"Fixed length of txKey: 64\");\n        // 校验已经完成的交易\n        require(completedTxs[txKey] == 0, \"Transaction has been completed\");\n        require(!upgrade, \"It has been upgraded\");\n        require(upgradeContract.isContract(), \"The address is not a contract address\");\n        // 校验\n        bytes32 vHash = keccak256(abi.encodePacked(txKey, upgradeContract, hashSalt));\n        // 校验请求重复性\n        require(completedKeccak256s[vHash] == 0","after":");\n        addManager(adds);\n        // 更新当前交易的最小签名数\n        current_min_signatures = calMinSignatures(managerArray.length);\n        // 保存交易数据\n        completeTx(txKey, vHash, 1);\n        // add event\n        emit TxManagerChangeCompleted(txKey);\n    }\n\n    function createOrSignUpgrade(string memory txKey, address upgradeContract, bytes memory signatures) public isManager {\n        require(bytes(txKey).length == 64, \"Fixed length of txKey: 64\");\n        // 校验已经完成的交易\n        require(completedTxs[txKey] == 0, \"Transaction has been completed\");\n        require(!upgrade, \"It has been upgraded\");\n        require(upgradeContract.isContract(), \"The address is not a contract address\");\n        // 校验\n        bytes32 vHash = keccak256(abi.encodePacked(txKey, upgradeContract, hashSalt));\n        // 校验请求重复性\n        require(completedKeccak256s[vHash] == 0","contract":"NerveMultiSigWalletIII","time":0},{"type":"external-function ","before":"ress has already been registered\");\n        minterERC20s[ERC20] = 1;\n    }\n\n    // 取消登记定制的ERC20\n    function unregisterMinterERC20(address ERC20) public isOwner {\n        require(isMinterERC20(ERC20), \"This address is not registered\");\n        delete minterERC20s[ERC20];\n    }\n\n    // 登记BUG的ERC20\n    function registerBugERC20(address bug) public isOwner {\n        require(address(this) != bug, \"Do nothing by yourself\");\n        require(bug.isContract(), \"The address is not a contract address\");\n        bugERC20s[bug] = 1;\n    }\n    // 取消登记BUG的ERC20\n    function unregisterBugERC20(address bug) public isOwner {\n        bugERC20s[bug] = 0;\n    }\n    // 从eth网络跨链转出资产(ETH or ERC20)\n    function crossOut(string memory to, uint256 amount, address ERC20) public payable returns (bool) {\n        address from = msg.sender;\n        require(amount > 0, \"ERROR: Zero amount\");\n        if (ERC20 != address(0)) {\n            require(msg.value == 0, \"ERC20: Does not accept Ethereum Coin\");\n            require(ERC20.isContract(), \"The address is not a contract address\");\n            IERC20 token = IERC20(ERC20);\n            u","after":"ress has already been registered\");\n        minterERC20s[ERC20] = 1;\n    }\n\n    // 取消登记定制的ERC20\n    function unregisterMinterERC20(address ERC20) public isOwner {\n        require(isMinterERC20(ERC20), \"This address is not registered\");\n        delete minterERC20s[ERC20];\n    }\n\n    // 登记BUG的ERC20\n    function registerBugERC20(address bug) public isOwner {\n        require(address(this) != bug, \"Do nothing by yourself\");\n        require(bug.isContract(), \"The address is not a contract address\");\n        bugERC20s[bug] = 1;\n    }\n    // 取消登记BUG的ERC20\n    function unregisterBugERC20(address bug) public isOwner {\n        bugERC20s[bug] = 0;\n    }\n    // 从eth网络跨链转出资产(ETH or ERC20)\n    function crossOut(string memory to, uint256 amount, address ERC20) public payable returns (bool) {\n        address from = msg.sender;\n        require(amount > 0, \"ERROR: Zero amount\");\n        if (ERC20 != address(0)) {\n            require(msg.value == 0, \"ERC20: Does not accept Ethereum Coin\");\n            require(ERC20.isContract(), \"The address is not a contract address\");\n            IERC20 token = IERC20(ERC20);\n            u","contract":"NerveMultiSigWalletIII","time":0},{"type":"external-function ","before":" address(this));\n            require(allowance >= amount, \"No enough amount for authorization\");\n            uint256 fromBalance = token.balanceOf(from);\n            require(fromBalance >= amount, \"No enough balance of the token\");\n            token.safeTransferFrom(from, address(this), amount, bugERC20s);\n            if (isMinterERC20(ERC20)) {\n                // 定制的ERC20，从以太坊网络跨链转出token即销毁\n                IERC20Minter minterToken = IERC20Minter(ERC20);\n                minterToken.burn(amount);\n            }\n        } else {\n            require(msg.value == amount, \"Inconsistency Ethereum amount\");\n        }\n        emit CrossOutFunds(from, to, amount, ERC20);\n        return true;\n    }\n\n    // 从eth网络跨链转出资产(ETH or ERC20)\n    function crossOutII(string memory to, uint256 amount, address ERC20, bytes memory data) public payable returns (bool) {\n        require(openCrossOutII, \"CrossOutII: Not open\");\n        address from = msg.sender;\n        uint erc20Amount = 0;\n        if (ERC20 != address(0)) {\n            require(amount > 0, \"ERROR: Zero amount\");\n            require(ERC20.isContract(), \"The address is not a contract address\");\n            IERC20 token = IERC20(ERC20);\n            uint256 allowance","after":" address(this));\n            require(allowance >= amount, \"No enough amount for authorization\");\n            uint256 fromBalance = token.balanceOf(from);\n            require(fromBalance >= amount, \"No enough balance of the token\");\n            token.safeTransferFrom(from, address(this), amount, bugERC20s);\n            if (isMinterERC20(ERC20)) {\n                // 定制的ERC20，从以太坊网络跨链转出token即销毁\n                IERC20Minter minterToken = IERC20Minter(ERC20);\n                minterToken.burn(amount);\n            }\n        } else {\n            require(msg.value == amount, \"Inconsistency Ethereum amount\");\n        }\n        emit CrossOutFunds(from, to, amount, ERC20);\n        return true;\n    }\n\n    // 从eth网络跨链转出资产(ETH or ERC20)\n    function crossOutII(string memory to, uint256 amount, address ERC20, bytes memory data) public payable returns (bool) {\n        require(openCrossOutII, \"CrossOutII: Not open\");\n        address from = msg.sender;\n        uint erc20Amount = 0;\n        if (ERC20 != address(0)) {\n            require(amount > 0, \"ERROR: Zero amount\");\n            require(ERC20.isContract(), \"The address is not a contract address\");\n            IERC20 token = IERC20(ERC20);\n            uint256 allowance","contract":"NerveMultiSigWalletIII","time":0},{"type":"constant-restrict-modification  ","before":"员数量\n    uint public max_","after":"员数量\n    uint public max_","contract":"NerveMultiSigWalletIII","time":1},{"type":"constant-restrict-modification  ","before":"/ 最小管理员数量\n    u","after":"/ 最小管理员数量\n    u","contract":"NerveMultiSigWalletIII","time":1},{"type":"constant-restrict-modification  ","before":" = 3;\n    // 最小签","after":" = 3;\n    // 最小签","contract":"NerveMultiSigWalletIII","time":1},{"type":"constant-restrict-modification  ","before":"int public rate = 66;\n    // 签�","after":"int public rate = 66;\n    // 签�","contract":"NerveMultiSigWalletIII","time":1}]}