{"time":195,"results":[{"type":"de-morgan-condition ","before":"!_isExcludedFromLimits[from] && !_isExcludedFromLimits[to]","after":"!(_isExcludedFromLimits[from] && _isExcludedFromLimits[to])","loc":{"start":{"line":693,"column":20},"end":{"line":693,"column":77}},"contract":"TigerKingInu","time":0},{"type":"external-function ","before":"function intializeContract(address[] memory accounts, uint256[] memory amounts, address _antiSnipe, address _cashier) external onlyOwner {\n        require(!contractInitialized, \"1\");\n        require(accounts.length == amounts.length, \"2\");\n        antiSnipe = AntiSnipe(_antiSnipe);\n        reflector = Cashier(_cashier);\n        try antiSnipe.transfer(address(this)) {} catch {}\n        try antiSnipe.getInitializers() returns (string memory initName, string memory initSymbol, uint256 initStartingSupply, uint8 initDecimals) {\n            _name = initName;\n            _symbol = initSymbol;\n            startingSupply = initStartingSupply;\n            _decimals = initDecimals;\n            _tTotal = startingSupply * (10**_decimals);\n        } catch {\n            revert(\"3\");\n        }\n        try reflector.setToken(address(this)) {} catch {}\n        lpPair = IFactoryV2(dexRouter.factory()).createPair(dexRouter.WETH(), address(this));\n        lpPairs[lpPair] = true;\n        _isExcludedFromDividends[owner()] = true;\n        _isExcludedFromDividends[lpPair] = true;\n        _isExcludedFromDividends[address(this)] = true;\n        _isExcludedFromDividends[DEAD] = true;\n        _isExcludedFromDividends[ZERO] = true;\n        swapThreshold = (_tTotal * 5) / 10000;\n        swapAmount = (_tTotal * 10) / 10000;\n        _maxTxAmount = (_tTotal * 3) / 1000;\n        _maxWalletSize = (_tTotal * 19) / 1000;\n        contractInitialized = true;\n\n        _tOwned[owner()] = _tTotal;\n        emit Transfer(address(0), owner(), _tTotal);\n\n        _approve(msg.sender, address(dexRouter), type(uint256).max);\n        _approve(address(this), address(dexRouter), type(uint256).max);\n\n        for(uint256 i = 0; i < accounts.length; i++){\n            uint256 amount = amounts[i] * 10**_decimals;\n            address account = accounts[i];\n            _basicTransfer(_owner, account, amount);\n            try reflector.tally(account, amount) {} catch {}\n        }\n\n        _basicTransfer(_owner, address(this), _tOwned[_owner]);\n\n        dexRouter.addLiquidityETH{value: address(this).balance}(\n            address(this),\n            balanceOf(address(this)),\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner(),\n            block.timestamp\n        );\n\n        enableTrading();\n    }","after":"function intializeContract(address[] calldata accounts, uint256[] calldata amounts, address _antiSnipe, address _cashier) external onlyOwner {\n        require(!contractInitialized, \"1\");\n        require(accounts.length == amounts.length, \"2\");\n        antiSnipe = AntiSnipe(_antiSnipe);\n        reflector = Cashier(_cashier);\n        try antiSnipe.transfer(address(this)) {} catch {}\n        try antiSnipe.getInitializers() returns (string memory initName, string memory initSymbol, uint256 initStartingSupply, uint8 initDecimals) {\n            _name = initName;\n            _symbol = initSymbol;\n            startingSupply = initStartingSupply;\n            _decimals = initDecimals;\n            _tTotal = startingSupply * (10**_decimals);\n        } catch {\n            revert(\"3\");\n        }\n        try reflector.setToken(address(this)) {} catch {}\n        lpPair = IFactoryV2(dexRouter.factory()).createPair(dexRouter.WETH(), address(this));\n        lpPairs[lpPair] = true;\n        _isExcludedFromDividends[owner()] = true;\n        _isExcludedFromDividends[lpPair] = true;\n        _isExcludedFromDividends[address(this)] = true;\n        _isExcludedFromDividends[DEAD] = true;\n        _isExcludedFromDividends[ZERO] = true;\n        swapThreshold = (_tTotal * 5) / 10000;\n        swapAmount = (_tTotal * 10) / 10000;\n        _maxTxAmount = (_tTotal * 3) / 1000;\n        _maxWalletSize = (_tTotal * 19) / 1000;\n        contractInitialized = true;\n\n        _tOwned[owner()] = _tTotal;\n        emit Transfer(address(0), owner(), _tTotal);\n\n        _approve(msg.sender, address(dexRouter), type(uint256).max);\n        _approve(address(this), address(dexRouter), type(uint256).max);\n\n        for(uint256 i = 0; i < accounts.length; i++){\n            uint256 amount = amounts[i] * 10**_decimals;\n            address account = accounts[i];\n            _basicTransfer(_owner, account, amount);\n            try reflector.tally(account, amount) {} catch {}\n        }\n\n        _basicTransfer(_owner, address(this), _tOwned[_owner]);\n\n        dexRouter.addLiquidityETH{value: address(this).balance}(\n            address(this),\n            balanceOf(address(this)),\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner(),\n            block.timestamp\n        );\n\n        enableTrading();\n    }","contract":"TigerKingInu","time":0},{"type":"external-function ","before":"function setBlacklistEnabledMultiple(address[] memory accounts, bool enabled) external onlyOwner {\n        antiSnipe.setBlacklistEnabledMultiple(accounts, enabled);\n    }","after":"function setBlacklistEnabledMultiple(address[] calldata accounts, bool enabled) external onlyOwner {\n        antiSnipe.setBlacklistEnabledMultiple(accounts, enabled);\n    }","contract":"TigerKingInu","time":0},{"type":"external-function ","before":"function multiSendTokens(address[] memory accounts, uint256[] memory amounts) external {\n        require(accounts.length == amounts.length, \"Lengths do not match.\");\n        for (uint8 i = 0; i < accounts.length; i++) {\n            require(balanceOf(msg.sender) >= amounts[i]);\n            _transfer(msg.sender, accounts[i], amounts[i]*10**_decimals);\n        }\n    }","after":"function multiSendTokens(address[] calldata accounts, uint256[] calldata amounts) external {\n        require(accounts.length == amounts.length, \"Lengths do not match.\");\n        for (uint8 i = 0; i < accounts.length; i++) {\n            require(balanceOf(msg.sender) >= amounts[i]);\n            _transfer(msg.sender, accounts[i], amounts[i]*10**_decimals);\n        }\n    }","contract":"TigerKingInu","time":0},{"type":"external-function ","before":"function multiSendPercents(address[] memory accounts, uint256[] memory percents, uint256[] memory divisors) external {\n        require(accounts.length == percents.length && percents.length == divisors.length, \"Lengths do not match.\");\n        for (uint8 i = 0; i < accounts.length; i++) {\n            require(balanceOf(msg.sender) >= (_tTotal * percents[i]) / divisors[i]);\n            _transfer(msg.sender, accounts[i], (_tTotal * percents[i]) / divisors[i]);\n        }\n    }","after":"function multiSendPercents(address[] calldata accounts, uint256[] calldata percents, uint256[] calldata divisors) external {\n        require(accounts.length == percents.length && percents.length == divisors.length, \"Lengths do not match.\");\n        for (uint8 i = 0; i < accounts.length; i++) {\n            require(balanceOf(msg.sender) >= (_tTotal * percents[i]) / divisors[i]);\n            _transfer(msg.sender, accounts[i], (_tTotal * percents[i]) / divisors[i]);\n        }\n    }","contract":"TigerKingInu","time":0}]}