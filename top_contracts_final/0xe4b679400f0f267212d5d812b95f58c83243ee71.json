{"time":171,"results":[{"type":"external-function ","before":"function initialize(\n        uint256 _chainId,\n        address _nextOwner,\n        uint256 _initialRate,\n        string memory _version,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) public initializer {\n        ERC20Detailed.initialize(_name, _symbol, _decimals);\n        ERC20WithRate.initialize(_nextOwner, _initialRate);\n        ERC20WithPermit.initialize(\n            _chainId,\n            _version,\n            _name,\n            _symbol,\n            _decimals\n        );\n        Claimable.initialize(_nextOwner);\n        CanReclaimTokens.initialize(_nextOwner);\n    }","after":"function initialize(\n        uint256 _chainId,\n        address _nextOwner,\n        uint256 _initialRate,\n        string calldata _version,\n        string calldata _name,\n        string calldata _symbol,\n        uint8 _decimals\n    ) public initializer {\n        ERC20Detailed.initialize(_name, _symbol, _decimals);\n        ERC20WithRate.initialize(_nextOwner, _initialRate);\n        ERC20WithPermit.initialize(\n            _chainId,\n            _version,\n            _name,\n            _symbol,\n            _decimals\n        );\n        Claimable.initialize(_nextOwner);\n        CanReclaimTokens.initialize(_nextOwner);\n    }","contract":"RenERC20LogicV1","time":0},{"type":"external-function ","before":"function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }","after":"function initialize(string calldata name, string calldata symbol, uint8 decimals) public initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }","contract":"RenERC20LogicV1","time":0},{"type":"external-function ","before":"function initialize(\n        uint256 _chainId,\n        string memory _version,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) public initializer {\n        ERC20Detailed.initialize(_name, _symbol, _decimals);\n        version = _version;\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name())),\n                keccak256(bytes(version)),\n                _chainId,\n                address(this)\n            )\n        );\n    }","after":"function initialize(\n        uint256 _chainId,\n        string calldata _version,\n        string calldata _name,\n        string calldata _symbol,\n        uint8 _decimals\n    ) public initializer {\n        ERC20Detailed.initialize(_name, _symbol, _decimals);\n        version = _version;\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\n                    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n                ),\n                keccak256(bytes(name())),\n                keccak256(bytes(version)),\n                _chainId,\n                address(this)\n            )\n        );\n    }","contract":"RenERC20LogicV1","time":0},{"type":"external-function ","before":"function initialize(address _logic, address _admin, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }","after":"function initialize(address _logic, address _admin, bytes calldata _data) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }","contract":"RenBTC","time":0},{"type":"external-function ","before":"function initialize(address _logic, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }","after":"function initialize(address _logic, bytes calldata _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }","contract":"RenBTC","time":0},{"type":"external-function ","before":"function initialize(address _logic, address _admin, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }","after":"function initialize(address _logic, address _admin, bytes calldata _data) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }","contract":"RenZEC","time":0},{"type":"external-function ","before":"function initialize(address _logic, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }","after":"function initialize(address _logic, bytes calldata _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }","contract":"RenZEC","time":0},{"type":"external-function ","before":"function initialize(address _logic, address _admin, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }","after":"function initialize(address _logic, address _admin, bytes calldata _data) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }","contract":"RenBCH","time":0},{"type":"external-function ","before":"function initialize(address _logic, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }","after":"function initialize(address _logic, bytes calldata _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }","contract":"RenBCH","time":0},{"type":"external-function ","before":"function mint(\n        bytes32 _pHash,\n        uint256 _amountUnderlying,\n        bytes32 _nHash,\n        bytes memory _sig\n    ) public returns (uint256) {\n        \n        bytes32 signedMessageHash = hashForSignature(\n            _pHash,\n            _amountUnderlying,\n            msg.sender,\n            _nHash\n        );\n        require(\n            status[signedMessageHash] == false,\n            \"Gateway: nonce hash already spent\"\n        );\n        if (!verifySignature(signedMessageHash, _sig)) {\n            \n            \n            \n            revert(\n                String.add8(\n                    \"Gateway: invalid signature. pHash: \",\n                    String.fromBytes32(_pHash),\n                    \", amount: \",\n                    String.fromUint(_amountUnderlying),\n                    \", msg.sender: \",\n                    String.fromAddress(msg.sender),\n                    \", _nHash: \",\n                    String.fromBytes32(_nHash)\n                )\n            );\n        }\n        status[signedMessageHash] = true;\n\n        uint256 amountScaled = token.fromUnderlying(_amountUnderlying);\n\n        \n        uint256 absoluteFeeScaled = amountScaled.mul(mintFee).div(\n            BIPS_DENOMINATOR\n        );\n        uint256 receivedAmountScaled = amountScaled.sub(\n            absoluteFeeScaled,\n            \"Gateway: fee exceeds amount\"\n        );\n\n        \n        token.mint(msg.sender, receivedAmountScaled);\n        \n        token.mint(feeRecipient, absoluteFeeScaled);\n\n        \n        uint256 receivedAmountUnderlying = token.toUnderlying(\n            receivedAmountScaled\n        );\n        emit LogMint(\n            msg.sender,\n            receivedAmountUnderlying,\n            nextN,\n            signedMessageHash\n        );\n        nextN += 1;\n\n        return receivedAmountScaled;\n    }","after":"function mint(\n        bytes32 _pHash,\n        uint256 _amountUnderlying,\n        bytes32 _nHash,\n        bytes calldata _sig\n    ) public returns (uint256) {\n        \n        bytes32 signedMessageHash = hashForSignature(\n            _pHash,\n            _amountUnderlying,\n            msg.sender,\n            _nHash\n        );\n        require(\n            status[signedMessageHash] == false,\n            \"Gateway: nonce hash already spent\"\n        );\n        if (!verifySignature(signedMessageHash, _sig)) {\n            \n            \n            \n            revert(\n                String.add8(\n                    \"Gateway: invalid signature. pHash: \",\n                    String.fromBytes32(_pHash),\n                    \", amount: \",\n                    String.fromUint(_amountUnderlying),\n                    \", msg.sender: \",\n                    String.fromAddress(msg.sender),\n                    \", _nHash: \",\n                    String.fromBytes32(_nHash)\n                )\n            );\n        }\n        status[signedMessageHash] = true;\n\n        uint256 amountScaled = token.fromUnderlying(_amountUnderlying);\n\n        \n        uint256 absoluteFeeScaled = amountScaled.mul(mintFee).div(\n            BIPS_DENOMINATOR\n        );\n        uint256 receivedAmountScaled = amountScaled.sub(\n            absoluteFeeScaled,\n            \"Gateway: fee exceeds amount\"\n        );\n\n        \n        token.mint(msg.sender, receivedAmountScaled);\n        \n        token.mint(feeRecipient, absoluteFeeScaled);\n\n        \n        uint256 receivedAmountUnderlying = token.toUnderlying(\n            receivedAmountScaled\n        );\n        emit LogMint(\n            msg.sender,\n            receivedAmountUnderlying,\n            nextN,\n            signedMessageHash\n        );\n        nextN += 1;\n\n        return receivedAmountScaled;\n    }","contract":"GatewayLogicV1","time":0},{"type":"external-function ","before":"function burn(bytes memory _to, uint256 _amount) public returns (uint256) {\n        \n        \n        require(_to.length != 0, \"Gateway: to address is empty\");\n\n        \n        uint256 fee = _amount.mul(burnFee).div(BIPS_DENOMINATOR);\n        uint256 amountAfterFee = _amount.sub(\n            fee,\n            \"Gateway: fee exceeds amount\"\n        );\n\n        \n        \n        \n        uint256 amountAfterFeeUnderlying = token.toUnderlying(amountAfterFee);\n\n        \n        token.burn(msg.sender, _amount);\n        token.mint(feeRecipient, fee);\n\n        require(\n            \n            \n            amountAfterFeeUnderlying > minimumBurnAmount,\n            \"Gateway: amount is less than the minimum burn amount\"\n        );\n\n        emit LogBurn(_to, amountAfterFeeUnderlying, nextN, _to);\n        nextN += 1;\n\n        return amountAfterFeeUnderlying;\n    }","after":"function burn(bytes calldata _to, uint256 _amount) public returns (uint256) {\n        \n        \n        require(_to.length != 0, \"Gateway: to address is empty\");\n\n        \n        uint256 fee = _amount.mul(burnFee).div(BIPS_DENOMINATOR);\n        uint256 amountAfterFee = _amount.sub(\n            fee,\n            \"Gateway: fee exceeds amount\"\n        );\n\n        \n        \n        \n        uint256 amountAfterFeeUnderlying = token.toUnderlying(amountAfterFee);\n\n        \n        token.burn(msg.sender, _amount);\n        token.mint(feeRecipient, fee);\n\n        require(\n            \n            \n            amountAfterFeeUnderlying > minimumBurnAmount,\n            \"Gateway: amount is less than the minimum burn amount\"\n        );\n\n        emit LogBurn(_to, amountAfterFeeUnderlying, nextN, _to);\n        nextN += 1;\n\n        return amountAfterFeeUnderlying;\n    }","contract":"GatewayLogicV1","time":0},{"type":"external-function ","before":"function initialize(address _logic, address _admin, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }","after":"function initialize(address _logic, address _admin, bytes calldata _data) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }","contract":"BTCGateway","time":0},{"type":"external-function ","before":"function initialize(address _logic, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }","after":"function initialize(address _logic, bytes calldata _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }","contract":"BTCGateway","time":0},{"type":"external-function ","before":"function initialize(address _logic, address _admin, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }","after":"function initialize(address _logic, address _admin, bytes calldata _data) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }","contract":"ZECGateway","time":0},{"type":"external-function ","before":"function initialize(address _logic, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }","after":"function initialize(address _logic, bytes calldata _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }","contract":"ZECGateway","time":0},{"type":"external-function ","before":"function initialize(address _logic, address _admin, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }","after":"function initialize(address _logic, address _admin, bytes calldata _data) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }","contract":"BCHGateway","time":0},{"type":"external-function ","before":"function initialize(address _logic, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }","after":"function initialize(address _logic, bytes calldata _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }","contract":"BCHGateway","time":0}]}