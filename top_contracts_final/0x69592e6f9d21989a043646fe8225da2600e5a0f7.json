{"time":212,"results":[{"type":"constant-restrict-modification  ","before":"{\n\tuint256 private MAX_UINT = 2**256 -","after":"{\n\tuint256 private constant MAX_UINT = 2**256 -","contract":"CosmosERC20","time":0},{"type":"immutable-restrict-modification ","before":"\n\n\tuint8 private cosmosDecima","after":"\n\n\tuint8 private cosmosDecima","contract":"CosmosERC20","time":0},{"type":"external-function ","before":".\n\tfunction submitLogicCall(\n\t\t// The validators that approve the call\n\t\tValsetArgs calldata _currentValset,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tValSignature[] calldata _sigs,\n\t\tLogicCallArgs memory _args\n\t) external nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the call has not timed out\n\t\t\tif (block.number >= _args.timeOut) {\n\t\t\t\trevert LogicCallTimedOut();\n\t\t\t}\n\n\t\t\t// Check that the invalidation nonce is higher than the last nonce for this invalidation Id\n\t\t\tif (state_invalidationMapping[_args.invalidationId] >= _args.invalidationNonce) {\n\t\t\t\trevert InvalidLogicCallNonce({\n\t\t\t\t\tnewNonce: _args.invalidationNonce,\n\t\t\t\t\tcurrentNonce: state_invalidationMapping[_args.invalidationId]\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// note the lack of nonce skipping check, it's not needed here since an attacker\n\t\t\t// will never be able to fill the invalidationId space, therefore a nonce lockout\n\t\t\t// is simply not possible\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\tvalidateValset(_currentValset, _sigs);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\tif (makeCheckpoint(_currentValset, state_gravityId) != state_lastValsetCheckpoint) {\n\t\t\t\trevert IncorrectCheckpoint();\n\t\t\t}\n\n\t\t\tif (_args.transferAmounts.length != _args.transferTokenContracts.length) {\n\t\t\t\trevert InvalidLogicCallTransfers();\n\t\t\t}\n\n\t\t\tif (_args.feeAmounts.length != _args.feeTokenContracts.length) {\n\t\t\t\trevert InvalidLogicCallFees();\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tbytes32 argsHash = keccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\tstate_gravityId,\n\t\t\t\t\t// bytes32 encoding of \"logicCall\"\n\t\t\t\t\t0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n\t\t\t\t\t_args.transferAmounts,\n\t\t\t\t\t_args.transferTokenContracts,\n\t\t\t\t\t_args.feeAmounts,\n\t\t\t\t\t_args.feeTokenContracts,\n\t\t\t\t\t_args.logicContractAddress,\n\t\t\t\t\t_args.payload,\n\t\t\t\t\t_args.timeOut,\n\t\t\t\t\t_args.invalidationId,\n\t\t\t\t\t_args.invalidationNonce\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValset,\n\t\t\t\t_sigs,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\targsHash,\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\t\t}\n\n\t\t// ACTIONS\n\n\t\t// Update invaldiation nonce\n\t\tstate_invalidationMapping[_args.invalidationId] = _args.invalidationNonce;\n\n\t\t// Send tokens to the logic contract\n\t\tfor (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n\t\t\tIERC20(_args.transferTokenContracts[i]).safeTransfer(\n\t\t\t\t_args.logicContractAddress,\n\t\t\t\t_args.transferAmounts[i]\n\t\t\t);\n\t\t}\n\n\t\t// Make call to logic contract\n\t\tbytes memory returnData = Address.functionCall(_args.logicContractAddress, _args.payload);\n\n\t\t// Send fees to msg.sender\n\t\tfor (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n\t\t\tIERC20(_args.feeTokenContracts[i]).safeTransfer(msg.sender, _args.feeAmounts[i]);\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce + 1;\n\t\t\temit LogicCallEvent(\n\t\t\t\t_args.invalidationId,\n\t\t\t\t_args.invalidationNonce,\n\t\t\t\treturnData,\n\t\t\t\tstate_lastEventNonce\n\t\t\t);\n\t\t}","after":".\n\tfunction submitLogicCall(\n\t\t// The validators that approve the call\n\t\tValsetArgs calldata _currentValset,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tValSignature[] calldata _sigs,\n\t\tLogicCallArgs calldata _args\n\t) external nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the call has not timed out\n\t\t\tif (block.number >= _args.timeOut) {\n\t\t\t\trevert LogicCallTimedOut();\n\t\t\t}\n\n\t\t\t// Check that the invalidation nonce is higher than the last nonce for this invalidation Id\n\t\t\tif (state_invalidationMapping[_args.invalidationId] >= _args.invalidationNonce) {\n\t\t\t\trevert InvalidLogicCallNonce({\n\t\t\t\t\tnewNonce: _args.invalidationNonce,\n\t\t\t\t\tcurrentNonce: state_invalidationMapping[_args.invalidationId]\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// note the lack of nonce skipping check, it's not needed here since an attacker\n\t\t\t// will never be able to fill the invalidationId space, therefore a nonce lockout\n\t\t\t// is simply not possible\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\tvalidateValset(_currentValset, _sigs);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\tif (makeCheckpoint(_currentValset, state_gravityId) != state_lastValsetCheckpoint) {\n\t\t\t\trevert IncorrectCheckpoint();\n\t\t\t}\n\n\t\t\tif (_args.transferAmounts.length != _args.transferTokenContracts.length) {\n\t\t\t\trevert InvalidLogicCallTransfers();\n\t\t\t}\n\n\t\t\tif (_args.feeAmounts.length != _args.feeTokenContracts.length) {\n\t\t\t\trevert InvalidLogicCallFees();\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tbytes32 argsHash = keccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\tstate_gravityId,\n\t\t\t\t\t// bytes32 encoding of \"logicCall\"\n\t\t\t\t\t0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n\t\t\t\t\t_args.transferAmounts,\n\t\t\t\t\t_args.transferTokenContracts,\n\t\t\t\t\t_args.feeAmounts,\n\t\t\t\t\t_args.feeTokenContracts,\n\t\t\t\t\t_args.logicContractAddress,\n\t\t\t\t\t_args.payload,\n\t\t\t\t\t_args.timeOut,\n\t\t\t\t\t_args.invalidationId,\n\t\t\t\t\t_args.invalidationNonce\n\t\t\t\t)\n\t\t\t);\n\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValset,\n\t\t\t\t_sigs,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\targsHash,\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\t\t}\n\n\t\t// ACTIONS\n\n\t\t// Update invaldiation nonce\n\t\tstate_invalidationMapping[_args.invalidationId] = _args.invalidationNonce;\n\n\t\t// Send tokens to the logic contract\n\t\tfor (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n\t\t\tIERC20(_args.transferTokenContracts[i]).safeTransfer(\n\t\t\t\t_args.logicContractAddress,\n\t\t\t\t_args.transferAmounts[i]\n\t\t\t);\n\t\t}\n\n\t\t// Make call to logic contract\n\t\tbytes memory returnData = Address.functionCall(_args.logicContractAddress, _args.payload);\n\n\t\t// Send fees to msg.sender\n\t\tfor (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n\t\t\tIERC20(_args.feeTokenContracts[i]).safeTransfer(msg.sender, _args.feeAmounts[i]);\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce + 1;\n\t\t\temit LogicCallEvent(\n\t\t\t\t_args.invalidationId,\n\t\t\t\t_args.invalidationNonce,\n\t\t\t\treturnData,\n\t\t\t\tstate_lastEventNonce\n\t\t\t);\n\t\t}","contract":"Gravity","time":0},{"type":"immutable-restrict-modification ","before":"n\n\tuint256 public state_powerThresho","after":"n\n\tuint256 public state_powerThresho","contract":"Gravity","time":1}]}