{"time":78,"results":[{"type":"struct-data-arrangement ","before":"\n   bool isFarm\n   uint256 toke\n   address tokenAddr","after":"   uint256 toke\n   address tokenAddr\n   bool isFarm\n","contract":"NFT721Farming","time":0},{"type":"external-function ","before":"   function depositBatch(address tokenAddress, uint256[] memory tokenId) public {\n         _depositBatch(msg.sender, tokenAddress, tokenId);\n  ","after":"   function depositBatch(address tokenAddress, uint256[] calldata tokenId) public {\n         _depositBatch(msg.sender, tokenAddress, tokenId);\n  ","contract":"NFT721Farming","time":0},{"type":"external-function ","before":"   function harvest(\n        uint256 _amount, \n        uint256 _lastBlockNumber, \n        uint256 _currentBlockNumber, \n        bytes32 _msgForSign, \n        bytes memory _signature\n    ) public \n    {\n        require(_currentBlockNumber <= block.number, \"currentBlockNumber cannot be larger than the last block\");\n\n        //Double spend check\n        require(getLastBlock(msg.sender) == _lastBlockNumber, \"lastBlockNumber must be equal to the value in the storage\");\n\n        //1. Lets check signer\n        address signedBy = _msgForSign.recover(_signature);\n        require(trustedSigner[signedBy] == true, \"Signature check failed!\");\n\n        //2. Check signed msg integrety\n        bytes32 actualMsg = getMsgForSign(\n            _amount,\n            _lastBlockNumber,\n            _currentBlockNumber,\n            msg.sender\n        );\n        require(actualMsg.toEthSignedMessageHash() == _msgForSign,\"Integrety check failed!\");\n\n        //Actions\n\n        userRewardInfo[msg.sender].rewardDebt += _amount;\n        userRewardInfo[msg.sender].lastBlock = _currentBlockNumber;\n        if (_amount > 0) {\n            IERC20 ERC20Token = IERC20(NFTS);\n            ERC20Token.transfer(msg.sender, _amount);\n        }\n        emit Harvest(msg.sender, _amount, _lastBlockNumber, _currentBlockNumber);\n  ","after":"   function harvest(\n        uint256 _amount, \n        uint256 _lastBlockNumber, \n        uint256 _currentBlockNumber, \n        bytes32 _msgForSign, \n        bytes calldata _signature\n    ) public \n    {\n        require(_currentBlockNumber <= block.number, \"currentBlockNumber cannot be larger than the last block\");\n\n        //Double spend check\n        require(getLastBlock(msg.sender) == _lastBlockNumber, \"lastBlockNumber must be equal to the value in the storage\");\n\n        //1. Lets check signer\n        address signedBy = _msgForSign.recover(_signature);\n        require(trustedSigner[signedBy] == true, \"Signature check failed!\");\n\n        //2. Check signed msg integrety\n        bytes32 actualMsg = getMsgForSign(\n            _amount,\n            _lastBlockNumber,\n            _currentBlockNumber,\n            msg.sender\n        );\n        require(actualMsg.toEthSignedMessageHash() == _msgForSign,\"Integrety check failed!\");\n\n        //Actions\n\n        userRewardInfo[msg.sender].rewardDebt += _amount;\n        userRewardInfo[msg.sender].lastBlock = _currentBlockNumber;\n        if (_amount > 0) {\n            IERC20 ERC20Token = IERC20(NFTS);\n            ERC20Token.transfer(msg.sender, _amount);\n        }\n        emit Harvest(msg.sender, _amount, _lastBlockNumber, _currentBlockNumber);\n  ","contract":"NFT721Farming","time":0},{"type":"immutable-restrict-modification ","before":"   address public NF","after":"   address public NF","contract":"NFT721Farming","time":1},{"type":"immutable-restrict-modification ","before":"   address public heroesUpgrad","after":"   address public heroesUpgrad","contract":"NFT721Farming","time":1}]}