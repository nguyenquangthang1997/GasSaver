{"time":249,"results":[{"type":"state-data-arrangement ","before":"\naddress public WETH;\naddress public feeCollector;\naddress public lockProxyAddress;\naddress public managerProxyContract;\nbytes public swapProxyHash;\nuint64 public swapChainId;\nuint64 public chainId;\nmapping(bytes => mapping(uint64 => bool)) public assetInPool;\nmapping(uint64 => address) public poolTokenMap;","after":"bytes public swapProxyHash;\nmapping(bytes => mapping(uint64 => bool)) public assetInPool;\nmapping(uint64 => address) public poolTokenMap;\naddress public WETH;\naddress public feeCollector;\naddress public lockProxyAddress;\naddress public managerProxyContract;\nuint64 public swapChainId;\nuint64 public chainId;\n","contract":"Swapper","time":1},{"type":"external-function ","before":"function setSwapProxyHash(bytes memory swapProxyAddr) onlyOwner public {\n        swapProxyHash = swapProxyAddr;\n    }","after":"function setSwapProxyHash(bytes calldata swapProxyAddr) onlyOwner public {\n        swapProxyHash = swapProxyAddr;\n    }","contract":"Swapper","time":0},{"type":"external-function ","before":"function bindAssetAndPool(bytes memory fromAssetHash, uint64 poolId) onlyOwner public returns (bool) {\n        assetInPool[fromAssetHash][poolId] = true;\n        return true;\n    }","after":"function bindAssetAndPool(bytes calldata fromAssetHash, uint64 poolId) onlyOwner public returns (bool) {\n        assetInPool[fromAssetHash][poolId] = true;\n        return true;\n    }","contract":"Swapper","time":0},{"type":"external-function ","before":"function bind3Asset(bytes memory asset1, bytes memory asset2, bytes memory asset3, uint64 poolId) onlyOwner public {\n        assetInPool[asset1][poolId] = true;\n        assetInPool[asset2][poolId] = true;\n        assetInPool[asset3][poolId] = true;\n    }","after":"function bind3Asset(bytes calldata asset1, bytes calldata asset2, bytes calldata asset3, uint64 poolId) onlyOwner public {\n        assetInPool[asset1][poolId] = true;\n        assetInPool[asset2][poolId] = true;\n        assetInPool[asset3][poolId] = true;\n    }","contract":"Swapper","time":0},{"type":"external-function ","before":"function registerPoolWith3Assets(uint64 poolId, address poolTokenAddress, bytes memory asset1, bytes memory asset2, bytes memory asset3) onlyOwner public {\n        poolTokenMap[poolId] = poolTokenAddress;\n        assetInPool[asset1][poolId] = true;\n        assetInPool[asset2][poolId] = true;\n        assetInPool[asset3][poolId] = true;\n    }","after":"function registerPoolWith3Assets(uint64 poolId, address poolTokenAddress, bytes calldata asset1, bytes calldata asset2, bytes calldata asset3) onlyOwner public {\n        poolTokenMap[poolId] = poolTokenAddress;\n        assetInPool[asset1][poolId] = true;\n        assetInPool[asset2][poolId] = true;\n        assetInPool[asset3][poolId] = true;\n    }","contract":"Swapper","time":0},{"type":"external-function ","before":"function swap(address fromAssetHash, uint64 toPoolId, uint64 toChainId, bytes memory toAssetHash, bytes memory toAddress, uint amount, uint minOutAmount, uint fee, uint id) public payable nonReentrant whenNotPaused returns (bool) {\n        _pull(fromAssetHash, amount);\n    \n        amount = _checkoutFee(fromAssetHash, amount, fee);\n        \n        _push(fromAssetHash, amount);\n\n        fromAssetHash = fromAssetHash==address(0) ? WETH : fromAssetHash ; \n        require(poolTokenMap[toPoolId] != address(0), \"given pool do not exsit\");\n        require(assetInPool[Utils.addressToBytes(fromAssetHash)][toPoolId],\"input token not in given pool\");\n        require(assetInPool[toAssetHash][toPoolId],\"output token not in given pool\");\n        require(toAddress.length !=0, \"empty toAddress\");\n        address addr;\n        assembly { addr := mload(add(toAddress,0x14)) }\n        require(addr != address(0),\"zero toAddress\");\n         \n        {\n            TxArgs memory txArgs = TxArgs({\n                amount: amount,\n                minOut: minOutAmount,\n                toPoolId: toPoolId,\n                toChainId: toChainId,\n                fromAssetHash: Utils.addressToBytes(fromAssetHash),\n                fromAddress: Utils.addressToBytes(_msgSender()),\n                toAssetHash: toAssetHash,\n                toAddress: toAddress\n            });\n            bytes memory txData = _serializeTxArgs(txArgs);\n            \n            address eccmAddr = IEthCrossChainManagerProxy(managerProxyContract).getEthCrossChainManager();\n            IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\n            \n            require(eccm.crossChain(swapChainId, swapProxyHash, \"swap\", txData), \"EthCrossChainManager crossChain executed error!\");\n        }\n        \n        emit LockEvent(fromAssetHash, _msgSender(), swapChainId, Utils.addressToBytes(address(0)), swapProxyHash, amount);\n        emit SwapEvent(fromAssetHash, _msgSender(), toPoolId, toChainId, toAssetHash, toAddress, amount, fee, id);\n        \n        return true;\n    }","after":"function swap(address fromAssetHash, uint64 toPoolId, uint64 toChainId, bytes calldata toAssetHash, bytes calldata toAddress, uint amount, uint minOutAmount, uint fee, uint id) public payable nonReentrant whenNotPaused returns (bool) {\n        _pull(fromAssetHash, amount);\n    \n        amount = _checkoutFee(fromAssetHash, amount, fee);\n        \n        _push(fromAssetHash, amount);\n\n        fromAssetHash = fromAssetHash==address(0) ? WETH : fromAssetHash ; \n        require(poolTokenMap[toPoolId] != address(0), \"given pool do not exsit\");\n        require(assetInPool[Utils.addressToBytes(fromAssetHash)][toPoolId],\"input token not in given pool\");\n        require(assetInPool[toAssetHash][toPoolId],\"output token not in given pool\");\n        require(toAddress.length !=0, \"empty toAddress\");\n        address addr;\n        assembly { addr := mload(add(toAddress,0x14)) }\n        require(addr != address(0),\"zero toAddress\");\n         \n        {\n            TxArgs memory txArgs = TxArgs({\n                amount: amount,\n                minOut: minOutAmount,\n                toPoolId: toPoolId,\n                toChainId: toChainId,\n                fromAssetHash: Utils.addressToBytes(fromAssetHash),\n                fromAddress: Utils.addressToBytes(_msgSender()),\n                toAssetHash: toAssetHash,\n                toAddress: toAddress\n            });\n            bytes memory txData = _serializeTxArgs(txArgs);\n            \n            address eccmAddr = IEthCrossChainManagerProxy(managerProxyContract).getEthCrossChainManager();\n            IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\n            \n            require(eccm.crossChain(swapChainId, swapProxyHash, \"swap\", txData), \"EthCrossChainManager crossChain executed error!\");\n        }\n        \n        emit LockEvent(fromAssetHash, _msgSender(), swapChainId, Utils.addressToBytes(address(0)), swapProxyHash, amount);\n        emit SwapEvent(fromAssetHash, _msgSender(), toPoolId, toChainId, toAssetHash, toAddress, amount, fee, id);\n        \n        return true;\n    }","contract":"Swapper","time":0},{"type":"external-function ","before":"function add_liquidity(address fromAssetHash, uint64 toPoolId, uint64 toChainId, bytes memory toAddress, uint amount, uint minOutAmount, uint fee, uint id) public payable nonReentrant whenNotPaused returns (bool) {\n        _pull(fromAssetHash, amount);\n            \n        amount = _checkoutFee(fromAssetHash, amount, fee);\n        \n        _push(fromAssetHash, amount);\n\n        fromAssetHash = fromAssetHash==address(0) ? WETH : fromAssetHash ;   \n        require(poolTokenMap[toPoolId] != address(0), \"given pool do not exsit\");\n        require(assetInPool[Utils.addressToBytes(fromAssetHash)][toPoolId],\"input token not in given pool\");\n        require(toAddress.length !=0, \"empty toAddress\");\n        address addr;\n        assembly { addr := mload(add(toAddress,0x14)) }\n        require(addr != address(0),\"zero toAddress\");\n        \n        {\n            TxArgs memory txArgs = TxArgs({\n                amount: amount,\n                minOut: minOutAmount,\n                toPoolId: toPoolId,\n                toChainId: toChainId,\n                fromAssetHash: Utils.addressToBytes(fromAssetHash),\n                fromAddress: Utils.addressToBytes(_msgSender()),\n                toAssetHash: Utils.addressToBytes(address(0)),\n                toAddress: toAddress\n            });\n            bytes memory txData = _serializeTxArgs(txArgs);\n            \n            address eccmAddr = IEthCrossChainManagerProxy(managerProxyContract).getEthCrossChainManager();\n            IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\n            \n            require(eccm.crossChain(swapChainId, swapProxyHash, \"add\", txData), \"EthCrossChainManager crossChain executed error!\");\n        }\n\n        emit LockEvent(fromAssetHash, _msgSender(), swapChainId, Utils.addressToBytes(address(0)), swapProxyHash, amount);\n        emit AddLiquidityEvent(fromAssetHash, _msgSender(), toPoolId, toChainId, Utils.addressToBytes(address(0)), toAddress, amount, fee, id);\n        \n        return true;\n    }","after":"function add_liquidity(address fromAssetHash, uint64 toPoolId, uint64 toChainId, bytes calldata toAddress, uint amount, uint minOutAmount, uint fee, uint id) public payable nonReentrant whenNotPaused returns (bool) {\n        _pull(fromAssetHash, amount);\n            \n        amount = _checkoutFee(fromAssetHash, amount, fee);\n        \n        _push(fromAssetHash, amount);\n\n        fromAssetHash = fromAssetHash==address(0) ? WETH : fromAssetHash ;   \n        require(poolTokenMap[toPoolId] != address(0), \"given pool do not exsit\");\n        require(assetInPool[Utils.addressToBytes(fromAssetHash)][toPoolId],\"input token not in given pool\");\n        require(toAddress.length !=0, \"empty toAddress\");\n        address addr;\n        assembly { addr := mload(add(toAddress,0x14)) }\n        require(addr != address(0),\"zero toAddress\");\n        \n        {\n            TxArgs memory txArgs = TxArgs({\n                amount: amount,\n                minOut: minOutAmount,\n                toPoolId: toPoolId,\n                toChainId: toChainId,\n                fromAssetHash: Utils.addressToBytes(fromAssetHash),\n                fromAddress: Utils.addressToBytes(_msgSender()),\n                toAssetHash: Utils.addressToBytes(address(0)),\n                toAddress: toAddress\n            });\n            bytes memory txData = _serializeTxArgs(txArgs);\n            \n            address eccmAddr = IEthCrossChainManagerProxy(managerProxyContract).getEthCrossChainManager();\n            IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\n            \n            require(eccm.crossChain(swapChainId, swapProxyHash, \"add\", txData), \"EthCrossChainManager crossChain executed error!\");\n        }\n\n        emit LockEvent(fromAssetHash, _msgSender(), swapChainId, Utils.addressToBytes(address(0)), swapProxyHash, amount);\n        emit AddLiquidityEvent(fromAssetHash, _msgSender(), toPoolId, toChainId, Utils.addressToBytes(address(0)), toAddress, amount, fee, id);\n        \n        return true;\n    }","contract":"Swapper","time":0},{"type":"external-function ","before":"function remove_liquidity(address fromAssetHash, uint64 toPoolId, uint64 toChainId, bytes memory toAssetHash, bytes memory toAddress, uint amount, uint minOutAmount, uint fee, uint id) public payable nonReentrant whenNotPaused returns (bool) {\n        _pull(fromAssetHash, amount);\n    \n        amount = _checkoutFee(fromAssetHash, amount, fee);\n        \n        _push(fromAssetHash, amount);\n            \n        fromAssetHash = fromAssetHash==address(0) ? WETH : fromAssetHash ; \n        require(poolTokenMap[toPoolId] != address(0), \"given pool do not exsit\");\n        require(poolTokenMap[toPoolId] == fromAssetHash,\"input token is not pool LP token\");\n        require(assetInPool[toAssetHash][toPoolId],\"output token not in given pool\");\n        require(toAddress.length !=0, \"empty toAddress\");\n        address addr;\n        assembly { addr := mload(add(toAddress,0x14)) }\n        require(addr != address(0),\"zero toAddress\");\n        \n        {\n            TxArgs memory txArgs = TxArgs({\n                amount: amount,\n                minOut: minOutAmount,\n                toPoolId: toPoolId,\n                toChainId: toChainId,\n                fromAssetHash: Utils.addressToBytes(fromAssetHash),\n                fromAddress: Utils.addressToBytes(_msgSender()),\n                toAssetHash: toAssetHash,\n                toAddress: toAddress\n            });\n            bytes memory txData = _serializeTxArgs(txArgs);\n            \n            address eccmAddr = IEthCrossChainManagerProxy(managerProxyContract).getEthCrossChainManager();\n            IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\n            \n            require(eccm.crossChain(swapChainId, swapProxyHash, \"remove\", txData), \"EthCrossChainManager crossChain executed error!\");\n        }\n        \n        emit LockEvent(fromAssetHash, _msgSender(), swapChainId, Utils.addressToBytes(address(0)), swapProxyHash, amount);\n        emit RemoveLiquidityEvent(fromAssetHash, _msgSender(), toPoolId, toChainId, toAssetHash, toAddress, amount, fee, id);\n        \n        return true;\n    }","after":"function remove_liquidity(address fromAssetHash, uint64 toPoolId, uint64 toChainId, bytes calldata toAssetHash, bytes calldata toAddress, uint amount, uint minOutAmount, uint fee, uint id) public payable nonReentrant whenNotPaused returns (bool) {\n        _pull(fromAssetHash, amount);\n    \n        amount = _checkoutFee(fromAssetHash, amount, fee);\n        \n        _push(fromAssetHash, amount);\n            \n        fromAssetHash = fromAssetHash==address(0) ? WETH : fromAssetHash ; \n        require(poolTokenMap[toPoolId] != address(0), \"given pool do not exsit\");\n        require(poolTokenMap[toPoolId] == fromAssetHash,\"input token is not pool LP token\");\n        require(assetInPool[toAssetHash][toPoolId],\"output token not in given pool\");\n        require(toAddress.length !=0, \"empty toAddress\");\n        address addr;\n        assembly { addr := mload(add(toAddress,0x14)) }\n        require(addr != address(0),\"zero toAddress\");\n        \n        {\n            TxArgs memory txArgs = TxArgs({\n                amount: amount,\n                minOut: minOutAmount,\n                toPoolId: toPoolId,\n                toChainId: toChainId,\n                fromAssetHash: Utils.addressToBytes(fromAssetHash),\n                fromAddress: Utils.addressToBytes(_msgSender()),\n                toAssetHash: toAssetHash,\n                toAddress: toAddress\n            });\n            bytes memory txData = _serializeTxArgs(txArgs);\n            \n            address eccmAddr = IEthCrossChainManagerProxy(managerProxyContract).getEthCrossChainManager();\n            IEthCrossChainManager eccm = IEthCrossChainManager(eccmAddr);\n            \n            require(eccm.crossChain(swapChainId, swapProxyHash, \"remove\", txData), \"EthCrossChainManager crossChain executed error!\");\n        }\n        \n        emit LockEvent(fromAssetHash, _msgSender(), swapChainId, Utils.addressToBytes(address(0)), swapProxyHash, amount);\n        emit RemoveLiquidityEvent(fromAssetHash, _msgSender(), toPoolId, toChainId, toAssetHash, toAddress, amount, fee, id);\n        \n        return true;\n    }","contract":"Swapper","time":0}]}