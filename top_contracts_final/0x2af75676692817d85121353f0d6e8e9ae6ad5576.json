{"time":270,"results":[{"type":"external-function ","before":"function batchMint(address[] memory to, uint256[] memory ids, bytes32[] memory uris, uint256[] memory values, bool safe) public onlyMinter {\n        require(ids.length == to.length &&\n            ids.length == uris.length &&\n            ids.length == values.length);\n\n        for (uint i = 0; i < ids.length; i++) {\n            if (isNFT(ids[i]) && values[i] == 1) {\n                _mintNonFungible(to[i], ids[i], uris[i], safe);\n            } else if (isFungible(ids[i]) && uint256(uris[i]) == 0) {\n                _mintFungible(to[i], ids[i], values[i]);\n            } else {\n                revert();\n            }\n        }\n    }","after":"function batchMint(address[] calldata to, uint256[] calldata ids, bytes32[] calldata uris, uint256[] calldata values, bool safe) public onlyMinter {\n        require(ids.length == to.length &&\n            ids.length == uris.length &&\n            ids.length == values.length);\n\n        for (uint i = 0; i < ids.length; i++) {\n            if (isNFT(ids[i]) && values[i] == 1) {\n                _mintNonFungible(to[i], ids[i], uris[i], safe);\n            } else if (isFungible(ids[i]) && uint256(uris[i]) == 0) {\n                _mintFungible(to[i], ids[i], values[i]);\n            } else {\n                revert();\n            }\n        }\n    }","contract":"DeltaTimeInventory","time":0},{"type":"external-function ","before":"function pauseCollections(uint256[] memory collectionIds) public onlyPauser {\n        for (uint256 i=0; i<collectionIds.length; i++) {\n            uint256 collectionId = collectionIds[i];\n            require(!isNFT(collectionId)); // only works on collections\n            _pausedCollections[collectionId] = true;\n        }\n        emit CollectionsPaused(collectionIds, _msgSender());\n    }","after":"function pauseCollections(uint256[] calldata collectionIds) public onlyPauser {\n        for (uint256 i=0; i<collectionIds.length; i++) {\n            uint256 collectionId = collectionIds[i];\n            require(!isNFT(collectionId)); // only works on collections\n            _pausedCollections[collectionId] = true;\n        }\n        emit CollectionsPaused(collectionIds, _msgSender());\n    }","contract":"DeltaTimeInventory","time":0},{"type":"external-function ","before":"function unpauseCollections(uint256[] memory collectionIds) public onlyPauser {\n        for (uint256 i=0; i<collectionIds.length; i++) {\n            uint256 collectionId = collectionIds[i];\n            require(!isNFT(collectionId)); // only works on collections\n            _pausedCollections[collectionId] = false;\n        }\n        emit CollectionsUnpaused(collectionIds, _msgSender());\n    }","after":"function unpauseCollections(uint256[] calldata collectionIds) public onlyPauser {\n        for (uint256 i=0; i<collectionIds.length; i++) {\n            uint256 collectionId = collectionIds[i];\n            require(!isNFT(collectionId)); // only works on collections\n            _pausedCollections[collectionId] = false;\n        }\n        emit CollectionsUnpaused(collectionIds, _msgSender());\n    }","contract":"DeltaTimeInventory","time":0},{"type":"external-function ","before":"function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data\n    ) public whenNotPaused whenIdNotPaused(tokenId) {\n        super.safeTransferFrom(from, to, tokenId, data);\n    }","after":"function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data\n    ) public whenNotPaused whenIdNotPaused(tokenId) {\n        super.safeTransferFrom(from, to, tokenId, data);\n    }","contract":"DeltaTimeInventory","time":0},{"type":"external-function ","before":"function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes memory data\n    ) public whenNotPaused whenIdNotPaused(id) {\n        super.safeTransferFrom(from, to, id, value, data);\n    }","after":"function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data\n    ) public whenNotPaused whenIdNotPaused(id) {\n        super.safeTransferFrom(from, to, id, value, data);\n    }","contract":"DeltaTimeInventory","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(address from, address to, uint256[] memory ids, uint256[] memory values, bytes memory data\n    ) public whenNotPaused {\n        for (uint256 i = 0; i < ids.length; ++i) {\n            require(!idPaused(ids[i]));\n        }\n        super.safeBatchTransferFrom(from, to, ids, values, data);\n    }","after":"function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata values, bytes calldata data\n    ) public whenNotPaused {\n        for (uint256 i = 0; i < ids.length; ++i) {\n            require(!idPaused(ids[i]));\n        }\n        super.safeBatchTransferFrom(from, to, ids, values, data);\n    }","contract":"DeltaTimeInventory","time":0},{"type":"external-function ","before":"function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {\n        _transferFrom(from, to, tokenId, data, true);\n    }","after":"function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) public {\n        _transferFrom(from, to, tokenId, data, true);\n    }","contract":"DeltaTimeInventory","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) public\n    {\n        require(to != address(0x0));\n\n        address sender = _msgSender();\n        bool operatable = (from == sender || _operatorApprovals[from][sender] == true);\n\n        if (isFungible(id) && value > 0) {\n            require(operatable);\n            _transferFungible(from, to, id, value);\n        } else if (isNFT(id) && value == 1) {\n            _transferNonFungible(from, to, id, operatable);\n            emit Transfer(from, to, id);\n        } else {\n            revert();\n        }\n\n        emit TransferSingle(sender, from, to, id, value);\n        require(_checkERC1155AndCallSafeTransfer(sender, from, to, id, value, data, false, false));\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) public\n    {\n        require(to != address(0x0));\n\n        address sender = _msgSender();\n        bool operatable = (from == sender || _operatorApprovals[from][sender] == true);\n\n        if (isFungible(id) && value > 0) {\n            require(operatable);\n            _transferFungible(from, to, id, value);\n        } else if (isNFT(id) && value == 1) {\n            _transferNonFungible(from, to, id, operatable);\n            emit Transfer(from, to, id);\n        } else {\n            revert();\n        }\n\n        emit TransferSingle(sender, from, to, id, value);\n        require(_checkERC1155AndCallSafeTransfer(sender, from, to, id, value, data, false, false));\n    }","contract":"DeltaTimeInventory","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public\n    {\n        require(to != address(0x0));\n        require(ids.length == values.length);\n\n        // Only supporting a global operator approval allows to do a single check and not to touch storage to handle allowances.\n        address sender = _msgSender();\n        require(from == sender || _operatorApprovals[from][sender] == true);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 value = values[i];\n\n            if (isFungible(id) && value > 0) {\n                _transferFungible(from, to, id, value);\n            } else if (isNFT(id) && value == 1) {\n                _transferNonFungible(from, to, id, true);\n                emit Transfer(from, to, id);\n            } else {\n                revert();\n            }\n        }\n\n        emit TransferBatch(sender, from, to, ids, values);\n        require(_checkERC1155AndCallSafeBatchTransfer(sender, from, to, ids, values, data));\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) public\n    {\n        require(to != address(0x0));\n        require(ids.length == values.length);\n\n        // Only supporting a global operator approval allows to do a single check and not to touch storage to handle allowances.\n        address sender = _msgSender();\n        require(from == sender || _operatorApprovals[from][sender] == true);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 value = values[i];\n\n            if (isFungible(id) && value > 0) {\n                _transferFungible(from, to, id, value);\n            } else if (isNFT(id) && value == 1) {\n                _transferNonFungible(from, to, id, true);\n                emit Transfer(from, to, id);\n            } else {\n                revert();\n            }\n        }\n\n        emit TransferBatch(sender, from, to, ids, values);\n        require(_checkERC1155AndCallSafeBatchTransfer(sender, from, to, ids, values, data));\n    }","contract":"DeltaTimeInventory","time":0}]}