{"time":205,"results":[{"type":"de-morgan-condition ","before":"   !(char >= 0x30 && char <= 0x39) && //9-0\n                !(char >= 0x41 && char <= 0x","after":"!(   (char >= 0x30 && char <= 0x39) && //9-0\n                (char >= 0x41 && char <= 0x)","loc":{"start":{"line":2171,"column":16},"end":{"line":2172,"column":46}},"contract":"PixelPugs","time":0},{"type":"external-function ","before":"   function changeName(uint256 tokenId, string memory newName) external nonReentrant {\n        address owner = ownerOf(tokenId);\n        require(address(yieldToken) != address(0), \"Yieldtoken not set\");\n        require(yieldToken.balanceOf(_msgSender()) >= nameChangePrice, \"Not enough tokens in wallet\");\n        require(_msgSender() == owner, \"ERC721: caller is not the owner\");\n        require(validateName(newName, 25) == true, \"Not a valid new name\");\n        require(sha256(bytes(newName)) != sha256(bytes(_tokenName[tokenId])), \"New name is same as the current one\");\n        require(isNameReserved(newName) == false, \"Name already reserved\");\n        \n        yieldToken.transferFrom(msg.sender, address(this), nameChangePrice);\n        // If already named, dereserve old name\n        if (bytes(_tokenName[tokenId]).length > 0) {\n            toggleReserveName(_tokenName[tokenId], false);\n        }\n        toggleReserveName(newName, true);\n        _tokenName[tokenId] = newName;\n        emit NameChange(tokenId, newName);\n  ","after":"   function changeName(uint256 tokenId, string calldata newName) external nonReentrant {\n        address owner = ownerOf(tokenId);\n        require(address(yieldToken) != address(0), \"Yieldtoken not set\");\n        require(yieldToken.balanceOf(_msgSender()) >= nameChangePrice, \"Not enough tokens in wallet\");\n        require(_msgSender() == owner, \"ERC721: caller is not the owner\");\n        require(validateName(newName, 25) == true, \"Not a valid new name\");\n        require(sha256(bytes(newName)) != sha256(bytes(_tokenName[tokenId])), \"New name is same as the current one\");\n        require(isNameReserved(newName) == false, \"Name already reserved\");\n        \n        yieldToken.transferFrom(msg.sender, address(this), nameChangePrice);\n        // If already named, dereserve old name\n        if (bytes(_tokenName[tokenId]).length > 0) {\n            toggleReserveName(_tokenName[tokenId], false);\n        }\n        toggleReserveName(newName, true);\n        _tokenName[tokenId] = newName;\n        emit NameChange(tokenId, newName);\n  ","contract":"PixelPugs","time":0},{"type":"external-function ","before":"   function changeBio(uint256 tokenId, string memory bio) external nonReentrant {\n\t\taddress owner = ownerOf(tokenId);\n\t\trequire(address(yieldToken) != address(0), \"Yieldtoken not set\");\n\t\trequire(yieldToken.balanceOf(_msgSender()) >= bioChangePrice, \"Not enough tokens in wallet\");\n\t\trequire(_msgSender() == owner, \"ERC721: caller is not the owner\");\n\t\trequire(validateName(bio, 280) == true, \"Not a valid bio\");\n        \n        yieldToken.transferFrom(msg.sender, address(this), bioChangePrice);\n        \n\t\t_bio[tokenId] = bio;\n\t\temit BioChange(tokenId, bio);","after":"   function changeBio(uint256 tokenId, string calldata bio) external nonReentrant {\n\t\taddress owner = ownerOf(tokenId);\n\t\trequire(address(yieldToken) != address(0), \"Yieldtoken not set\");\n\t\trequire(yieldToken.balanceOf(_msgSender()) >= bioChangePrice, \"Not enough tokens in wallet\");\n\t\trequire(_msgSender() == owner, \"ERC721: caller is not the owner\");\n\t\trequire(validateName(bio, 280) == true, \"Not a valid bio\");\n        \n        yieldToken.transferFrom(msg.sender, address(this), bioChangePrice);\n        \n\t\t_bio[tokenId] = bio;\n\t\temit BioChange(tokenId, bio);","contract":"PixelPugs","time":0},{"type":"external-function ","before":"   function presaleMint(bytes memory sig, uint256 numberOfMints) external payable nonReentrant {\n        uint256 supply = totalSupply();\n        uint256 claimed = presaleClaimed[msg.sender];\n\n        require(presaleActive, \"Presale must be active to mint\");\n        require(isValidSignature(msg.sender, sig), \"Account is not authorized for presale\");\n        require(numberOfMints <= maxMintPerAccount - claimed, \"Amount exceeds mintable limit\");\n        require(numberOfMints > 0, \"The minimum number of mints is 1\");\n        require(supply.add(numberOfMints) <= MAX_SUPPLY, \"Further minting would exceed max supply\");\n        require(price.mul(numberOfMints) == msg.value, \"Ether value sent is not correct\");\n        require(address(this).balance >= msg.value, \"Insufficient balance to mint\");\n\n        presaleClaimed[msg.sender] = claimed + numberOfMints;\n\n        for (uint256 i; i < numberOfMints; i++) {\n            uint256 tokenId = supply + i;\n            emit Mint(msg.sender, tokenId);\n            _safeMint(msg.sender, tokenId);\n            PugType pugType = PugType(0);\n            tokenIdToPugType[tokenId] = pugType;\n        }\n  ","after":"   function presaleMint(bytes calldata sig, uint256 numberOfMints) external payable nonReentrant {\n        uint256 supply = totalSupply();\n        uint256 claimed = presaleClaimed[msg.sender];\n\n        require(presaleActive, \"Presale must be active to mint\");\n        require(isValidSignature(msg.sender, sig), \"Account is not authorized for presale\");\n        require(numberOfMints <= maxMintPerAccount - claimed, \"Amount exceeds mintable limit\");\n        require(numberOfMints > 0, \"The minimum number of mints is 1\");\n        require(supply.add(numberOfMints) <= MAX_SUPPLY, \"Further minting would exceed max supply\");\n        require(price.mul(numberOfMints) == msg.value, \"Ether value sent is not correct\");\n        require(address(this).balance >= msg.value, \"Insufficient balance to mint\");\n\n        presaleClaimed[msg.sender] = claimed + numberOfMints;\n\n        for (uint256 i; i < numberOfMints; i++) {\n            uint256 tokenId = supply + i;\n            emit Mint(msg.sender, tokenId);\n            _safeMint(msg.sender, tokenId);\n            PugType pugType = PugType(0);\n            tokenIdToPugType[tokenId] = pugType;\n        }\n  ","contract":"PixelPugs","time":0},{"type":"external-function ","before":"   function setBaseURI(string memory uri) public onlyOwner {\n        baseURI = uri;\n  ","after":"   function setBaseURI(string calldata uri) public onlyOwner {\n        baseURI = uri;\n  ","contract":"PixelPugs","time":0}]}