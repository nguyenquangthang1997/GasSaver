{"time":230,"results":[{"type":"external-function ","before":"function appendStateBatch(bytes32[] memory _batch, uint256 _shouldStartAtElement) public {\n        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\n        // publication of batches by some other user.\n        require(\n            _shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );\n\n        // Proposers must have previously staked at the BondManager\n        require(\n            IBondManager(resolve(\"BondManager\")).isCollateralized(msg.sender),\n            \"Proposer does not have enough collateral posted\"\n        );\n\n        require(_batch.length > 0, \"Cannot submit an empty state batch.\");\n\n        require(\n            getTotalElements() + _batch.length <=\n                ICanonicalTransactionChain(resolve(\"CanonicalTransactionChain\")).getTotalElements(),\n            \"Number of state roots cannot exceed the number of canonical transactions.\"\n        );\n\n        // Pass the block's timestamp and the publisher of the data\n        // to be used in the fraud proofs\n        _appendBatch(_batch, abi.encode(block.timestamp, msg.sender));\n    }","after":"function appendStateBatch(bytes32[] calldata _batch, uint256 _shouldStartAtElement) public {\n        // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\n        // publication of batches by some other user.\n        require(\n            _shouldStartAtElement == getTotalElements(),\n            \"Actual batch start index does not match expected start index.\"\n        );\n\n        // Proposers must have previously staked at the BondManager\n        require(\n            IBondManager(resolve(\"BondManager\")).isCollateralized(msg.sender),\n            \"Proposer does not have enough collateral posted\"\n        );\n\n        require(_batch.length > 0, \"Cannot submit an empty state batch.\");\n\n        require(\n            getTotalElements() + _batch.length <=\n                ICanonicalTransactionChain(resolve(\"CanonicalTransactionChain\")).getTotalElements(),\n            \"Number of state roots cannot exceed the number of canonical transactions.\"\n        );\n\n        // Pass the block's timestamp and the publisher of the data\n        // to be used in the fraud proofs\n        _appendBatch(_batch, abi.encode(block.timestamp, msg.sender));\n    }","contract":"StateCommitmentChain","time":0},{"type":"external-function ","before":"function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader) public {\n        require(\n            msg.sender == resolve(\"OVM_FraudVerifier\"),\n            \"State batches can only be deleted by the OVM_FraudVerifier.\"\n        );\n\n        require(_isValidBatchHeader(_batchHeader), \"Invalid batch header.\");\n\n        require(\n            insideFraudProofWindow(_batchHeader),\n            \"State batches can only be deleted within the fraud proof window.\"\n        );\n\n        _deleteBatch(_batchHeader);\n    }","after":"function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader calldata _batchHeader) public {\n        require(\n            msg.sender == resolve(\"OVM_FraudVerifier\"),\n            \"State batches can only be deleted by the OVM_FraudVerifier.\"\n        );\n\n        require(_isValidBatchHeader(_batchHeader), \"Invalid batch header.\");\n\n        require(\n            insideFraudProofWindow(_batchHeader),\n            \"State batches can only be deleted within the fraud proof window.\"\n        );\n\n        _deleteBatch(_batchHeader);\n    }","contract":"StateCommitmentChain","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public FRAUD_PROOF_WINDOW;","after":"uint256 public immutable FRAUD_PROOF_WINDOW;","contract":"StateCommitmentChain","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public SEQUENCER_PUBLISH_WINDOW;","after":"uint256 public immutable SEQUENCER_PUBLISH_WINDOW;","contract":"StateCommitmentChain","time":0},{"type":"external-function ","before":"function setAddress(string memory _name, address _address) external onlyOwner {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(_name, _address, oldAddress);\n    }","after":"function setAddress(string calldata _name, address _address) external onlyOwner {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(_name, _address, oldAddress);\n    }","contract":"Lib_AddressManager","time":0}]}