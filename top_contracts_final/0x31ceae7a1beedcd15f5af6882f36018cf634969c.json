{"time":172,"results":[{"type":"external-function ","before":"function purchaseAllowList(uint256 numberOfTokens, uint256[] calldata factions, bytes32[] memory merkleProof) external payable {\n    require(isActive, 'Inactive');\n    require(block.timestamp < startTimes[3], 'Public sale started');\n\n    bytes32 root;\n    if (block.timestamp > startTimes[2]) {\n      root = roots[2];\n    } else if (block.timestamp > startTimes[1]) {\n      root = roots[1];\n    }  else if (block.timestamp > startTimes[0]) {\n      root = roots[0];\n    } else {\n      revert('Not started');\n    }\n\n    require(numberOfTokens == factions.length, 'Invalid params');\n    require(totalPublicSupply + numberOfTokens <= DEUSX_PUBLIC, 'Exceeds supply limit');\n    require(allowListClaimed[msg.sender] + numberOfTokens <= allowListMaxMint, 'Exceeds max allowed');\n    require(numberOfTokens * PRICE <= msg.value, 'Insufficient ETH'); \n\n    bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n\n    require(MerkleProof.verify(merkleProof, root, leaf), 'Invalid proof');\n\n    allowListClaimed[msg.sender] += numberOfTokens;\n\n    for (uint256 i = 0; i < numberOfTokens; i++) {\n\n      /*\n      * Public token numbering starts after DEUSX_GIFT.\n      * Tokens IDs start at 1.\n      */\n\n      totalPublicSupply += 1;\n      uint256 tokenId = DEUSX_GIFT + totalPublicSupply;\n\n      _safeMint(msg.sender, tokenId);\n\n      uint256 _faction = factions[i];\n      require(_faction < FACTION_NAMES.length, 'Invalid faction'); \n      factionOf[tokenId] = _faction;\n      factionNumbers[_faction] += 1;\n      emit SetFaction(tokenId, _faction);\n    }\n  }","after":"function purchaseAllowList(uint256 numberOfTokens, uint256[] calldata factions, bytes32[] calldata merkleProof) external payable {\n    require(isActive, 'Inactive');\n    require(block.timestamp < startTimes[3], 'Public sale started');\n\n    bytes32 root;\n    if (block.timestamp > startTimes[2]) {\n      root = roots[2];\n    } else if (block.timestamp > startTimes[1]) {\n      root = roots[1];\n    }  else if (block.timestamp > startTimes[0]) {\n      root = roots[0];\n    } else {\n      revert('Not started');\n    }\n\n    require(numberOfTokens == factions.length, 'Invalid params');\n    require(totalPublicSupply + numberOfTokens <= DEUSX_PUBLIC, 'Exceeds supply limit');\n    require(allowListClaimed[msg.sender] + numberOfTokens <= allowListMaxMint, 'Exceeds max allowed');\n    require(numberOfTokens * PRICE <= msg.value, 'Insufficient ETH'); \n\n    bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n\n    require(MerkleProof.verify(merkleProof, root, leaf), 'Invalid proof');\n\n    allowListClaimed[msg.sender] += numberOfTokens;\n\n    for (uint256 i = 0; i < numberOfTokens; i++) {\n\n      /*\n      * Public token numbering starts after DEUSX_GIFT.\n      * Tokens IDs start at 1.\n      */\n\n      totalPublicSupply += 1;\n      uint256 tokenId = DEUSX_GIFT + totalPublicSupply;\n\n      _safeMint(msg.sender, tokenId);\n\n      uint256 _faction = factions[i];\n      require(_faction < FACTION_NAMES.length, 'Invalid faction'); \n      factionOf[tokenId] = _faction;\n      factionNumbers[_faction] += 1;\n      emit SetFaction(tokenId, _faction);\n    }\n  }","contract":"DeusX","time":0},{"type":"external-function ","before":"function setProvenanceHash(string memory _provenanceHash) external onlyOwner {\n      provenanceHash = _provenanceHash;\n      emit SetProvenanceHash(_provenanceHash);\n  }","after":"function setProvenanceHash(string calldata _provenanceHash) external onlyOwner {\n      provenanceHash = _provenanceHash;\n      emit SetProvenanceHash(_provenanceHash);\n  }","contract":"DeusX","time":0}]}