{"time":109,"results":[{"type":"external-function ","before":"function init(address owner, address[] memory proxies) external {\n        initOwner(owner);\n        for(uint i = 0; i < proxies.length; i++) \n            _IS_ALLOWED_PROXY_[proxies[i]] = true;\n    }","after":"function init(address owner, address[] calldata proxies) external {\n        initOwner(owner);\n        for(uint i = 0; i < proxies.length; i++) \n            _IS_ALLOWED_PROXY_[proxies[i]] = true;\n    }","contract":"DODOApproveProxy","time":0},{"type":"external-function ","before":"function mixSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory mixAdapters,\n        address[] memory mixPairs,\n        address[] memory assetTo,\n        uint256 directions,\n        bytes[] memory moreInfos,\n        uint256 deadLine\n    ) external payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n        require(mixPairs.length > 0, \"DODORouteProxy: PAIRS_EMPTY\");\n        require(mixPairs.length == mixAdapters.length, \"DODORouteProxy: PAIR_ADAPTER_NOT_MATCH\");\n        require(mixPairs.length == assetTo.length - 1, \"DODORouteProxy: PAIR_ASSETTO_NOT_MATCH\");\n        require(minReturnAmount > 0, \"DODORouteProxy: RETURN_AMOUNT_ZERO\");\n\n        address _fromToken = fromToken;\n        address _toToken = toToken;\n        uint256 _fromTokenAmount = fromTokenAmount;\n        \n        uint256 toTokenOriginBalance = IERC20(_toToken).universalBalanceOf(msg.sender);\n        \n        _deposit(msg.sender, assetTo[0], _fromToken, _fromTokenAmount, _fromToken == _ETH_ADDRESS_);\n\n        for (uint256 i = 0; i < mixPairs.length; i++) {\n            if (directions & 1 == 0) {\n                IDODOAdapter(mixAdapters[i]).sellBase(assetTo[i + 1],mixPairs[i], moreInfos[i]);\n            } else {\n                IDODOAdapter(mixAdapters[i]).sellQuote(assetTo[i + 1],mixPairs[i], moreInfos[i]);\n            }\n            directions = directions >> 1;\n        }\n\n        if(_toToken == _ETH_ADDRESS_) {\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n            IWETH(_WETH_).withdraw(returnAmount);\n            msg.sender.transfer(returnAmount);\n        }else {\n            returnAmount = IERC20(_toToken).tokenBalanceOf(msg.sender).sub(toTokenOriginBalance);\n        }\n\n        require(returnAmount >= minReturnAmount, \"DODORouteProxy: Return amount is not enough\");\n\n        emit OrderHistory(\n            _fromToken,\n            _toToken,\n            msg.sender,\n            _fromTokenAmount,\n            returnAmount\n        );\n    }","after":"function mixSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] calldata mixAdapters,\n        address[] calldata mixPairs,\n        address[] calldata assetTo,\n        uint256 directions,\n        bytes[] calldata moreInfos,\n        uint256 deadLine\n    ) external payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n        require(mixPairs.length > 0, \"DODORouteProxy: PAIRS_EMPTY\");\n        require(mixPairs.length == mixAdapters.length, \"DODORouteProxy: PAIR_ADAPTER_NOT_MATCH\");\n        require(mixPairs.length == assetTo.length - 1, \"DODORouteProxy: PAIR_ASSETTO_NOT_MATCH\");\n        require(minReturnAmount > 0, \"DODORouteProxy: RETURN_AMOUNT_ZERO\");\n\n        address _fromToken = fromToken;\n        address _toToken = toToken;\n        uint256 _fromTokenAmount = fromTokenAmount;\n        \n        uint256 toTokenOriginBalance = IERC20(_toToken).universalBalanceOf(msg.sender);\n        \n        _deposit(msg.sender, assetTo[0], _fromToken, _fromTokenAmount, _fromToken == _ETH_ADDRESS_);\n\n        for (uint256 i = 0; i < mixPairs.length; i++) {\n            if (directions & 1 == 0) {\n                IDODOAdapter(mixAdapters[i]).sellBase(assetTo[i + 1],mixPairs[i], moreInfos[i]);\n            } else {\n                IDODOAdapter(mixAdapters[i]).sellQuote(assetTo[i + 1],mixPairs[i], moreInfos[i]);\n            }\n            directions = directions >> 1;\n        }\n\n        if(_toToken == _ETH_ADDRESS_) {\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n            IWETH(_WETH_).withdraw(returnAmount);\n            msg.sender.transfer(returnAmount);\n        }else {\n            returnAmount = IERC20(_toToken).tokenBalanceOf(msg.sender).sub(toTokenOriginBalance);\n        }\n\n        require(returnAmount >= minReturnAmount, \"DODORouteProxy: Return amount is not enough\");\n\n        emit OrderHistory(\n            _fromToken,\n            _toToken,\n            msg.sender,\n            _fromTokenAmount,\n            returnAmount\n        );\n    }","contract":"DODORouteProxy","time":0},{"type":"external-function ","before":"function dodoMutliSwap(\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        uint256[] memory totalWeight,\n        uint256[] memory splitNumber,\n        address[] memory midToken,\n        address[] memory assetFrom,\n        bytes[] memory sequence,\n        uint256 deadLine\n    ) external payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n        require(assetFrom.length == splitNumber.length, 'DODORouteProxy: PAIR_ASSETTO_NOT_MATCH');        \n        require(minReturnAmount > 0, \"DODORouteProxy: RETURN_AMOUNT_ZERO\");\n        \n        uint256 _fromTokenAmount = fromTokenAmount;\n        address fromToken = midToken[0];\n        address toToken = midToken[midToken.length - 1];\n\n        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);\n        _deposit(msg.sender, assetFrom[0], fromToken, _fromTokenAmount, fromToken == _ETH_ADDRESS_);\n\n        _multiSwap(totalWeight, midToken, splitNumber, sequence, assetFrom);\n    \n        if(toToken == _ETH_ADDRESS_) {\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n            IWETH(_WETH_).withdraw(returnAmount);\n            msg.sender.transfer(returnAmount);\n        }else {\n            returnAmount = IERC20(toToken).tokenBalanceOf(msg.sender).sub(toTokenOriginBalance);\n        }\n\n        require(returnAmount >= minReturnAmount, \"DODORouteProxy: Return amount is not enough\");\n    \n        emit OrderHistory(\n            fromToken,\n            toToken,\n            msg.sender,\n            _fromTokenAmount,\n            returnAmount\n        );    \n    }","after":"function dodoMutliSwap(\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        uint256[] calldata totalWeight,\n        uint256[] calldata splitNumber,\n        address[] calldata midToken,\n        address[] calldata assetFrom,\n        bytes[] calldata sequence,\n        uint256 deadLine\n    ) external payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n        require(assetFrom.length == splitNumber.length, 'DODORouteProxy: PAIR_ASSETTO_NOT_MATCH');        \n        require(minReturnAmount > 0, \"DODORouteProxy: RETURN_AMOUNT_ZERO\");\n        \n        uint256 _fromTokenAmount = fromTokenAmount;\n        address fromToken = midToken[0];\n        address toToken = midToken[midToken.length - 1];\n\n        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);\n        _deposit(msg.sender, assetFrom[0], fromToken, _fromTokenAmount, fromToken == _ETH_ADDRESS_);\n\n        _multiSwap(totalWeight, midToken, splitNumber, sequence, assetFrom);\n    \n        if(toToken == _ETH_ADDRESS_) {\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n            IWETH(_WETH_).withdraw(returnAmount);\n            msg.sender.transfer(returnAmount);\n        }else {\n            returnAmount = IERC20(toToken).tokenBalanceOf(msg.sender).sub(toTokenOriginBalance);\n        }\n\n        require(returnAmount >= minReturnAmount, \"DODORouteProxy: Return amount is not enough\");\n    \n        emit OrderHistory(\n            fromToken,\n            toToken,\n            msg.sender,\n            _fromTokenAmount,\n            returnAmount\n        );    \n    }","contract":"DODORouteProxy","time":0}]}