{"time":327,"results":[{"type":"external-function ","before":"function batchMint(address to, uint256[] memory nftIds) public virtual override {\n        require(isMinter(_msgSender()), \"Inventory: not a minter\");\n        _batchMint(to, nftIds);\n    }","after":"function batchMint(address to, uint256[] calldata nftIds) public virtual override {\n        require(isMinter(_msgSender()), \"Inventory: not a minter\");\n        _batchMint(to, nftIds);\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function safeMint(\n        address to,\n        uint256 nftId,\n        bytes memory data\n    ) public virtual override {\n        require(isMinter(_msgSender()), \"Inventory: not a minter\");\n        _mint(to, nftId, data, true);\n    }","after":"function safeMint(\n        address to,\n        uint256 nftId,\n        bytes calldata data\n    ) public virtual override {\n        require(isMinter(_msgSender()), \"Inventory: not a minter\");\n        _mint(to, nftId, data, true);\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function safeMint(\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) public virtual override {\n        require(isMinter(_msgSender()), \"Inventory: not a minter\");\n        _safeMint(to, id, value, data);\n    }","after":"function safeMint(\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) public virtual override {\n        require(isMinter(_msgSender()), \"Inventory: not a minter\");\n        _safeMint(to, id, value, data);\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function safeBatchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual override {\n        require(isMinter(_msgSender()), \"Inventory: not a minter\");\n        _safeBatchMint(to, ids, values, data);\n    }","after":"function safeBatchMint(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) public virtual override {\n        require(isMinter(_msgSender()), \"Inventory: not a minter\");\n        _safeBatchMint(to, ids, values, data);\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory nftIds\n    ) public virtual override {\n        require(!paused(), \"Inventory: paused\");\n        super.batchTransferFrom(from, to, nftIds);\n    }","after":"function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata nftIds\n    ) public virtual override {\n        require(!paused(), \"Inventory: paused\");\n        super.batchTransferFrom(from, to, nftIds);\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 nftId,\n        bytes memory data\n    ) public virtual override {\n        require(!paused(), \"Inventory: paused\");\n        super.safeTransferFrom(from, to, nftId, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 nftId,\n        bytes calldata data\n    ) public virtual override {\n        require(!paused(), \"Inventory: paused\");\n        super.safeTransferFrom(from, to, nftId, data);\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function batchBurnFrom(address from, uint256[] memory nftIds) public virtual override {\n        require(!paused(), \"Inventory: paused\");\n        super.batchBurnFrom(from, nftIds);\n    }","after":"function batchBurnFrom(address from, uint256[] calldata nftIds) public virtual override {\n        require(!paused(), \"Inventory: paused\");\n        super.batchBurnFrom(from, nftIds);\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) public virtual override {\n        require(!paused(), \"Inventory: paused\");\n        super.safeTransferFrom(from, to, id, value, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) public virtual override {\n        require(!paused(), \"Inventory: paused\");\n        super.safeTransferFrom(from, to, id, value, data);\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual override {\n        require(!paused(), \"Inventory: paused\");\n        super.safeBatchTransferFrom(from, to, ids, values, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) public virtual override {\n        require(!paused(), \"Inventory: paused\");\n        super.safeBatchTransferFrom(from, to, ids, values, data);\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function batchBurnFrom(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual override {\n        require(!paused(), \"Inventory: paused\");\n        super.batchBurnFrom(from, ids, values);\n    }","after":"function batchBurnFrom(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) public virtual override {\n        require(!paused(), \"Inventory: paused\");\n        super.batchBurnFrom(from, ids, values);\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function batchBurnFrom(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual override {\n        uint256 length = ids.length;\n        require(length == values.length, \"Inventory: inconsistent arrays\");\n\n        address sender = _msgSender();\n        bool operatable = _isOperatable(from, sender);\n\n        uint256 nfCollectionId;\n        uint256 nfCollectionCount;\n        uint256 nftsCount;\n        for (uint256 i; i != length; ++i) {\n            uint256 id = ids[i];\n            if (id.isFungibleToken()) {\n                _burnFungible(from, id, values[i], operatable);\n            } else if (id.isNonFungibleToken()) {\n                _burnNFT(from, id, values[i], operatable, true);\n                emit Transfer(from, address(0), id);\n                uint256 nextCollectionId = id.getNonFungibleCollection();\n                if (nfCollectionId == 0) {\n                    nfCollectionId = nextCollectionId;\n                    nfCollectionCount = 1;\n                } else {\n                    if (nextCollectionId != nfCollectionId) {\n                        _burnNFTUpdateCollection(from, nfCollectionId, nfCollectionCount);\n                        nfCollectionId = nextCollectionId;\n                        nftsCount += nfCollectionCount;\n                        nfCollectionCount = 1;\n                    } else {\n                        ++nfCollectionCount;\n                    }\n                }\n            } else {\n                revert(\"Inventory: not a token id\");\n            }\n        }\n\n        if (nfCollectionId != 0) {\n            _burnNFTUpdateCollection(from, nfCollectionId, nfCollectionCount);\n            nftsCount += nfCollectionCount;\n            // cannot underflow as balance is verified through ownership\n            _nftBalances[from] -= nftsCount;\n        }\n\n        emit TransferBatch(sender, from, address(0), ids, values);\n    }","after":"function batchBurnFrom(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) public virtual override {\n        uint256 length = ids.length;\n        require(length == values.length, \"Inventory: inconsistent arrays\");\n\n        address sender = _msgSender();\n        bool operatable = _isOperatable(from, sender);\n\n        uint256 nfCollectionId;\n        uint256 nfCollectionCount;\n        uint256 nftsCount;\n        for (uint256 i; i != length; ++i) {\n            uint256 id = ids[i];\n            if (id.isFungibleToken()) {\n                _burnFungible(from, id, values[i], operatable);\n            } else if (id.isNonFungibleToken()) {\n                _burnNFT(from, id, values[i], operatable, true);\n                emit Transfer(from, address(0), id);\n                uint256 nextCollectionId = id.getNonFungibleCollection();\n                if (nfCollectionId == 0) {\n                    nfCollectionId = nextCollectionId;\n                    nfCollectionCount = 1;\n                } else {\n                    if (nextCollectionId != nfCollectionId) {\n                        _burnNFTUpdateCollection(from, nfCollectionId, nfCollectionCount);\n                        nfCollectionId = nextCollectionId;\n                        nftsCount += nfCollectionCount;\n                        nfCollectionCount = 1;\n                    } else {\n                        ++nfCollectionCount;\n                    }\n                }\n            } else {\n                revert(\"Inventory: not a token id\");\n            }\n        }\n\n        if (nfCollectionId != 0) {\n            _burnNFTUpdateCollection(from, nfCollectionId, nfCollectionCount);\n            nftsCount += nfCollectionCount;\n            // cannot underflow as balance is verified through ownership\n            _nftBalances[from] -= nftsCount;\n        }\n\n        emit TransferBatch(sender, from, address(0), ids, values);\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function batchBurnFrom(address from, uint256[] memory nftIds) public virtual override {\n        address sender = _msgSender();\n        bool operatable = _isOperatable(from, sender);\n\n        uint256 length = nftIds.length;\n        uint256[] memory values = new uint256[](length);\n\n        uint256 nfCollectionId;\n        uint256 nfCollectionCount;\n        for (uint256 i; i != length; ++i) {\n            uint256 nftId = nftIds[i];\n            values[i] = 1;\n            _burnNFT(from, nftId, values[i], operatable, true);\n            emit Transfer(from, address(0), nftId);\n            uint256 nextCollectionId = nftId.getNonFungibleCollection();\n            if (nfCollectionId == 0) {\n                nfCollectionId = nextCollectionId;\n                nfCollectionCount = 1;\n            } else {\n                if (nextCollectionId != nfCollectionId) {\n                    _burnNFTUpdateCollection(from, nfCollectionId, nfCollectionCount);\n                    nfCollectionId = nextCollectionId;\n                    nfCollectionCount = 1;\n                } else {\n                    ++nfCollectionCount;\n                }\n            }\n        }\n\n        if (nfCollectionId != 0) {\n            _burnNFTUpdateCollection(from, nfCollectionId, nfCollectionCount);\n            _nftBalances[from] -= length;\n        }\n\n        emit TransferBatch(sender, from, address(0), nftIds, values);\n    }","after":"function batchBurnFrom(address from, uint256[] calldata nftIds) public virtual override {\n        address sender = _msgSender();\n        bool operatable = _isOperatable(from, sender);\n\n        uint256 length = nftIds.length;\n        uint256[] memory values = new uint256[](length);\n\n        uint256 nfCollectionId;\n        uint256 nfCollectionCount;\n        for (uint256 i; i != length; ++i) {\n            uint256 nftId = nftIds[i];\n            values[i] = 1;\n            _burnNFT(from, nftId, values[i], operatable, true);\n            emit Transfer(from, address(0), nftId);\n            uint256 nextCollectionId = nftId.getNonFungibleCollection();\n            if (nfCollectionId == 0) {\n                nfCollectionId = nextCollectionId;\n                nfCollectionCount = 1;\n            } else {\n                if (nextCollectionId != nfCollectionId) {\n                    _burnNFTUpdateCollection(from, nfCollectionId, nfCollectionCount);\n                    nfCollectionId = nextCollectionId;\n                    nfCollectionCount = 1;\n                } else {\n                    ++nfCollectionCount;\n                }\n            }\n        }\n\n        if (nfCollectionId != 0) {\n            _burnNFTUpdateCollection(from, nfCollectionId, nfCollectionCount);\n            _nftBalances[from] -= length;\n        }\n\n        emit TransferBatch(sender, from, address(0), nftIds, values);\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 nftId,\n        bytes memory data\n    ) public virtual override {\n        _transferFrom(\n            from,\n            to,\n            nftId,\n            data,\n            /* safe */\n            true\n        );\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 nftId,\n        bytes calldata data\n    ) public virtual override {\n        _transferFrom(\n            from,\n            to,\n            nftId,\n            data,\n            /* safe */\n            true\n        );\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory nftIds\n    ) public virtual override {\n        require(to != address(0), \"Inventory: transfer to zero\");\n        address sender = _msgSender();\n        bool operatable = _isOperatable(from, sender);\n\n        uint256 length = nftIds.length;\n        uint256[] memory values = new uint256[](length);\n\n        uint256 nfCollectionId;\n        uint256 nfCollectionCount;\n        for (uint256 i; i != length; ++i) {\n            uint256 nftId = nftIds[i];\n            values[i] = 1;\n            _transferNFT(from, to, nftId, 1, operatable, true);\n            emit Transfer(from, to, nftId);\n            uint256 nextCollectionId = nftId.getNonFungibleCollection();\n            if (nfCollectionId == 0) {\n                nfCollectionId = nextCollectionId;\n                nfCollectionCount = 1;\n            } else {\n                if (nextCollectionId != nfCollectionId) {\n                    _transferNFTUpdateCollection(from, to, nfCollectionId, nfCollectionCount);\n                    nfCollectionId = nextCollectionId;\n                    nfCollectionCount = 1;\n                } else {\n                    ++nfCollectionCount;\n                }\n            }\n        }\n\n        if (nfCollectionId != 0) {\n            _transferNFTUpdateCollection(from, to, nfCollectionId, nfCollectionCount);\n            _transferNFTUpdateBalances(from, to, length);\n        }\n\n        emit TransferBatch(_msgSender(), from, to, nftIds, values);\n        if (to.isContract() && _isERC1155TokenReceiver(to)) {\n            _callOnERC1155BatchReceived(from, to, nftIds, values, \"\");\n        }\n    }","after":"function batchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata nftIds\n    ) public virtual override {\n        require(to != address(0), \"Inventory: transfer to zero\");\n        address sender = _msgSender();\n        bool operatable = _isOperatable(from, sender);\n\n        uint256 length = nftIds.length;\n        uint256[] memory values = new uint256[](length);\n\n        uint256 nfCollectionId;\n        uint256 nfCollectionCount;\n        for (uint256 i; i != length; ++i) {\n            uint256 nftId = nftIds[i];\n            values[i] = 1;\n            _transferNFT(from, to, nftId, 1, operatable, true);\n            emit Transfer(from, to, nftId);\n            uint256 nextCollectionId = nftId.getNonFungibleCollection();\n            if (nfCollectionId == 0) {\n                nfCollectionId = nextCollectionId;\n                nfCollectionCount = 1;\n            } else {\n                if (nextCollectionId != nfCollectionId) {\n                    _transferNFTUpdateCollection(from, to, nfCollectionId, nfCollectionCount);\n                    nfCollectionId = nextCollectionId;\n                    nfCollectionCount = 1;\n                } else {\n                    ++nfCollectionCount;\n                }\n            }\n        }\n\n        if (nfCollectionId != 0) {\n            _transferNFTUpdateCollection(from, to, nfCollectionId, nfCollectionCount);\n            _transferNFTUpdateBalances(from, to, length);\n        }\n\n        emit TransferBatch(_msgSender(), from, to, nftIds, values);\n        if (to.isContract() && _isERC1155TokenReceiver(to)) {\n            _callOnERC1155BatchReceived(from, to, nftIds, values, \"\");\n        }\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) public virtual override {\n        address sender = _msgSender();\n        require(to != address(0), \"Inventory: transfer to zero\");\n        bool operatable = _isOperatable(from, sender);\n\n        if (id.isFungibleToken()) {\n            _transferFungible(from, to, id, value, operatable);\n        } else if (id.isNonFungibleToken()) {\n            _transferNFT(from, to, id, value, operatable, false);\n            emit Transfer(from, to, id);\n        } else {\n            revert(\"Inventory: not a token id\");\n        }\n\n        emit TransferSingle(sender, from, to, id, value);\n        if (to.isContract()) {\n            _callOnERC1155Received(from, to, id, value, data);\n        }\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) public virtual override {\n        address sender = _msgSender();\n        require(to != address(0), \"Inventory: transfer to zero\");\n        bool operatable = _isOperatable(from, sender);\n\n        if (id.isFungibleToken()) {\n            _transferFungible(from, to, id, value, operatable);\n        } else if (id.isNonFungibleToken()) {\n            _transferNFT(from, to, id, value, operatable, false);\n            emit Transfer(from, to, id);\n        } else {\n            revert(\"Inventory: not a token id\");\n        }\n\n        emit TransferSingle(sender, from, to, id, value);\n        if (to.isContract()) {\n            _callOnERC1155Received(from, to, id, value, data);\n        }\n    }","contract":"REVVInventory","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual override {\n        // internal function to avoid stack too deep error\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) public virtual override {\n        // internal function to avoid stack too deep error\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }","contract":"REVVInventory","time":0}]}