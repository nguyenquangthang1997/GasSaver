{"time":27,"results":[{"type":"external-function ","before":"function claim(\n        uint256 index,\n        bytes32 sig,\n        address account,\n        uint256 count,\n        bytes32[] memory proof\n    ) public {\n        require(address(mintable) != address(0), \"Minter: Must have a mintable set\");\n\n        require(!claimed[index], \"Minter: Can't claim a drop that's already been claimed\");\n        claimed[index] = true;\n\n        bytes32 node = makeNode(index, sig, account, count);\n        require(merkleVerify(node, proof), \"Minter: merkle verification failed\");\n\n        uint256 id = sigToTokenId[sig];\n        if (id == 0) {\n            sigToTokenId[sig] = nextId;\n            mintable.setTokenId(nextId, sig);\n            id = nextId;\n\n            nextId++;\n        }\n\n        mintable.mint(account, id, count);\n\n        emit Claimed(index, sig, account, count);\n    }","after":"function claim(\n        uint256 index,\n        bytes32 sig,\n        address account,\n        uint256 count,\n        bytes32[] calldata proof\n    ) public {\n        require(address(mintable) != address(0), \"Minter: Must have a mintable set\");\n\n        require(!claimed[index], \"Minter: Can't claim a drop that's already been claimed\");\n        claimed[index] = true;\n\n        bytes32 node = makeNode(index, sig, account, count);\n        require(merkleVerify(node, proof), \"Minter: merkle verification failed\");\n\n        uint256 id = sigToTokenId[sig];\n        if (id == 0) {\n            sigToTokenId[sig] = nextId;\n            mintable.setTokenId(nextId, sig);\n            id = nextId;\n\n            nextId++;\n        }\n\n        mintable.mint(account, id, count);\n\n        emit Claimed(index, sig, account, count);\n    }","contract":"Minter","time":0}]}