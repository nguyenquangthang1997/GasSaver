{"time":195,"results":[{"type":"state-data-arrangement ","before":"\nuint256 constant BLACK_SQUARE_ID = 741;\nuint256 constant BLACK_SQUARE_INDEX = 1115;\nuint256 constant MAX_SUPPLY = 10000;\nuint256 constant BIG_TREE = 8192;\nuint256 constant MEDIUM_TREE = 1024;\nuint256 constant SMALL_TREE = 512;\nuint256 constant SMALLEST_TREE = 256;\nuint256 constant HOLDERS_MINTING_PERIOD = 3 days;\nuint256 constant HOLDERS_CAP = 2000;\nuint256 constant FIRST_DROP_CAP = 750;\nuint256 constant SECOND_DROP_CAP = 650;\nuint256 constant THIRD_DROP_CAP = 600;\nuint256 constant LUCKYLIST_CAP = 1500;\nuint256 constant AUCTION_DURATION = 12 hours;\nuint256 constant AUCTION_PRICE = 0.05 ether;\nuint8 constant MAX_MINT_STAGES = 6;\nuint8 constant STAGE_HOLDERS = 1;\nuint8 constant STAGE_PUBLIC1 = 2;\nuint8 constant STAGE_PUBLIC2 = 3;\nuint8 constant STAGE_PUBLIC3 = 4;\nuint8 constant STAGE_2PLUS1 = 5;\nuint8 constant STAGE_AUCTION = 6;\naddress public fundAddress;\naddress public permitter;\nuint256 public immutable epoch;\naddress public immutable currencyPunks;\nuint256 public auctionStart;\nuint256 private baseStageSupply = 1;\nuint8 public mintStage;\nbytes32 constant PERMIT_TYPEHASH =\n        keccak256(bytes(\"Permit(address lucky,uint256 nonce)\"));\nmapping(uint256 => bool) isLuckyMinted;","after":"uint256 constant BLACK_SQUARE_ID = 741;\nuint256 constant BLACK_SQUARE_INDEX = 1115;\nuint256 constant MAX_SUPPLY = 10000;\nuint256 constant BIG_TREE = 8192;\nuint256 constant MEDIUM_TREE = 1024;\nuint256 constant SMALL_TREE = 512;\nuint256 constant SMALLEST_TREE = 256;\nuint256 constant HOLDERS_MINTING_PERIOD = 3 days;\nuint256 constant HOLDERS_CAP = 2000;\nuint256 constant FIRST_DROP_CAP = 750;\nuint256 constant SECOND_DROP_CAP = 650;\nuint256 constant THIRD_DROP_CAP = 600;\nuint256 constant LUCKYLIST_CAP = 1500;\nuint256 constant AUCTION_DURATION = 12 hours;\nuint256 constant AUCTION_PRICE = 0.05 ether;\nuint256 public immutable epoch;\nuint256 public auctionStart;\nuint256 private baseStageSupply = 1;\nbytes32 constant PERMIT_TYPEHASH =\n        keccak256(bytes(\"Permit(address lucky,uint256 nonce)\"));\nmapping(uint256 => bool) isLuckyMinted;\naddress public fundAddress;\naddress public permitter;\naddress public immutable currencyPunks;\nuint8 constant MAX_MINT_STAGES = 6;\nuint8 constant STAGE_HOLDERS = 1;\nuint8 constant STAGE_PUBLIC1 = 2;\nuint8 constant STAGE_PUBLIC2 = 3;\nuint8 constant STAGE_PUBLIC3 = 4;\nuint8 constant STAGE_2PLUS1 = 5;\nuint8 constant STAGE_AUCTION = 6;\nuint8 public mintStage;\n","contract":"MalevichPunks","time":3},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verifySignature(\n                userAddress,\n                hashMetaTransaction(metaTx),\n                sigR,\n                sigS,\n                sigV\n            ),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verifySignature(\n                userAddress,\n                hashMetaTransaction(metaTx),\n                sigR,\n                sigS,\n                sigV\n            ),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"MalevichPunks","time":0},{"type":"immutable-restrict-modification ","before":"address public fundAddress;","after":"address public immutable fundAddress;","contract":"MalevichPunks","time":1},{"type":"immutable-restrict-modification ","before":"address public permitter;","after":"address public immutable permitter;","contract":"MalevichPunks","time":1},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"MalevichPunks","time":1}]}