{"time":171,"results":[{"type":"external-function ","before":"function sendFundsToUser( address tokenAddress, uint256 amount, address payable receiver, bytes memory depositHash, uint256 tokenGasPrice ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {\n        uint256 initialGas = gasleft();\n        require(tokensInfo[tokenAddress].minCap <= amount && tokensInfo[tokenAddress].maxCap >= amount, \"Withdraw amount should be within allowed Cap limits\");\n        require(receiver != address(0), \"Bad receiver address\");\n\n        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);\n\n        require(!status, \"Already Processed\");\n        processedHash[hashSendTransaction] = true;\n\n        uint256 calculateAdminFee = amount.mul(adminFee).div(10000);\n\n        adminFeeAccumulatedByToken[tokenAddress] = adminFeeAccumulatedByToken[tokenAddress].add(calculateAdminFee); \n\n        uint256 totalGasUsed = (initialGas.sub(gasleft()));\n        totalGasUsed = totalGasUsed.add(tokensInfo[tokenAddress].transferOverhead);\n        totalGasUsed = totalGasUsed.add(baseGas);\n\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress].add(totalGasUsed.mul(tokenGasPrice));\n        uint256 amountToTransfer = amount.sub(calculateAdminFee.add(totalGasUsed.mul(tokenGasPrice)));\n\n        if (tokenAddress == NATIVE) {\n            require(address(this).balance >= amountToTransfer, \"Not Enough Balance\");\n            bool success = receiver.send(amountToTransfer);\n            require(success, \"Native Transfer Failed\");\n        } else {\n            require(IERC20(tokenAddress).balanceOf(address(this)) >= amountToTransfer, \"Not Enough Balance\");\n            SafeERC20.safeTransfer(IERC20(tokenAddress), receiver, amountToTransfer);\n        }\n\n        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash);\n    }","after":"function sendFundsToUser( address tokenAddress, uint256 amount, address payable receiver, bytes calldata depositHash, uint256 tokenGasPrice ) external nonReentrant onlyExecutor tokenChecks(tokenAddress) whenNotPaused {\n        uint256 initialGas = gasleft();\n        require(tokensInfo[tokenAddress].minCap <= amount && tokensInfo[tokenAddress].maxCap >= amount, \"Withdraw amount should be within allowed Cap limits\");\n        require(receiver != address(0), \"Bad receiver address\");\n\n        (bytes32 hashSendTransaction, bool status) = checkHashStatus(tokenAddress, amount, receiver, depositHash);\n\n        require(!status, \"Already Processed\");\n        processedHash[hashSendTransaction] = true;\n\n        uint256 calculateAdminFee = amount.mul(adminFee).div(10000);\n\n        adminFeeAccumulatedByToken[tokenAddress] = adminFeeAccumulatedByToken[tokenAddress].add(calculateAdminFee); \n\n        uint256 totalGasUsed = (initialGas.sub(gasleft()));\n        totalGasUsed = totalGasUsed.add(tokensInfo[tokenAddress].transferOverhead);\n        totalGasUsed = totalGasUsed.add(baseGas);\n\n        gasFeeAccumulatedByToken[tokenAddress] = gasFeeAccumulatedByToken[tokenAddress].add(totalGasUsed.mul(tokenGasPrice));\n        uint256 amountToTransfer = amount.sub(calculateAdminFee.add(totalGasUsed.mul(tokenGasPrice)));\n\n        if (tokenAddress == NATIVE) {\n            require(address(this).balance >= amountToTransfer, \"Not Enough Balance\");\n            bool success = receiver.send(amountToTransfer);\n            require(success, \"Native Transfer Failed\");\n        } else {\n            require(IERC20(tokenAddress).balanceOf(address(this)) >= amountToTransfer, \"Not Enough Balance\");\n            SafeERC20.safeTransfer(IERC20(tokenAddress), receiver, amountToTransfer);\n        }\n\n        emit AssetSent(tokenAddress, amount, amountToTransfer, receiver, depositHash);\n    }","contract":"LiquidityPoolManager","time":0}]}