{"time":204,"results":[{"type":"state-data-arrangement ","before":"\nbool    private _active;\nuint256 private _activeTime;\nuint256 private PRICE = 197800000000000000;\nuint32  private PRESALE_TIME = 86400;\nuint8   private MAX_QUANTITY = 5;\nuint8   public  COMMUNITY_QUOTA = 10;\naddress public  COMMUNITY_WALLET = 0x229ddBd9A20e3Df3ab7f540Ec77bEB258476fEe5;\naddress public  VIP_PASS_ADDRESS = 0x5645E72bcBCb9f218268e5DB15F62F016f885984;","after":"uint256 private _activeTime;\nuint256 private PRICE = 197800000000000000;\naddress public  COMMUNITY_WALLET = 0x229ddBd9A20e3Df3ab7f540Ec77bEB258476fEe5;\naddress public  VIP_PASS_ADDRESS = 0x5645E72bcBCb9f218268e5DB15F62F016f885984;\nuint32  private PRESALE_TIME = 86400;\nbool    private _active;\nuint8   private MAX_QUANTITY = 5;\nuint8   public  COMMUNITY_QUOTA = 10;\n","contract":"Mandelbrot","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"Mandelbrot","time":0},{"type":"constant-restrict-modification  ","before":"uint256 private PRICE = 197800000000000000;","after":"uint256 private constant PRICE = 197800000000000000;","contract":"Mandelbrot","time":2},{"type":"constant-restrict-modification  ","before":"uint32  private PRESALE_TIME = 86400;","after":"uint32  private constant PRESALE_TIME = 86400;","contract":"Mandelbrot","time":2},{"type":"constant-restrict-modification  ","before":"uint8   private MAX_QUANTITY = 5;","after":"uint8   private constant MAX_QUANTITY = 5;","contract":"Mandelbrot","time":2},{"type":"constant-restrict-modification  ","before":"uint8   public  COMMUNITY_QUOTA = 10;","after":"uint8   public  constant COMMUNITY_QUOTA = 10;","contract":"Mandelbrot","time":2},{"type":"constant-restrict-modification  ","before":"address public  COMMUNITY_WALLET = 0x229ddBd9A20e3Df3ab7f540Ec77bEB258476fEe5;","after":"address public  constant COMMUNITY_WALLET = 0x229ddBd9A20e3Df3ab7f540Ec77bEB258476fEe5;","contract":"Mandelbrot","time":2},{"type":"constant-restrict-modification  ","before":"address public  VIP_PASS_ADDRESS = 0x5645E72bcBCb9f218268e5DB15F62F016f885984;","after":"address public  constant VIP_PASS_ADDRESS = 0x5645E72bcBCb9f218268e5DB15F62F016f885984;","contract":"Mandelbrot","time":2},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"Mandelbrot","time":2},{"type":"external-function ","before":"function airdrop(address[] memory lucky_guys) public { // TO_DO: implement this!\n        require(lucky_guys.length<=balanceOf(msg.sender), \"You don't own enough VIPs!\");\n        for (uint i=0; i < lucky_guys.length; i++) {\n            transfer(lucky_guys[i],1);\n        }\n    }","after":"function airdrop(address[] calldata lucky_guys) public { // TO_DO: implement this!\n        require(lucky_guys.length<=balanceOf(msg.sender), \"You don't own enough VIPs!\");\n        for (uint i=0; i < lucky_guys.length; i++) {\n            transfer(lucky_guys[i],1);\n        }\n    }","contract":"VIP","time":0}]}