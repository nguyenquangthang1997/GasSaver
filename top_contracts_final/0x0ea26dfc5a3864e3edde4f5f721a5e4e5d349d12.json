{"time":281,"results":[{"type":"external-function ","before":"function whitelistMint(uint256 num, bytes32[] memory proof, bool autoStake) external override payable nonReentrant requireContractsSet {\n        uint256 supply = totalSupply();\n        require(tx.origin == _msgSender(), \"Only EOA\");\n        require(saleStage == 1 || _msgSender() == owner(), \"Pre-sale not started or has ended\");\n        require(remainingMint(_msgSender()) >= num, \"Hit mint limit\");\n        require(supply + num < supplyLimit, \"Exceeds maximum supply\");\n        require(msg.value >= num * price, \"Ether sent is not correct\");\n        require(whitelistMerkelRoot != 0, \"Whitelist not set\");\n        require(\n            proof.verify(whitelistMerkelRoot, keccak256(abi.encodePacked(_msgSender()))),\n            \"You aren't whitelisted\"\n        );\n        require(num > 0, \"Can't mint 0\");\n\n        minted[_msgSender()] += num;\n\n        for (uint256 i; i < num; i++) {\n            address recipient = autoStake ? address(staking) : _msgSender();\n            _safeMint(recipient, supply + i + 1);\n            tokenFaction[supply + i + 1] = walletAssignedMintFaction[_msgSender()];\n        }\n\n        if (autoStake) {\n            staking.stake(_msgSender(), supply + 1);\n        }\n    }","after":"function whitelistMint(uint256 num, bytes32[] calldata proof, bool autoStake) external override payable nonReentrant requireContractsSet {\n        uint256 supply = totalSupply();\n        require(tx.origin == _msgSender(), \"Only EOA\");\n        require(saleStage == 1 || _msgSender() == owner(), \"Pre-sale not started or has ended\");\n        require(remainingMint(_msgSender()) >= num, \"Hit mint limit\");\n        require(supply + num < supplyLimit, \"Exceeds maximum supply\");\n        require(msg.value >= num * price, \"Ether sent is not correct\");\n        require(whitelistMerkelRoot != 0, \"Whitelist not set\");\n        require(\n            proof.verify(whitelistMerkelRoot, keccak256(abi.encodePacked(_msgSender()))),\n            \"You aren't whitelisted\"\n        );\n        require(num > 0, \"Can't mint 0\");\n\n        minted[_msgSender()] += num;\n\n        for (uint256 i; i < num; i++) {\n            address recipient = autoStake ? address(staking) : _msgSender();\n            _safeMint(recipient, supply + i + 1);\n            tokenFaction[supply + i + 1] = walletAssignedMintFaction[_msgSender()];\n        }\n\n        if (autoStake) {\n            staking.stake(_msgSender(), supply + 1);\n        }\n    }","contract":"Blockverse","time":0},{"type":"external-function ","before":"function setCdnUri(string memory newCdnUri) external onlyOwner {\n        cdnUrl = newCdnUri;\n    }","after":"function setCdnUri(string calldata newCdnUri) external onlyOwner {\n        cdnUrl = newCdnUri;\n    }","contract":"BlockverseMetadata","time":0},{"type":"constant-restrict-modification  ","before":"uint256 unstakeFactionChangeTime = 3 days;","after":"uint256 constant unstakeFactionChangeTime = 3 days;","contract":"BlockverseStaking","time":0}]}