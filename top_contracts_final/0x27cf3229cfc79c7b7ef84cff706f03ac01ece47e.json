{"time":162,"results":[{"type":"external-function ","before":"function createIncentive(IncentiveKey memory key, uint256 reward) external override {\n        require(reward > 0, 'UniswapV3Staker::createIncentive: reward must be positive');\n        require(\n            block.timestamp <= key.startTime,\n            'UniswapV3Staker::createIncentive: start time must be now or in the future'\n        );\n        require(\n            key.startTime - block.timestamp <= maxIncentiveStartLeadTime,\n            'UniswapV3Staker::createIncentive: start time too far into future'\n        );\n        require(key.startTime < key.endTime, 'UniswapV3Staker::createIncentive: start time must be before end time');\n        require(\n            key.endTime - key.startTime <= maxIncentiveDuration,\n            'UniswapV3Staker::createIncentive: incentive duration is too long'\n        );\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        incentives[incentiveId].totalRewardUnclaimed += reward;\n\n        TransferHelper.safeTransferFrom(address(key.rewardToken), msg.sender, address(this), reward);\n\n        emit IncentiveCreated(key.rewardToken, key.pool, key.startTime, key.endTime, key.refundee, reward);\n    }","after":"function createIncentive(IncentiveKey calldata key, uint256 reward) external override {\n        require(reward > 0, 'UniswapV3Staker::createIncentive: reward must be positive');\n        require(\n            block.timestamp <= key.startTime,\n            'UniswapV3Staker::createIncentive: start time must be now or in the future'\n        );\n        require(\n            key.startTime - block.timestamp <= maxIncentiveStartLeadTime,\n            'UniswapV3Staker::createIncentive: start time too far into future'\n        );\n        require(key.startTime < key.endTime, 'UniswapV3Staker::createIncentive: start time must be before end time');\n        require(\n            key.endTime - key.startTime <= maxIncentiveDuration,\n            'UniswapV3Staker::createIncentive: incentive duration is too long'\n        );\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        incentives[incentiveId].totalRewardUnclaimed += reward;\n\n        TransferHelper.safeTransferFrom(address(key.rewardToken), msg.sender, address(this), reward);\n\n        emit IncentiveCreated(key.rewardToken, key.pool, key.startTime, key.endTime, key.refundee, reward);\n    }","contract":"UniswapV3Staker","time":0},{"type":"external-function ","before":"function endIncentive(IncentiveKey memory key) external override returns (uint256 refund) {\n        require(block.timestamp >= key.endTime, 'UniswapV3Staker::endIncentive: cannot end incentive before end time');\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n        Incentive storage incentive = incentives[incentiveId];\n\n        refund = incentive.totalRewardUnclaimed;\n\n        require(refund > 0, 'UniswapV3Staker::endIncentive: no refund available');\n        require(\n            incentive.numberOfStakes == 0,\n            'UniswapV3Staker::endIncentive: cannot end incentive while deposits are staked'\n        );\n\n        // issue the refund\n        incentive.totalRewardUnclaimed = 0;\n        TransferHelper.safeTransfer(address(key.rewardToken), key.refundee, refund);\n\n        // note we never clear totalSecondsClaimedX128\n\n        emit IncentiveEnded(incentiveId, refund);\n    }","after":"function endIncentive(IncentiveKey calldata key) external override returns (uint256 refund) {\n        require(block.timestamp >= key.endTime, 'UniswapV3Staker::endIncentive: cannot end incentive before end time');\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n        Incentive storage incentive = incentives[incentiveId];\n\n        refund = incentive.totalRewardUnclaimed;\n\n        require(refund > 0, 'UniswapV3Staker::endIncentive: no refund available');\n        require(\n            incentive.numberOfStakes == 0,\n            'UniswapV3Staker::endIncentive: cannot end incentive while deposits are staked'\n        );\n\n        // issue the refund\n        incentive.totalRewardUnclaimed = 0;\n        TransferHelper.safeTransfer(address(key.rewardToken), key.refundee, refund);\n\n        // note we never clear totalSecondsClaimedX128\n\n        emit IncentiveEnded(incentiveId, refund);\n    }","contract":"UniswapV3Staker","time":0},{"type":"external-function ","before":"function withdrawToken(\n        uint256 tokenId,\n        address to,\n        bytes memory data\n    ) external override {\n        require(to != address(this), 'UniswapV3Staker::withdrawToken: cannot withdraw to staker');\n        Deposit memory deposit = deposits[tokenId];\n        require(deposit.numberOfStakes == 0, 'UniswapV3Staker::withdrawToken: cannot withdraw token while staked');\n        require(deposit.owner == msg.sender, 'UniswapV3Staker::withdrawToken: only owner can withdraw token');\n\n        delete deposits[tokenId];\n        emit DepositTransferred(tokenId, deposit.owner, address(0));\n\n        nonfungiblePositionManager.safeTransferFrom(address(this), to, tokenId, data);\n    }","after":"function withdrawToken(\n        uint256 tokenId,\n        address to,\n        bytes calldata data\n    ) external override {\n        require(to != address(this), 'UniswapV3Staker::withdrawToken: cannot withdraw to staker');\n        Deposit memory deposit = deposits[tokenId];\n        require(deposit.numberOfStakes == 0, 'UniswapV3Staker::withdrawToken: cannot withdraw token while staked');\n        require(deposit.owner == msg.sender, 'UniswapV3Staker::withdrawToken: only owner can withdraw token');\n\n        delete deposits[tokenId];\n        emit DepositTransferred(tokenId, deposit.owner, address(0));\n\n        nonfungiblePositionManager.safeTransferFrom(address(this), to, tokenId, data);\n    }","contract":"UniswapV3Staker","time":0},{"type":"external-function ","before":"function stakeToken(IncentiveKey memory key, uint256 tokenId) external override {\n        require(deposits[tokenId].owner == msg.sender, 'UniswapV3Staker::stakeToken: only owner can stake token');\n\n        _stakeToken(key, tokenId);\n    }","after":"function stakeToken(IncentiveKey calldata key, uint256 tokenId) external override {\n        require(deposits[tokenId].owner == msg.sender, 'UniswapV3Staker::stakeToken: only owner can stake token');\n\n        _stakeToken(key, tokenId);\n    }","contract":"UniswapV3Staker","time":0},{"type":"external-function ","before":"function unstakeToken(IncentiveKey memory key, uint256 tokenId) external override {\n        Deposit memory deposit = deposits[tokenId];\n        // anyone can call unstakeToken if the block time is after the end time of the incentive\n        if (block.timestamp < key.endTime) {\n            require(\n                deposit.owner == msg.sender,\n                'UniswapV3Staker::unstakeToken: only owner can withdraw token before incentive end time'\n            );\n        }\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity) = stakes(tokenId, incentiveId);\n\n        require(liquidity != 0, 'UniswapV3Staker::unstakeToken: stake does not exist');\n\n        Incentive storage incentive = incentives[incentiveId];\n\n        deposits[tokenId].numberOfStakes--;\n        incentive.numberOfStakes--;\n\n        (, uint160 secondsPerLiquidityInsideX128, ) =\n            key.pool.snapshotCumulativesInside(deposit.tickLower, deposit.tickUpper);\n        (uint256 reward, uint160 secondsInsideX128) =\n            RewardMath.computeRewardAmount(\n                incentive.totalRewardUnclaimed,\n                incentive.totalSecondsClaimedX128,\n                key.startTime,\n                key.endTime,\n                liquidity,\n                secondsPerLiquidityInsideInitialX128,\n                secondsPerLiquidityInsideX128,\n                block.timestamp\n            );\n\n        // if this overflows, e.g. after 2^32-1 full liquidity seconds have been claimed,\n        // reward rate will fall drastically so it's safe\n        incentive.totalSecondsClaimedX128 += secondsInsideX128;\n        // reward is never greater than total reward unclaimed\n        incentive.totalRewardUnclaimed -= reward;\n        // this only overflows if a token has a total supply greater than type(uint256).max\n        rewards[key.rewardToken][deposit.owner] += reward;\n\n        Stake storage stake = _stakes[tokenId][incentiveId];\n        delete stake.secondsPerLiquidityInsideInitialX128;\n        delete stake.liquidityNoOverflow;\n        if (liquidity >= type(uint96).max) delete stake.liquidityIfOverflow;\n        emit TokenUnstaked(tokenId, incentiveId);\n    }","after":"function unstakeToken(IncentiveKey calldata key, uint256 tokenId) external override {\n        Deposit memory deposit = deposits[tokenId];\n        // anyone can call unstakeToken if the block time is after the end time of the incentive\n        if (block.timestamp < key.endTime) {\n            require(\n                deposit.owner == msg.sender,\n                'UniswapV3Staker::unstakeToken: only owner can withdraw token before incentive end time'\n            );\n        }\n\n        bytes32 incentiveId = IncentiveId.compute(key);\n\n        (uint160 secondsPerLiquidityInsideInitialX128, uint128 liquidity) = stakes(tokenId, incentiveId);\n\n        require(liquidity != 0, 'UniswapV3Staker::unstakeToken: stake does not exist');\n\n        Incentive storage incentive = incentives[incentiveId];\n\n        deposits[tokenId].numberOfStakes--;\n        incentive.numberOfStakes--;\n\n        (, uint160 secondsPerLiquidityInsideX128, ) =\n            key.pool.snapshotCumulativesInside(deposit.tickLower, deposit.tickUpper);\n        (uint256 reward, uint160 secondsInsideX128) =\n            RewardMath.computeRewardAmount(\n                incentive.totalRewardUnclaimed,\n                incentive.totalSecondsClaimedX128,\n                key.startTime,\n                key.endTime,\n                liquidity,\n                secondsPerLiquidityInsideInitialX128,\n                secondsPerLiquidityInsideX128,\n                block.timestamp\n            );\n\n        // if this overflows, e.g. after 2^32-1 full liquidity seconds have been claimed,\n        // reward rate will fall drastically so it's safe\n        incentive.totalSecondsClaimedX128 += secondsInsideX128;\n        // reward is never greater than total reward unclaimed\n        incentive.totalRewardUnclaimed -= reward;\n        // this only overflows if a token has a total supply greater than type(uint256).max\n        rewards[key.rewardToken][deposit.owner] += reward;\n\n        Stake storage stake = _stakes[tokenId][incentiveId];\n        delete stake.secondsPerLiquidityInsideInitialX128;\n        delete stake.liquidityNoOverflow;\n        if (liquidity >= type(uint96).max) delete stake.liquidityIfOverflow;\n        emit TokenUnstaked(tokenId, incentiveId);\n    }","contract":"UniswapV3Staker","time":0}]}