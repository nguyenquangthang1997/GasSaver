{"time":772,"results":[{"type":"external-function ","before":"dress) private _redeemedPasses;\n    string private _contractURI;\n\n    //Events\n    event DatesChanged(uint256[] ids, uint256[] open, uint256[] close);\n\n    event RedeemedPass(bytes32 hash, address account);\n\n    event MaxPerWalletChanged(uint256[] ids, uint256[] maxPerWallet);\n\n    event MaxPerTransactionChanged(uint256[] ids, uint256[] maxPerTransaction);\n\n    event PricesChanged(uint256[] ids, uint256[] prices);\n\n    event MaxItemsChanged(uint256[] ids, uint256[] maxItems);\n\n    event RedeemContractAddressChanged(\n        uint256[] ids,\n        address[] redeemContracts\n    );\n\n    event UriChanged(string newUri);\n\n    /// @dev We setup the roles and the name for the Smart Contract\n    constructor(string memory newContractName)\n        ERC1155(\"\")\n        EIP712(newContractName, \"1.0.0\")\n    {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(OPERATOR_ROLE, msg.sender);\n        _setupRole(WITHDRAWER_ROLE, msg.sender);\n        _setupRole(SIGNER_ROLE, msg.sender);\n    }\n\n    /// @dev Setup method\n    /// @param numPasses The number of passes to setup\n    /// @param maxItems An array containing the maximum of passes,\n    // for example if we defined numPasses = 2, and we want 2500 and 5000 maxItems, this array should be [2500, 5000]\n\n    /// @param maxPerWallet An array containing the maximum allowed passes per wallet\n    /// @p","after":"dress) private _redeemedPasses;\n    string private _contractURI;\n\n    //Events\n    event DatesChanged(uint256[] ids, uint256[] open, uint256[] close);\n\n    event RedeemedPass(bytes32 hash, address account);\n\n    event MaxPerWalletChanged(uint256[] ids, uint256[] maxPerWallet);\n\n    event MaxPerTransactionChanged(uint256[] ids, uint256[] maxPerTransaction);\n\n    event PricesChanged(uint256[] ids, uint256[] prices);\n\n    event MaxItemsChanged(uint256[] ids, uint256[] maxItems);\n\n    event RedeemContractAddressChanged(\n        uint256[] ids,\n        address[] redeemContracts\n    );\n\n    event UriChanged(string newUri);\n\n    /// @dev We setup the roles and the name for the Smart Contract\n    constructor(string memory newContractName)\n        ERC1155(\"\")\n        EIP712(newContractName, \"1.0.0\")\n    {\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _setupRole(OPERATOR_ROLE, msg.sender);\n        _setupRole(WITHDRAWER_ROLE, msg.sender);\n        _setupRole(SIGNER_ROLE, msg.sender);\n    }\n\n    /// @dev Setup method\n    /// @param numPasses The number of passes to setup\n    /// @param maxItems An array containing the maximum of passes,\n    // for example if we defined numPasses = 2, and we want 2500 and 5000 maxItems, this array should be [2500, 5000]\n\n    /// @param maxPerWallet An array containing the maximum allowed passes per wallet\n    /// @p","contract":"NomadPass","time":0},{"type":"external-function ","before":"n the sale is closed for each pass.\n    function setup(\n        uint256 numPasses,\n        uint256[] memory maxItems,\n        uint256[] memory maxPerWall","after":"n the sale is closed for each pass.\n    function setup(\n        uint256 numPasses,\n        uint256[] memory maxItems,\n        uint256[] memory maxPerWall","contract":"NomadPass","time":0},{"type":"external-function ","before":"    require(pass.maxItems > 0, \"TOKEN_ID_NOT_EXIST\");\n        return pass.maxPerWallet;\n    }\n\n    //Returns the maxPerTransaction for passId\n    function getMaxPerTransaction(uint256 passId)\n        public\n        view\n        returns (uint256)\n    {\n        Pass storage pass = _passes[passId];\n        require(pass.maxItems > 0, \"TOKEN_ID_NOT_EXIST\");\n        return pass.maxPerTransaction;\n    }\n\n    //Returns the redeemContract for passId\n    function getRedeemContract(uint256 passId) public view returns (address) {\n        Pass storage pass = _passes[passId];\n        require(pass.maxItems > 0, \"TOKEN_ID_NOT_EXIST\");\n        return pass.redeemContract;\n    }\n\n    //Returns the rede","after":"    require(pass.maxItems > 0, \"TOKEN_ID_NOT_EXIST\");\n        return pass.maxPerWallet;\n    }\n\n    //Returns the maxPerTransaction for passId\n    function getMaxPerTransaction(uint256 passId)\n        public\n        view\n        returns (uint256)\n    {\n        Pass storage pass = _passes[passId];\n        require(pass.maxItems > 0, \"TOKEN_ID_NOT_EXIST\");\n        return pass.maxPerTransaction;\n    }\n\n    //Returns the redeemContract for passId\n    function getRedeemContract(uint256 passId) public view returns (address) {\n        Pass storage pass = _passes[passId];\n        require(pass.maxItems > 0, \"TOKEN_ID_NOT_EXIST\");\n        return pass.redeemContract;\n    }\n\n    //Returns the rede","contract":"NomadPass","time":0},{"type":"external-function ","before":"xternal onlyRole(OPERATOR_ROLE) {\n        _passCounter.reset();\n        for (uint256 i = 0; i < newIndex; i++) {\n            _passCounter.increment();\n        }\n    }\n\n    /// @dev Pause the contract if anything weird happens\n    function pause() public onlyRole(OPERATOR_ROLE) {\n        _pause();\n    }\n\n    /// @dev Unpause the contarct\n    function unpause() public onlyRole(OPERATOR_ROLE) {\n        _unpause();\n    }\n\n    /// @dev After doing the setup, this method can be used to modify the sale dates.\n    /// This dates are used in the mintPas","after":"xternal onlyRole(OPERATOR_ROLE) {\n        _passCounter.reset();\n        for (uint256 i = 0; i < newIndex; i++) {\n            _passCounter.increment();\n        }\n    }\n\n    /// @dev Pause the contract if anything weird happens\n    function pause() public onlyRole(OPERATOR_ROLE) {\n        _pause();\n    }\n\n    /// @dev Unpause the contarct\n    function unpause() public onlyRole(OPERATOR_ROLE) {\n        _unpause();\n    }\n\n    /// @dev After doing the setup, this method can be used to modify the sale dates.\n    /// This dates are used in the mintPas","contract":"NomadPass","time":0},{"type":"external-function ","before":"r each pass\n    function setDates(\n        uint256[] memory ids,\n        uint256[] memory open,\n        uint256[] memory close\n    ) external onlyRole(OPERATOR_ROLE) {\n        require(ids.length > 0, \"INVALID_TOKENS_SIZE\");\n        require(open.length == ids.length, \"INVALID_OPEN_SIZE\");\n        require(close.length == ids.length, \"INVALID_CLOSE_SIZE\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            require(open[i] <= close[i], \"INVALID_DATES\");\n            Pass storage pass = _passes[ids[i]];\n\n            require(pass.maxItems > 0, \"TOKEN_ID_NOT_EXIST\");\n            pass.open = open[i];\n            ","after":"r each pass\n    function setDates(\n        uint256[] calldata ids,\n        uint256[] calldata open,\n        uint256[] memory close\n    ) external onlyRole(OPERATOR_ROLE) {\n        require(ids.length > 0, \"INVALID_TOKENS_SIZE\");\n        require(open.length == ids.length, \"INVALID_OPEN_SIZE\");\n        require(close.length == ids.length, \"INVALID_CLOSE_SIZE\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            require(open[i] <= close[i], \"INVALID_DATES\");\n            Pass storage pass = _passes[ids[i]];\n\n            require(pass.maxItems > 0, \"TOKEN_ID_NOT_EXIST\");\n            pass.open = open[i];\n            ","contract":"NomadPass","time":0},{"type":"external-function ","before":" /// @param maxPerWallet An array containing the maximum allowed passes per wallet.\n    function setMaxPerWallet(\n        uint256[] memory ids,\n        uint256[] memory maxPerWallet\n    ) external onlyRole(OPERATOR_ROLE) {\n        require(ids.length > 0, \"INVALID_TOKENS_SIZE\");\n        require(maxPerWallet.length == ids.length, \"INVALID_MAX_WALLET_SIZE\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            Pass storage pass = _passes[ids[i]];\n            require(pass.maxItems > 0, \"TOKEN_ID_NOT_EXIST\");\n            pass.maxPerWallet = maxPerWallet[i];\n        }\n        emit MaxPerWalletChanged(ids","after":" /// @param maxPerWallet An array containing the maximum allowed passes per wallet.\n    function setMaxPerWallet(\n        uint256[] memory ids,\n        uint256[] memory maxPerWallet\n    ) external onlyRole(OPERATOR_ROLE) {\n        require(ids.length > 0, \"INVALID_TOKENS_SIZE\");\n        require(maxPerWallet.length == ids.length, \"INVALID_MAX_WALLET_SIZE\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            Pass storage pass = _passes[ids[i]];\n            require(pass.maxItems > 0, \"TOKEN_ID_NOT_EXIST\");\n            pass.maxPerWallet = maxPerWallet[i];\n        }\n        emit MaxPerWalletChanged(ids","contract":"NomadPass","time":0},{"type":"external-function ","before":"s per transaction.\n    function setMaxPerTransaction(\n        uint256[] memory ids,\n        uint256[] memory maxPerTransaction\n    ) external onlyRole(OPERATOR_ROLE) {\n        require(ids.length > 0, \"INVALID_TOKENS_SIZE\");\n        require(\n            maxPerTransaction.length == ids.length,\n            \"INVALID_MAX_TRANSACTION_SIZE\"\n        );\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            Pass storage pass = _passes[ids[i]];\n            require(pass.maxItems > 0, \"TOKEN_ID_NOT_","after":"s per transaction.\n    function setMaxPerTransaction(\n        uint256[] memory ids,\n        uint256[] memory maxPerTransaction\n    ) external onlyRole(OPERATOR_ROLE) {\n        require(ids.length > 0, \"INVALID_TOKENS_SIZE\");\n        require(\n            maxPerTransaction.length == ids.length,\n            \"INVALID_MAX_TRANSACTION_SIZE\"\n        );\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            Pass storage pass = _passes[ids[i]];\n            require(pass.maxItems > 0, \"TOKEN_ID_NOT_","contract":"NomadPass","time":0},{"type":"external-function ","before":"n be used to modify the redeem contract address for each pass.\n    /// @param ids The ids of the passes\n    /// @param redeemContracts The addresses for each redeem contract\n    function setRedeemContracts(\n        uint256[] memory ids,\n        address[] memory redeemContracts\n    ) external onlyRole(OPERATOR_ROLE) {\n        require(ids.length > 0, \"INVALID_TOKENS_SIZE\");\n        require(\n            redeemContracts.length == ids.length,\n            \"INVALID_REDEEM_CONTRACTS_SIZE\"\n        );\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            Pass storage pas","after":"n be used to modify the redeem contract address for each pass.\n    /// @param ids The ids of the passes\n    /// @param redeemContracts The addresses for each redeem contract\n    function setRedeemContracts(\n        uint256[] memory ids,\n        address[] memory redeemContracts\n    ) external onlyRole(OPERATOR_ROLE) {\n        require(ids.length > 0, \"INVALID_TOKENS_SIZE\");\n        require(\n            redeemContracts.length == ids.length,\n            \"INVALID_REDEEM_CONTRACTS_SIZE\"\n        );\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            Pass storage pas","contract":"NomadPass","time":0},{"type":"external-function ","before":"@dev After doing the setup, this method can be used to modify the redeem price of each pass.\n    /// The prices are used in the redeemPa","after":"@dev After doing the setup, this method can be used to modify the redeem price of each pass.\n    /// The prices are used in the redeemPa","contract":"NomadPass","time":0},{"type":"external-function ","before":"  Pass storage pass = _passes[passId];\n        require(pass.maxItems > 0, \"TOKEN_ID_NOT_EXIST\");\n\n        bytes32 hash = _hash(msg.sender, passId, amount, nonce);\n\n        require(_verify(hash, signature), \"INVALID_SIGNATURE\");\n        require(_redeemedPasses[hash] == address(0), \"TOKEN_ALREADY_REDEEMED\");\n\n        require(block.timestamp >= pass.open, \"INVALID_OPEN_DATE\");\n        require(block.timestamp <= pass.close, \"INVALID_CLOSE_DATE\");\n\n        if (pass.maxPerTransaction > 0) {","after":"  Pass storage pass = _passes[passId];\n        require(pass.maxItems > 0, \"TOKEN_ID_NOT_EXIST\");\n\n        bytes32 hash = _hash(msg.sender, passId, amount, nonce);\n\n        require(_verify(hash, signature), \"INVALID_SIGNATURE\");\n        require(_redeemedPasses[hash] == address(0), \"TOKEN_ALREADY_REDEEMED\");\n\n        require(block.timestamp >= pass.open, \"INVALID_OPEN_DATE\");\n        require(block.timestamp <= pass.close, \"INVALID_CLOSE_DATE\");\n\n        if (pass.maxPerTransaction > 0) {","contract":"NomadPass","time":0},{"type":"external-function ","before":"       require(\n                amount <= pass.maxPerTransaction,\n                \"INVALID_MAX_PER_TRANSACTION\"\n            );\n        }\n\n        if (pass.maxPerWallet > 0) {\n            uint256 balance = balanceOf(msg.sender, passId);\n            require(\n          ","after":"       require(\n                amount <= pass.maxPerTransaction,\n                \"INVALID_MAX_PER_TRANSACTION\"\n            );\n        }\n\n        if (pass.maxPerWallet > 0) {\n            uint256 balance = balanceOf(msg.sender, passId);\n            require(\n          ","contract":"NomadPass","time":0},{"type":"external-function ","before":"ry) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][ac","after":"ry) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][ac","contract":"NomadPass","time":0},{"type":"external-function ","before":"\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts","after":"\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts","contract":"NomadPass","time":0},{"type":"external-function ","before":"lic view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n","after":"lic view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n","contract":"NomadPass","time":0}]}