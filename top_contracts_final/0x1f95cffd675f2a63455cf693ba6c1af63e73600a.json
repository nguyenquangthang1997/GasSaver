{"time":775,"results":[{"type":"external-function ","before":"function setQuest(uint256 id, string memory clue, bytes32 answer, string memory feature, string memory keyword, string memory cipher, uint256 keys) public onlyOwner {\n        require(id <= maxQuests);\n        Quest memory quest;\n        quest.clue = clue;\n        quest.answer = answer;\n        quest.feature = feature;\n        quest.keyword = keyword;\n        quest.cipher = cipher;\n        quest.keys = keys;\n        _quests[id] = quest;\n        emit QuestUpdated(id);\n    }","after":"function setQuest(uint256 id, string calldata clue, bytes32 answer, string calldata feature, string calldata keyword, string calldata cipher, uint256 keys) public onlyOwner {\n        require(id <= maxQuests);\n        Quest memory quest;\n        quest.clue = clue;\n        quest.answer = answer;\n        quest.feature = feature;\n        quest.keyword = keyword;\n        quest.cipher = cipher;\n        quest.keys = keys;\n        _quests[id] = quest;\n        emit QuestUpdated(id);\n    }","contract":"Floadmap1155","time":0},{"type":"external-function ","before":"function setPayload(uint256 id, string memory payload) public onlyOwner {\n        _tokenPayload[id] = payload;\n        emit PayloadUpdated(id);\n    }","after":"function setPayload(uint256 id, string calldata payload) public onlyOwner {\n        _tokenPayload[id] = payload;\n        emit PayloadUpdated(id);\n    }","contract":"Floadmap1155","time":0},{"type":"external-function ","before":"function solveQuest(uint256 questId, string memory answer) public nonReentrant {\n        require(balanceOf(msg.sender, questId) > 0);\n        require(_solvedQuests[questId] == 0);\n        require(checkQuest(questId, answer));\n\n        _tokenIds.increment();\n        uint256 tokenId = _tokenIds.current();\n\n        _solvedQuests[questId] = tokenId;\n        _burn(msg.sender, questId, 1);\n        _mint(msg.sender, tokenId, 1, bytes(\"\"));\n\n        uint256 keys = _quests[questId].keys;\n        if(keys > 1) {\n            flipkey.mintRandomBatch(msg.sender, keys);\n        } else {\n            flipkey.mintRandom(msg.sender);\n        }\n\n        emit QuestSolved(questId, tokenId, msg.sender);\n    }","after":"function solveQuest(uint256 questId, string calldata answer) public nonReentrant {\n        require(balanceOf(msg.sender, questId) > 0);\n        require(_solvedQuests[questId] == 0);\n        require(checkQuest(questId, answer));\n\n        _tokenIds.increment();\n        uint256 tokenId = _tokenIds.current();\n\n        _solvedQuests[questId] = tokenId;\n        _burn(msg.sender, questId, 1);\n        _mint(msg.sender, tokenId, 1, bytes(\"\"));\n\n        uint256 keys = _quests[questId].keys;\n        if(keys > 1) {\n            flipkey.mintRandomBatch(msg.sender, keys);\n        } else {\n            flipkey.mintRandom(msg.sender);\n        }\n\n        emit QuestSolved(questId, tokenId, msg.sender);\n    }","contract":"Floadmap1155","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"Floadmap1155","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"Floadmap1155","time":0},{"type":"constant-restrict-modification  ","before":"string public name = 'Floadmaps';","after":"string public constant name = 'Floadmaps';","contract":"Floadmap1155","time":1},{"type":"external-function ","before":"function savePairs(uint256[][] memory pairHashes) public onlyOwner {\n        for(uint256 i=0; i<pairHashes.length; i++) {\n            bytes32 pairHash = keccak256(abi.encodePacked(pairHashes[i][0], '-', pairHashes[i][1]));\n            _tokenPairs[pairHash] = true;\n        }\n    }","after":"function savePairs(uint256[][] calldata pairHashes) public onlyOwner {\n        for(uint256 i=0; i<pairHashes.length; i++) {\n            bytes32 pairHash = keccak256(abi.encodePacked(pairHashes[i][0], '-', pairHashes[i][1]));\n            _tokenPairs[pairHash] = true;\n        }\n    }","contract":"Flipmap","time":0},{"type":"constant-restrict-modification  ","before":"address sara    = 0x00796e910Bd0228ddF4cd79e3f353871a61C351C;","after":"address constant sara    = 0x00796e910Bd0228ddF4cd79e3f353871a61C351C;","contract":"Flipmap","time":0},{"type":"constant-restrict-modification  ","before":"address lambo   = 0xafBDEc0ba91FDFf03A91CbdF07392e6D72d43712;","after":"address constant lambo   = 0xafBDEc0ba91FDFf03A91CbdF07392e6D72d43712;","contract":"Flipmap","time":0},{"type":"constant-restrict-modification  ","before":"address dev     = 0xE424E566BFc3f7aDDFfb17862637DD61e2da3bE2;","after":"address constant dev     = 0xE424E566BFc3f7aDDFfb17862637DD61e2da3bE2;","contract":"Flipmap","time":0},{"type":"external-function ","before":" }\n\n    function setKeyData(uint256 key, bytes memory data) public onlyOwner {\n        _keys[key] = dat","after":" }\n\n    function setKeyData(uint256 key, bytes memory data) public onlyOwner {\n        _keys[key] = dat","contract":"Flipkey1155","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"Flipkey1155","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"Flipkey1155","time":0},{"type":"constant-restrict-modification  ","before":"s;\n\n    string public name = 'Fl","after":"s;\n\n    string public constant name = 'Fl","contract":"Flipkey1155","time":1},{"type":"constant-restrict-modification  ","before":"s;\n\n    uint256 maxLineLeng","after":"s;\n\n    uint256 maxLineLeng","contract":"Flipdata","time":0},{"type":"state-data-arrangement ","before":"\n }\n\n    address private\ner;\n    mapping (address => Creator) private _allo\n);\n\n    mapping(uint256 => VariantParents) private _tokenPare\nex;\n    mapping(bytes32 => bool) private _tok\ns;\n\n    bytes[] private _tokenDa\nex;\n    TokenMetadata[] private _tokenMetada\nx;\n\n    string private _ur\nx;\n\n    uint8 private _numOr\nls;\n    uint8 private constant _maxNumOriginal\n28;\n    uint8 private constant _maxNumVarian\n6;\n\n    bool public pu","after":"er;\n    mapping (address => Creator) private _allo\n);\n\n    mapping(uint256 => VariantParents) private _tokenPare\nex;\n    mapping(bytes32 => bool) private _tok\ns;\n\n    bytes[] private _tokenDa\nex;\n    TokenMetadata[] private _tokenMetada\nx;\n\n    string private _ur\n }\n\n    address private\nx;\n\n    uint8 private _numOr\nls;\n    uint8 private constant _maxNumOriginal\n28;\n    uint8 private constant _maxNumVarian\n6;\n\n    bool public pu\n","contract":"Blitmap","time":0},{"type":"struct-data-arrangement ","before":"\n        str\n        bool i\n        uint256 availabl\n        uint8 remain","after":"        str\n        uint256 availabl\n        bool i\n        uint8 remain\n","contract":"Blitmap","time":0},{"type":"external-function ","before":" }\n\n    function changeMetadataOf(uint256 tokenId, TokenMetadata memory newMetadata) public onlyOwner {\n        require(published == false, \"b:01\"); // only allow changes prior to publishing\n        _tokenMetadataIndex[tokenId] = newMetadata;\n        emit MetadataChanged(tokenId, newMetadata","after":" }\n\n    function changeMetadataOf(uint256 tokenId, TokenMetadata calldata newMetadata) public onlyOwner {\n        require(published == false, \"b:01\"); // only allow changes prior to publishing\n        _tokenMetadataIndex[tokenId] = newMetadata;\n        emit MetadataChanged(tokenId, newMetadata","contract":"Blitmap","time":0},{"type":"external-function ","before":" }\n\n    function mintOriginal(bytes memory tokenData, string memory name) public onlyAllowed {\n        require(published == false, \"b:01\");\n        require(_numOriginals < _maxNumOriginals, \"b:03\");\n        require(tokenData.length == 268, \"b:04\"); // any combination of 268 bytes is technically a valid blit\n        require(bytes(name).length > 0 && bytes(name).length < 11, \"b:05\");\n        require(_allowedList[msg.sender].remainingMints > 0, \"b:06\");\n\n        uint256 tokenId = totalSupply();\n\n        _tokenDataIndex.push(tokenData);\n\n        TokenMetadata memory metadata;\n        metadata.name = name;\n        metadata.remainingVariants = _maxNumVariants;\n        metadata.creator = msg.sender;\n        _allowedList[msg.sender].remainingMints--;\n        _tokenMetadataIndex.push(metadata);\n\n        _numOriginals++;\n\n        _safeMint(msg.sender, tokenId","after":" }\n\n    function mintOriginal(bytes calldata tokenData, string memory name) public onlyAllowed {\n        require(published == false, \"b:01\");\n        require(_numOriginals < _maxNumOriginals, \"b:03\");\n        require(tokenData.length == 268, \"b:04\"); // any combination of 268 bytes is technically a valid blit\n        require(bytes(name).length > 0 && bytes(name).length < 11, \"b:05\");\n        require(_allowedList[msg.sender].remainingMints > 0, \"b:06\");\n\n        uint256 tokenId = totalSupply();\n\n        _tokenDataIndex.push(tokenData);\n\n        TokenMetadata memory metadata;\n        metadata.name = name;\n        metadata.remainingVariants = _maxNumVariants;\n        metadata.creator = msg.sender;\n        _allowedList[msg.sender].remainingMints--;\n        _tokenMetadataIndex.push(metadata);\n\n        _numOriginals++;\n\n        _safeMint(msg.sender, tokenId","contract":"Blitmap","time":0},{"type":"immutable-restrict-modification ","before":" }\n\n    address private","after":" }\n\n    address private","contract":"Blitmap","time":1}]}