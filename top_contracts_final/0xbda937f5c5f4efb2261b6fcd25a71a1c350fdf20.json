{"time":432,"results":[{"type":"loop-duplication","before":"\nstart line 2458 column 12, end line 2460 column 12\nfor (uint256 i = 0; i < len1; i++) {\n                factors[i] = parent1Factors[i];\n            }\nstart line 2461 column 12, end line 2463 column 12\nfor (uint256 i = 0; i < len2; i++) {\n                factors[len1 + i] = parent2Factors[i];\n            }","after":"// merge loop\n\nstart line 2458 column 12, end line 2460 column 12\nfor (uint256 i = 0; i < len1; i++) {\n                factors[i] = parent1Factors[i];\n            }\nstart line 2461 column 12, end line 2463 column 12\nfor (uint256 i = 0; i < len2; i++) {\n                factors[len1 + i] = parent2Factors[i];\n            }","contract":"Primes","time":0},{"type":"external-function ","before":"function breedPrimes(\n        uint16 _parent1,\n        uint16 _parent2,\n        uint256 _attributes,\n        bytes32[] memory _merkleProof\n    ) external nonReentrant {\n        BreedInput memory input1 = _getInput(_parent1);\n        BreedInput memory input2 = _getInput(_parent2);\n        require(input1.owns && input2.owns, \"Breeder must own input token\");\n        _breed(input1, input2, _attributes, _merkleProof);\n    }","after":"function breedPrimes(\n        uint16 _parent1,\n        uint16 _parent2,\n        uint256 _attributes,\n        bytes32[] calldata _merkleProof\n    ) external nonReentrant {\n        BreedInput memory input1 = _getInput(_parent1);\n        BreedInput memory input2 = _getInput(_parent2);\n        require(input1.owns && input2.owns, \"Breeder must own input token\");\n        _breed(input1, input2, _attributes, _merkleProof);\n    }","contract":"Primes","time":0},{"type":"external-function ","before":"function crossBreed(\n        uint16 _parent1,\n        uint16 _parent2,\n        uint256 _attributes,\n        bytes32[] memory _merkleProof\n    ) external payable nonReentrant {\n        BreedInput memory input1 = _getInput(_parent1);\n        BreedInput memory input2 = _getInput(_parent2);\n        require(input1.owns, \"Must own first input\");\n        require(input2.rentalData.isRentable, \"Must be rentable\");\n        require(msg.value >= input2.rentalData.studFee, \"Must pay stud fee\");\n        payable(input2.owner).transfer((msg.value * 9) / 10);\n        require(block.timestamp < input2.rentalData.deadline, \"Rental passed deadline\");\n        if (input2.rentalData.whitelistOnly) {\n            bool isSuitor;\n            for (uint256 i = 0; i < 6; i++) {\n                isSuitor = isSuitor || input2.rentalData.suitors[i] == _parent1;\n            }\n            require(isSuitor, \"Must be whitelisted suitor\");\n        }\n        _breed(input1, input2, _attributes, _merkleProof);\n    }","after":"function crossBreed(\n        uint16 _parent1,\n        uint16 _parent2,\n        uint256 _attributes,\n        bytes32[] calldata _merkleProof\n    ) external payable nonReentrant {\n        BreedInput memory input1 = _getInput(_parent1);\n        BreedInput memory input2 = _getInput(_parent2);\n        require(input1.owns, \"Must own first input\");\n        require(input2.rentalData.isRentable, \"Must be rentable\");\n        require(msg.value >= input2.rentalData.studFee, \"Must pay stud fee\");\n        payable(input2.owner).transfer((msg.value * 9) / 10);\n        require(block.timestamp < input2.rentalData.deadline, \"Rental passed deadline\");\n        if (input2.rentalData.whitelistOnly) {\n            bool isSuitor;\n            for (uint256 i = 0; i < 6; i++) {\n                isSuitor = isSuitor || input2.rentalData.suitors[i] == _parent1;\n            }\n            require(isSuitor, \"Must be whitelisted suitor\");\n        }\n        _breed(input1, input2, _attributes, _merkleProof);\n    }","contract":"Primes","time":0},{"type":"external-function ","before":"function list(\n        uint16 _tokenId,\n        uint96 _fee,\n        uint32 _deadline,\n        uint16[] memory _suitors\n    ) external {\n        require(msg.sender == ownerOf(_tokenId), \"Must own said token\");\n\n        uint16[6] memory suitors;\n        uint256 len = _suitors.length;\n        if (len > 0) {\n            require(len < 6, \"Max 6 suitors\");\n            for (uint256 i = 0; i < len; i++) {\n                suitors[i] = _suitors[i];\n            }\n        }\n\n        rental[_tokenId] = RentalData({\n            isRentable: true,\n            whitelistOnly: len > 0,\n            studFee: _fee,\n            deadline: _deadline,\n            suitors: suitors\n        });\n\n        emit Listed(_tokenId);\n    }","after":"function list(\n        uint16 _tokenId,\n        uint96 _fee,\n        uint32 _deadline,\n        uint16[] calldata _suitors\n    ) external {\n        require(msg.sender == ownerOf(_tokenId), \"Must own said token\");\n\n        uint16[6] memory suitors;\n        uint256 len = _suitors.length;\n        if (len > 0) {\n            require(len < 6, \"Max 6 suitors\");\n            for (uint256 i = 0; i < len; i++) {\n                suitors[i] = _suitors[i];\n            }\n        }\n\n        rental[_tokenId] = RentalData({\n            isRentable: true,\n            whitelistOnly: len > 0,\n            studFee: _fee,\n            deadline: _deadline,\n            suitors: suitors\n        });\n\n        emit Listed(_tokenId);\n    }","contract":"Primes","time":0},{"type":"external-function ","before":"function mintRandomPrime(\n        uint256 _batch0Cap,\n        uint256 _batch1Cap,\n        bytes32[] memory _merkleProof\n    ) external payable {\n        mintRandomPrimes(1, _batch0Cap, _batch1Cap, _merkleProof);\n    }","after":"function mintRandomPrime(\n        uint256 _batch0Cap,\n        uint256 _batch1Cap,\n        bytes32[] calldata _merkleProof\n    ) external payable {\n        mintRandomPrimes(1, _batch0Cap, _batch1Cap, _merkleProof);\n    }","contract":"Primes","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(verify(userAddress, metaTx, sigR, sigS, sigV), \"Signer and signature do not match\");\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] += 1;\n\n        emit MetaTransactionExecuted(userAddress, payable(msg.sender), functionSignature);\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(verify(userAddress, metaTx, sigR, sigS, sigV), \"Signer and signature do not match\");\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] += 1;\n\n        emit MetaTransactionExecuted(userAddress, payable(msg.sender), functionSignature);\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"Primes","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public whitelistRootHash;","after":"bytes32 public immutable whitelistRootHash;","contract":"Primes","time":1},{"type":"immutable-restrict-modification ","before":"address public proxyRegistryAddress;","after":"address public immutable proxyRegistryAddress;","contract":"Primes","time":1},{"type":"constant-restrict-modification  ","before":"uint256 private _currentTokenId = 0;","after":"uint256 private constant _currentTokenId = 0;","contract":"Primes","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 public attributesRootHash;","after":"bytes32 public immutable attributesRootHash;","contract":"Primes","time":1}]}