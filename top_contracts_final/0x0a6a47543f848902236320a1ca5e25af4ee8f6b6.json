{"time":195,"results":[{"type":"external-function ","before":"function setBaseURI(string memory baseURI) public onlyOwner {\n        baseTokenURI = baseURI;\n    }","after":"function setBaseURI(string calldata baseURI) public onlyOwner {\n        baseTokenURI = baseURI;\n    }","contract":"BlockchainOfFame","time":0},{"type":"external-function ","before":"function setCustomTokenURI(uint256 tokenId, string memory _tokenURI) public onlyOwner {\n        _setTokenURI(tokenId, _tokenURI);\n    }","after":"function setCustomTokenURI(uint256 tokenId, string calldata _tokenURI) public onlyOwner {\n        _setTokenURI(tokenId, _tokenURI);\n    }","contract":"BlockchainOfFame","time":0},{"type":"external-function ","before":"function mintBof(string memory newName, string memory _tokenURI) public payable {\n        require(saleIsOpen, \"Sale must be active to mint NFT\");\n        require(msg.value == PRICE, \"Ether value sent is not correct\");\n        require(max_mints_per_address[msg.sender].add(1) <= 10,\"Max 10 mints per wallet allowed\");\n        \n            if (tokenCounter < MAX_ELEMENTS) {\n                \n                _safeMint(msg.sender, tokenCounter);\n\t\t\t\tchangeName(tokenCounter,newName);\n                _setTokenURI(tokenCounter,_tokenURI);\n                max_mints_per_address[msg.sender] = max_mints_per_address[msg.sender].add(1);\n                tokenCounter = tokenCounter + 1;\n            } else {\n               saleIsOpen = !saleIsOpen;\n               payable(msg.sender).transfer(PRICE);\n            }\n    }","after":"function mintBof(string calldata newName, string calldata _tokenURI) public payable {\n        require(saleIsOpen, \"Sale must be active to mint NFT\");\n        require(msg.value == PRICE, \"Ether value sent is not correct\");\n        require(max_mints_per_address[msg.sender].add(1) <= 10,\"Max 10 mints per wallet allowed\");\n        \n            if (tokenCounter < MAX_ELEMENTS) {\n                \n                _safeMint(msg.sender, tokenCounter);\n\t\t\t\tchangeName(tokenCounter,newName);\n                _setTokenURI(tokenCounter,_tokenURI);\n                max_mints_per_address[msg.sender] = max_mints_per_address[msg.sender].add(1);\n                tokenCounter = tokenCounter + 1;\n            } else {\n               saleIsOpen = !saleIsOpen;\n               payable(msg.sender).transfer(PRICE);\n            }\n    }","contract":"BlockchainOfFame","time":0},{"type":"external-function ","before":"function mintCustom(string memory newName) public payable {\n\t\trequire(bofCustomReserve >= 1, \"All custom NFTs already minted\");\n        require(saleIsOpen, \"Sale must be active to mint NFT\");\n        require(msg.value == CUSTOMPRICE, \"Ether value sent is not correct\");\n        require(max_mints_per_address[msg.sender].add(1) <= 10,\"Max 10 mints per wallet allowed\");\n        \n            if (tokenCounter < MAX_ELEMENTS) {\n                \n                _safeMint(msg.sender, tokenCounter);\n\t\t\t\tchangeName(tokenCounter,newName);\n                max_mints_per_address[msg.sender] = max_mints_per_address[msg.sender].add(1);\n\t\t\t\tbofCustomReserve = bofCustomReserve.sub(1);\n                tokenCounter = tokenCounter + 1;\n            } else {\n               saleIsOpen = !saleIsOpen;\n               payable(msg.sender).transfer(PRICE);\n            }\n    }","after":"function mintCustom(string calldata newName) public payable {\n\t\trequire(bofCustomReserve >= 1, \"All custom NFTs already minted\");\n        require(saleIsOpen, \"Sale must be active to mint NFT\");\n        require(msg.value == CUSTOMPRICE, \"Ether value sent is not correct\");\n        require(max_mints_per_address[msg.sender].add(1) <= 10,\"Max 10 mints per wallet allowed\");\n        \n            if (tokenCounter < MAX_ELEMENTS) {\n                \n                _safeMint(msg.sender, tokenCounter);\n\t\t\t\tchangeName(tokenCounter,newName);\n                max_mints_per_address[msg.sender] = max_mints_per_address[msg.sender].add(1);\n\t\t\t\tbofCustomReserve = bofCustomReserve.sub(1);\n                tokenCounter = tokenCounter + 1;\n            } else {\n               saleIsOpen = !saleIsOpen;\n               payable(msg.sender).transfer(PRICE);\n            }\n    }","contract":"BlockchainOfFame","time":0},{"type":"external-function ","before":"function whitelistedMints(string memory newName, string memory _tokenURI, bytes32[] calldata merkleProof ) payable external  {\n        address user_ = msg.sender;\n\n        require(saleIsOpen, \"Sale must be active to mint NFT\");\n        require(msg.value == WHITELISTPRICE, \"Ether value sent is not correct\");\n        require(max_mints_per_address[msg.sender].add(1) <= 10,\"Max 10 mints per wallet allowed\");\n\n        // Verify the merkle proof\n        require(MerkleProof.verify(merkleProof, merkleRoot,  keccak256(abi.encodePacked(user_))  ), \"Invalid proof\");\n\t\t\n            if (tokenCounter < MAX_ELEMENTS) {\n                \n                _safeMint(msg.sender, tokenCounter);\n\t\t\t\tchangeName(tokenCounter,newName);\n                _setTokenURI(tokenCounter,_tokenURI);\n                max_mints_per_address[msg.sender] = max_mints_per_address[msg.sender].add(1);\n                tokenCounter = tokenCounter + 1;\n            } else {\n               saleIsOpen = !saleIsOpen;\n               payable(msg.sender).transfer(PRICE);\n            }\n\n        emit WhitelistedMint(user_);\n    }","after":"function whitelistedMints(string calldata newName, string calldata _tokenURI, bytes32[] calldata merkleProof ) payable external  {\n        address user_ = msg.sender;\n\n        require(saleIsOpen, \"Sale must be active to mint NFT\");\n        require(msg.value == WHITELISTPRICE, \"Ether value sent is not correct\");\n        require(max_mints_per_address[msg.sender].add(1) <= 10,\"Max 10 mints per wallet allowed\");\n\n        // Verify the merkle proof\n        require(MerkleProof.verify(merkleProof, merkleRoot,  keccak256(abi.encodePacked(user_))  ), \"Invalid proof\");\n\t\t\n            if (tokenCounter < MAX_ELEMENTS) {\n                \n                _safeMint(msg.sender, tokenCounter);\n\t\t\t\tchangeName(tokenCounter,newName);\n                _setTokenURI(tokenCounter,_tokenURI);\n                max_mints_per_address[msg.sender] = max_mints_per_address[msg.sender].add(1);\n                tokenCounter = tokenCounter + 1;\n            } else {\n               saleIsOpen = !saleIsOpen;\n               payable(msg.sender).transfer(PRICE);\n            }\n\n        emit WhitelistedMint(user_);\n    }","contract":"BlockchainOfFame","time":0},{"type":"external-function ","before":"function reserveBOF(address _to, string memory newName, string memory _tokenURI) public onlyOwner {        \n        require(bofReserve >= 1, \"Not enough reserve\");\n            supply = tokenCounter;\n            _safeMint(_to, supply);\n\t\t\tchangeName(supply,newName);\n\t\t\t_setTokenURI(tokenCounter,_tokenURI);\n            bofReserve = bofReserve.sub(1);\n            tokenCounter = tokenCounter + 1;\n    }","after":"function reserveBOF(address _to, string calldata newName, string calldata _tokenURI) public onlyOwner {        \n        require(bofReserve >= 1, \"Not enough reserve\");\n            supply = tokenCounter;\n            _safeMint(_to, supply);\n\t\t\tchangeName(supply,newName);\n\t\t\t_setTokenURI(tokenCounter,_tokenURI);\n            bofReserve = bofReserve.sub(1);\n            tokenCounter = tokenCounter + 1;\n    }","contract":"BlockchainOfFame","time":0},{"type":"constant-restrict-modification  ","before":"address public creator1Address = 0x3116303B3787e298e1735dD540e81eb547FBf77C;","after":"address public constant creator1Address = 0x3116303B3787e298e1735dD540e81eb547FBf77C;","contract":"BlockchainOfFame","time":1},{"type":"constant-restrict-modification  ","before":"address public creator2Address = 0x5cA9cA6D35AFa49BCDAF8f23C400Ec6de1F0b627;","after":"address public constant creator2Address = 0x5cA9cA6D35AFa49BCDAF8f23C400Ec6de1F0b627;","contract":"BlockchainOfFame","time":1}]}