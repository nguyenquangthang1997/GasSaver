{"time":179,"results":[{"type":"state-data-arrangement ","before":"\n███╗██║██╔══██║██║   ██║    \n║╚════██║    ╚════██║██╔══\n║██║╚██╔╝██║██\n██║   ██║        \n�══╝\r\n// ╚███╔██�\n�██║  ██║╚███\n█╔╝    ██║████�\n�║    ████�\n��║██║  █�\n��█║ ╚═╝ █�\n1Tradable {\r\n    using SafeMath for uint256;\r\n ","after":"║██║╚██╔╝██║██\n██║   ██║        \n�══╝\r\n// ╚███╔██�\n�║    ████�\n��║██║  █�\n��█║ ╚═╝ █�\n1Tradable {\r\n    using SafeMath for uint256;\r\n \n███╗██║██╔══██║██║   ██║    \n║╚════██║    ╚════██║██╔══\n�██║  ██║╚███\n█╔╝    ██║████�\n","contract":"WhoIsSamot","time":0},{"type":"external-function ","before":"_SUPPLY = 8888;\r\n    uint256 public maxToMint = 5;\r\n    uint256 public maxToMintWhitelist = 5;\r\n    b","after":"_SUPPLY = 8888;\r\n    uint256 public maxToMint = 5;\r\n    uint256 public maxToMintWhitelist = 5;\r\n    b","contract":"WhoIsSamot","time":0},{"type":"external-function ","before":" _contractURI;\r\n    address[] whitelistAddr;\r\n\r\n    constructor(address _proxyRegistryAddress, addr","after":" _contractURI;\r\n    address[] whitelistAddr;\r\n\r\n    constructor(address _proxyRegistryAddress, addr","contract":"WhoIsSamot","time":0},{"type":"external-function ","before":"xToMint) external onlyOwner {\r\n        maxToMint = _maxToMint;\r\n    }\r\n\r\n    function setMaxToMintWhitelist(uint256 _maxToMint) external onlyOwner {\r\n        maxToMintWhitelist = _maxToMint;\r\n    }\r\n\r\n    function flipSaleState() public onlyOwner {\r\n        saleIsActive = !saleIsActive;\r\n    }\r\n\r\n    function flipPreSal","after":"xToMint) external onlyOwner {\r\n        maxToMint = _maxToMint;\r\n    }\r\n\r\n    function setMaxToMintWhitelist(uint256 _maxToMint) external onlyOwner {\r\n        maxToMintWhitelist = _maxToMint;\r\n    }\r\n\r\n    function flipSaleState() public onlyOwner {\r\n        saleIsActive = !saleIsActive;\r\n    }\r\n\r\n    function flipPreSal","contract":"WhoIsSamot","time":0},{"type":"external-function ","before":"utils/math/SafeMath.sol\";\r\nimport {EIP712Base} from \"./EIP712Base.sol\";\r\n\r\ncontract NativeMetaTransaction is EIP712Base {\r\n    using SafeMath for uint256;\r\n    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(\r\n        bytes(\r\n            \"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\"\r\n        )\r\n    );\r\n    event MetaTransactionExecuted(\r\n        address userAddress,\r\n        address payable relayerAddress,\r\n        bytes functionSignature\r\n    );\r\n    mapping(address => uint256) nonces;\r\n\r\n    /*\r\n     * Meta transaction structure.\r\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\r\n     * He should call the desired function directly in that case.\r\n     */\r\n    struct MetaTransaction {\r\n        uint256 nonce;\r\n        address from;\r\n        bytes functionSignature;\r\n    }\r\n\r\n    function executeMetaTransaction(\r\n        address userAddress,\r\n        bytes memory functionSignature,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        uint8 sigV\r\n    ) public payable returns (bytes memory) {\r\n        MetaTransaction memory metaT","after":"utils/math/SafeMath.sol\";\r\nimport {EIP712Base} from \"./EIP712Base.sol\";\r\n\r\ncontract NativeMetaTransaction is EIP712Base {\r\n    using SafeMath for uint256;\r\n    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(\r\n        bytes(\r\n            \"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\"\r\n        )\r\n    );\r\n    event MetaTransactionExecuted(\r\n        address userAddress,\r\n        address payable relayerAddress,\r\n        bytes functionSignature\r\n    );\r\n    mapping(address => uint256) nonces;\r\n\r\n    /*\r\n     * Meta transaction structure.\r\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\r\n     * He should call the desired function directly in that case.\r\n     */\r\n    struct MetaTransaction {\r\n        uint256 nonce;\r\n        address from;\r\n        bytes functionSignature;\r\n    }\r\n\r\n    function executeMetaTransaction(\r\n        address userAddress,\r\n        bytes memory functionSignature,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        uint8 sigV\r\n    ) public payable returns (bytes memory) {\r\n        MetaTransaction memory metaT","contract":"WhoIsSamot","time":0},{"type":"immutable-restrict-modification ","before":"solidity ^0.8.0;\r\n\r\nimport \"o","after":"solidity ^0.8.0;\r\n\r\nimport \"o","contract":"WhoIsSamot","time":1}]}