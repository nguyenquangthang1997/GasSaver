{"time":204,"results":[{"type":"loop-duplication","before":"\nstart line 1681 column 8, end line 1686 column 8\nfor (uint i = 0; i < forkIds.length; i++) {\n            uint id = forkIds[i];\n            uint256 amount = amountToSpend[i];\n            require(msg.sender == ownerOf(id), \"You do not own the NonFungibleForks you specified.\");\n            require(getForkMagic(id) >= amount, \"Insufficient NonFungibleForks magic.\");\n        }\nstart line 1688 column 8, end line 1695 column 8\nfor (uint i = 0; i < forkIds.length; i++) {\n            uint id = forkIds[i];\n            uint amount = amountToSpend[i];\n            ForkMagic storage forkMagic = forkMagicLevels[id];\n            forkMagic.magic = getForkMagic(id).sub(amount);\n            forkMagic.lastTimestamp = block.timestamp;\n            totalSpent = totalSpent.add(amount);\n        }","after":"// merge loop\n\nstart line 1681 column 8, end line 1686 column 8\nfor (uint i = 0; i < forkIds.length; i++) {\n            uint id = forkIds[i];\n            uint256 amount = amountToSpend[i];\n            require(msg.sender == ownerOf(id), \"You do not own the NonFungibleForks you specified.\");\n            require(getForkMagic(id) >= amount, \"Insufficient NonFungibleForks magic.\");\n        }\nstart line 1688 column 8, end line 1695 column 8\nfor (uint i = 0; i < forkIds.length; i++) {\n            uint id = forkIds[i];\n            uint amount = amountToSpend[i];\n            ForkMagic storage forkMagic = forkMagicLevels[id];\n            forkMagic.magic = getForkMagic(id).sub(amount);\n            forkMagic.lastTimestamp = block.timestamp;\n            totalSpent = totalSpent.add(amount);\n        }","contract":"NonFungibleForks","time":0},{"type":"external-function ","before":"function spendForkMagic(uint[] memory forkIds, uint256[] memory amountToSpend) public returns (uint256) {\n        require(forkIds.length == amountToSpend.length, \"You must provide a 1-to-1 relationship of magic amounts to spend from your NonFungibleForks.\");\n        require(!checkDuplicates(forkIds), \"You may not buy from the same coin per transaction.\");\n        require(forkIds.length <= 10, \"You can only spend from 10 NonFungibleForks at a time.\");\n        uint256 totalSpent = 0;\n        // Loop through first to make sure the owner actually owns all their NonFungibleForks and has enough magic in them.\n        for (uint i = 0; i < forkIds.length; i++) {\n            uint id = forkIds[i];\n            uint256 amount = amountToSpend[i];\n            require(msg.sender == ownerOf(id), \"You do not own the NonFungibleForks you specified.\");\n            require(getForkMagic(id) >= amount, \"Insufficient NonFungibleForks magic.\");\n        }\n        // See `upgradeForkPower` comments for explanation on why the NonFungibleForks' magics and `lastTimestamp` are updated.\n        for (uint i = 0; i < forkIds.length; i++) {\n            uint id = forkIds[i];\n            uint amount = amountToSpend[i];\n            ForkMagic storage forkMagic = forkMagicLevels[id];\n            forkMagic.magic = getForkMagic(id).sub(amount);\n            forkMagic.lastTimestamp = block.timestamp;\n            totalSpent = totalSpent.add(amount);\n        }\n        // The total magic that was spent is returned, so it can be used with future apps and integrations.\n        return totalSpent;\n    }","after":"function spendForkMagic(uint[] calldata forkIds, uint256[] calldata amountToSpend) public returns (uint256) {\n        require(forkIds.length == amountToSpend.length, \"You must provide a 1-to-1 relationship of magic amounts to spend from your NonFungibleForks.\");\n        require(!checkDuplicates(forkIds), \"You may not buy from the same coin per transaction.\");\n        require(forkIds.length <= 10, \"You can only spend from 10 NonFungibleForks at a time.\");\n        uint256 totalSpent = 0;\n        // Loop through first to make sure the owner actually owns all their NonFungibleForks and has enough magic in them.\n        for (uint i = 0; i < forkIds.length; i++) {\n            uint id = forkIds[i];\n            uint256 amount = amountToSpend[i];\n            require(msg.sender == ownerOf(id), \"You do not own the NonFungibleForks you specified.\");\n            require(getForkMagic(id) >= amount, \"Insufficient NonFungibleForks magic.\");\n        }\n        // See `upgradeForkPower` comments for explanation on why the NonFungibleForks' magics and `lastTimestamp` are updated.\n        for (uint i = 0; i < forkIds.length; i++) {\n            uint id = forkIds[i];\n            uint amount = amountToSpend[i];\n            ForkMagic storage forkMagic = forkMagicLevels[id];\n            forkMagic.magic = getForkMagic(id).sub(amount);\n            forkMagic.lastTimestamp = block.timestamp;\n            totalSpent = totalSpent.add(amount);\n        }\n        // The total magic that was spent is returned, so it can be used with future apps and integrations.\n        return totalSpent;\n    }","contract":"NonFungibleForks","time":1},{"type":"external-function ","before":"function setProvenanceHash(string memory _hash) public onlyOwner {\n        METADATA_PROVENANCE_HASH = _hash;\n    }","after":"function setProvenanceHash(string calldata _hash) public onlyOwner {\n        METADATA_PROVENANCE_HASH = _hash;\n    }","contract":"NonFungibleForks","time":0},{"type":"external-function ","before":"function setBaseURI(string memory newBaseURI) public onlyOwner {\n        baseURI = newBaseURI;\n    }","after":"function setBaseURI(string calldata newBaseURI) public onlyOwner {\n        baseURI = newBaseURI;\n    }","contract":"NonFungibleForks","time":0},{"type":"external-function ","before":"function giveAwayMany(address[] memory recipients) public nonReentrant() onlyOwner {\n        require(totalSupply().add(recipients.length) < MAX_FORKS, \"Not enough forks remain.\");\n        for (uint i = 0; i < recipients.length; i++) {\n            address giveawayTo = recipients[i];\n            _safeMint(giveawayTo, curIndex);\n            initializeForkMagic(curIndex);\n            adjustIndex();\n        }\n    }","after":"function giveAwayMany(address[] calldata recipients) public nonReentrant() onlyOwner {\n        require(totalSupply().add(recipients.length) < MAX_FORKS, \"Not enough forks remain.\");\n        for (uint i = 0; i < recipients.length; i++) {\n            address giveawayTo = recipients[i];\n            _safeMint(giveawayTo, curIndex);\n            initializeForkMagic(curIndex);\n            adjustIndex();\n        }\n    }","contract":"NonFungibleForks","time":0}]}