{"time":235,"results":[{"type":"loop-duplication","before":"\nstart line 680 column 8, end line 682 column 8\nfor (uint256 i = 0; i < ids.length; i++) {\n            require(_owners[ids[i]] == account, 'Error: account is not owner of token id');\n        }\nstart line 685 column 8, end line 690 column 8\nfor (uint256 i = 0; i < ids.length; i++) {\n            _beforeTokenTransfer(account, address(0), ids[i]);\n            _owners[ids[i]] = address(0);\n            _balances[account] -= 1;\n            emit Transfer(account, address(0), ids[i]);\n        }","after":"// merge loop\n\nstart line 680 column 8, end line 682 column 8\nfor (uint256 i = 0; i < ids.length; i++) {\n            require(_owners[ids[i]] == account, 'Error: account is not owner of token id');\n        }\nstart line 685 column 8, end line 690 column 8\nfor (uint256 i = 0; i < ids.length; i++) {\n            _beforeTokenTransfer(account, address(0), ids[i]);\n            _owners[ids[i]] = address(0);\n            _balances[account] -= 1;\n            emit Transfer(account, address(0), ids[i]);\n        }","contract":"DivineAnarchyToken","time":0},{"type":"de-morgan-condition ","before":"!exists(randomNumber) && !inArray","after":"!(exists(randomNumber) && inArray)","loc":{"start":{"line":943,"column":15},"end":{"line":943,"column":41}},"contract":"DivineAnarchyToken","time":0},{"type":"de-morgan-condition ","before":"!toRescue && !oracleForced","after":"!(toRescue && oracleForced)","loc":{"start":{"line":965,"column":11},"end":{"line":965,"column":25}},"contract":"DivineAnarchyToken","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseURI_) external onlyOwner {\n        _baseURI = baseURI_;\n    }","after":"function setBaseURI(string calldata baseURI_) external onlyOwner {\n        _baseURI = baseURI_;\n    }","contract":"DivineAnarchyToken","time":0},{"type":"external-function ","before":"function airdropToTreasury(uint256[][] memory treasuryRandom) external onlyOwner {\n        address divineTreasuryWallet = adminWallets.getDivineTreasuryWallet();\n        require(!paused(), \"Error: token transfer while paused\");\n        uint256[] memory tokenIds = treasuryRandom[0];\n        uint256[] memory classIds = treasuryRandom[1];\n        require(classIds.length == tokenIds.length);\n        uint256 amount = tokenIds.length;\n        require(_mintedToTreasury + amount <= MAX_MINTED_TO_TREASURY, 'Error: you are exceeding the max airdrop amount to Treasury');\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _beforeTokenTransfer(address(0), divineTreasuryWallet, tokenIds[i]);\n            _balances[divineTreasuryWallet] += 1;\n            _owners[tokenIds[i]] = divineTreasuryWallet;\n            _tokenClass[tokenIds[i]] = classIds[i];\n            _tokenClassSupplyCurrent[classIds[i]] += 1;\n            emit Transfer(address(0), divineTreasuryWallet, tokenIds[i]);\n        }\n\n        _mintedToTreasury += amount;\n\n        if(_mintedToTreasury == MAX_MINTED_TO_TREASURY) {\n            _mintedToTreasuryHasFinished = true;\n        }\n    }","after":"function airdropToTreasury(uint256[][] calldata treasuryRandom) external onlyOwner {\n        address divineTreasuryWallet = adminWallets.getDivineTreasuryWallet();\n        require(!paused(), \"Error: token transfer while paused\");\n        uint256[] memory tokenIds = treasuryRandom[0];\n        uint256[] memory classIds = treasuryRandom[1];\n        require(classIds.length == tokenIds.length);\n        uint256 amount = tokenIds.length;\n        require(_mintedToTreasury + amount <= MAX_MINTED_TO_TREASURY, 'Error: you are exceeding the max airdrop amount to Treasury');\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _beforeTokenTransfer(address(0), divineTreasuryWallet, tokenIds[i]);\n            _balances[divineTreasuryWallet] += 1;\n            _owners[tokenIds[i]] = divineTreasuryWallet;\n            _tokenClass[tokenIds[i]] = classIds[i];\n            _tokenClassSupplyCurrent[classIds[i]] += 1;\n            emit Transfer(address(0), divineTreasuryWallet, tokenIds[i]);\n        }\n\n        _mintedToTreasury += amount;\n\n        if(_mintedToTreasury == MAX_MINTED_TO_TREASURY) {\n            _mintedToTreasuryHasFinished = true;\n        }\n    }","contract":"DivineAnarchyToken","time":0},{"type":"external-function ","before":"function mint(address account, uint256 amount, bytes32[] memory proof) external nonReentrant payable {\n        // Pre minting checks.\n        address operator = _msgSender();\n\n        require(msg.value >= TOKEN_UNIT_PRICE * amount, 'Make sure you can afford 0.09 eth per token');\n        require(account != address(0), \"Error: mint to the zero address\");\n        require(!paused(), \"Error: token transfer while paused\");\n        require(_mintedToTreasuryHasFinished == true, 'Error: Wait until airdropping to Treasury has finished');\n        if (isPresaleActive == true) {\n            require(_tokensMintedByAddressAtPresale[operator] + amount <= MAX_TOKENS_MINTED_BY_ADDRESS_PRESALE, 'Error: you cannot mint more tokens at presale');\n            require(MerkleProof.verify(proof, root, keccak256(abi.encodePacked(operator))), \"you are not allowed to mint during presale\");\n        } else {\n            require(_tokensMintedByAddress[operator] + amount <= MAX_TOKENS_MINTED_BY_ADDRESS, 'Error: you cannot mint more tokens');\n        }\n\n        uint256[][] memory randomList = getRand(amount);\n        uint256[] memory tokensIds = randomList[0];\n        uint256[] memory classIds = randomList[1];\n\n        for (uint256 i = 0; i < amount; i++) {\n            _beforeTokenTransfer(address(0), account, tokensIds[i]);\n\n            _owners[tokensIds[i]] = account;\n            _balances[account] += 1;\n            _tokenClass[tokensIds[i]] = classIds[i];\n            _tokenClassSupplyCurrent[classIds[i]] += 1;\n\n            emit Transfer(address(0), account, tokensIds[i]);\n        }\n\n        // Post minting.\n        if (isPresaleActive == true) {\n            _tokensMintedByAddressAtPresale[operator] += amount;\n        } else {\n            _tokensMintedByAddress[operator] += amount;\n        }\n    }","after":"function mint(address account, uint256 amount, bytes32[] calldata proof) external nonReentrant payable {\n        // Pre minting checks.\n        address operator = _msgSender();\n\n        require(msg.value >= TOKEN_UNIT_PRICE * amount, 'Make sure you can afford 0.09 eth per token');\n        require(account != address(0), \"Error: mint to the zero address\");\n        require(!paused(), \"Error: token transfer while paused\");\n        require(_mintedToTreasuryHasFinished == true, 'Error: Wait until airdropping to Treasury has finished');\n        if (isPresaleActive == true) {\n            require(_tokensMintedByAddressAtPresale[operator] + amount <= MAX_TOKENS_MINTED_BY_ADDRESS_PRESALE, 'Error: you cannot mint more tokens at presale');\n            require(MerkleProof.verify(proof, root, keccak256(abi.encodePacked(operator))), \"you are not allowed to mint during presale\");\n        } else {\n            require(_tokensMintedByAddress[operator] + amount <= MAX_TOKENS_MINTED_BY_ADDRESS, 'Error: you cannot mint more tokens');\n        }\n\n        uint256[][] memory randomList = getRand(amount);\n        uint256[] memory tokensIds = randomList[0];\n        uint256[] memory classIds = randomList[1];\n\n        for (uint256 i = 0; i < amount; i++) {\n            _beforeTokenTransfer(address(0), account, tokensIds[i]);\n\n            _owners[tokensIds[i]] = account;\n            _balances[account] += 1;\n            _tokenClass[tokensIds[i]] = classIds[i];\n            _tokenClassSupplyCurrent[classIds[i]] += 1;\n\n            emit Transfer(address(0), account, tokensIds[i]);\n        }\n\n        // Post minting.\n        if (isPresaleActive == true) {\n            _tokensMintedByAddressAtPresale[operator] += amount;\n        } else {\n            _tokensMintedByAddress[operator] += amount;\n        }\n    }","contract":"DivineAnarchyToken","time":0},{"type":"external-function ","before":"function burnBatch(address account, uint256[] memory ids) public {\n        // Pre burning checks.\n        address operator = _msgSender();\n        require(!paused(), \"Error: token transfer while paused\");\n\n        if (account != operator && isApprovedForAll(account, operator) == false) {\n            for (uint256 i = 0; i < ids.length; i++) {\n                require(getApproved(ids[i]) == operator, 'Error: caller is neither owner nor approved');\n            }\n        } \n\n        for (uint256 i = 0; i < ids.length; i++) {\n            require(_owners[ids[i]] == account, 'Error: account is not owner of token id');\n        }\n\n        // Burn process.\n        for (uint256 i = 0; i < ids.length; i++) {\n            _beforeTokenTransfer(account, address(0), ids[i]);\n            _owners[ids[i]] = address(0);\n            _balances[account] -= 1;\n            emit Transfer(account, address(0), ids[i]);\n        }\n\n        // Post burning.\n        for (uint256 i=0; i < ids.length; i++) {\n            _tokenApprovals[ids[i]] = address(0);\n        }\n    }","after":"function burnBatch(address account, uint256[] calldata ids) public {\n        // Pre burning checks.\n        address operator = _msgSender();\n        require(!paused(), \"Error: token transfer while paused\");\n\n        if (account != operator && isApprovedForAll(account, operator) == false) {\n            for (uint256 i = 0; i < ids.length; i++) {\n                require(getApproved(ids[i]) == operator, 'Error: caller is neither owner nor approved');\n            }\n        } \n\n        for (uint256 i = 0; i < ids.length; i++) {\n            require(_owners[ids[i]] == account, 'Error: account is not owner of token id');\n        }\n\n        // Burn process.\n        for (uint256 i = 0; i < ids.length; i++) {\n            _beforeTokenTransfer(account, address(0), ids[i]);\n            _owners[ids[i]] = address(0);\n            _balances[account] -= 1;\n            emit Transfer(account, address(0), ids[i]);\n        }\n\n        // Post burning.\n        for (uint256 i=0; i < ids.length; i++) {\n            _tokenApprovals[ids[i]] = address(0);\n        }\n    }","contract":"DivineAnarchyToken","time":0},{"type":"external-function ","before":"function airdropApples(uint256 amount, uint256 appleClass, address[] memory accounts) external override onlyOwner {        \n        require(accounts.length == amount, \"amount not egal to list length\");\n        require(appleClass == ASCENSION_APPLE || appleClass == BAD_APPLE, 'Error: The token class is not an apple');\n        require(_tokenClassSupplyCurrent[appleClass] + amount <= _tokenClassSupplyCap[appleClass], 'Error: You exceed the supply cap for this apple class');\n\n        uint256 appleIdSetter;\n\n        if (appleClass == ASCENSION_APPLE) {\n            appleIdSetter = _initAscensionApple + _tokenClassSupplyCurrent[ASCENSION_APPLE];\n        } else {\n            appleIdSetter = _initBadApple + _tokenClassSupplyCurrent[BAD_APPLE];\n        }\n\n        for (uint256 i = 0; i < accounts.length; i++) {\n            uint256 appleId = appleIdSetter + i;\n            _beforeTokenTransfer(address(0), accounts[i], appleId);\n            _owners[appleId] = accounts[i];\n            _balances[accounts[i]] += 1;\n            _tokenClass[appleId] = appleClass;\n        } \n\n        _tokenClassSupplyCurrent[appleClass] += amount;\n    }","after":"function airdropApples(uint256 amount, uint256 appleClass, address[] calldata accounts) external override onlyOwner {        \n        require(accounts.length == amount, \"amount not egal to list length\");\n        require(appleClass == ASCENSION_APPLE || appleClass == BAD_APPLE, 'Error: The token class is not an apple');\n        require(_tokenClassSupplyCurrent[appleClass] + amount <= _tokenClassSupplyCap[appleClass], 'Error: You exceed the supply cap for this apple class');\n\n        uint256 appleIdSetter;\n\n        if (appleClass == ASCENSION_APPLE) {\n            appleIdSetter = _initAscensionApple + _tokenClassSupplyCurrent[ASCENSION_APPLE];\n        } else {\n            appleIdSetter = _initBadApple + _tokenClassSupplyCurrent[BAD_APPLE];\n        }\n\n        for (uint256 i = 0; i < accounts.length; i++) {\n            uint256 appleId = appleIdSetter + i;\n            _beforeTokenTransfer(address(0), accounts[i], appleId);\n            _owners[appleId] = accounts[i];\n            _balances[accounts[i]] += 1;\n            _tokenClass[appleId] = appleClass;\n        } \n\n        _tokenClassSupplyCurrent[appleClass] += amount;\n    }","contract":"DivineAnarchyToken","time":0},{"type":"constant-restrict-modification  ","before":"uint256 private _initAscensionApple = 10011;","after":"uint256 private constant _initAscensionApple = 10011;","contract":"DivineAnarchyToken","time":1},{"type":"constant-restrict-modification  ","before":"uint256 private _initBadApple = 13011;","after":"uint256 private constant _initBadApple = 13011;","contract":"DivineAnarchyToken","time":1}]}