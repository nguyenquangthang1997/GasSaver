{"time":245,"results":[{"type":"de-morgan-condition ","before":"!uriLocked && !metadataFrozen[_id]","after":"!(uriLocked && metadataFrozen[_id])","loc":{"start":{"line":1055,"column":12},"end":{"line":1055,"column":45}},"contract":"Super1155","time":0},{"type":"state-data-arrangement ","before":"\nbytes32 public constant SET_URI = keccak256(\"SET_URI\");\nbytes32 public constant SET_PROXY_REGISTRY = keccak256(\"SET_PROXY_REGISTRY\");\nbytes32 public constant CONFIGURE_GROUP = keccak256(\"CONFIGURE_GROUP\");\nbytes32 public constant MINT = keccak256(\"MINT\");\nbytes32 public constant BURN = keccak256(\"BURN\");\nbytes32 public constant SET_METADATA = keccak256(\"SET_METADATA\");\nbytes32 public constant LOCK_URI = keccak256(\"LOCK_URI\");\nbytes32 public constant LOCK_ITEM_URI = keccak256(\"LOCK_ITEM_URI\");\nbytes32 public constant LOCK_CREATION = keccak256(\"LOCK_CREATION\");\nbytes4 private constant INTERFACE_ERC1155 = 0xd9b67a26;\nbytes4 private constant INTERFACE_ERC1155_METADATA_URI = 0x0e89341c;\nuint256 private constant GROUP_MASK = uint256(uint128(~0)) << 128;\nstring public name;\nstring public metadataUri;\naddress public proxyRegistryAddress;\nmapping (uint256 => mapping(address => uint256)) private balances;\nmapping (uint256 => mapping(address => uint256)) public groupBalances;\nmapping(address => uint256) public totalBalances;\nmapping (address => mapping(address => bool)) private operatorApprovals;\nmapping (uint256 => ItemGroup) public itemGroups;\nmapping (uint256 => uint256) public circulatingSupply;\nmapping (uint256 => uint256) public mintCount;\nmapping (uint256 => uint256) public burnCount;\nmapping (uint256 => bool) public metadataFrozen;\nmapping (uint256 => string) public metadata;\nbool public uriLocked;\nbool public locked;","after":"bytes32 public constant SET_URI = keccak256(\"SET_URI\");\nbytes32 public constant SET_PROXY_REGISTRY = keccak256(\"SET_PROXY_REGISTRY\");\nbytes32 public constant CONFIGURE_GROUP = keccak256(\"CONFIGURE_GROUP\");\nbytes32 public constant MINT = keccak256(\"MINT\");\nbytes32 public constant BURN = keccak256(\"BURN\");\nbytes32 public constant SET_METADATA = keccak256(\"SET_METADATA\");\nbytes32 public constant LOCK_URI = keccak256(\"LOCK_URI\");\nbytes32 public constant LOCK_ITEM_URI = keccak256(\"LOCK_ITEM_URI\");\nbytes32 public constant LOCK_CREATION = keccak256(\"LOCK_CREATION\");\nuint256 private constant GROUP_MASK = uint256(uint128(~0)) << 128;\nstring public name;\nstring public metadataUri;\nmapping (uint256 => mapping(address => uint256)) private balances;\nmapping (uint256 => mapping(address => uint256)) public groupBalances;\nmapping(address => uint256) public totalBalances;\nmapping (address => mapping(address => bool)) private operatorApprovals;\nmapping (uint256 => ItemGroup) public itemGroups;\nmapping (uint256 => uint256) public circulatingSupply;\nmapping (uint256 => uint256) public mintCount;\nmapping (uint256 => uint256) public burnCount;\nmapping (uint256 => bool) public metadataFrozen;\nmapping (uint256 => string) public metadata;\naddress public proxyRegistryAddress;\nbytes4 private constant INTERFACE_ERC1155 = 0xd9b67a26;\nbytes4 private constant INTERFACE_ERC1155_METADATA_URI = 0x0e89341c;\nbool public uriLocked;\nbool public locked;\n","contract":"Super1155","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(address _from, address _to,\r\n    uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\r\n    external override virtual {\r\n    require(_ids.length == _amounts.length,\r\n      \"ERC1155: ids and amounts length mismatch\");\r\n    require(_to != address(0),\r\n      \"ERC1155: transfer to the zero address\");\r\n    require(_from == _msgSender() || isApprovedForAll(_from, _msgSender()),\r\n      \"ERC1155: caller is not owner nor approved\");\r\n\r\n    // Validate transfer and perform all batch token sends.\r\n    _beforeTokenTransfer(_msgSender(), _from, _to, _ids, _amounts, _data);\r\n    for (uint256 i = 0; i < _ids.length; ++i) {\r\n\r\n      // Retrieve the item's group ID.\r\n      uint256 groupId = (_ids[i] & GROUP_MASK) >> 128;\r\n\r\n      // Update all specially-tracked group-specific balances.\r\n      balances[_ids[i]][_from] = balances[_ids[i]][_from].sub(_amounts[i],\r\n        \"ERC1155: insufficient balance for transfer\");\r\n      balances[_ids[i]][_to] = balances[_ids[i]][_to].add(_amounts[i]);\r\n      groupBalances[groupId][_from] = groupBalances[groupId][_from]\r\n        .sub(_amounts[i]);\r\n      groupBalances[groupId][_to] = groupBalances[groupId][_to]\r\n        .add(_amounts[i]);\r\n      totalBalances[_from] = totalBalances[_from].sub(_amounts[i]);\r\n      totalBalances[_to] = totalBalances[_to].add(_amounts[i]);\r\n    }\r\n\r\n    // Emit the transfer event and perform the safety check.\r\n    emit TransferBatch(_msgSender(), _from, _to, _ids, _amounts);\r\n    _doSafeBatchTransferAcceptanceCheck(_msgSender(), _from, _to, _ids,\r\n      _amounts, _data);\r\n  }","after":"function safeBatchTransferFrom(address _from, address _to,\r\n    uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data)\r\n    external override virtual {\r\n    require(_ids.length == _amounts.length,\r\n      \"ERC1155: ids and amounts length mismatch\");\r\n    require(_to != address(0),\r\n      \"ERC1155: transfer to the zero address\");\r\n    require(_from == _msgSender() || isApprovedForAll(_from, _msgSender()),\r\n      \"ERC1155: caller is not owner nor approved\");\r\n\r\n    // Validate transfer and perform all batch token sends.\r\n    _beforeTokenTransfer(_msgSender(), _from, _to, _ids, _amounts, _data);\r\n    for (uint256 i = 0; i < _ids.length; ++i) {\r\n\r\n      // Retrieve the item's group ID.\r\n      uint256 groupId = (_ids[i] & GROUP_MASK) >> 128;\r\n\r\n      // Update all specially-tracked group-specific balances.\r\n      balances[_ids[i]][_from] = balances[_ids[i]][_from].sub(_amounts[i],\r\n        \"ERC1155: insufficient balance for transfer\");\r\n      balances[_ids[i]][_to] = balances[_ids[i]][_to].add(_amounts[i]);\r\n      groupBalances[groupId][_from] = groupBalances[groupId][_from]\r\n        .sub(_amounts[i]);\r\n      groupBalances[groupId][_to] = groupBalances[groupId][_to]\r\n        .add(_amounts[i]);\r\n      totalBalances[_from] = totalBalances[_from].sub(_amounts[i]);\r\n      totalBalances[_to] = totalBalances[_to].add(_amounts[i]);\r\n    }\r\n\r\n    // Emit the transfer event and perform the safety check.\r\n    emit TransferBatch(_msgSender(), _from, _to, _ids, _amounts);\r\n    _doSafeBatchTransferAcceptanceCheck(_msgSender(), _from, _to, _ids,\r\n      _amounts, _data);\r\n  }","contract":"Super1155","time":0},{"type":"external-function ","before":"function burnBatch(address _burner, uint256[] memory _ids,\r\n    uint256[] memory _amounts) external virtual {\r\n    require(_burner != address(0),\r\n      \"ERC1155: burn from the zero address\");\r\n    require(_ids.length == _amounts.length,\r\n      \"ERC1155: ids and amounts length mismatch\");\r\n\r\n    // Validate and perform the burn.\r\n    address operator = _msgSender();\r\n    _beforeTokenTransfer(operator, _burner, address(0), _ids, _amounts, \"\");\r\n\r\n    // Loop through each of the batched IDs to update storage of special\r\n    // balances and circulation balances.\r\n    for (uint i = 0; i < _ids.length; i++) {\r\n      require(_hasItemRight(_ids[i], BURN),\r\n        \"Super1155: you do not have the right to burn that item\");\r\n\r\n      // Retrieve the group ID from the given item `_id` and check burn.\r\n      uint256 shiftedGroupId = (_ids[i] & GROUP_MASK);\r\n      uint256 groupId = shiftedGroupId >> 128;\r\n      uint256 burntItemId = _burnChecker(_ids[i], _amounts[i]);\r\n\r\n      // Update storage of special balances and circulating values.\r\n      balances[burntItemId][_burner] = balances[burntItemId][_burner]\r\n        .sub(_amounts[i],\r\n        \"ERC1155: burn amount exceeds balance\");\r\n      groupBalances[groupId][_burner] = groupBalances[groupId][_burner]\r\n        .sub(_amounts[i]);\r\n      totalBalances[_burner] = totalBalances[_burner].sub(_amounts[i]);\r\n      burnCount[burntItemId] = burnCount[burntItemId].add(_amounts[i]);\r\n      circulatingSupply[burntItemId] = circulatingSupply[burntItemId]\r\n        .sub(_amounts[i]);\r\n      itemGroups[groupId].burnCount = itemGroups[groupId].burnCount\r\n        .add(_amounts[i]);\r\n      itemGroups[groupId].circulatingSupply =\r\n        itemGroups[groupId].circulatingSupply.sub(_amounts[i]);\r\n    }\r\n\r\n    // Emit the burn event.\r\n    emit TransferBatch(operator, _burner, address(0), _ids, _amounts);\r\n  }","after":"function burnBatch(address _burner, uint256[] calldata _ids,\r\n    uint256[] calldata _amounts) external virtual {\r\n    require(_burner != address(0),\r\n      \"ERC1155: burn from the zero address\");\r\n    require(_ids.length == _amounts.length,\r\n      \"ERC1155: ids and amounts length mismatch\");\r\n\r\n    // Validate and perform the burn.\r\n    address operator = _msgSender();\r\n    _beforeTokenTransfer(operator, _burner, address(0), _ids, _amounts, \"\");\r\n\r\n    // Loop through each of the batched IDs to update storage of special\r\n    // balances and circulation balances.\r\n    for (uint i = 0; i < _ids.length; i++) {\r\n      require(_hasItemRight(_ids[i], BURN),\r\n        \"Super1155: you do not have the right to burn that item\");\r\n\r\n      // Retrieve the group ID from the given item `_id` and check burn.\r\n      uint256 shiftedGroupId = (_ids[i] & GROUP_MASK);\r\n      uint256 groupId = shiftedGroupId >> 128;\r\n      uint256 burntItemId = _burnChecker(_ids[i], _amounts[i]);\r\n\r\n      // Update storage of special balances and circulating values.\r\n      balances[burntItemId][_burner] = balances[burntItemId][_burner]\r\n        .sub(_amounts[i],\r\n        \"ERC1155: burn amount exceeds balance\");\r\n      groupBalances[groupId][_burner] = groupBalances[groupId][_burner]\r\n        .sub(_amounts[i]);\r\n      totalBalances[_burner] = totalBalances[_burner].sub(_amounts[i]);\r\n      burnCount[burntItemId] = burnCount[burntItemId].add(_amounts[i]);\r\n      circulatingSupply[burntItemId] = circulatingSupply[burntItemId]\r\n        .sub(_amounts[i]);\r\n      itemGroups[groupId].burnCount = itemGroups[groupId].burnCount\r\n        .add(_amounts[i]);\r\n      itemGroups[groupId].circulatingSupply =\r\n        itemGroups[groupId].circulatingSupply.sub(_amounts[i]);\r\n    }\r\n\r\n    // Emit the burn event.\r\n    emit TransferBatch(operator, _burner, address(0), _ids, _amounts);\r\n  }","contract":"Super1155","time":0},{"type":"external-function ","before":"function setMetadata(uint256 _id, string memory _metadata)\r\n    external hasItemRight(_id, SET_METADATA) {\r\n    require(!uriLocked && !metadataFrozen[_id],\r\n      \"Super1155: you cannot edit this metadata because it is frozen\");\r\n    string memory oldMetadata = metadata[_id];\r\n    metadata[_id] = _metadata;\r\n    emit MetadataChanged(_msgSender(), _id, oldMetadata, _metadata);\r\n  }","after":"function setMetadata(uint256 _id, string calldata _metadata)\r\n    external hasItemRight(_id, SET_METADATA) {\r\n    require(!uriLocked && !metadataFrozen[_id],\r\n      \"Super1155: you cannot edit this metadata because it is frozen\");\r\n    string memory oldMetadata = metadata[_id];\r\n    metadata[_id] = _metadata;\r\n    emit MetadataChanged(_msgSender(), _id, oldMetadata, _metadata);\r\n  }","contract":"Super1155","time":0}]}