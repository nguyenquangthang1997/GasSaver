{"time":1667,"results":[{"type":"struct-data-arrangement ","before":"\nuint256 id\naddress proposer\nuint256 eta\naddress[] targets\nuint256[] values\nstring[] signatures\nbytes[] calldatas\nuint256 startTime\nuint256 endTime\nuint256 forVotes\nuint256 againstVotes\nbool canceled\nbool executed\nmapping(address => Receipt) receipts","after":"uint256 id\nuint256 eta\naddress[] targets\nuint256[] values\nstring[] signatures\nbytes[] calldatas\nuint256 startTime\nuint256 endTime\nuint256 forVotes\nuint256 againstVotes\nmapping(address => Receipt) receipts\naddress proposer\nbool canceled\nbool executed\n","contract":"IGovernorAlpha","time":0},{"type":"immutable-restrict-modification ","before":"address public bpool;","after":"address public immutable bpool;","contract":"Upgrade","time":0},{"type":"immutable-restrict-modification ","before":"address public weth;","after":"address public immutable weth;","contract":"MIMODeployment","time":0},{"type":"immutable-restrict-modification ","before":"address public wbtc;","after":"address public immutable wbtc;","contract":"MIMODeployment","time":0},{"type":"immutable-restrict-modification ","before":"address public usdc;","after":"address public immutable usdc;","contract":"MIMODeployment","time":0},{"type":"external-function ","before":"function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    uint256 income = a.core().availableIncome();\n    if (income > 0 && payees.length > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }","after":"function changePayees(address[] calldata _payees, uint256[] calldata _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    uint256 income = a.core().availableIncome();\n    if (income > 0 && payees.length > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }","contract":"FeeDistributorV1","time":0},{"type":"external-function ","before":"function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    if (payees.length > 0 && mintableTokens() > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }","after":"function changePayees(address[] calldata _payees, uint256[] calldata _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    if (payees.length > 0 && mintableTokens() > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }","contract":"MIMODistributorV2","time":0},{"type":"immutable-restrict-modification ","before":"uint256 private _FIRST_WEEK_TOKENS;","after":"uint256 private immutable _FIRST_WEEK_TOKENS;","contract":"MIMODistributorV2","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public override startTime;","after":"uint256 public override immutable startTime;","contract":"MIMODistributorV2","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public alreadyMinted;","after":"uint256 public immutable alreadyMinted;","contract":"MIMODistributorV2","time":1},{"type":"external-function ","before":"function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    if (payees.length > 0 && mintableTokens() > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }","after":"function changePayees(address[] calldata _payees, uint256[] calldata _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    if (payees.length > 0 && mintableTokens() > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }","contract":"PolygonDistributor","time":0},{"type":"immutable-restrict-modification ","before":"address public erc20Predicate;","after":"address public immutable erc20Predicate;","contract":"PolygonDistributor","time":0},{"type":"external-function ","before":"function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    if (payees.length > 0 && mintableTokens() > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }","after":"function changePayees(address[] calldata _payees, uint256[] calldata _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    if (payees.length > 0 && mintableTokens() > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }","contract":"EthereumDistributor","time":0},{"type":"external-function ","before":"function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    uint256 income = a.core().state().availableIncome();\n    if (income > 0 && payees.length > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }","after":"function changePayees(address[] calldata _payees, uint256[] calldata _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    uint256 income = a.core().state().availableIncome();\n    if (income > 0 && payees.length > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }","contract":"FeeDistributor","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public override version = 3;","after":"uint256 public override constant version = 3;","contract":"MockChainlinkFeed","time":0},{"type":"immutable-restrict-modification ","before":"uint8 public override decimals;","after":"uint8 public override immutable decimals;","contract":"MockChainlinkFeed","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public override version = 3;","after":"uint256 public override constant version = 3;","contract":"MockChainlinkAggregator","time":0},{"type":"immutable-restrict-modification ","before":"uint8 public override decimals;","after":"uint8 public override immutable decimals;","contract":"MockChainlinkAggregator","time":0},{"type":"external-function ","before":"function queueTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public override returns (bytes32) {\n    require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n    require(\n      eta >= block.timestamp.add(delay),\n      \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }","after":"function queueTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) public override returns (bytes32) {\n    require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n    require(\n      eta >= block.timestamp.add(delay),\n      \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n    );\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }","contract":"TestTimelock","time":0},{"type":"external-function ","before":"function cancelTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public override {\n    require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }","after":"function cancelTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) public override {\n    require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }","contract":"TestTimelock","time":0},{"type":"external-function ","before":"function executeTransaction(\n    address target,\n    uint256 value,\n    string memory signature,\n    bytes memory data,\n    uint256 eta\n  ) public payable override returns (bytes memory) {\n    require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n    require(block.timestamp >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n    require(block.timestamp <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n    require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }","after":"function executeTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) public payable override returns (bytes memory) {\n    require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n    require(block.timestamp >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n    require(block.timestamp <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n    require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }","contract":"TestTimelock","time":0},{"type":"external-function ","before":"function propose(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    string memory description,\n    uint256 endTime\n  ) public override returns (uint256) {\n    uint256 votingDuration = endTime.sub(block.timestamp);\n    require(votingDuration >= a.parallel().config().minVotingPeriod(), \"Proposal end-time too early\");\n    require(votingDuration <= a.parallel().config().maxVotingPeriod(), \"Proposal end-time too late\");\n\n    require(\n      a.votingEscrow().balanceOfAt(msg.sender, endTime) > proposalThreshold(),\n      \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n    );\n    require(\n      targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\n      \"GovernorAlpha::propose: proposal function information arity mismatch\"\n    );\n    require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n    require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n    uint256 latestProposalId = latestProposalIds[msg.sender];\n    if (latestProposalId != 0) {\n      ProposalState proposersLatestProposalState = state(latestProposalId);\n      require(\n        proposersLatestProposalState != ProposalState.Active,\n        \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n      );\n    }\n\n    proposalCount++;\n    Proposal memory newProposal = Proposal({\n      id: proposalCount,\n      proposer: msg.sender,\n      eta: 0,\n      targets: targets,\n      values: values,\n      signatures: signatures,\n      calldatas: calldatas,\n      startTime: block.timestamp,\n      endTime: endTime,\n      forVotes: 0,\n      againstVotes: 0,\n      canceled: false,\n      executed: false\n    });\n\n    proposals[newProposal.id] = newProposal;\n    latestProposalIds[newProposal.proposer] = newProposal.id;\n\n    emit ProposalCreated(\n      newProposal.id,\n      msg.sender,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      block.timestamp,\n      endTime,\n      description\n    );\n    return newProposal.id;\n  }","after":"function propose(\n    address[] calldata targets,\n    uint256[] calldata values,\n    string[] calldata signatures,\n    bytes[] calldata calldatas,\n    string calldata description,\n    uint256 endTime\n  ) public override returns (uint256) {\n    uint256 votingDuration = endTime.sub(block.timestamp);\n    require(votingDuration >= a.parallel().config().minVotingPeriod(), \"Proposal end-time too early\");\n    require(votingDuration <= a.parallel().config().maxVotingPeriod(), \"Proposal end-time too late\");\n\n    require(\n      a.votingEscrow().balanceOfAt(msg.sender, endTime) > proposalThreshold(),\n      \"GovernorAlpha::propose: proposer votes below proposal threshold\"\n    );\n    require(\n      targets.length == values.length && targets.length == signatures.length && targets.length == calldatas.length,\n      \"GovernorAlpha::propose: proposal function information arity mismatch\"\n    );\n    require(targets.length != 0, \"GovernorAlpha::propose: must provide actions\");\n    require(targets.length <= proposalMaxOperations(), \"GovernorAlpha::propose: too many actions\");\n\n    uint256 latestProposalId = latestProposalIds[msg.sender];\n    if (latestProposalId != 0) {\n      ProposalState proposersLatestProposalState = state(latestProposalId);\n      require(\n        proposersLatestProposalState != ProposalState.Active,\n        \"GovernorAlpha::propose: one live proposal per proposer, found an already active proposal\"\n      );\n    }\n\n    proposalCount++;\n    Proposal memory newProposal = Proposal({\n      id: proposalCount,\n      proposer: msg.sender,\n      eta: 0,\n      targets: targets,\n      values: values,\n      signatures: signatures,\n      calldatas: calldatas,\n      startTime: block.timestamp,\n      endTime: endTime,\n      forVotes: 0,\n      againstVotes: 0,\n      canceled: false,\n      executed: false\n    });\n\n    proposals[newProposal.id] = newProposal;\n    latestProposalIds[newProposal.proposer] = newProposal.id;\n\n    emit ProposalCreated(\n      newProposal.id,\n      msg.sender,\n      targets,\n      values,\n      signatures,\n      calldatas,\n      block.timestamp,\n      endTime,\n      description\n    );\n    return newProposal.id;\n  }","contract":"GovernorAlpha","time":0},{"type":"external-function ","before":"function changePayees(address[] memory _payees, uint256[] memory _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    if (payees.length > 0 && mintableTokens() > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }","after":"function changePayees(address[] calldata _payees, uint256[] calldata _shares) public override onlyManager {\n    require(_payees.length == _shares.length, \"Payees and shares mismatched\");\n    require(_payees.length > 0, \"No payees\");\n\n    if (payees.length > 0 && mintableTokens() > 0) {\n      release();\n    }\n\n    for (uint256 i = 0; i < payees.length; i++) {\n      delete shares[payees[i]];\n    }\n    delete payees;\n    totalShares = 0;\n\n    for (uint256 i = 0; i < _payees.length; i++) {\n      _addPayee(_payees[i], _shares[i]);\n    }\n  }","contract":"MIMODistributor","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public override startTime;","after":"uint256 public override immutable startTime;","contract":"MIMODistributor","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public lockExpiry;","after":"uint256 public immutable lockExpiry;","contract":"MIMOBuyback","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public poolID;","after":"bytes32 public immutable poolID;","contract":"MIMOBuyback","time":0}]}