{"time":157,"results":[{"type":"external-function ","before":"function deposit(\n      address contractAddress,\n      uint256[] memory tokenIds,\n      uint256[] memory tokenTraits,\n      bytes calldata signature\n    ) public nonReentrant {\n      require(!depositPaused, \"Deposit paused\");\n      require(stakingLaunched, \"Staking is not launched yet\");\n      require(\n        contractAddress != address(0) &&\n        contractAddress == address(CBCNft)\n        || contractAddress == address(BLACKBOXNft)\n        || contractAddress == address(ARMSNft),\n        \"Unknown contract\"\n      );\n      ContractTypes contractType = _contractTypes[contractAddress];\n\n      if (tokenTraits.length > 0) {\n        require(_validateSignature(\n          signature,\n          contractAddress,\n          tokenIds,\n          tokenTraits\n        ), \"Invalid data provided\");\n        _setTokensValues(contractAddress, tokenIds, tokenTraits);\n      }\n\n      Staker storage user = _stakers[_msgSender()];\n      uint256 newYield = user.currentYield;\n\n      for (uint256 i; i < tokenIds.length; i++) {\n        require(IERC721(contractAddress).ownerOf(tokenIds[i]) == _msgSender(), \"Not the owner\");\n        IERC721(contractAddress).safeTransferFrom(_msgSender(), address(this), tokenIds[i]);\n\n        _ownerOfToken[contractAddress][tokenIds[i]] = _msgSender();\n\n        if (user.currentYield != 0 || contractType != ContractTypes.ARMS) {\n          newYield += getTokenYield(contractAddress, tokenIds[i]);\n        }\n\n        if (contractType == ContractTypes.CBC) { user.stakedCBC.push(tokenIds[i]); }\n        if (contractType == ContractTypes.ARMS) { user.stakedARMS.push(tokenIds[i]); }\n        if (contractType == ContractTypes.BLACKBOX) { user.stakedBLACKBOX.push(tokenIds[i]); }\n      }\n\n      if (user.currentYield == 0 && newYield != 0 && user.stakedARMS.length > 0) {\n        for (uint256 i; i < user.stakedARMS.length; i++) {\n          uint256 tokenYield = getTokenYield(address(ARMSNft), user.stakedARMS[i]);\n          newYield += tokenYield;\n        }\n      }\n\n      accumulate(_msgSender());\n      user.currentYield = newYield;\n\n      emit Deposit(_msgSender(), contractAddress, tokenIds.length);\n    }","after":"function deposit(\n      address contractAddress,\n      uint256[] calldata tokenIds,\n      uint256[] calldata tokenTraits,\n      bytes calldata signature\n    ) public nonReentrant {\n      require(!depositPaused, \"Deposit paused\");\n      require(stakingLaunched, \"Staking is not launched yet\");\n      require(\n        contractAddress != address(0) &&\n        contractAddress == address(CBCNft)\n        || contractAddress == address(BLACKBOXNft)\n        || contractAddress == address(ARMSNft),\n        \"Unknown contract\"\n      );\n      ContractTypes contractType = _contractTypes[contractAddress];\n\n      if (tokenTraits.length > 0) {\n        require(_validateSignature(\n          signature,\n          contractAddress,\n          tokenIds,\n          tokenTraits\n        ), \"Invalid data provided\");\n        _setTokensValues(contractAddress, tokenIds, tokenTraits);\n      }\n\n      Staker storage user = _stakers[_msgSender()];\n      uint256 newYield = user.currentYield;\n\n      for (uint256 i; i < tokenIds.length; i++) {\n        require(IERC721(contractAddress).ownerOf(tokenIds[i]) == _msgSender(), \"Not the owner\");\n        IERC721(contractAddress).safeTransferFrom(_msgSender(), address(this), tokenIds[i]);\n\n        _ownerOfToken[contractAddress][tokenIds[i]] = _msgSender();\n\n        if (user.currentYield != 0 || contractType != ContractTypes.ARMS) {\n          newYield += getTokenYield(contractAddress, tokenIds[i]);\n        }\n\n        if (contractType == ContractTypes.CBC) { user.stakedCBC.push(tokenIds[i]); }\n        if (contractType == ContractTypes.ARMS) { user.stakedARMS.push(tokenIds[i]); }\n        if (contractType == ContractTypes.BLACKBOX) { user.stakedBLACKBOX.push(tokenIds[i]); }\n      }\n\n      if (user.currentYield == 0 && newYield != 0 && user.stakedARMS.length > 0) {\n        for (uint256 i; i < user.stakedARMS.length; i++) {\n          uint256 tokenYield = getTokenYield(address(ARMSNft), user.stakedARMS[i]);\n          newYield += tokenYield;\n        }\n      }\n\n      accumulate(_msgSender());\n      user.currentYield = newYield;\n\n      emit Deposit(_msgSender(), contractAddress, tokenIds.length);\n    }","contract":"CreepzInvasionGrounds","time":0},{"type":"external-function ","before":"function withdraw(\n      address contractAddress,\n      uint256[] memory tokenIds\n    ) public nonReentrant {\n      require(\n        contractAddress != address(0) &&\n        contractAddress == address(CBCNft)\n        || contractAddress == address(BLACKBOXNft)\n        || contractAddress == address(ARMSNft),\n        \"Unknown contract\"\n      );\n      ContractTypes contractType = _contractTypes[contractAddress];\n      Staker storage user = _stakers[_msgSender()];\n      uint256 newYield = user.currentYield;\n\n      for (uint256 i; i < tokenIds.length; i++) {\n        require(IERC721(contractAddress).ownerOf(tokenIds[i]) == address(this), \"Not the owner\");\n\n        _ownerOfToken[contractAddress][tokenIds[i]] = address(0);\n\n        if (user.currentYield != 0) {\n          uint256 tokenYield = getTokenYield(contractAddress, tokenIds[i]);\n          newYield -= tokenYield;\n        }\n\n        if (contractType == ContractTypes.CBC) {\n          user.stakedCBC = _moveTokenInTheList(user.stakedCBC, tokenIds[i]);\n          user.stakedCBC.pop();\n        }\n        if (contractType == ContractTypes.ARMS) {\n          user.stakedARMS = _moveTokenInTheList(user.stakedARMS, tokenIds[i]);\n          user.stakedARMS.pop();\n        }\n        if (contractType == ContractTypes.BLACKBOX) {\n          user.stakedBLACKBOX = _moveTokenInTheList(user.stakedBLACKBOX, tokenIds[i]);\n          user.stakedBLACKBOX.pop();\n        }\n\n        IERC721(contractAddress).safeTransferFrom(address(this), _msgSender(), tokenIds[i]);\n      }\n\n      if (user.stakedCBC.length == 0 && user.stakedBLACKBOX.length == 0) {\n        newYield = 0;\n      }\n\n      accumulate(_msgSender());\n      user.currentYield = newYield;\n\n      emit Withdraw(_msgSender(), contractAddress, tokenIds.length);\n    }","after":"function withdraw(\n      address contractAddress,\n      uint256[] calldata tokenIds\n    ) public nonReentrant {\n      require(\n        contractAddress != address(0) &&\n        contractAddress == address(CBCNft)\n        || contractAddress == address(BLACKBOXNft)\n        || contractAddress == address(ARMSNft),\n        \"Unknown contract\"\n      );\n      ContractTypes contractType = _contractTypes[contractAddress];\n      Staker storage user = _stakers[_msgSender()];\n      uint256 newYield = user.currentYield;\n\n      for (uint256 i; i < tokenIds.length; i++) {\n        require(IERC721(contractAddress).ownerOf(tokenIds[i]) == address(this), \"Not the owner\");\n\n        _ownerOfToken[contractAddress][tokenIds[i]] = address(0);\n\n        if (user.currentYield != 0) {\n          uint256 tokenYield = getTokenYield(contractAddress, tokenIds[i]);\n          newYield -= tokenYield;\n        }\n\n        if (contractType == ContractTypes.CBC) {\n          user.stakedCBC = _moveTokenInTheList(user.stakedCBC, tokenIds[i]);\n          user.stakedCBC.pop();\n        }\n        if (contractType == ContractTypes.ARMS) {\n          user.stakedARMS = _moveTokenInTheList(user.stakedARMS, tokenIds[i]);\n          user.stakedARMS.pop();\n        }\n        if (contractType == ContractTypes.BLACKBOX) {\n          user.stakedBLACKBOX = _moveTokenInTheList(user.stakedBLACKBOX, tokenIds[i]);\n          user.stakedBLACKBOX.pop();\n        }\n\n        IERC721(contractAddress).safeTransferFrom(address(this), _msgSender(), tokenIds[i]);\n      }\n\n      if (user.stakedCBC.length == 0 && user.stakedBLACKBOX.length == 0) {\n        newYield = 0;\n      }\n\n      accumulate(_msgSender());\n      user.currentYield = newYield;\n\n      emit Withdraw(_msgSender(), contractAddress, tokenIds.length);\n    }","contract":"CreepzInvasionGrounds","time":0},{"type":"external-function ","before":"function emergencyWithdraw(address tokenAddress, uint256[] memory tokenIds) public onlyOwner {\n      require(tokenIds.length <= 50, \"50 is max per tx\");\n      pauseDeposit(true);\n      for (uint256 i; i < tokenIds.length; i++) {\n        address receiver = _ownerOfToken[tokenAddress][tokenIds[i]];\n        if (receiver != address(0) && IERC721(tokenAddress).ownerOf(tokenIds[i]) == address(this)) {\n          IERC721(tokenAddress).transferFrom(address(this), receiver, tokenIds[i]);\n          emit WithdrawStuckERC721(receiver, tokenAddress, tokenIds[i]);\n        }\n      }\n    }","after":"function emergencyWithdraw(address tokenAddress, uint256[] calldata tokenIds) public onlyOwner {\n      require(tokenIds.length <= 50, \"50 is max per tx\");\n      pauseDeposit(true);\n      for (uint256 i; i < tokenIds.length; i++) {\n        address receiver = _ownerOfToken[tokenAddress][tokenIds[i]];\n        if (receiver != address(0) && IERC721(tokenAddress).ownerOf(tokenIds[i]) == address(this)) {\n          IERC721(tokenAddress).transferFrom(address(this), receiver, tokenIds[i]);\n          emit WithdrawStuckERC721(receiver, tokenAddress, tokenIds[i]);\n        }\n      }\n    }","contract":"CreepzInvasionGrounds","time":0}]}