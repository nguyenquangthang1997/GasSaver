{"time":163,"results":[{"type":"external-function ","before":"telistMintedAmount;\r\n\r\n    // events\r\n    event Mint(address indexed owner, uint256 tokenId);\r\n\r\n    // constructor\r\n    constructor() ERC721A(\"PunkX\", \"PUNKX\", 300) {}\r\n\r\n    // dev mint\r\n    function ownerMintFromReserved(address to, uint256 amount)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(amount <= reservedSize, \"Minting amount exceed reserved size\");\r\n        reservedSize = reservedSize - amount;\r\n        _mintWithoutValidation(to, amount);\r\n    }\r\n\r\n    // whitelist mint\r\n    function whitelistMint(bytes32[] memory proof) external payable {\r\n        require(!whitelistMintPaused, \"Whitelist mint paused\");\r\n        require(\r\n            isAddressWhitelisted(proof, msg.sender) || isAddressXlisted(proof, msg.sender),\r\n            \"Not eligible\"\r\n        );\r\n\r\n        uint256 limit = maxItemsPerTx;\r\n        if (isAddressXlisted(proof, msg.sender)) {\r\n            limit = maxItemsPerTxForXlist;\r\n        }\r\n\r\n        uint256 remainder = msg.value % mintPrice;\r\n        require(remainder == 0, \"Send a divisible amount of eth\");\r\n\r\n        uint256 amount = msg.value / mintPrice;\r\n        require(amount > 0, \"Amount to mi","after":"telistMintedAmount;\r\n\r\n    // events\r\n    event Mint(address indexed owner, uint256 tokenId);\r\n\r\n    // constructor\r\n    constructor() ERC721A(\"PunkX\", \"PUNKX\", 300) {}\r\n\r\n    // dev mint\r\n    function ownerMintFromReserved(address to, uint256 amount)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(amount <= reservedSize, \"Minting amount exceed reserved size\");\r\n        reservedSize = reservedSize - amount;\r\n        _mintWithoutValidation(to, amount);\r\n    }\r\n\r\n    // whitelist mint\r\n    function whitelistMint(bytes32[] memory proof) external payable {\r\n        require(!whitelistMintPaused, \"Whitelist mint paused\");\r\n        require(\r\n            isAddressWhitelisted(proof, msg.sender) || isAddressXlisted(proof, msg.sender),\r\n            \"Not eligible\"\r\n        );\r\n\r\n        uint256 limit = maxItemsPerTx;\r\n        if (isAddressXlisted(proof, msg.sender)) {\r\n            limit = maxItemsPerTxForXlist;\r\n        }\r\n\r\n        uint256 remainder = msg.value % mintPrice;\r\n        require(remainder == 0, \"Send a divisible amount of eth\");\r\n\r\n        uint256 amount = msg.value / mintPrice;\r\n        require(amount > 0, \"Amount to mi","contract":"PunkX","time":0},{"type":"external-function ","before":"elistMintPaused;\r\n    }\r\n\r\n    function setWhitelistMintInfo(\r\n        bytes32 _whitelistMerkleRoot,\r\n        bytes32 _X","after":"elistMintPaused;\r\n    }\r\n\r\n    function setWhitelistMintInfo(\r\n        bytes32 _whitelistMerkleRoot,\r\n        bytes32 _X","contract":"PunkX","time":0},{"type":"constant-restrict-modification  ","before":"��░░░░░╚═════�","after":"��░░░░░╚═════�","contract":"PunkX","time":0},{"type":"constant-restrict-modification  ","before":"of} from \"@openzeppelin/contracts/utils/c","after":"of} from \"@openzeppelin/contracts/utils/c","contract":"PunkX","time":0}]}