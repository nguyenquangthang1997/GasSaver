{"time":194,"results":[{"type":"external-function ","before":"function safeMint(\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) public virtual override {\n        _requireMinter(_msgSender());\n        _safeMint(to, id, value, data);\n    }","after":"function safeMint(\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) public virtual override {\n        _requireMinter(_msgSender());\n        _safeMint(to, id, value, data);\n    }","contract":"TokenLaunchpadVouchers","time":0},{"type":"external-function ","before":"function safeBatchMint(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual override {\n        _requireMinter(_msgSender());\n        _safeBatchMint(to, ids, values, data);\n    }","after":"function safeBatchMint(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) public virtual override {\n        _requireMinter(_msgSender());\n        _safeBatchMint(to, ids, values, data);\n    }","contract":"TokenLaunchpadVouchers","time":0},{"type":"external-function ","before":"function batchBurnFrom(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual override {\n        uint256 length = ids.length;\n        require(length == values.length, \"Inventory: inconsistent arrays\");\n\n        address sender = _msgSender();\n        require(_isOperatable(from, sender), \"Inventory: non-approved sender\");\n\n        uint256 nfCollectionId;\n        uint256 nfCollectionCount;\n        for (uint256 i; i != length; ++i) {\n            uint256 id = ids[i];\n            uint256 value = values[i];\n            if (id.isFungibleToken()) {\n                _burnFungible(from, id, value);\n            } else if (id.isNonFungibleToken()) {\n                _burnNFT(from, id, value, true);\n                uint256 nextCollectionId = id.getNonFungibleCollection();\n                if (nfCollectionId == 0) {\n                    nfCollectionId = nextCollectionId;\n                    nfCollectionCount = 1;\n                } else {\n                    if (nextCollectionId != nfCollectionId) {\n                        _balances[nfCollectionId][from] -= nfCollectionCount;\n                        _supplies[nfCollectionId] -= nfCollectionCount;\n                        nfCollectionId = nextCollectionId;\n                        nfCollectionCount = 1;\n                    } else {\n                        ++nfCollectionCount;\n                    }\n                }\n            } else {\n                revert(\"Inventory: not a token id\");\n            }\n        }\n\n        if (nfCollectionId != 0) {\n            _balances[nfCollectionId][from] -= nfCollectionCount;\n            _supplies[nfCollectionId] -= nfCollectionCount;\n        }\n\n        emit TransferBatch(sender, from, address(0), ids, values);\n    }","after":"function batchBurnFrom(\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) public virtual override {\n        uint256 length = ids.length;\n        require(length == values.length, \"Inventory: inconsistent arrays\");\n\n        address sender = _msgSender();\n        require(_isOperatable(from, sender), \"Inventory: non-approved sender\");\n\n        uint256 nfCollectionId;\n        uint256 nfCollectionCount;\n        for (uint256 i; i != length; ++i) {\n            uint256 id = ids[i];\n            uint256 value = values[i];\n            if (id.isFungibleToken()) {\n                _burnFungible(from, id, value);\n            } else if (id.isNonFungibleToken()) {\n                _burnNFT(from, id, value, true);\n                uint256 nextCollectionId = id.getNonFungibleCollection();\n                if (nfCollectionId == 0) {\n                    nfCollectionId = nextCollectionId;\n                    nfCollectionCount = 1;\n                } else {\n                    if (nextCollectionId != nfCollectionId) {\n                        _balances[nfCollectionId][from] -= nfCollectionCount;\n                        _supplies[nfCollectionId] -= nfCollectionCount;\n                        nfCollectionId = nextCollectionId;\n                        nfCollectionCount = 1;\n                    } else {\n                        ++nfCollectionCount;\n                    }\n                }\n            } else {\n                revert(\"Inventory: not a token id\");\n            }\n        }\n\n        if (nfCollectionId != 0) {\n            _balances[nfCollectionId][from] -= nfCollectionCount;\n            _supplies[nfCollectionId] -= nfCollectionCount;\n        }\n\n        emit TransferBatch(sender, from, address(0), ids, values);\n    }","contract":"TokenLaunchpadVouchers","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes memory data\n    ) public virtual override {\n        address sender = _msgSender();\n        require(to != address(0), \"Inventory: transfer to zero\");\n        require(_isOperatable(from, sender), \"Inventory: non-approved sender\");\n\n        if (id.isFungibleToken()) {\n            _transferFungible(from, to, id, value);\n        } else if (id.isNonFungibleToken()) {\n            _transferNFT(from, to, id, value, false);\n        } else {\n            revert(\"Inventory: not a token id\");\n        }\n\n        emit TransferSingle(sender, from, to, id, value);\n        if (to.isContract()) {\n            _callOnERC1155Received(from, to, id, value, data);\n        }\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) public virtual override {\n        address sender = _msgSender();\n        require(to != address(0), \"Inventory: transfer to zero\");\n        require(_isOperatable(from, sender), \"Inventory: non-approved sender\");\n\n        if (id.isFungibleToken()) {\n            _transferFungible(from, to, id, value);\n        } else if (id.isNonFungibleToken()) {\n            _transferNFT(from, to, id, value, false);\n        } else {\n            revert(\"Inventory: not a token id\");\n        }\n\n        emit TransferSingle(sender, from, to, id, value);\n        if (to.isContract()) {\n            _callOnERC1155Received(from, to, id, value, data);\n        }\n    }","contract":"TokenLaunchpadVouchers","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory values,\n        bytes memory data\n    ) public virtual override {\n        // internal function to avoid stack too deep error\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) public virtual override {\n        // internal function to avoid stack too deep error\n        _safeBatchTransferFrom(from, to, ids, values, data);\n    }","contract":"TokenLaunchpadVouchers","time":0}]}