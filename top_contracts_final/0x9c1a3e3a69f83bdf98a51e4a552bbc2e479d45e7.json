{"time":74,"results":[{"type":"external-function ","before":"function releaseTokens(address user, uint256 amount, string memory burnTxHash) external onlyOwner nonReentrant {\n        require(burnTxHashes[burnTxHash] == false, \"Burn Tx Hash already exists\");\n        burnTxHashes[burnTxHash] = true;\n        token.safeTransfer(user, amount);\n        emit Release(user, amount, burnTxHash);\n    }","after":"function releaseTokens(address user, uint256 amount, string calldata burnTxHash) external onlyOwner nonReentrant {\n        require(burnTxHashes[burnTxHash] == false, \"Burn Tx Hash already exists\");\n        burnTxHashes[burnTxHash] = true;\n        token.safeTransfer(user, amount);\n        emit Release(user, amount, burnTxHash);\n    }","contract":"BundlesLock","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[msg.sender],\n            from: msg.sender,\n            functionSignature: functionSignature\n        });\n        require(verify(owner(), metaTx, sigR, sigS, sigV), \"Signer and signature do not match\");\n\n        // increase nonce for user (to avoid re-use)\n        nonces[msg.sender] = nonces[msg.sender] + 1;\n\n        // Append owner and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(abi.encodePacked(functionSignature, owner()));\n        string memory response = string(returnData);\n        require(success, response);\n        emit MetaTransactionExecuted(owner(), msg.sender, functionSignature, returnData);\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[msg.sender],\n            from: msg.sender,\n            functionSignature: functionSignature\n        });\n        require(verify(owner(), metaTx, sigR, sigS, sigV), \"Signer and signature do not match\");\n\n        // increase nonce for user (to avoid re-use)\n        nonces[msg.sender] = nonces[msg.sender] + 1;\n\n        // Append owner and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(abi.encodePacked(functionSignature, owner()));\n        string memory response = string(returnData);\n        require(success, response);\n        emit MetaTransactionExecuted(owner(), msg.sender, functionSignature, returnData);\n        return returnData;\n    }","contract":"BundlesLock","time":0}]}