{"time":205,"results":[{"type":"external-function ","before":"   function updateState(uint256 tokenId, string memory t, uint256 speed)\n        public\n        approvedOrOwner(_msgSender(), tokenId)\n    {\n        require(0 <= speed && speed <= 10, \"SpiralFrequencies: Invalid speed only 0-10 allowed.\");\n        _state[tokenId].t     = t;\n        _state[tokenId].speed = speed;\n\n        emit StateChange(msg.sender, tokenId, _state[tokenId]);\n  ","after":"   function updateState(uint256 tokenId, string calldata t, uint256 speed)\n        public\n        approvedOrOwner(_msgSender(), tokenId)\n    {\n        require(0 <= speed && speed <= 10, \"SpiralFrequencies: Invalid speed only 0-10 allowed.\");\n        _state[tokenId].t     = t;\n        _state[tokenId].speed = speed;\n\n        emit StateChange(msg.sender, tokenId, _state[tokenId]);\n  ","contract":"SpiralFrequencies","time":0},{"type":"external-function ","before":"   function setArtist(string memory artist_)\n        public\n        onlyOwner\n    {\n        artist = artist_;\n  ","after":"   function setArtist(string calldata artist_)\n        public\n        onlyOwner\n    {\n        artist = artist_;\n  ","contract":"SpiralFrequencies","time":0},{"type":"external-function ","before":"   function setDescription(string memory description_)\n        public\n        onlyOwner\n    {\n        description = description_;\n  ","after":"   function setDescription(string calldata description_)\n        public\n        onlyOwner\n    {\n        description = description_;\n  ","contract":"SpiralFrequencies","time":0},{"type":"external-function ","before":"   function setCode(string memory code_)\n        public\n        onlyOwner\n    {\n        code = code_;\n  ","after":"   function setCode(string calldata code_)\n        public\n        onlyOwner\n    {\n        code = code_;\n  ","contract":"SpiralFrequencies","time":0},{"type":"external-function ","before":"   function secureMint(bytes32 msgHash, bytes memory signature, uint256 allocation, uint256 count, string memory nonce)\n        external\n    {\n        require(!_usedNonces[nonce], \"invalid nonce\");\n        require(totalSupply() < tokenMax, \"all tokens minted\");\n        require(totalSupply() + count <= tokenMax, \"exceed token supply\");\n        require(publicMinted + count <= publicMax, \"exceed public supply\");\n        require(_mints[msg.sender] + count <= allocation, \"exceed allocation\");\n        require(validateSigner(msgHash, signature), \"invalid signer\");\n        require(validateHash(msgHash, msg.sender, allocation, count, nonce), \"invalid hash\");\n        publicMinted += count;\n        _mints[msg.sender] += count;\n        _usedNonces[nonce] = true;\n        for (uint256 i = 0; i < count; ++i) {\n            _mintTo(msg.sender);\n        }\n  ","after":"   function secureMint(bytes32 msgHash, bytes calldata signature, uint256 allocation, uint256 count, string calldata nonce)\n        external\n    {\n        require(!_usedNonces[nonce], \"invalid nonce\");\n        require(totalSupply() < tokenMax, \"all tokens minted\");\n        require(totalSupply() + count <= tokenMax, \"exceed token supply\");\n        require(publicMinted + count <= publicMax, \"exceed public supply\");\n        require(_mints[msg.sender] + count <= allocation, \"exceed allocation\");\n        require(validateSigner(msgHash, signature), \"invalid signer\");\n        require(validateHash(msgHash, msg.sender, allocation, count, nonce), \"invalid hash\");\n        publicMinted += count;\n        _mints[msg.sender] += count;\n        _usedNonces[nonce] = true;\n        for (uint256 i = 0; i < count; ++i) {\n            _mintTo(msg.sender);\n        }\n  ","contract":"SpiralFrequencies","time":0},{"type":"external-function ","before":"   function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n  ","after":"   function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n  ","contract":"SpiralFrequencies","time":0},{"type":"immutable-restrict-modification ","before":"   address _proxyRegistryAddre","after":"   address _proxyRegistryAddre","contract":"SpiralFrequencies","time":0},{"type":"constant-restrict-modification  ","before":"   uint256 private _currentTokenId =","after":"   uint256 private constant _currentTokenId =","contract":"SpiralFrequencies","time":0},{"type":"constant-restrict-modification  ","before":"   address private _signer = 0x9bf0E17205F269494DFc7957b9Da48f4F08847","after":"   address private constant _signer = 0x9bf0E17205F269494DFc7957b9Da48f4F08847","contract":"SpiralFrequencies","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public publicM","after":"   uint256 public publicM","contract":"SpiralFrequencies","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public privateM","after":"   uint256 public privateM","contract":"SpiralFrequencies","time":0},{"type":"immutable-restrict-modification ","before":"   uint256 public tokenM","after":"   uint256 public tokenM","contract":"SpiralFrequencies","time":0}]}