{"time":923,"results":[{"type":"external-function ","before":"(swapFeePercentage);\n    }\n\n    function setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig)\n        public\n        virtual\n        authenticate\n        whenNotPaused\n    {\n        _setAssetManagerPool","after":"(swapFeePercentage);\n    }\n\n    function setAssetManagerPoolConfig(IERC20 token, bytes memory poolConfig)\n        public\n        virtual\n        authenticate\n        whenNotPaused\n    {\n        _setAssetManagerPool","contract":"BaseWeightedPool","time":0},{"type":"external-function ","before":"POOL_ID);\n        _;\n    }\n\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        if (totalSupply() == 0) {\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(\n                poolId,\n                sender,\n                recipient,\n                scalingFactors,\n                userData\n            );\n\n            // On initialization, we lock _getMinimumBpt() by minting it for the zero address. This BPT acts as a\n            // minimum as it will never be burned, which reduces potential issues with rounding, and also prevents the\n            // Pool from ever being fully drained.\n            _require(bptAmountOut >= _getMinimumBpt(), Errors.MINIMUM_BPT);\n            _mintPoolTokens(address(0), _getMinimumBpt());\n            _mintPoolTokens(recipient, bptAmountOut - _getMinimumBpt());\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n            return (amountsIn, new uint256[](_getTotalTokens()));\n        } else {\n            _upscaleArray(balances, scalingFactors);\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n            return (amountsIn, dueProt","after":"POOL_ID);\n        _;\n    }\n\n    function onJoinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n\n        if (totalSupply() == 0) {\n            (uint256 bptAmountOut, uint256[] memory amountsIn) = _onInitializePool(\n                poolId,\n                sender,\n                recipient,\n                scalingFactors,\n                userData\n            );\n\n            // On initialization, we lock _getMinimumBpt() by minting it for the zero address. This BPT acts as a\n            // minimum as it will never be burned, which reduces potential issues with rounding, and also prevents the\n            // Pool from ever being fully drained.\n            _require(bptAmountOut >= _getMinimumBpt(), Errors.MINIMUM_BPT);\n            _mintPoolTokens(address(0), _getMinimumBpt());\n            _mintPoolTokens(recipient, bptAmountOut - _getMinimumBpt());\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n\n            return (amountsIn, new uint256[](_getTotalTokens()));\n        } else {\n            _upscaleArray(balances, scalingFactors);\n            (uint256 bptAmountOut, uint256[] memory amountsIn, uint256[] memory dueProtocolFeeAmounts) = _onJoinPool(\n                poolId,\n                sender,\n                recipient,\n                balances,\n                lastChangeBlock,\n                protocolSwapFeePercentage,\n                scalingFactors,\n                userData\n            );\n\n            // Note we no longer use `balances` after calling `_onJoinPool`, which may mutate it.\n\n            _mintPoolTokens(recipient, bptAmountOut);\n\n            // amountsIn are amounts entering the Pool, so we round up.\n            _downscaleUpArray(amountsIn, scalingFactors);\n            // dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n            _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n            return (amountsIn, dueProt","contract":"BaseWeightedPool","time":0},{"type":"external-function ","before":"eAmounts);\n        }\n    }\n\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            scalingFactors,\n            userData\n        );\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n        _downscaleDownArray(amountsOut, scalingFactors);\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n        return (amountsOu","after":"eAmounts);\n        }\n    }\n\n    function onExitPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) public virtual override onlyVault(poolId) returns (uint256[] memory, uint256[] memory) {\n        uint256[] memory scalingFactors = _scalingFactors();\n        _upscaleArray(balances, scalingFactors);\n\n        (uint256 bptAmountIn, uint256[] memory amountsOut, uint256[] memory dueProtocolFeeAmounts) = _onExitPool(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            scalingFactors,\n            userData\n        );\n\n        // Note we no longer use `balances` after calling `_onExitPool`, which may mutate it.\n\n        _burnPoolTokens(sender, bptAmountIn);\n\n        // Both amountsOut and dueProtocolFeeAmounts are amounts exiting the Pool, so we round down.\n        _downscaleDownArray(amountsOut, scalingFactors);\n        _downscaleDownArray(dueProtocolFeeAmounts, scalingFactors);\n\n        return (amountsOu","contract":"BaseWeightedPool","time":0},{"type":"external-function ","before":"th_sendTransaction.\n     */\n    function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        r","after":"th_sendTransaction.\n     */\n    function queryJoin(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptOut, uint256[] memory amountsIn) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onJoinPool,\n            _downscaleUpArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        r","contract":"BaseWeightedPool","time":0},{"type":"external-function ","before":"th_sendTransaction.\n     */\n    function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] memory balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        r","after":"th_sendTransaction.\n     */\n    function queryExit(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        uint256[] calldata balances,\n        uint256 lastChangeBlock,\n        uint256 protocolSwapFeePercentage,\n        bytes memory userData\n    ) external returns (uint256 bptIn, uint256[] memory amountsOut) {\n        InputHelpers.ensureInputLengthMatch(balances.length, _getTotalTokens());\n\n        _queryAction(\n            poolId,\n            sender,\n            recipient,\n            balances,\n            lastChangeBlock,\n            protocolSwapFeePercentage,\n            userData,\n            _onExitPool,\n            _downscaleDownArray\n        );\n\n        // The `return` opcode is executed directly inside `_queryAction`, so execution never reaches this statement,\n        // and we don't need to return anything here - it just silences compiler warnings.\n        r","contract":"BaseWeightedPool","time":0},{"type":"constant-restrict-modification  ","before":"ext-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,ui","after":"ext-line var-name-mixedcase\n    bytes32 private immutable constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,ui","contract":"BaseWeightedPool","time":1},{"type":"external-function ","before":"'s worth of rewards\n     */\n    function claimWeek(\n        address liquidityProvider,\n        uint256 week,\n        uint256 claimedBalance,\n        bytes32[] memory merkleProof\n    ) external {\n        require(msg.sender == liquidityProvider, \"user must claim own balance\");\n        require(!claimed[week][liquidityProvider], \"cannot claim twice\");\n        require(verifyClaim(liquidityProvider, week, claimedBalance, merkleProof), \"Incorrect merkle proof\");\n\n        claimed[week][liquidityProvider] = true;\n        _disburse(liquidity","after":"'s worth of rewards\n     */\n    function claimWeek(\n        address liquidityProvider,\n        uint256 week,\n        uint256 claimedBalance,\n        bytes32[] memory merkleProof\n    ) external {\n        require(msg.sender == liquidityProvider, \"user must claim own balance\");\n        require(!claimed[week][liquidityProvider], \"cannot claim twice\");\n        require(verifyClaim(liquidityProvider, week, claimedBalance, merkleProof), \"Incorrect merkle proof\");\n\n        claimed[week][liquidityProvider] = true;\n        _disburse(liquidity","contract":"MerkleRedeem","time":0},{"type":"external-function ","before":"ple weeks of reward\n     */\n    function claimWeeks(address liquidityProvider, Claim[] memory claims) external {\n        require(msg.sender == liquidityProvider, \"user must claim own balance\");\n\n        uint256 totalBalance = _processClaims(liquidityProvider, claims);\n        _disburse(liquidi","after":"ple weeks of reward\n     */\n    function claimWeeks(address liquidityProvider, Claim[] memory claims) external {\n        require(msg.sender == liquidityProvider, \"user must claim own balance\");\n\n        uint256 totalBalance = _processClaims(liquidityProvider, claims);\n        _disburse(liquidi","contract":"MerkleRedeem","time":0},{"type":"external-function ","before":"to internal balance\n     */\n    function claimWeeksToInternalBalance(address liquidityProvider, Claim[] memory claims) external {\n        require(msg.sender == liquidityProvider, \"user must claim own balance\");\n\n        uint256 totalBalance = _processClaims(liquidityProvider, claims);\n\n        _disburseToInternalBalance(liquidi","after":"to internal balance\n     */\n    function claimWeeksToInternalBalance(address liquidityProvider, Claim[] memory claims) external {\n        require(msg.sender == liquidityProvider, \"user must claim own balance\");\n\n        uint256 totalBalance = _processClaims(liquidityProvider, claims);\n\n        _disburseToInternalBalance(liquidi","contract":"MerkleRedeem","time":0},{"type":"external-function ","before":"wards to a callback\n     */\n    function claimWeeksWithCallback(\n        address liquidityProvider,\n        IDistributorCallback callbackContract,\n        bytes calldata callbackData,\n        Claim[] memory claims\n    ) external {\n        require(msg.sender == liquidityProvider, \"user must claim own balance\");\n        uint256 totalBalance = _processClaims(liquidityProvider, claims);\n\n        _disburseToInternalBalance(address(callbackContract), totalBalance);\n\n        callbackContract.distribu","after":"wards to a callback\n     */\n    function claimWeeksWithCallback(\n        address liquidityProvider,\n        IDistributorCallback callbackContract,\n        bytes calldata callbackData,\n        Claim[] memory claims\n    ) external {\n        require(msg.sender == liquidityProvider, \"user must claim own balance\");\n        uint256 totalBalance = _processClaims(liquidityProvider, claims);\n\n        _disburseToInternalBalance(address(callbackContract), totalBalance);\n\n        callbackContract.distribu","contract":"MerkleRedeem","time":0},{"type":"external-function ","before":"ions for a claimer.\n     */\n    function claimDistributions(\n        address claimer,\n        Claim[] memory claims,\n        IERC20[] memory tokens\n    ) external {\n        _processClaims(claimer, claime","after":"ions for a claimer.\n     */\n    function claimDistributions(\n        address claimer,\n        Claim[] calldata claims,\n        IERC20[] memory tokens\n    ) external {\n        _processClaims(claimer, claime","contract":"MerkleOrchard","time":0},{"type":"external-function ","before":"o internal balance.\n     */\n    function claimDistributionsToInternalBalance(\n        address claimer,\n        Claim[] memory claims,\n        IERC20[] memory tokens\n    ) external {\n        require(msg.sender == claimer, \"user must claim own balance\");\n        _processClaims(claimer, claim","after":"o internal balance.\n     */\n    function claimDistributionsToInternalBalance(\n        address claimer,\n        Claim[] calldata claims,\n        IERC20[] memory tokens\n    ) external {\n        require(msg.sender == claimer, \"user must claim own balance\");\n        _processClaims(claimer, claim","contract":"MerkleOrchard","time":0},{"type":"external-function ","before":"ions to a callback.\n     */\n    function claimDistributionsWithCallback(\n        address claimer,\n        Claim[] memory claims,\n        IERC20[] memory tokens,\n        IDistributorCallback callbackContract,\n        bytes calldata callbackData\n    ) external {\n        require(msg.sender == claimer, \"user must claim own balance\");\n        _processClaims(claimer, address(callbackContract), claims, tokens, true);\n        callbackContract.distribu","after":"ions to a callback.\n     */\n    function claimDistributionsWithCallback(\n        address claimer,\n        Claim[] calldata claims,\n        IERC20[] calldata tokens,\n        IDistributorCallback callbackContract,\n        bytes calldata callbackData\n    ) external {\n        require(msg.sender == claimer, \"user must claim own balance\");\n        _processClaims(claimer, address(callbackContract), claims, tokens, true);\n        callbackContract.distribu","contract":"MerkleOrchard","time":0}]}