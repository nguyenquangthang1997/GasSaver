{"time":213,"results":[{"type":"state-data-arrangement ","before":"\nuint256 public constant FEE_PRECISION = 1000;\nbool private initialized;\nuint256 public customerFee = 0;\nuint256 public freelancerFee = 100;\nuint256 public extraDuration = 172800;\nuint256 public precision = 10000000000;\nuint256 public priceOutdateDelay = 14400;\nuint256 public priceOutdateDelayStable = 172800;\nbool public convertAvailable = true;\naddress public weth;\naddress public tokenManager;\naddress public serviceFeesRecipient;\naddress public disputer;\nmapping(bytes32 => Contract) public contracts;\nmapping(address => uint256) public serviceFeesAccum;","after":"uint256 public constant FEE_PRECISION = 1000;\nuint256 public customerFee = 0;\nuint256 public freelancerFee = 100;\nuint256 public extraDuration = 172800;\nuint256 public precision = 10000000000;\nuint256 public priceOutdateDelay = 14400;\nuint256 public priceOutdateDelayStable = 172800;\nmapping(bytes32 => Contract) public contracts;\nmapping(address => uint256) public serviceFeesAccum;\naddress public weth;\naddress public tokenManager;\naddress public serviceFeesRecipient;\naddress public disputer;\nbool private initialized;\nbool public convertAvailable = true;\n","contract":"LaborXContract","time":1},{"type":"external-function ","before":"function refundToCustomerWithFreelancerSignature(\n        bytes32 _contractId,\n        bytes memory signature\n    ) public onlyCustomer(_contractId) onlyCreatedState(_contractId) {\n        address signerAddress = _contractId.toEthSignedMessageHash().recover(signature);\n        require(signerAddress == contracts[_contractId].freelancer, \"Freelancer signature is incorrect\");\n        uint256 customerFeeAmount = contracts[_contractId].customerFee * contracts[_contractId].amount / FEE_PRECISION;\n        uint256 customerAmount = contracts[_contractId].amount + customerFeeAmount;\n        contracts[_contractId].state = State.RETURNED_FUNDS_TO_CUSTOMER;\n        if (contracts[_contractId].token == weth) {\n            IWETH(weth).withdraw(customerAmount);\n            payable(contracts[_contractId].customer).transfer(customerAmount);\n        } else {\n            IERC20(contracts[_contractId].token).safeTransfer(\n                contracts[_contractId].customer,\n                customerAmount\n            );\n        }\n        emit RefundedToCustomer(_contractId, customerAmount);\n    }","after":"function refundToCustomerWithFreelancerSignature(\n        bytes32 _contractId,\n        bytes calldata signature\n    ) public onlyCustomer(_contractId) onlyCreatedState(_contractId) {\n        address signerAddress = _contractId.toEthSignedMessageHash().recover(signature);\n        require(signerAddress == contracts[_contractId].freelancer, \"Freelancer signature is incorrect\");\n        uint256 customerFeeAmount = contracts[_contractId].customerFee * contracts[_contractId].amount / FEE_PRECISION;\n        uint256 customerAmount = contracts[_contractId].amount + customerFeeAmount;\n        contracts[_contractId].state = State.RETURNED_FUNDS_TO_CUSTOMER;\n        if (contracts[_contractId].token == weth) {\n            IWETH(weth).withdraw(customerAmount);\n            payable(contracts[_contractId].customer).transfer(customerAmount);\n        } else {\n            IERC20(contracts[_contractId].token).safeTransfer(\n                contracts[_contractId].customer,\n                customerAmount\n            );\n        }\n        emit RefundedToCustomer(_contractId, customerAmount);\n    }","contract":"LaborXContract","time":0},{"type":"external-function ","before":"function addToken(\n        address _tokenAddress,\n        string memory _name,\n        string memory _symbol,\n        uint256 _decimals,\n        address _usdPriceContract,\n        bool _isStable\n    ) public onlyOwner {\n        (bool found,) = indexOfToken(_tokenAddress);\n        require(!found, 'Token already added');\n        tokens[_tokenAddress] = Token(_tokenAddress, _name, _symbol, _decimals, _usdPriceContract, _isStable);\n        tokenAddresses.push(_tokenAddress);\n        emit TokenAdded(_tokenAddress);\n    }","after":"function addToken(\n        address _tokenAddress,\n        string calldata _name,\n        string calldata _symbol,\n        uint256 _decimals,\n        address _usdPriceContract,\n        bool _isStable\n    ) public onlyOwner {\n        (bool found,) = indexOfToken(_tokenAddress);\n        require(!found, 'Token already added');\n        tokens[_tokenAddress] = Token(_tokenAddress, _name, _symbol, _decimals, _usdPriceContract, _isStable);\n        tokenAddresses.push(_tokenAddress);\n        emit TokenAdded(_tokenAddress);\n    }","contract":"TokenManager","time":0}]}