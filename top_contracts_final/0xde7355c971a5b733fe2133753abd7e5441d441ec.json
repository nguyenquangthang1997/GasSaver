{"time":159,"results":[{"type":"external-function ","before":"function appendStateBatch(\n    bytes32[] memory _batch,\n    uint256 _shouldStartAtElement\n  ) public {\n    // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\n    // publication of batches by some other user.\n    require(\n      _shouldStartAtElement == getTotalElements(),\n      'Actual batch start index does not match expected start index.'\n    );\n\n    // Proposers must have previously staked at the BondManager\n    require(\n      IBondManager(resolve('BondManager')).isCollateralized(msg.sender),\n      'Proposer does not have enough collateral posted'\n    );\n\n    require(_batch.length > 0, 'Cannot submit an empty state batch.');\n\n    require(\n      getTotalElements() + _batch.length <=\n        ICanonicalTransactionChain(resolve('CanonicalTransactionChain'))\n          .getTotalElements(),\n      'Number of state roots cannot exceed the number of canonical transactions.'\n    );\n\n    // Pass the block's timestamp and the publisher of the data\n    // to be used in the fraud proofs\n    _appendBatch(_batch, abi.encode(block.timestamp, msg.sender));\n  }","after":"function appendStateBatch(\n    bytes32[] calldata _batch,\n    uint256 _shouldStartAtElement\n  ) public {\n    // Fail fast in to make sure our batch roots aren't accidentally made fraudulent by the\n    // publication of batches by some other user.\n    require(\n      _shouldStartAtElement == getTotalElements(),\n      'Actual batch start index does not match expected start index.'\n    );\n\n    // Proposers must have previously staked at the BondManager\n    require(\n      IBondManager(resolve('BondManager')).isCollateralized(msg.sender),\n      'Proposer does not have enough collateral posted'\n    );\n\n    require(_batch.length > 0, 'Cannot submit an empty state batch.');\n\n    require(\n      getTotalElements() + _batch.length <=\n        ICanonicalTransactionChain(resolve('CanonicalTransactionChain'))\n          .getTotalElements(),\n      'Number of state roots cannot exceed the number of canonical transactions.'\n    );\n\n    // Pass the block's timestamp and the publisher of the data\n    // to be used in the fraud proofs\n    _appendBatch(_batch, abi.encode(block.timestamp, msg.sender));\n  }","contract":"StateCommitmentChain","time":0},{"type":"external-function ","before":"function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\n    public\n  {\n    require(\n      msg.sender == resolve('OVM_FraudVerifier'),\n      'State batches can only be deleted by the OVM_FraudVerifier.'\n    );\n\n    require(_isValidBatchHeader(_batchHeader), 'Invalid batch header.');\n\n    require(\n      insideFraudProofWindow(_batchHeader),\n      'State batches can only be deleted within the fraud proof window.'\n    );\n\n    _deleteBatch(_batchHeader);\n  }","after":"function deleteStateBatch(Lib_OVMCodec.ChainBatchHeader calldata _batchHeader)\n    public\n  {\n    require(\n      msg.sender == resolve('OVM_FraudVerifier'),\n      'State batches can only be deleted by the OVM_FraudVerifier.'\n    );\n\n    require(_isValidBatchHeader(_batchHeader), 'Invalid batch header.');\n\n    require(\n      insideFraudProofWindow(_batchHeader),\n      'State batches can only be deleted within the fraud proof window.'\n    );\n\n    _deleteBatch(_batchHeader);\n  }","contract":"StateCommitmentChain","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public FRAUD_PROOF_WINDOW;","after":"uint256 public immutable FRAUD_PROOF_WINDOW;","contract":"StateCommitmentChain","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public SEQUENCER_PUBLISH_WINDOW;","after":"uint256 public immutable SEQUENCER_PUBLISH_WINDOW;","contract":"StateCommitmentChain","time":1},{"type":"external-function ","before":"function setAddress(string memory _name, address _address)\n    external\n    onlyOwner\n  {\n    bytes32 nameHash = _getNameHash(_name);\n    address oldAddress = addresses[nameHash];\n    addresses[nameHash] = _address;\n\n    emit AddressSet(_name, _address, oldAddress);\n  }","after":"function setAddress(string calldata _name, address _address)\n    external\n    onlyOwner\n  {\n    bytes32 nameHash = _getNameHash(_name);\n    address oldAddress = addresses[nameHash];\n    addresses[nameHash] = _address;\n\n    emit AddressSet(_name, _address, oldAddress);\n  }","contract":"Lib_AddressManager","time":0}]}