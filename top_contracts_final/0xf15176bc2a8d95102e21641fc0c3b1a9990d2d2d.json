{"time":173,"results":[{"type":"external-function ","before":"function mintLegends(uint256[] memory _tokenIds, uint256[] memory _quantities, bytes32[] calldata _proof) public payable whenNotPaused nonReentrant {\n    require(_tokenIds.length == _quantities.length);\n    if (currentMerkleRoot != 0) {\n      require(verify(leaf(msg.sender, _tokenIds, _quantities), _proof), \"Invalid merkle proof\");\n    }\n\n    uint256 txCost = 0;\n    for (uint256 i = 0; i < _tokenIds.length; i++) {\n      txCost += tokens[_tokenIds[i]].mintPrice * _quantities[i];\n    }\n    require(txCost <= msg.value, \"Not enough ETH\");\n\n    for (uint256 i = 0; i < _tokenIds.length; i++) {\n      uint256 mintTokenRequired = tokens[_tokenIds[i]].mintTokenRequired;\n      if (mintTokenRequired > 0) {\n        require(mintToken.balanceOf(msg.sender, mintTokenRequired) >= 1, \"Must own a mint token\");\n        mintToken.burn(msg.sender, mintTokenRequired, 1);\n      }\n\n      mintInternal(msg.sender, _tokenIds[i], _quantities[i]);\n    }\n  }","after":"function mintLegends(uint256[] calldata _tokenIds, uint256[] calldata _quantities, bytes32[] calldata _proof) public payable whenNotPaused nonReentrant {\n    require(_tokenIds.length == _quantities.length);\n    if (currentMerkleRoot != 0) {\n      require(verify(leaf(msg.sender, _tokenIds, _quantities), _proof), \"Invalid merkle proof\");\n    }\n\n    uint256 txCost = 0;\n    for (uint256 i = 0; i < _tokenIds.length; i++) {\n      txCost += tokens[_tokenIds[i]].mintPrice * _quantities[i];\n    }\n    require(txCost <= msg.value, \"Not enough ETH\");\n\n    for (uint256 i = 0; i < _tokenIds.length; i++) {\n      uint256 mintTokenRequired = tokens[_tokenIds[i]].mintTokenRequired;\n      if (mintTokenRequired > 0) {\n        require(mintToken.balanceOf(msg.sender, mintTokenRequired) >= 1, \"Must own a mint token\");\n        mintToken.burn(msg.sender, mintTokenRequired, 1);\n      }\n\n      mintInternal(msg.sender, _tokenIds[i], _quantities[i]);\n    }\n  }","contract":"ApeDaoLegends","time":0},{"type":"external-function ","before":"function addToken(uint256 _mintPrice, uint256 _maxSupply, uint256 _mintTokenRequired, uint256 _maxTransactionLimit, string memory _name) public onlyOwner {\n    require(_mintTokenRequired <= 3);\n\n    tokenCounter.increment();\n\n    Token storage token = tokens[tokenCounter.current()];\n    token.mintPrice = _mintPrice;\n    token.maxSupply = _maxSupply;\n    token.maxTransactionLimit = _maxTransactionLimit;\n    token.name = _name;\n    token.mintTokenRequired = _mintTokenRequired;\n  }","after":"function addToken(uint256 _mintPrice, uint256 _maxSupply, uint256 _mintTokenRequired, uint256 _maxTransactionLimit, string calldata _name) public onlyOwner {\n    require(_mintTokenRequired <= 3);\n\n    tokenCounter.increment();\n\n    Token storage token = tokens[tokenCounter.current()];\n    token.mintPrice = _mintPrice;\n    token.maxSupply = _maxSupply;\n    token.maxTransactionLimit = _maxTransactionLimit;\n    token.name = _name;\n    token.mintTokenRequired = _mintTokenRequired;\n  }","contract":"ApeDaoLegends","time":0},{"type":"external-function ","before":"function setBaseURI(string memory _baseURI) public onlyOwner {\n    baseURI = _baseURI;\n  }","after":"function setBaseURI(string calldata _baseURI) public onlyOwner {\n    baseURI = _baseURI;\n  }","contract":"ApeDaoLegends","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"ApeDaoLegends","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"ApeDaoLegends","time":0},{"type":"external-function ","before":"function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }","after":"function burnBatch(\n        address account,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }","contract":"ApeDaoLegends","time":0}]}