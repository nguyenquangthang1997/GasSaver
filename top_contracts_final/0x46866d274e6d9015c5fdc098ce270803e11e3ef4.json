{"time":2428,"results":[{"type":"external-function ","before":"function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] memory amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            _getAPrecise(self),\n            self.lpToken,\n            0,\n            self.balances,\n            self.tokenPrecisionMultipliers\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        IERC20[] memory pooledTokens = self.pooledTokens;\n\n        require(\n            amounts.length == pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n\n        require(\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\n                maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n        {\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                balances1[i] = v.balances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }\n\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n        }\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1);\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }","after":"function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            _getAPrecise(self),\n            self.lpToken,\n            0,\n            self.balances,\n            self.tokenPrecisionMultipliers\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        IERC20[] memory pooledTokens = self.pooledTokens;\n\n        require(\n            amounts.length == pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n\n        require(\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\n                maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n        {\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                balances1[i] = v.balances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }\n\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n        }\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1);\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }","contract":"SwapUtils","time":0},{"type":"external-function ","before":"function initialize(string memory name, string memory symbol)\n        external\n        initializer\n        returns (bool)\n    {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __Ownable_init_unchained();\n        return true;\n    }","after":"function initialize(string calldata name, string calldata symbol)\n        external\n        initializer\n        returns (bool)\n    {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __Ownable_init_unchained();\n        return true;\n    }","contract":"LPToken","time":0},{"type":"external-function ","before":"function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual override initializer {\n        Swap.initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress\n        );\n        flashLoanFeeBPS = 8; // 8 bps\n        protocolFeeShareBPS = 0; // 0 bps\n    }","after":"function initialize(\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual override initializer {\n        Swap.initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress\n        );\n        flashLoanFeeBPS = 8; // 8 bps\n        protocolFeeShareBPS = 0; // 0 bps\n    }","contract":"SwapFlashLoan","time":0},{"type":"external-function ","before":"function flashLoan(\n        address receiver,\n        IERC20 token,\n        uint256 amount,\n        bytes memory params\n    ) external nonReentrant {\n        uint8 tokenIndex = getTokenIndex(address(token));\n        uint256 availableLiquidityBefore = token.balanceOf(address(this));\n        uint256 protocolBalanceBefore = availableLiquidityBefore.sub(\n            swapStorage.balances[tokenIndex]\n        );\n        require(\n            amount > 0 && availableLiquidityBefore >= amount,\n            \"invalid amount\"\n        );\n\n        // Calculate the additional amount of tokens the pool should end up with\n        uint256 amountFee = amount.mul(flashLoanFeeBPS).div(10000);\n        // Calculate the portion of the fee that will go to the protocol\n        uint256 protocolFee = amountFee.mul(protocolFeeShareBPS).div(10000);\n        require(amountFee > 0, \"amount is small for a flashLoan\");\n\n        // Transfer the requested amount of tokens\n        token.safeTransfer(receiver, amount);\n\n        // Execute callback function on receiver\n        IFlashLoanReceiver(receiver).executeOperation(\n            address(this),\n            address(token),\n            amount,\n            amountFee,\n            params\n        );\n\n        uint256 availableLiquidityAfter = token.balanceOf(address(this));\n        require(\n            availableLiquidityAfter >= availableLiquidityBefore.add(amountFee),\n            \"flashLoan fee is not met\"\n        );\n\n        swapStorage.balances[tokenIndex] = availableLiquidityAfter\n            .sub(protocolBalanceBefore)\n            .sub(protocolFee);\n        emit FlashLoan(receiver, tokenIndex, amount, amountFee, protocolFee);\n    }","after":"function flashLoan(\n        address receiver,\n        IERC20 token,\n        uint256 amount,\n        bytes calldata params\n    ) external nonReentrant {\n        uint8 tokenIndex = getTokenIndex(address(token));\n        uint256 availableLiquidityBefore = token.balanceOf(address(this));\n        uint256 protocolBalanceBefore = availableLiquidityBefore.sub(\n            swapStorage.balances[tokenIndex]\n        );\n        require(\n            amount > 0 && availableLiquidityBefore >= amount,\n            \"invalid amount\"\n        );\n\n        // Calculate the additional amount of tokens the pool should end up with\n        uint256 amountFee = amount.mul(flashLoanFeeBPS).div(10000);\n        // Calculate the portion of the fee that will go to the protocol\n        uint256 protocolFee = amountFee.mul(protocolFeeShareBPS).div(10000);\n        require(amountFee > 0, \"amount is small for a flashLoan\");\n\n        // Transfer the requested amount of tokens\n        token.safeTransfer(receiver, amount);\n\n        // Execute callback function on receiver\n        IFlashLoanReceiver(receiver).executeOperation(\n            address(this),\n            address(token),\n            amount,\n            amountFee,\n            params\n        );\n\n        uint256 availableLiquidityAfter = token.balanceOf(address(this));\n        require(\n            availableLiquidityAfter >= availableLiquidityBefore.add(amountFee),\n            \"flashLoan fee is not met\"\n        );\n\n        swapStorage.balances[tokenIndex] = availableLiquidityAfter\n            .sub(protocolBalanceBefore)\n            .sub(protocolFee);\n        emit FlashLoan(receiver, tokenIndex, amount, amountFee, protocolFee);\n    }","contract":"SwapFlashLoan","time":0},{"type":"external-function ","before":"function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual initializer {\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                        _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            precisionMultipliers[i] =\n                10 **\n                    uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(\n                        uint256(decimals[i])\n                    );\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < AmplificationUtils.MAX_A, \"_a exceeds maximum\");\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < SwapUtils.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n\n        // Clone and initialize a LPToken contract\n        LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n        require(\n            lpToken.initialize(lpTokenName, lpTokenSymbol),\n            \"could not init lpToken clone\"\n        );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = lpToken;\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a.mul(AmplificationUtils.A_PRECISION);\n        swapStorage.futureA = _a.mul(AmplificationUtils.A_PRECISION);\n        // swapStorage.initialATime = 0;\n        // swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n    }","after":"function initialize(\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual initializer {\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                        _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            precisionMultipliers[i] =\n                10 **\n                    uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(\n                        uint256(decimals[i])\n                    );\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < AmplificationUtils.MAX_A, \"_a exceeds maximum\");\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < SwapUtils.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n\n        // Clone and initialize a LPToken contract\n        LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n        require(\n            lpToken.initialize(lpTokenName, lpTokenSymbol),\n            \"could not init lpToken clone\"\n        );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = lpToken;\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a.mul(AmplificationUtils.A_PRECISION);\n        swapStorage.futureA = _a.mul(AmplificationUtils.A_PRECISION);\n        // swapStorage.initialATime = 0;\n        // swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n    }","contract":"SwapFlashLoan","time":0},{"type":"external-function ","before":"function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        address lpTokenTargetAddress\n    ) public virtual override initializer {\n        SwapV1.initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            _withdrawFee,\n            lpTokenTargetAddress\n        );\n        flashLoanFeeBPS = 8; // 8 bps\n        protocolFeeShareBPS = 0; // 0 bps\n    }","after":"function initialize(\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        address lpTokenTargetAddress\n    ) public virtual override initializer {\n        SwapV1.initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            _withdrawFee,\n            lpTokenTargetAddress\n        );\n        flashLoanFeeBPS = 8; // 8 bps\n        protocolFeeShareBPS = 0; // 0 bps\n    }","contract":"SwapFlashLoanV1","time":0},{"type":"external-function ","before":"function flashLoan(\n        address receiver,\n        IERC20 token,\n        uint256 amount,\n        bytes memory params\n    ) external nonReentrant {\n        uint8 tokenIndex = getTokenIndex(address(token));\n        uint256 availableLiquidityBefore = token.balanceOf(address(this));\n        uint256 protocolBalanceBefore = availableLiquidityBefore.sub(\n            swapStorage.balances[tokenIndex]\n        );\n        require(\n            amount > 0 && availableLiquidityBefore >= amount,\n            \"invalid amount\"\n        );\n\n        // Calculate the additional amount of tokens the pool should end up with\n        uint256 amountFee = amount.mul(flashLoanFeeBPS).div(10000);\n        // Calculate the portion of the fee that will go to the protocol\n        uint256 protocolFee = amountFee.mul(protocolFeeShareBPS).div(10000);\n        require(amountFee > 0, \"amount is small for a flashLoan\");\n\n        // Transfer the requested amount of tokens\n        token.safeTransfer(receiver, amount);\n\n        // Execute callback function on receiver\n        IFlashLoanReceiver(receiver).executeOperation(\n            address(this),\n            address(token),\n            amount,\n            amountFee,\n            params\n        );\n\n        uint256 availableLiquidityAfter = token.balanceOf(address(this));\n        require(\n            availableLiquidityAfter >= availableLiquidityBefore.add(amountFee),\n            \"flashLoan fee is not met\"\n        );\n\n        swapStorage.balances[tokenIndex] = availableLiquidityAfter\n            .sub(protocolBalanceBefore)\n            .sub(protocolFee);\n        emit FlashLoan(receiver, tokenIndex, amount, amountFee, protocolFee);\n    }","after":"function flashLoan(\n        address receiver,\n        IERC20 token,\n        uint256 amount,\n        bytes calldata params\n    ) external nonReentrant {\n        uint8 tokenIndex = getTokenIndex(address(token));\n        uint256 availableLiquidityBefore = token.balanceOf(address(this));\n        uint256 protocolBalanceBefore = availableLiquidityBefore.sub(\n            swapStorage.balances[tokenIndex]\n        );\n        require(\n            amount > 0 && availableLiquidityBefore >= amount,\n            \"invalid amount\"\n        );\n\n        // Calculate the additional amount of tokens the pool should end up with\n        uint256 amountFee = amount.mul(flashLoanFeeBPS).div(10000);\n        // Calculate the portion of the fee that will go to the protocol\n        uint256 protocolFee = amountFee.mul(protocolFeeShareBPS).div(10000);\n        require(amountFee > 0, \"amount is small for a flashLoan\");\n\n        // Transfer the requested amount of tokens\n        token.safeTransfer(receiver, amount);\n\n        // Execute callback function on receiver\n        IFlashLoanReceiver(receiver).executeOperation(\n            address(this),\n            address(token),\n            amount,\n            amountFee,\n            params\n        );\n\n        uint256 availableLiquidityAfter = token.balanceOf(address(this));\n        require(\n            availableLiquidityAfter >= availableLiquidityBefore.add(amountFee),\n            \"flashLoan fee is not met\"\n        );\n\n        swapStorage.balances[tokenIndex] = availableLiquidityAfter\n            .sub(protocolBalanceBefore)\n            .sub(protocolFee);\n        emit FlashLoan(receiver, tokenIndex, amount, amountFee, protocolFee);\n    }","contract":"SwapFlashLoanV1","time":0},{"type":"external-function ","before":"function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        address lpTokenTargetAddress\n    ) public virtual initializer {\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                        _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= SwapUtilsV1.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            precisionMultipliers[i] =\n                10 **\n                    uint256(SwapUtilsV1.POOL_PRECISION_DECIMALS).sub(\n                        uint256(decimals[i])\n                    );\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < AmplificationUtilsV1.MAX_A, \"_a exceeds maximum\");\n        require(_fee < SwapUtilsV1.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < SwapUtilsV1.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n        require(\n            _withdrawFee < SwapUtilsV1.MAX_WITHDRAW_FEE,\n            \"_withdrawFee exceeds maximum\"\n        );\n\n        // Clone and initialize a LPToken contract\n        LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n        require(\n            lpToken.initialize(lpTokenName, lpTokenSymbol),\n            \"could not init lpToken clone\"\n        );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = lpToken;\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a.mul(AmplificationUtilsV1.A_PRECISION);\n        swapStorage.futureA = _a.mul(AmplificationUtilsV1.A_PRECISION);\n        // swapStorage.initialATime = 0;\n        // swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n        swapStorage.defaultWithdrawFee = _withdrawFee;\n    }","after":"function initialize(\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        address lpTokenTargetAddress\n    ) public virtual initializer {\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                        _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= SwapUtilsV1.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            precisionMultipliers[i] =\n                10 **\n                    uint256(SwapUtilsV1.POOL_PRECISION_DECIMALS).sub(\n                        uint256(decimals[i])\n                    );\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < AmplificationUtilsV1.MAX_A, \"_a exceeds maximum\");\n        require(_fee < SwapUtilsV1.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < SwapUtilsV1.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n        require(\n            _withdrawFee < SwapUtilsV1.MAX_WITHDRAW_FEE,\n            \"_withdrawFee exceeds maximum\"\n        );\n\n        // Clone and initialize a LPToken contract\n        LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n        require(\n            lpToken.initialize(lpTokenName, lpTokenSymbol),\n            \"could not init lpToken clone\"\n        );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = lpToken;\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a.mul(AmplificationUtilsV1.A_PRECISION);\n        swapStorage.futureA = _a.mul(AmplificationUtilsV1.A_PRECISION);\n        // swapStorage.initialATime = 0;\n        // swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n        swapStorage.defaultWithdrawFee = _withdrawFee;\n    }","contract":"SwapFlashLoanV1","time":0},{"type":"external-function ","before":"function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] memory amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            _getAPrecise(self),\n            self.lpToken,\n            0,\n            self.balances,\n            self.tokenPrecisionMultipliers\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        IERC20[] memory pooledTokens = self.pooledTokens;\n\n        require(\n            amounts.length == pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n\n        require(\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\n                maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n        {\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                balances1[i] = v.balances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }\n\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n        }\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1).mul(FEE_DENOMINATOR).div(\n            FEE_DENOMINATOR.sub(_calculateCurrentWithdrawFee(self, msg.sender))\n        );\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }","after":"function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            _getAPrecise(self),\n            self.lpToken,\n            0,\n            self.balances,\n            self.tokenPrecisionMultipliers\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        IERC20[] memory pooledTokens = self.pooledTokens;\n\n        require(\n            amounts.length == pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n\n        require(\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\n                maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n        {\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                balances1[i] = v.balances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }\n\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n        }\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1).mul(FEE_DENOMINATOR).div(\n            FEE_DENOMINATOR.sub(_calculateCurrentWithdrawFee(self, msg.sender))\n        );\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }","contract":"SwapUtilsV1","time":1},{"type":"external-function ","before":"function removeLiquidityImbalance(\n        SwapUtils.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint256[] memory amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        // Using this struct to avoid stack too deep error\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            self.lpToken,\n            0,\n            self._getAPrecise(),\n            _updateBaseVirtualPrice(metaSwapStorage),\n            self.tokenPrecisionMultipliers,\n            self.balances\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        require(\n            amounts.length == v.newBalances.length,\n            \"Amounts should match pool tokens\"\n        );\n        require(maxBurnAmount != 0, \"Must burn more than 0\");\n\n        uint256 feePerToken = SwapUtils._feePerToken(\n            self.swapFee,\n            v.newBalances.length\n        );\n\n        // Calculate how much LPToken should be burned\n        uint256[] memory fees = new uint256[](v.newBalances.length);\n        {\n            uint256[] memory balances1 = new uint256[](v.newBalances.length);\n\n            v.d0 = SwapUtils.getD(\n                _xp(\n                    v.newBalances,\n                    v.tokenPrecisionMultipliers,\n                    v.baseVirtualPrice\n                ),\n                v.preciseA\n            );\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\n                balances1[i] = v.newBalances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n            v.d1 = SwapUtils.getD(\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\n                v.preciseA\n            );\n\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.newBalances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }\n\n            v.d2 = SwapUtils.getD(\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\n                v.preciseA\n            );\n        }\n\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n\n        // Scale up by withdraw fee\n        tokenAmount = tokenAmount.add(1);\n\n        // Check for max burn amount\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        // Burn the calculated amount of LPToken from the caller and send the desired tokens\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n        for (uint256 i = 0; i < v.newBalances.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }","after":"function removeLiquidityImbalance(\n        SwapUtils.Swap storage self,\n        MetaSwap storage metaSwapStorage,\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        // Using this struct to avoid stack too deep error\n        ManageLiquidityInfo memory v = ManageLiquidityInfo(\n            0,\n            0,\n            0,\n            self.lpToken,\n            0,\n            self._getAPrecise(),\n            _updateBaseVirtualPrice(metaSwapStorage),\n            self.tokenPrecisionMultipliers,\n            self.balances\n        );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        require(\n            amounts.length == v.newBalances.length,\n            \"Amounts should match pool tokens\"\n        );\n        require(maxBurnAmount != 0, \"Must burn more than 0\");\n\n        uint256 feePerToken = SwapUtils._feePerToken(\n            self.swapFee,\n            v.newBalances.length\n        );\n\n        // Calculate how much LPToken should be burned\n        uint256[] memory fees = new uint256[](v.newBalances.length);\n        {\n            uint256[] memory balances1 = new uint256[](v.newBalances.length);\n\n            v.d0 = SwapUtils.getD(\n                _xp(\n                    v.newBalances,\n                    v.tokenPrecisionMultipliers,\n                    v.baseVirtualPrice\n                ),\n                v.preciseA\n            );\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\n                balances1[i] = v.newBalances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n            v.d1 = SwapUtils.getD(\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\n                v.preciseA\n            );\n\n            for (uint256 i = 0; i < v.newBalances.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.newBalances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }\n\n            v.d2 = SwapUtils.getD(\n                _xp(balances1, v.tokenPrecisionMultipliers, v.baseVirtualPrice),\n                v.preciseA\n            );\n        }\n\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n\n        // Scale up by withdraw fee\n        tokenAmount = tokenAmount.add(1);\n\n        // Check for max burn amount\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        // Burn the calculated amount of LPToken from the caller and send the desired tokens\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n        for (uint256 i = 0; i < v.newBalances.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }","contract":"MetaSwapUtils","time":0},{"type":"external-function ","before":"function deploy(\n        address swapAddress,\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) external returns (address) {\n        address swapClone = _clone(swapAddress);\n        ISwap(swapClone).initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress\n        );\n        Ownable(swapClone).transferOwnership(owner());\n        emit NewSwapPool(msg.sender, swapClone, _pooledTokens);\n        return swapClone;\n    }","after":"function deploy(\n        address swapAddress,\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) external returns (address) {\n        address swapClone = _clone(swapAddress);\n        ISwap(swapClone).initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress\n        );\n        Ownable(swapClone).transferOwnership(owner());\n        emit NewSwapPool(msg.sender, swapClone, _pooledTokens);\n        return swapClone;\n    }","contract":"SwapDeployer","time":0},{"type":"external-function ","before":"function deployMetaSwap(\n        address metaSwapAddress,\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress,\n        ISwap baseSwap\n    ) external returns (address) {\n        address metaSwapClone = _clone(metaSwapAddress);\n        IMetaSwap(metaSwapClone).initializeMetaSwap(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress,\n            baseSwap\n        );\n        Ownable(metaSwapClone).transferOwnership(owner());\n        emit NewSwapPool(msg.sender, metaSwapClone, _pooledTokens);\n        return metaSwapClone;\n    }","after":"function deployMetaSwap(\n        address metaSwapAddress,\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress,\n        ISwap baseSwap\n    ) external returns (address) {\n        address metaSwapClone = _clone(metaSwapAddress);\n        IMetaSwap(metaSwapClone).initializeMetaSwap(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress,\n            baseSwap\n        );\n        Ownable(metaSwapClone).transferOwnership(owner());\n        emit NewSwapPool(msg.sender, metaSwapClone, _pooledTokens);\n        return metaSwapClone;\n    }","contract":"SwapDeployer","time":0},{"type":"external-function ","before":"function initialize(string memory name, string memory symbol)\n        external\n        initializer\n        returns (bool)\n    {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __Ownable_init_unchained();\n        return true;\n    }","after":"function initialize(string calldata name, string calldata symbol)\n        external\n        initializer\n        returns (bool)\n    {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __Ownable_init_unchained();\n        return true;\n    }","contract":"LPTokenV1","time":0},{"type":"external-function ","before":"function deploy(\n        address swapAddress,\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        address lpTokenTargetAddress\n    ) external returns (address) {\n        address swapClone = Clones.clone(swapAddress);\n        ISwapV1(swapClone).initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            _withdrawFee,\n            lpTokenTargetAddress\n        );\n        Ownable(swapClone).transferOwnership(owner());\n        emit NewSwapPool(msg.sender, swapClone, _pooledTokens);\n        return swapClone;\n    }","after":"function deploy(\n        address swapAddress,\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        uint256 _withdrawFee,\n        address lpTokenTargetAddress\n    ) external returns (address) {\n        address swapClone = Clones.clone(swapAddress);\n        ISwapV1(swapClone).initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            _withdrawFee,\n            lpTokenTargetAddress\n        );\n        Ownable(swapClone).transferOwnership(owner());\n        emit NewSwapPool(msg.sender, swapClone, _pooledTokens);\n        return swapClone;\n    }","contract":"SwapDeployerV1","time":0},{"type":"immutable-restrict-modification ","before":"address public owner;","after":"address public immutable owner;","contract":"SwapMigrator","time":0},{"type":"external-function ","before":"  function flashLoan(\n        ISwapFlashLoan swap,\n        IERC20 token,\n        uint256 amount,\n        bytes memory params\n    ) external {\n        swap.flashLoan(address(this), token, amount, params);\n   ","after":"  function flashLoan(\n        ISwapFlashLoan swap,\n        IERC20 token,\n        uint256 amount,\n        bytes calldata params\n    ) external {\n        swap.flashLoan(address(this), token, amount, params);\n   ","contract":"FlashLoanBorrowerExample","time":0},{"type":"external-function ","before":"  function test_removeLiquidity(uint256 amount, uint256[] memory minAmounts)\n        public\n    {\n        uint256[] memory balanceBefore = new uint256[](n);\n        uint256[] memory balanceAfter = new uint256[](n);\n\n        for (uint8 i = 0; i < n; i++) {\n            balanceBefore[i] = swap.getToken(i).balanceOf(address(this));\n        }\n\n        uint256[] memory returnValue = swap.removeLiquidity(\n            amount,\n            minAmounts,\n            MAX_INT\n        );\n\n        for (uint8 i = 0; i < n; i++) {\n            balanceAfter[i] = swap.getToken(i).balanceOf(address(this));\n            console.log(\n                \"removeLiquidity: Expected %s, got %s\",\n                balanceAfter[i].sub(balanceBefore[i]),\n                returnValue[i]\n            );\n            require(\n                balanceAfter[i].sub(balanceBefore[i]) == returnValue[i],\n                \"removeLiquidity()'s return value does not match received amounts of tokens\"\n            );\n        }\n   ","after":"  function test_removeLiquidity(uint256 amount, uint256[] calldata minAmounts)\n        public\n    {\n        uint256[] memory balanceBefore = new uint256[](n);\n        uint256[] memory balanceAfter = new uint256[](n);\n\n        for (uint8 i = 0; i < n; i++) {\n            balanceBefore[i] = swap.getToken(i).balanceOf(address(this));\n        }\n\n        uint256[] memory returnValue = swap.removeLiquidity(\n            amount,\n            minAmounts,\n            MAX_INT\n        );\n\n        for (uint8 i = 0; i < n; i++) {\n            balanceAfter[i] = swap.getToken(i).balanceOf(address(this));\n            console.log(\n                \"removeLiquidity: Expected %s, got %s\",\n                balanceAfter[i].sub(balanceBefore[i]),\n                returnValue[i]\n            );\n            require(\n                balanceAfter[i].sub(balanceBefore[i]) == returnValue[i],\n                \"removeLiquidity()'s return value does not match received amounts of tokens\"\n            );\n        }\n   ","contract":"TestSwapReturnValues","time":0},{"type":"immutable-restrict-modification ","before":"  uint8 public ","after":"  uiimmutable nt8 public ","contract":"TestSwapReturnValues","time":0},{"type":"external-function ","before":"  function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] memory amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        require(\n            amounts.length == self.pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n        require(\n            maxBurnAmount <= self.lpToken.balanceOf(msg.sender) &&\n                maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        RemoveLiquidityImbalanceInfo memory v = RemoveLiquidityImbalanceInfo(\n            0,\n            0,\n            0,\n            0\n        );\n\n        uint256 tokenSupply = self.lpToken.totalSupply();\n        uint256 feePerToken = _feePerToken(self);\n\n        uint256[] memory balances1 = self.balances;\n\n        v.preciseA = _getAPrecise(self);\n        v.d0 = getD(_xp(self), v.preciseA);\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            balances1[i] = balances1[i].sub(\n                amounts[i],\n                \"Cannot withdraw more than available\"\n            );\n        }\n        v.d1 = getD(_xp(self, balances1), v.preciseA);\n        uint256[] memory fees = new uint256[](self.pooledTokens.length);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\n            uint256 difference = idealBalance.difference(balances1[i]);\n            fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n            self.balances[i] = balances1[i].sub(\n                fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n            );\n            balances1[i] = balances1[i].sub(fees[i]);\n        }\n\n        v.d2 = getD(_xp(self, balances1), v.preciseA);\n\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(tokenSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1).mul(FEE_DENOMINATOR).div(\n            FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, msg.sender))\n        );\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        self.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            tokenSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n   ","after":"  function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        require(\n            amounts.length == self.pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n        require(\n            maxBurnAmount <= self.lpToken.balanceOf(msg.sender) &&\n                maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        RemoveLiquidityImbalanceInfo memory v = RemoveLiquidityImbalanceInfo(\n            0,\n            0,\n            0,\n            0\n        );\n\n        uint256 tokenSupply = self.lpToken.totalSupply();\n        uint256 feePerToken = _feePerToken(self);\n\n        uint256[] memory balances1 = self.balances;\n\n        v.preciseA = _getAPrecise(self);\n        v.d0 = getD(_xp(self), v.preciseA);\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            balances1[i] = balances1[i].sub(\n                amounts[i],\n                \"Cannot withdraw more than available\"\n            );\n        }\n        v.d1 = getD(_xp(self, balances1), v.preciseA);\n        uint256[] memory fees = new uint256[](self.pooledTokens.length);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            uint256 idealBalance = v.d1.mul(self.balances[i]).div(v.d0);\n            uint256 difference = idealBalance.difference(balances1[i]);\n            fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n            self.balances[i] = balances1[i].sub(\n                fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n            );\n            balances1[i] = balances1[i].sub(fees[i]);\n        }\n\n        v.d2 = getD(_xp(self, balances1), v.preciseA);\n\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(tokenSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1).mul(FEE_DENOMINATOR).div(\n            FEE_DENOMINATOR.sub(calculateCurrentWithdrawFee(self, msg.sender))\n        );\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        self.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < self.pooledTokens.length; i++) {\n            self.pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            tokenSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n   ","contract":"SwapUtilsGuarded","time":0},{"type":"external-function ","before":"  function addMigrationData(\n        address oldPoolAddress,\n        MigrationData memory mData,\n        bool overwrite\n    ) external onlyOwner {\n        // Check\n        if (!overwrite) {\n            require(\n                address(migrationMap[oldPoolAddress].oldPoolLPTokenAddress) ==\n                    address(0),\n                \"cannot overwrite existing migration data\"\n            );\n        }\n        require(\n            address(mData.oldPoolLPTokenAddress) != address(0),\n            \"oldPoolLPTokenAddress == 0\"\n        );\n        require(\n            address(mData.newPoolLPTokenAddress) != address(0),\n            \"newPoolLPTokenAddress == 0\"\n        );\n\n        for (uint8 i = 0; i < 32; i++) {\n            address oldPoolToken;\n            try ISwap(oldPoolAddress).getToken(i) returns (IERC20 token) {\n                oldPoolToken = address(token);\n            } catch {\n                require(i > 0, \"Failed to get tokens underlying Saddle pool.\");\n                oldPoolToken = address(0);\n            }\n\n            try ISwap(mData.newPoolAddress).getToken(i) returns (IERC20 token) {\n                require(\n                    oldPoolToken == address(token) &&\n                        oldPoolToken == address(mData.tokens[i]),\n                    \"Failed to match tokens list\"\n                );\n            } catch {\n                require(i > 0, \"Failed to get tokens underlying Saddle pool.\");\n                require(\n                    oldPoolToken == address(0) && i == mData.tokens.length,\n                    \"Failed to match tokens list\"\n                );\n                break;\n            }\n        }\n\n        // Effect\n        migrationMap[oldPoolAddress] = mData;\n\n        // Interaction\n        // Approve old LP Token to be used for withdraws.\n        mData.oldPoolLPTokenAddress.approve(oldPoolAddress, MAX_UINT256);\n\n        // Approve underlying tokens to be used for deposits.\n        for (uint256 i = 0; i < mData.tokens.length; i++) {\n            mData.tokens[i].safeApprove(mData.newPoolAddress, 0);\n            mData.tokens[i].safeApprove(mData.newPoolAddress, MAX_UINT256);\n        }\n\n        emit AddMigrationData(oldPoolAddress, mData);\n   ","after":"  function addMigrationData(\n        address oldPoolAddress,\n        MigrationData calldata mData,\n        bool overwrite\n    ) external onlyOwner {\n        // Check\n        if (!overwrite) {\n            require(\n                address(migrationMap[oldPoolAddress].oldPoolLPTokenAddress) ==\n                    address(0),\n                \"cannot overwrite existing migration data\"\n            );\n        }\n        require(\n            address(mData.oldPoolLPTokenAddress) != address(0),\n            \"oldPoolLPTokenAddress == 0\"\n        );\n        require(\n            address(mData.newPoolLPTokenAddress) != address(0),\n            \"newPoolLPTokenAddress == 0\"\n        );\n\n        for (uint8 i = 0; i < 32; i++) {\n            address oldPoolToken;\n            try ISwap(oldPoolAddress).getToken(i) returns (IERC20 token) {\n                oldPoolToken = address(token);\n            } catch {\n                require(i > 0, \"Failed to get tokens underlying Saddle pool.\");\n                oldPoolToken = address(0);\n            }\n\n            try ISwap(mData.newPoolAddress).getToken(i) returns (IERC20 token) {\n                require(\n                    oldPoolToken == address(token) &&\n                        oldPoolToken == address(mData.tokens[i]),\n                    \"Failed to match tokens list\"\n                );\n            } catch {\n                require(i > 0, \"Failed to get tokens underlying Saddle pool.\");\n                require(\n                    oldPoolToken == address(0) && i == mData.tokens.length,\n                    \"Failed to match tokens list\"\n                );\n                break;\n            }\n        }\n\n        // Effect\n        migrationMap[oldPoolAddress] = mData;\n\n        // Interaction\n        // Approve old LP Token to be used for withdraws.\n        mData.oldPoolLPTokenAddress.approve(oldPoolAddress, MAX_UINT256);\n\n        // Approve underlying tokens to be used for deposits.\n        for (uint256 i = 0; i < mData.tokens.length; i++) {\n            mData.tokens[i].safeApprove(mData.newPoolAddress, 0);\n            mData.tokens[i].safeApprove(mData.newPoolAddress, MAX_UINT256);\n        }\n\n        emit AddMigrationData(oldPoolAddress, mData);\n   ","contract":"GeneralizedSwapMigrator","time":0},{"type":"external-function ","before":"  function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual override initializer {\n        revert(\"use initializeMetaSwap() instead\");\n   ","after":"  function initialize(\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual override initializer {\n        revert(\"use initializeMetaSwap() instead\");\n   ","contract":"MetaSwap","time":0},{"type":"external-function ","before":"  function initializeMetaSwap(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress,\n        ISwap baseSwap\n    ) external virtual initializer {\n        Swap.initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress\n        );\n\n        // MetaSwap initializer\n        metaSwapStorage.baseSwap = baseSwap;\n        metaSwapStorage.baseVirtualPrice = baseSwap.getVirtualPrice();\n        metaSwapStorage.baseCacheLastUpdated = block.timestamp;\n\n        // Read all tokens that belong to baseSwap\n        {\n            uint8 i;\n            for (; i < 32; i++) {\n                try baseSwap.getToken(i) returns (IERC20 token) {\n                    metaSwapStorage.baseTokens.push(token);\n                    token.safeApprove(address(baseSwap), MAX_UINT256);\n                } catch {\n                    break;\n                }\n            }\n            require(i > 1, \"baseSwap must pool at least 2 tokens\");\n        }\n\n        // Check the last element of _pooledTokens is owned by baseSwap\n        IERC20 baseLPToken = _pooledTokens[_pooledTokens.length - 1];\n        require(\n            LPToken(address(baseLPToken)).owner() == address(baseSwap),\n            \"baseLPToken is not owned by baseSwap\"\n        );\n\n        // Pre-approve the baseLPToken to be used by baseSwap\n        baseLPToken.safeApprove(address(baseSwap), MAX_UINT256);\n   ","after":"  function initializeMetaSwap(\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress,\n        ISwap baseSwap\n    ) external virtual initializer {\n        Swap.initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress\n        );\n\n        // MetaSwap initializer\n        metaSwapStorage.baseSwap = baseSwap;\n        metaSwapStorage.baseVirtualPrice = baseSwap.getVirtualPrice();\n        metaSwapStorage.baseCacheLastUpdated = block.timestamp;\n\n        // Read all tokens that belong to baseSwap\n        {\n            uint8 i;\n            for (; i < 32; i++) {\n                try baseSwap.getToken(i) returns (IERC20 token) {\n                    metaSwapStorage.baseTokens.push(token);\n                    token.safeApprove(address(baseSwap), MAX_UINT256);\n                } catch {\n                    break;\n                }\n            }\n            require(i > 1, \"baseSwap must pool at least 2 tokens\");\n        }\n\n        // Check the last element of _pooledTokens is owned by baseSwap\n        IERC20 baseLPToken = _pooledTokens[_pooledTokens.length - 1];\n        require(\n            LPToken(address(baseLPToken)).owner() == address(baseSwap),\n            \"baseLPToken is not owned by baseSwap\"\n        );\n\n        // Pre-approve the baseLPToken to be used by baseSwap\n        baseLPToken.safeApprove(address(baseSwap), MAX_UINT256);\n   ","contract":"MetaSwap","time":0},{"type":"external-function ","before":"function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual initializer {\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                        _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            precisionMultipliers[i] =\n                10 **\n                    uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(\n                        uint256(decimals[i])\n                    );\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < AmplificationUtils.MAX_A, \"_a exceeds maximum\");\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < SwapUtils.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n\n        // Clone and initialize a LPToken contract\n        LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n        require(\n            lpToken.initialize(lpTokenName, lpTokenSymbol),\n            \"could not init lpToken clone\"\n        );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = lpToken;\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a.mul(AmplificationUtils.A_PRECISION);\n        swapStorage.futureA = _a.mul(AmplificationUtils.A_PRECISION);\n        // swapStorage.initialATime = 0;\n        // swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n    }","after":"function initialize(\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual initializer {\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                        _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            precisionMultipliers[i] =\n                10 **\n                    uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(\n                        uint256(decimals[i])\n                    );\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < AmplificationUtils.MAX_A, \"_a exceeds maximum\");\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < SwapUtils.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n\n        // Clone and initialize a LPToken contract\n        LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n        require(\n            lpToken.initialize(lpTokenName, lpTokenSymbol),\n            \"could not init lpToken clone\"\n        );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = lpToken;\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a.mul(AmplificationUtils.A_PRECISION);\n        swapStorage.futureA = _a.mul(AmplificationUtils.A_PRECISION);\n        // swapStorage.initialATime = 0;\n        // swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n    }","contract":"MetaSwap","time":0}]}