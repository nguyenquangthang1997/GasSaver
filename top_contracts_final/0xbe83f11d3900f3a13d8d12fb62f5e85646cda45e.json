{"time":134,"results":[{"type":"state-data-arrangement ","before":"\naddress public WBTC_ADDR;\naddress public lpToken;\nmapping(address => bool) public whitelist;\nuint8 public churnedInCount;\nuint8 public tssThreshold;\nuint8 public nodeRewardsRatio;\nuint8 public depositFeesBPS;\nuint8 public withdrawalFeeBPS;\nuint256 public lockedLPTokensForNode;\nuint256 public feesLPTokensForNode;\nuint256 public initialExchangeRate;\nuint256 private priceDecimals;\nuint256 private lpDecimals;\nmapping(address => uint256) private floatAmountOf;\nmapping(bytes32 => bool) private used;\nmapping(address => bytes32) private nodes;\nmapping(address => bool) private isInList;\naddress[] private nodeAddrs;","after":"mapping(address => bool) public whitelist;\nuint256 public lockedLPTokensForNode;\nuint256 public feesLPTokensForNode;\nuint256 public initialExchangeRate;\nuint256 private priceDecimals;\nuint256 private lpDecimals;\nmapping(address => uint256) private floatAmountOf;\nmapping(bytes32 => bool) private used;\nmapping(address => bytes32) private nodes;\nmapping(address => bool) private isInList;\naddress[] private nodeAddrs;\naddress public WBTC_ADDR;\naddress public lpToken;\nuint8 public churnedInCount;\nuint8 public tssThreshold;\nuint8 public nodeRewardsRatio;\nuint8 public depositFeesBPS;\nuint8 public withdrawalFeeBPS;\n","contract":"SwapContract","time":1},{"type":"external-function ","before":"function singleTransferERC20(\n        address _destToken,\n        address _to,\n        uint256 _amount,\n        uint256 _totalSwapped,\n        uint256 _rewardsAmount,\n        bytes32[] memory _redeemedFloatTxIds\n    ) external override onlyOwner returns (bool) {\n        require(whitelist[_destToken], \"_destToken is not whitelisted\");\n        require(\n            _destToken != address(0),\n            \"_destToken should not be address(0)\"\n        );\n        address _feesToken = address(0);\n        if (_totalSwapped > 0) {\n            _swap(address(0), WBTC_ADDR, _totalSwapped);\n        } else if (_totalSwapped == 0) {\n            _feesToken = WBTC_ADDR;\n        }\n        if (_destToken == lpToken) {\n            _feesToken = lpToken;\n        }\n        _rewardsCollection(_feesToken, _rewardsAmount);\n        _addUsedTxs(_redeemedFloatTxIds);\n        require(IERC20(_destToken).transfer(_to, _amount));\n        return true;\n    }","after":"function singleTransferERC20(\n        address _destToken,\n        address _to,\n        uint256 _amount,\n        uint256 _totalSwapped,\n        uint256 _rewardsAmount,\n        bytes32[] calldata _redeemedFloatTxIds\n    ) external override onlyOwner returns (bool) {\n        require(whitelist[_destToken], \"_destToken is not whitelisted\");\n        require(\n            _destToken != address(0),\n            \"_destToken should not be address(0)\"\n        );\n        address _feesToken = address(0);\n        if (_totalSwapped > 0) {\n            _swap(address(0), WBTC_ADDR, _totalSwapped);\n        } else if (_totalSwapped == 0) {\n            _feesToken = WBTC_ADDR;\n        }\n        if (_destToken == lpToken) {\n            _feesToken = lpToken;\n        }\n        _rewardsCollection(_feesToken, _rewardsAmount);\n        _addUsedTxs(_redeemedFloatTxIds);\n        require(IERC20(_destToken).transfer(_to, _amount));\n        return true;\n    }","contract":"SwapContract","time":0},{"type":"external-function ","before":"function multiTransferERC20TightlyPacked(\n        address _destToken,\n        bytes32[] memory _addressesAndAmounts,\n        uint256 _totalSwapped,\n        uint256 _rewardsAmount,\n        bytes32[] memory _redeemedFloatTxIds\n    ) external override onlyOwner returns (bool) {\n        require(whitelist[_destToken], \"_destToken is not whitelisted\");\n        require(\n            _destToken != address(0),\n            \"_destToken should not be address(0)\"\n        );\n        address _feesToken = address(0);\n        if (_totalSwapped > 0) {\n            _swap(address(0), WBTC_ADDR, _totalSwapped);\n        } else if (_totalSwapped == 0) {\n            _feesToken = WBTC_ADDR;\n        }\n        if (_destToken == lpToken) {\n            _feesToken = lpToken;\n        }\n        _rewardsCollection(_feesToken, _rewardsAmount);\n        _addUsedTxs(_redeemedFloatTxIds);\n        for (uint256 i = 0; i < _addressesAndAmounts.length; i++) {\n            require(\n                IERC20(_destToken).transfer(\n                    address(uint160(uint256(_addressesAndAmounts[i]))),\n                    uint256(uint96(bytes12(_addressesAndAmounts[i])))\n                ),\n                \"Batch transfer error\"\n            );\n        }\n        return true;\n    }","after":"function multiTransferERC20TightlyPacked(\n        address _destToken,\n        bytes32[] calldata _addressesAndAmounts,\n        uint256 _totalSwapped,\n        uint256 _rewardsAmount,\n        bytes32[] calldata _redeemedFloatTxIds\n    ) external override onlyOwner returns (bool) {\n        require(whitelist[_destToken], \"_destToken is not whitelisted\");\n        require(\n            _destToken != address(0),\n            \"_destToken should not be address(0)\"\n        );\n        address _feesToken = address(0);\n        if (_totalSwapped > 0) {\n            _swap(address(0), WBTC_ADDR, _totalSwapped);\n        } else if (_totalSwapped == 0) {\n            _feesToken = WBTC_ADDR;\n        }\n        if (_destToken == lpToken) {\n            _feesToken = lpToken;\n        }\n        _rewardsCollection(_feesToken, _rewardsAmount);\n        _addUsedTxs(_redeemedFloatTxIds);\n        for (uint256 i = 0; i < _addressesAndAmounts.length; i++) {\n            require(\n                IERC20(_destToken).transfer(\n                    address(uint160(uint256(_addressesAndAmounts[i]))),\n                    uint256(uint96(bytes12(_addressesAndAmounts[i])))\n                ),\n                \"Batch transfer error\"\n            );\n        }\n        return true;\n    }","contract":"SwapContract","time":0},{"type":"external-function ","before":"function churn(\n        address _newOwner,\n        bytes32[] memory _rewardAddressAndAmounts,\n        bool[] memory _isRemoved,\n        uint8 _churnedInCount,\n        uint8 _tssThreshold,\n        uint8 _nodeRewardsRatio,\n        uint8 _withdrawalFeeBPS\n    ) external override onlyOwner returns (bool) {\n        require(\n            _tssThreshold >= tssThreshold && _tssThreshold <= 2**8 - 1,\n            \"_tssThreshold should be >= tssThreshold\"\n        );\n        require(\n            _churnedInCount >= _tssThreshold + uint8(1),\n            \"n should be >= t+1\"\n        );\n        require(\n            _nodeRewardsRatio >= 0 && _nodeRewardsRatio <= 100,\n            \"_nodeRewardsRatio is not valid\"\n        );\n        require(\n            _withdrawalFeeBPS >= 0 && _withdrawalFeeBPS <= 100,\n            \"_withdrawalFeeBPS is invalid\"\n        );\n        require(\n            _rewardAddressAndAmounts.length == _isRemoved.length,\n            \"_rewardAddressAndAmounts and _isRemoved length is not match\"\n        );\n        transferOwnership(_newOwner);\n        // Update active node list\n        for (uint256 i = 0; i < _rewardAddressAndAmounts.length; i++) {\n            (address newNode, ) = _splitToValues(_rewardAddressAndAmounts[i]);\n            _addNode(newNode, _rewardAddressAndAmounts[i], _isRemoved[i]);\n        }\n        bytes32[] memory nodeList = getActiveNodes();\n        if (nodeList.length > 100) {\n            revert(\"Stored node size should be <= 100\");\n        }\n        churnedInCount = _churnedInCount;\n        tssThreshold = _tssThreshold;\n        nodeRewardsRatio = _nodeRewardsRatio;\n        withdrawalFeeBPS = _withdrawalFeeBPS;\n        return true;\n    }","after":"function churn(\n        address _newOwner,\n        bytes32[] calldata _rewardAddressAndAmounts,\n        bool[] calldata _isRemoved,\n        uint8 _churnedInCount,\n        uint8 _tssThreshold,\n        uint8 _nodeRewardsRatio,\n        uint8 _withdrawalFeeBPS\n    ) external override onlyOwner returns (bool) {\n        require(\n            _tssThreshold >= tssThreshold && _tssThreshold <= 2**8 - 1,\n            \"_tssThreshold should be >= tssThreshold\"\n        );\n        require(\n            _churnedInCount >= _tssThreshold + uint8(1),\n            \"n should be >= t+1\"\n        );\n        require(\n            _nodeRewardsRatio >= 0 && _nodeRewardsRatio <= 100,\n            \"_nodeRewardsRatio is not valid\"\n        );\n        require(\n            _withdrawalFeeBPS >= 0 && _withdrawalFeeBPS <= 100,\n            \"_withdrawalFeeBPS is invalid\"\n        );\n        require(\n            _rewardAddressAndAmounts.length == _isRemoved.length,\n            \"_rewardAddressAndAmounts and _isRemoved length is not match\"\n        );\n        transferOwnership(_newOwner);\n        // Update active node list\n        for (uint256 i = 0; i < _rewardAddressAndAmounts.length; i++) {\n            (address newNode, ) = _splitToValues(_rewardAddressAndAmounts[i]);\n            _addNode(newNode, _rewardAddressAndAmounts[i], _isRemoved[i]);\n        }\n        bytes32[] memory nodeList = getActiveNodes();\n        if (nodeList.length > 100) {\n            revert(\"Stored node size should be <= 100\");\n        }\n        churnedInCount = _churnedInCount;\n        tssThreshold = _tssThreshold;\n        nodeRewardsRatio = _nodeRewardsRatio;\n        withdrawalFeeBPS = _withdrawalFeeBPS;\n        return true;\n    }","contract":"SwapContract","time":0}]}