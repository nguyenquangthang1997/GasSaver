{"time":330,"results":[{"type":"external-function ","before":"function presalePurchase(\n        uint256 _quantity,\n        bytes32 _hash,\n        bytes memory _signature\n    ) external payable nonReentrant whenNotPaused {\n        require(block.timestamp >= presaleStartTime, \"Presale has not started\");\n        require(\n            checkHash(_hash, _signature, _SIGNER),\n            \"Address is not on Presale List\"\n        );\n        /// @dev Presale always enforces a per-wallet limit\n        require(\n            _quantity + mintBalances[msg.sender] <= PRESALE_MINT_LIMIT,\n            \"Quantity exceeds per-wallet limit\"\n        );\n        require(_quantity * PRESALE_PRICE <= msg.value, \"Not enough minerals\");\n\n        _mint(_quantity);\n    }","after":"function presalePurchase(\n        uint256 _quantity,\n        bytes32 _hash,\n        bytes calldata _signature\n    ) external payable nonReentrant whenNotPaused {\n        require(block.timestamp >= presaleStartTime, \"Presale has not started\");\n        require(\n            checkHash(_hash, _signature, _SIGNER),\n            \"Address is not on Presale List\"\n        );\n        /// @dev Presale always enforces a per-wallet limit\n        require(\n            _quantity + mintBalances[msg.sender] <= PRESALE_MINT_LIMIT,\n            \"Quantity exceeds per-wallet limit\"\n        );\n        require(_quantity * PRESALE_PRICE <= msg.value, \"Not enough minerals\");\n\n        _mint(_quantity);\n    }","contract":"Main","time":0},{"type":"external-function ","before":"e\n    {\n        tokenOffset = randomness % MAX_SUPPLY;\n    }\n\n    function setProvenance(string memory _provenance)","after":"e\n    {\n        tokenOffset = randomness % MAX_SUPPLY;\n    }\n\n    function setProvenance(string memory _provenance)","contract":"Main","time":0},{"type":"external-function ","before":"ate) external onlyOwner {\n        isRevealed = _state;\n    }\n\n    function setBaseURI(string me","after":"ate) external onlyOwner {\n        isRevealed = _state;\n    }\n\n    function setBaseURI(string me","contract":"Main","time":0},{"type":"external-function ","before":"case.\n     */\n    struct MetaTransaction {\n        uint256 nonce;\n        address from;\n        bytes functionSignature;\n    }\n\n    function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(fu","after":"case.\n     */\n    struct MetaTransaction {\n        uint256 nonce;\n        address from;\n        bytes functionSignature;\n    }\n\n    function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(fu","contract":"Main","time":0},{"type":"constant-restrict-modification  ","before":"uint128 public MAX_SUPPLY = 10001;","after":"uint128 public constant MAX_SUPPLY = 10001;","contract":"Main","time":1},{"type":"constant-restrict-modification  ","before":"uint128 public PRESALE_MINT_LIMIT = 4;","after":"uint128 public constant PRESALE_MINT_LIMIT = 4;","contract":"Main","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public publicStartInterval = 1 days;","after":"uint256 public constant publicStartInterval = 1 days;","contract":"Main","time":1},{"type":"constant-restrict-modification  ","before":"address private _treasury = 0x8fBc1fB5fd267aFefF5cc4e69b3ca6D41567dc01;","after":"address private constant _treasury = 0x8fBc1fB5fd267aFefF5cc4e69b3ca6D41567dc01;","contract":"Main","time":1},{"type":"immutable-restrict-modification ","before":"uint256 internal LINK_FEE;","after":"uint256 internal immutable LINK_FEE;","contract":"Main","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 internal LINK_KEY_HASH;","after":"bytes32 internal immutable LINK_KEY_HASH;","contract":"Main","time":1},{"type":"constant-restrict-modification  ","before":"ublic constant REWARD_RATE = 10 ether;\n\n    // 10","after":"ublic constant REWARD_RATE = 10 ether;\n\n    // 10","contract":"RewardToken","time":1}]}