{"time":202,"results":[{"type":"external-function ","before":"function setCurrentCollectionBaseURI(string memory newuri) public onlyOwner {\n        currentSeasonalCollectionURI = newuri;\n    }","after":"function setCurrentCollectionBaseURI(string calldata newuri) public onlyOwner {\n        currentSeasonalCollectionURI = newuri;\n    }","contract":"Morphys","time":0},{"type":"external-function ","before":"function mintMorphy(uint256[] memory tokenIds) public payable {\n        require(tokenIds.length <= maxPerMint, \"Minting too much at once is not supported\");\n        require(mintingIsActive, \"Minting must be active to mint Morphy\");\n        require((totalSupply() + tokenIds.length) <= MAX_MORPHYS, \"Mint would exceed max supply of Morhpys\");\n        Flowtys flowtys = Flowtys(flowtysContract);\n        for(uint i = 0; i < tokenIds.length; i++) {\n            // Allow minting if we are the owner of original Flowty, skip otherwise\n            if (flowtys.ownerOf(tokenIds[i]) != msg.sender) {\n                require(false, \"Attempt to mint Morphy for non owned Flowty\");\n            }\n        }\n        require(getTotalPrice(tokenIds) == msg.value, \"Ether value sent is not correct\");\n        \n        for(uint i = 0; i < tokenIds.length; i++) {\n            createMorphy(msg.sender, tokenIds[i]);\n        }\n    }","after":"function mintMorphy(uint256[] calldata tokenIds) public payable {\n        require(tokenIds.length <= maxPerMint, \"Minting too much at once is not supported\");\n        require(mintingIsActive, \"Minting must be active to mint Morphy\");\n        require((totalSupply() + tokenIds.length) <= MAX_MORPHYS, \"Mint would exceed max supply of Morhpys\");\n        Flowtys flowtys = Flowtys(flowtysContract);\n        for(uint i = 0; i < tokenIds.length; i++) {\n            // Allow minting if we are the owner of original Flowty, skip otherwise\n            if (flowtys.ownerOf(tokenIds[i]) != msg.sender) {\n                require(false, \"Attempt to mint Morphy for non owned Flowty\");\n            }\n        }\n        require(getTotalPrice(tokenIds) == msg.value, \"Ether value sent is not correct\");\n        \n        for(uint i = 0; i < tokenIds.length; i++) {\n            createMorphy(msg.sender, tokenIds[i]);\n        }\n    }","contract":"Morphys","time":0},{"type":"external-function ","before":"function morphSeason(uint256[] memory tokenIds) public payable {\n        require(morphingIsActive, \"Morphing must be active to change season\");\n        Flowtys flowtys = Flowtys(flowtysContract);\n        uint256 totalPrice = 0;\n        for(uint i = 0; i < tokenIds.length; i++) {\n            // Allow morphing for owner only\n            if (ownerOf(tokenIds[i]) != msg.sender || !_exists(tokenIds[i])) {\n                require(false, \"Trying to morph non existing/not owned Morphy\");\n            }\n            // If you own a Flowty that has changed aging to minimum require => Morphing is free\n            if (!(flowtys.ownerOf(tokenIds[i]) == msg.sender && flowtys.getAge(tokenIds[i]) >= morhpingAgeThreeshold)) {\n                totalPrice = totalPrice + morphingPrice;\n            }\n        }\n        require(totalPrice == msg.value, \"Ether value sent is not correct\");\n\n        for(uint i = 0; i < tokenIds.length; i++) {\n            _morphysRegistry[tokenIds[i]] = currentSeasonalCollectionURI;\n            emit MorphyUpdated(tokenIds[i], currentSeasonalCollectionURI);\n        }\n    }","after":"function morphSeason(uint256[] calldata tokenIds) public payable {\n        require(morphingIsActive, \"Morphing must be active to change season\");\n        Flowtys flowtys = Flowtys(flowtysContract);\n        uint256 totalPrice = 0;\n        for(uint i = 0; i < tokenIds.length; i++) {\n            // Allow morphing for owner only\n            if (ownerOf(tokenIds[i]) != msg.sender || !_exists(tokenIds[i])) {\n                require(false, \"Trying to morph non existing/not owned Morphy\");\n            }\n            // If you own a Flowty that has changed aging to minimum require => Morphing is free\n            if (!(flowtys.ownerOf(tokenIds[i]) == msg.sender && flowtys.getAge(tokenIds[i]) >= morhpingAgeThreeshold)) {\n                totalPrice = totalPrice + morphingPrice;\n            }\n        }\n        require(totalPrice == msg.value, \"Ether value sent is not correct\");\n\n        for(uint i = 0; i < tokenIds.length; i++) {\n            _morphysRegistry[tokenIds[i]] = currentSeasonalCollectionURI;\n            emit MorphyUpdated(tokenIds[i], currentSeasonalCollectionURI);\n        }\n    }","contract":"Morphys","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public lastFlowtyMintedBlock = 13263728;","after":"uint256 public constant lastFlowtyMintedBlock = 13263728;","contract":"Morphys","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public agingPricingThreshold = 40320;","after":"uint256 public constant agingPricingThreshold = 40320;","contract":"Morphys","time":0},{"type":"constant-restrict-modification  ","before":"address public flowtysContract = 0x52607cb9c342821ea41ad265B9Bb6a23BEa49468;","after":"address public constant flowtysContract = 0x52607cb9c342821ea41ad265B9Bb6a23BEa49468;","contract":"Morphys","time":0},{"type":"external-function ","before":"function setBaseURI(string memory newuri) public onlyOwner {\n        _baseFlowtyURI = newuri;\n    }","after":"function setBaseURI(string calldata newuri) public onlyOwner {\n        _baseFlowtyURI = newuri;\n    }","contract":"Flowtys","time":0},{"type":"external-function ","before":"function setProvenanceHash(string memory provenanceHash) public onlyOwner {\n        provenance = provenanceHash;\n    }","after":"function setProvenanceHash(string calldata provenanceHash) public onlyOwner {\n        provenance = provenanceHash;\n    }","contract":"Flowtys","time":0}]}