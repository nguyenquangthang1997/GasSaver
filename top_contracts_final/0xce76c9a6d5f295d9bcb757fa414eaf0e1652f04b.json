{"time":141,"results":[{"type":"state-data-arrangement ","before":"\nbytes32 merkleRoot;\nbool merkleSet = false;\nuint256 public constant MAX_PER_CALL = 26;\nuint256 public constant MAX_PER_CALL_PRESALE = 5;\nuint256 public constant MAX_SUPPLY = 4445;\nuint256 public NFT_PRICE = 0;\nstring public baseURI;\nbool public presaleOngoing;\naddress public proxyRegistryAddress;\nmapping(address => bool) public projectProxy;\nmapping(address => uint256) public presaleMintedAmounts;","after":"bytes32 merkleRoot;\nuint256 public constant MAX_PER_CALL = 26;\nuint256 public constant MAX_PER_CALL_PRESALE = 5;\nuint256 public constant MAX_SUPPLY = 4445;\nuint256 public NFT_PRICE = 0;\nstring public baseURI;\nmapping(address => bool) public projectProxy;\nmapping(address => uint256) public presaleMintedAmounts;\naddress public proxyRegistryAddress;\nbool merkleSet = false;\nbool public presaleOngoing;\n","contract":"TheWanderings","time":0},{"type":"external-function ","before":"function mintPresale(uint256 amount, bytes32[] memory merkleProof) external payable whenPaused {\n        require(presaleOngoing, \"Presale hasn't started yet\");\n        uint256 ogAmount = _owners.length;\n        require(ogAmount + amount < MAX_SUPPLY, \"Amount exceeds max supply\");\n        require(presaleMintedAmounts[msg.sender] + amount < MAX_PER_CALL_PRESALE, \"Amount exceeds presale max\");\n\n        // Verify merkleProof\n        require(merkleProof.verify(merkleRoot, keccak256(abi.encodePacked(msg.sender))), \"Invalid proof. Not whitelisted\");\n\n\n        for (uint256 i = 0; i < amount; i++) {\n            _mint(msg.sender, ogAmount + i);\n        }\n        presaleMintedAmounts[msg.sender] += amount;\n    }","after":"function mintPresale(uint256 amount, bytes32[] calldata merkleProof) external payable whenPaused {\n        require(presaleOngoing, \"Presale hasn't started yet\");\n        uint256 ogAmount = _owners.length;\n        require(ogAmount + amount < MAX_SUPPLY, \"Amount exceeds max supply\");\n        require(presaleMintedAmounts[msg.sender] + amount < MAX_PER_CALL_PRESALE, \"Amount exceeds presale max\");\n\n        // Verify merkleProof\n        require(merkleProof.verify(merkleRoot, keccak256(abi.encodePacked(msg.sender))), \"Invalid proof. Not whitelisted\");\n\n\n        for (uint256 i = 0; i < amount; i++) {\n            _mint(msg.sender, ogAmount + i);\n        }\n        presaleMintedAmounts[msg.sender] += amount;\n    }","contract":"TheWanderings","time":1},{"type":"external-function ","before":"function setBaseURI(string memory uri) external onlyOwner {\n        baseURI = uri;\n    }","after":"function setBaseURI(string calldata uri) external onlyOwner {\n        baseURI = uri;\n    }","contract":"TheWanderings","time":0},{"type":"external-function ","before":"function batchTransferFrom(address _from, address _to, uint256[] memory _tokenIds) public {\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            transferFrom(_from, _to, _tokenIds[i]);\n        }\n    }","after":"function batchTransferFrom(address _from, address _to, uint256[] calldata _tokenIds) public {\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            transferFrom(_from, _to, _tokenIds[i]);\n        }\n    }","contract":"TheWanderings","time":0},{"type":"external-function ","before":"function batchSafeTransferFrom(address _from, address _to, uint256[] memory _tokenIds, bytes memory data_) public {\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            safeTransferFrom(_from, _to, _tokenIds[i], data_);\n        }\n    }","after":"function batchSafeTransferFrom(address _from, address _to, uint256[] calldata _tokenIds, bytes calldata data_) public {\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            safeTransferFrom(_from, _to, _tokenIds[i], data_);\n        }\n    }","contract":"TheWanderings","time":0}]}