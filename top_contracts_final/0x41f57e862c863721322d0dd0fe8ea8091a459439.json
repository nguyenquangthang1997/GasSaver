{"time":123,"results":[{"type":"state-data-arrangement ","before":"\nuint256 public vxPrice = 55000000000000000;\nuint256 public immutable MAX_SUPPLY = 10000;\nuint256 public immutable MAX_TEAMRESERVE = 100;\nbool public saleActive = false;\nuint256 public maxSaleMint = 10;\nstring public VOXprovenance;\nuint256 public teamMints = 0;\nbytes32 public MerkleRoot;\naddress public proxyRegistryAddress;\nmapping(address => AddressInfo) public addressInfo;","after":"uint256 public vxPrice = 55000000000000000;\nuint256 public immutable MAX_SUPPLY = 10000;\nuint256 public immutable MAX_TEAMRESERVE = 100;\nuint256 public maxSaleMint = 10;\nstring public VOXprovenance;\nuint256 public teamMints = 0;\nbytes32 public MerkleRoot;\nmapping(address => AddressInfo) public addressInfo;\naddress public proxyRegistryAddress;\nbool public saleActive = false;\n","contract":"EthalienVOX","time":1},{"type":"external-function ","before":"function mintPresale(bytes32[] memory _proof, bytes1 _maxAmountKey, uint256 _mintAmount) public payable reentryLock {\r\n\t\trequire(MerkleRoot > 0x00, \"claim period not started!\");\r\n\t\t\r\n\t\tuint256 supply = totalSupply();\r\n\t\trequire(supply + _mintAmount < MAX_SUPPLY + 1, \"max collection limit exceeded\");\r\n\t\t\r\n\t\trequire(MerkleProof.verify(_proof, MerkleRoot, keccak256(abi.encodePacked(msg.sender, _maxAmountKey))), \"unauthorized proof-key combo for sender\");\r\n\r\n\t\trequire(addressInfo[msg.sender].ownerPresaleMints + _mintAmount < uint8(_maxAmountKey) + 1, \"max free NFT claims exceeded\");\r\n\t\trequire(msg.value >= _mintAmount * vxPrice, \"not enough ETH sent\");\r\n\t\t\r\n\t\taddressInfo[msg.sender].ownerPresaleMints += _mintAmount;\r\n\t\t\r\n\t\tfor (uint256 i=0; i < _mintAmount; i++) {\r\n\t\t  _safeMint(msg.sender, supply + i);\r\n\t\t}\r\n\t}","after":"function mintPresale(bytes32[] calldata _proof, bytes1 _maxAmountKey, uint256 _mintAmount) public payable reentryLock {\r\n\t\trequire(MerkleRoot > 0x00, \"claim period not started!\");\r\n\t\t\r\n\t\tuint256 supply = totalSupply();\r\n\t\trequire(supply + _mintAmount < MAX_SUPPLY + 1, \"max collection limit exceeded\");\r\n\t\t\r\n\t\trequire(MerkleProof.verify(_proof, MerkleRoot, keccak256(abi.encodePacked(msg.sender, _maxAmountKey))), \"unauthorized proof-key combo for sender\");\r\n\r\n\t\trequire(addressInfo[msg.sender].ownerPresaleMints + _mintAmount < uint8(_maxAmountKey) + 1, \"max free NFT claims exceeded\");\r\n\t\trequire(msg.value >= _mintAmount * vxPrice, \"not enough ETH sent\");\r\n\t\t\r\n\t\taddressInfo[msg.sender].ownerPresaleMints += _mintAmount;\r\n\t\t\r\n\t\tfor (uint256 i=0; i < _mintAmount; i++) {\r\n\t\t  _safeMint(msg.sender, supply + i);\r\n\t\t}\r\n\t}","contract":"EthalienVOX","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseURI_) public onlyOwner {\r\n        _setBaseURI(baseURI_);\r\n    }","after":"function setBaseURI(string calldata baseURI_) public onlyOwner {\r\n        _setBaseURI(baseURI_);\r\n    }","contract":"EthalienVOX","time":0},{"type":"external-function ","before":"function setProvenance(string memory _provenance) public onlyOwner {\r\n        VOXprovenance = _provenance;\r\n    }","after":"function setProvenance(string calldata _provenance) public onlyOwner {\r\n        VOXprovenance = _provenance;\r\n    }","contract":"EthalienVOX","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public immutable MAX_SUPPLY = 10000;","after":"uint256 public immutable constant MAX_SUPPLY = 10000;","contract":"EthalienVOX","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public immutable MAX_TEAMRESERVE = 100;","after":"uint256 public immutable constant MAX_TEAMRESERVE = 100;","contract":"EthalienVOX","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public maxSaleMint = 10;","after":"uint256 public constant maxSaleMint = 10;","contract":"EthalienVOX","time":0}]}