{"time":269,"results":[{"type":"external-function ","before":"function buy(uint[] memory tiers, string calldata ticket, bytes calldata signature) external payable {\n    SaleConfig storage saleConfig = saleConfigByTicketId[ticket];\n    SaleState storage saleState = saleStateByTicketId[ticket];\n\n    uint quantity = tiers.length;\n\n    require(saleState.active, 'sale not started');\n    require(quantity > 0 && quantity <= 2, 'Invalid Quantity');\n    require(totalPrice(tiers) == msg.value, 'wrong price');\n    require(saleState.numSold + quantity <= saleConfig.maxSell, 'Not enough for sale');\n\n    bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n        keccak256(\"Ticket(address wallet,string ticket)\"),\n        msg.sender,\n        keccak256(bytes(ticket))\n    )));\n    address signer = ECDSA.recover(digest, signature);\n    require(signer == saleConfig.ticketSigner, 'invalid ticket');\n\n\n    for (uint tierIdx = 0; tierIdx < tiers.length; tierIdx++) {\n      uint tier = tiers[tierIdx];\n      TierConfig storage tierConfig = tierConfigByTier[tier];\n\n      require(tierConfig.numTokens != 0, 'tier not available');\n      require(numSoldByTier[tier] + 1 <= tierConfig.numTokens, 'Tier Sold out');\n      require(saleState.numSoldByTier[tier] + 1 <= saleConfig.maxSellByTier[tier], 'Sale Tier Sold out');\n\n      saleState.numSold += 1;\n      saleState.numSoldByTier[tier] += 1;\n\n      uint tokenId = tierConfig.firstTokenId + numSoldByTier[tier]++;\n      tokenContract.mint(msg.sender, tokenId);\n      emit TokenPurchased(tokenId, msg.sender);\n    }\n  }","after":"function buy(uint[] calldata tiers, string calldata ticket, bytes calldata signature) external payable {\n    SaleConfig storage saleConfig = saleConfigByTicketId[ticket];\n    SaleState storage saleState = saleStateByTicketId[ticket];\n\n    uint quantity = tiers.length;\n\n    require(saleState.active, 'sale not started');\n    require(quantity > 0 && quantity <= 2, 'Invalid Quantity');\n    require(totalPrice(tiers) == msg.value, 'wrong price');\n    require(saleState.numSold + quantity <= saleConfig.maxSell, 'Not enough for sale');\n\n    bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n        keccak256(\"Ticket(address wallet,string ticket)\"),\n        msg.sender,\n        keccak256(bytes(ticket))\n    )));\n    address signer = ECDSA.recover(digest, signature);\n    require(signer == saleConfig.ticketSigner, 'invalid ticket');\n\n\n    for (uint tierIdx = 0; tierIdx < tiers.length; tierIdx++) {\n      uint tier = tiers[tierIdx];\n      TierConfig storage tierConfig = tierConfigByTier[tier];\n\n      require(tierConfig.numTokens != 0, 'tier not available');\n      require(numSoldByTier[tier] + 1 <= tierConfig.numTokens, 'Tier Sold out');\n      require(saleState.numSoldByTier[tier] + 1 <= saleConfig.maxSellByTier[tier], 'Sale Tier Sold out');\n\n      saleState.numSold += 1;\n      saleState.numSoldByTier[tier] += 1;\n\n      uint tokenId = tierConfig.firstTokenId + numSoldByTier[tier]++;\n      tokenContract.mint(msg.sender, tokenId);\n      emit TokenPurchased(tokenId, msg.sender);\n    }\n  }","contract":"TokenSales","time":0}]}