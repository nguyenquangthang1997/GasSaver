{"time":88,"results":[{"type":"struct-data-arrangement ","before":"\nuint256 snapshotEntries\nuint256 amountOfWinners\nuint256 randomNumber\nuint256 tokenId\nuint256 claimOpen\nuint256 claimClose\nbool isFulfilled\nbool allowDuplicates\nstring entryListIpfsHash\naddress contractAddress\nmapping(address => uint256) claimed\nbytes32 merkleRoot","after":"uint256 snapshotEntries\nuint256 amountOfWinners\nuint256 randomNumber\nuint256 tokenId\nuint256 claimOpen\nuint256 claimClose\nstring entryListIpfsHash\nmapping(address => uint256) claimed\nbytes32 merkleRoot\naddress contractAddress\nbool isFulfilled\nbool allowDuplicates\n","contract":"Pixelvault1155Giveaway","time":0},{"type":"external-function ","before":"function startDraw(\n        uint256 _snapshotEntries, \n        uint256 _amountOfWinners, \n        uint256 _tokenId, \n        address _contractAddress, \n        string memory _entryListIpfsHash, \n        bool _allowDuplicates, \n        uint256 _claimOpen, \n        uint256 _claimClose\n    ) external onlyOwner returns (bytes32 requestId) {\n        require(counter.current() == 0 || giveaways[counter.current()-1].isFulfilled, \"Draw: previous draw not fulfilled\");    \n        require(_amountOfWinners < _snapshotEntries, \"Draw: amount of winners must be smaller than number of entries\");    \n        require(\n            LINK.balanceOf(address(this)) >= fee,\n            \"Not enough LINK - fill contract with faucet\"\n        );\n\n        Giveaway storage d = giveaways[counter.current()];\n        d.snapshotEntries = _snapshotEntries;\n        d.amountOfWinners = _amountOfWinners;\n        d.tokenId = _tokenId;     \n        d.contractAddress = _contractAddress;\n        d.entryListIpfsHash = _entryListIpfsHash;\n        d.allowDuplicates = _allowDuplicates;\n        d.claimOpen = _claimOpen;\n        d.claimClose = _claimClose;\n\n        counter.increment();\n\n        return requestRandomness(keyHash, fee);\n    }","after":"function startDraw(\n        uint256 _snapshotEntries, \n        uint256 _amountOfWinners, \n        uint256 _tokenId, \n        address _contractAddress, \n        string calldata _entryListIpfsHash, \n        bool _allowDuplicates, \n        uint256 _claimOpen, \n        uint256 _claimClose\n    ) external onlyOwner returns (bytes32 requestId) {\n        require(counter.current() == 0 || giveaways[counter.current()-1].isFulfilled, \"Draw: previous draw not fulfilled\");    \n        require(_amountOfWinners < _snapshotEntries, \"Draw: amount of winners must be smaller than number of entries\");    \n        require(\n            LINK.balanceOf(address(this)) >= fee,\n            \"Not enough LINK - fill contract with faucet\"\n        );\n\n        Giveaway storage d = giveaways[counter.current()];\n        d.snapshotEntries = _snapshotEntries;\n        d.amountOfWinners = _amountOfWinners;\n        d.tokenId = _tokenId;     \n        d.contractAddress = _contractAddress;\n        d.entryListIpfsHash = _entryListIpfsHash;\n        d.allowDuplicates = _allowDuplicates;\n        d.claimOpen = _claimOpen;\n        d.claimClose = _claimClose;\n\n        counter.increment();\n\n        return requestRandomness(keyHash, fee);\n    }","contract":"Pixelvault1155Giveaway","time":0},{"type":"external-function ","before":"function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","after":"function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","contract":"Pixelvault1155Giveaway","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","after":"function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","contract":"Pixelvault1155Giveaway","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 internal keyHash;","after":"bytes32 internal immutable keyHash;","contract":"Pixelvault1155Giveaway","time":0},{"type":"immutable-restrict-modification ","before":"uint256 internal fee;","after":"uint256 internal immutable fee;","contract":"Pixelvault1155Giveaway","time":0}]}