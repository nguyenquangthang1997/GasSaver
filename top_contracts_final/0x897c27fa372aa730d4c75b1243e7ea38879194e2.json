{"time":144,"results":[{"type":"external-function ","before":"function updateValset(\n\t\t// The new version of the validator set\n\t\taddress[] memory _newValidators,\n\t\tuint256[] memory _newPowers,\n\t\tuint256 _newValsetNonce,\n\t\t// The current validators that approve the change\n\t\taddress[] memory _currentValidators,\n\t\tuint256[] memory _currentPowers,\n\t\tuint256 _currentValsetNonce,\n\t\t// These are arrays of the parts of the current validator's signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s\n\t) public nonReentrant {\n\t\t// CHECKS\n\n\t\t// Check that the valset nonce is greater than the old one\n\t\trequire(\n\t\t\t_newValsetNonce > _currentValsetNonce,\n\t\t\t\"New valset nonce must be greater than the current nonce\"\n\t\t);\n\n\t\t// Check that new validators and powers set is well-formed\n\t\trequire(_newValidators.length == _newPowers.length, \"Malformed new validator set\");\n\n\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\trequire(\n\t\t\t_currentValidators.length == _currentPowers.length &&\n\t\t\t\t_currentValidators.length == _v.length &&\n\t\t\t\t_currentValidators.length == _r.length &&\n\t\t\t\t_currentValidators.length == _s.length,\n\t\t\t\"Malformed current validator set\"\n\t\t);\n\n\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\trequire(\n\t\t\tmakeCheckpoint(\n\t\t\t\t_currentValidators,\n\t\t\t\t_currentPowers,\n\t\t\t\t_currentValsetNonce,\n\t\t\t\tstate_gravityId\n\t\t\t) == state_lastValsetCheckpoint,\n\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t);\n\n\t\t// Check that enough current validators have signed off on the new validator set\n\t\tbytes32 newCheckpoint =\n\t\t\tmakeCheckpoint(_newValidators, _newPowers, _newValsetNonce, state_gravityId);\n\n\t\tcheckValidatorSignatures(\n\t\t\t_currentValidators,\n\t\t\t_currentPowers,\n\t\t\t_v,\n\t\t\t_r,\n\t\t\t_s,\n\t\t\tnewCheckpoint,\n\t\t\tstate_powerThreshold\n\t\t);\n\n\t\t// ACTIONS\n\n\t\t// Stored to be used next time to validate that the valset\n\t\t// supplied by the caller is correct.\n\t\tstate_lastValsetCheckpoint = newCheckpoint;\n\n\t\t// Store new nonce\n\t\tstate_lastValsetNonce = _newValsetNonce;\n\n\t\t// LOGS\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit ValsetUpdatedEvent(_newValsetNonce, state_lastEventNonce, _newValidators, _newPowers);\n\t}","after":"function updateValset(\n\t\t// The new version of the validator set\n\t\taddress[] calldata _newValidators,\n\t\tuint256[] calldata _newPowers,\n\t\tuint256 _newValsetNonce,\n\t\t// The current validators that approve the change\n\t\taddress[] calldata _currentValidators,\n\t\tuint256[] calldata _currentPowers,\n\t\tuint256 _currentValsetNonce,\n\t\t// These are arrays of the parts of the current validator's signatures\n\t\tuint8[] calldata _v,\n\t\tbytes32[] calldata _r,\n\t\tbytes32[] calldata _s\n\t) public nonReentrant {\n\t\t// CHECKS\n\n\t\t// Check that the valset nonce is greater than the old one\n\t\trequire(\n\t\t\t_newValsetNonce > _currentValsetNonce,\n\t\t\t\"New valset nonce must be greater than the current nonce\"\n\t\t);\n\n\t\t// Check that new validators and powers set is well-formed\n\t\trequire(_newValidators.length == _newPowers.length, \"Malformed new validator set\");\n\n\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\trequire(\n\t\t\t_currentValidators.length == _currentPowers.length &&\n\t\t\t\t_currentValidators.length == _v.length &&\n\t\t\t\t_currentValidators.length == _r.length &&\n\t\t\t\t_currentValidators.length == _s.length,\n\t\t\t\"Malformed current validator set\"\n\t\t);\n\n\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\trequire(\n\t\t\tmakeCheckpoint(\n\t\t\t\t_currentValidators,\n\t\t\t\t_currentPowers,\n\t\t\t\t_currentValsetNonce,\n\t\t\t\tstate_gravityId\n\t\t\t) == state_lastValsetCheckpoint,\n\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t);\n\n\t\t// Check that enough current validators have signed off on the new validator set\n\t\tbytes32 newCheckpoint =\n\t\t\tmakeCheckpoint(_newValidators, _newPowers, _newValsetNonce, state_gravityId);\n\n\t\tcheckValidatorSignatures(\n\t\t\t_currentValidators,\n\t\t\t_currentPowers,\n\t\t\t_v,\n\t\t\t_r,\n\t\t\t_s,\n\t\t\tnewCheckpoint,\n\t\t\tstate_powerThreshold\n\t\t);\n\n\t\t// ACTIONS\n\n\t\t// Stored to be used next time to validate that the valset\n\t\t// supplied by the caller is correct.\n\t\tstate_lastValsetCheckpoint = newCheckpoint;\n\n\t\t// Store new nonce\n\t\tstate_lastValsetNonce = _newValsetNonce;\n\n\t\t// LOGS\n\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\temit ValsetUpdatedEvent(_newValsetNonce, state_lastEventNonce, _newValidators, _newPowers);\n\t}","contract":"Hub2Eth","time":0},{"type":"external-function ","before":"function submitBatch(\n\t\t// The validators that approve the batch\n\t\taddress[] memory _currentValidators,\n\t\tuint256[] memory _currentPowers,\n\t\tuint256 _currentValsetNonce,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\t// The batch of transactions\n\t\tuint256[] memory _amounts,\n\t\taddress payable[] memory _destinations,\n\t\tuint256[] memory _fees,\n\t\tuint256 _batchNonce,\n\t\taddress _tokenContract,\n\t\t// a block height beyond which this batch is not valid\n\t\t// used to provide a fee-free timeout\n\t\tuint256 _batchTimeout\n\t) public nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the batch nonce is higher than the last nonce for this token\n\t\t\trequire(\n\t\t\t\tstate_lastBatchNonces[_tokenContract] < _batchNonce,\n\t\t\t\t\"New batch nonce must be greater than the current nonce\"\n\t\t\t);\n\n\t\t\t// Check that the block height is less than the timeout height\n\t\t\trequire(\n\t\t\t\tblock.number < _batchTimeout,\n\t\t\t\t\"Batch timeout must be greater than the current block height\"\n\t\t\t);\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\trequire(\n\t\t\t\t_currentValidators.length == _currentPowers.length &&\n\t\t\t\t\t_currentValidators.length == _v.length &&\n\t\t\t\t\t_currentValidators.length == _r.length &&\n\t\t\t\t\t_currentValidators.length == _s.length,\n\t\t\t\t\"Malformed current validator set\"\n\t\t\t);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\trequire(\n\t\t\t\tmakeCheckpoint(\n\t\t\t\t\t_currentValidators,\n\t\t\t\t\t_currentPowers,\n\t\t\t\t\t_currentValsetNonce,\n\t\t\t\t\tstate_gravityId\n\t\t\t\t) == state_lastValsetCheckpoint,\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t\t);\n\n\t\t\t// Check that the transaction batch is well-formed\n\t\t\trequire(\n\t\t\t\t_amounts.length == _destinations.length && _amounts.length == _fees.length,\n\t\t\t\t\"Malformed batch of transactions\"\n\t\t\t);\n\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValidators,\n\t\t\t\t_currentPowers,\n\t\t\t\t_v,\n\t\t\t\t_r,\n\t\t\t\t_s,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encode(\n\t\t\t\t\t\tstate_gravityId,\n\t\t\t\t\t\t// bytes32 encoding of \"transactionBatch\"\n\t\t\t\t\t\t0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n\t\t\t\t\t\t_amounts,\n\t\t\t\t\t\t_destinations,\n\t\t\t\t\t\t_fees,\n\t\t\t\t\t\t_batchNonce,\n\t\t\t\t\t\t_tokenContract,\n\t\t\t\t\t\t_batchTimeout\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\n\t\t\t// ACTIONS\n\n\t\t\t// Store batch nonce\n\t\t\tstate_lastBatchNonces[_tokenContract] = _batchNonce;\n\n\t\t\t// Send transaction amounts to destinations\n\t\t\tif (_tokenContract == wethAddress) {\n\t\t\t\tfor (uint256 i = 0; i < _amounts.length; i++) {\n\t\t\t\t\tIWETH(wethAddress).withdraw(_amounts[i]);\n\t\t\t\t\tTransferHelper.safeTransferETH(_destinations[i], _amounts[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (uint256 i = 0; i < _amounts.length; i++) {\n\t\t\t\t\tIERC20(_tokenContract).safeTransfer(_destinations[i], _amounts[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\t\temit TransactionBatchExecutedEvent(_batchNonce, _tokenContract, state_lastEventNonce);\n\t\t}\n\t}","after":"function submitBatch(\n\t\t// The validators that approve the batch\n\t\taddress[] calldata _currentValidators,\n\t\tuint256[] calldata _currentPowers,\n\t\tuint256 _currentValsetNonce,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tuint8[] calldata _v,\n\t\tbytes32[] calldata _r,\n\t\tbytes32[] calldata _s,\n\t\t// The batch of transactions\n\t\tuint256[] calldata _amounts,\n\t\taddress payable[] calldata _destinations,\n\t\tuint256[] calldata _fees,\n\t\tuint256 _batchNonce,\n\t\taddress _tokenContract,\n\t\t// a block height beyond which this batch is not valid\n\t\t// used to provide a fee-free timeout\n\t\tuint256 _batchTimeout\n\t) public nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the batch nonce is higher than the last nonce for this token\n\t\t\trequire(\n\t\t\t\tstate_lastBatchNonces[_tokenContract] < _batchNonce,\n\t\t\t\t\"New batch nonce must be greater than the current nonce\"\n\t\t\t);\n\n\t\t\t// Check that the block height is less than the timeout height\n\t\t\trequire(\n\t\t\t\tblock.number < _batchTimeout,\n\t\t\t\t\"Batch timeout must be greater than the current block height\"\n\t\t\t);\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\trequire(\n\t\t\t\t_currentValidators.length == _currentPowers.length &&\n\t\t\t\t\t_currentValidators.length == _v.length &&\n\t\t\t\t\t_currentValidators.length == _r.length &&\n\t\t\t\t\t_currentValidators.length == _s.length,\n\t\t\t\t\"Malformed current validator set\"\n\t\t\t);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\trequire(\n\t\t\t\tmakeCheckpoint(\n\t\t\t\t\t_currentValidators,\n\t\t\t\t\t_currentPowers,\n\t\t\t\t\t_currentValsetNonce,\n\t\t\t\t\tstate_gravityId\n\t\t\t\t) == state_lastValsetCheckpoint,\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t\t);\n\n\t\t\t// Check that the transaction batch is well-formed\n\t\t\trequire(\n\t\t\t\t_amounts.length == _destinations.length && _amounts.length == _fees.length,\n\t\t\t\t\"Malformed batch of transactions\"\n\t\t\t);\n\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValidators,\n\t\t\t\t_currentPowers,\n\t\t\t\t_v,\n\t\t\t\t_r,\n\t\t\t\t_s,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encode(\n\t\t\t\t\t\tstate_gravityId,\n\t\t\t\t\t\t// bytes32 encoding of \"transactionBatch\"\n\t\t\t\t\t\t0x7472616e73616374696f6e426174636800000000000000000000000000000000,\n\t\t\t\t\t\t_amounts,\n\t\t\t\t\t\t_destinations,\n\t\t\t\t\t\t_fees,\n\t\t\t\t\t\t_batchNonce,\n\t\t\t\t\t\t_tokenContract,\n\t\t\t\t\t\t_batchTimeout\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\n\t\t\t// ACTIONS\n\n\t\t\t// Store batch nonce\n\t\t\tstate_lastBatchNonces[_tokenContract] = _batchNonce;\n\n\t\t\t// Send transaction amounts to destinations\n\t\t\tif (_tokenContract == wethAddress) {\n\t\t\t\tfor (uint256 i = 0; i < _amounts.length; i++) {\n\t\t\t\t\tIWETH(wethAddress).withdraw(_amounts[i]);\n\t\t\t\t\tTransferHelper.safeTransferETH(_destinations[i], _amounts[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (uint256 i = 0; i < _amounts.length; i++) {\n\t\t\t\t\tIERC20(_tokenContract).safeTransfer(_destinations[i], _amounts[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\t\temit TransactionBatchExecutedEvent(_batchNonce, _tokenContract, state_lastEventNonce);\n\t\t}\n\t}","contract":"Hub2Eth","time":0},{"type":"external-function ","before":"function submitLogicCall(\n\t\t// The validators that approve the call\n\t\taddress[] memory _currentValidators,\n\t\tuint256[] memory _currentPowers,\n\t\tuint256 _currentValsetNonce,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tuint8[] memory _v,\n\t\tbytes32[] memory _r,\n\t\tbytes32[] memory _s,\n\t\tLogicCallArgs memory _args\n\t) public nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the call has not timed out\n\t\t\trequire(block.number < _args.timeOut, \"Timed out\");\n\n\t\t\t// Check that the invalidation nonce is higher than the last nonce for this invalidation Id\n\t\t\trequire(\n\t\t\t\tstate_invalidationMapping[_args.invalidationId] < _args.invalidationNonce,\n\t\t\t\t\"New invalidation nonce must be greater than the current nonce\"\n\t\t\t);\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\trequire(\n\t\t\t\t_currentValidators.length == _currentPowers.length &&\n\t\t\t\t\t_currentValidators.length == _v.length &&\n\t\t\t\t\t_currentValidators.length == _r.length &&\n\t\t\t\t\t_currentValidators.length == _s.length,\n\t\t\t\t\"Malformed current validator set\"\n\t\t\t);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\trequire(\n\t\t\t\tmakeCheckpoint(\n\t\t\t\t\t_currentValidators,\n\t\t\t\t\t_currentPowers,\n\t\t\t\t\t_currentValsetNonce,\n\t\t\t\t\tstate_gravityId\n\t\t\t\t) == state_lastValsetCheckpoint,\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t\t);\n\n\t\t\t// Check that the token transfer list is well-formed\n\t\t\trequire(\n\t\t\t\t_args.transferAmounts.length == _args.transferTokenContracts.length,\n\t\t\t\t\"Malformed list of token transfers\"\n\t\t\t);\n\n\t\t\t// Check that the fee list is well-formed\n\t\t\trequire(\n\t\t\t\t_args.feeAmounts.length == _args.feeTokenContracts.length,\n\t\t\t\t\"Malformed list of fees\"\n\t\t\t);\n\t\t}\n\n\t\tbytes32 argsHash =\n\t\t\tkeccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\tstate_gravityId,\n\t\t\t\t\t// bytes32 encoding of \"logicCall\"\n\t\t\t\t\t0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n\t\t\t\t\t_args.transferAmounts,\n\t\t\t\t\t_args.transferTokenContracts,\n\t\t\t\t\t_args.feeAmounts,\n\t\t\t\t\t_args.feeTokenContracts,\n\t\t\t\t\t_args.logicContractAddress,\n\t\t\t\t\t_args.payload,\n\t\t\t\t\t_args.timeOut,\n\t\t\t\t\t_args.invalidationId,\n\t\t\t\t\t_args.invalidationNonce\n\t\t\t\t)\n\t\t\t);\n\n\t\t{\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValidators,\n\t\t\t\t_currentPowers,\n\t\t\t\t_v,\n\t\t\t\t_r,\n\t\t\t\t_s,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\targsHash,\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\t\t}\n\n\t\t// ACTIONS\n\n\t\t// Update invaldiation nonce\n\t\tstate_invalidationMapping[_args.invalidationId] = _args.invalidationNonce;\n\n\t\t// Send tokens to the logic contract\n\t\tfor (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n\t\t\tIERC20(_args.transferTokenContracts[i]).safeTransfer(\n\t\t\t\t_args.logicContractAddress,\n\t\t\t\t_args.transferAmounts[i]\n\t\t\t);\n\t\t}\n\n\t\t// Make call to logic contract\n\t\tbytes memory returnData = Address.functionCall(_args.logicContractAddress, _args.payload);\n\n\t\t// Send fees to msg.sender\n\t\tfor (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n\t\t\tIERC20(_args.feeTokenContracts[i]).safeTransfer(msg.sender, _args.feeAmounts[i]);\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\t\temit LogicCallEvent(\n\t\t\t\t_args.invalidationId,\n\t\t\t\t_args.invalidationNonce,\n\t\t\t\tstate_lastEventNonce,\n\t\t\t\treturnData\n\t\t\t);\n\t\t}\n\t}","after":"function submitLogicCall(\n\t\t// The validators that approve the call\n\t\taddress[] calldata _currentValidators,\n\t\tuint256[] calldata _currentPowers,\n\t\tuint256 _currentValsetNonce,\n\t\t// These are arrays of the parts of the validators signatures\n\t\tuint8[] calldata _v,\n\t\tbytes32[] calldata _r,\n\t\tbytes32[] calldata _s,\n\t\tLogicCallArgs calldata _args\n\t) public nonReentrant {\n\t\t// CHECKS scoped to reduce stack depth\n\t\t{\n\t\t\t// Check that the call has not timed out\n\t\t\trequire(block.number < _args.timeOut, \"Timed out\");\n\n\t\t\t// Check that the invalidation nonce is higher than the last nonce for this invalidation Id\n\t\t\trequire(\n\t\t\t\tstate_invalidationMapping[_args.invalidationId] < _args.invalidationNonce,\n\t\t\t\t\"New invalidation nonce must be greater than the current nonce\"\n\t\t\t);\n\n\t\t\t// Check that current validators, powers, and signatures (v,r,s) set is well-formed\n\t\t\trequire(\n\t\t\t\t_currentValidators.length == _currentPowers.length &&\n\t\t\t\t\t_currentValidators.length == _v.length &&\n\t\t\t\t\t_currentValidators.length == _r.length &&\n\t\t\t\t\t_currentValidators.length == _s.length,\n\t\t\t\t\"Malformed current validator set\"\n\t\t\t);\n\n\t\t\t// Check that the supplied current validator set matches the saved checkpoint\n\t\t\trequire(\n\t\t\t\tmakeCheckpoint(\n\t\t\t\t\t_currentValidators,\n\t\t\t\t\t_currentPowers,\n\t\t\t\t\t_currentValsetNonce,\n\t\t\t\t\tstate_gravityId\n\t\t\t\t) == state_lastValsetCheckpoint,\n\t\t\t\t\"Supplied current validators and powers do not match checkpoint.\"\n\t\t\t);\n\n\t\t\t// Check that the token transfer list is well-formed\n\t\t\trequire(\n\t\t\t\t_args.transferAmounts.length == _args.transferTokenContracts.length,\n\t\t\t\t\"Malformed list of token transfers\"\n\t\t\t);\n\n\t\t\t// Check that the fee list is well-formed\n\t\t\trequire(\n\t\t\t\t_args.feeAmounts.length == _args.feeTokenContracts.length,\n\t\t\t\t\"Malformed list of fees\"\n\t\t\t);\n\t\t}\n\n\t\tbytes32 argsHash =\n\t\t\tkeccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\tstate_gravityId,\n\t\t\t\t\t// bytes32 encoding of \"logicCall\"\n\t\t\t\t\t0x6c6f67696343616c6c0000000000000000000000000000000000000000000000,\n\t\t\t\t\t_args.transferAmounts,\n\t\t\t\t\t_args.transferTokenContracts,\n\t\t\t\t\t_args.feeAmounts,\n\t\t\t\t\t_args.feeTokenContracts,\n\t\t\t\t\t_args.logicContractAddress,\n\t\t\t\t\t_args.payload,\n\t\t\t\t\t_args.timeOut,\n\t\t\t\t\t_args.invalidationId,\n\t\t\t\t\t_args.invalidationNonce\n\t\t\t\t)\n\t\t\t);\n\n\t\t{\n\t\t\t// Check that enough current validators have signed off on the transaction batch and valset\n\t\t\tcheckValidatorSignatures(\n\t\t\t\t_currentValidators,\n\t\t\t\t_currentPowers,\n\t\t\t\t_v,\n\t\t\t\t_r,\n\t\t\t\t_s,\n\t\t\t\t// Get hash of the transaction batch and checkpoint\n\t\t\t\targsHash,\n\t\t\t\tstate_powerThreshold\n\t\t\t);\n\t\t}\n\n\t\t// ACTIONS\n\n\t\t// Update invaldiation nonce\n\t\tstate_invalidationMapping[_args.invalidationId] = _args.invalidationNonce;\n\n\t\t// Send tokens to the logic contract\n\t\tfor (uint256 i = 0; i < _args.transferAmounts.length; i++) {\n\t\t\tIERC20(_args.transferTokenContracts[i]).safeTransfer(\n\t\t\t\t_args.logicContractAddress,\n\t\t\t\t_args.transferAmounts[i]\n\t\t\t);\n\t\t}\n\n\t\t// Make call to logic contract\n\t\tbytes memory returnData = Address.functionCall(_args.logicContractAddress, _args.payload);\n\n\t\t// Send fees to msg.sender\n\t\tfor (uint256 i = 0; i < _args.feeAmounts.length; i++) {\n\t\t\tIERC20(_args.feeTokenContracts[i]).safeTransfer(msg.sender, _args.feeAmounts[i]);\n\t\t}\n\n\t\t// LOGS scoped to reduce stack depth\n\t\t{\n\t\t\tstate_lastEventNonce = state_lastEventNonce.add(1);\n\t\t\temit LogicCallEvent(\n\t\t\t\t_args.invalidationId,\n\t\t\t\t_args.invalidationNonce,\n\t\t\t\tstate_lastEventNonce,\n\t\t\t\treturnData\n\t\t\t);\n\t\t}\n\t}","contract":"Hub2Eth","time":0},{"type":"external-function ","before":"function panicHalt(address[] memory _tokenContracts, address _safeAddress) public {\n\t\trequire(msg.sender == guardian, \"permission denied\");\n\n\t\tfor (uint256 i = 0; i < _tokenContracts.length; i++) {\n\t\t\tIERC20 token = IERC20(_tokenContracts[i]);\n\t\t\ttoken.safeTransfer(_safeAddress, token.balanceOf(address(this)));\n\t\t}\n\t}","after":"function panicHalt(address[] calldata _tokenContracts, address _safeAddress) public {\n\t\trequire(msg.sender == guardian, \"permission denied\");\n\n\t\tfor (uint256 i = 0; i < _tokenContracts.length; i++) {\n\t\t\tIERC20 token = IERC20(_tokenContracts[i]);\n\t\t\ttoken.safeTransfer(_safeAddress, token.balanceOf(address(this)));\n\t\t}\n\t}","contract":"Hub2Eth","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public state_gravityId;","after":"bytes32 public immutable state_gravityId;","contract":"Hub2Eth","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public state_powerThreshold;","after":"uint256 public immutable state_powerThreshold;","contract":"Hub2Eth","time":0},{"type":"immutable-restrict-modification ","before":"address public wethAddress;","after":"address public immutable wethAddress;","contract":"Hub2Eth","time":0}]}