{"time":200,"results":[{"type":"external-function ","before":"function intializeContract(address[] memory accounts, uint256[] memory amounts) external onlyOwner {\n        require(!contractInitialized, \"Contract already initialized.\");\n        require(accounts.length < 50, \"Max 50 wallets.\");\n        require(accounts.length == amounts.length, \"Must be equal lengths.\");\n\n        _name = \"Miyazaki Inu\";\n        _symbol = \"MIYAZAKI\";\n        startingSupply = 1_000_000_000_000_000;\n        if (startingSupply < 10000000000) {\n            _decimals = 18;\n        } else {\n            _decimals = 9;\n        }\n        _tTotal = startingSupply * (10**_decimals);\n        _rTotal = (MAX - (MAX % _tTotal));\n\n        dexRouter = IUniswapV2Router02(_routerAddress);\n        lpPair = IUniswapV2Factory(dexRouter.factory()).createPair(dexRouter.WETH(), address(this));\n        lpPairs[lpPair] = true;\n\n        uint256 percent = 2;\n        uint256 divisor = 1000;\n        _maxTxAmount = (_tTotal * percent) / divisor;\n        maxTxAmountUI = (startingSupply * percent) / divisor;\n        percent = 55;\n        divisor = 10000;\n        _maxWalletSize = (_tTotal * percent) / divisor;\n        maxWalletSizeUI = (startingSupply * percent) / divisor;\n        swapThreshold = (_tTotal * 5) / 10000;\n        swapAmount = (_tTotal * 5) / 1000;\n        if(address(antiSnipe) == address(0)){\n            antiSnipe = AntiSnipe(address(this));\n        }\n        contractInitialized = true;     \n        _rOwned[owner()] = _rTotal;\n        emit Transfer(address(0), owner(), _tTotal);\n\n        _approve(address(this), address(dexRouter), type(uint256).max);\n\n        for(uint256 i = 0; i < accounts.length; i++){\n            address wallet = accounts[i];\n            uint256 amount = amounts[i]*10**_decimals;\n            _transfer(owner(), wallet, amount);\n        }\n\n        _transfer(owner(), address(this), balanceOf(owner()));\n\n        dexRouter.addLiquidityETH{value: address(this).balance}(\n            address(this),\n            balanceOf(address(this)),\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner(),\n            block.timestamp\n        );\n\n        enableTrading();\n    }","after":"function intializeContract(address[] calldata accounts, uint256[] calldata amounts) external onlyOwner {\n        require(!contractInitialized, \"Contract already initialized.\");\n        require(accounts.length < 50, \"Max 50 wallets.\");\n        require(accounts.length == amounts.length, \"Must be equal lengths.\");\n\n        _name = \"Miyazaki Inu\";\n        _symbol = \"MIYAZAKI\";\n        startingSupply = 1_000_000_000_000_000;\n        if (startingSupply < 10000000000) {\n            _decimals = 18;\n        } else {\n            _decimals = 9;\n        }\n        _tTotal = startingSupply * (10**_decimals);\n        _rTotal = (MAX - (MAX % _tTotal));\n\n        dexRouter = IUniswapV2Router02(_routerAddress);\n        lpPair = IUniswapV2Factory(dexRouter.factory()).createPair(dexRouter.WETH(), address(this));\n        lpPairs[lpPair] = true;\n\n        uint256 percent = 2;\n        uint256 divisor = 1000;\n        _maxTxAmount = (_tTotal * percent) / divisor;\n        maxTxAmountUI = (startingSupply * percent) / divisor;\n        percent = 55;\n        divisor = 10000;\n        _maxWalletSize = (_tTotal * percent) / divisor;\n        maxWalletSizeUI = (startingSupply * percent) / divisor;\n        swapThreshold = (_tTotal * 5) / 10000;\n        swapAmount = (_tTotal * 5) / 1000;\n        if(address(antiSnipe) == address(0)){\n            antiSnipe = AntiSnipe(address(this));\n        }\n        contractInitialized = true;     \n        _rOwned[owner()] = _rTotal;\n        emit Transfer(address(0), owner(), _tTotal);\n\n        _approve(address(this), address(dexRouter), type(uint256).max);\n\n        for(uint256 i = 0; i < accounts.length; i++){\n            address wallet = accounts[i];\n            uint256 amount = amounts[i]*10**_decimals;\n            _transfer(owner(), wallet, amount);\n        }\n\n        _transfer(owner(), address(this), balanceOf(owner()));\n\n        dexRouter.addLiquidityETH{value: address(this).balance}(\n            address(this),\n            balanceOf(address(this)),\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner(),\n            block.timestamp\n        );\n\n        enableTrading();\n    }","contract":"AaTokenContract","time":0},{"type":"constant-restrict-modification  ","before":"bool private allowedPresaleExclusion = true;","after":"bool private constant allowedPresaleExclusion = true;","contract":"AaTokenContract","time":1}]}