{"time":860,"results":[{"type":"state-data-arrangement ","before":"\nuint256 internal constant ALL_TOKEN_NUM = 10133;\nstring public constant SHA256 = \"253762fe521a835df8726d8c614f0f7bbb86e67690b422e0c3556d7b4d5e146d\";\nuint256 internal constant ALL_DRAW_NUM = 3;\nDraw[ALL_DRAW_NUM] internal allDraws;\nuint256 internal soldNumber;\nbool internal enabled = true;\nuint256 internal constant ALL_SLICE_NUM = 6;\nSlice[ALL_SLICE_NUM] internal slices;\nuint256 internal giftFund;\naddress internal giftFundAddress;","after":"uint256 internal constant ALL_TOKEN_NUM = 10133;\nstring public constant SHA256 = \"253762fe521a835df8726d8c614f0f7bbb86e67690b422e0c3556d7b4d5e146d\";\nuint256 internal constant ALL_DRAW_NUM = 3;\nDraw[ALL_DRAW_NUM] internal allDraws;\nuint256 internal soldNumber;\nuint256 internal constant ALL_SLICE_NUM = 6;\nSlice[ALL_SLICE_NUM] internal slices;\nuint256 internal giftFund;\naddress internal giftFundAddress;\nbool internal enabled = true;\n","contract":"Anon","time":0},{"type":"external-function ","before":"function draw(string memory uuid) public onlyWhenEnabled payable {\n        uint256 number;\n        for (uint256 i = 0; i < ALL_DRAW_NUM; i++) {\n            if (allDraws[i].price == msg.value) {\n                number = allDraws[i].number;\n                break;\n            }\n        }\n\n        require(\n            number > 0,\n            \"Invalid price, please pay either 0.1 ETH for 1 draw or 0.45 ETH for 5 draws or 0.8 ETH for 10 draws\"\n        );\n\n        uint256 newSoldNumber = soldNumber + number;\n\n        require(newSoldNumber <= ALL_TOKEN_NUM, \"Not enough supply\");\n\n        uint256[] memory tokens = new uint256[](number);\n\n        for (uint256 i = 0; i < number; i++) {\n            // tokenId is taken sequential\n            uint256 tokenId = soldNumber + i;\n            // mint the token immediately\n            _mint(msg.sender, tokenId);\n\n            tokens[i] = tokenId;\n        }\n\n        // update the sold number\n        soldNumber = newSoldNumber;\n\n        // Emit token drawn event\n        emit TokenDrawn(uuid, tokens);\n    }","after":"function draw(string calldata uuid) public onlyWhenEnabled payable {\n        uint256 number;\n        for (uint256 i = 0; i < ALL_DRAW_NUM; i++) {\n            if (allDraws[i].price == msg.value) {\n                number = allDraws[i].number;\n                break;\n            }\n        }\n\n        require(\n            number > 0,\n            \"Invalid price, please pay either 0.1 ETH for 1 draw or 0.45 ETH for 5 draws or 0.8 ETH for 10 draws\"\n        );\n\n        uint256 newSoldNumber = soldNumber + number;\n\n        require(newSoldNumber <= ALL_TOKEN_NUM, \"Not enough supply\");\n\n        uint256[] memory tokens = new uint256[](number);\n\n        for (uint256 i = 0; i < number; i++) {\n            // tokenId is taken sequential\n            uint256 tokenId = soldNumber + i;\n            // mint the token immediately\n            _mint(msg.sender, tokenId);\n\n            tokens[i] = tokenId;\n        }\n\n        // update the sold number\n        soldNumber = newSoldNumber;\n\n        // Emit token drawn event\n        emit TokenDrawn(uuid, tokens);\n    }","contract":"Anon","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseURI_) public onlyOwner {\n        _setBaseURI(baseURI_);\n    }","after":"function setBaseURI(string calldata baseURI_) public onlyOwner {\n        _setBaseURI(baseURI_);\n    }","contract":"Anon","time":0},{"type":"external-function ","before":"function onTokenTransfer(address sender, uint256 fee, bytes memory _data)\n        public\n    {\n        (bytes32 keyHash, uint256 seed) = abi.decode(_data, (bytes32, uint256));\n        emit RandomnessRequest(sender, keyHash, seed);\n    }","after":"function onTokenTransfer(address sender, uint256 fee, bytes calldata _data)\n        public\n    {\n        (bytes32 keyHash, uint256 seed) = abi.decode(_data, (bytes32, uint256));\n        emit RandomnessRequest(sender, keyHash, seed);\n    }","contract":"DummyVRF","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            msg.sender,\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            msg.sender,\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"NativeMetaTransaction","time":0}]}