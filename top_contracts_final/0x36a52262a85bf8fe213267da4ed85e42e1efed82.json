{"time":153,"results":[{"type":"external-function ","before":"function addToWhiteList(\n        address[] memory _addresses\n    ) \n        external\n        onlyOwner\n    {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            require(_addresses[i] != address(0), \"Cannot add the null address\");\n            whiteList[_addresses[i]] = true;\n            /**\n            * @dev We don't want to reset _whiteListClaimed count\n            * if we try to add someone more than once.\n            */\n            whiteListClaimed[_addresses[i]] > 0 ? whiteListClaimed[_addresses[i]] : 0;\n        }\n    }","after":"function addToWhiteList(\n        address[] calldata _addresses\n    ) \n        external\n        onlyOwner\n    {\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            require(_addresses[i] != address(0), \"Cannot add the null address\");\n            whiteList[_addresses[i]] = true;\n            /**\n            * @dev We don't want to reset _whiteListClaimed count\n            * if we try to add someone more than once.\n            */\n            whiteListClaimed[_addresses[i]] > 0 ? whiteListClaimed[_addresses[i]] : 0;\n        }\n    }","contract":"Horizon","time":0},{"type":"external-function ","before":"function setURIs(\n        string memory _blindURI, \n        string memory _URI\n    ) \n        external \n        onlyOwner \n    {\n        blindURI = _blindURI;\n        baseURI = _URI;\n    }","after":"function setURIs(\n        string calldata _blindURI, \n        string calldata _URI\n    ) \n        external \n        onlyOwner \n    {\n        blindURI = _blindURI;\n        baseURI = _URI;\n    }","contract":"Horizon","time":0},{"type":"external-function ","before":"function mintMultipleByOwner(\n        address[] memory _to, \n        uint256[] memory _tokenId\n    ) \n        public \n        onlyOwner\n    {\n        require(_to.length == _tokenId.length, \"Should have same length\");\n        for(uint256 i = 0; i < _to.length; i++){\n            require(_tokenId[i] >= MAX_NFT_PUBLIC, \"Tokens number to mint must exceed number of public tokens\");\n            require(_tokenId[i] < MAX_NFT, \"Tokens number to mint cannot exceed number of MAX tokens\");\n            _safeMint(_to[i], _tokenId[i]);\n            giveawayCount = giveawayCount.add(1);\n        }\n    }","after":"function mintMultipleByOwner(\n        address[] calldata _to, \n        uint256[] calldata _tokenId\n    ) \n        public \n        onlyOwner\n    {\n        require(_to.length == _tokenId.length, \"Should have same length\");\n        for(uint256 i = 0; i < _to.length; i++){\n            require(_tokenId[i] >= MAX_NFT_PUBLIC, \"Tokens number to mint must exceed number of public tokens\");\n            require(_tokenId[i] < MAX_NFT, \"Tokens number to mint cannot exceed number of MAX tokens\");\n            _safeMint(_to[i], _tokenId[i]);\n            giveawayCount = giveawayCount.add(1);\n        }\n    }","contract":"Horizon","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public NFTPrice = 120000000000000000;","after":"uint256 public constant NFTPrice = 120000000000000000;","contract":"Horizon","time":0}]}