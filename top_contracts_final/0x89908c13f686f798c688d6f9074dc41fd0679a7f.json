{"time":183,"results":[{"type":"external-function ","before":"function setUri(string memory newuri) external onlyOwner\n    {\n        _setURI(newuri);\n    }","after":"function setUri(string calldata newuri) external onlyOwner\n    {\n        _setURI(newuri);\n    }","contract":"Gears","time":0},{"type":"external-function ","before":"function mint(uint16[] memory multipassIds) external canMint(uint16(multipassIds.length))\n    {\n        uint number = uint16(multipassIds.length);\n        address holder = _msgSender();\n        \n        uint16 _currentMintedID = nftToken.currentMinted;\n        for (uint16 i = 0; i < number; i++)\n        {\n            if (!IMultipassGear(multipassAddress).hasApplyGear(multipassIds[i]))\n            {\n                IMultipassGear(multipassAddress).applyGear(multipassIds[i], holder, _currentMintedID);\n                _balances[_currentMintedID][holder].amount += 1;\n                _balances[_currentMintedID][holder].multipassId = multipassIds[i];\n                _balances[_currentMintedID][holder].mintedAtTimestamp = uint32(block.timestamp);\n\n                emit TransferSingle(_msgSender(), address(0), holder, _currentMintedID, 1);\n                emit MintGear(_currentMintedID, multipassIds[i], holder, holder, block.timestamp);\n\n                _currentMintedID += 1;\n            }\n        }\n        nftToken.currentMinted = _currentMintedID;\n    }","after":"function mint(uint16[] calldata multipassIds) external canMint(uint16(multipassIds.length))\n    {\n        uint number = uint16(multipassIds.length);\n        address holder = _msgSender();\n        \n        uint16 _currentMintedID = nftToken.currentMinted;\n        for (uint16 i = 0; i < number; i++)\n        {\n            if (!IMultipassGear(multipassAddress).hasApplyGear(multipassIds[i]))\n            {\n                IMultipassGear(multipassAddress).applyGear(multipassIds[i], holder, _currentMintedID);\n                _balances[_currentMintedID][holder].amount += 1;\n                _balances[_currentMintedID][holder].multipassId = multipassIds[i];\n                _balances[_currentMintedID][holder].mintedAtTimestamp = uint32(block.timestamp);\n\n                emit TransferSingle(_msgSender(), address(0), holder, _currentMintedID, 1);\n                emit MintGear(_currentMintedID, multipassIds[i], holder, holder, block.timestamp);\n\n                _currentMintedID += 1;\n            }\n        }\n        nftToken.currentMinted = _currentMintedID;\n    }","contract":"Gears","time":0},{"type":"external-function ","before":"function applyingToAvatar(uint16[] memory gearIds, uint16[] memory avatarIds) external\n    {\n        address holder = _msgSender();\n        require(gearIds.length == avatarIds.length, \"Must the same length between avatars and gears.\");\n        for (uint i = 0; i < gearIds.length; i++)\n        {\n            require(existsToken(holder, gearIds[i]), \"Holder:did not own this token\");\n            IAvatarsGear(avatarAddress).applyGear(avatarIds[i], holder, uint32(gearIds[i]));\n            _balances[gearIds[i]][holder].amount = 0;\n            emit ApplyGear(gearIds[i], holder, avatarIds[i]);\n            emit TransferSingle(holder, holder, address(0), gearIds[i], 1);\n        }\n    }","after":"function applyingToAvatar(uint16[] calldata gearIds, uint16[] calldata avatarIds) external\n    {\n        address holder = _msgSender();\n        require(gearIds.length == avatarIds.length, \"Must the same length between avatars and gears.\");\n        for (uint i = 0; i < gearIds.length; i++)\n        {\n            require(existsToken(holder, gearIds[i]), \"Holder:did not own this token\");\n            IAvatarsGear(avatarAddress).applyGear(avatarIds[i], holder, uint32(gearIds[i]));\n            _balances[gearIds[i]][holder].amount = 0;\n            emit ApplyGear(gearIds[i], holder, avatarIds[i]);\n            emit TransferSingle(holder, holder, address(0), gearIds[i], 1);\n        }\n    }","contract":"Gears","time":0},{"type":"external-function ","before":"function mintAndApply(uint16[] memory multipassIds, uint16[] memory avatarIds) external\n    {\n        require(avatarIds.length == multipassIds.length, \"Must the same length between multipass and avatars.\");\n        uint number = uint16(multipassIds.length);\n        address holder = _msgSender();\n        uint16 _currentMintedID = nftToken.currentMinted;\n\n        for (uint16 i = 0; i < number; i++)\n        {\n            if (!IMultipassGear(multipassAddress).hasApplyGear(multipassIds[i]))\n            {\n                IMultipassGear(multipassAddress).applyGear(multipassIds[i], holder, _currentMintedID);\n                _balances[_currentMintedID][holder].multipassId = multipassIds[i];\n                _balances[_currentMintedID][holder].mintedAtTimestamp = uint32(block.timestamp);\n\n                IAvatarsGear(avatarAddress).applyGear(avatarIds[i], holder, _currentMintedID);\n\n                emit ApplyGear(_currentMintedID, holder, avatarIds[i]);\n                emit TransferSingle(holder, holder, address(0), _currentMintedID, 1);\n\n                _currentMintedID += 1;\n            }\n        }\n        nftToken.currentMinted = _currentMintedID;\n    }","after":"function mintAndApply(uint16[] calldata multipassIds, uint16[] calldata avatarIds) external\n    {\n        require(avatarIds.length == multipassIds.length, \"Must the same length between multipass and avatars.\");\n        uint number = uint16(multipassIds.length);\n        address holder = _msgSender();\n        uint16 _currentMintedID = nftToken.currentMinted;\n\n        for (uint16 i = 0; i < number; i++)\n        {\n            if (!IMultipassGear(multipassAddress).hasApplyGear(multipassIds[i]))\n            {\n                IMultipassGear(multipassAddress).applyGear(multipassIds[i], holder, _currentMintedID);\n                _balances[_currentMintedID][holder].multipassId = multipassIds[i];\n                _balances[_currentMintedID][holder].mintedAtTimestamp = uint32(block.timestamp);\n\n                IAvatarsGear(avatarAddress).applyGear(avatarIds[i], holder, _currentMintedID);\n\n                emit ApplyGear(_currentMintedID, holder, avatarIds[i]);\n                emit TransferSingle(holder, holder, address(0), _currentMintedID, 1);\n\n                _currentMintedID += 1;\n            }\n        }\n        nftToken.currentMinted = _currentMintedID;\n    }","contract":"Gears","time":1},{"type":"external-function ","before":"function batchMint(address[] memory _addrs) external onlyOwner\n    {        \n        require(nftToken.currentMinted + uint16(_addrs.length) <= nftToken.totalSupply + 1, \"Exceed the max supply!\");\n\n        uint8 number = uint8(_addrs.length);\n        uint16 _currentMintedID = nftToken.currentMinted;\n\n        for (uint8 i = 0; i < number; i++)\n        {\n            _balances[_currentMintedID][_addrs[i]].amount += 1;\n            _balances[_currentMintedID][_addrs[i]].mintedAtTimestamp = uint32(block.timestamp);\n            _balances[_currentMintedID][_addrs[i]].multipassId = 65535;\n\n            emit TransferSingle(_msgSender(), address(0), _addrs[i], _currentMintedID, 1);\n            emit MintGear(_currentMintedID, 65535, _addrs[i], _msgSender(), block.timestamp);\n\n            _currentMintedID++;\n        }\n        nftToken.currentMinted = _currentMintedID;\n    }","after":"function batchMint(address[] calldata _addrs) external onlyOwner\n    {        \n        require(nftToken.currentMinted + uint16(_addrs.length) <= nftToken.totalSupply + 1, \"Exceed the max supply!\");\n\n        uint8 number = uint8(_addrs.length);\n        uint16 _currentMintedID = nftToken.currentMinted;\n\n        for (uint8 i = 0; i < number; i++)\n        {\n            _balances[_currentMintedID][_addrs[i]].amount += 1;\n            _balances[_currentMintedID][_addrs[i]].mintedAtTimestamp = uint32(block.timestamp);\n            _balances[_currentMintedID][_addrs[i]].multipassId = 65535;\n\n            emit TransferSingle(_msgSender(), address(0), _addrs[i], _currentMintedID, 1);\n            emit MintGear(_currentMintedID, 65535, _addrs[i], _msgSender(), block.timestamp);\n\n            _currentMintedID++;\n        }\n        nftToken.currentMinted = _currentMintedID;\n    }","contract":"Gears","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"Gears","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"Gears","time":0}]}