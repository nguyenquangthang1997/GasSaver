{"time":597,"results":[{"type":"de-morgan-condition ","before":"!admins[witnessA] || !admins[witnessB]","after":"!(admins[witnessA] || admins[witnessB])","loc":{"start":{"line":44,"column":10},"end":{"line":44,"column":47}},"contract":"WrappedPeercoin","time":0},{"type":"external-function ","before":"function claimTokens(uint256 _amount, string memory _externalAddress, address _receiver, address _signerA, bytes memory _signatureA, address _signerB, bytes memory _signatureB, address _signerC, bytes memory _signatureC) public onlyEOA {\n      require(!usedExternalAddresses[_externalAddress], \"wPPC: invalid nonce\");\n\n      address witnessA = recoverSigner(prefixed(keccak256(abi.encodePacked(_receiver, _amount, _externalAddress, _signerA))), _signatureA);\n      address witnessB = recoverSigner(prefixed(keccak256(abi.encodePacked(_receiver, _amount, _externalAddress, _signerB))), _signatureB);\n      address witnessC = recoverSigner(prefixed(keccak256(abi.encodePacked(_receiver, _amount, _externalAddress, _signerC))), _signatureC);\n\n      if (witnessA == witnessB || witnessB == witnessC) {\n        revert(\"Same witness cannot sign twice\");\n      }\n\n      if (!admins[witnessA] || !admins[witnessB] || !admins[witnessC]) {\n        revert('Could not validate one or more signatures');\n      }\n\n      usedExternalAddresses[_externalAddress] = true;\n\n      _mint(_receiver, (_amount-fee));\n  }","after":"function claimTokens(uint256 _amount, string calldata _externalAddress, address _receiver, address _signerA, bytes calldata _signatureA, address _signerB, bytes calldata _signatureB, address _signerC, bytes calldata _signatureC) public onlyEOA {\n      require(!usedExternalAddresses[_externalAddress], \"wPPC: invalid nonce\");\n\n      address witnessA = recoverSigner(prefixed(keccak256(abi.encodePacked(_receiver, _amount, _externalAddress, _signerA))), _signatureA);\n      address witnessB = recoverSigner(prefixed(keccak256(abi.encodePacked(_receiver, _amount, _externalAddress, _signerB))), _signatureB);\n      address witnessC = recoverSigner(prefixed(keccak256(abi.encodePacked(_receiver, _amount, _externalAddress, _signerC))), _signatureC);\n\n      if (witnessA == witnessB || witnessB == witnessC) {\n        revert(\"Same witness cannot sign twice\");\n      }\n\n      if (!admins[witnessA] || !admins[witnessB] || !admins[witnessC]) {\n        revert('Could not validate one or more signatures');\n      }\n\n      usedExternalAddresses[_externalAddress] = true;\n\n      _mint(_receiver, (_amount-fee));\n  }","contract":"WrappedPeercoin","time":0},{"type":"external-function ","before":"function burnTokens(uint256 _amount, string memory _externalAddress) public onlyEOA {\n      _burn(msg.sender, _amount);\n\n      emit WPPCBurned(msg.sender, address(0), _amount, _externalAddress);\n  }","after":"function burnTokens(uint256 _amount, string calldata _externalAddress) public onlyEOA {\n      _burn(msg.sender, _amount);\n\n      emit WPPCBurned(msg.sender, address(0), _amount, _externalAddress);\n  }","contract":"WrappedPeercoin","time":0},{"type":"constant-restrict-modification  ","before":"uint32 fee = 10000;","after":"uint32 constant fee = 10000;","contract":"WrappedPeercoin","time":0}]}