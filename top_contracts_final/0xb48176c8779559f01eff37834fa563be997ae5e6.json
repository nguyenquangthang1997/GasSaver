{"time":145,"results":[{"type":"external-function ","before":"      bytes32 merkleRoot;\n        string ipfsMetadataHash;\n    }\n    constructor(\n        string memory _name,\n        string memory _symbol\n    ) public ERC1155(\"ipfs://\") {\n        name_ = _name;\n        symbol_ = _symbol;\n\n    }\n\n    function mintCommemorativeShark(\n        uint256 _nounId,\n        bytes32[] calldata merkleProof\n    ) external payable {\n        require(commemorativeNfts[_nounId].merkleRoot != bytes32(0), \"Project does not exist\");\n        require(balanceOf(msg.sender, _nounId) < 1, \"Already claimed this Nft\");\n        require(msg.val","after":"      bytes32 merkleRoot;\n        string ipfsMetadataHash;\n    }\n    constructor(\n        string calldata _name,\n        string memory _symbol\n    ) public ERC1155(\"ipfs://\") {\n        name_ = _name;\n        symbol_ = _symbol;\n\n    }\n\n    function mintCommemorativeShark(\n        uint256 _nounId,\n        bytes32[] calldata merkleProof\n    ) external payable {\n        require(commemorativeNfts[_nounId].merkleRoot != bytes32(0), \"Project does not exist\");\n        require(balanceOf(msg.sender, _nounId) < 1, \"Already claimed this Nft\");\n        require(msg.val","contract":"SharkDaoNfts","time":0},{"type":"external-function ","before":"commemorativeNfts[_nounId].mintCost, \"Mint: Ether Value incorrect\");\n        bytes32 node = keccak256(abi.encodePacked(msg.sender));\n        require(_verify(merkleProof, node, _nounId), \"Invalid proof\");\n        \n        uint excessPayment = msg.value - commemorativeNfts[_nounId].mintCost;\n        if (excessPayment > 0) {\n            (bool returnExcessStatus, ) = _msgSender().call{value: excessPayment}(\"\");\n            require(returnExcessStatus, \"Error returning excess payment\");\n        }\n        _mi","after":"commemorativeNfts[_nounId].mintCost, \"Mint: Ether Value incorrect\");\n        bytes32 node = keccak256(abi.encodePacked(msg.sender));\n        require(_verify(merkleProof, node, _nounId), \"Invalid proof\");\n        \n        uint excessPayment = msg.value - commemorativeNfts[_nounId].mintCost;\n        if (excessPayment > 0) {\n            (bool returnExcessStatus, ) = _msgSender().call{value: excessPayment}(\"\");\n            require(returnExcessStatus, \"Error returning excess payment\");\n        }\n        _mi","contract":"SharkDaoNfts","time":0},{"type":"external-function ","before":"░░░░░░----------\n--------░░░░░░--░░░████████�","after":"░░░░░░----------\n--------░░░░░░--░░░████████�","contract":"SharkDaoNfts","time":0},{"type":"external-function ","before":"Id ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in t","after":"Id ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in t","contract":"SharkDaoNfts","time":0},{"type":"external-function ","before":"{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(accou","after":"{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string calldata) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(accou","contract":"SharkDaoNfts","time":0},{"type":"external-function ","before":"upply;\n\n    /**\n     * @dev Total amount of tokens in with a given id.\n     */\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    /**\n     * @dev Indicates weither any token exist with a given id, or not.\n     */\n    function exists(uint256 id) public view virtual returns","after":"upply;\n\n    /**\n     * @dev Total amount of tokens in with a given id.\n     */\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\n        return _totalSupply[id];\n    }\n\n    /**\n     * @dev Indicates weither any token exist with a given id, or not.\n     */\n    function exists(uint256 id) public view virtual returns","contract":"SharkDaoNfts","time":0}]}