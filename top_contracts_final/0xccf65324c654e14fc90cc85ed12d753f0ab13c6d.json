{"time":65,"results":[{"type":"external-function ","before":"function redeemManyTokens(\n        address[] memory _tokenContracts,\n        uint256[] memory _tokenIds,\n        uint256[] memory _purposes,\n        string memory _redeemerName,\n        uint256 _price,\n        address _paymentTokenAddress,\n        bytes memory _signature,\n        uint256 _timestamp\n    ) external payable {\n        require(\n            _tokenContracts.length == _tokenIds.length &&\n                _tokenIds.length == _purposes.length,\n            \"Array length mismatch\"\n        );\n        require(_timestamp + _transactionOffset >= block.timestamp, \"Transaction timed out\");\n        require(\n            verifySignature(\n                _tokenContracts,\n                _tokenIds,\n                _purposes,\n                _price,\n                _paymentTokenAddress,\n                _signature,\n                _timestamp\n            ),\n            \"Signature mismatch\"\n        );\n        uint256 len = _tokenContracts.length;\n        for (uint256 i = 0; i < len; i++) {\n            require(\n                !_isTokenRedeemedForPurpose[_tokenContracts[i]][_tokenIds[i]][\n                    _purposes[i]\n                ],\n                \"Can't be redeemed again\"\n            );\n            IERC721 token = IERC721(_tokenContracts[i]);\n            require(\n                token.ownerOf(_tokenIds[i]) == msg.sender,\n                \"Redeemee needs to own this token\"\n            );\n            _isTokenRedeemedForPurpose[_tokenContracts[i]][_tokenIds[i]][\n                _purposes[i]\n            ] = true;\n            uint256[] memory purpose = new uint256[](1);\n            purpose[0] = _purposes[i];\n            emit Redeemed(\n                _tokenContracts[i],\n                _tokenIds[0],\n                msg.sender,\n                _redeemerName,\n                purpose\n            );\n        }\n        if (_price != 0) {\n            if (_paymentTokenAddress == address(0)) {\n                require(msg.value >= _price, \"Not enough ether\");\n                if (_price < msg.value) {\n                    payable(msg.sender).transfer(msg.value - _price);\n                }\n            } else {\n                require(\n                    IERC20(_paymentTokenAddress).transferFrom(\n                        msg.sender,\n                        address(this),\n                        _price\n                    )\n                );\n            }\n        }\n    }","after":"function redeemManyTokens(\n        address[] calldata _tokenContracts,\n        uint256[] calldata _tokenIds,\n        uint256[] calldata _purposes,\n        string calldata _redeemerName,\n        uint256 _price,\n        address _paymentTokenAddress,\n        bytes calldata _signature,\n        uint256 _timestamp\n    ) external payable {\n        require(\n            _tokenContracts.length == _tokenIds.length &&\n                _tokenIds.length == _purposes.length,\n            \"Array length mismatch\"\n        );\n        require(_timestamp + _transactionOffset >= block.timestamp, \"Transaction timed out\");\n        require(\n            verifySignature(\n                _tokenContracts,\n                _tokenIds,\n                _purposes,\n                _price,\n                _paymentTokenAddress,\n                _signature,\n                _timestamp\n            ),\n            \"Signature mismatch\"\n        );\n        uint256 len = _tokenContracts.length;\n        for (uint256 i = 0; i < len; i++) {\n            require(\n                !_isTokenRedeemedForPurpose[_tokenContracts[i]][_tokenIds[i]][\n                    _purposes[i]\n                ],\n                \"Can't be redeemed again\"\n            );\n            IERC721 token = IERC721(_tokenContracts[i]);\n            require(\n                token.ownerOf(_tokenIds[i]) == msg.sender,\n                \"Redeemee needs to own this token\"\n            );\n            _isTokenRedeemedForPurpose[_tokenContracts[i]][_tokenIds[i]][\n                _purposes[i]\n            ] = true;\n            uint256[] memory purpose = new uint256[](1);\n            purpose[0] = _purposes[i];\n            emit Redeemed(\n                _tokenContracts[i],\n                _tokenIds[0],\n                msg.sender,\n                _redeemerName,\n                purpose\n            );\n        }\n        if (_price != 0) {\n            if (_paymentTokenAddress == address(0)) {\n                require(msg.value >= _price, \"Not enough ether\");\n                if (_price < msg.value) {\n                    payable(msg.sender).transfer(msg.value - _price);\n                }\n            } else {\n                require(\n                    IERC20(_paymentTokenAddress).transferFrom(\n                        msg.sender,\n                        address(this),\n                        _price\n                    )\n                );\n            }\n        }\n    }","contract":"UniqRedeem","time":0},{"type":"external-function ","before":"function redeemTokenForPurposes(\n        address _tokenContract,\n        uint256 _tokenId,\n        uint256[] memory _purposes,\n        string memory _redeemerName,\n        uint256 _price,\n        address _paymentTokenAddress,\n        bytes memory _signature,\n        uint256 _timestamp\n    ) external payable {\n        uint256 len = _purposes.length;\n        require(_timestamp + _transactionOffset >= block.timestamp, \"Transaction timed out\");\n        address[] memory _tokenContracts = new address[](len);\n        uint256[] memory _tokenIds = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            _tokenContracts[i] = _tokenContract;\n            _tokenIds[i] = _tokenId;\n            require(\n                !_isTokenRedeemedForPurpose[_tokenContract][_tokenId][\n                    _purposes[i]\n                ],\n                \"Can't be claimed again\"\n            );\n            IERC721 token = IERC721(_tokenContract);\n            require(\n                token.ownerOf(_tokenId) == msg.sender,\n                \"Claimer needs to own this token\"\n            );\n            _isTokenRedeemedForPurpose[_tokenContract][_tokenId][\n                _purposes[i]\n            ] = true;\n        }\n        require(\n            verifySignature(\n                _tokenContracts,\n                _tokenIds,\n                _purposes,\n                _price,\n                _paymentTokenAddress,\n                _signature,\n                _timestamp\n            ),\n            \"Signature mismatch\"\n        );\n        if (_price != 0) {\n            if (_paymentTokenAddress == address(0)) {\n                require(msg.value >= _price, \"Not enough ether\");\n                if (_price < msg.value) {\n                    payable(msg.sender).transfer(msg.value - _price);\n                }\n            } else {\n                require(\n                    IERC20(_paymentTokenAddress).transferFrom(\n                        msg.sender,\n                        address(this),\n                        _price\n                    )\n                );\n            }\n        }\n        emit Redeemed(\n            _tokenContract,\n            _tokenId,\n            msg.sender,\n            _redeemerName,\n            _purposes\n        );\n    }","after":"function redeemTokenForPurposes(\n        address _tokenContract,\n        uint256 _tokenId,\n        uint256[] calldata _purposes,\n        string calldata _redeemerName,\n        uint256 _price,\n        address _paymentTokenAddress,\n        bytes calldata _signature,\n        uint256 _timestamp\n    ) external payable {\n        uint256 len = _purposes.length;\n        require(_timestamp + _transactionOffset >= block.timestamp, \"Transaction timed out\");\n        address[] memory _tokenContracts = new address[](len);\n        uint256[] memory _tokenIds = new uint256[](len);\n        for (uint256 i = 0; i < len; i++) {\n            _tokenContracts[i] = _tokenContract;\n            _tokenIds[i] = _tokenId;\n            require(\n                !_isTokenRedeemedForPurpose[_tokenContract][_tokenId][\n                    _purposes[i]\n                ],\n                \"Can't be claimed again\"\n            );\n            IERC721 token = IERC721(_tokenContract);\n            require(\n                token.ownerOf(_tokenId) == msg.sender,\n                \"Claimer needs to own this token\"\n            );\n            _isTokenRedeemedForPurpose[_tokenContract][_tokenId][\n                _purposes[i]\n            ] = true;\n        }\n        require(\n            verifySignature(\n                _tokenContracts,\n                _tokenIds,\n                _purposes,\n                _price,\n                _paymentTokenAddress,\n                _signature,\n                _timestamp\n            ),\n            \"Signature mismatch\"\n        );\n        if (_price != 0) {\n            if (_paymentTokenAddress == address(0)) {\n                require(msg.value >= _price, \"Not enough ether\");\n                if (_price < msg.value) {\n                    payable(msg.sender).transfer(msg.value - _price);\n                }\n            } else {\n                require(\n                    IERC20(_paymentTokenAddress).transferFrom(\n                        msg.sender,\n                        address(this),\n                        _price\n                    )\n                );\n            }\n        }\n        emit Redeemed(\n            _tokenContract,\n            _tokenId,\n            msg.sender,\n            _redeemerName,\n            _purposes\n        );\n    }","contract":"UniqRedeem","time":0},{"type":"external-function ","before":"function setStatusesForTokens(address[] memory _tokenAddresses, uint256[] memory _tokenIds, uint256[] memory _purposes, bool[] memory isRedeemed) external onlyOwner{\n        uint256 len = _tokenAddresses.length;\n        require(len == _tokenIds.length && len == _purposes.length && len == isRedeemed.length, \"Arrays lengths mismatch\");\n        for(uint i = 0; i < len; i++){\n            _isTokenRedeemedForPurpose[_tokenAddresses[i]][_tokenIds[i]][_purposes[i]] = isRedeemed[i];\n        }\n    }","after":"function setStatusesForTokens(address[] calldata _tokenAddresses, uint256[] calldata _tokenIds, uint256[] calldata _purposes, bool[] calldata isRedeemed) external onlyOwner{\n        uint256 len = _tokenAddresses.length;\n        require(len == _tokenIds.length && len == _purposes.length && len == isRedeemed.length, \"Arrays lengths mismatch\");\n        for(uint i = 0; i < len; i++){\n            _isTokenRedeemedForPurpose[_tokenAddresses[i]][_tokenIds[i]][_purposes[i]] = isRedeemed[i];\n        }\n    }","contract":"UniqRedeem","time":0}]}