{"time":113,"results":[{"type":"external-function ","before":"  function batchBuyFromOpenSea(\n        OpenseaTrades[] memory openseaTrades\n    ) payable external nonReentrant {\n        // execute trades\n        for (uint256 i = 0; i < openseaTrades.length; i++) {\n            // execute trade\n            address(0x7Be8076f4EA4A4AD08075C2508e481d6C946D12b).call{value:openseaTrades[i].value}(openseaTrades[i].tradeData);\n        }\n\n        // return remaining ETH (if any)\n        assembly {\n            if gt(selfbalance(), 0) {\n                let callStatus := call(\n                    gas(),\n                    caller(),\n                    selfbalance(),\n                    0,\n                    0,\n                    0,\n                    0\n                )\n            }\n        }\n   ","after":"  function batchBuyFromOpenSea(\n        OpenseaTrades[] calldata openseaTrades\n    ) payable external nonReentrant {\n        // execute trades\n        for (uint256 i = 0; i < openseaTrades.length; i++) {\n            // execute trade\n            address(0x7Be8076f4EA4A4AD08075C2508e481d6C946D12b).call{value:openseaTrades[i].value}(openseaTrades[i].tradeData);\n        }\n\n        // return remaining ETH (if any)\n        assembly {\n            if gt(selfbalance(), 0) {\n                let callStatus := call(\n                    gas(),\n                    caller(),\n                    selfbalance(),\n                    0,\n                    0,\n                    0,\n                    0\n                )\n            }\n        }\n   ","contract":"GemSwap","time":0},{"type":"external-function ","before":"  function batchBuyWithETH(\n        MarketRegistry.TradeDetails[] memory tradeDetails\n    ) payable external nonReentrant {\n        // execute trades\n        _trade(tradeDetails);\n\n        // return remaining ETH (if any)\n        assembly {\n            if gt(selfbalance(), 0) {\n                let callStatus := call(\n                    gas(),\n                    caller(),\n                    selfbalance(),\n                    0,\n                    0,\n                    0,\n                    0\n                )\n            }\n        }\n   ","after":"  function batchBuyWithETH(\n        MarketRegistry.TradeDetails[] calldata tradeDetails\n    ) payable external nonReentrant {\n        // execute trades\n        _trade(tradeDetails);\n\n        // return remaining ETH (if any)\n        assembly {\n            if gt(selfbalance(), 0) {\n                let callStatus := call(\n                    gas(),\n                    caller(),\n                    selfbalance(),\n                    0,\n                    0,\n                    0,\n                    0\n                )\n            }\n        }\n   ","contract":"GemSwap","time":0},{"type":"external-function ","before":"  function batchBuyWithERC20s(\n        ERC20Details memory erc20Details,\n        MarketRegistry.TradeDetails[] memory tradeDetails,\n        ConverstionDetails[] memory converstionDetails,\n        address[] memory dustTokens\n    ) payable external nonReentrant {\n        // transfer ERC20 tokens from the sender to this contract\n        for (uint256 i = 0; i < erc20Details.tokenAddrs.length; i++) {\n            erc20Details.tokenAddrs[i].call(abi.encodeWithSelector(0x23b872dd, msg.sender, address(this), erc20Details.amounts[i]));\n            // IERC20(erc20Details.tokenAddrs[i]).transferFrom(\n            //     msg.sender,\n            //     address(this),\n            //     erc20Details.amounts[i]\n            // );\n        }\n\n        // Convert any assets if needed\n        _conversionHelper(converstionDetails);\n\n        // execute trades\n        _trade(tradeDetails);\n\n        // return dust tokens (if any)\n        _returnDust(dustTokens);\n   ","after":"  function batchBuyWithERC20s(\n        ERC20Details calldata erc20Details,\n        MarketRegistry.TradeDetails[] calldata tradeDetails,\n        ConverstionDetails[] calldata converstionDetails,\n        address[] calldata dustTokens\n    ) payable external nonReentrant {\n        // transfer ERC20 tokens from the sender to this contract\n        for (uint256 i = 0; i < erc20Details.tokenAddrs.length; i++) {\n            erc20Details.tokenAddrs[i].call(abi.encodeWithSelector(0x23b872dd, msg.sender, address(this), erc20Details.amounts[i]));\n            // IERC20(erc20Details.tokenAddrs[i]).transferFrom(\n            //     msg.sender,\n            //     address(this),\n            //     erc20Details.amounts[i]\n            // );\n        }\n\n        // Convert any assets if needed\n        _conversionHelper(converstionDetails);\n\n        // execute trades\n        _trade(tradeDetails);\n\n        // return dust tokens (if any)\n        _returnDust(dustTokens);\n   ","contract":"GemSwap","time":0},{"type":"external-function ","before":"  function multiAssetSwap(\n        ERC20Details memory erc20Details,\n        SpecialTransferHelper.ERC721Details[] memory erc721Details,\n        ERC1155Details[] memory erc1155Details,\n        ConverstionDetails[] memory converstionDetails,\n        MarketRegistry.TradeDetails[] memory tradeDetails,\n        address[] memory dustTokens,\n        uint256[2] memory feeDetails    // [affiliateIndex, ETH fee in Wei]\n    ) payable external isOpenForTrades nonReentrant {\n        // collect fees\n        _collectFee(feeDetails);\n\n        // transfer all tokens\n        _transferFromHelper(\n            erc20Details,\n            erc721Details,\n            erc1155Details\n        );\n\n        // Convert any assets if needed\n        _conversionHelper(converstionDetails);\n\n        // execute trades\n        _trade(tradeDetails);\n\n        // return dust tokens (if any)\n        _returnDust(dustTokens);\n   ","after":"  function multiAssetSwap(\n        ERC20Details calldata erc20Details,\n        SpecialTransferHelper.ERC721Details[] calldata erc721Details,\n        ERC1155Details[] calldata erc1155Details,\n        ConverstionDetails[] calldata converstionDetails,\n        MarketRegistry.TradeDetails[] calldata tradeDetails,\n        address[] calldata dustTokens,\n        uint256[2] calldata feeDetails    // [affiliateIndex, ETH fee in Wei]\n    ) payable external isOpenForTrades nonReentrant {\n        // collect fees\n        _collectFee(feeDetails);\n\n        // transfer all tokens\n        _transferFromHelper(\n            erc20Details,\n            erc721Details,\n            erc1155Details\n        );\n\n        // Convert any assets if needed\n        _conversionHelper(converstionDetails);\n\n        // execute trades\n        _trade(tradeDetails);\n\n        // return dust tokens (if any)\n        _returnDust(dustTokens);\n   ","contract":"GemSwap","time":0},{"type":"external-function ","before":"  function multiAssetSwapWithoutFee(\n        ERC20Details memory erc20Details,\n        SpecialTransferHelper.ERC721Details[] memory erc721Details,\n        ERC1155Details[] memory erc1155Details,\n        ConverstionDetails[] memory converstionDetails,\n        MarketRegistry.TradeDetails[] memory tradeDetails,\n        address[] memory dustTokens,\n        uint256 sponsoredMarketIndex\n    ) payable external isOpenForFreeTrades nonReentrant {\n        // fetch the marketId of the sponsored market\n        SponsoredMarket memory sponsoredMarket = sponsoredMarkets[sponsoredMarketIndex];\n        // check if the market is active\n        require(sponsoredMarket.isActive, \"multiAssetSwapWithoutFee: InActive sponsored market\");\n\n        // transfer all tokens\n        _transferFromHelper(\n            erc20Details,\n            erc721Details,\n            erc1155Details\n        );\n\n        // Convert any assets if needed\n        _conversionHelper(converstionDetails);\n\n        // execute trades\n        bool isSponsored = _tradeSponsored(tradeDetails, sponsoredMarket.marketId);\n\n        // check if the trades include the sponsored market\n        require(isSponsored, \"multiAssetSwapWithoutFee: trades do not include sponsored market\");\n\n        // return dust tokens (if any)\n        _returnDust(dustTokens);\n   ","after":"  function multiAssetSwapWithoutFee(\n        ERC20Details calldata erc20Details,\n        SpecialTransferHelper.ERC721Details[] calldata erc721Details,\n        ERC1155Details[] calldata erc1155Details,\n        ConverstionDetails[] calldata converstionDetails,\n        MarketRegistry.TradeDetails[] calldata tradeDetails,\n        address[] calldata dustTokens,\n        uint256 sponsoredMarketIndex\n    ) payable external isOpenForFreeTrades nonReentrant {\n        // fetch the marketId of the sponsored market\n        SponsoredMarket memory sponsoredMarket = sponsoredMarkets[sponsoredMarketIndex];\n        // check if the market is active\n        require(sponsoredMarket.isActive, \"multiAssetSwapWithoutFee: InActive sponsored market\");\n\n        // transfer all tokens\n        _transferFromHelper(\n            erc20Details,\n            erc721Details,\n            erc1155Details\n        );\n\n        // Convert any assets if needed\n        _conversionHelper(converstionDetails);\n\n        // execute trades\n        bool isSponsored = _tradeSponsored(tradeDetails, sponsoredMarket.marketId);\n\n        // check if the trades include the sponsored market\n        require(isSponsored, \"multiAssetSwapWithoutFee: trades do not include sponsored market\");\n\n        // return dust tokens (if any)\n        _returnDust(dustTokens);\n   ","contract":"GemSwap","time":0}]}