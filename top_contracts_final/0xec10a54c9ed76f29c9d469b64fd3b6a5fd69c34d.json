{"time":217,"results":[{"type":"de-morgan-condition ","before":"!proposal.flags[4] && !proposal.flags[5]","after":"!(proposal.flags[4] && proposal.flags[5])","loc":{"start":{"line":475,"column":16},"end":{"line":475,"column":55}},"contract":"Moloch","time":0},{"type":"struct-data-arrangement ","before":"\naddress delegateKey\nuint256 shares\nuint256 loot\nbool exists\nuint256 highestIndexYesVote\nuint256 jailed","after":"uint256 shares\nuint256 loot\nuint256 highestIndexYesVote\nuint256 jailed\naddress delegateKey\nbool exists\n","contract":"Moloch","time":0},{"type":"external-function ","before":"function submitProposal(\n        address applicant,\n        uint256 sharesRequested,\n        uint256 lootRequested,\n        uint256 tributeOffered,\n        address tributeToken,\n        uint256 paymentRequested,\n        address paymentToken,\n        string memory details\n    ) public nonReentrant returns (uint256 proposalId) {\n        require(sharesRequested.add(lootRequested) <= MAX_NUMBER_OF_SHARES_AND_LOOT, \"too many shares requested\");\n        require(tokenWhitelist[tributeToken], \"tributeToken is not whitelisted\");\n        require(tokenWhitelist[paymentToken], \"payment is not whitelisted\");\n        require(applicant != address(0), \"applicant cannot be 0\");\n        require(applicant != GUILD && applicant != ESCROW && applicant != TOTAL, \"applicant address cannot be reserved\");\n        require(members[applicant].jailed == 0, \"proposal applicant must not be jailed\");\n\n        if (tributeOffered > 0 && userTokenBalances[GUILD][tributeToken] == 0) {\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, 'cannot submit more tribute proposals for new tokens - guildbank is full');\n        }\n\n        // collect tribute from proposer and store it in the Moloch until the proposal is processed\n        require(IERC20(tributeToken).transferFrom(msg.sender, address(this), tributeOffered), \"tribute token transfer failed\");\n        unsafeAddToBalance(ESCROW, tributeToken, tributeOffered);\n\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n\n        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags);\n        return proposalCount - 1; // return proposalId - contracts calling submit might want it\n    }","after":"function submitProposal(\n        address applicant,\n        uint256 sharesRequested,\n        uint256 lootRequested,\n        uint256 tributeOffered,\n        address tributeToken,\n        uint256 paymentRequested,\n        address paymentToken,\n        string calldata details\n    ) public nonReentrant returns (uint256 proposalId) {\n        require(sharesRequested.add(lootRequested) <= MAX_NUMBER_OF_SHARES_AND_LOOT, \"too many shares requested\");\n        require(tokenWhitelist[tributeToken], \"tributeToken is not whitelisted\");\n        require(tokenWhitelist[paymentToken], \"payment is not whitelisted\");\n        require(applicant != address(0), \"applicant cannot be 0\");\n        require(applicant != GUILD && applicant != ESCROW && applicant != TOTAL, \"applicant address cannot be reserved\");\n        require(members[applicant].jailed == 0, \"proposal applicant must not be jailed\");\n\n        if (tributeOffered > 0 && userTokenBalances[GUILD][tributeToken] == 0) {\n            require(totalGuildBankTokens < MAX_TOKEN_GUILDBANK_COUNT, 'cannot submit more tribute proposals for new tokens - guildbank is full');\n        }\n\n        // collect tribute from proposer and store it in the Moloch until the proposal is processed\n        require(IERC20(tributeToken).transferFrom(msg.sender, address(this), tributeOffered), \"tribute token transfer failed\");\n        unsafeAddToBalance(ESCROW, tributeToken, tributeOffered);\n\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n\n        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags);\n        return proposalCount - 1; // return proposalId - contracts calling submit might want it\n    }","contract":"Moloch","time":0},{"type":"external-function ","before":"function submitWhitelistProposal(address tokenToWhitelist, string memory details) public nonReentrant returns (uint256 proposalId) {\n        require(tokenToWhitelist != address(0), \"must provide token address\");\n        require(!tokenWhitelist[tokenToWhitelist], \"cannot already have whitelisted the token\");\n        require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"cannot submit more whitelist proposals\");\n\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n        flags[4] = true; // whitelist\n\n        _submitProposal(address(0), 0, 0, 0, tokenToWhitelist, 0, address(0), details, flags);\n        return proposalCount - 1;\n    }","after":"function submitWhitelistProposal(address tokenToWhitelist, string calldata details) public nonReentrant returns (uint256 proposalId) {\n        require(tokenToWhitelist != address(0), \"must provide token address\");\n        require(!tokenWhitelist[tokenToWhitelist], \"cannot already have whitelisted the token\");\n        require(approvedTokens.length < MAX_TOKEN_WHITELIST_COUNT, \"cannot submit more whitelist proposals\");\n\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n        flags[4] = true; // whitelist\n\n        _submitProposal(address(0), 0, 0, 0, tokenToWhitelist, 0, address(0), details, flags);\n        return proposalCount - 1;\n    }","contract":"Moloch","time":0},{"type":"external-function ","before":"function submitGuildKickProposal(address memberToKick, string memory details) public nonReentrant returns (uint256 proposalId) {\n        Member memory member = members[memberToKick];\n\n        require(member.shares > 0 || member.loot > 0, \"member must have at least one share or one loot\");\n        require(members[memberToKick].jailed == 0, \"member must not already be jailed\");\n\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n        flags[5] = true; // guild kick\n\n        _submitProposal(memberToKick, 0, 0, 0, address(0), 0, address(0), details, flags);\n        return proposalCount - 1;\n    }","after":"function submitGuildKickProposal(address memberToKick, string calldata details) public nonReentrant returns (uint256 proposalId) {\n        Member memory member = members[memberToKick];\n\n        require(member.shares > 0 || member.loot > 0, \"member must have at least one share or one loot\");\n        require(members[memberToKick].jailed == 0, \"member must not already be jailed\");\n\n        bool[6] memory flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n        flags[5] = true; // guild kick\n\n        _submitProposal(memberToKick, 0, 0, 0, address(0), 0, address(0), details, flags);\n        return proposalCount - 1;\n    }","contract":"Moloch","time":0},{"type":"external-function ","before":"function withdrawBalances(address[] memory tokens, uint256[] memory amounts, bool max) public nonReentrant {\n        require(tokens.length == amounts.length, \"tokens and amounts arrays must be matching lengths\");\n\n        for (uint256 i=0; i < tokens.length; i++) {\n            uint256 withdrawAmount = amounts[i];\n            if (max) { // withdraw the maximum balance\n                withdrawAmount = userTokenBalances[msg.sender][tokens[i]];\n            }\n\n            _withdrawBalance(tokens[i], withdrawAmount);\n        }\n    }","after":"function withdrawBalances(address[] calldata tokens, uint256[] calldata amounts, bool max) public nonReentrant {\n        require(tokens.length == amounts.length, \"tokens and amounts arrays must be matching lengths\");\n\n        for (uint256 i=0; i < tokens.length; i++) {\n            uint256 withdrawAmount = amounts[i];\n            if (max) { // withdraw the maximum balance\n                withdrawAmount = userTokenBalances[msg.sender][tokens[i]];\n            }\n\n            _withdrawBalance(tokens[i], withdrawAmount);\n        }\n    }","contract":"Moloch","time":0},{"type":"external-function ","before":"function summonMoloch(\n        address[] memory _summoner,\n        address[] memory _approvedTokens,\n        uint256 _periodDuration,\n        uint256 _votingPeriodLength,\n        uint256 _gracePeriodLength,\n        uint256 _proposalDeposit,\n        uint256 _dilutionBound,\n        uint256 _processingReward,\n        uint256[] memory _summonerShares\n    ) public returns (address) {\n        Moloch moloch = Moloch(createClone(template));\n        \n        moloch.init(\n            _summoner,\n            _approvedTokens,\n            _periodDuration,\n            _votingPeriodLength,\n            _gracePeriodLength,\n            _proposalDeposit,\n            _dilutionBound,\n            _processingReward,\n            _summonerShares\n        );\n       \n        emit SummonComplete(address(moloch), _summoner, _approvedTokens, now, _periodDuration, _votingPeriodLength, _gracePeriodLength, _proposalDeposit, _dilutionBound, _processingReward, _summonerShares);\n        \n        return address(moloch);\n    }","after":"function summonMoloch(\n        address[] calldata _summoner,\n        address[] calldata _approvedTokens,\n        uint256 _periodDuration,\n        uint256 _votingPeriodLength,\n        uint256 _gracePeriodLength,\n        uint256 _proposalDeposit,\n        uint256 _dilutionBound,\n        uint256 _processingReward,\n        uint256[] calldata _summonerShares\n    ) public returns (address) {\n        Moloch moloch = Moloch(createClone(template));\n        \n        moloch.init(\n            _summoner,\n            _approvedTokens,\n            _periodDuration,\n            _votingPeriodLength,\n            _gracePeriodLength,\n            _proposalDeposit,\n            _dilutionBound,\n            _processingReward,\n            _summonerShares\n        );\n       \n        emit SummonComplete(address(moloch), _summoner, _approvedTokens, now, _periodDuration, _votingPeriodLength, _gracePeriodLength, _proposalDeposit, _dilutionBound, _processingReward, _summonerShares);\n        \n        return address(moloch);\n    }","contract":"MolochSummoner","time":0},{"type":"external-function ","before":"function registerDao(\n        address _daoAdress,\n        string memory _daoTitle,\n        string memory _http,\n        uint _version\n      ) public returns (bool) {\n          \n      moloch = Moloch(_daoAdress);\n      (,,,bool exists,,) = moloch.members(msg.sender);\n    \n      require(exists == true, \"must be a member\");\n      require(daos[_daoAdress] == false, \"dao metadata already registered\");\n\n      daos[_daoAdress] = true;\n      \n      daoIdx = daoIdx + 1;\n      emit Register(daoIdx, _daoAdress, _daoTitle, _http, _version);\n      return true;\n      \n    }","after":"function registerDao(\n        address _daoAdress,\n        string calldata _daoTitle,\n        string calldata _http,\n        uint _version\n      ) public returns (bool) {\n          \n      moloch = Moloch(_daoAdress);\n      (,,,bool exists,,) = moloch.members(msg.sender);\n    \n      require(exists == true, \"must be a member\");\n      require(daos[_daoAdress] == false, \"dao metadata already registered\");\n\n      daos[_daoAdress] = true;\n      \n      daoIdx = daoIdx + 1;\n      emit Register(daoIdx, _daoAdress, _daoTitle, _http, _version);\n      return true;\n      \n    }","contract":"MolochSummoner","time":0}]}