{"time":185,"results":[{"type":"state-data-arrangement ","before":"\nbytes4 internal constant ERC1155_RECEIVED_VALUE = 0xf23a6e61;\nbytes4 internal constant ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\nmapping(address => mapping(uint256 => uint256)) internal balances;\nmapping(address => mapping(address => bool)) internal operators;\nbytes4 private constant INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\nbytes4 private constant INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;","after":"mapping(address => mapping(uint256 => uint256)) internal balances;\nmapping(address => mapping(address => bool)) internal operators;\nbytes4 internal constant ERC1155_RECEIVED_VALUE = 0xf23a6e61;\nbytes4 internal constant ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\nbytes4 private constant INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\nbytes4 private constant INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\n","contract":"ERC1155","time":0},{"type":"external-function ","before":"function upgradeToAndCall(address implementation, bytes memory data) public payable onlyProxyOwner {\n    upgradeTo(implementation);\n    (bool result, ) = address(this).delegatecall(data);\n    require(result);\n  }","after":"function upgradeToAndCall(address implementation, bytes calldata data) public payable onlyProxyOwner {\n    upgradeTo(implementation);\n    (bool result, ) = address(this).delegatecall(data);\n    require(result);\n  }","contract":"OwnableDelegateProxy","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public DELAY_PERIOD = 2 weeks;","after":"uint256 public constant DELAY_PERIOD = 2 weeks;","contract":"ProxyRegistry","time":0},{"type":"external-function ","before":"function setBaseMetadataURI(string memory _newBaseMetadataURI) public onlyWhitelistAdmin {\n    _setBaseMetadataURI(_newBaseMetadataURI);\n  }","after":"function setBaseMetadataURI(string calldata _newBaseMetadataURI) public onlyWhitelistAdmin {\n    _setBaseMetadataURI(_newBaseMetadataURI);\n  }","contract":"EddaNft","time":0},{"type":"external-function ","before":"function mint(\n    address _to,\n    uint256 _id,\n    uint256 _quantity,\n    bytes memory _data\n  ) public onlyMinter {\n    uint256 tokenId = _id;\n    require(tokenSupply[tokenId].add(_quantity) <= tokenMaxSupply[tokenId], \"Max supply reached\");\n    _mint(_to, _id, _quantity, _data);\n    tokenSupply[_id] = tokenSupply[_id].add(_quantity);\n  }","after":"function mint(\n    address _to,\n    uint256 _id,\n    uint256 _quantity,\n    bytes calldata _data\n  ) public onlyMinter {\n    uint256 tokenId = _id;\n    require(tokenSupply[tokenId].add(_quantity) <= tokenMaxSupply[tokenId], \"Max supply reached\");\n    _mint(_to, _id, _quantity, _data);\n    tokenSupply[_id] = tokenSupply[_id].add(_quantity);\n  }","contract":"EddaNft","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _id,\n    uint256 _amount,\n    bytes memory _data\n  ) public {\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \"ERC1155#safeTransferFrom: INVALID_OPERATOR\");\n    require(_to != address(0), \"ERC1155#safeTransferFrom: INVALID_RECIPIENT\");\n    // require(_amount >= balances[_from][_id]) is not necessary since checked with safemath operations\n\n    _safeTransferFrom(_from, _to, _id, _amount);\n    _callonERC1155Received(_from, _to, _id, _amount, _data);\n  }","after":"function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _id,\n    uint256 _amount,\n    bytes calldata _data\n  ) public {\n    require((msg.sender == _from) || isApprovedForAll(_from, msg.sender), \"ERC1155#safeTransferFrom: INVALID_OPERATOR\");\n    require(_to != address(0), \"ERC1155#safeTransferFrom: INVALID_RECIPIENT\");\n    // require(_amount >= balances[_from][_id]) is not necessary since checked with safemath operations\n\n    _safeTransferFrom(_from, _to, _id, _amount);\n    _callonERC1155Received(_from, _to, _id, _amount, _data);\n  }","contract":"EddaNft","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n    address _from,\n    address _to,\n    uint256[] memory _ids,\n    uint256[] memory _amounts,\n    bytes memory _data\n  ) public {\n    // Requirements\n    require(\n      (msg.sender == _from) || isApprovedForAll(_from, msg.sender),\n      \"ERC1155#safeBatchTransferFrom: INVALID_OPERATOR\"\n    );\n    require(_to != address(0), \"ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT\");\n\n    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n    _callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\n  }","after":"function safeBatchTransferFrom(\n    address _from,\n    address _to,\n    uint256[] calldata _ids,\n    uint256[] calldata _amounts,\n    bytes calldata _data\n  ) public {\n    // Requirements\n    require(\n      (msg.sender == _from) || isApprovedForAll(_from, msg.sender),\n      \"ERC1155#safeBatchTransferFrom: INVALID_OPERATOR\"\n    );\n    require(_to != address(0), \"ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT\");\n\n    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n    _callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\n  }","contract":"EddaNft","time":0},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"EddaNft","time":1}]}