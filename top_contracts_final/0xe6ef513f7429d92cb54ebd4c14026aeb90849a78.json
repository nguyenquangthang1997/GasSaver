{"time":258,"results":[{"type":"external-function ","before":"   function addToPresaleWhitelist(uint256 _tierId, address[] memory _addresses)\n        external\n        onlyOwner\n    {\n        Tier memory tier = allTiers[_tierId];\n\n        require(tier.id == _tierId, \"Invalid tier\");\n\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            address _address = _addresses[i];\n\n            uint256[] storage tierIds = presaleWhitelist[_address];\n\n            bool exists = false;\n            for (uint256 j = 0; j < tierIds.length; j++) {\n                if (tierIds[j] == tier.id) {\n                    exists = true;\n                }\n            }\n\n            if (!exists) {\n                tierIds.push(tier.id);\n            }\n\n            presaleWhitelist[_address] = tierIds;\n        }\n  ","after":"   function addToPresaleWhitelist(uint256 _tierId, address[] calldata _addresses)\n        external\n        onlyOwner\n    {\n        Tier memory tier = allTiers[_tierId];\n\n        require(tier.id == _tierId, \"Invalid tier\");\n\n        for (uint256 i = 0; i < _addresses.length; i++) {\n            address _address = _addresses[i];\n\n            uint256[] storage tierIds = presaleWhitelist[_address];\n\n            bool exists = false;\n            for (uint256 j = 0; j < tierIds.length; j++) {\n                if (tierIds[j] == tier.id) {\n                    exists = true;\n                }\n            }\n\n            if (!exists) {\n                tierIds.push(tier.id);\n            }\n\n            presaleWhitelist[_address] = tierIds;\n        }\n  ","contract":"ImpactTheoryFoundersKey","time":0},{"type":"external-function ","before":"   function mint(\n        uint256 _tierId,\n        uint256 _amount,\n        bytes32 _hash,\n        bytes memory _signature,\n        string memory _nonce\n    ) public payable whenOwnerOrPublicSaleActive {\n        require(\n            matchAddressSigner(_hash, _signature),\n            \"Direct mint disallowed\"\n        );\n        require(!usedNonces[_nonce], \"Hash already used\");\n        require(\n            hashTransaction(_msgSender(), _amount, _nonce) == _hash,\n            \"Hash failed\"\n        );\n\n        Tier memory tier = allTiers[_tierId];\n        TierInfo memory tierInfo = allTiersInfo[_tierId];\n\n        require(tier.id == _tierId, \"Invalid tier\");\n\n        // Must mint at least one\n        require(_amount > 0, \"Must mint at least one\");\n\n        // Check there enough mints left for tier\n        require(\n            getMintsLeft(tier.id).sub(_amount) >= 0,\n            \"Minting would exceed max supply\"\n        );\n\n        // Get current address total balance\n        uint256 currentTotalAmount = super.balanceOf(_msgSender());\n\n        // Loop over all tokens for address and get current tier count\n        uint256 currentTierAmount = 0;\n        for (uint256 i = 0; i < currentTotalAmount; i++) {\n            uint256 tokenId = super.tokenOfOwnerByIndex(_msgSender(), i);\n            Tier memory _tokenTier = tokenTier[tokenId];\n            if (_tokenTier.id == tier.id) {\n                currentTierAmount++;\n            }\n        }\n\n        uint256 costToMint = 0;\n        uint256 amount = _amount;\n\n        // Is owner\n        bool isOwner = owner() == _msgSender();\n\n        // If not owner, check amounts are not more than max amounts\n        if (!isOwner) {\n            // Get elapsed sale time\n            uint256 elapsed = getElapsedSaleTime();\n\n            // Time logic based on tier and constants\n            uint256 closedPresaleStart = (tier.id - 1).mul(\n                DURATION_BETWEEN_TIERS\n            );\n            uint256 closedPresaleEnd = closedPresaleStart.add(\n                CLOSED_PRESALE_DURATION\n            );\n\n            // If still in the closed whitelist, do not allow more than max per closed presale\n            if (elapsed <= closedPresaleEnd) {\n                require(\n                    currentTierAmount.add(amount) <= tierInfo.maxPerClosedPresale,\n                    \"Requested amount exceeds maximum whitelist mint amount\"\n                );\n            }\n\n            // Do not allow more than max total mint\n            require(\n                currentTierAmount.add(amount) <= tierInfo.maxTotalMint,\n                \"Requested amount exceeds maximum total mint amount\"\n            );\n        }\n\n        // Get cost to mint\n        costToMint = getMintPrice(tier.id).mul(amount);\n\n        // Check cost to mint for tier, and if enough ETH is passed to mint\n        require(costToMint <= msg.value, \"ETH amount sent is not correct\");\n\n        for (uint256 i = 0; i < amount; i++) {\n            // Token id is tier starting offset plus count of already minted\n            uint256 tokenId = tierInfo.startingOffset.add(tierCounts[tier.id]);\n\n            // Safe mint\n            _safeMint(_msgSender(), tokenId);\n\n            // Attribute token id with tier\n            tokenTier[tokenId] = tier;\n\n            // Store minted at timestamp by token id\n            tokenMintedAt[tokenId] = block.timestamp;\n\n            // Increment tier counter\n            tierCounts[tier.id] = tierCounts[tier.id].add(1);\n        }\n\n        usedNonces[_nonce] = true;\n\n        // Send mint cost to payment address\n        Address.sendValue(payable(paymentAddress), costToMint);\n\n        // Return unused value\n        if (msg.value > costToMint) {\n            Address.sendValue(payable(_msgSender()), msg.value.sub(costToMint));\n        }\n  ","after":"   function mint(\n        uint256 _tierId,\n        uint256 _amount,\n        bytes32 _hash,\n        bytes calldata _signature,\n        string calldata _nonce\n    ) public payable whenOwnerOrPublicSaleActive {\n        require(\n            matchAddressSigner(_hash, _signature),\n            \"Direct mint disallowed\"\n        );\n        require(!usedNonces[_nonce], \"Hash already used\");\n        require(\n            hashTransaction(_msgSender(), _amount, _nonce) == _hash,\n            \"Hash failed\"\n        );\n\n        Tier memory tier = allTiers[_tierId];\n        TierInfo memory tierInfo = allTiersInfo[_tierId];\n\n        require(tier.id == _tierId, \"Invalid tier\");\n\n        // Must mint at least one\n        require(_amount > 0, \"Must mint at least one\");\n\n        // Check there enough mints left for tier\n        require(\n            getMintsLeft(tier.id).sub(_amount) >= 0,\n            \"Minting would exceed max supply\"\n        );\n\n        // Get current address total balance\n        uint256 currentTotalAmount = super.balanceOf(_msgSender());\n\n        // Loop over all tokens for address and get current tier count\n        uint256 currentTierAmount = 0;\n        for (uint256 i = 0; i < currentTotalAmount; i++) {\n            uint256 tokenId = super.tokenOfOwnerByIndex(_msgSender(), i);\n            Tier memory _tokenTier = tokenTier[tokenId];\n            if (_tokenTier.id == tier.id) {\n                currentTierAmount++;\n            }\n        }\n\n        uint256 costToMint = 0;\n        uint256 amount = _amount;\n\n        // Is owner\n        bool isOwner = owner() == _msgSender();\n\n        // If not owner, check amounts are not more than max amounts\n        if (!isOwner) {\n            // Get elapsed sale time\n            uint256 elapsed = getElapsedSaleTime();\n\n            // Time logic based on tier and constants\n            uint256 closedPresaleStart = (tier.id - 1).mul(\n                DURATION_BETWEEN_TIERS\n            );\n            uint256 closedPresaleEnd = closedPresaleStart.add(\n                CLOSED_PRESALE_DURATION\n            );\n\n            // If still in the closed whitelist, do not allow more than max per closed presale\n            if (elapsed <= closedPresaleEnd) {\n                require(\n                    currentTierAmount.add(amount) <= tierInfo.maxPerClosedPresale,\n                    \"Requested amount exceeds maximum whitelist mint amount\"\n                );\n            }\n\n            // Do not allow more than max total mint\n            require(\n                currentTierAmount.add(amount) <= tierInfo.maxTotalMint,\n                \"Requested amount exceeds maximum total mint amount\"\n            );\n        }\n\n        // Get cost to mint\n        costToMint = getMintPrice(tier.id).mul(amount);\n\n        // Check cost to mint for tier, and if enough ETH is passed to mint\n        require(costToMint <= msg.value, \"ETH amount sent is not correct\");\n\n        for (uint256 i = 0; i < amount; i++) {\n            // Token id is tier starting offset plus count of already minted\n            uint256 tokenId = tierInfo.startingOffset.add(tierCounts[tier.id]);\n\n            // Safe mint\n            _safeMint(_msgSender(), tokenId);\n\n            // Attribute token id with tier\n            tokenTier[tokenId] = tier;\n\n            // Store minted at timestamp by token id\n            tokenMintedAt[tokenId] = block.timestamp;\n\n            // Increment tier counter\n            tierCounts[tier.id] = tierCounts[tier.id].add(1);\n        }\n\n        usedNonces[_nonce] = true;\n\n        // Send mint cost to payment address\n        Address.sendValue(payable(paymentAddress), costToMint);\n\n        // Return unused value\n        if (msg.value > costToMint) {\n            Address.sendValue(payable(_msgSender()), msg.value.sub(costToMint));\n        }\n  ","contract":"ImpactTheoryFoundersKey","time":0},{"type":"external-function ","before":"   function burnMultiple(uint256[] memory _tokenIds) public onlyOwner {\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            // Token id\n            uint256 tokenId = _tokenIds[i];\n\n            _burn(tokenId);\n        }\n  ","after":"   function burnMultiple(uint256[] calldata _tokenIds) public onlyOwner {\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\n            // Token id\n            uint256 tokenId = _tokenIds[i];\n\n            _burn(tokenId);\n        }\n  ","contract":"ImpactTheoryFoundersKey","time":0},{"type":"external-function ","before":"   function setBaseURI(string memory _uri) public onlyOwner {\n        baseTokenURI = _uri;\n  ","after":"   function setBaseURI(string calldata _uri) public onlyOwner {\n        baseTokenURI = _uri;\n  ","contract":"ImpactTheoryFoundersKey","time":0},{"type":"external-function ","before":"   function setBaseURIForMetadata(string memory _uri) public onlyOwner {\n        baseTokenURIForMetadata = _uri;\n  ","after":"   function setBaseURIForMetadata(string calldata _uri) public onlyOwner {\n        baseTokenURIForMetadata = _uri;\n  ","contract":"ImpactTheoryFoundersKey","time":0}]}