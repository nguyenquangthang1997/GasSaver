{"time":1064,"results":[{"type":"external-function ","before":"function setPlaceholderImageURL(string memory newPlaceholderImageURL) public onlyOwner\n    {\n        placeholderImageURL = newPlaceholderImageURL;\n    }","after":"function setPlaceholderImageURL(string calldata newPlaceholderImageURL) public onlyOwner\n    {\n        placeholderImageURL = newPlaceholderImageURL;\n    }","contract":"ExampleRelicMinter","time":0},{"type":"external-function ","before":"function setImageBaseURL(string memory newImageBaseURL) public onlyOwner\n    {\n        imageBaseURL = newImageBaseURL;\n    }","after":"function setImageBaseURL(string calldata newImageBaseURL) public onlyOwner\n    {\n        imageBaseURL = newImageBaseURL;\n    }","contract":"ExampleRelicMinter","time":0},{"type":"immutable-restrict-modification ","before":"uint256 private _minTokenId;","after":"uint256 private immutable _minTokenId;","contract":"ExampleRelicMinter","time":0},{"type":"immutable-restrict-modification ","before":"uint256 private _maxTokenId;","after":"uint256 private immutable _maxTokenId;","contract":"ExampleRelicMinter","time":0},{"type":"external-function ","before":"function init(\n        string memory name,\n        string memory symbol,\n        address proxyRegistryAddress,\n        string memory placeholderImageURL,\n        string memory animationBaseURL,\n        string memory collectionName,\n        string memory collectionDesc,\n        string memory collectionImgURL,\n        string memory collectionExtURL,\n        uint256 feeBasisPoints,\n        address feeRecipient)\n        public onlyOwner initializer\n    {\n        _initializeEIP712(name);\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name, symbol);\n        __ERC721TradableUpgradeable_init_unchained(proxyRegistryAddress);\n\n        _placeholderImageURL = placeholderImageURL;\n        _animationBaseURL = animationBaseURL;\n        _collectionName = collectionName;\n        _collectionDesc = collectionDesc;\n        _collectionImgURL = collectionImgURL;\n        _collectionExtURL = collectionExtURL;\n        _feeBasisPoints = feeBasisPoints;\n        _feeRecipient = feeRecipient;\n    }","after":"function init(\n        string calldata name,\n        string calldata symbol,\n        address proxyRegistryAddress,\n        string calldata placeholderImageURL,\n        string calldata animationBaseURL,\n        string calldata collectionName,\n        string calldata collectionDesc,\n        string calldata collectionImgURL,\n        string calldata collectionExtURL,\n        uint256 feeBasisPoints,\n        address feeRecipient)\n        public onlyOwner initializer\n    {\n        _initializeEIP712(name);\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name, symbol);\n        __ERC721TradableUpgradeable_init_unchained(proxyRegistryAddress);\n\n        _placeholderImageURL = placeholderImageURL;\n        _animationBaseURL = animationBaseURL;\n        _collectionName = collectionName;\n        _collectionDesc = collectionDesc;\n        _collectionImgURL = collectionImgURL;\n        _collectionExtURL = collectionExtURL;\n        _feeBasisPoints = feeBasisPoints;\n        _feeRecipient = feeRecipient;\n    }","contract":"Relic","time":0},{"type":"external-function ","before":"function setPlaceholderImageURL(string memory placeholderImageURL) public onlyOwner\n    {\n        _placeholderImageURL = placeholderImageURL;\n    }","after":"function setPlaceholderImageURL(string calldata placeholderImageURL) public onlyOwner\n    {\n        _placeholderImageURL = placeholderImageURL;\n    }","contract":"Relic","time":0},{"type":"external-function ","before":"function setAnimationBaseURL(string memory animationBaseURL) public onlyOwner\n    {\n        _animationBaseURL = animationBaseURL;\n    }","after":"function setAnimationBaseURL(string calldata animationBaseURL) public onlyOwner\n    {\n        _animationBaseURL = animationBaseURL;\n    }","contract":"Relic","time":0},{"type":"external-function ","before":"function setCollectionName(string memory collectionName) public onlyOwner\n    {\n        _collectionName = collectionName;\n    }","after":"function setCollectionName(string calldata collectionName) public onlyOwner\n    {\n        _collectionName = collectionName;\n    }","contract":"Relic","time":0},{"type":"external-function ","before":"function setCollectionDesc(string memory collectionDesc) public onlyOwner\n    {\n        _collectionDesc = collectionDesc;\n    }","after":"function setCollectionDesc(string calldata collectionDesc) public onlyOwner\n    {\n        _collectionDesc = collectionDesc;\n    }","contract":"Relic","time":0},{"type":"external-function ","before":"function setCollectionImgURL(string memory collectionImgURL) public onlyOwner\n    {\n        _collectionImgURL = collectionImgURL;\n    }","after":"function setCollectionImgURL(string calldata collectionImgURL) public onlyOwner\n    {\n        _collectionImgURL = collectionImgURL;\n    }","contract":"Relic","time":0},{"type":"external-function ","before":"function setCollectionExtURL(string memory collectionExtURL) public onlyOwner\n    {\n        _collectionExtURL = collectionExtURL;\n    }","after":"function setCollectionExtURL(string calldata collectionExtURL) public onlyOwner\n    {\n        _collectionExtURL = collectionExtURL;\n    }","contract":"Relic","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"Relic","time":0},{"type":"constant-restrict-modification  ","before":"uint256 private _currentTokenId = 0;","after":"uint256 private constant _currentTokenId = 0;","contract":"Relic","time":1},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"ERC721Tradable","time":0},{"type":"immutable-restrict-modification ","before":"address _proxyRegistry;","after":"address immutable _proxyRegistry;","contract":"ERC721Tradable","time":0},{"type":"external-function ","before":"function claimRewards(uint256[] memory tokenIds) public\n    {\n        uint256 dungeonCount = _dungeons.length;\n        Loot loot = _loot;\n        Relic relic = _relic;\n\n        for (uint256 i = 0; i < tokenIds.length; ++i)\n        {\n            (uint256 dungeonId, uint256 rewardFirstId, uint256 rewardCount) = \n                _getRewardsForToken(loot, dungeonCount, tokenIds[i]);\n\n            bytes12 data = bytes12(uint96(dungeonId & 0xffffffffffffffffffffffff));\n\n            for (uint256 j = 0; j < rewardCount; ++j)\n            {\n                relic.mint(msg.sender, rewardFirstId + j, data);\n            }\n        }\n    }","after":"function claimRewards(uint256[] calldata tokenIds) public\n    {\n        uint256 dungeonCount = _dungeons.length;\n        Loot loot = _loot;\n        Relic relic = _relic;\n\n        for (uint256 i = 0; i < tokenIds.length; ++i)\n        {\n            (uint256 dungeonId, uint256 rewardFirstId, uint256 rewardCount) = \n                _getRewardsForToken(loot, dungeonCount, tokenIds[i]);\n\n            bytes12 data = bytes12(uint96(dungeonId & 0xffffffffffffffffffffffff));\n\n            for (uint256 j = 0; j < rewardCount; ++j)\n            {\n                relic.mint(msg.sender, rewardFirstId + j, data);\n            }\n        }\n    }","contract":"Dungeon","time":0},{"type":"external-function ","before":"function setImageBaseURL(string memory newImageBaseURL) public onlyOwner\n    {\n        imageBaseURL = newImageBaseURL;\n    }","after":"function setImageBaseURL(string calldata newImageBaseURL) public onlyOwner\n    {\n        imageBaseURL = newImageBaseURL;\n    }","contract":"Dungeon","time":0}]}