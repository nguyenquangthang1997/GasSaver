{"time":132,"results":[{"type":"external-function ","before":"function mintPresale(bytes32[] memory _proof, bytes1 _maxAmountKey, uint256 _mintAmount) public payable reentryLock {\n    require(MerkleRoot > 0x00, \"claim period not started!\");\n    uint256 supply = totalSupply();\n    require(supply + _mintAmount < maxSupply + 1, \"max collection limit exceeded\");\n\t\n\tbytes32 senderHash = keccak256(abi.encodePacked(msg.sender, _maxAmountKey));\n    bool proven = MerkleProof.verify(_proof, MerkleRoot, senderHash);\n\trequire(proven, \"unauthorized proof-key combo for sender\");\n\t\n\tuint _maxAmount = uint8(_maxAmountKey);\n\tif(msg.value == 0) {\n\t\t// FREE MINT REQUEST\n\t\trequire(ownerMintCount[msg.sender].freeClaims + _mintAmount < _maxAmount + 1, \"max free NFT claims exceeded\");\n\t\townerMintCount[msg.sender].freeClaims += uint128(_mintAmount);\n\t} else {\n\t\t// PRE-SALE\n\t\trequire(ownerMintCount[msg.sender].presaleMinted + _mintAmount < maxPresaleAmount + 1, \"max NFT pre-sales exceeded\");\n\t\trequire(msg.value >= _mintAmount * cost, \"not enought ETH sent\");\n\t\townerMintCount[msg.sender].presaleMinted += uint128(_mintAmount);\n\t}\n\t\n    for (uint256 i = 0; i < _mintAmount; i++) {\n      _safeMint(msg.sender, supply + i);\n    }\n  }","after":"function mintPresale(bytes32[] calldata _proof, bytes1 _maxAmountKey, uint256 _mintAmount) public payable reentryLock {\n    require(MerkleRoot > 0x00, \"claim period not started!\");\n    uint256 supply = totalSupply();\n    require(supply + _mintAmount < maxSupply + 1, \"max collection limit exceeded\");\n\t\n\tbytes32 senderHash = keccak256(abi.encodePacked(msg.sender, _maxAmountKey));\n    bool proven = MerkleProof.verify(_proof, MerkleRoot, senderHash);\n\trequire(proven, \"unauthorized proof-key combo for sender\");\n\t\n\tuint _maxAmount = uint8(_maxAmountKey);\n\tif(msg.value == 0) {\n\t\t// FREE MINT REQUEST\n\t\trequire(ownerMintCount[msg.sender].freeClaims + _mintAmount < _maxAmount + 1, \"max free NFT claims exceeded\");\n\t\townerMintCount[msg.sender].freeClaims += uint128(_mintAmount);\n\t} else {\n\t\t// PRE-SALE\n\t\trequire(ownerMintCount[msg.sender].presaleMinted + _mintAmount < maxPresaleAmount + 1, \"max NFT pre-sales exceeded\");\n\t\trequire(msg.value >= _mintAmount * cost, \"not enought ETH sent\");\n\t\townerMintCount[msg.sender].presaleMinted += uint128(_mintAmount);\n\t}\n\t\n    for (uint256 i = 0; i < _mintAmount; i++) {\n      _safeMint(msg.sender, supply + i);\n    }\n  }","contract":"StreetMeltsSociety","time":0},{"type":"external-function ","before":"function setBaseExtension(string memory _newBaseExtension) public onlyOwner {\n    baseExtension = _newBaseExtension;\n  }","after":"function setBaseExtension(string calldata _newBaseExtension) public onlyOwner {\n    baseExtension = _newBaseExtension;\n  }","contract":"StreetMeltsSociety","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public maxPresaleAmount = 3;","after":"uint256 public constant maxPresaleAmount = 3;","contract":"StreetMeltsSociety","time":0}]}