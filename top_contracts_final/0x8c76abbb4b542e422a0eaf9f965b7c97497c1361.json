{"time":734,"results":[{"type":"loop-duplication","before":"\nstart line 304 column 8, end line 306 column 8\nfor (uint i=0; i< mpIndexs.length; i++) {\n           require(isValidClaim(numPasses[i],amounts[i],mpIndexs[i],merkleProofs[i]), \"One or more claims are invalid\");\n        }\nstart line 308 column 8, end line 310 column 8\nfor (uint i=0; i< mpIndexs.length; i++) {\n            mintPasses[mpIndexs[i]].claimedMPs[msg.sender] = mintPasses[mpIndexs[i]].claimedMPs[msg.sender].add(numPasses[i]);\n        }","after":"// merge loop\n\nstart line 304 column 8, end line 306 column 8\nfor (uint i=0; i< mpIndexs.length; i++) {\n           require(isValidClaim(numPasses[i],amounts[i],mpIndexs[i],merkleProofs[i]), \"One or more claims are invalid\");\n        }\nstart line 308 column 8, end line 310 column 8\nfor (uint i=0; i< mpIndexs.length; i++) {\n            mintPasses[mpIndexs[i]].claimedMPs[msg.sender] = mintPasses[mpIndexs[i]].claimedMPs[msg.sender].add(numPasses[i]);\n        }","contract":"CollectibleMintPassFactory","time":0},{"type":"struct-data-arrangement ","before":"\nbytes32 merkleRoot\nbool saleIsOpen\nuint256 windowOpens\nuint256 windowCloses\nuint256 mintPrice\nuint256 maxSupply\nuint256 maxPerWallet\nuint256 maxMintPerTxn\nstring ipfsMetadataHash\naddress redeemableContract\nmapping(address => uint256) claimedMPs","after":"bytes32 merkleRoot\nuint256 windowOpens\nuint256 windowCloses\nuint256 mintPrice\nuint256 maxSupply\nuint256 maxPerWallet\nuint256 maxMintPerTxn\nstring ipfsMetadataHash\nmapping(address => uint256) claimedMPs\naddress redeemableContract\nbool saleIsOpen\n","contract":"CollectibleMintPassFactory","time":1},{"type":"external-function ","before":"function addMintPass(\n        bytes32 _merkleRoot, \n        uint256 _windowOpens, \n        uint256 _windowCloses, \n        uint256 _mintPrice, \n        uint256 _maxSupply,\n        uint256 _maxMintPerTxn,\n        string memory _ipfsMetadataHash,\n        address _redeemableContract,\n        uint256 _maxPerWallet\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_windowOpens < _windowCloses, \"addMintPass: open window must be before close window\");\n        require(_windowOpens > 0 && _windowCloses > 0, \"addMintPass: window cannot be 0\");\n\n\n        MintPass storage mp = mintPasses[mpCounter.current()];\n        mp.saleIsOpen = false;\n        mp.merkleRoot = _merkleRoot;\n        mp.windowOpens = _windowOpens;\n        mp.windowCloses = _windowCloses;\n        mp.mintPrice = _mintPrice;\n        mp.maxSupply = _maxSupply;\n        mp.maxMintPerTxn = _maxMintPerTxn;\n        mp.maxPerWallet = _maxPerWallet;\n        mp.ipfsMetadataHash = _ipfsMetadataHash;\n        mp.redeemableContract = _redeemableContract;\n        mpCounter.increment();\n\n    }","after":"function addMintPass(\n        bytes32 _merkleRoot, \n        uint256 _windowOpens, \n        uint256 _windowCloses, \n        uint256 _mintPrice, \n        uint256 _maxSupply,\n        uint256 _maxMintPerTxn,\n        string calldata _ipfsMetadataHash,\n        address _redeemableContract,\n        uint256 _maxPerWallet\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_windowOpens < _windowCloses, \"addMintPass: open window must be before close window\");\n        require(_windowOpens > 0 && _windowCloses > 0, \"addMintPass: window cannot be 0\");\n\n\n        MintPass storage mp = mintPasses[mpCounter.current()];\n        mp.saleIsOpen = false;\n        mp.merkleRoot = _merkleRoot;\n        mp.windowOpens = _windowOpens;\n        mp.windowCloses = _windowCloses;\n        mp.mintPrice = _mintPrice;\n        mp.maxSupply = _maxSupply;\n        mp.maxMintPerTxn = _maxMintPerTxn;\n        mp.maxPerWallet = _maxPerWallet;\n        mp.ipfsMetadataHash = _ipfsMetadataHash;\n        mp.redeemableContract = _redeemableContract;\n        mpCounter.increment();\n\n    }","contract":"CollectibleMintPassFactory","time":0},{"type":"external-function ","before":"function editMintPass(\n        bytes32 _merkleRoot, \n        uint256 _windowOpens, \n        uint256 _windowCloses, \n        uint256 _mintPrice, \n        uint256 _maxSupply,\n        uint256 _maxMintPerTxn,\n        string memory _ipfsMetadataHash,        \n        address _redeemableContract, \n        uint256 _mpIndex,\n        bool _saleIsOpen,\n        uint256 _maxPerWallet\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_windowOpens < _windowCloses, \"editMintPass: open window must be before close window\");\n        require(_windowOpens > 0 && _windowCloses > 0, \"editMintPass: window cannot be 0\");\n\n        \n        mintPasses[_mpIndex].merkleRoot = _merkleRoot;\n        mintPasses[_mpIndex].windowOpens = _windowOpens;\n        mintPasses[_mpIndex].windowCloses = _windowCloses;\n        mintPasses[_mpIndex].mintPrice = _mintPrice;  \n        mintPasses[_mpIndex].maxSupply = _maxSupply;    \n        mintPasses[_mpIndex].maxMintPerTxn = _maxMintPerTxn; \n        mintPasses[_mpIndex].ipfsMetadataHash = _ipfsMetadataHash;    \n        mintPasses[_mpIndex].redeemableContract = _redeemableContract;\n        mintPasses[_mpIndex].saleIsOpen = _saleIsOpen; \n        mintPasses[_mpIndex].maxPerWallet = _maxPerWallet; \n    }","after":"function editMintPass(\n        bytes32 _merkleRoot, \n        uint256 _windowOpens, \n        uint256 _windowCloses, \n        uint256 _mintPrice, \n        uint256 _maxSupply,\n        uint256 _maxMintPerTxn,\n        string calldata _ipfsMetadataHash,        \n        address _redeemableContract, \n        uint256 _mpIndex,\n        bool _saleIsOpen,\n        uint256 _maxPerWallet\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        require(_windowOpens < _windowCloses, \"editMintPass: open window must be before close window\");\n        require(_windowOpens > 0 && _windowCloses > 0, \"editMintPass: window cannot be 0\");\n\n        \n        mintPasses[_mpIndex].merkleRoot = _merkleRoot;\n        mintPasses[_mpIndex].windowOpens = _windowOpens;\n        mintPasses[_mpIndex].windowCloses = _windowCloses;\n        mintPasses[_mpIndex].mintPrice = _mintPrice;  \n        mintPasses[_mpIndex].maxSupply = _maxSupply;    \n        mintPasses[_mpIndex].maxMintPerTxn = _maxMintPerTxn; \n        mintPasses[_mpIndex].ipfsMetadataHash = _ipfsMetadataHash;    \n        mintPasses[_mpIndex].redeemableContract = _redeemableContract;\n        mintPasses[_mpIndex].saleIsOpen = _saleIsOpen; \n        mintPasses[_mpIndex].maxPerWallet = _maxPerWallet; \n    }","contract":"CollectibleMintPassFactory","time":0},{"type":"external-function ","before":"function editTokenIPFSMetaDataHash(\n        string memory _ipfsMetadataHash, \n        uint256 _mpIndex\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        mintPasses[_mpIndex].ipfsMetadataHash = _ipfsMetadataHash;\n    }","after":"function editTokenIPFSMetaDataHash(\n        string calldata _ipfsMetadataHash, \n        uint256 _mpIndex\n    ) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        mintPasses[_mpIndex].ipfsMetadataHash = _ipfsMetadataHash;\n    }","contract":"CollectibleMintPassFactory","time":0},{"type":"external-function ","before":"function setContractURI(string memory uri) external onlyRole(DEFAULT_ADMIN_ROLE){\n        _contractURI = uri;\n    }","after":"function setContractURI(string calldata uri) external onlyRole(DEFAULT_ADMIN_ROLE){\n        _contractURI = uri;\n    }","contract":"CollectibleMintPassFactory","time":0},{"type":"external-function ","before":"function setURI(string memory baseURI) external onlyOwner {\n        _setURI(baseURI);\n    }","after":"function setURI(string calldata baseURI) external onlyOwner {\n        _setURI(baseURI);\n    }","contract":"CollectibleMintPassFactory","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"CollectibleMintPassFactory","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"CollectibleMintPassFactory","time":0},{"type":"external-function ","before":"function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }","after":"function burnBatch(\n        address account,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }","contract":"CollectibleMintPassFactory","time":0}]}