{"time":172,"results":[{"type":"external-function ","before":"function setURIs(\n        string memory _blindURI, \n        string memory _URI\n    ) \n        external \n        onlyOwner \n    {\n        blindURI = _blindURI;\n        baseURI = _URI;\n    }","after":"function setURIs(\n        string calldata _blindURI, \n        string calldata _URI\n    ) \n        external \n        onlyOwner \n    {\n        blindURI = _blindURI;\n        baseURI = _URI;\n    }","contract":"MGDC","time":0},{"type":"external-function ","before":"function mintNFTDuringPresale(\n        uint256 _numOfTokens,\n        bytes32[] memory _proof\n    ) \n        public \n        payable\n    {\n        require(isActive, 'Sale is not active');\n        require(isPresaleActive, 'Whitelist is not active');\n        require(verify(_proof, bytes32(uint256(uint160(msg.sender)))), \"Not whitelisted\");\n        if (!freeMintActive){\n            require(totalSupply() < MAX_NFT_PUBLIC, 'All public tokens have been minted');\n            require(_numOfTokens <= WHITELIST_MAX_MINT, 'Cannot purchase this many tokens');\n            require(totalSupply().add(_numOfTokens).sub(giveawayCount) <= MAX_NFT_PUBLIC, 'Purchase would exceed max public supply of NFTs');\n            require(whiteListClaimed[msg.sender].add(_numOfTokens) <= WHITELIST_MAX_MINT, 'Purchase exceeds max whiteed');\n            require(NFTPrice.mul(_numOfTokens) == msg.value, \"Ether value sent is not correct\");\n            for (uint256 i = 0; i < _numOfTokens; i++) {\n                    whiteListClaimed[msg.sender] += 1;\n                    _safeMint(msg.sender, totalSupply().sub(giveawayCount));\n            }\n        }\n        else{\n            require(totalSupply() < MAX_NFT, 'All tokens have been minted');\n            require(_numOfTokens == 1, 'Cannot purchase this many tokens');\n            require(!giveawayMintClaimed[msg.sender], 'Already claimed giveaway');\n            giveawayMintClaimed[msg.sender] = true;\n            _safeMint(msg.sender, totalSupply());\n        }\n    }","after":"function mintNFTDuringPresale(\n        uint256 _numOfTokens,\n        bytes32[] calldata _proof\n    ) \n        public \n        payable\n    {\n        require(isActive, 'Sale is not active');\n        require(isPresaleActive, 'Whitelist is not active');\n        require(verify(_proof, bytes32(uint256(uint160(msg.sender)))), \"Not whitelisted\");\n        if (!freeMintActive){\n            require(totalSupply() < MAX_NFT_PUBLIC, 'All public tokens have been minted');\n            require(_numOfTokens <= WHITELIST_MAX_MINT, 'Cannot purchase this many tokens');\n            require(totalSupply().add(_numOfTokens).sub(giveawayCount) <= MAX_NFT_PUBLIC, 'Purchase would exceed max public supply of NFTs');\n            require(whiteListClaimed[msg.sender].add(_numOfTokens) <= WHITELIST_MAX_MINT, 'Purchase exceeds max whiteed');\n            require(NFTPrice.mul(_numOfTokens) == msg.value, \"Ether value sent is not correct\");\n            for (uint256 i = 0; i < _numOfTokens; i++) {\n                    whiteListClaimed[msg.sender] += 1;\n                    _safeMint(msg.sender, totalSupply().sub(giveawayCount));\n            }\n        }\n        else{\n            require(totalSupply() < MAX_NFT, 'All tokens have been minted');\n            require(_numOfTokens == 1, 'Cannot purchase this many tokens');\n            require(!giveawayMintClaimed[msg.sender], 'Already claimed giveaway');\n            giveawayMintClaimed[msg.sender] = true;\n            _safeMint(msg.sender, totalSupply());\n        }\n    }","contract":"MGDC","time":0},{"type":"external-function ","before":"function mintMultipleByOwner(\n        address[] memory _to, \n        uint256[] memory _tokenId\n    )\n        public\n        onlyOwner\n    {\n        require(_to.length == _tokenId.length, \"Should have same length\");\n        for(uint256 i = 0; i < _to.length; i++){\n            require(_tokenId[i] >= MAX_NFT_PUBLIC, \"Tokens number to mint must exceed number of public tokens\");\n            require(_tokenId[i] < MAX_NFT, \"Tokens number to mint cannot exceed number of MAX tokens\");\n            _safeMint(_to[i], _tokenId[i]);\n            giveawayCount = giveawayCount.add(1);\n        }\n    }","after":"function mintMultipleByOwner(\n        address[] calldata _to, \n        uint256[] calldata _tokenId\n    )\n        public\n        onlyOwner\n    {\n        require(_to.length == _tokenId.length, \"Should have same length\");\n        for(uint256 i = 0; i < _to.length; i++){\n            require(_tokenId[i] >= MAX_NFT_PUBLIC, \"Tokens number to mint must exceed number of public tokens\");\n            require(_tokenId[i] < MAX_NFT, \"Tokens number to mint cannot exceed number of MAX tokens\");\n            _safeMint(_to[i], _tokenId[i]);\n            giveawayCount = giveawayCount.add(1);\n        }\n    }","contract":"MGDC","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public NFTPrice = 250000000000000000;","after":"uint256 public constant NFTPrice = 250000000000000000;","contract":"MGDC","time":0}]}