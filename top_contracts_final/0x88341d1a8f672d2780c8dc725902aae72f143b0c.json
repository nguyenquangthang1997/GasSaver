{"time":188,"results":[{"type":"state-data-arrangement ","before":"\n bytes4 private constant _ERC721_RECEIVED = 0x150b7a02\n mapping (uint256 => address) private _tokenOwner\n mapping (uint256 => address) private _tokenApprovals\n mapping (address => uint256) private _ownedTokensCount\n mapping (address => mapping (address => bool)) private _operatorApprovals\n bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd","after":" mapping (uint256 => address) private _tokenOwner\n mapping (uint256 => address) private _tokenApprovals\n mapping (address => uint256) private _ownedTokensCount\n mapping (address => mapping (address => bool)) private _operatorApprovals\n bytes4 private constant _ERC721_RECEIVED = 0x150b7a02\n bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd\n","contract":"ERC721","time":0},{"type":"struct-data-arrangement ","before":"\n uint256 loanI\n uint256 loanPrincipalAmoun\n uint256 maximumRepaymentAmoun\n uint256 nftCollateralI\n uint64 loanStartTim\n uint32 loanDuratio\n uint32 loanInterestRateForDurationInBasisPoint\n uint32 loanAdminFeeInBasisPoint\n address nftCollateralContrac\n address loanERC20Denominatio\n address borrowe\n bool interestIsProRate","after":" uint256 loanI\n uint256 loanPrincipalAmoun\n uint256 maximumRepaymentAmoun\n uint256 nftCollateralI\n address nftCollateralContrac\n address loanERC20Denominatio\n address borrowe\n uint64 loanStartTim\n uint32 loanDuratio\n uint32 loanInterestRateForDurationInBasisPoint\n uint32 loanAdminFeeInBasisPoint\n bool interestIsProRate\n","contract":"NFTfi","time":7},{"type":"external-function ","before":" function beginLoan(\n        uint256 _loanPrincipalAmount,\n        uint256 _maximumRepaymentAmount,\n        uint256 _nftCollateralId,\n        uint256 _loanDuration,\n        uint256 _loanInterestRateForDurationInBasisPoints,\n        uint256 _adminFeeInBasisPoints,\n        uint256[2] memory _borrowerAndLenderNonces,\n        address _nftCollateralContract,\n        address _loanERC20Denomination,\n        address _lender,\n        bytes memory _borrowerSignature,\n        bytes memory _lenderSignature\n    ) public whenNotPaused nonReentrant {\n\n        // Save loan details to a struct in memory first, to save on gas if any\n        // of the below checks fail, and to avoid the \"Stack Too Deep\" error by\n        // clumping the parameters together into one struct held in memory.\n        Loan memory loan = Loan({\n            loanId: totalNumLoans, //currentLoanId,\n            loanPrincipalAmount: _loanPrincipalAmount,\n            maximumRepaymentAmount: _maximumRepaymentAmount,\n            nftCollateralId: _nftCollateralId,\n            loanStartTime: uint64(now), //_loanStartTime\n            loanDuration: uint32(_loanDuration),\n            loanInterestRateForDurationInBasisPoints: uint32(_loanInterestRateForDurationInBasisPoints),\n            loanAdminFeeInBasisPoints: uint32(_adminFeeInBasisPoints),\n            nftCollateralContract: _nftCollateralContract,\n            loanERC20Denomination: _loanERC20Denomination,\n            borrower: msg.sender, //borrower\n            interestIsProRated: (_loanInterestRateForDurationInBasisPoints != ~(uint32(0)))\n        });\n\n        // Sanity check loan values.\n        require(loan.maximumRepaymentAmount >= loan.loanPrincipalAmount, 'Negative interest rate loans are not allowed.');\n        require(uint256(loan.loanDuration) <= maximumLoanDuration, 'Loan duration exceeds maximum loan duration');\n        require(uint256(loan.loanDuration) != 0, 'Loan duration cannot be zero');\n        require(uint256(loan.loanAdminFeeInBasisPoints) == adminFeeInBasisPoints, 'The admin fee has changed since this order was signed.');\n\n        // Check that both the collateral and the principal come from supported\n        // contracts.\n        require(erc20CurrencyIsWhitelisted[loan.loanERC20Denomination], 'Currency denomination is not whitelisted to be used by this contract');\n        require(nftContractIsWhitelisted[loan.nftCollateralContract], 'NFT collateral contract is not whitelisted to be used by this contract');\n\n        // Check loan nonces. These are different from Ethereum account nonces.\n        // Here, these are uint256 numbers that should uniquely identify\n        // each signature for each user (i.e. each user should only create one\n        // off-chain signature for each nonce, with a nonce being any arbitrary\n        // uint256 value that they have not used yet for an off-chain NFTfi\n        // signature).\n        require(!_nonceHasBeenUsedForUser[msg.sender][_borrowerAndLenderNonces[0]], 'Borrower nonce invalid, borrower has either cancelled/begun this loan, or reused this nonce when signing');\n        _nonceHasBeenUsedForUser[msg.sender][_borrowerAndLenderNonces[0]] = true;\n        require(!_nonceHasBeenUsedForUser[_lender][_borrowerAndLenderNonces[1]], 'Lender nonce invalid, lender has either cancelled/begun this loan, or reused this nonce when signing');\n        _nonceHasBeenUsedForUser[_lender][_borrowerAndLenderNonces[1]] = true;\n\n        // Check that both signatures are valid.\n        require(isValidBorrowerSignature(\n            loan.nftCollateralId,\n            _borrowerAndLenderNonces[0],//_borrowerNonce,\n            loan.nftCollateralContract,\n            msg.sender,      //borrower,\n            _borrowerSignature\n        ), 'Borrower signature is invalid');\n        require(isValidLenderSignature(\n            loan.loanPrincipalAmount,\n            loan.maximumRepaymentAmount,\n            loan.nftCollateralId,\n            loan.loanDuration,\n            loan.loanInterestRateForDurationInBasisPoints,\n            loan.loanAdminFeeInBasisPoints,\n            _borrowerAndLenderNonces[1],//_lenderNonce,\n            loan.nftCollateralContract,\n            loan.loanERC20Denomination,\n            _lender,\n            loan.interestIsProRated,\n            _lenderSignature\n        ), 'Lender signature is invalid');\n\n        // Add the loan to storage before moving collateral/principal to follow\n        // the Checks-Effects-Interactions pattern.\n        loanIdToLoan[totalNumLoans] = loan;\n        totalNumLoans = totalNumLoans.add(1);\n\n        // Update number of active loans.\n        totalActiveLoans = totalActiveLoans.add(1);\n        require(totalActiveLoans <= maximumNumberOfActiveLoans, 'Contract has reached the maximum number of active loans allowed by admins');\n\n        // Transfer collateral from borrower to this contract to be held until\n        // loan completion.\n        IERC721(loan.nftCollateralContract).transferFrom(msg.sender, address(this), loan.nftCollateralId);\n\n        // Transfer principal from lender to borrower.\n        IERC20(loan.loanERC20Denomination).transferFrom(_lender, msg.sender, loan.loanPrincipalAmount);\n\n        // Issue an ERC721 promissory note to the lender that gives them the\n        // right to either the principal-plus-interest or the collateral.\n        _mint(_lender, loan.loanId);\n\n        // Emit an event with all relevant details from this transaction.\n        emit LoanStarted(\n            loan.loanId,\n            msg.sender,      //borrower,\n            _lender,\n            loan.loanPrincipalAmount,\n            loan.maximumRepaymentAmount,\n            loan.nftCollateralId,\n            now,             //_loanStartTime\n            loan.loanDuration,\n            loan.loanInterestRateForDurationInBasisPoints,\n            loan.nftCollateralContract,\n            loan.loanERC20Denomination,\n            loan.interestIsProRated\n        );\n    ","after":" function beginLoan(\n        uint256 _loanPrincipalAmount,\n        uint256 _maximumRepaymentAmount,\n        uint256 _nftCollateralId,\n        uint256 _loanDuration,\n        uint256 _loanInterestRateForDurationInBasisPoints,\n        uint256 _adminFeeInBasisPoints,\n        uint256[2] calldata _borrowerAndLenderNonces,\n        address _nftCollateralContract,\n        address _loanERC20Denomination,\n        address _lender,\n        bytes calldata _borrowerSignature,\n        bytes calldata _lenderSignature\n    ) public whenNotPaused nonReentrant {\n\n        // Save loan details to a struct in memory first, to save on gas if any\n        // of the below checks fail, and to avoid the \"Stack Too Deep\" error by\n        // clumping the parameters together into one struct held in memory.\n        Loan memory loan = Loan({\n            loanId: totalNumLoans, //currentLoanId,\n            loanPrincipalAmount: _loanPrincipalAmount,\n            maximumRepaymentAmount: _maximumRepaymentAmount,\n            nftCollateralId: _nftCollateralId,\n            loanStartTime: uint64(now), //_loanStartTime\n            loanDuration: uint32(_loanDuration),\n            loanInterestRateForDurationInBasisPoints: uint32(_loanInterestRateForDurationInBasisPoints),\n            loanAdminFeeInBasisPoints: uint32(_adminFeeInBasisPoints),\n            nftCollateralContract: _nftCollateralContract,\n            loanERC20Denomination: _loanERC20Denomination,\n            borrower: msg.sender, //borrower\n            interestIsProRated: (_loanInterestRateForDurationInBasisPoints != ~(uint32(0)))\n        });\n\n        // Sanity check loan values.\n        require(loan.maximumRepaymentAmount >= loan.loanPrincipalAmount, 'Negative interest rate loans are not allowed.');\n        require(uint256(loan.loanDuration) <= maximumLoanDuration, 'Loan duration exceeds maximum loan duration');\n        require(uint256(loan.loanDuration) != 0, 'Loan duration cannot be zero');\n        require(uint256(loan.loanAdminFeeInBasisPoints) == adminFeeInBasisPoints, 'The admin fee has changed since this order was signed.');\n\n        // Check that both the collateral and the principal come from supported\n        // contracts.\n        require(erc20CurrencyIsWhitelisted[loan.loanERC20Denomination], 'Currency denomination is not whitelisted to be used by this contract');\n        require(nftContractIsWhitelisted[loan.nftCollateralContract], 'NFT collateral contract is not whitelisted to be used by this contract');\n\n        // Check loan nonces. These are different from Ethereum account nonces.\n        // Here, these are uint256 numbers that should uniquely identify\n        // each signature for each user (i.e. each user should only create one\n        // off-chain signature for each nonce, with a nonce being any arbitrary\n        // uint256 value that they have not used yet for an off-chain NFTfi\n        // signature).\n        require(!_nonceHasBeenUsedForUser[msg.sender][_borrowerAndLenderNonces[0]], 'Borrower nonce invalid, borrower has either cancelled/begun this loan, or reused this nonce when signing');\n        _nonceHasBeenUsedForUser[msg.sender][_borrowerAndLenderNonces[0]] = true;\n        require(!_nonceHasBeenUsedForUser[_lender][_borrowerAndLenderNonces[1]], 'Lender nonce invalid, lender has either cancelled/begun this loan, or reused this nonce when signing');\n        _nonceHasBeenUsedForUser[_lender][_borrowerAndLenderNonces[1]] = true;\n\n        // Check that both signatures are valid.\n        require(isValidBorrowerSignature(\n            loan.nftCollateralId,\n            _borrowerAndLenderNonces[0],//_borrowerNonce,\n            loan.nftCollateralContract,\n            msg.sender,      //borrower,\n            _borrowerSignature\n        ), 'Borrower signature is invalid');\n        require(isValidLenderSignature(\n            loan.loanPrincipalAmount,\n            loan.maximumRepaymentAmount,\n            loan.nftCollateralId,\n            loan.loanDuration,\n            loan.loanInterestRateForDurationInBasisPoints,\n            loan.loanAdminFeeInBasisPoints,\n            _borrowerAndLenderNonces[1],//_lenderNonce,\n            loan.nftCollateralContract,\n            loan.loanERC20Denomination,\n            _lender,\n            loan.interestIsProRated,\n            _lenderSignature\n        ), 'Lender signature is invalid');\n\n        // Add the loan to storage before moving collateral/principal to follow\n        // the Checks-Effects-Interactions pattern.\n        loanIdToLoan[totalNumLoans] = loan;\n        totalNumLoans = totalNumLoans.add(1);\n\n        // Update number of active loans.\n        totalActiveLoans = totalActiveLoans.add(1);\n        require(totalActiveLoans <= maximumNumberOfActiveLoans, 'Contract has reached the maximum number of active loans allowed by admins');\n\n        // Transfer collateral from borrower to this contract to be held until\n        // loan completion.\n        IERC721(loan.nftCollateralContract).transferFrom(msg.sender, address(this), loan.nftCollateralId);\n\n        // Transfer principal from lender to borrower.\n        IERC20(loan.loanERC20Denomination).transferFrom(_lender, msg.sender, loan.loanPrincipalAmount);\n\n        // Issue an ERC721 promissory note to the lender that gives them the\n        // right to either the principal-plus-interest or the collateral.\n        _mint(_lender, loan.loanId);\n\n        // Emit an event with all relevant details from this transaction.\n        emit LoanStarted(\n            loan.loanId,\n            msg.sender,      //borrower,\n            _lender,\n            loan.loanPrincipalAmount,\n            loan.maximumRepaymentAmount,\n            loan.nftCollateralId,\n            now,             //_loanStartTime\n            loan.loanDuration,\n            loan.loanInterestRateForDurationInBasisPoints,\n            loan.nftCollateralContract,\n            loan.loanERC20Denomination,\n            loan.interestIsProRated\n        );\n    ","contract":"NFTfi","time":0}]}