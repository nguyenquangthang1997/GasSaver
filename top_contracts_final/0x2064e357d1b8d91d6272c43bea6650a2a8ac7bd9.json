{"time":285,"results":[{"type":"external-function ","before":"Store is AccessControlUpgradeable, UUPSUpgradeable {\n    struct Allowance {\n        address minter;\n        uint16 amount;\n    }\n\n    mapping(address => uint16) public allowances;\n    address[] public minters;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer { }\n\n    function initialize() public initializer {\n        _grantRole(DEFAULT_ADMIN_ROLE, ","after":"Store is AccessControlUpgradeable, UUPSUpgradeable {\n    struct Allowance {\n        address minter;\n        uint16 amount;\n    }\n\n    mapping(address => uint16) public allowances;\n    address[] public minters;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() initializer { }\n\n    function initialize() public initializer {\n        _grantRole(DEFAULT_ADMIN_ROLE, ","contract":"AllowancesStore","time":0},{"type":"external-function ","before":"nder);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n    \n    function update(Allowance[] memory _allowances) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint i = 0; i < _allowances.length; i++) {\n            if (_allowances[i].amount != 0 && allowances[_allowances[i].minter] == 0) {","after":"nder);\n    }\n\n    function _authorizeUpgrade(address) internal override onlyRole(DEFAULT_ADMIN_ROLE) {}\n    \n    function update(Allowance[] memory _allowances) external onlyRole(DEFAULT_ADMIN_ROLE) {\n        for (uint i = 0; i < _allowances.length; i++) {\n            if (_allowances[i].amount != 0 && allowances[_allowances[i].minter] == 0) {","contract":"AllowancesStore","time":0},{"type":"external-function ","before":"on`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, byt","after":"on`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, byt","contract":"AllowancesStore","time":0},{"type":"constant-restrict-modification  ","before":"on __UUPSUpgradeable_init_unchained() internal on","after":"on __UUPSUpgradeable_init_unchained() internal on","contract":"AllowancesStore","time":1},{"type":"external-function ","before":" this can be re-assigned or updated later.\n     * \n     * @param _owner can authorize, mint, gets royalties and a dividend of sales, can update the content URL.\n     * @param _info token properties\n     * @param _size number of NFTs that can be minted from this contract: set to 0 for unbound\n     * @param _price sale price in wei\n     * @param _royalties perpetual royalties paid to the creator upon token selling\n     * @param _shares array of tuples listing the shareholders and their respective shares in bps (one per each shareholder)\n     * @param _allowancesRef contract address storing array of tuples listing the allowed minters and their allowances\n     */\n    function initialize(\n        address _owner,\n        Info memory _info,\n        uint64 _size,\n        uint256 _price,\n        uint16 _royalties,\n        Shares[] memory _shares,\n        address _allowancesRef\n    ) public initializer {\n        __ERC721_init(_info.name, _info.symbol);\n        __Ownable_init();\n\n        transferOwnership(_owner); // set ownership\n        require(bytes(_info.contentUrl).length > 0, \"Empty content URL\");\n        contentUrl = _info.contentUrl;\n        contentHash = _info.contentHash;\n        require(bytes(_info.metadataUrl).length > 0, \"Empty metadata URL\");\n        met","after":" this can be re-assigned or updated later.\n     * \n     * @param _owner can authorize, mint, gets royalties and a dividend of sales, can update the content URL.\n     * @param _info token properties\n     * @param _size number of NFTs that can be minted from this contract: set to 0 for unbound\n     * @param _price sale price in wei\n     * @param _royalties perpetual royalties paid to the creator upon token selling\n     * @param _shares array of tuples listing the shareholders and their respective shares in bps (one per each shareholder)\n     * @param _allowancesRef contract address storing array of tuples listing the allowed minters and their allowances\n     */\n    function initialize(\n        address _owner,\n        Info memory _info,\n        uint64 _size,\n        uint256 _price,\n        uint16 _royalties,\n        Shares[] memory _shares,\n        address _allowancesRef\n    ) public initializer {\n        __ERC721_init(_info.name, _info.symbol);\n        __Ownable_init();\n\n        transferOwnership(_owner); // set ownership\n        require(bytes(_info.contentUrl).length > 0, \"Empty content URL\");\n        contentUrl = _info.contentUrl;\n        contentHash = _info.contentHash;\n        require(bytes(_info.metadataUrl).length > 0, \"Empty metadata URL\");\n        met","contract":"MintableRewards","time":0},{"type":"external-function ","before":"lowed minter, mints one NFT for him.\n     */\n    function mint() external override returns (uint256) {\n        require(_isAllowedToMint(1), \"Minting not allowed\");\n        address[] memory toMint = new address[](1);\n        toMint[0] = msg.sender;\n        if (owner() != msg.sender && !_isPublicAllowed()) {\n            _consumeAllowance(1);\n        }\n        retur","after":"lowed minter, mints one NFT for him.\n     */\n    function mint() external override returns (uint256) {\n        require(_isAllowedToMint(1), \"Minting not allowed\");\n        address[] memory toMint = new address[](1);\n        toMint[0] = msg.sender;\n        if (owner() != msg.sender && !_isPublicAllowed()) {\n            _consumeAllowance(1);\n        }\n        retur","contract":"MintableRewards","time":0},{"type":"external-function ","before":"r.owner();\n    }\n\n    function transferOwnership(address newOwner) public override onlyOwner {\n        require(newOwner != address(0), \"New owner is the zero address\");\n        shares[newOwner] = shares[newOwner] + shares[owner()];\n        shares[owner()] = 0;\n         _transferOwnership(newOwner);\n    }\n\n    function","after":"r.owner();\n    }\n\n    function transferOwnership(address newOwner) public override onlyOwner {\n        require(newOwner != address(0), \"New owner is the zero address\");\n        shares[newOwner] = shares[newOwner] + shares[owner()];\n        shares[owner()] = 0;\n         _transferOwnership(newOwner);\n    }\n\n    function","contract":"MintableRewards","time":0},{"type":"external-function ","before":"tes a new editions contract as a factory with a beacon proxy, returning the address of the newly created contract.\n     * Important: None of these fields can be changed after calling this operation, with the sole exception of the contentUrl field which\n     * must refer to a content having the same hash.\n     * \n     * @param info info of the editions\n     * @param size number of NFTs that can be minted from this contract: set to 0 for unbound\n     * @param price price for sale in wei\n     * @param royalties perpetual royalties paid to the creator upon token selling\n     * @param shares array of tuples listing the shareholders and their respective shares in bps (one per each shareholder)\n     * @param allowancesRef address of the allowances holding contract\n     * @return the address of the editions contract created\n     */\n    function create(\n        Min","after":"tes a new editions contract as a factory with a beacon proxy, returning the address of the newly created contract.\n     * Important: None of these fields can be changed after calling this operation, with the sole exception of the contentUrl field which\n     * must refer to a content having the same hash.\n     * \n     * @param info info of the editions\n     * @param size number of NFTs that can be minted from this contract: set to 0 for unbound\n     * @param price price for sale in wei\n     * @param royalties perpetual royalties paid to the creator upon token selling\n     * @param shares array of tuples listing the shareholders and their respective shares in bps (one per each shareholder)\n     * @param allowancesRef address of the allowances holding contract\n     * @return the address of the editions contract created\n     */\n    function create(\n        Min","contract":"MintableRewardsFactory","time":0},{"type":"external-function ","before":"on`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, byt","after":"on`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, byt","contract":"MintableRewardsFactory","time":0},{"type":"constant-restrict-modification  ","before":"on __UUPSUpgradeable_init_unchained() internal on","after":"on __UUPSUpgradeable_init_unchained() internal on","contract":"MintableRewardsFactory","time":0}]}