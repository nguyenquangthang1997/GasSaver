{"time":135,"results":[{"type":"state-data-arrangement ","before":"\nuint constant public MAX_OWNER_COUNT = 50;\nmapping (address => uint) public tokenWhitelist;\nmapping(uint => Transaction) public transactions;\nmapping(uint => mapping(address => bool)) public confirmations;\nmapping(address => bool) public isOwner;\nmapping(address => uint) public secretTxNonce;\nmapping(address => uint) public tokenBalances;\nmapping(address => uint) public tokenLimits;\naddress[] public tokens;\naddress[] public owners;\naddress   public investorContract;\naddress payable public feeCollector;\nuint public required;\nuint public transactionCount;\nbool public paused = false;","after":"uint constant public MAX_OWNER_COUNT = 50;\nmapping (address => uint) public tokenWhitelist;\nmapping(uint => Transaction) public transactions;\nmapping(uint => mapping(address => bool)) public confirmations;\nmapping(address => bool) public isOwner;\nmapping(address => uint) public secretTxNonce;\nmapping(address => uint) public tokenBalances;\nmapping(address => uint) public tokenLimits;\naddress[] public tokens;\naddress[] public owners;\nuint public required;\nuint public transactionCount;\naddress   public investorContract;\naddress payable public feeCollector;\nbool public paused = false;\n","contract":"DuplexBridge","time":0},{"type":"struct-data-arrangement ","before":"\naddress destination\nuint value\nbytes data\nbool executed\nuint nonce\naddress token\nuint amount\nuint fee","after":"uint value\nbytes data\nuint nonce\nuint amount\nuint fee\naddress destination\naddress token\nbool executed\n","contract":"DuplexBridge","time":1},{"type":"external-function ","before":"function swapToken(bytes memory _recipient, uint256 _amount, address _tokenAddress, uint256 _toSCRT)\n    public\n    notPaused()\n    tokenWhitelisted(_tokenAddress)\n    isSecretAddress(_recipient)\n    isNotGoingAboveLimit(_tokenAddress, _amount)\n    {\n        IERC20 ercToken = IERC20(_tokenAddress);\n        ITangoRouter investor = ITangoRouter(investorContract);\n\n        require(_amount >= tokenWhitelist[_tokenAddress], \"Require transfer greater than minimum\");\n\n        tokenBalances[_tokenAddress] = tokenBalances[_tokenAddress] + _amount;\n\n        if (ercToken.allowance(address(this), investorContract) < _amount) {\n            ercToken.safeApprove(investorContract, type(uint256).max);\n        }\n\n        ercToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        investor.invest(_tokenAddress, _amount);\n\n        emit SwapToken(\n            msg.sender,\n            _recipient,\n            _amount,\n            _tokenAddress,\n            _toSCRT\n        );\n    }","after":"function swapToken(bytes calldata _recipient, uint256 _amount, address _tokenAddress, uint256 _toSCRT)\n    public\n    notPaused()\n    tokenWhitelisted(_tokenAddress)\n    isSecretAddress(_recipient)\n    isNotGoingAboveLimit(_tokenAddress, _amount)\n    {\n        IERC20 ercToken = IERC20(_tokenAddress);\n        ITangoRouter investor = ITangoRouter(investorContract);\n\n        require(_amount >= tokenWhitelist[_tokenAddress], \"Require transfer greater than minimum\");\n\n        tokenBalances[_tokenAddress] = tokenBalances[_tokenAddress] + _amount;\n\n        if (ercToken.allowance(address(this), investorContract) < _amount) {\n            ercToken.safeApprove(investorContract, type(uint256).max);\n        }\n\n        ercToken.safeTransferFrom(msg.sender, address(this), _amount);\n\n        investor.invest(_tokenAddress, _amount);\n\n        emit SwapToken(\n            msg.sender,\n            _recipient,\n            _amount,\n            _tokenAddress,\n            _toSCRT\n        );\n    }","contract":"DuplexBridge","time":0},{"type":"external-function ","before":"function swap(bytes memory _recipient)\n    public\n    notPaused()\n    isSecretAddress(_recipient)\n    payable {\n        revert();\n    }","after":"function swap(bytes calldata _recipient)\n    public\n    notPaused()\n    isSecretAddress(_recipient)\n    payable {\n        revert();\n    }","contract":"DuplexBridge","time":0},{"type":"external-function ","before":"function submitTransaction(address destination, uint value, uint nonce, address token, uint fee, uint amount, bytes memory data)\n    public\n    ownerExists(msg.sender)\n    notSubmitted(token, nonce)\n    isNotUnderflowingBalance(token, amount)\n    returns (uint transactionId)\n    {\n        transactionId = addTransaction(destination, value, nonce, token, fee, amount, data);\n        secretTxNonce[token] = nonce;\n\n        confirmTransaction(transactionId);\n    }","after":"function submitTransaction(address destination, uint value, uint nonce, address token, uint fee, uint amount, bytes calldata data)\n    public\n    ownerExists(msg.sender)\n    notSubmitted(token, nonce)\n    isNotUnderflowingBalance(token, amount)\n    returns (uint transactionId)\n    {\n        transactionId = addTransaction(destination, value, nonce, token, fee, amount, data);\n        secretTxNonce[token] = nonce;\n\n        confirmTransaction(transactionId);\n    }","contract":"DuplexBridge","time":0}]}