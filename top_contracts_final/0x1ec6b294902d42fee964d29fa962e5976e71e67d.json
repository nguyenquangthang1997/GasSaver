{"time":141,"results":[{"type":"state-data-arrangement ","before":"\naddress payable private owner;\nstring public metadataBaseUri;\nbool public initialized;\naddress public nftAddress;\naddress public recipientAddress;\nuint256 public price;\nbool public shouldBurn = false;\nmapping(address => mapping(uint => PreMint)) preMints;\nmapping(address => mapping(uint => PreMint)) preMintsByIndex;\nmapping(address => uint) preMintCounts;\nmapping(uint => PreTransfer) preTransfers;\nmapping(uint => mapping(uint => PreTransfer)) preTransfersByIndex;\nmapping(uint => uint) preTransferCounts;\nmapping(uint => Offer[]) offers;\nmapping(uint => Offer[]) rejected;\nmapping(address => mapping(uint => Offer)) offered;\nmapping(address => bool) public witnesses;\nmapping(uint256 => bool) usedNonces;","after":"string public metadataBaseUri;\nuint256 public price;\nmapping(address => mapping(uint => PreMint)) preMints;\nmapping(address => mapping(uint => PreMint)) preMintsByIndex;\nmapping(address => uint) preMintCounts;\nmapping(uint => PreTransfer) preTransfers;\nmapping(uint => mapping(uint => PreTransfer)) preTransfersByIndex;\nmapping(uint => uint) preTransferCounts;\nmapping(uint => Offer[]) offers;\nmapping(uint => Offer[]) rejected;\nmapping(address => mapping(uint => Offer)) offered;\nmapping(address => bool) public witnesses;\nmapping(uint256 => bool) usedNonces;\naddress payable private owner;\naddress public nftAddress;\naddress public recipientAddress;\nbool public initialized;\nbool public shouldBurn = false;\n","contract":"VaultHandlerV7","time":1},{"type":"external-function ","before":"function transferWithCode(uint256 _tokenId, string calldata code, address _to, uint256 _nonce,  bytes memory signature) public payable {\n        require(witnesses[getAddressFromSignature(_tokenId, _nonce, signature)], 'Not Witnessed');\n        IERC721 nftToken = IERC721(nftAddress);\n        PreTransfer memory preTransfer = preTransfers[_tokenId];\n        require(preTransfer.preImage == sha256(abi.encodePacked(code)), 'Code does not match'); // Payload should match\n        nftToken.transferFrom(preTransfer._from, _to,  _tokenId);\n        delete preTransfers[_tokenId];\n        delete preTransfersByIndex[_tokenId][preTransferCounts[_tokenId]];\n        preTransferCounts[_tokenId] = preTransferCounts[_tokenId].sub(1);\n        usedNonces[_nonce] = true;\n    }","after":"function transferWithCode(uint256 _tokenId, string calldata code, address _to, uint256 _nonce,  bytes calldata signature) public payable {\n        require(witnesses[getAddressFromSignature(_tokenId, _nonce, signature)], 'Not Witnessed');\n        IERC721 nftToken = IERC721(nftAddress);\n        PreTransfer memory preTransfer = preTransfers[_tokenId];\n        require(preTransfer.preImage == sha256(abi.encodePacked(code)), 'Code does not match'); // Payload should match\n        nftToken.transferFrom(preTransfer._from, _to,  _tokenId);\n        delete preTransfers[_tokenId];\n        delete preTransfersByIndex[_tokenId][preTransferCounts[_tokenId]];\n        preTransferCounts[_tokenId] = preTransferCounts[_tokenId].sub(1);\n        usedNonces[_nonce] = true;\n    }","contract":"VaultHandlerV7","time":0},{"type":"external-function ","before":"function updateTokenUri(uint256 _tokenId,string memory _uri) external isOwner {\n        IERC721 nftToken = IERC721(nftAddress);\n        nftToken.updateTokenUri(_tokenId, _uri);\n    }","after":"function updateTokenUri(uint256 _tokenId,string calldata _uri) external isOwner {\n        IERC721 nftToken = IERC721(nftAddress);\n        nftToken.updateTokenUri(_tokenId, _uri);\n    }","contract":"VaultHandlerV7","time":0},{"type":"immutable-restrict-modification ","before":"bool public initialized;","after":"bool public immutable initialized;","contract":"VaultHandlerV7","time":0}]}