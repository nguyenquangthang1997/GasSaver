{"time":152,"results":[{"type":"external-function ","before":"function withdrawMultipleForGiveaway(uint256 amount, address[] memory winnerAddresses) public onlyOwner {\n        for (uint256 i = 0;  i < winnerAddresses.length; i++) {\n            Address.sendValue(payable(winnerAddresses[i]), amount);\n            emit PaymentReleased(winnerAddresses[i], amount);\n        }\n    }","after":"function withdrawMultipleForGiveaway(uint256 amount, address[] calldata winnerAddresses) public onlyOwner {\n        for (uint256 i = 0;  i < winnerAddresses.length; i++) {\n            Address.sendValue(payable(winnerAddresses[i]), amount);\n            emit PaymentReleased(winnerAddresses[i], amount);\n        }\n    }","contract":"BallerApes","time":0},{"type":"external-function ","before":"function reserveMintMultiple(address[] memory winnerAddresses) public onlyOwner {        \n        for (uint256 i = 0; i < winnerAddresses.length; i++) {\n            _tokenIdCounter.increment();\n            _safeMint(winnerAddresses[i], _tokenIdCounter.current());\n        }\n    }","after":"function reserveMintMultiple(address[] calldata winnerAddresses) public onlyOwner {        \n        for (uint256 i = 0; i < winnerAddresses.length; i++) {\n            _tokenIdCounter.increment();\n            _safeMint(winnerAddresses[i], _tokenIdCounter.current());\n        }\n    }","contract":"BallerApes","time":0},{"type":"external-function ","before":"function claimApes(uint256 numberOfMints, uint256 batchNumber, bytes memory signature) public {\n        require(currentBatchNumber == batchNumber, \"This batch has expired\");\n        require(!hasClaimed[batchNumber][msg.sender], \"This address has already minted\");\n        bytes32 hashToVerify = hashClaim(msg.sender, numberOfMints, batchNumber);\n        require(signerAddress == hashToVerify.toEthSignedMessageHash().recover(signature), \"Invalid signature\");\n\n        hasClaimed[batchNumber][msg.sender] = true;\n\n        for (uint256 i = 1; i <= numberOfMints; i++) {\n            _tokenIdCounter.increment();\n            _safeMint(msg.sender, _tokenIdCounter.current());\n        }\n    }","after":"function claimApes(uint256 numberOfMints, uint256 batchNumber, bytes calldata signature) public {\n        require(currentBatchNumber == batchNumber, \"This batch has expired\");\n        require(!hasClaimed[batchNumber][msg.sender], \"This address has already minted\");\n        bytes32 hashToVerify = hashClaim(msg.sender, numberOfMints, batchNumber);\n        require(signerAddress == hashToVerify.toEthSignedMessageHash().recover(signature), \"Invalid signature\");\n\n        hasClaimed[batchNumber][msg.sender] = true;\n\n        for (uint256 i = 1; i <= numberOfMints; i++) {\n            _tokenIdCounter.increment();\n            _safeMint(msg.sender, _tokenIdCounter.current());\n        }\n    }","contract":"BallerApes","time":0},{"type":"external-function ","before":"function setBaseURI(string memory newBaseURI) public onlyOwner {\n        baseURI = newBaseURI;\n    }","after":"function setBaseURI(string calldata newBaseURI) public onlyOwner {\n        baseURI = newBaseURI;\n    }","contract":"BallerApes","time":0},{"type":"external-function ","before":"function setProvenanceHash(string memory provenanceHash) public onlyOwner {\n        provenance = provenanceHash;\n    }","after":"function setProvenanceHash(string calldata provenanceHash) public onlyOwner {\n        provenance = provenanceHash;\n    }","contract":"BallerApes","time":0}]}