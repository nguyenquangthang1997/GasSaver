{"time":270,"results":[{"type":"external-function ","before":"function mint(\n        address _to,\n        uint256 _blockNumber,\n        bytes32 _blockHash,\n        string memory _ipfsHash,\n        uint256 _price,\n        bytes memory _signature\n    ) external payable {\n        require(\n            verifySig(\n                _to,\n                _blockNumber,\n                _blockHash,\n                _ipfsHash,\n                _price,\n                getChainID(),\n                signer,\n                _signature\n            ),\n            \"EthBlocksMinter: Not a valid signature\"\n        );\n        require(msg.value >= _price, \"EthBlocksMinter: Price is low\");\n        uint256 remainder = msg.value.sub(_price);\n        beneficiary.transfer(_price);\n        ethBlock.mint(_to, _blockNumber, _blockHash, _ipfsHash);\n        payable(msg.sender).transfer(remainder);\n    }","after":"function mint(\n        address _to,\n        uint256 _blockNumber,\n        bytes32 _blockHash,\n        string calldata _ipfsHash,\n        uint256 _price,\n        bytes calldata _signature\n    ) external payable {\n        require(\n            verifySig(\n                _to,\n                _blockNumber,\n                _blockHash,\n                _ipfsHash,\n                _price,\n                getChainID(),\n                signer,\n                _signature\n            ),\n            \"EthBlocksMinter: Not a valid signature\"\n        );\n        require(msg.value >= _price, \"EthBlocksMinter: Price is low\");\n        uint256 remainder = msg.value.sub(_price);\n        beneficiary.transfer(_price);\n        ethBlock.mint(_to, _blockNumber, _blockHash, _ipfsHash);\n        payable(msg.sender).transfer(remainder);\n    }","contract":"Minter","time":0},{"type":"external-function ","before":"function updateToken(\n        address _to,\n        uint256 _blockNumber,\n        bytes32 _blockHash,\n        string memory _ipfsHash,\n        uint256 _price,\n        bytes memory _signature\n    ) external payable {\n        require(\n            verifySig(\n                _to,\n                _blockNumber,\n                _blockHash,\n                _ipfsHash,\n                _price,\n                getChainID(),\n                signer,\n                _signature\n            ),\n            \"EthBlocks: Not a valid signature\"\n        );\n        require(msg.value >= _price, \"EthBlocksMinter: Price is low\");\n        require(\n            ethBlock.ownerOf(_blockNumber) == msg.sender,\n            \"EthBlocksMinter: update caller is not owner\"\n        );\n        uint256 remainder = msg.value.sub(_price);\n        beneficiary.transfer(_price);\n        ethBlock.updateToken(_blockNumber, _blockHash, _ipfsHash);\n        payable(msg.sender).transfer(remainder);\n    }","after":"function updateToken(\n        address _to,\n        uint256 _blockNumber,\n        bytes32 _blockHash,\n        string calldata _ipfsHash,\n        uint256 _price,\n        bytes calldata _signature\n    ) external payable {\n        require(\n            verifySig(\n                _to,\n                _blockNumber,\n                _blockHash,\n                _ipfsHash,\n                _price,\n                getChainID(),\n                signer,\n                _signature\n            ),\n            \"EthBlocks: Not a valid signature\"\n        );\n        require(msg.value >= _price, \"EthBlocksMinter: Price is low\");\n        require(\n            ethBlock.ownerOf(_blockNumber) == msg.sender,\n            \"EthBlocksMinter: update caller is not owner\"\n        );\n        uint256 remainder = msg.value.sub(_price);\n        beneficiary.transfer(_price);\n        ethBlock.updateToken(_blockNumber, _blockHash, _ipfsHash);\n        payable(msg.sender).transfer(remainder);\n    }","contract":"Minter","time":0},{"type":"external-function ","before":"function mint(\n        address _to,\n        uint256 _blockNumber,\n        bytes32 _blockHash,\n        string memory _ipfsHash\n    ) external onlyMinter {\n        _safeMint(_to, _blockNumber);\n        _setTokenURI(_blockNumber, _ipfsHash);\n        blockHashes[_blockNumber] = _blockHash;\n        emit RoyaltiesSet(_blockNumber, _getRoyalties());\n    }","after":"function mint(\n        address _to,\n        uint256 _blockNumber,\n        bytes32 _blockHash,\n        string calldata _ipfsHash\n    ) external onlyMinter {\n        _safeMint(_to, _blockNumber);\n        _setTokenURI(_blockNumber, _ipfsHash);\n        blockHashes[_blockNumber] = _blockHash;\n        emit RoyaltiesSet(_blockNumber, _getRoyalties());\n    }","contract":"EthBlocks","time":0},{"type":"external-function ","before":"function updateToken(\n        uint256 _blockNumber,\n        bytes32 _blockHash,\n        string memory _ipfsHash\n    ) external onlyMinter {\n        _setTokenURI(_blockNumber, _ipfsHash);\n        blockHashes[_blockNumber] = _blockHash;\n        emit Updated(_blockNumber, tokenURI(_blockNumber));\n    }","after":"function updateToken(\n        uint256 _blockNumber,\n        bytes32 _blockHash,\n        string calldata _ipfsHash\n    ) external onlyMinter {\n        _setTokenURI(_blockNumber, _ipfsHash);\n        blockHashes[_blockNumber] = _blockHash;\n        emit Updated(_blockNumber, tokenURI(_blockNumber));\n    }","contract":"EthBlocks","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"EthBlocks","time":0},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"EthBlocks","time":1}]}