{"time":113,"results":[{"type":"external-function ","before":"function claimMultipleRewards(uint[] memory tokenIds) public {\n        for (uint i = 0; i < tokenIds.length; i++) {\n            claimRewards(tokenIds[i]);\n        }\n    }","after":"function claimMultipleRewards(uint[] calldata tokenIds) public {\n        for (uint i = 0; i < tokenIds.length; i++) {\n            claimRewards(tokenIds[i]);\n        }\n    }","contract":"BoredPunkYachtClub","time":0},{"type":"external-function ","before":"function mintAndBurn(uint256 oldId, uint256 newId, bytes32 leaf, bytes32[] memory proof) external {\n        // Don't allow reminting\n        require(!_exists(newId), \"Token already minted\");\n\n        // Verify that (oldId, newId) correspond to the Merkle leaf\n        require(keccak256(abi.encodePacked(oldId, newId)) == leaf, \"Ids don't match Merkle leaf\");\n\n        // Verify that (oldId, newId) is a valid pair in the Merkle tree\n        require(verify(merkleRoot, leaf, proof), \"Not a valid element in the Merkle tree\");\n\n        // Verify that msg.sender is the owner of the old token\n        require(Opensea(openseaSharedAddress).balanceOf(msg.sender, oldId), \"Only token owner can mintAndBurn\"); // Error coming here\n\n        // Transfer the old OpenSea Shared Storefront token to this contract (with ability for owner to retrieve in case of error)\n        Opensea(openseaSharedAddress).safeTransferFrom(msg.sender, burnAddress, oldId, 1, \"\");\n\n        // Mint new token\n        _mint(msg.sender, newId);\n        emit Mint(msg.sender, newId);\n        totalSupply += 1;\n\n        // Initialize the rewards multiplier\n        tokenMultipliers[newId] = curMul;\n    }","after":"function mintAndBurn(uint256 oldId, uint256 newId, bytes32 leaf, bytes32[] calldata proof) external {\n        // Don't allow reminting\n        require(!_exists(newId), \"Token already minted\");\n\n        // Verify that (oldId, newId) correspond to the Merkle leaf\n        require(keccak256(abi.encodePacked(oldId, newId)) == leaf, \"Ids don't match Merkle leaf\");\n\n        // Verify that (oldId, newId) is a valid pair in the Merkle tree\n        require(verify(merkleRoot, leaf, proof), \"Not a valid element in the Merkle tree\");\n\n        // Verify that msg.sender is the owner of the old token\n        require(Opensea(openseaSharedAddress).balanceOf(msg.sender, oldId), \"Only token owner can mintAndBurn\"); // Error coming here\n\n        // Transfer the old OpenSea Shared Storefront token to this contract (with ability for owner to retrieve in case of error)\n        Opensea(openseaSharedAddress).safeTransferFrom(msg.sender, burnAddress, oldId, 1, \"\");\n\n        // Mint new token\n        _mint(msg.sender, newId);\n        emit Mint(msg.sender, newId);\n        totalSupply += 1;\n\n        // Initialize the rewards multiplier\n        tokenMultipliers[newId] = curMul;\n    }","contract":"BoredPunkYachtClub","time":0},{"type":"external-function ","before":"function setBaseTokenURI(string memory __baseTokenURI) public onlyOwner {\n        _baseTokenURI = __baseTokenURI;\n    }","after":"function setBaseTokenURI(string calldata __baseTokenURI) public onlyOwner {\n        _baseTokenURI = __baseTokenURI;\n    }","contract":"BoredPunkYachtClub","time":0},{"type":"constant-restrict-modification  ","before":"address public openseaSharedAddress = 0x495f947276749Ce646f68AC8c248420045cb7b5e;","after":"address public constant openseaSharedAddress = 0x495f947276749Ce646f68AC8c248420045cb7b5e;","contract":"BoredPunkYachtClub","time":0},{"type":"constant-restrict-modification  ","before":"address public burnAddress = 0x000000000000000000000000000000000000dEaD;","after":"address public constant burnAddress = 0x000000000000000000000000000000000000dEaD;","contract":"BoredPunkYachtClub","time":0},{"type":"constant-restrict-modification  ","before":"uint public maxSupply = 888;","after":"uint public constant maxSupply = 888;","contract":"BoredPunkYachtClub","time":0},{"type":"constant-restrict-modification  ","before":"uint public spoofInitBalance = 1 ether;","after":"uint public constant spoofInitBalance = 1 ether;","contract":"BoredPunkYachtClub","time":0}]}