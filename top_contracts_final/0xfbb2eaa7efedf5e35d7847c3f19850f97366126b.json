{"time":66,"results":[{"type":"external-function ","before":"function buy(\n        Lot memory lot_,\n        bytes memory signature_,\n        address buyer_\n    ) external payable whenNotPaused nonReentrant {\n        // CHECKS\n        require(msg.value == lot_.price, \"FPA: incorrect amount sent\");\n\n        require(lot_.notBefore <= block.timestamp, \"FPA: auction not yet started\");\n        require(lot_.deadline == 0 || lot_.deadline >= block.timestamp, \"FPA: auction already ended\");\n\n        bytes32 digest = _getLotDigest(lot_);\n        require(_lotDigestNonce[digest] == false, \"FPA: lot already sold\");\n        require(ECDSA.recover(digest, signature_) == lot_.seller, \"FPA: invalid signature\");\n\n        // PRE-EFFECTS\n        // Get amounts\n        uint256 auctionFee = (lot_.price * _auctionFeeBps) / 10000;\n\n        // Get royalty amount\n        (address royaltyReceiver, uint256 royaltyAmount) = _getRoyaltyInfo(\n            lot_.tokenAddress,\n            lot_.tokenId,\n            lot_.price - auctionFee\n        );\n\n        if (royaltyReceiver == address(0) || royaltyReceiver == lot_.seller) {\n            // No royalty, or royalty goes to seller\n            royaltyAmount = 0;\n        }\n\n        uint256 sellerShare = lot_.price - (auctionFee + royaltyAmount);\n        assert(sellerShare + auctionFee + royaltyAmount <= lot_.price);\n\n        // EFFECTS\n        _lotDigestNonce[digest] = true;\n\n        // INTERACTIONS\n        // Transfer the token and ensure delivery of the token\n        IERC721(lot_.tokenAddress).safeTransferFrom(lot_.seller, buyer_, lot_.tokenId);\n        require(IERC721(lot_.tokenAddress).ownerOf(lot_.tokenId) == buyer_, \"FixedPriceAuction: token transfer failed\"); // ensure delivery\n\n        // Ensure delivery of the payment\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool paymentSent, ) = lot_.seller.call{value: sellerShare}(\"\");\n        require(paymentSent, \"FixedPriceAuction: payment failed\");\n    }","after":"function buy(\n        Lot calldata lot_,\n        bytes calldata signature_,\n        address buyer_\n    ) external payable whenNotPaused nonReentrant {\n        // CHECKS\n        require(msg.value == lot_.price, \"FPA: incorrect amount sent\");\n\n        require(lot_.notBefore <= block.timestamp, \"FPA: auction not yet started\");\n        require(lot_.deadline == 0 || lot_.deadline >= block.timestamp, \"FPA: auction already ended\");\n\n        bytes32 digest = _getLotDigest(lot_);\n        require(_lotDigestNonce[digest] == false, \"FPA: lot already sold\");\n        require(ECDSA.recover(digest, signature_) == lot_.seller, \"FPA: invalid signature\");\n\n        // PRE-EFFECTS\n        // Get amounts\n        uint256 auctionFee = (lot_.price * _auctionFeeBps) / 10000;\n\n        // Get royalty amount\n        (address royaltyReceiver, uint256 royaltyAmount) = _getRoyaltyInfo(\n            lot_.tokenAddress,\n            lot_.tokenId,\n            lot_.price - auctionFee\n        );\n\n        if (royaltyReceiver == address(0) || royaltyReceiver == lot_.seller) {\n            // No royalty, or royalty goes to seller\n            royaltyAmount = 0;\n        }\n\n        uint256 sellerShare = lot_.price - (auctionFee + royaltyAmount);\n        assert(sellerShare + auctionFee + royaltyAmount <= lot_.price);\n\n        // EFFECTS\n        _lotDigestNonce[digest] = true;\n\n        // INTERACTIONS\n        // Transfer the token and ensure delivery of the token\n        IERC721(lot_.tokenAddress).safeTransferFrom(lot_.seller, buyer_, lot_.tokenId);\n        require(IERC721(lot_.tokenAddress).ownerOf(lot_.tokenId) == buyer_, \"FixedPriceAuction: token transfer failed\"); // ensure delivery\n\n        // Ensure delivery of the payment\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool paymentSent, ) = lot_.seller.call{value: sellerShare}(\"\");\n        require(paymentSent, \"FixedPriceAuction: payment failed\");\n    }","contract":"FixedPriceAuction","time":0}]}