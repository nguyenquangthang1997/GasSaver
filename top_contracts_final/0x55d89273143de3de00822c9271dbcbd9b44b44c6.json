{"time":178,"results":[{"type":"external-function ","before":" for checking a Merkle proof for your Founders Pass holding status, which may entitle you to a free item.\n    function generalBuildWithPass(bytes32[] memory _merkleProof, uint buildCount) validateBuild(buildCount) nonReentrant external payable {\n        require(currentMode == ReleaseMode.OPEN, \"It's not go time yet.\");\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n\n        // The amount we're charging (e.g, the amount we're validating) will depend on\n        // if we detected a Founder Pass match. If so we check for a lesser amount of eth.\n        uint buildCountToCharge = buildCount;\n        if(MerkleProof.verify(_merkleProof, _founderPassMerkleRoot, leaf)){\n          if(_founderPassRedeemed[msg.sender] != 1){ // if the pass is NOT already used, mark it as used and let us use the free one.\n            buildCountToCharge = buildCountToCharge - 1;\n            _founderPassRedeemed[msg.sender] = 1;\n          }\n        }\n\n        require(msg.v","after":" for checking a Merkle proof for your Founders Pass holding status, which may entitle you to a free item.\n    function generalBuildWithPass(bytes32[] memory _merkleProof, uint buildCount) validateBuild(buildCount) nonReentrant external payable {\n        require(currentMode == ReleaseMode.OPEN, \"It's not go time yet.\");\n\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n\n        // The amount we're charging (e.g, the amount we're validating) will depend on\n        // if we detected a Founder Pass match. If so we check for a lesser amount of eth.\n        uint buildCountToCharge = buildCount;\n        if(MerkleProof.verify(_merkleProof, _founderPassMerkleRoot, leaf)){\n          if(_founderPassRedeemed[msg.sender] != 1){ // if the pass is NOT already used, mark it as used and let us use the free one.\n            buildCountToCharge = buildCountToCharge - 1;\n            _founderPassRedeemed[msg.sender] = 1;\n          }\n        }\n\n        require(msg.v","contract":"Turf","time":0},{"type":"external-function ","before":"tself\n    will limit participants, plus the limit of mints per address checked in `validateBuild`.\n    */\n    function preSaleBuild(bytes32[] memory merkleProof, bytes32[] memory foundersMerkleProof, uint buildCount) validateBuild(buildCount) validatePreSaleAction nonReentrant external payable {\n      bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n      require(MerkleProof.verify(merkleProof, _presaleMerkleRoot, leaf), \"Not on allowlist\");\n\n      // You can get your Founders Pass freebie during the presale, which is in another Merkle Tree.\n      // The amount we're charging (e.g, the amount we're validating) will depend on\n      // if we detected a Founder Pass match. If so we check for a lesser amount of eth.\n      uint buildCountToCharge = buildCount;\n      if(MerkleProof.verify(foundersMerkleProof, _founderPassMerkleRoot, leaf)){\n        if(_founderPassRedeemed[msg.sender] != 1){ // if the pass is NOT already used, mark it as used and let us use the free one.\n          buildCountToCharge = buildCountToCharge - 1;\n          _founderPassRedeemed[msg.sender] = 1;\n        }\n      }\n\n      require(msg","after":"tself\n    will limit participants, plus the limit of mints per address checked in `validateBuild`.\n    */\n    function preSaleBuild(bytes32[] memory merkleProof, bytes32[] memory foundersMerkleProof, uint buildCount) validateBuild(buildCount) validatePreSaleAction nonReentrant external payable {\n      bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n      require(MerkleProof.verify(merkleProof, _presaleMerkleRoot, leaf), \"Not on allowlist\");\n\n      // You can get your Founders Pass freebie during the presale, which is in another Merkle Tree.\n      // The amount we're charging (e.g, the amount we're validating) will depend on\n      // if we detected a Founder Pass match. If so we check for a lesser amount of eth.\n      uint buildCountToCharge = buildCount;\n      if(MerkleProof.verify(foundersMerkleProof, _founderPassMerkleRoot, leaf)){\n        if(_founderPassRedeemed[msg.sender] != 1){ // if the pass is NOT already used, mark it as used and let us use the free one.\n          buildCountToCharge = buildCountToCharge - 1;\n          _founderPassRedeemed[msg.sender] = 1;\n        }\n      }\n\n      require(msg","contract":"Turf","time":0},{"type":"external-function ","before":" == price * buildCountToCharge, \"Sent incorrect Ether\");\n      mint(msg.sender, buildCount, true);\n    }\n\n    function foundersBuild(bytes32[] memory foundersMerkleProof, uint buildCount) validateBuild(buildCount) validateFoundersAction nonReentrant external payable {\n      bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n      require(MerkleProof.verify(foundersMerkleProof, _founderPassMerkleRoot, leaf), \"Not a Founder\");\n\n      // You can get your Founders Pass freebie during the presale, which is in another Merkle Tree.\n      // The amount we're charging (e.g, the amount we're validating) will depend on\n      // if we detected a Founder Pass match. If so we check for a lesser amount of eth.\n      uint buildCountToCharge = buildCount;\n\n      if(_founderPassRedeemed[msg.sender] != 1){ // if the pass is NOT already used, mark it as used and let us use the free one.\n        buildCountToCharge = buildCountToCharge - 1;\n        _founderPassRedeemed[msg.sender] = 1;\n      }\n\n      require(msg.v","after":" == price * buildCountToCharge, \"Sent incorrect Ether\");\n      mint(msg.sender, buildCount, true);\n    }\n\n    function foundersBuild(bytes32[] memory foundersMerkleProof, uint buildCount) validateBuild(buildCount) validateFoundersAction nonReentrant external payable {\n      bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n      require(MerkleProof.verify(foundersMerkleProof, _founderPassMerkleRoot, leaf), \"Not a Founder\");\n\n      // You can get your Founders Pass freebie during the presale, which is in another Merkle Tree.\n      // The amount we're charging (e.g, the amount we're validating) will depend on\n      // if we detected a Founder Pass match. If so we check for a lesser amount of eth.\n      uint buildCountToCharge = buildCount;\n\n      if(_founderPassRedeemed[msg.sender] != 1){ // if the pass is NOT already used, mark it as used and let us use the free one.\n        buildCountToCharge = buildCountToCharge - 1;\n        _founderPassRedeemed[msg.sender] = 1;\n      }\n\n      require(msg.v","contract":"Turf","time":0},{"type":"external-function ","before":"ncodePacked(sender));\n      return MerkleProof.verify(_merkleProof, _founderPassMerkleRoot, leaf);\n    }\n\n    function setMysteryZones(uint[] memory ids) exter","after":"ncodePacked(sender));\n      return MerkleProof.verify(_merkleProof, _founderPassMerkleRoot, leaf);\n    }\n\n    function setMysteryZones(uint[] memory ids) exter","contract":"Turf","time":0},{"type":"external-function ","before":"tStaffPassMerkleRoot(bytes32 merkRoot) external onlyOwner {\n      _staffPassMerkleRoot = merkRoot;\n    }\n\n    function setMysteryZoneUri(string memory uri) external onlyOwner {\n     ","after":"tStaffPassMerkleRoot(bytes32 merkRoot) external onlyOwner {\n      _staffPassMerkleRoot = merkRoot;\n    }\n\n    function setMysteryZoneUri(string memory uri) external onlyOwner {\n     ","contract":"Turf","time":0},{"type":"external-function ","before":" The new baseTokenURI\n    /// @dev Need this so we can set the new base URI for the cut over to permaweb.\n    function setBaseURI(string memory baseTokenURI_) external onlyOwn","after":" The new baseTokenURI\n    /// @dev Need this so we can set the new base URI for the cut over to permaweb.\n    function setBaseURI(string memory baseTokenURI_) external onlyOwn","contract":"Turf","time":0},{"type":"external-function ","before":"tokens\n    /// @param countPerPerson How many to send to each given address\n    /// @dev Our air dropper.\n    function friendBuild(address[] memory recipients, uint countPerPerson) external nonReentrant onlyOwner {\n      require(totalSupply() + (recipients.length * countPerPerson) <= maxSupply, \"would exceed max supply\");\n      require(friendMintCount + (recipients.length * countPerPerson) <= maxFriendSupply, \"would exceed max friend supply\");\n      for (uint i = 0; i < recipients.length; i++) {\n        mint(re","after":"tokens\n    /// @param countPerPerson How many to send to each given address\n    /// @dev Our air dropper.\n    function friendBuild(address[] memory recipients, uint countPerPerson) external nonReentrant onlyOwner {\n      require(totalSupply() + (recipients.length * countPerPerson) <= maxSupply, \"would exceed max supply\");\n      require(friendMintCount + (recipients.length * countPerPerson) <= maxFriendSupply, \"would exceed max friend supply\");\n      for (uint i = 0; i < recipients.length; i++) {\n        mint(re","contract":"Turf","time":0},{"type":"immutable-restrict-modification ","before":";\n\n    mapping (uint256 => bool) public mys","after":";\n\n    mapping (uint256 => bool) public mys","contract":"Turf","time":1},{"type":"immutable-restrict-modification ","before":"vate constant MAX_PER_ADD","after":"vate constant MAX_PER_ADD","contract":"Turf","time":1},{"type":"immutable-restrict-modification ","before":" uint256 public maxSu","after":" uint256 public maxSu","contract":"Turf","time":1},{"type":"immutable-restrict-modification ","before":"  uint256 public price;\n\n    // ","after":"  uint256 public price;\n\n    // ","contract":"Turf","time":1}]}