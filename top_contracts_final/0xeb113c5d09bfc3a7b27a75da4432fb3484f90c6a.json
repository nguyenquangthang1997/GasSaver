{"time":269,"results":[{"type":"struct-data-arrangement ","before":"\n   string n\n   string art\n   string descript\n   string webs\n   string lice\n   address payable artistAddr\n   address payable additionalPa\n   uint256 additionalPayeePercent\n   uint256 secondMarketRoya\n   uint256 pricePerTokenIn\n   string projectBase\n   uint256 invocati\n   uint256 maxInvocati\n   mapping(uint256 => string) scri\n   uint scriptCo\n   uint256 has\n   bool act\n   bool loc\n   bool pau\n   bool privateSaleIsAct\n   bool claima\n   uint256 maxPurchasea\n   mapping(address => bool) whiteL\n   mapping(address => uint256) whiteListPurcha\n   mapping(address => uint256) whiteListLi\n   mapping(string => bool) usedNon\n   mapping(uint256 => bool) isTokenClaima","after":"   string n\n   string art\n   string descript\n   string webs\n   string lice\n   uint256 additionalPayeePercent\n   uint256 secondMarketRoya\n   uint256 pricePerTokenIn\n   string projectBase\n   uint256 invocati\n   uint256 maxInvocati\n   mapping(uint256 => string) scri\n   uint scriptCo\n   uint256 has\n   uint256 maxPurchasea\n   mapping(address => bool) whiteL\n   mapping(address => uint256) whiteListPurcha\n   mapping(address => uint256) whiteListLi\n   mapping(string => bool) usedNon\n   mapping(uint256 => bool) isTokenClaima\n   address payable artistAddr\n   address payable additionalPa\n   bool act\n   bool loc\n   bool pau\n   bool privateSaleIsAct\n   bool claima\n","contract":"Kinesis","time":1},{"type":"external-function ","before":"   function mint(uint256 _projectId, bytes32 hash, bytes memory signature, string memory nonce, uint256 tokenQuantity) external payable {\n        require(!_isContract(msg.sender), \"Can't mint from a contract smh\");\n        require(matchAddressSigner(hash, signature), \"DIRECT_MINT_DISALLOWED\");\n        require(!projects[_projectId].usedNonces[nonce], \"HASH_USED\");\n        require(hashTransaction(msg.sender, _projectId, tokenQuantity, nonce) == hash, \"HASH_FAIL\");\n\n        require(tokenQuantity > 0, \"You must mint at least one piece.\");\n        require(tokenQuantity <= projects[_projectId].maxPurchaseable, \"You are minting too many pieces at once!\");\n        require(totalSupply() + tokenQuantity <= projects[_projectId].maxInvocations, \"The amount of pieces you are trying to mint exceeds the max supply.\");\n        \n        require(projects[_projectId].active || msg.sender == projects[_projectId].artistAddress, \"Project must exist and be active\");\n        require(!projects[_projectId].paused || msg.sender == projects[_projectId].artistAddress, \"Purchases are paused.\");        \n        require(!projects[_projectId].claimable, \"This project can only be claimed, not minted\");\n        require(projects[_projectId].pricePerTokenInWei * tokenQuantity <= msg.value, \"Incorrect Ether value.\");\n\n        if (projects[_projectId].privateSaleIsActive) {\n            require(projects[_projectId].whiteList[msg.sender], \"Buyer not whitelisted for this private sale\");\n            require(projects[_projectId].whiteListPurchases[msg.sender].add(tokenQuantity) <= projects[_projectId].whiteListLimit[msg.sender], \"Cannot exceed allotted presale mint count\");\n            projects[_projectId].whiteListPurchases[msg.sender] = projects[_projectId].whiteListPurchases[msg.sender].add(tokenQuantity);\n        }\n\n        for (uint256 i = 0; i < tokenQuantity; i++) {\n            _mintToken(msg.sender, _projectId);\n        }\n        _splitFunds(_projectId);\n\n        projects[_projectId].usedNonces[nonce] = true;\n ","after":"   function mint(uint256 _projectId, bytes32 hash, bytes calldata signature, string calldata nonce, uint256 tokenQuantity) external payable {\n        require(!_isContract(msg.sender), \"Can't mint from a contract smh\");\n        require(matchAddressSigner(hash, signature), \"DIRECT_MINT_DISALLOWED\");\n        require(!projects[_projectId].usedNonces[nonce], \"HASH_USED\");\n        require(hashTransaction(msg.sender, _projectId, tokenQuantity, nonce) == hash, \"HASH_FAIL\");\n\n        require(tokenQuantity > 0, \"You must mint at least one piece.\");\n        require(tokenQuantity <= projects[_projectId].maxPurchaseable, \"You are minting too many pieces at once!\");\n        require(totalSupply() + tokenQuantity <= projects[_projectId].maxInvocations, \"The amount of pieces you are trying to mint exceeds the max supply.\");\n        \n        require(projects[_projectId].active || msg.sender == projects[_projectId].artistAddress, \"Project must exist and be active\");\n        require(!projects[_projectId].paused || msg.sender == projects[_projectId].artistAddress, \"Purchases are paused.\");        \n        require(!projects[_projectId].claimable, \"This project can only be claimed, not minted\");\n        require(projects[_projectId].pricePerTokenInWei * tokenQuantity <= msg.value, \"Incorrect Ether value.\");\n\n        if (projects[_projectId].privateSaleIsActive) {\n            require(projects[_projectId].whiteList[msg.sender], \"Buyer not whitelisted for this private sale\");\n            require(projects[_projectId].whiteListPurchases[msg.sender].add(tokenQuantity) <= projects[_projectId].whiteListLimit[msg.sender], \"Cannot exceed allotted presale mint count\");\n            projects[_projectId].whiteListPurchases[msg.sender] = projects[_projectId].whiteListPurchases[msg.sender].add(tokenQuantity);\n        }\n\n        for (uint256 i = 0; i < tokenQuantity; i++) {\n            _mintToken(msg.sender, _projectId);\n        }\n        _splitFunds(_projectId);\n\n        projects[_projectId].usedNonces[nonce] = true;\n ","contract":"Kinesis","time":0},{"type":"external-function ","before":"   function addProject(uint256 _pricePerTokenInWei, uint256 _mintVolume, string memory _name, string memory _description, string memory _artistName, string memory _artistWebsite, uint256 _txnLimit, bool _claimable) public onlyAuthorized {\n\n        uint256 projectId = nextProjectId;\n        projects[projectId].artistAddress = payable(msg.sender);\n        projects[projectId].pricePerTokenInWei = _pricePerTokenInWei;\n        projects[projectId].paused=true;\n        projects[projectId].maxInvocations = _mintVolume;\n        projects[projectId].name = _name;\n        projects[projectId].description = _description;\n        projects[projectId].artist = _artistName;\n        projects[projectId].website = _artistWebsite;\n        projects[projectId].maxPurchaseable = _txnLimit;\n        projects[projectId].hashes = 1;\n        projects[projectId].claimable = _claimable;\n        nextProjectId = nextProjectId.add(1);\n  ","after":"   function addProject(uint256 _pricePerTokenInWei, uint256 _mintVolume, string calldata _name, string calldata _description, string calldata _artistName, string calldata _artistWebsite, uint256 _txnLimit, bool _claimable) public onlyAuthorized {\n\n        uint256 projectId = nextProjectId;\n        projects[projectId].artistAddress = payable(msg.sender);\n        projects[projectId].pricePerTokenInWei = _pricePerTokenInWei;\n        projects[projectId].paused=true;\n        projects[projectId].maxInvocations = _mintVolume;\n        projects[projectId].name = _name;\n        projects[projectId].description = _description;\n        projects[projectId].artist = _artistName;\n        projects[projectId].website = _artistWebsite;\n        projects[projectId].maxPurchaseable = _txnLimit;\n        projects[projectId].hashes = 1;\n        projects[projectId].claimable = _claimable;\n        nextProjectId = nextProjectId.add(1);\n  ","contract":"Kinesis","time":0},{"type":"external-function ","before":"   function updateProjectName(uint256 _projectId, string memory _projectName) onlyUnlocked(_projectId) onlyArtistOrAuthorized(_projectId) external {\n        projects[_projectId].name = _projectName;\n  ","after":"   function updateProjectName(uint256 _projectId, string calldata _projectName) onlyUnlocked(_projectId) onlyArtistOrAuthorized(_projectId) external {\n        projects[_projectId].name = _projectName;\n  ","contract":"Kinesis","time":0},{"type":"external-function ","before":"   function updateProjectArtistName(uint256 _projectId, string memory _projectArtistName) onlyUnlocked(_projectId) onlyArtistOrAuthorized(_projectId) external {\n        projects[_projectId].artist = _projectArtistName;\n  ","after":"   function updateProjectArtistName(uint256 _projectId, string calldata _projectArtistName) onlyUnlocked(_projectId) onlyArtistOrAuthorized(_projectId) external {\n        projects[_projectId].artist = _projectArtistName;\n  ","contract":"Kinesis","time":0},{"type":"external-function ","before":"   function updateProjectDescription(uint256 _projectId, string memory _projectDescription) onlyArtistOrAuthorized(_projectId) external {\n        projects[_projectId].description = _projectDescription;\n  ","after":"   function updateProjectDescription(uint256 _projectId, string calldata _projectDescription) onlyArtistOrAuthorized(_projectId) external {\n        projects[_projectId].description = _projectDescription;\n  ","contract":"Kinesis","time":0},{"type":"external-function ","before":"   function updateProjectWebsite(uint256 _projectId, string memory _projectWebsite) onlyArtistOrAuthorized(_projectId) external {\n        projects[_projectId].website = _projectWebsite;\n  ","after":"   function updateProjectWebsite(uint256 _projectId, string calldata _projectWebsite) onlyArtistOrAuthorized(_projectId) external {\n        projects[_projectId].website = _projectWebsite;\n  ","contract":"Kinesis","time":0},{"type":"external-function ","before":"   function updateProjectLicense(uint256 _projectId, string memory _projectLicense) onlyUnlocked(_projectId) onlyArtistOrAuthorized(_projectId) external {\n        projects[_projectId].license = _projectLicense;\n  ","after":"   function updateProjectLicense(uint256 _projectId, string calldata _projectLicense) onlyUnlocked(_projectId) onlyArtistOrAuthorized(_projectId) external {\n        projects[_projectId].license = _projectLicense;\n  ","contract":"Kinesis","time":0},{"type":"external-function ","before":"   function addProjectScript(uint256 _projectId, string memory _script) onlyUnlocked(_projectId) onlyArtistOrAuthorized(_projectId) external {\n        projects[_projectId].scripts[projects[_projectId].scriptCount] = _script;\n        projects[_projectId].scriptCount = projects[_projectId].scriptCount.add(1);\n  ","after":"   function addProjectScript(uint256 _projectId, string calldata _script) onlyUnlocked(_projectId) onlyArtistOrAuthorized(_projectId) external {\n        projects[_projectId].scripts[projects[_projectId].scriptCount] = _script;\n        projects[_projectId].scriptCount = projects[_projectId].scriptCount.add(1);\n  ","contract":"Kinesis","time":0},{"type":"external-function ","before":"   function updateProjectScript(uint256 _projectId, uint256 _scriptId, string memory _script) onlyUnlocked(_projectId) onlyArtistOrAuthorized(_projectId) external {\n        require(_scriptId < projects[_projectId].scriptCount, \"scriptId out of range\");\n        projects[_projectId].scripts[_scriptId] = _script;\n  ","after":"   function updateProjectScript(uint256 _projectId, uint256 _scriptId, string calldata _script) onlyUnlocked(_projectId) onlyArtistOrAuthorized(_projectId) external {\n        require(_scriptId < projects[_projectId].scriptCount, \"scriptId out of range\");\n        projects[_projectId].scripts[_scriptId] = _script;\n  ","contract":"Kinesis","time":0},{"type":"external-function ","before":"   function updateProjectBaseURI(uint256 _projectId, string memory _newBaseURI) onlyArtistOrAuthorized(_projectId) external {\n        projects[_projectId].projectBaseURI = _newBaseURI;\n  ","after":"   function updateProjectBaseURI(uint256 _projectId, string calldata _newBaseURI) onlyArtistOrAuthorized(_projectId) external {\n        projects[_projectId].projectBaseURI = _newBaseURI;\n  ","contract":"Kinesis","time":0}]}