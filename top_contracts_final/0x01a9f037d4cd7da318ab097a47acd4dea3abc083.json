{"time":144,"results":[{"type":"external-function ","before":"function setContractState(string memory _contractState) public onlyOwner {\n        contractState = _contractState;\n    }","after":"function setContractState(string calldata _contractState) public onlyOwner {\n        contractState = _contractState;\n    }","contract":"Vortex","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseURI_) public onlyOwner {\n        currentBaseURI = baseURI_;\n    }","after":"function setBaseURI(string calldata baseURI_) public onlyOwner {\n        currentBaseURI = baseURI_;\n    }","contract":"Vortex","time":0},{"type":"external-function ","before":"function presaleMint(uint256 quantity, bytes32[] memory proof)\n        public\n        payable\n    {\n        /// get the variables as comparable bytes\n        bytes32 _contractState = keccak256(abi.encodePacked(contractState));\n        /// check that one of the presale windows is active\n        require(\n            _contractState == presale1State || _contractState == presale2State,\n            \"Presale minting is not active\"\n        );\n\n        // get the mint price\n        uint256 _mintPrice = _contractState == presale1State\n            ? mintPriceDiscounted\n            : mintPrice;\n\n        // check the txn value\n        require(\n            msg.value >= _mintPrice * quantity,\n            \"Insufficient value for presale mint\"\n        );\n\n        // check that the required NFTs are held in the sender's wallet\n        if (_contractState == presale1State) {\n            // must hold an eternal fragment\n            uint256 balance = getExternalBalance(presale1address, msg.sender);\n            require(balance > 0, \"Not holding any Eternal Fragments\");\n        }\n\n        // get the sender's balance\n        uint256 currentBalance = balanceOf(msg.sender);\n\n        // calculate the total presale pool size\n        uint256 presalePoolSize = maxSupply -\n            (nWhitelisted * presaleGuaranteedTokens) -\n            reservedTokens;\n\n        // calculate the remaining presale pool based on the amt claimed so far\n        uint256 remainingPresalePool = presalePoolSize -\n            presalePoolTokensClaimed;\n\n        // calculate the amount of guaranteed tokens available to the sender\n        uint256 remainingGuaranteedTokens = currentBalance >\n            presaleGuaranteedTokens\n            ? 0\n            : presaleGuaranteedTokens - currentBalance;\n\n        // calculate the max number mintable in this txn\n        uint256 mintableTokens = remainingGuaranteedTokens +\n            remainingPresalePool;\n\n        // check that the requested quantity is allowed\n        require(mintableTokens >= quantity, \"Presale supply is exhausted\");\n\n        /// check that the sender is on the whitelist\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        require(verify(proof, leaf), \"Proof is not valid\");\n\n        // all checks have passed, mint the tokens\n        mint(quantity, _contractState);\n    }","after":"function presaleMint(uint256 quantity, bytes32[] calldata proof)\n        public\n        payable\n    {\n        /// get the variables as comparable bytes\n        bytes32 _contractState = keccak256(abi.encodePacked(contractState));\n        /// check that one of the presale windows is active\n        require(\n            _contractState == presale1State || _contractState == presale2State,\n            \"Presale minting is not active\"\n        );\n\n        // get the mint price\n        uint256 _mintPrice = _contractState == presale1State\n            ? mintPriceDiscounted\n            : mintPrice;\n\n        // check the txn value\n        require(\n            msg.value >= _mintPrice * quantity,\n            \"Insufficient value for presale mint\"\n        );\n\n        // check that the required NFTs are held in the sender's wallet\n        if (_contractState == presale1State) {\n            // must hold an eternal fragment\n            uint256 balance = getExternalBalance(presale1address, msg.sender);\n            require(balance > 0, \"Not holding any Eternal Fragments\");\n        }\n\n        // get the sender's balance\n        uint256 currentBalance = balanceOf(msg.sender);\n\n        // calculate the total presale pool size\n        uint256 presalePoolSize = maxSupply -\n            (nWhitelisted * presaleGuaranteedTokens) -\n            reservedTokens;\n\n        // calculate the remaining presale pool based on the amt claimed so far\n        uint256 remainingPresalePool = presalePoolSize -\n            presalePoolTokensClaimed;\n\n        // calculate the amount of guaranteed tokens available to the sender\n        uint256 remainingGuaranteedTokens = currentBalance >\n            presaleGuaranteedTokens\n            ? 0\n            : presaleGuaranteedTokens - currentBalance;\n\n        // calculate the max number mintable in this txn\n        uint256 mintableTokens = remainingGuaranteedTokens +\n            remainingPresalePool;\n\n        // check that the requested quantity is allowed\n        require(mintableTokens >= quantity, \"Presale supply is exhausted\");\n\n        /// check that the sender is on the whitelist\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n        require(verify(proof, leaf), \"Proof is not valid\");\n\n        // all checks have passed, mint the tokens\n        mint(quantity, _contractState);\n    }","contract":"Vortex","time":0},{"type":"constant-restrict-modification  ","before":"bytes32 presale1State = keccak256(abi.encodePacked(\"presale_1\"));","after":"bytes32 constant presale1State = keccak256(abi.encodePacked(\"presale_1\"));","contract":"Vortex","time":0},{"type":"constant-restrict-modification  ","before":"bytes32 presale2State = keccak256(abi.encodePacked(\"presale_2\"));","after":"bytes32 constant presale2State = keccak256(abi.encodePacked(\"presale_2\"));","contract":"Vortex","time":0},{"type":"constant-restrict-modification  ","before":"bytes32 publicMintState = keccak256(abi.encodePacked(\"public_mint\"));","after":"bytes32 constant publicMintState = keccak256(abi.encodePacked(\"public_mint\"));","contract":"Vortex","time":0}]}