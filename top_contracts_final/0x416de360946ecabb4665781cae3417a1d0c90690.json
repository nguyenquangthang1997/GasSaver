{"time":274,"results":[{"type":"external-function ","before":"function initPools(\n                     uint256[] memory _poolId,\n                     uint256[] memory _supply,\n                     uint256[] memory _costInUnicorns, \n                     uint256[] memory _costInRainbows, \n                     uint256[] memory _costInEth, \n                     uint256[] memory _maxMintsPerAddress,  \n                     uint32[] memory _mintTimeStart,\n                     bool[] memory _requiresWhitelist\n                  ) external onlyOwner {\n      \n\n      for (uint256 i; i < _poolId.length; i++) {\n        poolTypes[_poolId[i]] = PoolType({\n            costInUnicorns: uint64(_costInUnicorns[i]),\n            costInRainbows: uint64(_costInRainbows[i]),\n            costInEth: uint64(_costInEth[i]),\n            maxMintsPerAddress: uint16(_maxMintsPerAddress[i]),\n            mintTimeStart: uint32(_mintTimeStart[i]),\n            supply: uint32(_supply[i]),\n            requiresWhitelist: _requiresWhitelist[i]\n          });\n      }\n  }","after":"function initPools(\n                     uint256[] calldata _poolId,\n                     uint256[] calldata _supply,\n                     uint256[] calldata _costInUnicorns, \n                     uint256[] calldata _costInRainbows, \n                     uint256[] calldata _costInEth, \n                     uint256[] calldata _maxMintsPerAddress,  \n                     uint32[] calldata _mintTimeStart,\n                     bool[] calldata _requiresWhitelist\n                  ) external onlyOwner {\n      \n\n      for (uint256 i; i < _poolId.length; i++) {\n        poolTypes[_poolId[i]] = PoolType({\n            costInUnicorns: uint64(_costInUnicorns[i]),\n            costInRainbows: uint64(_costInRainbows[i]),\n            costInEth: uint64(_costInEth[i]),\n            maxMintsPerAddress: uint16(_maxMintsPerAddress[i]),\n            mintTimeStart: uint32(_mintTimeStart[i]),\n            supply: uint32(_supply[i]),\n            requiresWhitelist: _requiresWhitelist[i]\n          });\n      }\n  }","contract":"Raini721FunctionsV3","time":0},{"type":"external-function ","before":"function mint(\n      uint256[] memory _poolType,\n      uint256[] memory _amount, \n      bool[] memory _useUnicorns, \n      address[] memory _rainbowPools, \n      address[] memory _unicornPools,\n      bytes memory sig, \n      uint256 maxMints\n    ) external payable nonReentrant {\n\n    require(maxMints == 0 || checkSigniture(_msgSender(), sig, maxMints), 'invalid sig');\n\n    MintData memory _locals = MintData({\n      totalPriceRainbows: 0,\n      totalPriceUnicorns: 0,\n      minCostRainbows: 0,\n      minCostUnicorns: 0,\n      fee: 0,\n      amountEthToWithdraw: 0,\n      maxMints: 0,\n      totalToMint: 0,\n      success: false\n    });\n\n    for (uint256 i = 0; i < _poolType.length; i++) {\n      \n      PoolType memory poolType = poolTypes[_poolType[i]];\n\n      _locals.maxMints = poolType.maxMintsPerAddress == 0 ? 10 ** 10 : poolType.maxMintsPerAddress;\n      if (poolType.requiresWhitelist && (maxMints < _locals.maxMints)) {\n        _locals.maxMints = maxMints;\n      }\n\n      require(block.timestamp >= poolType.mintTimeStart || hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), 'too early');\n      require(numberMintedByAddress[_msgSender()][_poolType[i]] + _amount[i] <= _locals.maxMints, \"Max mints reached for address\");\n\n      uint256 numberMinted = numberOfPoolMinted[_poolType[i]];\n      if (numberMinted + _amount[i] > poolType.supply) {\n        _amount[i] = poolType.supply - numberMinted;\n      }\n\n      _locals.totalToMint += _amount[i];\n\n      if (poolType.maxMintsPerAddress > 0) {\n        numberMintedByAddress[_msgSender()][_poolType[i]] += _amount[i];\n        numberOfPoolMinted[_poolType[i]] += _amount[i];\n      }\n\n      if (poolType.costInUnicorns > 0 || poolType.costInRainbows > 0) {\n        if (_useUnicorns[i]) {\n          require(poolType.costInUnicorns > 0, \"unicorns not allowed\");\n          uint256 cost = poolType.costInUnicorns * _amount[i] * POINT_COST_DECIMALS;\n          _locals.totalPriceUnicorns += cost;\n          if (poolType.costInEth > 0) {\n            _locals.minCostUnicorns += cost;\n          }\n        } else {\n          require(poolType.costInRainbows > 0, \"rainbows not allowed\");\n          uint256 cost = poolType.costInRainbows * _amount[i] * POINT_COST_DECIMALS;\n          _locals.totalPriceRainbows += cost;\n          if (poolType.costInEth > 0) {\n            _locals.minCostRainbows += cost;\n          }\n        }\n\n        if (poolType.costInEth == 0) {\n          if (poolType.costInRainbows > 0) {\n            _locals.fee += (poolType.costInRainbows * _amount[i] * POINT_COST_DECIMALS * mintingFeeBasisPoints) / (rainbowToEth * 10000);\n          } else {\n            _locals.fee += (poolType.costInUnicorns * _amount[i] * POINT_COST_DECIMALS * mintingFeeBasisPoints) / (unicornToEth * 10000);\n          }\n        }\n      }\n      \n      _locals.amountEthToWithdraw += poolType.costInEth * _amount[i];\n    }\n    \n    if (_locals.totalPriceUnicorns > 0 || _locals.totalPriceRainbows > 0 ) {\n      for (uint256 n = 0; n < 2; n++) {\n        bool loopTypeUnicorns = n > 0;\n\n        uint256 totalBalance = 0;\n        uint256 totalPrice = loopTypeUnicorns ? _locals.totalPriceUnicorns : _locals.totalPriceRainbows;\n        uint256 remainingPrice = totalPrice;\n\n        if (totalPrice > 0) {\n          uint256 loopLength = loopTypeUnicorns ? _unicornPools.length : _rainbowPools.length;\n\n          require(loopLength > 0, \"invalid pools\");\n\n          for (uint256 i = 0; i < loopLength; i++) {\n            IStakingPool pool;\n            if (loopTypeUnicorns) {\n              require((unicornPools[_unicornPools[i]]), \"invalid unicorn pool\");\n              pool = IStakingPool(_unicornPools[i]);\n            } else {\n              require((rainbowPools[_rainbowPools[i]]), \"invalid rainbow pool\");\n              pool = IStakingPool(_rainbowPools[i]);\n            }\n\n            uint256 _balance = pool.balanceOf(_msgSender());\n            totalBalance += _balance;\n\n            if (totalBalance >=  totalPrice) {\n              pool.burn(_msgSender(), remainingPrice);\n              remainingPrice = 0;\n              break;\n            } else {\n              pool.burn(_msgSender(), _balance);\n              remainingPrice -= _balance;\n            }\n          }\n\n          if (remainingPrice > 0) {\n            totalPrice -= loopTypeUnicorns ? _locals.minCostUnicorns : _locals.minCostRainbows;\n            uint256 minPoints = (totalPrice * minPointsPercentToMint) / 100;\n            require(totalPrice - remainingPrice >= minPoints, \"not enough balance\");\n            uint256 pointsToEth = loopTypeUnicorns ? unicornToEth : rainbowToEth;\n            require(msg.value * pointsToEth > remainingPrice, \"not enough balance\");\n            _locals.fee += remainingPrice / pointsToEth;\n          }\n        }\n      }\n    }\n\n\n    require(_locals.amountEthToWithdraw + _locals.fee <= msg.value, \"not enough eth\");\n\n    (_locals.success, ) = _msgSender().call{ value: msg.value - (_locals.amountEthToWithdraw + _locals.fee)}(\"\"); // refund excess Eth\n    require(_locals.success, \"transfer failed\");\n\n    (_locals.success, ) = feeRecipient.call{ value: _locals.fee }(\"\"); // pay fees\n    require(_locals.success, \"fee transfer failed\");\n    (_locals.success, ) = ethRecipient.call{ value: _locals.amountEthToWithdraw }(\"\"); // pay eth recipient\n    require(_locals.success, \"transfer failed\");\n\n\n    require(_locals.totalToMint > 0, 'Allocation exhausted');\n    require(_locals.totalToMint <= maxMintsPerTx, '_amount over max');\n    \n    nftContract.mintNext(_msgSender(), _locals.totalToMint);\n  }","after":"function mint(\n      uint256[] calldata _poolType,\n      uint256[] calldata _amount, \n      bool[] calldata _useUnicorns, \n      address[] calldata _rainbowPools, \n      address[] calldata _unicornPools,\n      bytes memory sig, \n      uint256 maxMints\n    ) external payable nonReentrant {\n\n    require(maxMints == 0 || checkSigniture(_msgSender(), sig, maxMints), 'invalid sig');\n\n    MintData memory _locals = MintData({\n      totalPriceRainbows: 0,\n      totalPriceUnicorns: 0,\n      minCostRainbows: 0,\n      minCostUnicorns: 0,\n      fee: 0,\n      amountEthToWithdraw: 0,\n      maxMints: 0,\n      totalToMint: 0,\n      success: false\n    });\n\n    for (uint256 i = 0; i < _poolType.length; i++) {\n      \n      PoolType memory poolType = poolTypes[_poolType[i]];\n\n      _locals.maxMints = poolType.maxMintsPerAddress == 0 ? 10 ** 10 : poolType.maxMintsPerAddress;\n      if (poolType.requiresWhitelist && (maxMints < _locals.maxMints)) {\n        _locals.maxMints = maxMints;\n      }\n\n      require(block.timestamp >= poolType.mintTimeStart || hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), 'too early');\n      require(numberMintedByAddress[_msgSender()][_poolType[i]] + _amount[i] <= _locals.maxMints, \"Max mints reached for address\");\n\n      uint256 numberMinted = numberOfPoolMinted[_poolType[i]];\n      if (numberMinted + _amount[i] > poolType.supply) {\n        _amount[i] = poolType.supply - numberMinted;\n      }\n\n      _locals.totalToMint += _amount[i];\n\n      if (poolType.maxMintsPerAddress > 0) {\n        numberMintedByAddress[_msgSender()][_poolType[i]] += _amount[i];\n        numberOfPoolMinted[_poolType[i]] += _amount[i];\n      }\n\n      if (poolType.costInUnicorns > 0 || poolType.costInRainbows > 0) {\n        if (_useUnicorns[i]) {\n          require(poolType.costInUnicorns > 0, \"unicorns not allowed\");\n          uint256 cost = poolType.costInUnicorns * _amount[i] * POINT_COST_DECIMALS;\n          _locals.totalPriceUnicorns += cost;\n          if (poolType.costInEth > 0) {\n            _locals.minCostUnicorns += cost;\n          }\n        } else {\n          require(poolType.costInRainbows > 0, \"rainbows not allowed\");\n          uint256 cost = poolType.costInRainbows * _amount[i] * POINT_COST_DECIMALS;\n          _locals.totalPriceRainbows += cost;\n          if (poolType.costInEth > 0) {\n            _locals.minCostRainbows += cost;\n          }\n        }\n\n        if (poolType.costInEth == 0) {\n          if (poolType.costInRainbows > 0) {\n            _locals.fee += (poolType.costInRainbows * _amount[i] * POINT_COST_DECIMALS * mintingFeeBasisPoints) / (rainbowToEth * 10000);\n          } else {\n            _locals.fee += (poolType.costInUnicorns * _amount[i] * POINT_COST_DECIMALS * mintingFeeBasisPoints) / (unicornToEth * 10000);\n          }\n        }\n      }\n      \n      _locals.amountEthToWithdraw += poolType.costInEth * _amount[i];\n    }\n    \n    if (_locals.totalPriceUnicorns > 0 || _locals.totalPriceRainbows > 0 ) {\n      for (uint256 n = 0; n < 2; n++) {\n        bool loopTypeUnicorns = n > 0;\n\n        uint256 totalBalance = 0;\n        uint256 totalPrice = loopTypeUnicorns ? _locals.totalPriceUnicorns : _locals.totalPriceRainbows;\n        uint256 remainingPrice = totalPrice;\n\n        if (totalPrice > 0) {\n          uint256 loopLength = loopTypeUnicorns ? _unicornPools.length : _rainbowPools.length;\n\n          require(loopLength > 0, \"invalid pools\");\n\n          for (uint256 i = 0; i < loopLength; i++) {\n            IStakingPool pool;\n            if (loopTypeUnicorns) {\n              require((unicornPools[_unicornPools[i]]), \"invalid unicorn pool\");\n              pool = IStakingPool(_unicornPools[i]);\n            } else {\n              require((rainbowPools[_rainbowPools[i]]), \"invalid rainbow pool\");\n              pool = IStakingPool(_rainbowPools[i]);\n            }\n\n            uint256 _balance = pool.balanceOf(_msgSender());\n            totalBalance += _balance;\n\n            if (totalBalance >=  totalPrice) {\n              pool.burn(_msgSender(), remainingPrice);\n              remainingPrice = 0;\n              break;\n            } else {\n              pool.burn(_msgSender(), _balance);\n              remainingPrice -= _balance;\n            }\n          }\n\n          if (remainingPrice > 0) {\n            totalPrice -= loopTypeUnicorns ? _locals.minCostUnicorns : _locals.minCostRainbows;\n            uint256 minPoints = (totalPrice * minPointsPercentToMint) / 100;\n            require(totalPrice - remainingPrice >= minPoints, \"not enough balance\");\n            uint256 pointsToEth = loopTypeUnicorns ? unicornToEth : rainbowToEth;\n            require(msg.value * pointsToEth > remainingPrice, \"not enough balance\");\n            _locals.fee += remainingPrice / pointsToEth;\n          }\n        }\n      }\n    }\n\n\n    require(_locals.amountEthToWithdraw + _locals.fee <= msg.value, \"not enough eth\");\n\n    (_locals.success, ) = _msgSender().call{ value: msg.value - (_locals.amountEthToWithdraw + _locals.fee)}(\"\"); // refund excess Eth\n    require(_locals.success, \"transfer failed\");\n\n    (_locals.success, ) = feeRecipient.call{ value: _locals.fee }(\"\"); // pay fees\n    require(_locals.success, \"fee transfer failed\");\n    (_locals.success, ) = ethRecipient.call{ value: _locals.amountEthToWithdraw }(\"\"); // pay eth recipient\n    require(_locals.success, \"transfer failed\");\n\n\n    require(_locals.totalToMint > 0, 'Allocation exhausted');\n    require(_locals.totalToMint <= maxMintsPerTx, '_amount over max');\n    \n    nftContract.mintNext(_msgSender(), _locals.totalToMint);\n  }","contract":"Raini721FunctionsV3","time":1},{"type":"immutable-restrict-modification ","before":"address public contractOwner;","after":"address public immutable contractOwner;","contract":"Raini721FunctionsV3","time":0},{"type":"external-function ","before":"   function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n  ","after":"   function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n  ","contract":"ERC1155","time":0},{"type":"external-function ","before":"   function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n  ","after":"   function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n  ","contract":"ERC1155","time":0}]}