{"time":192,"results":[{"type":"state-data-arrangement ","before":"\nuint16 public constant maxSupply = 10000;\nstring internal tokenMutableMetadataURI;\nstring internal tokenPermanentMetadataURI;\nstring public contractMetadataURI;\nstring public provenanceCID;\nuint256 internal linkFee;\nbytes32 internal linkKeyHash;\nuint256 public startingIndex;\nmapping (uint256 => address) public creatorOf;\nuint16 public creatorRoyaltyInHundredthPercent;\naddress internal ctrSigner;","after":"string internal tokenMutableMetadataURI;\nstring internal tokenPermanentMetadataURI;\nstring public contractMetadataURI;\nstring public provenanceCID;\nuint256 internal linkFee;\nbytes32 internal linkKeyHash;\nuint256 public startingIndex;\nmapping (uint256 => address) public creatorOf;\naddress internal ctrSigner;\nuint16 public constant maxSupply = 10000;\nuint16 public creatorRoyaltyInHundredthPercent;\n","contract":"CTR10000","time":0},{"type":"external-function ","before":"function setContractMetadata(string memory _contractMetadataURI) public onlyOwner {\r\n        contractMetadataURI = _contractMetadataURI;\r\n    }","after":"function setContractMetadata(string calldata _contractMetadataURI) public onlyOwner {\r\n        contractMetadataURI = _contractMetadataURI;\r\n    }","contract":"CTR10000","time":0},{"type":"external-function ","before":"function setProvenance(string memory _provenanceCID) public onlyOwner {\r\n        require(currentStatus() == Status.Deployed);\r\n\r\n        provenanceCID = _provenanceCID;\r\n    }","after":"function setProvenance(string calldata _provenanceCID) public onlyOwner {\r\n        require(currentStatus() == Status.Deployed);\r\n\r\n        provenanceCID = _provenanceCID;\r\n    }","contract":"CTR10000","time":0},{"type":"external-function ","before":"function mint(bytes memory ctrSignature) public {\r\n        require(currentStatus() == Status.StartingIndexReceived);\r\n\r\n        bytes32 messageHash = keccak256(abi.encodePacked(msg.sender, balanceOf(msg.sender)));\r\n\r\n        address recoveredSigner = ECDSA.recover(\r\n            messageHash,\r\n            ctrSignature\r\n        );\r\n\r\n        require(recoveredSigner == ctrSigner);\r\n\r\n        uint256 currentTokenId = _nextTokenId.current();\r\n\r\n        _nextTokenId.increment();\r\n\r\n        _safeMint(msg.sender, currentTokenId);\r\n\r\n        creatorOf[currentTokenId] = msg.sender;\r\n    }","after":"function mint(bytes calldata ctrSignature) public {\r\n        require(currentStatus() == Status.StartingIndexReceived);\r\n\r\n        bytes32 messageHash = keccak256(abi.encodePacked(msg.sender, balanceOf(msg.sender)));\r\n\r\n        address recoveredSigner = ECDSA.recover(\r\n            messageHash,\r\n            ctrSignature\r\n        );\r\n\r\n        require(recoveredSigner == ctrSigner);\r\n\r\n        uint256 currentTokenId = _nextTokenId.current();\r\n\r\n        _nextTokenId.increment();\r\n\r\n        _safeMint(msg.sender, currentTokenId);\r\n\r\n        creatorOf[currentTokenId] = msg.sender;\r\n    }","contract":"CTR10000","time":0},{"type":"external-function ","before":"function freezeMetadata(string memory _tokenPermanentMetadataURI) public onlyOwner {\r\n        require(currentStatus() == Status.MintingCompleted);\r\n\r\n        tokenPermanentMetadataURI = _tokenPermanentMetadataURI;\r\n    }","after":"function freezeMetadata(string calldata _tokenPermanentMetadataURI) public onlyOwner {\r\n        require(currentStatus() == Status.MintingCompleted);\r\n\r\n        tokenPermanentMetadataURI = _tokenPermanentMetadataURI;\r\n    }","contract":"CTR10000","time":0},{"type":"external-function ","before":"   function executeMetaTransaction(\r\n        address userAddress,\r\n        bytes memory functionSignature,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        uint8 sigV\r\n    ) public payable returns (bytes memory) {\r\n        MetaTransaction memory metaTx = MetaTransaction({\r\n            nonce: nonces[userAddress],\r\n            from: userAddress,\r\n            functionSignature: functionSignature\r\n        });\r\n\r\n        require(\r\n            verify(userAddress, metaTx, sigR, sigS, sigV),\r\n            \"Signer and signature do not match\"\r\n        );\r\n\r\n        // increase nonce for user (to avoid re-use)\r\n        nonces[userAddress] = nonces[userAddress].add(1);\r\n\r\n        emit MetaTransactionExecuted(\r\n            userAddress,\r\n            payable(msg.sender),\r\n            functionSignature\r\n        );\r\n\r\n        // Append userAddress and relayer address at the end to extract it from calling context\r\n        (bool success, bytes memory returnData) = address(this).call(\r\n            abi.encodePacked(functionSignature, userAddress)\r\n        );\r\n        require(success, \"Function call not successful\");\r\n\r\n        return returnData;\r\n  ","after":"   function executeMetaTransaction(\r\n        address userAddress,\r\n        bytes calldata functionSignature,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        uint8 sigV\r\n    ) public payable returns (bytes memory) {\r\n        MetaTransaction memory metaTx = MetaTransaction({\r\n            nonce: nonces[userAddress],\r\n            from: userAddress,\r\n            functionSignature: functionSignature\r\n        });\r\n\r\n        require(\r\n            verify(userAddress, metaTx, sigR, sigS, sigV),\r\n            \"Signer and signature do not match\"\r\n        );\r\n\r\n        // increase nonce for user (to avoid re-use)\r\n        nonces[userAddress] = nonces[userAddress].add(1);\r\n\r\n        emit MetaTransactionExecuted(\r\n            userAddress,\r\n            payable(msg.sender),\r\n            functionSignature\r\n        );\r\n\r\n        // Append userAddress and relayer address at the end to extract it from calling context\r\n        (bool success, bytes memory returnData) = address(this).call(\r\n            abi.encodePacked(functionSignature, userAddress)\r\n        );\r\n        require(success, \"Function call not successful\");\r\n\r\n        return returnData;\r\n  ","contract":"CTR10000","time":0},{"type":"immutable-restrict-modification ","before":"uint256 internal linkFee;","after":"uint256 internal immutable linkFee;","contract":"CTR10000","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 internal linkKeyHash;","after":"bytes32 internal immutable linkKeyHash;","contract":"CTR10000","time":1},{"type":"immutable-restrict-modification ","before":"address internal ctrSigner;","after":"address internal immutable ctrSigner;","contract":"CTR10000","time":1},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"CTR10000","time":1}]}