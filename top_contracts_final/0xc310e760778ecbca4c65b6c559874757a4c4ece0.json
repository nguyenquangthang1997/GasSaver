{"time":282,"results":[{"type":"immutable-restrict-modification ","before":"address private punkOwner;","after":"address private immutable punkOwner;","contract":"PunkProxy","time":0},{"type":"external-function ","before":"function createSwapIntent(swapIntent memory _swapIntent, swapStruct[] memory _nftsOne, swapStruct[] memory _nftsTwo) payable public whenNotPaused {\n        if(payment.status) {\n            if(ERC721Interface(TRADESQUAD).balanceOf(msg.sender)==0) {\n                require(msg.value>=payment.value.add(_swapIntent.valueOne), \"Not enought WEI for handle the transaction\");\n                _swapIntent.swapFee = getWeiPayValueAmount() ;\n            }\n            else {\n                require(msg.value>=_swapIntent.valueOne, \"Not enought WEI for handle the transaction\");\n                _swapIntent.swapFee = 0 ;\n            }\n        }\n        else\n            require(msg.value>=_swapIntent.valueOne, \"Not enought WEI for handle the transaction\");\n\n        _swapIntent.addressOne = msg.sender;\n        _swapIntent.id = _swapIds.current();\n        _swapIntent.swapStart = block.timestamp;\n        _swapIntent.swapEnd = 0;\n        _swapIntent.status = swapStatus.Opened ;\n\n        swapMatch[_swapIds.current()] = swapList[msg.sender].length;\n        swapList[msg.sender].push(_swapIntent);\n        \n        uint256 i;\n        for(i=0; i<_nftsOne.length; i++)\n            nftsOne[_swapIntent.id].push(_nftsOne[i]);\n            \n        for(i=0; i<_nftsTwo.length; i++)\n            nftsTwo[_swapIntent.id].push(_nftsTwo[i]);\n        \n        for(i=0; i<nftsOne[_swapIntent.id].length; i++) {\n            require(whiteList[nftsOne[_swapIntent.id][i].dapp], \"A DAPP is not handled by the system\");\n            if(nftsOne[_swapIntent.id][i].typeStd == ERC20) {\n                ERC20Interface(nftsOne[_swapIntent.id][i].dapp).transferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].blc[0]);\n            }\n            else if(nftsOne[_swapIntent.id][i].typeStd == ERC721) {\n                ERC721Interface(nftsOne[_swapIntent.id][i].dapp).safeTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId[0], nftsOne[_swapIntent.id][i].data);\n            }\n            else if(nftsOne[_swapIntent.id][i].typeStd == ERC1155) {\n                ERC1155Interface(nftsOne[_swapIntent.id][i].dapp).safeBatchTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data);\n            }\n            else if(nftsOne[_swapIntent.id][i].typeStd == CRYPTOPUNK) { // Controllo che il CP sia presente sul proxy e che non sia in uso in un altro trade\n                require(punkInUse[nftsOne[_swapIntent.id][i].tokenId[0]] == false, \"Punk in use on another trade\");\n                require(CPInterface(CRYPTOPUNK).punkIndexToAddress(nftsOne[_swapIntent.id][i].tokenId[0]) == address(punkProxies[msg.sender]), \"CryptoPunk missing\");\n                punkInUse[nftsOne[_swapIntent.id][i].tokenId[0]] = true;\n            }\n            else {\n                customInterface(dappRelations[nftsOne[_swapIntent.id][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapIntent.id][i].dapp, _swapIntent.addressOne, dappRelations[nftsOne[_swapIntent.id][i].dapp], nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data);\n            }\n        }\n\n        emit swapEvent(msg.sender, (block.timestamp-(block.timestamp%secs)), _swapIntent.status, _swapIntent.id, _swapIntent.addressTwo);\n        _swapIds.increment();\n    }","after":"function createSwapIntent(swapIntent calldata _swapIntent, swapStruct[] calldata _nftsOne, swapStruct[] memory _nftsTwo) payable public whenNotPaused {\n        if(payment.status) {\n            if(ERC721Interface(TRADESQUAD).balanceOf(msg.sender)==0) {\n                require(msg.value>=payment.value.add(_swapIntent.valueOne), \"Not enought WEI for handle the transaction\");\n                _swapIntent.swapFee = getWeiPayValueAmount() ;\n            }\n            else {\n                require(msg.value>=_swapIntent.valueOne, \"Not enought WEI for handle the transaction\");\n                _swapIntent.swapFee = 0 ;\n            }\n        }\n        else\n            require(msg.value>=_swapIntent.valueOne, \"Not enought WEI for handle the transaction\");\n\n        _swapIntent.addressOne = msg.sender;\n        _swapIntent.id = _swapIds.current();\n        _swapIntent.swapStart = block.timestamp;\n        _swapIntent.swapEnd = 0;\n        _swapIntent.status = swapStatus.Opened ;\n\n        swapMatch[_swapIds.current()] = swapList[msg.sender].length;\n        swapList[msg.sender].push(_swapIntent);\n        \n        uint256 i;\n        for(i=0; i<_nftsOne.length; i++)\n            nftsOne[_swapIntent.id].push(_nftsOne[i]);\n            \n        for(i=0; i<_nftsTwo.length; i++)\n            nftsTwo[_swapIntent.id].push(_nftsTwo[i]);\n        \n        for(i=0; i<nftsOne[_swapIntent.id].length; i++) {\n            require(whiteList[nftsOne[_swapIntent.id][i].dapp], \"A DAPP is not handled by the system\");\n            if(nftsOne[_swapIntent.id][i].typeStd == ERC20) {\n                ERC20Interface(nftsOne[_swapIntent.id][i].dapp).transferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].blc[0]);\n            }\n            else if(nftsOne[_swapIntent.id][i].typeStd == ERC721) {\n                ERC721Interface(nftsOne[_swapIntent.id][i].dapp).safeTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId[0], nftsOne[_swapIntent.id][i].data);\n            }\n            else if(nftsOne[_swapIntent.id][i].typeStd == ERC1155) {\n                ERC1155Interface(nftsOne[_swapIntent.id][i].dapp).safeBatchTransferFrom(_swapIntent.addressOne, address(this), nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data);\n            }\n            else if(nftsOne[_swapIntent.id][i].typeStd == CRYPTOPUNK) { // Controllo che il CP sia presente sul proxy e che non sia in uso in un altro trade\n                require(punkInUse[nftsOne[_swapIntent.id][i].tokenId[0]] == false, \"Punk in use on another trade\");\n                require(CPInterface(CRYPTOPUNK).punkIndexToAddress(nftsOne[_swapIntent.id][i].tokenId[0]) == address(punkProxies[msg.sender]), \"CryptoPunk missing\");\n                punkInUse[nftsOne[_swapIntent.id][i].tokenId[0]] = true;\n            }\n            else {\n                customInterface(dappRelations[nftsOne[_swapIntent.id][i].dapp]).bridgeSafeTransferFrom(nftsOne[_swapIntent.id][i].dapp, _swapIntent.addressOne, dappRelations[nftsOne[_swapIntent.id][i].dapp], nftsOne[_swapIntent.id][i].tokenId, nftsOne[_swapIntent.id][i].blc, nftsOne[_swapIntent.id][i].data);\n            }\n        }\n\n        emit swapEvent(msg.sender, (block.timestamp-(block.timestamp%secs)), _swapIntent.status, _swapIntent.id, _swapIntent.addressTwo);\n        _swapIds.increment();\n    }","contract":"BatchSwap","time":1}]}