{"time":264,"results":[{"type":"constant-restrict-modification  ","before":"   bytes32 private immutable _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)","after":"   bytes32 private immutable constant _PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)","contract":"ERC20Permit","time":1},{"type":"external-function ","before":"o\n    function cancelOrder(Order memory order) external {\n        require(order.makerAssetData.decodeAddress(_FROM_INDEX) == msg.sender, \"LOP: Access denied\");\n\n        bytes32 orderHash = _hash(order);\n        _remaining[orderHash] = 1;\n        emit OrderFilled(msg.sender, orderHash, 0);","after":"o\n    function cancelOrder(Order calldata order) external {\n        require(order.makerAssetData.decodeAddress(_FROM_INDEX) == msg.sender, \"LOP: Access denied\");\n\n        bytes32 orderHash = _hash(order);\n        _remaining[orderHash] = 1;\n        emit OrderFilled(msg.sender, orderHash, 0);","contract":"LimitOrderProtocol","time":0},{"type":"external-function ","before":"t\n    function fillOrderRFQ(OrderRFQ memory order, bytes memory signature, uint256 makingAmount, uint256 takingAmount) external {\n        // Check time expiration\n        uint256 expiration = uint128(order.info) >> 64;\n        require(expiration == 0 || block.timestamp <= expiration, \"LOP: order expired\");  // solhint-disable-line not-rely-on-time\n\n        // Validate double spend\n        address maker = order.makerAssetData.decodeAddress(_FROM_INDEX);\n        uint256 invalidatorSlot = uint64(order.info) >> 8;\n        uint256 invalidatorBit = 1 << uint8(order.info);\n        uint256 invalidator = _invalidator[maker][invalidatorSlot];\n        require(invalidator & invalidatorBit == 0, \"LOP: already filled\");\n        _invalidator[maker][invalidatorSlot] = invalidator | invalidatorBit;\n\n        // Compute partial fill if needed\n        uint256 orderMakerAmount = order.makerAssetData.decodeUint256(_AMOUNT_INDEX);\n        uint256 orderTakerAmount = order.takerAssetData.decodeUint256(_AMOUNT_INDEX);\n        if (takingAmount == 0 && makingAmount == 0) {\n            // Two zeros means whole order\n            makingAmount = orderMakerAmount;\n            takingAmount = orderTakerAmount;\n        }\n        else if (takingAmount == 0) {\n            takingAmount = (makingAmount * orderTakerAmount + orderMakerAmount - 1) / orderMakerAmount;\n        }\n        else if (makingAmount == 0) {\n            makingAmount = takingAmount * orderMakerAmount / orderTakerAmount;\n        }\n        else {\n            revert(\"LOP: one of amounts should be 0\");\n        }\n\n        require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n        require(makingAmount <= orderMakerAmount, \"LOP: making amount exceeded\");\n        require(takingAmount <= orderTakerAmount, \"LOP: taking amount exceeded\");\n\n        // Validate order\n        bytes32 orderHash = _hash(order);\n        _validate(order.makerAssetData, order.takerAssetData, signature, orderHash);\n\n        // Maker => Taker, Taker => Maker\n        _callMakerAssetTransferFrom(order.makerAsset, order.makerAssetData, msg.sender, makingAmount);\n        _callTakerAssetTransferFrom(order.takerAsset, order.takerAssetData, msg.sender, takingAmount);\n\n        emit OrderFilledRFQ(orderHash, makingAmount);","after":"t\n    function fillOrderRFQ(OrderRFQ calldata order, bytes calldata signature, uint256 makingAmount, uint256 takingAmount) external {\n        // Check time expiration\n        uint256 expiration = uint128(order.info) >> 64;\n        require(expiration == 0 || block.timestamp <= expiration, \"LOP: order expired\");  // solhint-disable-line not-rely-on-time\n\n        // Validate double spend\n        address maker = order.makerAssetData.decodeAddress(_FROM_INDEX);\n        uint256 invalidatorSlot = uint64(order.info) >> 8;\n        uint256 invalidatorBit = 1 << uint8(order.info);\n        uint256 invalidator = _invalidator[maker][invalidatorSlot];\n        require(invalidator & invalidatorBit == 0, \"LOP: already filled\");\n        _invalidator[maker][invalidatorSlot] = invalidator | invalidatorBit;\n\n        // Compute partial fill if needed\n        uint256 orderMakerAmount = order.makerAssetData.decodeUint256(_AMOUNT_INDEX);\n        uint256 orderTakerAmount = order.takerAssetData.decodeUint256(_AMOUNT_INDEX);\n        if (takingAmount == 0 && makingAmount == 0) {\n            // Two zeros means whole order\n            makingAmount = orderMakerAmount;\n            takingAmount = orderTakerAmount;\n        }\n        else if (takingAmount == 0) {\n            takingAmount = (makingAmount * orderTakerAmount + orderMakerAmount - 1) / orderMakerAmount;\n        }\n        else if (makingAmount == 0) {\n            makingAmount = takingAmount * orderMakerAmount / orderTakerAmount;\n        }\n        else {\n            revert(\"LOP: one of amounts should be 0\");\n        }\n\n        require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n        require(makingAmount <= orderMakerAmount, \"LOP: making amount exceeded\");\n        require(takingAmount <= orderTakerAmount, \"LOP: taking amount exceeded\");\n\n        // Validate order\n        bytes32 orderHash = _hash(order);\n        _validate(order.makerAssetData, order.takerAssetData, signature, orderHash);\n\n        // Maker => Taker, Taker => Maker\n        _callMakerAssetTransferFrom(order.makerAsset, order.makerAssetData, msg.sender, makingAmount);\n        _callTakerAssetTransferFrom(order.takerAsset, order.takerAssetData, msg.sender, takingAmount);\n\n        emit OrderFilledRFQ(orderHash, makingAmount);","contract":"LimitOrderProtocol","time":0},{"type":"external-function ","before":"a\n    function fillOrder(Order memory order, bytes calldata signature, uint256 makingAmount, uint256 takingAmount, uint256 thresholdAmount) external returns(uint256, uint256) {\n        bytes32 orderHash = _hash(order);\n\n        uint256 remainingMakerAmount;\n        { // Stack too deep\n            bool orderExists;\n            (orderExists, remainingMakerAmount) = _remaining[orderHash].trySub(1);\n            if (!orderExists) {\n                // First fill: validate order and permit maker asset\n                _validate(order.makerAssetData, order.takerAssetData, signature, orderHash);\n                remainingMakerAmount = order.makerAssetData.decodeUint256(_AMOUNT_INDEX);\n                if (order.permit.length > 0) {\n                    (address token, bytes memory permit) = abi.decode(order.permit, (address, bytes));\n                    token.uncheckedFunctionCall(abi.encodePacked(IERC20Permit.permit.selector, permit), \"LOP: permit failed\");\n                    require(_remaining[orderHash] == 0, \"LOP: reentrancy detected\");\n                }\n            }\n        }\n\n        // Check if order is valid\n        if (order.predicate.length > 0) {\n            require(checkPredicate(order), \"LOP: predicate returned false\");\n        }\n\n        // Compute maker and taker assets amount\n        if ((takingAmount == 0) == (makingAmount == 0)) {\n            revert(\"LOP: only one amount should be 0\");\n        }\n        else if (takingAmount == 0) {\n            takingAmount = _callGetTakerAmount(order, makingAmount);\n            require(takingAmount <= thresholdAmount, \"LOP: taking amount too high\");\n        }\n        else {\n            makingAmount = _callGetMakerAmount(order, takingAmount);\n            require(makingAmount >= thresholdAmount, \"LOP: making amount too low\");\n        }\n\n        require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n\n        // Update remaining amount in storage\n        remainingMakerAmount = remainingMakerAmount.sub(makingAmount, \"LOP: taking > remaining\");\n        _remaining[orderHash] = remainingMakerAmount + 1;\n        emit OrderFilled(msg.sender, orderHash, remainingMakerAmount);\n\n        // Taker => Maker\n        _callTakerAssetTransferFrom(order.takerAsset, order.takerAssetData, msg.sender, takingAmount);\n\n        // Maker can handle funds interactively\n        if (order.interaction.length > 0) {\n            InteractiveMaker(order.makerAssetData.decodeAddress(_FROM_INDEX))\n                .notifyFillOrder(order.makerAsset, order.takerAsset, makingAmount, takingAmount, order.interaction);\n        }\n\n        // Maker => Taker\n        _callMakerAssetTransferFrom(order.makerAsset, order.makerAssetData, msg.sender, makingAmount);\n\n        return (makingAmount, takingAmount);","after":"a\n    function fillOrder(Order calldata order, bytes calldata signature, uint256 makingAmount, uint256 takingAmount, uint256 thresholdAmount) external returns(uint256, uint256) {\n        bytes32 orderHash = _hash(order);\n\n        uint256 remainingMakerAmount;\n        { // Stack too deep\n            bool orderExists;\n            (orderExists, remainingMakerAmount) = _remaining[orderHash].trySub(1);\n            if (!orderExists) {\n                // First fill: validate order and permit maker asset\n                _validate(order.makerAssetData, order.takerAssetData, signature, orderHash);\n                remainingMakerAmount = order.makerAssetData.decodeUint256(_AMOUNT_INDEX);\n                if (order.permit.length > 0) {\n                    (address token, bytes memory permit) = abi.decode(order.permit, (address, bytes));\n                    token.uncheckedFunctionCall(abi.encodePacked(IERC20Permit.permit.selector, permit), \"LOP: permit failed\");\n                    require(_remaining[orderHash] == 0, \"LOP: reentrancy detected\");\n                }\n            }\n        }\n\n        // Check if order is valid\n        if (order.predicate.length > 0) {\n            require(checkPredicate(order), \"LOP: predicate returned false\");\n        }\n\n        // Compute maker and taker assets amount\n        if ((takingAmount == 0) == (makingAmount == 0)) {\n            revert(\"LOP: only one amount should be 0\");\n        }\n        else if (takingAmount == 0) {\n            takingAmount = _callGetTakerAmount(order, makingAmount);\n            require(takingAmount <= thresholdAmount, \"LOP: taking amount too high\");\n        }\n        else {\n            makingAmount = _callGetMakerAmount(order, takingAmount);\n            require(makingAmount >= thresholdAmount, \"LOP: making amount too low\");\n        }\n\n        require(makingAmount > 0 && takingAmount > 0, \"LOP: can't swap 0 amount\");\n\n        // Update remaining amount in storage\n        remainingMakerAmount = remainingMakerAmount.sub(makingAmount, \"LOP: taking > remaining\");\n        _remaining[orderHash] = remainingMakerAmount + 1;\n        emit OrderFilled(msg.sender, orderHash, remainingMakerAmount);\n\n        // Taker => Maker\n        _callTakerAssetTransferFrom(order.takerAsset, order.takerAssetData, msg.sender, takingAmount);\n\n        // Maker can handle funds interactively\n        if (order.interaction.length > 0) {\n            InteractiveMaker(order.makerAssetData.decodeAddress(_FROM_INDEX))\n                .notifyFillOrder(order.makerAsset, order.takerAsset, makingAmount, takingAmount, order.interaction);\n        }\n\n        // Maker => Taker\n        _callMakerAssetTransferFrom(order.makerAsset, order.makerAssetData, msg.sender, makingAmount);\n\n        return (makingAmount, takingAmount);","contract":"LimitOrderProtocol","time":0},{"type":"constant-restrict-modification  ","before":"e\n    bytes4 immutable private _MAX_SELECTOR = bytes4(uint32(IERC20.transferFrom.selector) ","after":"e\n    bytes4 immutable private constant _MAX_SELECTOR = bytes4(uint32(IERC20.transferFrom.selector) ","contract":"LimitOrderProtocol","time":1}]}