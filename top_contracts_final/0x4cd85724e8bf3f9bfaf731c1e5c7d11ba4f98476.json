{"time":35,"results":[{"type":"external-function ","before":"function redeemParcels(uint256 tokenId, bytes32[] memory proof) public {\r\n        require(merkleRoot != 0, \"ParcelMinter: no MerkleRoot yet\");\r\n        require(isMinted[tokenId] == false, \"ParcelMinter: Already Minted\");\r\n        require(proof.verify(merkleRoot, keccak256(abi.encodePacked(msg.sender, tokenId))), \"ParcelMinter: Not Allocated\");\r\n\r\n        address minter = msg.sender;\r\n\r\n        isMinted[tokenId] = true;\r\n\r\n        netvrkMap.mint(minter, tokenId);\r\n        emit ParcelMinted(minter, tokenId);\r\n    }","after":"function redeemParcels(uint256 tokenId, bytes32[] calldata proof) public {\r\n        require(merkleRoot != 0, \"ParcelMinter: no MerkleRoot yet\");\r\n        require(isMinted[tokenId] == false, \"ParcelMinter: Already Minted\");\r\n        require(proof.verify(merkleRoot, keccak256(abi.encodePacked(msg.sender, tokenId))), \"ParcelMinter: Not Allocated\");\r\n\r\n        address minter = msg.sender;\r\n\r\n        isMinted[tokenId] = true;\r\n\r\n        netvrkMap.mint(minter, tokenId);\r\n        emit ParcelMinted(minter, tokenId);\r\n    }","contract":"ParcelMinter","time":0},{"type":"external-function ","before":"function batchRedeemParcels(uint256[] calldata tokenIds, bytes32[][] memory proofs) public {\r\n        require(merkleRoot != 0, \"ParcelMinter: no MerkleRoot yet\");\r\n        uint256 tokenId;        \r\n        address minter = msg.sender;\r\n\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            tokenId = tokenIds[i];\r\n            require(proofs[i].verify(merkleRoot, keccak256(abi.encodePacked(minter,tokenId))), \"ParcelMinter: Not Allocated\");\r\n            require(isMinted[tokenId] == false, \"ParcelMinter: Already Minted\");\r\n            isMinted[tokenId] = true;\r\n\r\n            netvrkMap.mint(minter, tokenId);\r\n            emit ParcelMinted(minter, tokenId);\r\n        }\r\n    }","after":"function batchRedeemParcels(uint256[] calldata tokenIds, bytes32[][] calldata proofs) public {\r\n        require(merkleRoot != 0, \"ParcelMinter: no MerkleRoot yet\");\r\n        uint256 tokenId;        \r\n        address minter = msg.sender;\r\n\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            tokenId = tokenIds[i];\r\n            require(proofs[i].verify(merkleRoot, keccak256(abi.encodePacked(minter,tokenId))), \"ParcelMinter: Not Allocated\");\r\n            require(isMinted[tokenId] == false, \"ParcelMinter: Already Minted\");\r\n            isMinted[tokenId] = true;\r\n\r\n            netvrkMap.mint(minter, tokenId);\r\n            emit ParcelMinted(minter, tokenId);\r\n        }\r\n    }","contract":"ParcelMinter","time":0}]}