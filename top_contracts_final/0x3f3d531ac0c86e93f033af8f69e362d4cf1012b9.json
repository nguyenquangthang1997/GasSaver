{"time":265,"results":[{"type":"state-data-arrangement ","before":"\nuint256 constant MAX_LEVELS = 5;\nuint256 constant MAX_MOB_CARDS_PER_CHARACTER = 17;\nuint256 constant MAX_BOSS_CARDS_PER_CHARACTER = 17;\nuint256 constant MAX_HERO_CARDS_PER_CHARACTER = 1;\nuint256 constant CHARACTER_SLOT_SIZE = 100;\nuint256 constant BOSS_OFFSET = 100000;\nuint256 constant HERO_OFFSET = 200000;\nuint256 constant LEVEL_OFFSET = 10000;\nuint256 constant MOB_CHARACTERS = 15;\nuint256 constant BOSS_CHARACTERS = 8;\nuint256 constant HERO_CHARACTERS = 1;\nuint256 constant MOB_START_LEVEL = 0;\nuint256 constant BOSS_START_LEVEL = 2;\nuint256 constant HERO_START_LEVEL = 4;\naddress payable public treasuryAddress;\nmapping (address => bool) isWhitelisted;\nmapping (address => bool) usedWhitelist;\nmapping (address => uint) mintedCardsQty;\nuint public maximumMintPerWallet;\nuint public mintPrice;\nbool public presaleOpen = false;\nbool public publicSaleOpen = false;\nuint256 randomSeed;\nAllocationState[MAX_LEVELS] state;","after":"uint256 constant MAX_LEVELS = 5;\nuint256 constant MAX_MOB_CARDS_PER_CHARACTER = 17;\nuint256 constant MAX_BOSS_CARDS_PER_CHARACTER = 17;\nuint256 constant MAX_HERO_CARDS_PER_CHARACTER = 1;\nuint256 constant CHARACTER_SLOT_SIZE = 100;\nuint256 constant BOSS_OFFSET = 100000;\nuint256 constant HERO_OFFSET = 200000;\nuint256 constant LEVEL_OFFSET = 10000;\nuint256 constant MOB_CHARACTERS = 15;\nuint256 constant BOSS_CHARACTERS = 8;\nuint256 constant HERO_CHARACTERS = 1;\nuint256 constant MOB_START_LEVEL = 0;\nuint256 constant BOSS_START_LEVEL = 2;\nuint256 constant HERO_START_LEVEL = 4;\nmapping (address => bool) isWhitelisted;\nmapping (address => bool) usedWhitelist;\nmapping (address => uint) mintedCardsQty;\nuint public maximumMintPerWallet;\nuint public mintPrice;\nuint256 randomSeed;\nAllocationState[MAX_LEVELS] state;\naddress payable public treasuryAddress;\nbool public presaleOpen = false;\nbool public publicSaleOpen = false;\n","contract":"Hero","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"Hero","time":0},{"type":"immutable-restrict-modification ","before":"address payable public treasuryAddress;","after":"address payable public immutable treasuryAddress;","contract":"Hero","time":2},{"type":"immutable-restrict-modification ","before":"uint public maximumMintPerWallet;","after":"uint public immutable maximumMintPerWallet;","contract":"Hero","time":2},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"Hero","time":2}]}