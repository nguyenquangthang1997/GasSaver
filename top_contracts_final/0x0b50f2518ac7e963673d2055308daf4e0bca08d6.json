{"time":193,"results":[{"type":"state-data-arrangement ","before":"\nstring public baseURI;\nbool public isBaseURIset = false;\nuint256 public mintPrice = 20000000000000000;\nuint256 public editPrice = 0;\nuint16 constant MAX_TOKEN_ID = 9999;\nuint256 public earlyAccessWindowOpens = 1641916800;\nuint256 public gameStartWindowOpens  = 1641920400;\nuint16 public freeMintCount = 1000;\nuint8 public maxBatchMintCount = 20;\nbool public paused = false;\nuint16 public apeTotal;\nuint16 public punkTotal;\nmapping (uint16 => TokenInfo) public tokenInfo;","after":"string public baseURI;\nuint256 public mintPrice = 20000000000000000;\nuint256 public editPrice = 0;\nuint256 public earlyAccessWindowOpens = 1641916800;\nuint256 public gameStartWindowOpens  = 1641920400;\nmapping (uint16 => TokenInfo) public tokenInfo;\nuint16 constant MAX_TOKEN_ID = 9999;\nuint16 public freeMintCount = 1000;\nuint16 public apeTotal;\nuint16 public punkTotal;\nbool public isBaseURIset = false;\nuint8 public maxBatchMintCount = 20;\nbool public paused = false;\n","contract":"ShuffleWar","time":1},{"type":"external-function ","before":"function verifyAndMintItem(uint16 tokenId, \n        uint8 tokenType, \n        bytes memory moves, \n        uint256[] memory _movesData,\n        uint16 shuffleIterationCount,\n        uint16[] memory batchMintTokens)\n      external\n      payable\n  {\n\n      require(!paused, \"Minting paused\");\n\n      require(block.timestamp >= earlyAccessWindowOpens, \"Game not started\");\n      require(block.timestamp >= gameStartWindowOpens || getTotalMintedCount() < freeMintCount, \"EA limit reached\");\n\n      uint8 totalMintCount = uint8(batchMintTokens.length) + 1;\n      require(msg.value == getMintPrice(totalMintCount), \"Incorrect payment\");\n\n      require(!(_exists(tokenId)), \"Already minted\");\n      require(tokenId > 0 && tokenId <= MAX_TOKEN_ID, \"Invalid tokenId\");\n      require(tokenType == 0 || tokenType == 1, \"Invalid tokenType\");\n\n      require(batchMintTokens.length <= maxBatchMintCount, \"Token limit exceeded\");\n\n      require (verifyMoves(tokenId, moves, shuffleIterationCount), \"Puzzle not solved, unable to verify moves\");\n\n      for (uint8 i = 0; i < batchMintTokens.length; i++) {\n          uint16 nextMintTokenId = batchMintTokens[i];\n          require(!(_exists(nextMintTokenId)), \"Already minted\");\n          require(nextMintTokenId > 0 && nextMintTokenId <= MAX_TOKEN_ID, \"Invalid tokenId\");\n          tokenInfo[nextMintTokenId] = TokenInfo(tokenType, false, tokenId, _movesData);\n          _safeMint(msg.sender, nextMintTokenId);\n          emit NftMinted(msg.sender, nextMintTokenId);\n      }\n\n      tokenInfo[tokenId] = TokenInfo(tokenType, false, 0, _movesData);\n      _safeMint(msg.sender, tokenId);\n      emit NftMinted(msg.sender, tokenId);\n\n      if (tokenType == 0) {\n          apeTotal += totalMintCount;\n      } else {\n          punkTotal += totalMintCount;\n      }\n  }","after":"function verifyAndMintItem(uint16 tokenId, \n        uint8 tokenType, \n        bytes calldata moves, \n        uint256[] calldata _movesData,\n        uint16 shuffleIterationCount,\n        uint16[] calldata batchMintTokens)\n      external\n      payable\n  {\n\n      require(!paused, \"Minting paused\");\n\n      require(block.timestamp >= earlyAccessWindowOpens, \"Game not started\");\n      require(block.timestamp >= gameStartWindowOpens || getTotalMintedCount() < freeMintCount, \"EA limit reached\");\n\n      uint8 totalMintCount = uint8(batchMintTokens.length) + 1;\n      require(msg.value == getMintPrice(totalMintCount), \"Incorrect payment\");\n\n      require(!(_exists(tokenId)), \"Already minted\");\n      require(tokenId > 0 && tokenId <= MAX_TOKEN_ID, \"Invalid tokenId\");\n      require(tokenType == 0 || tokenType == 1, \"Invalid tokenType\");\n\n      require(batchMintTokens.length <= maxBatchMintCount, \"Token limit exceeded\");\n\n      require (verifyMoves(tokenId, moves, shuffleIterationCount), \"Puzzle not solved, unable to verify moves\");\n\n      for (uint8 i = 0; i < batchMintTokens.length; i++) {\n          uint16 nextMintTokenId = batchMintTokens[i];\n          require(!(_exists(nextMintTokenId)), \"Already minted\");\n          require(nextMintTokenId > 0 && nextMintTokenId <= MAX_TOKEN_ID, \"Invalid tokenId\");\n          tokenInfo[nextMintTokenId] = TokenInfo(tokenType, false, tokenId, _movesData);\n          _safeMint(msg.sender, nextMintTokenId);\n          emit NftMinted(msg.sender, nextMintTokenId);\n      }\n\n      tokenInfo[tokenId] = TokenInfo(tokenType, false, 0, _movesData);\n      _safeMint(msg.sender, tokenId);\n      emit NftMinted(msg.sender, tokenId);\n\n      if (tokenType == 0) {\n          apeTotal += totalMintCount;\n      } else {\n          punkTotal += totalMintCount;\n      }\n  }","contract":"ShuffleWar","time":0},{"type":"external-function ","before":"function setBaseURI(string memory _newBaseURI) external onlyOwner {\n    require(!isBaseURIset, \"Base URI is locked\");\n    baseURI = _newBaseURI;\n  }","after":"function setBaseURI(string calldata _newBaseURI) external onlyOwner {\n    require(!isBaseURIset, \"Base URI is locked\");\n    baseURI = _newBaseURI;\n  }","contract":"ShuffleWar","time":0},{"type":"external-function ","before":"function editMoves(\n        uint16 tokenId, \n        uint8 tokenType, \n        bytes memory moves, \n        uint256[] memory _movesData, \n        uint16 shuffleIterationCount\n    ) external payable {\n\n    require(_exists(tokenId), \"EditMoves: TokenId doesn't exist\");\n    require(tokenInfo[uint16(tokenId)].editAllowed, \"EditMoves: Not allowed to edit moves\");\n    require(msg.sender == ownerOf(tokenId), \"Not authorised to edit token type\");\n    require(msg.value == editPrice, \"Incorrect payment\");\n    require(tokenType == 0 || tokenType == 1, \"Invalid tokenType\");\n    require (verifyMoves(tokenId, moves, shuffleIterationCount), \"Puzzle not solved, unable to verify moves\");\n\n    tokenInfo[tokenId] = TokenInfo(tokenType, false, 0, _movesData);\n  }","after":"function editMoves(\n        uint16 tokenId, \n        uint8 tokenType, \n        bytes calldata moves, \n        uint256[] calldata _movesData, \n        uint16 shuffleIterationCount\n    ) external payable {\n\n    require(_exists(tokenId), \"EditMoves: TokenId doesn't exist\");\n    require(tokenInfo[uint16(tokenId)].editAllowed, \"EditMoves: Not allowed to edit moves\");\n    require(msg.sender == ownerOf(tokenId), \"Not authorised to edit token type\");\n    require(msg.value == editPrice, \"Incorrect payment\");\n    require(tokenType == 0 || tokenType == 1, \"Invalid tokenType\");\n    require (verifyMoves(tokenId, moves, shuffleIterationCount), \"Puzzle not solved, unable to verify moves\");\n\n    tokenInfo[tokenId] = TokenInfo(tokenType, false, 0, _movesData);\n  }","contract":"ShuffleWar","time":0}]}