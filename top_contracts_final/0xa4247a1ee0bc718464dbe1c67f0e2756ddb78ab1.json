{"time":326,"results":[{"type":"state-data-arrangement ","before":"\naddress dataContract;\naddress percentageContract;\naddress vaultContract;\naddress levelUpContract;\nmapping(uint => bool) private _usedVaults;\nmapping(address => uint) private _whitelistMinters;\nbytes32[] public rootHashes;\nuint public constant maxTokens = 5000;\nuint public vaultHolderReserves = 500;\nuint[] public rarities;\nuint public total = 0;\nuint mintCost = 0.05 ether;\nuint publicMintCost = 0.1 ether;\nuint public whitelistMintStart;\nuint public publicMintStart;\nbool sysAdminMinted;\nbool error404Minted;\nbool code200Minted;\nbool giveawaysMinted;\naddress error404Address;\naddress code200Address;\naddress giveawaysAddress;\nmapping(uint => uint) public levels;\nmapping(uint => uint) public rarity;\nstring[] private rarityText = [\n        \"Common\",\n        \"Uncommon\",\n        \"Rare\",\n        \"Epic\",\n        \"Legendary\"\n    ];\nstring[] private firstStat = [\n        \"Health\",\n        \"Strength\",\n        \"Speed\",\n        \"Accuracy\",\n        \"Intelligence\",\n        \"Tech\",\n        \"Hack speed\",\n        \"SQL skill\",\n        \"Network\",\n        \"DNA\",\n        \"De-auth\",\n        \"Pwd cracking\",\n        \"XSS forgery\",\n        \"Decrypt\",\n        \"Cryptography\"\n    ];\nstring[] private secondStat = [\n        \"Lockpicking\",\n        \"Regeneration\",\n        \"Armor\",\n        \"Backpack\",\n        \"Intelligence\",\n        \"Charge\",\n        \"Damage boost\",\n        \"Reflexes\",\n        \"Radar\",\n        \"Keymaster\",\n        \"Pickpocket\",\n        \"EMP shield\",\n        \"EMP power\",\n        \"Run silent\",\n        \"Nanotech\"\n    ];\nstring[] private firstAugment = [\n        \"Scrapper\",\n        \"Bionic Arms\",\n        \"Detoxifier\",\n        \"Bionic Lungs\",\n        \"Hardened Bones\",\n        \"Berserk\",\n        \"Blood pump\",\n        \"Edge runner\",\n        \"Adrenaline Pump\",\n        \"Bloodware\",\n        \"Cyber Joints\",\n        \"Cloaking\",\n        \"Nanobots\",\n        \"Synthetic Heart\",\n        \"?\"\n    ];\nstring[] private secondAugment = [\n        \"Nightvision\",\n        \"Titan Knuckles\",\n        \"Cyber Legs\",\n        \"Cyber Arms\",\n        \"Reflex Boost\",\n        \"Lizard skin\",\n        \"Titanium Bones\",\n        \"Echolocation\",\n        \"Thermal vision\",\n        \"X-ray Vision\",\n        \"Shapeshifter\",\n        \"Exoskeleton\",\n        \"Stealth kit\",\n        \"Double Heart\",\n        \"?\"\n    ];\nstring internal baseTokenURI;\nstring internal externalURI;\nbytes32 internal keyHash;\nuint internal fee;\nuint internal randomResult;\nuint[maxTokens] internal indices;\nuint32 internal nonce;","after":"mapping(uint => bool) private _usedVaults;\nmapping(address => uint) private _whitelistMinters;\nbytes32[] public rootHashes;\nuint public constant maxTokens = 5000;\nuint public vaultHolderReserves = 500;\nuint[] public rarities;\nuint public total = 0;\nuint mintCost = 0.05 ether;\nuint publicMintCost = 0.1 ether;\nuint public whitelistMintStart;\nuint public publicMintStart;\nmapping(uint => uint) public levels;\nmapping(uint => uint) public rarity;\nstring[] private rarityText = [\n        \"Common\",\n        \"Uncommon\",\n        \"Rare\",\n        \"Epic\",\n        \"Legendary\"\n    ];\nstring[] private firstStat = [\n        \"Health\",\n        \"Strength\",\n        \"Speed\",\n        \"Accuracy\",\n        \"Intelligence\",\n        \"Tech\",\n        \"Hack speed\",\n        \"SQL skill\",\n        \"Network\",\n        \"DNA\",\n        \"De-auth\",\n        \"Pwd cracking\",\n        \"XSS forgery\",\n        \"Decrypt\",\n        \"Cryptography\"\n    ];\nstring[] private secondStat = [\n        \"Lockpicking\",\n        \"Regeneration\",\n        \"Armor\",\n        \"Backpack\",\n        \"Intelligence\",\n        \"Charge\",\n        \"Damage boost\",\n        \"Reflexes\",\n        \"Radar\",\n        \"Keymaster\",\n        \"Pickpocket\",\n        \"EMP shield\",\n        \"EMP power\",\n        \"Run silent\",\n        \"Nanotech\"\n    ];\nstring[] private firstAugment = [\n        \"Scrapper\",\n        \"Bionic Arms\",\n        \"Detoxifier\",\n        \"Bionic Lungs\",\n        \"Hardened Bones\",\n        \"Berserk\",\n        \"Blood pump\",\n        \"Edge runner\",\n        \"Adrenaline Pump\",\n        \"Bloodware\",\n        \"Cyber Joints\",\n        \"Cloaking\",\n        \"Nanobots\",\n        \"Synthetic Heart\",\n        \"?\"\n    ];\nstring[] private secondAugment = [\n        \"Nightvision\",\n        \"Titan Knuckles\",\n        \"Cyber Legs\",\n        \"Cyber Arms\",\n        \"Reflex Boost\",\n        \"Lizard skin\",\n        \"Titanium Bones\",\n        \"Echolocation\",\n        \"Thermal vision\",\n        \"X-ray Vision\",\n        \"Shapeshifter\",\n        \"Exoskeleton\",\n        \"Stealth kit\",\n        \"Double Heart\",\n        \"?\"\n    ];\nstring internal baseTokenURI;\nstring internal externalURI;\nbytes32 internal keyHash;\nuint internal fee;\nuint internal randomResult;\nuint[maxTokens] internal indices;\naddress dataContract;\naddress percentageContract;\naddress vaultContract;\naddress levelUpContract;\naddress error404Address;\naddress code200Address;\naddress giveawaysAddress;\nuint32 internal nonce;\nbool sysAdminMinted;\nbool error404Minted;\nbool code200Minted;\nbool giveawaysMinted;\n","contract":"ConsoleNFT_Cyber_Upgrades","time":31},{"type":"external-function ","before":"function setMerkleHashes(bytes32[] memory _rootHash) external onlyOwner {\n        rootHashes = new bytes32[](0);\n        for (uint i=0; i < _rootHash.length; i++) {\n            rootHashes.push(_rootHash[i]);\n        }\n    }","after":"function setMerkleHashes(bytes32[] calldata _rootHash) external onlyOwner {\n        rootHashes = new bytes32[](0);\n        for (uint i=0; i < _rootHash.length; i++) {\n            rootHashes.push(_rootHash[i]);\n        }\n    }","contract":"ConsoleNFT_Cyber_Upgrades","time":0},{"type":"external-function ","before":"function setBaseTokenURI(string memory _uri) external onlyOwner {\n        baseTokenURI = _uri;\n    }","after":"function setBaseTokenURI(string calldata _uri) external onlyOwner {\n        baseTokenURI = _uri;\n    }","contract":"ConsoleNFT_Cyber_Upgrades","time":0},{"type":"external-function ","before":"function setExternalURI(string memory _uri) external onlyOwner {\n        externalURI = _uri;\n    }","after":"function setExternalURI(string calldata _uri) external onlyOwner {\n        externalURI = _uri;\n    }","contract":"ConsoleNFT_Cyber_Upgrades","time":0},{"type":"external-function ","before":"function whitelistClaim(bytes32[] memory proof) public nonReentrant payable {\n        require(whitelistMintStart < block.timestamp, \"The whitelist mint did not start yet\");\n        require(maxTokens - total > vaultHolderReserves, \"Minting over vault holder limit\");\n        require(total < maxTokens, \"All tokens have been already minted\");\n\t\trequire(msg.value == mintCost, \"Incorrect mint cost value\");\n        require(_whitelistMinters[_msgSender()] < 1, \"You've already minted\");\n\t\t\n\t\t// Merkle tree validation\n\t\tbytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n\n        bool notWhitelisted;\n\n        for (uint i=0; i < rootHashes.length; i++) {\n\n            if (MerkleProof.verify(proof, rootHashes[i], leaf)) {\n\n                uint userTokens = i * 1000;\n                \n                // Proceed in minting process\n                uint tokenId = getVRFRandomIndex(false, 0, userTokens);\n                total++;\n\n                // Set the _whitelistMinters value to tokenId for this address as it has minted\n                _whitelistMinters[_msgSender()] = tokenId;\n\n                _safeMint(_msgSender(), tokenId);\n\n                notWhitelisted = false;\n                break;\n\n            }\n            else {\n                notWhitelisted = true;\n            }\n        }\n\n        if (notWhitelisted) {\n            // Sorry, not whitelisted\n            revert(\"Invalid proof\");\n        }\n\n    }","after":"function whitelistClaim(bytes32[] calldata proof) public nonReentrant payable {\n        require(whitelistMintStart < block.timestamp, \"The whitelist mint did not start yet\");\n        require(maxTokens - total > vaultHolderReserves, \"Minting over vault holder limit\");\n        require(total < maxTokens, \"All tokens have been already minted\");\n\t\trequire(msg.value == mintCost, \"Incorrect mint cost value\");\n        require(_whitelistMinters[_msgSender()] < 1, \"You've already minted\");\n\t\t\n\t\t// Merkle tree validation\n\t\tbytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n\n        bool notWhitelisted;\n\n        for (uint i=0; i < rootHashes.length; i++) {\n\n            if (MerkleProof.verify(proof, rootHashes[i], leaf)) {\n\n                uint userTokens = i * 1000;\n                \n                // Proceed in minting process\n                uint tokenId = getVRFRandomIndex(false, 0, userTokens);\n                total++;\n\n                // Set the _whitelistMinters value to tokenId for this address as it has minted\n                _whitelistMinters[_msgSender()] = tokenId;\n\n                _safeMint(_msgSender(), tokenId);\n\n                notWhitelisted = false;\n                break;\n\n            }\n            else {\n                notWhitelisted = true;\n            }\n        }\n\n        if (notWhitelisted) {\n            // Sorry, not whitelisted\n            revert(\"Invalid proof\");\n        }\n\n    }","contract":"ConsoleNFT_Cyber_Upgrades","time":0},{"type":"external-function ","before":"function vaultHolderClaim(bytes32[] memory proof, uint[] memory vaultIds) public nonReentrant {\n        require(whitelistMintStart < block.timestamp, \"The whitelist mint did not start yet\");\n        require(total + vaultIds.length < maxTokens, \"Minting over the max tokens limit\");\n\n        for (uint i=0; i < vaultIds.length; i++) {\n            require(validateVaultOwnership(vaultIds[i]), \"Vault ownership validation failed\");\n            require(!checkUsedVault(vaultIds[i]), \"Vault was already used\");\n        }\n\n        uint userTokens = 0;\n\n        // Merkle tree for getting tokens\n\t\tbytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n\n        for (uint i=0; i < rootHashes.length; i++) {\n\n            if (MerkleProof.verify(proof, rootHashes[i], leaf) ) {\n\n                userTokens = i * 1000;\n\n            }\n\n        }\n\n        for (uint i=0; i < vaultIds.length; i++) {\n\n            // get vault rarity\n            uint tokenId = getVRFRandomIndex(true, getVaultRarity(vaultIds[i]), userTokens);\n            _usedVaults[vaultIds[i]] = true;\n\n            total++;\n            vaultHolderReserves--;\n            _safeMint(_msgSender(), tokenId);\n        }\n\n    }","after":"function vaultHolderClaim(bytes32[] calldata proof, uint[] calldata vaultIds) public nonReentrant {\n        require(whitelistMintStart < block.timestamp, \"The whitelist mint did not start yet\");\n        require(total + vaultIds.length < maxTokens, \"Minting over the max tokens limit\");\n\n        for (uint i=0; i < vaultIds.length; i++) {\n            require(validateVaultOwnership(vaultIds[i]), \"Vault ownership validation failed\");\n            require(!checkUsedVault(vaultIds[i]), \"Vault was already used\");\n        }\n\n        uint userTokens = 0;\n\n        // Merkle tree for getting tokens\n\t\tbytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n\n        for (uint i=0; i < rootHashes.length; i++) {\n\n            if (MerkleProof.verify(proof, rootHashes[i], leaf) ) {\n\n                userTokens = i * 1000;\n\n            }\n\n        }\n\n        for (uint i=0; i < vaultIds.length; i++) {\n\n            // get vault rarity\n            uint tokenId = getVRFRandomIndex(true, getVaultRarity(vaultIds[i]), userTokens);\n            _usedVaults[vaultIds[i]] = true;\n\n            total++;\n            vaultHolderReserves--;\n            _safeMint(_msgSender(), tokenId);\n        }\n\n    }","contract":"ConsoleNFT_Cyber_Upgrades","time":0},{"type":"external-function ","before":"function vaultHolderClaimCombined(bytes32[] memory proof, uint[] memory vaultIds) public nonReentrant payable {\n        require(whitelistMintStart < block.timestamp, \"The whitelist mint did not start yet\");\n        require(total + 1 + vaultIds.length < maxTokens, \"Minting over the max tokens limit\");\n        require(msg.value == mintCost, \"Incorrect mint cost value\");\n        require(_whitelistMinters[_msgSender()] < 1, \"You've already minted\");\n\n        for (uint i=0; i < vaultIds.length; i++) {\n            require(validateVaultOwnership(vaultIds[i]), \"Vault ownership validation failed\");\n            require(!checkUsedVault(vaultIds[i]), \"Vault was already used\");\n        }\n\n        uint userTokens = 0;\n\n        // Merkle tree for getting tokens\n\t\tbytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n\n        for (uint i=0; i < rootHashes.length; i++) {\n\n            if (MerkleProof.verify(proof, rootHashes[i], leaf) ) {\n\n                userTokens = i * 1000;\n\n            }\n\n        }\n\n        // Continue minting process\n        for (uint i=0; i < vaultIds.length; i++) {\n            uint tokenId = getVRFRandomIndex(true, getVaultRarity(vaultIds[i]), userTokens);\n            _usedVaults[vaultIds[i]] = true;\n\n            total++;\n            vaultHolderReserves--;\n            _safeMint(_msgSender(), tokenId);\n        }\n\n        // + 1 for whitelist\n        uint additionalTokenId = getVRFRandomIndex(false, 0, userTokens);\n        total++;\n        _whitelistMinters[_msgSender()] = additionalTokenId;\n        _safeMint(_msgSender(), additionalTokenId);\n\n    }","after":"function vaultHolderClaimCombined(bytes32[] calldata proof, uint[] calldata vaultIds) public nonReentrant payable {\n        require(whitelistMintStart < block.timestamp, \"The whitelist mint did not start yet\");\n        require(total + 1 + vaultIds.length < maxTokens, \"Minting over the max tokens limit\");\n        require(msg.value == mintCost, \"Incorrect mint cost value\");\n        require(_whitelistMinters[_msgSender()] < 1, \"You've already minted\");\n\n        for (uint i=0; i < vaultIds.length; i++) {\n            require(validateVaultOwnership(vaultIds[i]), \"Vault ownership validation failed\");\n            require(!checkUsedVault(vaultIds[i]), \"Vault was already used\");\n        }\n\n        uint userTokens = 0;\n\n        // Merkle tree for getting tokens\n\t\tbytes32 leaf = keccak256(abi.encodePacked(msg.sender));\n\n        for (uint i=0; i < rootHashes.length; i++) {\n\n            if (MerkleProof.verify(proof, rootHashes[i], leaf) ) {\n\n                userTokens = i * 1000;\n\n            }\n\n        }\n\n        // Continue minting process\n        for (uint i=0; i < vaultIds.length; i++) {\n            uint tokenId = getVRFRandomIndex(true, getVaultRarity(vaultIds[i]), userTokens);\n            _usedVaults[vaultIds[i]] = true;\n\n            total++;\n            vaultHolderReserves--;\n            _safeMint(_msgSender(), tokenId);\n        }\n\n        // + 1 for whitelist\n        uint additionalTokenId = getVRFRandomIndex(false, 0, userTokens);\n        total++;\n        _whitelistMinters[_msgSender()] = additionalTokenId;\n        _safeMint(_msgSender(), additionalTokenId);\n\n    }","contract":"ConsoleNFT_Cyber_Upgrades","time":0},{"type":"constant-restrict-modification  ","before":"uint mintCost = 0.05 ether;","after":"uint constant mintCost = 0.05 ether;","contract":"ConsoleNFT_Cyber_Upgrades","time":1},{"type":"constant-restrict-modification  ","before":"uint publicMintCost = 0.1 ether;","after":"uint constant publicMintCost = 0.1 ether;","contract":"ConsoleNFT_Cyber_Upgrades","time":1},{"type":"immutable-restrict-modification ","before":"address error404Address;","after":"address immutable error404Address;","contract":"ConsoleNFT_Cyber_Upgrades","time":1},{"type":"immutable-restrict-modification ","before":"address code200Address;","after":"address immutable code200Address;","contract":"ConsoleNFT_Cyber_Upgrades","time":1},{"type":"immutable-restrict-modification ","before":"address giveawaysAddress;","after":"address immutable giveawaysAddress;","contract":"ConsoleNFT_Cyber_Upgrades","time":1},{"type":"immutable-restrict-modification ","before":"bytes32 internal keyHash;","after":"bytes32 internal immutable keyHash;","contract":"ConsoleNFT_Cyber_Upgrades","time":1},{"type":"immutable-restrict-modification ","before":"uint internal fee;","after":"uint internal immutable fee;","contract":"ConsoleNFT_Cyber_Upgrades","time":1}]}