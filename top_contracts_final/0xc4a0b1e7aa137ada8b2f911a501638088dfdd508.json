{"time":277,"results":[{"type":"de-morgan-condition ","before":"!(char >= 0x30 && char <= 0x39) && //9-0\r\n                !(char >= 0x41 && char <= 0x5A)","after":"!((char >= 0x30 && char <= 0x39) && //9-0\r\n                (char >= 0x41 && char <= 0x5A))","loc":{"start":{"line":2611,"column":16},"end":{"line":2612,"column":46}},"contract":"UninterestedUnicorns","time":0},{"type":"external-function ","before":"function airdrop(address[] memory _to) external onlyAdmin {\r\n        for (uint256 i = 0; i < _to.length; i++) {\r\n            _tokenIds.increment();\r\n            _mint(_to[i], _tokenIds.current());\r\n        }\r\n    }","after":"function airdrop(address[] calldata _to) external onlyAdmin {\r\n        for (uint256 i = 0; i < _to.length; i++) {\r\n            _tokenIds.increment();\r\n            _mint(_to[i], _tokenIds.current());\r\n        }\r\n    }","contract":"UninterestedUnicorns","time":0},{"type":"external-function ","before":"function changeBio(uint256 _tokenId, string memory _bio) public virtual {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_msgSender() == owner, \"ERC721: caller is not the owner\");\r\n\r\n        CANDY_TOKEN.burn(_msgSender(), BIO_CHANGE_PRICE);\r\n\r\n        bio[_tokenId] = _bio;\r\n        emit BioChange(_tokenId, _bio);\r\n    }","after":"function changeBio(uint256 _tokenId, string calldata _bio) public virtual {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_msgSender() == owner, \"ERC721: caller is not the owner\");\r\n\r\n        CANDY_TOKEN.burn(_msgSender(), BIO_CHANGE_PRICE);\r\n\r\n        bio[_tokenId] = _bio;\r\n        emit BioChange(_tokenId, _bio);\r\n    }","contract":"UninterestedUnicorns","time":0},{"type":"external-function ","before":"function changeName(uint256 tokenId, string memory newName) public virtual {\r\n        address owner = ownerOf(tokenId);\r\n        require(_msgSender() == owner, \"ERC721: caller is not the owner\");\r\n        require(validateName(newName) == true, \"Not a valid new name\");\r\n        require(\r\n            sha256(bytes(newName)) != sha256(bytes(tokenName[tokenId])),\r\n            \"New name is same as the current one\"\r\n        );\r\n        require(isNameReserved(newName) == false, \"Name already reserved\");\r\n\r\n        CANDY_TOKEN.burn(_msgSender(), NAME_CHANGE_PRICE);\r\n\r\n        // If already named, dereserve old name\r\n        if (bytes(tokenName[tokenId]).length > 0) {\r\n            toggleReserveName(tokenName[tokenId], false);\r\n        }\r\n        toggleReserveName(newName, true);\r\n        tokenName[tokenId] = newName;\r\n        emit NameChange(tokenId, newName);\r\n    }","after":"function changeName(uint256 tokenId, string calldata newName) public virtual {\r\n        address owner = ownerOf(tokenId);\r\n        require(_msgSender() == owner, \"ERC721: caller is not the owner\");\r\n        require(validateName(newName) == true, \"Not a valid new name\");\r\n        require(\r\n            sha256(bytes(newName)) != sha256(bytes(tokenName[tokenId])),\r\n            \"New name is same as the current one\"\r\n        );\r\n        require(isNameReserved(newName) == false, \"Name already reserved\");\r\n\r\n        CANDY_TOKEN.burn(_msgSender(), NAME_CHANGE_PRICE);\r\n\r\n        // If already named, dereserve old name\r\n        if (bytes(tokenName[tokenId]).length > 0) {\r\n            toggleReserveName(tokenName[tokenId], false);\r\n        }\r\n        toggleReserveName(newName, true);\r\n        tokenName[tokenId] = newName;\r\n        emit NameChange(tokenId, newName);\r\n    }","contract":"UninterestedUnicorns","time":0},{"type":"external-function ","before":"function updateBaseURI(string memory newURI) public onlyAdmin {\r\n        _setBaseURI(newURI);\r\n    }","after":"function updateBaseURI(string calldata newURI) public onlyAdmin {\r\n        _setBaseURI(newURI);\r\n    }","contract":"UninterestedUnicorns","time":0},{"type":"external-function ","before":"function lockTokens(uint8[] memory tokenIds) public onlyQuester {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            _isLocked[tokenIds[i]] = true;\r\n        }\r\n    }","after":"function lockTokens(uint8[] calldata tokenIds) public onlyQuester {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            _isLocked[tokenIds[i]] = true;\r\n        }\r\n    }","contract":"UninterestedUnicorns","time":0},{"type":"external-function ","before":"function unlockTokens(uint8[] memory tokenIds) public onlyQuester {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            _isLocked[tokenIds[i]] = false;\r\n        }\r\n    }","after":"function unlockTokens(uint8[] calldata tokenIds) public onlyQuester {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            _isLocked[tokenIds[i]] = false;\r\n        }\r\n    }","contract":"UninterestedUnicorns","time":0},{"type":"immutable-restrict-modification ","before":"address payable public TREASURY;","after":"address payable public immutable TREASURY;","contract":"UninterestedUnicorns","time":1}]}