{"time":290,"results":[{"type":"state-data-arrangement ","before":"\nstring private baseURI = \"https://api.merrymodz.io/\";\nuint32 private tokenCount;\naddress private signerAddress;\nmapping(string => bool) private isNonceUsed;\nmapping(uint256 => uint256) private _tokenMintedAt;\nmapping(uint256 => uint256) private _tokenLastTransferredAt;\nmapping(uint256 => FKUsage) public fkUsage;\naddress public withdrawalAddress =\r\n        0xdAD835097E934A3B7D0b8528Cc6a29D58BA1D308;\naddress public magicContractAddress;\nmapping(uint256 => uint256) private _magic;\nuint32 public constant TOTAL_SUPPLY = 10000;\nuint32 public constant MINT_LIMIT = 15;\nuint256 public constant PRICE = 0.07 ether;\nbytes32 public firstProvenanceHash;\nuint256 public randomSeed;\nbytes32 public finalProvenanceHash;\nbool public preSaleStarted = false;\nbool public isPresaleActive = false;\nbool public saleStarted = false;\nbool public isSaleActive = false;\nbool public saleHasEnded = false;","after":"string private baseURI = \"https://api.merrymodz.io/\";\nmapping(string => bool) private isNonceUsed;\nmapping(uint256 => uint256) private _tokenMintedAt;\nmapping(uint256 => uint256) private _tokenLastTransferredAt;\nmapping(uint256 => FKUsage) public fkUsage;\nmapping(uint256 => uint256) private _magic;\nuint256 public constant PRICE = 0.07 ether;\nbytes32 public firstProvenanceHash;\nuint256 public randomSeed;\nbytes32 public finalProvenanceHash;\naddress private signerAddress;\naddress public withdrawalAddress =\r\n        0xdAD835097E934A3B7D0b8528Cc6a29D58BA1D308;\naddress public magicContractAddress;\nuint32 private tokenCount;\nuint32 public constant TOTAL_SUPPLY = 10000;\nuint32 public constant MINT_LIMIT = 15;\nbool public preSaleStarted = false;\nbool public isPresaleActive = false;\nbool public saleStarted = false;\nbool public isSaleActive = false;\nbool public saleHasEnded = false;\n","contract":"MerryModz","time":60},{"type":"external-function ","before":"function mint(\r\n        uint8 _amount,\r\n        string memory _nonce,\r\n        bytes memory _signature\r\n    ) external payable onlySignedTx(_amount, _nonce, _signature) nonReentrant {\r\n        require(isSaleActive, \"Sale not active\");\r\n        require(_amount <= (TOTAL_SUPPLY - tokenCount), \"Not enough supply\");\r\n        require(_amount > 0, \"You must mint at least 1\");\r\n        require(\r\n            _amount <= MINT_LIMIT,\r\n            \"Cannot mint more than MINT_LIMIT per transaction\"\r\n        );\r\n        require(\r\n            (balanceOf(msg.sender) + _amount) <= MINT_LIMIT,\r\n            \"Any one wallet cannot hold more than MINT_LIMIT\"\r\n        );\r\n\r\n        require(\r\n            msg.value >= PRICE * _amount,\r\n            \"Insufficient eth to process the order\"\r\n        );\r\n\r\n        if (msg.value > PRICE * _amount) {\r\n            payable(msg.sender).transfer(msg.value - (PRICE * _amount)); // Refund if sent more than required\r\n        }\r\n\r\n        uint256 fromId = tokenCount + 1;\r\n        uint256 toId = tokenCount + _amount;\r\n\r\n        _mintPrivate(msg.sender, _amount);\r\n\r\n        emit Minted(fromId, toId);\r\n    }","after":"function mint(\r\n        uint8 _amount,\r\n        string calldata _nonce,\r\n        bytes calldata _signature\r\n    ) external payable onlySignedTx(_amount, _nonce, _signature) nonReentrant {\r\n        require(isSaleActive, \"Sale not active\");\r\n        require(_amount <= (TOTAL_SUPPLY - tokenCount), \"Not enough supply\");\r\n        require(_amount > 0, \"You must mint at least 1\");\r\n        require(\r\n            _amount <= MINT_LIMIT,\r\n            \"Cannot mint more than MINT_LIMIT per transaction\"\r\n        );\r\n        require(\r\n            (balanceOf(msg.sender) + _amount) <= MINT_LIMIT,\r\n            \"Any one wallet cannot hold more than MINT_LIMIT\"\r\n        );\r\n\r\n        require(\r\n            msg.value >= PRICE * _amount,\r\n            \"Insufficient eth to process the order\"\r\n        );\r\n\r\n        if (msg.value > PRICE * _amount) {\r\n            payable(msg.sender).transfer(msg.value - (PRICE * _amount)); // Refund if sent more than required\r\n        }\r\n\r\n        uint256 fromId = tokenCount + 1;\r\n        uint256 toId = tokenCount + _amount;\r\n\r\n        _mintPrivate(msg.sender, _amount);\r\n\r\n        emit Minted(fromId, toId);\r\n    }","contract":"MerryModz","time":0},{"type":"external-function ","before":"function fkMint(\r\n        uint256[] memory _fkPresaleTokenIds,\r\n        uint256[] memory _fkFreeMintTokenIds,\r\n        uint32 _amount,\r\n        string memory _nonce,\r\n        bytes memory _signature\r\n    )\r\n        external\r\n        payable\r\n        override\r\n        onlySignedTx(_amount, _nonce, _signature)\r\n        nonReentrant\r\n    {\r\n        require(isPresaleActive || isSaleActive, \"No sale active\");\r\n\r\n        uint256[] memory eligibleFKs = itfkPeer.getFoundersKeysByTierIds(\r\n            msg.sender,\r\n            3 // 3 = 011 = Heroic & Legendary\r\n        );\r\n        require(\r\n            arrayContains(eligibleFKs, _fkFreeMintTokenIds) &&\r\n                arrayContains(eligibleFKs, _fkPresaleTokenIds),\r\n            \"Not owner of Heroic or Legendary Founder's Key\"\r\n        );\r\n\r\n        if (isPresaleActive) {\r\n            require(\r\n                arrayContains(_fkPresaleTokenIds, _fkFreeMintTokenIds),\r\n                \"Free minting tokens must be presale tokens\"\r\n            );\r\n            require(\r\n                _amount == _fkPresaleTokenIds.length,\r\n                \"1 mint per Founder's Key during presale\"\r\n            );\r\n            for (uint256 i; i < _fkPresaleTokenIds.length; i++) {\r\n                require(\r\n                    !fkUsage[_fkPresaleTokenIds[i]].presale,\r\n                    \"Founder's Key already used during presale\"\r\n                );\r\n            }\r\n        } else {\r\n            require(_amount > 0, \"You must mint at least 1\");\r\n        }\r\n\r\n        require(_amount <= (TOTAL_SUPPLY - tokenCount), \"Not enough supply\");\r\n\r\n        require(\r\n            (balanceOf(msg.sender) + _amount) <= MINT_LIMIT ||\r\n                (balanceOf(msg.sender) + _amount) <= eligibleFKs.length,\r\n            \"Any one wallet cannot hold more than MINT_LIMIT\"\r\n        );\r\n\r\n        require(\r\n            _amount >= _fkFreeMintTokenIds.length,\r\n            \"You must attempt to mint at least the amount of free mints being used\"\r\n        );\r\n\r\n        uint32 purchaseAmount = uint32(_amount - _fkFreeMintTokenIds.length);\r\n\r\n        if (msg.value > PRICE * purchaseAmount) {\r\n            payable(msg.sender).transfer(msg.value - (PRICE * purchaseAmount)); // Refund if sent more than required\r\n        }\r\n\r\n        if (_fkFreeMintTokenIds.length > 0) {\r\n            _fkFreeMint(_fkFreeMintTokenIds);\r\n        }\r\n\r\n        if (purchaseAmount > 0) {\r\n            _fkPaidMint(_fkPresaleTokenIds, purchaseAmount);\r\n        }\r\n    }","after":"function fkMint(\r\n        uint256[] calldata _fkPresaleTokenIds,\r\n        uint256[] calldata _fkFreeMintTokenIds,\r\n        uint32 _amount,\r\n        string calldata _nonce,\r\n        bytes calldata _signature\r\n    )\r\n        external\r\n        payable\r\n        override\r\n        onlySignedTx(_amount, _nonce, _signature)\r\n        nonReentrant\r\n    {\r\n        require(isPresaleActive || isSaleActive, \"No sale active\");\r\n\r\n        uint256[] memory eligibleFKs = itfkPeer.getFoundersKeysByTierIds(\r\n            msg.sender,\r\n            3 // 3 = 011 = Heroic & Legendary\r\n        );\r\n        require(\r\n            arrayContains(eligibleFKs, _fkFreeMintTokenIds) &&\r\n                arrayContains(eligibleFKs, _fkPresaleTokenIds),\r\n            \"Not owner of Heroic or Legendary Founder's Key\"\r\n        );\r\n\r\n        if (isPresaleActive) {\r\n            require(\r\n                arrayContains(_fkPresaleTokenIds, _fkFreeMintTokenIds),\r\n                \"Free minting tokens must be presale tokens\"\r\n            );\r\n            require(\r\n                _amount == _fkPresaleTokenIds.length,\r\n                \"1 mint per Founder's Key during presale\"\r\n            );\r\n            for (uint256 i; i < _fkPresaleTokenIds.length; i++) {\r\n                require(\r\n                    !fkUsage[_fkPresaleTokenIds[i]].presale,\r\n                    \"Founder's Key already used during presale\"\r\n                );\r\n            }\r\n        } else {\r\n            require(_amount > 0, \"You must mint at least 1\");\r\n        }\r\n\r\n        require(_amount <= (TOTAL_SUPPLY - tokenCount), \"Not enough supply\");\r\n\r\n        require(\r\n            (balanceOf(msg.sender) + _amount) <= MINT_LIMIT ||\r\n                (balanceOf(msg.sender) + _amount) <= eligibleFKs.length,\r\n            \"Any one wallet cannot hold more than MINT_LIMIT\"\r\n        );\r\n\r\n        require(\r\n            _amount >= _fkFreeMintTokenIds.length,\r\n            \"You must attempt to mint at least the amount of free mints being used\"\r\n        );\r\n\r\n        uint32 purchaseAmount = uint32(_amount - _fkFreeMintTokenIds.length);\r\n\r\n        if (msg.value > PRICE * purchaseAmount) {\r\n            payable(msg.sender).transfer(msg.value - (PRICE * purchaseAmount)); // Refund if sent more than required\r\n        }\r\n\r\n        if (_fkFreeMintTokenIds.length > 0) {\r\n            _fkFreeMint(_fkFreeMintTokenIds);\r\n        }\r\n\r\n        if (purchaseAmount > 0) {\r\n            _fkPaidMint(_fkPresaleTokenIds, purchaseAmount);\r\n        }\r\n    }","contract":"MerryModz","time":0},{"type":"external-function ","before":"function giveaway(address[] memory _toArray, uint32 _amount)\r\n        external\r\n        onlyOwner\r\n        nonReentrant\r\n    {\r\n        require(_amount > 0, \"Must mint at least 1\");\r\n        require(\r\n            _toArray.length * _amount <= 100,\r\n            \"Limited to 100 giveaways per transaction\"\r\n        );\r\n        require(\r\n            _toArray.length * _amount <= (TOTAL_SUPPLY - tokenCount),\r\n            \"Exceeds token supply\"\r\n        );\r\n\r\n        uint256 fromId = tokenCount + 1;\r\n        uint256 toId = tokenCount + (_toArray.length * _amount);\r\n\r\n        for (uint256 i; i < _toArray.length; i++) {\r\n            _mintPrivate(_toArray[i], _amount);\r\n        }\r\n\r\n        emit Minted(fromId, toId);\r\n    }","after":"function giveaway(address[] calldata _toArray, uint32 _amount)\r\n        external\r\n        onlyOwner\r\n        nonReentrant\r\n    {\r\n        require(_amount > 0, \"Must mint at least 1\");\r\n        require(\r\n            _toArray.length * _amount <= 100,\r\n            \"Limited to 100 giveaways per transaction\"\r\n        );\r\n        require(\r\n            _toArray.length * _amount <= (TOTAL_SUPPLY - tokenCount),\r\n            \"Exceeds token supply\"\r\n        );\r\n\r\n        uint256 fromId = tokenCount + 1;\r\n        uint256 toId = tokenCount + (_toArray.length * _amount);\r\n\r\n        for (uint256 i; i < _toArray.length; i++) {\r\n            _mintPrivate(_toArray[i], _amount);\r\n        }\r\n\r\n        emit Minted(fromId, toId);\r\n    }","contract":"MerryModz","time":0},{"type":"external-function ","before":"function setBaseURI(string memory _uri) public onlyOwner {\r\n        require(\r\n            bytes(_uri)[bytes(_uri).length - 1] == bytes1(\"/\"),\r\n            \"Must set trailing slash\"\r\n        );\r\n        baseURI = _uri;\r\n        emit SetBaseURI(_uri);\r\n    }","after":"function setBaseURI(string calldata _uri) public onlyOwner {\r\n        require(\r\n            bytes(_uri)[bytes(_uri).length - 1] == bytes1(\"/\"),\r\n            \"Must set trailing slash\"\r\n        );\r\n        baseURI = _uri;\r\n        emit SetBaseURI(_uri);\r\n    }","contract":"MerryModz","time":0}]}