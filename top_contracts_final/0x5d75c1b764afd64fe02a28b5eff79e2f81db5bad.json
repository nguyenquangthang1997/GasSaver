{"time":208,"results":[{"type":"external-function ","before":"\n        payable\r\n        nonReentrant\r\n    {\r\n        require(block.number > startingBlockNumber, \"Not started\");\r\n        require(burnMintingActive, \"Not active\");\r\n        require(!_exists(tokenId), \"Token exists\");\r\n        require(_msgSender() == _tokenSlotOwners[tokenId], \"Not owner\");\r\n        require(burnMintPricePerNft == msg.value, \"Invalid price\");\r\n        require(\r\n            _flavorEligibilityMap[desiredFlavor] == true,\r\n            \"Ineligible flavor\"\r\n        );\r\n\r\n        _burnMintCultTokens(_msgSender(), tokenId, desiredFlavor);\r\n    }\r\n\r\n    function airdropCultTokens(\r\n        address[] memory friends,\r\n        uint256[] memory tokenIds,\r\n        uint256 desiredFlavor\r\n    ) external onlyOwner ","after":"\n        payable\r\n        nonReentrant\r\n    {\r\n        require(block.number > startingBlockNumber, \"Not started\");\r\n        require(burnMintingActive, \"Not active\");\r\n        require(!_exists(tokenId), \"Token exists\");\r\n        require(_msgSender() == _tokenSlotOwners[tokenId], \"Not owner\");\r\n        require(burnMintPricePerNft == msg.value, \"Invalid price\");\r\n        require(\r\n            _flavorEligibilityMap[desiredFlavor] == true,\r\n            \"Ineligible flavor\"\r\n        );\r\n\r\n        _burnMintCultTokens(_msgSender(), tokenId, desiredFlavor);\r\n    }\r\n\r\n    function airdropCultTokens(\r\n        address[] memory friends,\r\n        uint256[] memory tokenIds,\r\n        uint256 desiredFlavor\r\n    ) external onlyOwner ","contract":"NFTCult","time":0},{"type":"external-function ","before":"   require(friends.length == tokenIds.length, \"Unmatched arrays\");\r\n        require(\r\n            _flavorEligibilityMap[desiredFlavor] == true,\r\n            \"Ineligible flavor\"\r\n        );\r\n\r\n        uint256 idx;\r\n        for (idx = 0; idx < friends.length; idx++) {\r\n            require(!_exists(tokenIds[idx]), \"Token exists\");\r\n    ","after":"   require(friends.length == tokenIds.length, \"Unmatched arrays\");\r\n        require(\r\n            _flavorEligibilityMap[desiredFlavor] == true,\r\n            \"Ineligible flavor\"\r\n        );\r\n\r\n        uint256 idx;\r\n        for (idx = 0; idx < friends.length; idx++) {\r\n            require(!_exists(tokenIds[idx]), \"Token exists\");\r\n    ","contract":"NFTCult","time":0},{"type":"external-function ","before":"ternal\r\n        onlyOwner\r\n    {\r\n        require(0 < count && count <= MAX_MINT_PER_TRANS, \"Invalid count\");\r\n\r\n        uint256 idx;\r\n        for (idx = 0; idx < friends.length; idx++) {\r\n            _mintCultTokens(friends[idx], count);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forge tokens together to create new tokens.\r\n     * Note: provided array are the owner's indexes of tokens, NOT tokenIds.\r\n     * EX: Owner owns [ID#55, ID#99, ID#2012]\r\n     * The owner token indexes might be [1, 3, 2] (My point: its unrelated to\r\n     * the ID of the token.)\r\n     */\r\n    function forgeCultTokens(\r\n        uint256[] memory candidateOwnerIndexes,\r\n        uint256 opCode\r\n    ) external nonReentrant {\r\n        require(forgingActive == true, \"Forging not active\");\r\n        require(\r\n            candidateOwnerIndexes.length < MAX_COMBINABLE_TOKENS,\r\n            \"Too many tokens\"\r\n        );\r\n\r\n        require(opCode == 0 || opCode == 1 || opCode == 2, \"Invalid opcode\");\r\n\r\n        uint256 idx;\r\n        uint256[] memory tokenIdsToForge = new uint256[](\r\n            candidateOwnerIndexes.length\r\n        );\r\n\r\n        for (idx = 0; idx < candidateOwnerIndexes.length; idx++) {\r\n            // Validate existence and ownership.\r\n            tokenIdsToForge[idx] = tokenOfOwnerByIndex(\r\n                _msgSender(),\r\n                candidateOwnerIndexes[idx]\r\n            );\r\n        }\r\n\r\n        uint256 craftedTokenId = maxNftsForSale + 1;\r\n        uint256 targetFlavor = 0;\r\n        uint256 checkValue = 0;\r\n\r\n        for (idx = 0; idx < tokenIdsToForge.length; idx++) {\r\n            uint256 tokenFlavor = _tokenFlavors[tokenIdsToForge[idx]];\r\n\r\n            if (opCode == 0) {\r\n                // lateral forge [Must be same flavor]\r\n                if (checkValue == 0) {\r\n                    checkValue = (tokenFlavor / 100) * 100;\r\n                } else {\r\n                    require(\r\n                        checkValue == (tokenFlavor / 100) * 100,\r\n                        \"Incompatible flavors\"\r\n                    );\r\n                }\r\n\r\n                targetFlavor += tokenFlavor % 100;\r\n            } else if (opCode == 1) {\r\n                // vertical forge [Must be same color scheme]\r\n                if (checkValue == 0) {\r\n                    checkValue = tokenFlavor % 100;\r\n                } else {\r\n                    require(\r\n                        checkValue == tokenFlavor % 100,\r\n                        \"Incompatible colors\"\r\n                    );\r\n                }\r\n\r\n                targetFlavor += tokenFlavor / 100;\r\n            } else if (opCode == 2) {\r\n                // multiply forge\r\n                targetFlavor = targetFlavor == 0\r\n                    ? tokenFlavor\r\n                    : targetFlavor * tokenFlavor;\r\n            }\r\n\r\n            // Keep track of the lowest id to use for the new mint.\r\n            if (tokenIdsToForge[idx] < craftedTokenId) {\r\n                craftedTokenId = tokenIdsToForge[idx];\r\n            }\r\n        }\r\n\r\n        if (opCode == 0) {\r\n            targetFlavor = targetFlavor + checkValue;\r\n        } else if (opCode == 1) {\r\n            targetFlavor = (targetFlavor * 100) + checkValue;\r\n        }\r\n\r\n        // Make sure the requested forge target exists.\r\n        require(","after":"ternal\r\n        onlyOwner\r\n    {\r\n        require(0 < count && count <= MAX_MINT_PER_TRANS, \"Invalid count\");\r\n\r\n        uint256 idx;\r\n        for (idx = 0; idx < friends.length; idx++) {\r\n            _mintCultTokens(friends[idx], count);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Forge tokens together to create new tokens.\r\n     * Note: provided array are the owner's indexes of tokens, NOT tokenIds.\r\n     * EX: Owner owns [ID#55, ID#99, ID#2012]\r\n     * The owner token indexes might be [1, 3, 2] (My point: its unrelated to\r\n     * the ID of the token.)\r\n     */\r\n    function forgeCultTokens(\r\n        uint256[] memory candidateOwnerIndexes,\r\n        uint256 opCode\r\n    ) external nonReentrant {\r\n        require(forgingActive == true, \"Forging not active\");\r\n        require(\r\n            candidateOwnerIndexes.length < MAX_COMBINABLE_TOKENS,\r\n            \"Too many tokens\"\r\n        );\r\n\r\n        require(opCode == 0 || opCode == 1 || opCode == 2, \"Invalid opcode\");\r\n\r\n        uint256 idx;\r\n        uint256[] memory tokenIdsToForge = new uint256[](\r\n            candidateOwnerIndexes.length\r\n        );\r\n\r\n        for (idx = 0; idx < candidateOwnerIndexes.length; idx++) {\r\n            // Validate existence and ownership.\r\n            tokenIdsToForge[idx] = tokenOfOwnerByIndex(\r\n                _msgSender(),\r\n                candidateOwnerIndexes[idx]\r\n            );\r\n        }\r\n\r\n        uint256 craftedTokenId = maxNftsForSale + 1;\r\n        uint256 targetFlavor = 0;\r\n        uint256 checkValue = 0;\r\n\r\n        for (idx = 0; idx < tokenIdsToForge.length; idx++) {\r\n            uint256 tokenFlavor = _tokenFlavors[tokenIdsToForge[idx]];\r\n\r\n            if (opCode == 0) {\r\n                // lateral forge [Must be same flavor]\r\n                if (checkValue == 0) {\r\n                    checkValue = (tokenFlavor / 100) * 100;\r\n                } else {\r\n                    require(\r\n                        checkValue == (tokenFlavor / 100) * 100,\r\n                        \"Incompatible flavors\"\r\n                    );\r\n                }\r\n\r\n                targetFlavor += tokenFlavor % 100;\r\n            } else if (opCode == 1) {\r\n                // vertical forge [Must be same color scheme]\r\n                if (checkValue == 0) {\r\n                    checkValue = tokenFlavor % 100;\r\n                } else {\r\n                    require(\r\n                        checkValue == tokenFlavor % 100,\r\n                        \"Incompatible colors\"\r\n                    );\r\n                }\r\n\r\n                targetFlavor += tokenFlavor / 100;\r\n            } else if (opCode == 2) {\r\n                // multiply forge\r\n                targetFlavor = targetFlavor == 0\r\n                    ? tokenFlavor\r\n                    : targetFlavor * tokenFlavor;\r\n            }\r\n\r\n            // Keep track of the lowest id to use for the new mint.\r\n            if (tokenIdsToForge[idx] < craftedTokenId) {\r\n                craftedTokenId = tokenIdsToForge[idx];\r\n            }\r\n        }\r\n\r\n        if (opCode == 0) {\r\n            targetFlavor = targetFlavor + checkValue;\r\n        } else if (opCode == 1) {\r\n            targetFlavor = (targetFlavor * 100) + checkValue;\r\n        }\r\n\r\n        // Make sure the requested forge target exists.\r\n        require(","contract":"NFTCult","time":0},{"type":"external-function ","before":"x]);\r\n        }\r\n\r\n        // Make sure the slot is now free.\r\n        require(!_exists(craftedTokenId","after":"x]);\r\n        }\r\n\r\n        // Make sure the slot is now free.\r\n        require(!_exists(craftedTokenId","contract":"NFTCult","time":0},{"type":"external-function ","before":"token id\");\r\n\r\n        // Execute the mint.\r\n        _safeMint(_msgSender(), craftedTokenId);\r\n        _setTokenURI(craftedTokenId, targetFlavor);\r\n    }\r\n\r\n    function burnCultToken(uint256 tokenId) external nonReentrant {\r\n        require(\r\n            _isApprovedOrOwner(_msgSender(), tokenId),\r\n            \"Not owner or approved\"\r\n        );\r\n\r\n        _burn(tokenId);\r\n    }\r\n\r\n    function setBaseURI(string memory __baseUri) external onlyOwner {\r\n        baseURI = __baseUri;\r\n    }\r\n\r\n    // Bulk method to allow one single call to set up the contract.\r\n    function setFlavorURIBulk(\r\n        uint256[] memory flavorIndex,\r\n        string[] memory flavorUri,\r\n        bool[] memory extendedFlavor,\r\n        bool[] memory enableBurnMin","after":"token id\");\r\n\r\n        // Execute the mint.\r\n        _safeMint(_msgSender(), craftedTokenId);\r\n        _setTokenURI(craftedTokenId, targetFlavor);\r\n    }\r\n\r\n    function burnCultToken(uint256 tokenId) external nonReentrant {\r\n        require(\r\n            _isApprovedOrOwner(_msgSender(), tokenId),\r\n            \"Not owner or approved\"\r\n        );\r\n\r\n        _burn(tokenId);\r\n    }\r\n\r\n    function setBaseURI(string memory __baseUri) external onlyOwner {\r\n        baseURI = __baseUri;\r\n    }\r\n\r\n    // Bulk method to allow one single call to set up the contract.\r\n    function setFlavorURIBulk(\r\n        uint256[] memory flavorIndex,\r\n        string[] memory flavorUri,\r\n        bool[] memory extendedFlavor,\r\n        bool[] memory enableBurnMin","contract":"NFTCult","time":0},{"type":"immutable-restrict-modification ","before":" our Discord: https://disco","after":" our Discord: https://disco","contract":"NFTCult","time":0},{"type":"immutable-restrict-modification ","before":"v looking for a community? We ","after":"v looking for a community? We ","contract":"NFTCult","time":0},{"type":"immutable-restrict-modification ","before":"love to have\r\n *  you in the #�","after":"love to have\r\n *  you in the #�","contract":"NFTCult","time":0},{"type":"immutable-restrict-modification ","before":"tech-and-dev-home channel.\r","after":"tech-and-dev-home channel.\r","contract":"NFTCult","time":0}]}