{"time":189,"results":[{"type":"state-data-arrangement ","before":"\n   address signerAddress = 0x8E7c6DBdae809c79C9f8Aa0F9ACf05614b4EB5\n   uint256 private _currentTokenId = 3\n   uint256 private _reservedTokenId =\n   uint256 private MAX_RESERVED_ID = 3\n   uint256 public mintedSupply =\n   bool public lockingEnabled = fal\n   string public baseURI = \"https://api.thecellszone.com/json\n   mapping (uint256 => string) private _tokenUR\n   mapping (uint256 => string) public tokenIdToCellCo\n   mapping (string => uint256) public cellCodeToToken\n   mapping (address => mapping(uint => bool)) private lockNonc","after":"   uint256 private _currentTokenId = 3\n   uint256 private _reservedTokenId =\n   uint256 private MAX_RESERVED_ID = 3\n   uint256 public mintedSupply =\n   string public baseURI = \"https://api.thecellszone.com/json\n   mapping (uint256 => string) private _tokenUR\n   mapping (uint256 => string) public tokenIdToCellCo\n   mapping (string => uint256) public cellCodeToToken\n   mapping (address => mapping(uint => bool)) private lockNonc\n   address signerAddress = 0x8E7c6DBdae809c79C9f8Aa0F9ACf05614b4EB5\n   bool public lockingEnabled = fal\n","contract":"ERC721Cells","time":0},{"type":"external-function ","before":"   function verifyAndMint(bytes memory signature, uint amount, uint nonce, uint mintPrice, uint data) public payable {\n        require(signatureMint, \"Signature mint is not active\");\n        require(amount >= minMintable, \"Quantity too low\");        \n        require(amount <= MAX_CELLS_PURCHASE || mintedSupply + amount <= maxMintable || totalSupply() + amount <= MAX_CELLS, \"Quantity too high\");\n        require(!mintNonces[msg.sender][nonce], \"Nonce already used\");\n\n        uint price;\n        if (mintPrice == 1) {\n            price = getPackPrice(amount);\n        } else if (mintPrice == 2) {\n            price = cellPrice;\n        } else {\n            price = mintPrice;\n        }\n        \n        require(price * amount <= msg.value, \"Ether value sent is not correct\");\n        \n        bytes32 hash = keccak256(abi.encode(msg.sender, amount, nonce, mintPrice, data));\n        bytes32 messageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n        address signer = messageHash.recover(signature);\n        require(signer == signerAddress, \"Signers don't match\");\n\n        mintNonces[msg.sender][nonce] = true;\n        mintCell(msg.sender, amount, randomMint, data);\n        if (bonusCoins) {\n            sendBonusCoins(msg.sender, amount);\n        }\n  ","after":"   function verifyAndMint(bytes calldata signature, uint amount, uint nonce, uint mintPrice, uint data) public payable {\n        require(signatureMint, \"Signature mint is not active\");\n        require(amount >= minMintable, \"Quantity too low\");        \n        require(amount <= MAX_CELLS_PURCHASE || mintedSupply + amount <= maxMintable || totalSupply() + amount <= MAX_CELLS, \"Quantity too high\");\n        require(!mintNonces[msg.sender][nonce], \"Nonce already used\");\n\n        uint price;\n        if (mintPrice == 1) {\n            price = getPackPrice(amount);\n        } else if (mintPrice == 2) {\n            price = cellPrice;\n        } else {\n            price = mintPrice;\n        }\n        \n        require(price * amount <= msg.value, \"Ether value sent is not correct\");\n        \n        bytes32 hash = keccak256(abi.encode(msg.sender, amount, nonce, mintPrice, data));\n        bytes32 messageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n        address signer = messageHash.recover(signature);\n        require(signer == signerAddress, \"Signers don't match\");\n\n        mintNonces[msg.sender][nonce] = true;\n        mintCell(msg.sender, amount, randomMint, data);\n        if (bonusCoins) {\n            sendBonusCoins(msg.sender, amount);\n        }\n  ","contract":"Cells","time":0},{"type":"external-function ","before":"   function setBaseURI(string memory newURI) public onlyOwner {\n        baseURI = newURI;\n  ","after":"   function setBaseURI(string calldata newURI) public onlyOwner {\n        baseURI = newURI;\n  ","contract":"Cells","time":0},{"type":"external-function ","before":"   function lockCell(\n        bytes memory signature,\n        uint256 tokenId, \n        uint256 nonce,\n        string memory cellCode,\n        string memory _tokenURI\n    ) external {\n        require(lockingEnabled, \"locking disabled\");\n        require(ownerOf(tokenId) == msg.sender, \"not your cell\");\n        require(bytes(_tokenURIs[tokenId]).length == 0 || !lockNonces[msg.sender][nonce], \"already locked\");\n\n        bytes32 _hash = keccak256(abi.encode(msg.sender, tokenId, nonce, cellCode, _tokenURI));\n        bytes32 messageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash));\n        address signer = messageHash.recover(signature);\n        require(signer == signerAddress, \"Signers don't match\");\n\n        lockNonces[msg.sender][nonce] = true;\n        _setTokenURI(tokenId, _tokenURI);\n        _setCellCode(tokenId, cellCode);\n        \n        emit LockedCell(tokenId, msg.sender, cellCode, _tokenURI);\n        emit PermanentURI(_tokenURI, tokenId);\n  ","after":"   function lockCell(\n        bytes calldata signature,\n        uint256 tokenId, \n        uint256 nonce,\n        string calldata cellCode,\n        string calldata _tokenURI\n    ) external {\n        require(lockingEnabled, \"locking disabled\");\n        require(ownerOf(tokenId) == msg.sender, \"not your cell\");\n        require(bytes(_tokenURIs[tokenId]).length == 0 || !lockNonces[msg.sender][nonce], \"already locked\");\n\n        bytes32 _hash = keccak256(abi.encode(msg.sender, tokenId, nonce, cellCode, _tokenURI));\n        bytes32 messageHash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _hash));\n        address signer = messageHash.recover(signature);\n        require(signer == signerAddress, \"Signers don't match\");\n\n        lockNonces[msg.sender][nonce] = true;\n        _setTokenURI(tokenId, _tokenURI);\n        _setCellCode(tokenId, cellCode);\n        \n        emit LockedCell(tokenId, msg.sender, cellCode, _tokenURI);\n        emit PermanentURI(_tokenURI, tokenId);\n  ","contract":"Cells","time":0},{"type":"constant-restrict-modification  ","before":"   uint256 private MAX_RESERVED_ID = 3","after":"   uint256 private constant MAX_RESERVED_ID = 3","contract":"Cells","time":1}]}