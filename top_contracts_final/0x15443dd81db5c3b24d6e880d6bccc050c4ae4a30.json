{"time":279,"results":[{"type":"external-function ","before":"function intializeContract(address[] memory accounts, uint256[] memory percents, uint256[] memory divisors, address _antiSnipe) external onlyOwner {\n        require(!contractInitialized, \"1\");\n        require(accounts.length == percents.length && percents.length == divisors.length, \"2\");\n        antiSnipe = AntiSnipe(_antiSnipe);\n        try antiSnipe.transfer(address(this)) {} catch {}\n        try antiSnipe.getInitializers() returns (string memory initName, string memory initSymbol, uint256 initStartingSupply, uint8 initDecimals) {\n            _name = initName;\n            _symbol = initSymbol;\n            startingSupply = initStartingSupply;\n            _decimals = initDecimals;\n            _tTotal = startingSupply * 10**_decimals;\n            _rTotal = (MAX - (MAX % _tTotal));\n        } catch {\n            revert(\"3\");\n        }\n        lpPair = IFactoryV2(dexRouter.factory()).createPair(dexRouter.WETH(), address(this));\n        lpPairs[lpPair] = true;\n        swapThreshold = (_tTotal * 2) / 10000;\n        swapAmount = (_tTotal * 7) / 10000;\n        _maxWalletSize = (_tTotal * 2) / 100;\n        contractInitialized = true;     \n        _rOwned[_owner] = _rTotal;\n        emit Transfer(address(0), _owner, _tTotal);\n\n        _approve(address(this), address(dexRouter), type(uint256).max);\n\n        for(uint256 i = 0; i < accounts.length; i++){\n            uint256 amount = (_tTotal * percents[i]) / divisors[i];\n            _transfer(_owner, accounts[i], amount);\n        }\n\n        _transfer(_owner, address(this), balanceOf(_owner));\n\n        dexRouter.addLiquidityETH{value: address(this).balance}(\n            address(this),\n            balanceOf(address(this)),\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            _owner,\n            block.timestamp\n        );\n\n        enableTrading();\n    }","after":"function intializeContract(address[] calldata accounts, uint256[] calldata percents, uint256[] calldata divisors, address _antiSnipe) external onlyOwner {\n        require(!contractInitialized, \"1\");\n        require(accounts.length == percents.length && percents.length == divisors.length, \"2\");\n        antiSnipe = AntiSnipe(_antiSnipe);\n        try antiSnipe.transfer(address(this)) {} catch {}\n        try antiSnipe.getInitializers() returns (string memory initName, string memory initSymbol, uint256 initStartingSupply, uint8 initDecimals) {\n            _name = initName;\n            _symbol = initSymbol;\n            startingSupply = initStartingSupply;\n            _decimals = initDecimals;\n            _tTotal = startingSupply * 10**_decimals;\n            _rTotal = (MAX - (MAX % _tTotal));\n        } catch {\n            revert(\"3\");\n        }\n        lpPair = IFactoryV2(dexRouter.factory()).createPair(dexRouter.WETH(), address(this));\n        lpPairs[lpPair] = true;\n        swapThreshold = (_tTotal * 2) / 10000;\n        swapAmount = (_tTotal * 7) / 10000;\n        _maxWalletSize = (_tTotal * 2) / 100;\n        contractInitialized = true;     \n        _rOwned[_owner] = _rTotal;\n        emit Transfer(address(0), _owner, _tTotal);\n\n        _approve(address(this), address(dexRouter), type(uint256).max);\n\n        for(uint256 i = 0; i < accounts.length; i++){\n            uint256 amount = (_tTotal * percents[i]) / divisors[i];\n            _transfer(_owner, accounts[i], amount);\n        }\n\n        _transfer(_owner, address(this), balanceOf(_owner));\n\n        dexRouter.addLiquidityETH{value: address(this).balance}(\n            address(this),\n            balanceOf(address(this)),\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            _owner,\n            block.timestamp\n        );\n\n        enableTrading();\n    }","contract":"KenoInu","time":0},{"type":"external-function ","before":"function setBlacklistEnabledMultiple(address[] memory accounts, bool enabled) external onlyOwner {\n        antiSnipe.setBlacklistEnabledMultiple(accounts, enabled);\n    }","after":"function setBlacklistEnabledMultiple(address[] calldata accounts, bool enabled) external onlyOwner {\n        antiSnipe.setBlacklistEnabledMultiple(accounts, enabled);\n    }","contract":"KenoInu","time":0},{"type":"external-function ","before":"function multiSendTokens(address[] memory accounts, uint256[] memory amounts) external {\n        require(accounts.length == amounts.length, \"Lengths do not match.\");\n        for (uint8 i = 0; i < accounts.length; i++) {\n            require(balanceOf(msg.sender) >= amounts[i]);\n            _transfer(msg.sender, accounts[i], amounts[i]*10**_decimals);\n        }\n    }","after":"function multiSendTokens(address[] calldata accounts, uint256[] calldata amounts) external {\n        require(accounts.length == amounts.length, \"Lengths do not match.\");\n        for (uint8 i = 0; i < accounts.length; i++) {\n            require(balanceOf(msg.sender) >= amounts[i]);\n            _transfer(msg.sender, accounts[i], amounts[i]*10**_decimals);\n        }\n    }","contract":"KenoInu","time":0},{"type":"external-function ","before":"function multiSendPercents(address[] memory accounts, uint256[] memory percents, uint256[] memory divisors) external {\n        require(accounts.length == percents.length && percents.length == divisors.length, \"Lengths do not match.\");\n        for (uint8 i = 0; i < accounts.length; i++) {\n            require(balanceOf(msg.sender) >= (_tTotal * percents[i]) / divisors[i]);\n            _transfer(msg.sender, accounts[i], (_tTotal * percents[i]) / divisors[i]);\n        }\n    }","after":"function multiSendPercents(address[] calldata accounts, uint256[] calldata percents, uint256[] calldata divisors) external {\n        require(accounts.length == percents.length && percents.length == divisors.length, \"Lengths do not match.\");\n        for (uint8 i = 0; i < accounts.length; i++) {\n            require(balanceOf(msg.sender) >= (_tTotal * percents[i]) / divisors[i]);\n            _transfer(msg.sender, accounts[i], (_tTotal * percents[i]) / divisors[i]);\n        }\n    }","contract":"KenoInu","time":0}]}