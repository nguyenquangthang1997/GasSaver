{"time":224,"results":[{"type":"external-function ","before":"function purchaseTicket(uint _tvl, uint counter, bytes memory signature) public payable {\n        require(!session[session_id].deposit_paused, \"deposit paused\");\n        require(session[session_id].end_timestamp > block.timestamp, \"jackpot ended\");\n        require(msg.value == eth_per_ticket, \"invalid payment\");\n        require(counter > user_info[msg.sender].purchase_counter, 'EXPIRED COUNTER'); // prevent replay attack\n        require(_verifySign(signer, msg.sender, _tvl, counter, signature), \"invalid signature\");\n\n        // replace user purchase counter number\n        user_info[msg.sender].purchase_counter = counter;\n        \n        // uniform lowest bound number is 0\n        // result format is in array index so max upper bound number need to minus 1\n        uint mul_index  = UniformRandomNumber.uniform(_rngSeed(), multiplier_list.length);\n        uint pool_index = _pickPoolIndex();\n        \n        // tvl should source from maximizer pool. (LP staked value * weightage)\n        uint actual_weightage = _tvl.mul(multiplier_list[mul_index], DECIMAL);\n        \n        pool[session_id][pool_index].total_weightage                = pool[session_id][pool_index].total_weightage.add(actual_weightage);\n        user_pool[msg.sender][session_id][pool_index].weightage     = user_pool[msg.sender][session_id][pool_index].weightage.add(actual_weightage);\n        user_pool[msg.sender][session_id][pool_index].num_of_ticket = user_pool[msg.sender][session_id][pool_index].num_of_ticket.add(1);\n        user_session[msg.sender][session_id].tvl                    = user_session[msg.sender][session_id].tvl.add(_tvl);\n        user_session[msg.sender][session_id].num_of_ticket          = user_session[msg.sender][session_id].num_of_ticket.add(1);\n        user_session[msg.sender][session_id].has_purchased          = true;\n        \n        if (swap_payment) {\n            _paymentDistributionDex(msg.value);\n        } else {\n            _paymentDistributionBuyback(msg.value);    \n        }\n\n        // withdrawal penalty set once\n        // -> block.timestamp + 30 day + session(end - now)\n        if (user_session[msg.sender][session_id].penalty_until_timestamp <= 0) {\n            user_session[msg.sender][session_id].first_deposit_timestamp = block.timestamp;\n            user_session[msg.sender][session_id].penalty_until_timestamp = session[session_id].end_timestamp.add(penalty_base_minute * 60);\n        }\n        \n        emit PurchaseTicket(session_id, multiplier_list[mul_index], pool_index, eth_per_ticket, _tvl, actual_weightage, block.timestamp, msg.sender);\n    }","after":"function purchaseTicket(uint _tvl, uint counter, bytes calldata signature) public payable {\n        require(!session[session_id].deposit_paused, \"deposit paused\");\n        require(session[session_id].end_timestamp > block.timestamp, \"jackpot ended\");\n        require(msg.value == eth_per_ticket, \"invalid payment\");\n        require(counter > user_info[msg.sender].purchase_counter, 'EXPIRED COUNTER'); // prevent replay attack\n        require(_verifySign(signer, msg.sender, _tvl, counter, signature), \"invalid signature\");\n\n        // replace user purchase counter number\n        user_info[msg.sender].purchase_counter = counter;\n        \n        // uniform lowest bound number is 0\n        // result format is in array index so max upper bound number need to minus 1\n        uint mul_index  = UniformRandomNumber.uniform(_rngSeed(), multiplier_list.length);\n        uint pool_index = _pickPoolIndex();\n        \n        // tvl should source from maximizer pool. (LP staked value * weightage)\n        uint actual_weightage = _tvl.mul(multiplier_list[mul_index], DECIMAL);\n        \n        pool[session_id][pool_index].total_weightage                = pool[session_id][pool_index].total_weightage.add(actual_weightage);\n        user_pool[msg.sender][session_id][pool_index].weightage     = user_pool[msg.sender][session_id][pool_index].weightage.add(actual_weightage);\n        user_pool[msg.sender][session_id][pool_index].num_of_ticket = user_pool[msg.sender][session_id][pool_index].num_of_ticket.add(1);\n        user_session[msg.sender][session_id].tvl                    = user_session[msg.sender][session_id].tvl.add(_tvl);\n        user_session[msg.sender][session_id].num_of_ticket          = user_session[msg.sender][session_id].num_of_ticket.add(1);\n        user_session[msg.sender][session_id].has_purchased          = true;\n        \n        if (swap_payment) {\n            _paymentDistributionDex(msg.value);\n        } else {\n            _paymentDistributionBuyback(msg.value);    \n        }\n\n        // withdrawal penalty set once\n        // -> block.timestamp + 30 day + session(end - now)\n        if (user_session[msg.sender][session_id].penalty_until_timestamp <= 0) {\n            user_session[msg.sender][session_id].first_deposit_timestamp = block.timestamp;\n            user_session[msg.sender][session_id].penalty_until_timestamp = session[session_id].end_timestamp.add(penalty_base_minute * 60);\n        }\n        \n        emit PurchaseTicket(session_id, multiplier_list[mul_index], pool_index, eth_per_ticket, _tvl, actual_weightage, block.timestamp, msg.sender);\n    }","contract":"Optimiser","time":0},{"type":"external-function ","before":"function updateMultiplierList(uint[] memory _multiplier_list) public hasAccessPermission {\n       multiplier_list = _multiplier_list;\n       emit UpdateMultiplierList(multiplier_list);\n    }","after":"function updateMultiplierList(uint[] calldata _multiplier_list) public hasAccessPermission {\n       multiplier_list = _multiplier_list;\n       emit UpdateMultiplierList(multiplier_list);\n    }","contract":"Optimiser","time":0},{"type":"external-function ","before":"function updatePoolCategory(uint new_max_category, uint[] memory reward_rates, uint[] memory chance_rates) public hasAccessPermission {\n        require(reward_rates.length == category_size, \"invalid input size\");\n\n        // remove old setting\n        for (uint i = 0; i < category_size; i++) {\n            delete pool_reward_list[i];\n            delete pool_chances[i];\n            _updatePoolChances(i, 0);\n        }\n\n        // add new setting\n        for (uint i = 0; i < new_max_category; i++) {\n            pool_reward_list[i] = reward_rates[i];\n            _updatePoolChances(i, chance_rates[i]);\n        }\n\n        category_size = new_max_category;\n        \n        emit UpdatePoolCategory(new_max_category, reward_rates, chance_rates);\n    }","after":"function updatePoolCategory(uint new_max_category, uint[] calldata reward_rates, uint[] calldata chance_rates) public hasAccessPermission {\n        require(reward_rates.length == category_size, \"invalid input size\");\n\n        // remove old setting\n        for (uint i = 0; i < category_size; i++) {\n            delete pool_reward_list[i];\n            delete pool_chances[i];\n            _updatePoolChances(i, 0);\n        }\n\n        // add new setting\n        for (uint i = 0; i < new_max_category; i++) {\n            pool_reward_list[i] = reward_rates[i];\n            _updatePoolChances(i, chance_rates[i]);\n        }\n\n        category_size = new_max_category;\n        \n        emit UpdatePoolCategory(new_max_category, reward_rates, chance_rates);\n    }","contract":"Optimiser","time":0}]}