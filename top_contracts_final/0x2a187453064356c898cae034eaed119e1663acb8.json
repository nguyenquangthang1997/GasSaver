{"time":179,"results":[{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping (uint256 => address) private _tokenOwner;\nmapping (uint256 => address) private _tokenApprovals;\nmapping (address => Counters.Counter) private _ownedTokensCount;\nmapping (address => mapping (address => bool)) private _operatorApprovals;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;","after":"mapping (uint256 => address) private _tokenOwner;\nmapping (uint256 => address) private _tokenApprovals;\nmapping (address => Counters.Counter) private _ownedTokensCount;\nmapping (address => mapping (address => bool)) private _operatorApprovals;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n","contract":"ERC721","time":1},{"type":"external-function ","before":"function onERC721Received(\n        address /* _operator */,\n        address /* _from */,\n        uint256 _tokenId,\n        bytes memory /* _data */\n    )\n        public\n        returns (bytes4)\n    {\n        require(msg.sender == address(base), \"Only base can send NFTs to this contract\");\n\n        // Re-claim to update the owner at the ENS Registry\n        base.reclaim(_tokenId, address(this));\n        return ERC721_RECEIVED;\n    }","after":"function onERC721Received(\n        address /* _operator */,\n        address /* _from */,\n        uint256 _tokenId,\n        bytes calldata /* _data */\n    )\n        public\n        returns (bytes4)\n    {\n        require(msg.sender == address(base), \"Only base can send NFTs to this contract\");\n\n        // Re-claim to update the owner at the ENS Registry\n        base.reclaim(_tokenId, address(this));\n        return ERC721_RECEIVED;\n    }","contract":"DCLRegistrar","time":0},{"type":"external-function ","before":"function forwardToResolver(bytes memory _data) public onlyOwner {\n        address resolver = registry.resolver(domainNameHash);\n\n        _checkNotAllowedAddresses(resolver);\n\n        (bool success, bytes memory res) = resolver.call(_data);\n\n        require(success, \"Call failed\");\n\n        // Make sure this contract is still the owner of the domain\n        _checkOwnerOfDomain();\n\n        emit CallForwarwedToResolver(resolver, _data, res);\n    }","after":"function forwardToResolver(bytes calldata _data) public onlyOwner {\n        address resolver = registry.resolver(domainNameHash);\n\n        _checkNotAllowedAddresses(resolver);\n\n        (bool success, bytes memory res) = resolver.call(_data);\n\n        require(success, \"Call failed\");\n\n        // Make sure this contract is still the owner of the domain\n        _checkOwnerOfDomain();\n\n        emit CallForwarwedToResolver(resolver, _data, res);\n    }","contract":"DCLRegistrar","time":0},{"type":"constant-restrict-modification  ","before":"bytes32 emptyNamehash = 0x00;","after":"bytes32 constant emptyNamehash = 0x00;","contract":"DCLRegistrar","time":1}]}