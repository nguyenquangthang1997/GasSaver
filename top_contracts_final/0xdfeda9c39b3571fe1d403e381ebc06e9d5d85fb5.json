{"time":234,"results":[{"type":"state-data-arrangement ","before":"\nbytes32 public constant EVENT_MANAGER_ROLE = keccak256(\"EVENT_MANAGER_ROLE\");\nstring public name;\nstring public symbol;\naddress public nftContractAddress;\nuint256 public numCollections;\nmapping (uint256 => Collection) public collections;\nuint16 public build = 14;\nuint256 public tokenCount = 0;\nbool private _enabled = true;\nbool private _locked = false;\nbytes4 constant public ERC1155_ACCEPTED = 0xf23a6e61;\naddress payable public contract_owner;\nmapping(uint256 => address) public tokenToAddress;\nPass[] public passes;","after":"bytes32 public constant EVENT_MANAGER_ROLE = keccak256(\"EVENT_MANAGER_ROLE\");\nstring public name;\nstring public symbol;\nuint256 public numCollections;\nmapping (uint256 => Collection) public collections;\nuint256 public tokenCount = 0;\nmapping(uint256 => address) public tokenToAddress;\nPass[] public passes;\naddress public nftContractAddress;\naddress payable public contract_owner;\nbytes4 constant public ERC1155_ACCEPTED = 0xf23a6e61;\nuint16 public build = 14;\nbool private _enabled = true;\nbool private _locked = false;\n","contract":"MintPass","time":2},{"type":"struct-data-arrangement ","before":"\nbytes32 name\nuint16 collectionType\nstring uri\nuint cost\nbool mintPassOpenToPublic\nbool mintNftOpenToPublic\nuint256 totalMintCount\nuint256 remaingMintCount\nuint16 artistPayablePercent\naddress artistPayableAddress\naddress nftContractAddress\nmapping(address => uint) whitelistPass\nmapping(address => uint) whitelistNft","after":"bytes32 name\nstring uri\nuint cost\nuint256 totalMintCount\nuint256 remaingMintCount\nmapping(address => uint) whitelistPass\nmapping(address => uint) whitelistNft\naddress artistPayableAddress\naddress nftContractAddress\nuint16 collectionType\nuint16 artistPayablePercent\nbool mintPassOpenToPublic\nbool mintNftOpenToPublic\n","contract":"MintPass","time":1},{"type":"external-function ","before":"function mintPass(address _to, uint256 collectionId, bytes memory _data) public payable onlyWhenEnabled {\n        require(collections[collectionId].remaingMintCount > 0, \"AP: No remaining passes to mint\");\n\n        require(msg.value >= collections[collectionId].cost, \"AP: Not enough value to mint\");\n        require(\n            hasRole(MINTER_ROLE, _msgSender()) || collections[collectionId].whitelistPass[msg.sender] > 0 || collections[collectionId].mintPassOpenToPublic,\n            \"Only contract owner or whitelist can mint.\"\n        );\n        // Decrement remaining available mintables\n        collections[collectionId].remaingMintCount--;\n\n        _mint(_to, tokenCount, 1, _data);\n\n        // Subtract from the number that can be minted from that address\n        if(!collections[collectionId].mintPassOpenToPublic) {\n            if(!hasRole(MINTER_ROLE, _msgSender())) {\n                collections[collectionId].whitelistPass[msg.sender]--;\n            }\n        }\n        // Set the ownership of this token to sender\n        tokenToAddress[tokenCount] = _to;\n        // Push associated data for mint to NFT array\n        passes.push(Pass({\n            collectionId:  collectionId,\n            sale_price: msg.value\n        }));\n\n        // Split minting value\n        uint artistFraction = 90;\n        uint artistTotal = (collections[collectionId].cost * artistFraction) / 100;\n        uint apTotal = msg.value - artistTotal;\n        address artistAddress = collections[collectionId].artistPayableAddress;\n        payable(contract_owner).transfer(apTotal); // send the ETH to the Afterparty wallet\n        payable(artistAddress).transfer(artistTotal); // send the ETH to the Artist wallet\n\n        // Increment token count\n        tokenCount++;\n\n        // Emit minted event\n        emit evtPassMinted(contract_owner, msg.sender, msg.value);\n    }","after":"function mintPass(address _to, uint256 collectionId, bytes calldata _data) public payable onlyWhenEnabled {\n        require(collections[collectionId].remaingMintCount > 0, \"AP: No remaining passes to mint\");\n\n        require(msg.value >= collections[collectionId].cost, \"AP: Not enough value to mint\");\n        require(\n            hasRole(MINTER_ROLE, _msgSender()) || collections[collectionId].whitelistPass[msg.sender] > 0 || collections[collectionId].mintPassOpenToPublic,\n            \"Only contract owner or whitelist can mint.\"\n        );\n        // Decrement remaining available mintables\n        collections[collectionId].remaingMintCount--;\n\n        _mint(_to, tokenCount, 1, _data);\n\n        // Subtract from the number that can be minted from that address\n        if(!collections[collectionId].mintPassOpenToPublic) {\n            if(!hasRole(MINTER_ROLE, _msgSender())) {\n                collections[collectionId].whitelistPass[msg.sender]--;\n            }\n        }\n        // Set the ownership of this token to sender\n        tokenToAddress[tokenCount] = _to;\n        // Push associated data for mint to NFT array\n        passes.push(Pass({\n            collectionId:  collectionId,\n            sale_price: msg.value\n        }));\n\n        // Split minting value\n        uint artistFraction = 90;\n        uint artistTotal = (collections[collectionId].cost * artistFraction) / 100;\n        uint apTotal = msg.value - artistTotal;\n        address artistAddress = collections[collectionId].artistPayableAddress;\n        payable(contract_owner).transfer(apTotal); // send the ETH to the Afterparty wallet\n        payable(artistAddress).transfer(artistTotal); // send the ETH to the Artist wallet\n\n        // Increment token count\n        tokenCount++;\n\n        // Emit minted event\n        emit evtPassMinted(contract_owner, msg.sender, msg.value);\n    }","contract":"MintPass","time":0},{"type":"external-function ","before":"function mintPassBatch(address _to, uint256 collectionId, bytes memory _data, uint count) public onlyWhenEnabled {\n        // TODO: Get remaining mint count function\n        require(collections[collectionId].remaingMintCount > count, \"AP: Not enough remaining passes to mint\");\n\n        require( hasRole(MINTER_ROLE, _msgSender()), \"Only minter can batch mint.\" );\n        // Decrement remaining available mintables\n        collections[collectionId].remaingMintCount -= count;\n\n        uint[] memory ids = new uint[](count);\n        uint[] memory amounts = new uint[](count);\n        for (uint256 i = 0; i < count; i++) {\n            ids[i] = tokenCount+i;\n            amounts[i] = 1;\n            tokenToAddress[tokenCount+i] = _to;\n            // Push associated data for mint to NFT array\n            passes.push(Pass({\n                collectionId:  collectionId,\n                sale_price: 0\n            }));\n        }\n        _mintBatch(_to, ids, amounts, _data);\n        // Increment token count\n        tokenCount += count;\n\n        // Emit minted event\n        emit evtPassMintedBatch(_to, msg.sender, _data, count);\n    }","after":"function mintPassBatch(address _to, uint256 collectionId, bytes calldata _data, uint count) public onlyWhenEnabled {\n        // TODO: Get remaining mint count function\n        require(collections[collectionId].remaingMintCount > count, \"AP: Not enough remaining passes to mint\");\n\n        require( hasRole(MINTER_ROLE, _msgSender()), \"Only minter can batch mint.\" );\n        // Decrement remaining available mintables\n        collections[collectionId].remaingMintCount -= count;\n\n        uint[] memory ids = new uint[](count);\n        uint[] memory amounts = new uint[](count);\n        for (uint256 i = 0; i < count; i++) {\n            ids[i] = tokenCount+i;\n            amounts[i] = 1;\n            tokenToAddress[tokenCount+i] = _to;\n            // Push associated data for mint to NFT array\n            passes.push(Pass({\n                collectionId:  collectionId,\n                sale_price: 0\n            }));\n        }\n        _mintBatch(_to, ids, amounts, _data);\n        // Increment token count\n        tokenCount += count;\n\n        // Emit minted event\n        emit evtPassMintedBatch(_to, msg.sender, _data, count);\n    }","contract":"MintPass","time":0},{"type":"external-function ","before":"function createCollection (bytes32 _name, uint16 _collectionType, uint256 _cost, string memory _uri, uint256 _remaingMintCount, uint16 _artistPayablePercent, address _artistPayableAddress) public {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"AP: must have minter role to create collection\");\n        Collection storage newCol = collections[numCollections++];\n        newCol.name = _name;\n        newCol.collectionType = _collectionType;\n        newCol.uri = _uri;\n        newCol.cost = _cost;\n        newCol.totalMintCount = _remaingMintCount;\n        newCol.remaingMintCount = _remaingMintCount;\n        newCol.mintPassOpenToPublic = false;\n        newCol.mintNftOpenToPublic = false;\n        newCol.artistPayablePercent = _artistPayablePercent;\n        newCol.artistPayableAddress = _artistPayableAddress;\n        newCol.nftContractAddress = 0x0000000000000000000000000000000000000000;\n    }","after":"function createCollection (bytes32 _name, uint16 _collectionType, uint256 _cost, string calldata _uri, uint256 _remaingMintCount, uint16 _artistPayablePercent, address _artistPayableAddress) public {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"AP: must have minter role to create collection\");\n        Collection storage newCol = collections[numCollections++];\n        newCol.name = _name;\n        newCol.collectionType = _collectionType;\n        newCol.uri = _uri;\n        newCol.cost = _cost;\n        newCol.totalMintCount = _remaingMintCount;\n        newCol.remaingMintCount = _remaingMintCount;\n        newCol.mintPassOpenToPublic = false;\n        newCol.mintNftOpenToPublic = false;\n        newCol.artistPayablePercent = _artistPayablePercent;\n        newCol.artistPayableAddress = _artistPayableAddress;\n        newCol.nftContractAddress = 0x0000000000000000000000000000000000000000;\n    }","contract":"MintPass","time":0},{"type":"external-function ","before":"function setURI(string memory newuri) public  {\n        require(\n            msg.sender == contract_owner,\n            \"Only contract owner add to whitelist.\"\n        );\n        _setURI(newuri);\n    }","after":"function setURI(string calldata newuri) public  {\n        require(\n            msg.sender == contract_owner,\n            \"Only contract owner add to whitelist.\"\n        );\n        _setURI(newuri);\n    }","contract":"MintPass","time":0},{"type":"external-function ","before":"function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mint(to, id, amount, data);\n    }","after":"function mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mint(to, id, amount, data);\n    }","contract":"MintPass","time":0},{"type":"external-function ","before":"function mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mintBatch(to, ids, amounts, data);\n    }","after":"function mintBatch(\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual {\n        require(hasRole(MINTER_ROLE, _msgSender()), \"ERC1155PresetMinterPauser: must have minter role to mint\");\n\n        _mintBatch(to, ids, amounts, data);\n    }","contract":"MintPass","time":0},{"type":"external-function ","before":"function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }","after":"function burnBatch(\n        address account,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }","contract":"MintPass","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"MintPass","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"MintPass","time":0},{"type":"constant-restrict-modification  ","before":"uint16 public build = 14;","after":"uint16 public constant build = 14;","contract":"MintPass","time":1}]}