{"time":39,"results":[{"type":"external-function ","before":"function approve(string memory ethHash, string memory btcHash, bytes32 _tunnelKey) public onlyTrustee(_tunnelKey) {\n        string memory key = string(abi.encodePacked(ethHash, btcHash, _tunnelKey));\n        if (proposals[key].isExist == false) {\n            Proposal memory p = Proposal({\n                ethHash: ethHash,\n                btcHash: btcHash,\n                voteCount: 1,\n                finished: false,\n                isExist: true\n            });\n            proposals[key] = p;\n            proposals[key].voteState[msg.sender] = true;\n            emit VoteBurnProposal(_tunnelKey, ethHash, btcHash, msg.sender, p.voteCount);\n        } else {\n            Proposal storage p = proposals[key];\n            if(p.voteState[msg.sender] == true) {\n                return;\n            }\n            if(p.finished) {\n                return;\n            }\n            p.voteCount = p.voteCount.add(1);\n            p.voteState[msg.sender] = true;\n            emit VoteBurnProposal(_tunnelKey, ethHash, btcHash, msg.sender, p.voteCount);\n        }\n        Proposal storage p = proposals[key];\n        uint trusteeCount = getTrusteeCount(_tunnelKey);\n        uint threshold = trusteeCount.mod(3) == 0 ? trusteeCount.mul(2).div(3) : trusteeCount.mul(2).div(3).add(diff);\n        if (p.voteCount >= threshold) {\n            p.finished = true;\n            emit BurnProposalSuccess(_tunnelKey, ethHash, btcHash);\n        }\n    }","after":"function approve(string calldata ethHash, string calldata btcHash, bytes32 _tunnelKey) public onlyTrustee(_tunnelKey) {\n        string memory key = string(abi.encodePacked(ethHash, btcHash, _tunnelKey));\n        if (proposals[key].isExist == false) {\n            Proposal memory p = Proposal({\n                ethHash: ethHash,\n                btcHash: btcHash,\n                voteCount: 1,\n                finished: false,\n                isExist: true\n            });\n            proposals[key] = p;\n            proposals[key].voteState[msg.sender] = true;\n            emit VoteBurnProposal(_tunnelKey, ethHash, btcHash, msg.sender, p.voteCount);\n        } else {\n            Proposal storage p = proposals[key];\n            if(p.voteState[msg.sender] == true) {\n                return;\n            }\n            if(p.finished) {\n                return;\n            }\n            p.voteCount = p.voteCount.add(1);\n            p.voteState[msg.sender] = true;\n            emit VoteBurnProposal(_tunnelKey, ethHash, btcHash, msg.sender, p.voteCount);\n        }\n        Proposal storage p = proposals[key];\n        uint trusteeCount = getTrusteeCount(_tunnelKey);\n        uint threshold = trusteeCount.mod(3) == 0 ? trusteeCount.mul(2).div(3) : trusteeCount.mul(2).div(3).add(diff);\n        if (p.voteCount >= threshold) {\n            p.finished = true;\n            emit BurnProposalSuccess(_tunnelKey, ethHash, btcHash);\n        }\n    }","contract":"BurnProposal","time":0}]}