{"time":218,"results":[{"type":"external-function ","before":"   function mint(bytes memory signature, string memory nonce, uint256 numberOfTokens)\n        public\n        whenNotPaused\n        returns (uint256)\n    {   \n        require(checkBal(msg.sender), \"Does not hold enough tokens!\");\n        require( totalSupply(0) + 1 <= MAX_Tokens, \"This exceeds the maximum number of NFTs on sale!\");\n        require(balanceOf(msg.sender, 0) < 1, \"Already has enough tokens\");\n        require(msg.sender == tx.origin, \"Can only mint through a wallet\");\n\n        bytes32 messageHash = hashTransaction(msg.sender, numberOfTokens, nonce);\n        require(messageHash.recover(signature) == _signerAddress, \"Unrecognizable Hash\");\n        require(!usedHashes[messageHash], \"Reused Hash\");\n\n        _mint(msg.sender, 0, 1, \"\");\n\n        usedHashes[messageHash] = true;\n\n       return totalSupply(0);\n  ","after":"   function mint(bytes calldata signature, string calldata nonce, uint256 numberOfTokens)\n        public\n        whenNotPaused\n        returns (uint256)\n    {   \n        require(checkBal(msg.sender), \"Does not hold enough tokens!\");\n        require( totalSupply(0) + 1 <= MAX_Tokens, \"This exceeds the maximum number of NFTs on sale!\");\n        require(balanceOf(msg.sender, 0) < 1, \"Already has enough tokens\");\n        require(msg.sender == tx.origin, \"Can only mint through a wallet\");\n\n        bytes32 messageHash = hashTransaction(msg.sender, numberOfTokens, nonce);\n        require(messageHash.recover(signature) == _signerAddress, \"Unrecognizable Hash\");\n        require(!usedHashes[messageHash], \"Reused Hash\");\n\n        _mint(msg.sender, 0, 1, \"\");\n\n        usedHashes[messageHash] = true;\n\n       return totalSupply(0);\n  ","contract":"RebelPatch","time":0},{"type":"external-function ","before":"   function setURI(string memory baseURI) external onlyOwner {\n        _setURI(baseURI);\n  ","after":"   function setURI(string calldata baseURI) external onlyOwner {\n        _setURI(baseURI);\n  ","contract":"RebelPatch","time":0},{"type":"external-function ","before":"   function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n  ","after":"   function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n  ","contract":"RebelPatch","time":0},{"type":"external-function ","before":"   function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n  ","after":"   function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n  ","contract":"RebelPatch","time":0},{"type":"external-function ","before":"   function burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n  ","after":"   function burnBatch(\n        address account,\n        uint256[] calldata ids,\n        uint256[] calldata values\n    ) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n  ","contract":"RebelPatch","time":0},{"type":"constant-restrict-modification  ","before":"   bool internal lockURI = fal","after":"   bool internal constant lockURI = fal","contract":"RebelPatch","time":1}]}