{"time":206,"results":[{"type":"external-function ","before":"function addGenesis(uint[] memory _Genesis) public onlyOwner {\n    for (uint256 i = 0; i < _Genesis.length; i++) {\n      Genesis[_Genesis[i]] = true;\n    }\n  }","after":"function addGenesis(uint[] calldata _Genesis) public onlyOwner {\n    for (uint256 i = 0; i < _Genesis.length; i++) {\n      Genesis[_Genesis[i]] = true;\n    }\n  }","contract":"Insect","time":0},{"type":"external-function ","before":"function removeGenesis(uint[] memory _Genesis) public onlyOwner {\n    for (uint256 i = 0; i < _Genesis.length; i++) {\n      Genesis[_Genesis[i]] = true;\n    }\n  }","after":"function removeGenesis(uint[] calldata _Genesis) public onlyOwner {\n    for (uint256 i = 0; i < _Genesis.length; i++) {\n      Genesis[_Genesis[i]] = true;\n    }\n  }","contract":"Insect","time":0},{"type":"state-data-arrangement ","before":"\nuint public constant MAX_TOKENS = 4444;\nuint public PRESALE_LIMIT = 4444;\nuint public presaleTokensSold = 0;\nuint public constant NUMBER_RESERVED_TOKENS = 100;\nuint256 public PRICE = 80000000000000000;\nuint public perAddressLimit = 2;\nbool public saleIsActive = false;\nbool public preSaleIsActive = false;\nbool public whitelist = true;\nbool public revealed = false;\nuint public reservedTokensMinted = 0;\nstring private _baseTokenURI;\nstring public notRevealedUri;\nbytes32 root;\nmapping(address => uint) public addressMintedBalance;\naddress payable private devguy = payable(0x0F7961EE81B7cB2B859157E9c0D7b1A1D9D35A5D);\naddress deadZone = address(0x000000000000000000000000000000000000dEaD);","after":"uint public constant MAX_TOKENS = 4444;\nuint public PRESALE_LIMIT = 4444;\nuint public presaleTokensSold = 0;\nuint public constant NUMBER_RESERVED_TOKENS = 100;\nuint256 public PRICE = 80000000000000000;\nuint public perAddressLimit = 2;\nuint public reservedTokensMinted = 0;\nstring private _baseTokenURI;\nstring public notRevealedUri;\nbytes32 root;\nmapping(address => uint) public addressMintedBalance;\naddress payable private devguy = payable(0x0F7961EE81B7cB2B859157E9c0D7b1A1D9D35A5D);\naddress deadZone = address(0x000000000000000000000000000000000000dEaD);\nbool public saleIsActive = false;\nbool public preSaleIsActive = false;\nbool public whitelist = true;\nbool public revealed = false;\n","contract":"MetaLizards","time":0},{"type":"external-function ","before":"function mintToken(uint256 amount, bytes32[] memory proof) external payable\n    {\n        require(!whitelist || verify(proof), \"Address not whitelisted\");\n        require(msg.sender == tx.origin, \"No transaction from smart contracts!\");\n        require(preSaleIsActive || saleIsActive, \"Sale must be active to mint\");\n        require(amount > 0 && amount <= 10, \"Max 10 NFTs per transaction\");\n        require(!preSaleIsActive || presaleTokensSold + amount <= PRESALE_LIMIT, \"Purchase would exceed max supply\");\n        require(totalSupply() + amount <= MAX_TOKENS - (NUMBER_RESERVED_TOKENS - reservedTokensMinted), \"Purchase would exceed max supply\");\n        require(msg.value >= PRICE * amount, \"Not enough ETH for transaction\");\n        require(addressMintedBalance[msg.sender] + amount <= perAddressLimit, \"Max NFT per address exceeded\");\n        \n        for (uint i = 0; i < amount; i++) \n        {\n            addressMintedBalance[msg.sender]++;\n            _safeMint(msg.sender, totalSupply() + 1);\n        }\n\n        if (preSaleIsActive) presaleTokensSold++;\n    }","after":"function mintToken(uint256 amount, bytes32[] calldata proof) external payable\n    {\n        require(!whitelist || verify(proof), \"Address not whitelisted\");\n        require(msg.sender == tx.origin, \"No transaction from smart contracts!\");\n        require(preSaleIsActive || saleIsActive, \"Sale must be active to mint\");\n        require(amount > 0 && amount <= 10, \"Max 10 NFTs per transaction\");\n        require(!preSaleIsActive || presaleTokensSold + amount <= PRESALE_LIMIT, \"Purchase would exceed max supply\");\n        require(totalSupply() + amount <= MAX_TOKENS - (NUMBER_RESERVED_TOKENS - reservedTokensMinted), \"Purchase would exceed max supply\");\n        require(msg.value >= PRICE * amount, \"Not enough ETH for transaction\");\n        require(addressMintedBalance[msg.sender] + amount <= perAddressLimit, \"Max NFT per address exceeded\");\n        \n        for (uint i = 0; i < amount; i++) \n        {\n            addressMintedBalance[msg.sender]++;\n            _safeMint(msg.sender, totalSupply() + 1);\n        }\n\n        if (preSaleIsActive) presaleTokensSold++;\n    }","contract":"MetaLizards","time":0},{"type":"external-function ","before":"function setNotRevealedURI(string memory _notRevealedURI) public onlyOwner {\n        notRevealedUri = _notRevealedURI;\n    }","after":"function setNotRevealedURI(string calldata _notRevealedURI) public onlyOwner {\n        notRevealedUri = _notRevealedURI;\n    }","contract":"MetaLizards","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseURI) external onlyOwner {\n        _setBaseURI(baseURI);\n    }","after":"function setBaseURI(string calldata baseURI) external onlyOwner {\n        _setBaseURI(baseURI);\n    }","contract":"MetaLizards","time":0},{"type":"constant-restrict-modification  ","before":"address payable private devguy = payable(0x0F7961EE81B7cB2B859157E9c0D7b1A1D9D35A5D);","after":"address payable private constant devguy = payable(0x0F7961EE81B7cB2B859157E9c0D7b1A1D9D35A5D);","contract":"MetaLizards","time":1},{"type":"constant-restrict-modification  ","before":"address deadZone = address(0x000000000000000000000000000000000000dEaD);","after":"address constant deadZone = address(0x000000000000000000000000000000000000dEaD);","contract":"MetaLizards","time":1}]}