{"time":235,"results":[{"type":"external-function ","before":"function newProxiedSmartPool(\n        string memory _name, \n        string memory _symbol,\n        uint256 _initialSupply,\n        address[] memory _tokens,\n        uint256[] memory _amounts,\n        uint256[] memory _weights,\n        uint256 _cap\n    ) public onlyOwner returns(address) {\n        // Deploy proxy contract\n        PProxyPausable proxy = new PProxyPausable();\n        \n        // Setup proxy\n        proxy.setImplementation(smartPoolImplementation);\n        proxy.setPauzer(msg.sender);\n        proxy.setProxyOwner(msg.sender); \n        \n        // Setup balancer pool\n        address balancerPoolAddress = balancerFactory.newBPool();\n        IBPool bPool = IBPool(balancerPoolAddress);\n\n        for(uint256 i = 0; i < _tokens.length; i ++) {\n            IERC20 token = IERC20(_tokens[i]);\n            // Transfer tokens to this contract\n            token.transferFrom(msg.sender, address(this), _amounts[i]);\n            // Approve the balancer pool\n            token.approve(balancerPoolAddress, uint256(-1));\n            // Bind tokens\n            bPool.bind(_tokens[i], _amounts[i], _weights[i]);\n        }\n        bPool.setController(address(proxy));\n        \n        // Setup smart pool\n        PCappedSmartPool smartPool = PCappedSmartPool(address(proxy));\n    \n        smartPool.init(balancerPoolAddress, _name, _symbol, _initialSupply);\n        smartPool.setCap(_cap);\n        smartPool.setPublicSwapSetter(msg.sender);\n        smartPool.setTokenBinder(msg.sender);\n        smartPool.setController(msg.sender);\n        smartPool.approveTokens();\n        \n        isPool[address(smartPool)] = true;\n        pools.push(address(smartPool));\n\n        emit SmartPoolCreated(address(smartPool), _name, _symbol);\n\n        smartPool.transfer(msg.sender, _initialSupply);\n\n        return address(smartPool);\n    }","after":"function newProxiedSmartPool(\n        string calldata _name, \n        string calldata _symbol,\n        uint256 _initialSupply,\n        address[] calldata _tokens,\n        uint256[] calldata _amounts,\n        uint256[] calldata _weights,\n        uint256 _cap\n    ) public onlyOwner returns(address) {\n        // Deploy proxy contract\n        PProxyPausable proxy = new PProxyPausable();\n        \n        // Setup proxy\n        proxy.setImplementation(smartPoolImplementation);\n        proxy.setPauzer(msg.sender);\n        proxy.setProxyOwner(msg.sender); \n        \n        // Setup balancer pool\n        address balancerPoolAddress = balancerFactory.newBPool();\n        IBPool bPool = IBPool(balancerPoolAddress);\n\n        for(uint256 i = 0; i < _tokens.length; i ++) {\n            IERC20 token = IERC20(_tokens[i]);\n            // Transfer tokens to this contract\n            token.transferFrom(msg.sender, address(this), _amounts[i]);\n            // Approve the balancer pool\n            token.approve(balancerPoolAddress, uint256(-1));\n            // Bind tokens\n            bPool.bind(_tokens[i], _amounts[i], _weights[i]);\n        }\n        bPool.setController(address(proxy));\n        \n        // Setup smart pool\n        PCappedSmartPool smartPool = PCappedSmartPool(address(proxy));\n    \n        smartPool.init(balancerPoolAddress, _name, _symbol, _initialSupply);\n        smartPool.setCap(_cap);\n        smartPool.setPublicSwapSetter(msg.sender);\n        smartPool.setTokenBinder(msg.sender);\n        smartPool.setController(msg.sender);\n        smartPool.approveTokens();\n        \n        isPool[address(smartPool)] = true;\n        pools.push(address(smartPool));\n\n        emit SmartPoolCreated(address(smartPool), _name, _symbol);\n\n        smartPool.transfer(msg.sender, _initialSupply);\n\n        return address(smartPool);\n    }","contract":"PProxiedFactory","time":0},{"type":"external-function ","before":"function initUK(address _pool, address _uniswapFactory, address _kyber, address[] memory _swapOnKyber, address _feeReciever) public {\n        // UnsiwapRecipe enforces that init can only be called once\n        ukprs storage s = lukprs();\n\n        PUniswapPoolRecipe.init(_pool, _uniswapFactory);\n        s.kyber = IKyberNetwork(_kyber);\n        s.feeReceiver = _feeReciever;\n\n        _setOwner(msg.sender);\n\n        for(uint256 i = 0; i < _swapOnKyber.length; i ++) {\n            s.swapOnKyber[_swapOnKyber[i]] = true;\n        }\n    }","after":"function initUK(address _pool, address _uniswapFactory, address _kyber, address[] calldata _swapOnKyber, address _feeReciever) public {\n        // UnsiwapRecipe enforces that init can only be called once\n        ukprs storage s = lukprs();\n\n        PUniswapPoolRecipe.init(_pool, _uniswapFactory);\n        s.kyber = IKyberNetwork(_kyber);\n        s.feeReceiver = _feeReciever;\n\n        _setOwner(msg.sender);\n\n        for(uint256 i = 0; i < _swapOnKyber.length; i ++) {\n            s.swapOnKyber[_swapOnKyber[i]] = true;\n        }\n    }","contract":"PUniswapKyberPoolRecipe","time":0}]}