{"time":480,"results":[{"type":"external-function ","before":"function initialize(string memory name, string memory symbol)\n        external\n        initializer\n        returns (bool)\n    {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __Ownable_init_unchained();\n        return true;\n    }","after":"function initialize(string calldata name, string calldata symbol)\n        external\n        initializer\n        returns (bool)\n    {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name, symbol);\n        __Ownable_init_unchained();\n        return true;\n    }","contract":"LPToken","time":0},{"type":"external-function ","before":"function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual override initializer {\n        Swap.initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress\n        );\n        flashLoanFeeBPS = 8; // 8 bps\n        protocolFeeShareBPS = 0; // 0 bps\n    }","after":"function initialize(\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual override initializer {\n        Swap.initialize(\n            _pooledTokens,\n            decimals,\n            lpTokenName,\n            lpTokenSymbol,\n            _a,\n            _fee,\n            _adminFee,\n            lpTokenTargetAddress\n        );\n        flashLoanFeeBPS = 8; // 8 bps\n        protocolFeeShareBPS = 0; // 0 bps\n    }","contract":"SwapFlashLoan","time":1},{"type":"external-function ","before":"function flashLoan(\n        address receiver,\n        IERC20 token,\n        uint256 amount,\n        bytes memory params\n    ) external nonReentrant {\n        uint8 tokenIndex = getTokenIndex(address(token));\n        uint256 availableLiquidityBefore = token.balanceOf(address(this));\n        uint256 protocolBalanceBefore =\n            availableLiquidityBefore.sub(swapStorage.balances[tokenIndex]);\n        require(\n            amount > 0 && availableLiquidityBefore >= amount,\n            \"invalid amount\"\n        );\n\n        // Calculate the additional amount of tokens the pool should end up with\n        uint256 amountFee = amount.mul(flashLoanFeeBPS).div(10000);\n        // Calculate the portion of the fee that will go to the protocol\n        uint256 protocolFee = amountFee.mul(protocolFeeShareBPS).div(10000);\n        require(amountFee > 0, \"amount is small for a flashLoan\");\n\n        // Transfer the requested amount of tokens\n        token.safeTransfer(receiver, amount);\n\n        // Execute callback function on receiver\n        IFlashLoanReceiver(receiver).executeOperation(\n            address(this),\n            address(token),\n            amount,\n            amountFee,\n            params\n        );\n\n        uint256 availableLiquidityAfter = token.balanceOf(address(this));\n        require(\n            availableLiquidityAfter >= availableLiquidityBefore.add(amountFee),\n            \"flashLoan fee is not met\"\n        );\n\n        swapStorage.balances[tokenIndex] = availableLiquidityAfter\n            .sub(protocolBalanceBefore)\n            .sub(protocolFee);\n        emit FlashLoan(receiver, tokenIndex, amount, amountFee, protocolFee);\n    }","after":"function flashLoan(\n        address receiver,\n        IERC20 token,\n        uint256 amount,\n        bytes calldata params\n    ) external nonReentrant {\n        uint8 tokenIndex = getTokenIndex(address(token));\n        uint256 availableLiquidityBefore = token.balanceOf(address(this));\n        uint256 protocolBalanceBefore =\n            availableLiquidityBefore.sub(swapStorage.balances[tokenIndex]);\n        require(\n            amount > 0 && availableLiquidityBefore >= amount,\n            \"invalid amount\"\n        );\n\n        // Calculate the additional amount of tokens the pool should end up with\n        uint256 amountFee = amount.mul(flashLoanFeeBPS).div(10000);\n        // Calculate the portion of the fee that will go to the protocol\n        uint256 protocolFee = amountFee.mul(protocolFeeShareBPS).div(10000);\n        require(amountFee > 0, \"amount is small for a flashLoan\");\n\n        // Transfer the requested amount of tokens\n        token.safeTransfer(receiver, amount);\n\n        // Execute callback function on receiver\n        IFlashLoanReceiver(receiver).executeOperation(\n            address(this),\n            address(token),\n            amount,\n            amountFee,\n            params\n        );\n\n        uint256 availableLiquidityAfter = token.balanceOf(address(this));\n        require(\n            availableLiquidityAfter >= availableLiquidityBefore.add(amountFee),\n            \"flashLoan fee is not met\"\n        );\n\n        swapStorage.balances[tokenIndex] = availableLiquidityAfter\n            .sub(protocolBalanceBefore)\n            .sub(protocolFee);\n        emit FlashLoan(receiver, tokenIndex, amount, amountFee, protocolFee);\n    }","contract":"SwapFlashLoan","time":0},{"type":"external-function ","before":"function initialize(\n        IERC20[] memory _pooledTokens,\n        uint8[] memory decimals,\n        string memory lpTokenName,\n        string memory lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual initializer {\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                        _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            precisionMultipliers[i] =\n                10 **\n                    uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(\n                        uint256(decimals[i])\n                    );\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < AmplificationUtils.MAX_A, \"_a exceeds maximum\");\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < SwapUtils.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n\n        // Clone and initialize a LPToken contract\n        LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n        require(\n            lpToken.initialize(lpTokenName, lpTokenSymbol),\n            \"could not init lpToken clone\"\n        );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = lpToken;\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a.mul(AmplificationUtils.A_PRECISION);\n        swapStorage.futureA = _a.mul(AmplificationUtils.A_PRECISION);\n        // swapStorage.initialATime = 0;\n        // swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n    }","after":"function initialize(\n        IERC20[] calldata _pooledTokens,\n        uint8[] calldata decimals,\n        string calldata lpTokenName,\n        string calldata lpTokenSymbol,\n        uint256 _a,\n        uint256 _fee,\n        uint256 _adminFee,\n        address lpTokenTargetAddress\n    ) public virtual initializer {\n        __OwnerPausable_init();\n        __ReentrancyGuard_init();\n        // Check _pooledTokens and precisions parameter\n        require(_pooledTokens.length > 1, \"_pooledTokens.length <= 1\");\n        require(_pooledTokens.length <= 32, \"_pooledTokens.length > 32\");\n        require(\n            _pooledTokens.length == decimals.length,\n            \"_pooledTokens decimals mismatch\"\n        );\n\n        uint256[] memory precisionMultipliers = new uint256[](decimals.length);\n\n        for (uint8 i = 0; i < _pooledTokens.length; i++) {\n            if (i > 0) {\n                // Check if index is already used. Check if 0th element is a duplicate.\n                require(\n                    tokenIndexes[address(_pooledTokens[i])] == 0 &&\n                        _pooledTokens[0] != _pooledTokens[i],\n                    \"Duplicate tokens\"\n                );\n            }\n            require(\n                address(_pooledTokens[i]) != address(0),\n                \"The 0 address isn't an ERC-20\"\n            );\n            require(\n                decimals[i] <= SwapUtils.POOL_PRECISION_DECIMALS,\n                \"Token decimals exceeds max\"\n            );\n            precisionMultipliers[i] =\n                10 **\n                    uint256(SwapUtils.POOL_PRECISION_DECIMALS).sub(\n                        uint256(decimals[i])\n                    );\n            tokenIndexes[address(_pooledTokens[i])] = i;\n        }\n\n        // Check _a, _fee, _adminFee, _withdrawFee parameters\n        require(_a < AmplificationUtils.MAX_A, \"_a exceeds maximum\");\n        require(_fee < SwapUtils.MAX_SWAP_FEE, \"_fee exceeds maximum\");\n        require(\n            _adminFee < SwapUtils.MAX_ADMIN_FEE,\n            \"_adminFee exceeds maximum\"\n        );\n\n        // Clone and initialize a LPToken contract\n        LPToken lpToken = LPToken(Clones.clone(lpTokenTargetAddress));\n        require(\n            lpToken.initialize(lpTokenName, lpTokenSymbol),\n            \"could not init lpToken clone\"\n        );\n\n        // Initialize swapStorage struct\n        swapStorage.lpToken = lpToken;\n        swapStorage.pooledTokens = _pooledTokens;\n        swapStorage.tokenPrecisionMultipliers = precisionMultipliers;\n        swapStorage.balances = new uint256[](_pooledTokens.length);\n        swapStorage.initialA = _a.mul(AmplificationUtils.A_PRECISION);\n        swapStorage.futureA = _a.mul(AmplificationUtils.A_PRECISION);\n        // swapStorage.initialATime = 0;\n        // swapStorage.futureATime = 0;\n        swapStorage.swapFee = _fee;\n        swapStorage.adminFee = _adminFee;\n    }","contract":"SwapFlashLoan","time":0},{"type":"external-function ","before":"function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] memory amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        ManageLiquidityInfo memory v =\n            ManageLiquidityInfo(\n                0,\n                0,\n                0,\n                _getAPrecise(self),\n                self.lpToken,\n                0,\n                self.balances,\n                self.tokenPrecisionMultipliers\n            );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        IERC20[] memory pooledTokens = self.pooledTokens;\n\n        require(\n            amounts.length == pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n\n        require(\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\n                maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n        {\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                balances1[i] = v.balances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }\n\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n        }\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1);\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }","after":"function removeLiquidityImbalance(\n        Swap storage self,\n        uint256[] calldata amounts,\n        uint256 maxBurnAmount\n    ) public returns (uint256) {\n        ManageLiquidityInfo memory v =\n            ManageLiquidityInfo(\n                0,\n                0,\n                0,\n                _getAPrecise(self),\n                self.lpToken,\n                0,\n                self.balances,\n                self.tokenPrecisionMultipliers\n            );\n        v.totalSupply = v.lpToken.totalSupply();\n\n        IERC20[] memory pooledTokens = self.pooledTokens;\n\n        require(\n            amounts.length == pooledTokens.length,\n            \"Amounts should match pool tokens\"\n        );\n\n        require(\n            maxBurnAmount <= v.lpToken.balanceOf(msg.sender) &&\n                maxBurnAmount != 0,\n            \">LP.balanceOf\"\n        );\n\n        uint256 feePerToken = _feePerToken(self.swapFee, pooledTokens.length);\n        uint256[] memory fees = new uint256[](pooledTokens.length);\n        {\n            uint256[] memory balances1 = new uint256[](pooledTokens.length);\n            v.d0 = getD(_xp(v.balances, v.multipliers), v.preciseA);\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                balances1[i] = v.balances[i].sub(\n                    amounts[i],\n                    \"Cannot withdraw more than available\"\n                );\n            }\n            v.d1 = getD(_xp(balances1, v.multipliers), v.preciseA);\n\n            for (uint256 i = 0; i < pooledTokens.length; i++) {\n                uint256 idealBalance = v.d1.mul(v.balances[i]).div(v.d0);\n                uint256 difference = idealBalance.difference(balances1[i]);\n                fees[i] = feePerToken.mul(difference).div(FEE_DENOMINATOR);\n                self.balances[i] = balances1[i].sub(\n                    fees[i].mul(self.adminFee).div(FEE_DENOMINATOR)\n                );\n                balances1[i] = balances1[i].sub(fees[i]);\n            }\n\n            v.d2 = getD(_xp(balances1, v.multipliers), v.preciseA);\n        }\n        uint256 tokenAmount = v.d0.sub(v.d2).mul(v.totalSupply).div(v.d0);\n        require(tokenAmount != 0, \"Burnt amount cannot be zero\");\n        tokenAmount = tokenAmount.add(1);\n\n        require(tokenAmount <= maxBurnAmount, \"tokenAmount > maxBurnAmount\");\n\n        v.lpToken.burnFrom(msg.sender, tokenAmount);\n\n        for (uint256 i = 0; i < pooledTokens.length; i++) {\n            pooledTokens[i].safeTransfer(msg.sender, amounts[i]);\n        }\n\n        emit RemoveLiquidityImbalance(\n            msg.sender,\n            amounts,\n            fees,\n            v.d1,\n            v.totalSupply.sub(tokenAmount)\n        );\n\n        return tokenAmount;\n    }","contract":"SwapUtils","time":0}]}