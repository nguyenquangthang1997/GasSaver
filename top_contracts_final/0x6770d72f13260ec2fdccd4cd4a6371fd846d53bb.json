{"time":151,"results":[{"type":"external-function ","before":"function setBaseTokenURI(string memory uri_) external onlyOwner {\n        baseTokenURI = uri_; }","after":"function setBaseTokenURI(string calldata uri_) external onlyOwner {\n        baseTokenURI = uri_; }","contract":"MetaChickens","time":0},{"type":"external-function ","before":"function setBaseTokenURI_EXT(string memory ext_) external onlyOwner {\n        baseTokenURI_EXT = ext_; }","after":"function setBaseTokenURI_EXT(string calldata ext_) external onlyOwner {\n        baseTokenURI_EXT = ext_; }","contract":"MetaChickens","time":0},{"type":"external-function ","before":"function changeName(uint256 tokenId_, string memory name_) public onlyControllers {\n        metaChickensName[tokenId_] = name_; }","after":"function changeName(uint256 tokenId_, string calldata name_) public onlyControllers {\n        metaChickensName[tokenId_] = name_; }","contract":"MetaChickens","time":0},{"type":"external-function ","before":"function changeBio(uint256 tokenId_, string memory bio_) public onlyControllers {\n        metaChickensBio[tokenId_] = bio_; }","after":"function changeBio(uint256 tokenId_, string calldata bio_) public onlyControllers {\n        metaChickensBio[tokenId_] = bio_; }","contract":"MetaChickens","time":0},{"type":"external-function ","before":"function ownerMintToMany(address[] memory tos_, uint256[] memory amounts_) external onlyOwner {\n        require(tos_.length == amounts_.length, \"Length mismatch!\");\n        // Iterate through each request\n        for (uint256 i = 0; i < tos_.length; i++) {\n            // Do ownerMint logic\n            for (uint256 j = 0 ; j < amounts_[i]; j++) {\n                _mint(tos_[i], __getTokenId() + j);\n            }\n            totalSupply += amounts_[i];\n        }\n    }","after":"function ownerMintToMany(address[] calldata tos_, uint256[] calldata amounts_) external onlyOwner {\n        require(tos_.length == amounts_.length, \"Length mismatch!\");\n        // Iterate through each request\n        for (uint256 i = 0; i < tos_.length; i++) {\n            // Do ownerMint logic\n            for (uint256 j = 0 ; j < amounts_[i]; j++) {\n                _mint(tos_[i], __getTokenId() + j);\n            }\n            totalSupply += amounts_[i];\n        }\n    }","contract":"MetaChickens","time":0},{"type":"external-function ","before":"function whitelistMint(bytes32[] memory proof_, uint256 amount_) external payable onlySender whitelistSale {\n        require(isWhitelisted(msg.sender, proof_), \"You are not whitelisted!\");\n        require(addressToWhitelistMinted[msg.sender]+amount_ < 3, \"You have no whitelisted mints remaining!\");\n        require(msg.value == mintPrice*amount_, \"Invalid Value Sent!\");\n        require(maxTokens >= totalSupply+amount_, \"No enough tokens available!\");\n        for (uint256 i = 0; i < amount_; i++) {\n            _mint(msg.sender, __getTokenId());\n            emit Mint(msg.sender, __getTokenId());\n            addressToWhitelistMinted[msg.sender]++;\n            totalSupply++;\n        }\n    }","after":"function whitelistMint(bytes32[] calldata proof_, uint256 amount_) external payable onlySender whitelistSale {\n        require(isWhitelisted(msg.sender, proof_), \"You are not whitelisted!\");\n        require(addressToWhitelistMinted[msg.sender]+amount_ < 3, \"You have no whitelisted mints remaining!\");\n        require(msg.value == mintPrice*amount_, \"Invalid Value Sent!\");\n        require(maxTokens >= totalSupply+amount_, \"No enough tokens available!\");\n        for (uint256 i = 0; i < amount_; i++) {\n            _mint(msg.sender, __getTokenId());\n            emit Mint(msg.sender, __getTokenId());\n            addressToWhitelistMinted[msg.sender]++;\n            totalSupply++;\n        }\n    }","contract":"MetaChickens","time":0},{"type":"external-function ","before":"function multiTransferFrom(address from_, address to_, uint256[] memory tokenIds_) public {\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            ERC721.transferFrom(from_, to_, tokenIds_[i]);\n        }\n    }","after":"function multiTransferFrom(address from_, address to_, uint256[] calldata tokenIds_) public {\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            ERC721.transferFrom(from_, to_, tokenIds_[i]);\n        }\n    }","contract":"MetaChickens","time":0},{"type":"external-function ","before":"function multiSafeTransferFrom(address from_, address to_, uint256[] memory tokenIds_, bytes[] memory datas_) public {\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            ERC721.safeTransferFrom(from_, to_, tokenIds_[i], datas_[i]);\n        }\n    }","after":"function multiSafeTransferFrom(address from_, address to_, uint256[] calldata tokenIds_, bytes[] calldata datas_) public {\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\n            ERC721.safeTransferFrom(from_, to_, tokenIds_[i], datas_[i]);\n        }\n    }","contract":"MetaChickens","time":0},{"type":"constant-restrict-modification  ","before":"uint16 immutable public maxTokens = 10000;","after":"uint16 immutable public constant maxTokens = 10000;","contract":"MetaChickens","time":1}]}