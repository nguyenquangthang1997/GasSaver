{"time":123,"results":[{"type":"external-function ","before":"function transferToOtherBlockchain(uint128 blockchain, uint256 amount, string memory newAddress) external whenNotPaused\n    {\n        require(\n            bytes(newAddress).length > 0,\n            \"swapContract: No destination address provided\"\n        );\n        require(\n            existingOtherBlockchain[blockchain] && blockchain != numOfThisBlockchain,\n            \"swapContract: Wrong choose of blockchain\"\n        );\n        require(\n            amount >= feeAmountOfBlockchain[blockchain],\n            \"swapContract: Not enough amount of tokens\"\n        );\n        address sender = _msgSender();\n        require(\n            tokenAddress.balanceOf(sender) >= amount,\n            \"swapContract: Not enough balance\"\n        );\n        tokenAddress.transferFrom(sender, address(this), amount);\n        emit TransferToOtherBlockchain(blockchain, sender, amount, newAddress);\n    }","after":"function transferToOtherBlockchain(uint128 blockchain, uint256 amount, string calldata newAddress) external whenNotPaused\n    {\n        require(\n            bytes(newAddress).length > 0,\n            \"swapContract: No destination address provided\"\n        );\n        require(\n            existingOtherBlockchain[blockchain] && blockchain != numOfThisBlockchain,\n            \"swapContract: Wrong choose of blockchain\"\n        );\n        require(\n            amount >= feeAmountOfBlockchain[blockchain],\n            \"swapContract: Not enough amount of tokens\"\n        );\n        address sender = _msgSender();\n        require(\n            tokenAddress.balanceOf(sender) >= amount,\n            \"swapContract: Not enough balance\"\n        );\n        tokenAddress.transferFrom(sender, address(this), amount);\n        emit TransferToOtherBlockchain(blockchain, sender, amount, newAddress);\n    }","contract":"swapContract","time":0},{"type":"external-function ","before":"function transferToUserWithFee(\n        address user,\n        uint256 amountWithFee,\n        bytes32 originalTxHash,\n        bytes memory concatSignatures\n    ) \n        external\n        onlyRelayer\n        whenNotPaused\n    {\n        require(\n            amountWithFee >= minTokenAmount,\n            \"swapContract: Amount must be greater than minimum\"\n        );\n        require(\n            user != address(0),\n            \"swapContract: Address cannot be zero address\"   // TODO: check this requirement\n        );\n        require(\n            concatSignatures.length.mod(SIGNATURE_LENGTH) == 0,\n            \"swapContract: Signatures lengths must be divisible by 65\"\n        );\n        require(\n            concatSignatures.length.div(SIGNATURE_LENGTH) >= minConfirmationSignatures,\n            \"swapContract: Not enough signatures passed\"\n        );\n\n        bytes32 hashedParams = getHashPacked(user, amountWithFee, originalTxHash);\n        (bool processed, bytes32 savedHash) = isProcessedTransaction(originalTxHash);\n        require(!processed && savedHash != hashedParams, \"swapContract: Transaction already processed\");\n        \n        uint256 signaturesCount = concatSignatures.length.div(uint256(SIGNATURE_LENGTH));\n        address[] memory validatorAddresses = new address[](signaturesCount);\n        for (uint256 i = 0; i < signaturesCount; i++) {\n            address validatorAddress = ecOffsetRecover(hashedParams, concatSignatures, i * SIGNATURE_LENGTH);\n            require(isValidator(validatorAddress), \"swapContract: Validator address not in whitelist\");\n            for (uint256 j = 0; j < i; j++) {\n                require(validatorAddress != validatorAddresses[j], \"swapContract: Validator address is duplicated\");\n            }\n            validatorAddresses[i] = validatorAddress;\n        }\n        processedTransactions[originalTxHash] = hashedParams;\n\n        uint256 fee = feeAmountOfBlockchain[numOfThisBlockchain];\n        uint256 amountWithoutFee = amountWithFee.sub(fee);\n        tokenAddress.transfer(user, amountWithoutFee);\n        tokenAddress.transfer(feeAddress, fee);\n        emit TransferFromOtherBlockchain(user, amountWithFee, amountWithoutFee, originalTxHash);\n    }","after":"function transferToUserWithFee(\n        address user,\n        uint256 amountWithFee,\n        bytes32 originalTxHash,\n        bytes calldata concatSignatures\n    ) \n        external\n        onlyRelayer\n        whenNotPaused\n    {\n        require(\n            amountWithFee >= minTokenAmount,\n            \"swapContract: Amount must be greater than minimum\"\n        );\n        require(\n            user != address(0),\n            \"swapContract: Address cannot be zero address\"   // TODO: check this requirement\n        );\n        require(\n            concatSignatures.length.mod(SIGNATURE_LENGTH) == 0,\n            \"swapContract: Signatures lengths must be divisible by 65\"\n        );\n        require(\n            concatSignatures.length.div(SIGNATURE_LENGTH) >= minConfirmationSignatures,\n            \"swapContract: Not enough signatures passed\"\n        );\n\n        bytes32 hashedParams = getHashPacked(user, amountWithFee, originalTxHash);\n        (bool processed, bytes32 savedHash) = isProcessedTransaction(originalTxHash);\n        require(!processed && savedHash != hashedParams, \"swapContract: Transaction already processed\");\n        \n        uint256 signaturesCount = concatSignatures.length.div(uint256(SIGNATURE_LENGTH));\n        address[] memory validatorAddresses = new address[](signaturesCount);\n        for (uint256 i = 0; i < signaturesCount; i++) {\n            address validatorAddress = ecOffsetRecover(hashedParams, concatSignatures, i * SIGNATURE_LENGTH);\n            require(isValidator(validatorAddress), \"swapContract: Validator address not in whitelist\");\n            for (uint256 j = 0; j < i; j++) {\n                require(validatorAddress != validatorAddresses[j], \"swapContract: Validator address is duplicated\");\n            }\n            validatorAddresses[i] = validatorAddress;\n        }\n        processedTransactions[originalTxHash] = hashedParams;\n\n        uint256 fee = feeAmountOfBlockchain[numOfThisBlockchain];\n        uint256 amountWithoutFee = amountWithFee.sub(fee);\n        tokenAddress.transfer(user, amountWithoutFee);\n        tokenAddress.transfer(feeAddress, fee);\n        emit TransferFromOtherBlockchain(user, amountWithFee, amountWithoutFee, originalTxHash);\n    }","contract":"swapContract","time":0},{"type":"immutable-restrict-modification ","before":"uint128 public numOfThisBlockchain;","after":"uint128 public immutable numOfThisBlockchain;","contract":"swapContract","time":1}]}