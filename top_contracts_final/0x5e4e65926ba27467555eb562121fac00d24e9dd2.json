{"time":179,"results":[{"type":"external-function ","before":"function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes memory _data\n    ) external {\n        require(\n            _data.length <= MAX_ROLLUP_TX_SIZE,\n            \"Transaction data size exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit <= maxTransactionGasLimit,\n            \"Transaction gas limit exceeds maximum for rollup transaction.\"\n        );\n\n        require(_gasLimit >= MIN_ROLLUP_TX_GAS, \"Transaction gas limit too low to enqueue.\");\n\n        // Transactions submitted to the queue lack a method for paying gas fees to the Sequencer.\n        // So we need to prevent spam attacks by ensuring that the cost of enqueueing a transaction\n        // from L1 to L2 is not underpriced. For transaction with a high L2 gas limit, we do this by\n        // burning some extra gas on L1. Of course there is also some intrinsic cost to enqueueing a\n        // transaction, so we want to make sure not to over-charge (by burning too much L1 gas).\n        // Therefore, we define 'enqueueL2GasPrepaid' as the L2 gas limit above which we must burn\n        // additional gas on L1. This threshold is the product of two inputs:\n        // 1. enqueueGasCost: the base cost of calling this function.\n        // 2. l2GasDiscountDivisor: the ratio between the cost of gas on L1 and L2. This is a\n        //    positive integer, meaning we assume L2 gas is always less costly.\n        // The calculation below for gasToConsume can be seen as converting the difference (between\n        // the specified L2 gas limit and the prepaid L2 gas limit) to an L1 gas amount.\n        if (_gasLimit > enqueueL2GasPrepaid) {\n            uint256 gasToConsume = (_gasLimit - enqueueL2GasPrepaid) / l2GasDiscountDivisor;\n            uint256 startingGas = gasleft();\n\n            // Although this check is not necessary (burn below will run out of gas if not true), it\n            // gives the user an explicit reason as to why the enqueue attempt failed.\n            require(startingGas > gasToConsume, \"Insufficient gas for L2 rate limiting burn.\");\n\n            uint256 i;\n            while (startingGas - gasleft() < gasToConsume) {\n                i++;\n            }\n        }\n\n        // Apply an aliasing unless msg.sender == tx.origin. This prevents an attack in which a\n        // contract on L1 has the same address as a contract on L2 but doesn't have the same code.\n        // We can safely ignore this for EOAs because they're guaranteed to have the same \"code\"\n        // (i.e. no code at all). This also makes it possible for users to interact with contracts\n        // on L2 even when the Sequencer is down.\n        address sender;\n        if (msg.sender == tx.origin) {\n            sender = msg.sender;\n        } else {\n            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        bytes32 transactionHash = keccak256(abi.encode(sender, _target, _gasLimit, _data));\n\n        queueElements.push(\n            Lib_OVMCodec.QueueElement({\n                transactionHash: transactionHash,\n                timestamp: uint40(block.timestamp),\n                blockNumber: uint40(block.number)\n            })\n        );\n        uint256 queueIndex = queueElements.length - 1;\n        emit TransactionEnqueued(sender, _target, _gasLimit, _data, queueIndex, block.timestamp);\n    }","after":"function enqueue(\n        address _target,\n        uint256 _gasLimit,\n        bytes calldata _data\n    ) external {\n        require(\n            _data.length <= MAX_ROLLUP_TX_SIZE,\n            \"Transaction data size exceeds maximum for rollup transaction.\"\n        );\n\n        require(\n            _gasLimit <= maxTransactionGasLimit,\n            \"Transaction gas limit exceeds maximum for rollup transaction.\"\n        );\n\n        require(_gasLimit >= MIN_ROLLUP_TX_GAS, \"Transaction gas limit too low to enqueue.\");\n\n        // Transactions submitted to the queue lack a method for paying gas fees to the Sequencer.\n        // So we need to prevent spam attacks by ensuring that the cost of enqueueing a transaction\n        // from L1 to L2 is not underpriced. For transaction with a high L2 gas limit, we do this by\n        // burning some extra gas on L1. Of course there is also some intrinsic cost to enqueueing a\n        // transaction, so we want to make sure not to over-charge (by burning too much L1 gas).\n        // Therefore, we define 'enqueueL2GasPrepaid' as the L2 gas limit above which we must burn\n        // additional gas on L1. This threshold is the product of two inputs:\n        // 1. enqueueGasCost: the base cost of calling this function.\n        // 2. l2GasDiscountDivisor: the ratio between the cost of gas on L1 and L2. This is a\n        //    positive integer, meaning we assume L2 gas is always less costly.\n        // The calculation below for gasToConsume can be seen as converting the difference (between\n        // the specified L2 gas limit and the prepaid L2 gas limit) to an L1 gas amount.\n        if (_gasLimit > enqueueL2GasPrepaid) {\n            uint256 gasToConsume = (_gasLimit - enqueueL2GasPrepaid) / l2GasDiscountDivisor;\n            uint256 startingGas = gasleft();\n\n            // Although this check is not necessary (burn below will run out of gas if not true), it\n            // gives the user an explicit reason as to why the enqueue attempt failed.\n            require(startingGas > gasToConsume, \"Insufficient gas for L2 rate limiting burn.\");\n\n            uint256 i;\n            while (startingGas - gasleft() < gasToConsume) {\n                i++;\n            }\n        }\n\n        // Apply an aliasing unless msg.sender == tx.origin. This prevents an attack in which a\n        // contract on L1 has the same address as a contract on L2 but doesn't have the same code.\n        // We can safely ignore this for EOAs because they're guaranteed to have the same \"code\"\n        // (i.e. no code at all). This also makes it possible for users to interact with contracts\n        // on L2 even when the Sequencer is down.\n        address sender;\n        if (msg.sender == tx.origin) {\n            sender = msg.sender;\n        } else {\n            sender = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\n        }\n\n        bytes32 transactionHash = keccak256(abi.encode(sender, _target, _gasLimit, _data));\n\n        queueElements.push(\n            Lib_OVMCodec.QueueElement({\n                transactionHash: transactionHash,\n                timestamp: uint40(block.timestamp),\n                blockNumber: uint40(block.number)\n            })\n        );\n        uint256 queueIndex = queueElements.length - 1;\n        emit TransactionEnqueued(sender, _target, _gasLimit, _data, queueIndex, block.timestamp);\n    }","contract":"CanonicalTransactionChain","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public maxTransactionGasLimit;","after":"uint256 public immutable maxTransactionGasLimit;","contract":"CanonicalTransactionChain","time":0},{"type":"external-function ","before":"function setAddress(string memory _name, address _address) external onlyOwner {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(_name, _address, oldAddress);\n    }","after":"function setAddress(string calldata _name, address _address) external onlyOwner {\n        bytes32 nameHash = _getNameHash(_name);\n        address oldAddress = addresses[nameHash];\n        addresses[nameHash] = _address;\n\n        emit AddressSet(_name, _address, oldAddress);\n    }","contract":"Lib_AddressManager","time":0}]}