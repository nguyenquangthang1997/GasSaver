{"time":261,"results":[{"type":"external-function ","before":"function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }","after":"function initialize(string calldata name, string calldata symbol, uint8 decimals) public initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }","contract":"RenToken","time":0},{"type":"external-function ","before":"function initialize(\n        string memory _VERSION,\n        RenToken _renAddress,\n        DarknodeRegistryStore _storeAddress,\n        uint256 _minimumBond,\n        uint256 _minimumPodSize,\n        uint256 _minimumEpochIntervalSeconds,\n        uint256 _deregistrationIntervalSeconds\n    ) public initializer {\n        Claimable.initialize(msg.sender);\n        CanReclaimTokens.initialize(msg.sender);\n        VERSION = _VERSION;\n\n        store = _storeAddress;\n        ren = _renAddress;\n\n        minimumBond = _minimumBond;\n        nextMinimumBond = minimumBond;\n\n        minimumPodSize = _minimumPodSize;\n        nextMinimumPodSize = minimumPodSize;\n\n        minimumEpochInterval = _minimumEpochIntervalSeconds;\n        nextMinimumEpochInterval = minimumEpochInterval;\n        deregistrationInterval = _deregistrationIntervalSeconds;\n\n        uint256 epochhash = uint256(blockhash(block.number - 1));\n        currentEpoch = Epoch({\n            epochhash: epochhash,\n            blocktime: block.timestamp\n        });\n        emit LogNewEpoch(epochhash);\n    }","after":"function initialize(\n        string calldata _VERSION,\n        RenToken _renAddress,\n        DarknodeRegistryStore _storeAddress,\n        uint256 _minimumBond,\n        uint256 _minimumPodSize,\n        uint256 _minimumEpochIntervalSeconds,\n        uint256 _deregistrationIntervalSeconds\n    ) public initializer {\n        Claimable.initialize(msg.sender);\n        CanReclaimTokens.initialize(msg.sender);\n        VERSION = _VERSION;\n\n        store = _storeAddress;\n        ren = _renAddress;\n\n        minimumBond = _minimumBond;\n        nextMinimumBond = minimumBond;\n\n        minimumPodSize = _minimumPodSize;\n        nextMinimumPodSize = minimumPodSize;\n\n        minimumEpochInterval = _minimumEpochIntervalSeconds;\n        nextMinimumEpochInterval = minimumEpochInterval;\n        deregistrationInterval = _deregistrationIntervalSeconds;\n\n        uint256 epochhash = uint256(blockhash(block.number - 1));\n        currentEpoch = Epoch({\n            epochhash: epochhash,\n            blocktime: block.timestamp\n        });\n        emit LogNewEpoch(epochhash);\n    }","contract":"DarknodeRegistryLogicV1","time":0},{"type":"external-function ","before":"function initialize(address _logic, address _admin, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }","after":"function initialize(address _logic, address _admin, bytes calldata _data) public payable {\n    require(_implementation() == address(0));\n    InitializableUpgradeabilityProxy.initialize(_logic, _data);\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(_admin);\n  }","contract":"DarknodeRegistryProxy","time":0},{"type":"external-function ","before":"function initialize(address _logic, bytes memory _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }","after":"function initialize(address _logic, bytes calldata _data) public payable {\n    require(_implementation() == address(0));\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }","contract":"DarknodeRegistryProxy","time":0}]}