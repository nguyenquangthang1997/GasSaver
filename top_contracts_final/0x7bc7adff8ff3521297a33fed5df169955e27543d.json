{"time":85,"results":[{"type":"external-function ","before":"function addTokenWyvernType(uint[] memory tokenIds, uint[] memory wyvernTypeCodes) external onlyOwner {\n        require(tokenIds.length == wyvernTypeCodes.length, \"Inputs provided with different no of values, should be EQUAL.\");\n        for (uint i = 0; i < tokenIds.length; i++) {\n            wyvernTokenToWyvernType[tokenIds[i]] = wyvernTypeCodes[i];\n        }\n    }","after":"function addTokenWyvernType(uint[] calldata tokenIds, uint[] calldata wyvernTypeCodes) external onlyOwner {\n        require(tokenIds.length == wyvernTypeCodes.length, \"Inputs provided with different no of values, should be EQUAL.\");\n        for (uint i = 0; i < tokenIds.length; i++) {\n            wyvernTokenToWyvernType[tokenIds[i]] = wyvernTypeCodes[i];\n        }\n    }","contract":"WYVERNSBREATH","time":0},{"type":"external-function ","before":"function claimToken(uint[] memory tokenIds) external {\n        uint amount = 0;\n        uint today_count = block.timestamp / timeInSecsInADay;\n        for (uint i = 0; i < tokenIds.length; i++) {\n            if (nft.ownerOf(tokenIds[i]) == msg.sender) {\n                uint tokenAccumulation = getPendingReward(tokenIds[i], today_count, getTypeOfToken(tokenIds[i]));\n                if (tokenAccumulation > 0) {\n                    if (maxSupply < _totalSupply + amount + tokenAccumulation) {\n                        emit mintOverflown(amount, tokenAccumulation, \"Minting Limit Reached\");\n                        break;\n                    }\n                    amount += tokenAccumulation;\n                    lastUpdate[tokenIds[i]] = today_count;\n                }\n            }\n        }\n        require (amount > 0,\"NO positive number of $BREATH tokens are available to mint\");\n        _mint(msg.sender, amount);\n    }","after":"function claimToken(uint[] calldata tokenIds) external {\n        uint amount = 0;\n        uint today_count = block.timestamp / timeInSecsInADay;\n        for (uint i = 0; i < tokenIds.length; i++) {\n            if (nft.ownerOf(tokenIds[i]) == msg.sender) {\n                uint tokenAccumulation = getPendingReward(tokenIds[i], today_count, getTypeOfToken(tokenIds[i]));\n                if (tokenAccumulation > 0) {\n                    if (maxSupply < _totalSupply + amount + tokenAccumulation) {\n                        emit mintOverflown(amount, tokenAccumulation, \"Minting Limit Reached\");\n                        break;\n                    }\n                    amount += tokenAccumulation;\n                    lastUpdate[tokenIds[i]] = today_count;\n                }\n            }\n        }\n        require (amount > 0,\"NO positive number of $BREATH tokens are available to mint\");\n        _mint(msg.sender, amount);\n    }","contract":"WYVERNSBREATH","time":0},{"type":"constant-restrict-modification  ","before":"uint deployedTime = 1637427600;","after":"uint constant deployedTime = 1637427600;","contract":"WYVERNSBREATH","time":0},{"type":"immutable-restrict-modification ","before":"uint8 public _decimals;","after":"uint8 public immutable _decimals;","contract":"WYVERNSBREATH","time":0}]}