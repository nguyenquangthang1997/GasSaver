{"time":74,"results":[{"type":"external-function ","before":"function mint(uint256 nTokens, bytes32[] memory proof) external whenSaleStarted payable {\n        super.beforeMint();\n\n        require(isWhitelisted(whitelistRoot, msg.sender, proof), \"Not whitelisted\");\n\n        require(claimedByAddress[msg.sender] + nTokens <= maxPerAddress, \"Cannot claim more per address\");\n\n        require(msg.value >= nTokens * price, \"Not enough ETH to mint\");\n\n        nft.mintExternal{ value: msg.value }(nTokens, msg.sender, bytes32(0x0));\n\n        claimedByAddress[msg.sender] += nTokens;\n    }","after":"function mint(uint256 nTokens, bytes32[] calldata proof) external whenSaleStarted payable {\n        super.beforeMint();\n\n        require(isWhitelisted(whitelistRoot, msg.sender, proof), \"Not whitelisted\");\n\n        require(claimedByAddress[msg.sender] + nTokens <= maxPerAddress, \"Cannot claim more per address\");\n\n        require(msg.value >= nTokens * price, \"Not enough ETH to mint\");\n\n        nft.mintExternal{ value: msg.value }(nTokens, msg.sender, bytes32(0x0));\n\n        claimedByAddress[msg.sender] += nTokens;\n    }","contract":"WhitelistMerkleTreeExtension","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public price;","after":"uint256 public immutable price;","contract":"WhitelistMerkleTreeExtension","time":0}]}