{"time":246,"results":[{"type":"external-function ","before":"function goldListSale(bytes32[] memory merkleProof, uint256 numberOfTokens) public payable isValidMerkleProof(merkleProof, goldListMerkleRoot) {\n        require(!MINTING_PAUSED, \"Minting is not active\");\n        require(CURRENT_STAGE == STAGE.PRE_SALE, \"Current stage should be PRE_SALE\");\n        require(totalSupply() < MAX_ELEMENTS, 'All tokens have been minted');\n        require(totalSupply() + numberOfTokens < MAX_ELEMENTS, 'Purchase would exceed max supply');\n        require(_allowListClaimed1[msg.sender] + numberOfTokens <= PURCHASE_LIMIT[0], 'Purchase exceeds max allowed');\n        require(STAGE_PRICE[0] * numberOfTokens <= msg.value, 'ETH amount is not sufficient');\n\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _tokenIdTracker.increment();\n\n            claimedList[_tokenIdTracker.current()] = msg.sender; // should be checked\n            _allowListClaimed1[msg.sender] += 1;\n            _safeMint(msg.sender, _tokenIdTracker.current());\n            _setTokenURI(_tokenIdTracker.current(), uint2str(_tokenIdTracker.current()));\n        }\n    }","after":"function goldListSale(bytes32[] calldata merkleProof, uint256 numberOfTokens) public payable isValidMerkleProof(merkleProof, goldListMerkleRoot) {\n        require(!MINTING_PAUSED, \"Minting is not active\");\n        require(CURRENT_STAGE == STAGE.PRE_SALE, \"Current stage should be PRE_SALE\");\n        require(totalSupply() < MAX_ELEMENTS, 'All tokens have been minted');\n        require(totalSupply() + numberOfTokens < MAX_ELEMENTS, 'Purchase would exceed max supply');\n        require(_allowListClaimed1[msg.sender] + numberOfTokens <= PURCHASE_LIMIT[0], 'Purchase exceeds max allowed');\n        require(STAGE_PRICE[0] * numberOfTokens <= msg.value, 'ETH amount is not sufficient');\n\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _tokenIdTracker.increment();\n\n            claimedList[_tokenIdTracker.current()] = msg.sender; // should be checked\n            _allowListClaimed1[msg.sender] += 1;\n            _safeMint(msg.sender, _tokenIdTracker.current());\n            _setTokenURI(_tokenIdTracker.current(), uint2str(_tokenIdTracker.current()));\n        }\n    }","contract":"HighRoller","time":0},{"type":"external-function ","before":"function silverListSale(bytes32[] memory merkleProof, uint256 numberOfTokens) public payable isValidMerkleProof(merkleProof, silverListMerkleRoot) {\n        require(!MINTING_PAUSED, \"Minting is not active\");\n        require(CURRENT_STAGE == STAGE.PRE_SALE, \"Current stage should be PRE_SALE\");\n        require(totalSupply() < MAX_ELEMENTS, 'All tokens have been minted');\n        require(totalSupply() + numberOfTokens < MAX_ELEMENTS, 'Purchase would exceed max supply');\n        require(_allowListClaimed2[msg.sender] + numberOfTokens <= PURCHASE_LIMIT[1], 'Purchase exceeds max allowed');\n        require(STAGE_PRICE[1] * numberOfTokens <= msg.value, 'ETH amount is not sufficient');\n\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _tokenIdTracker.increment();\n\n            claimedList[_tokenIdTracker.current()] = msg.sender; // should be checked\n            _allowListClaimed2[msg.sender] += 1;\n            _safeMint(msg.sender, _tokenIdTracker.current());\n            _setTokenURI(_tokenIdTracker.current(), uint2str(_tokenIdTracker.current()));\n        }\n    }","after":"function silverListSale(bytes32[] calldata merkleProof, uint256 numberOfTokens) public payable isValidMerkleProof(merkleProof, silverListMerkleRoot) {\n        require(!MINTING_PAUSED, \"Minting is not active\");\n        require(CURRENT_STAGE == STAGE.PRE_SALE, \"Current stage should be PRE_SALE\");\n        require(totalSupply() < MAX_ELEMENTS, 'All tokens have been minted');\n        require(totalSupply() + numberOfTokens < MAX_ELEMENTS, 'Purchase would exceed max supply');\n        require(_allowListClaimed2[msg.sender] + numberOfTokens <= PURCHASE_LIMIT[1], 'Purchase exceeds max allowed');\n        require(STAGE_PRICE[1] * numberOfTokens <= msg.value, 'ETH amount is not sufficient');\n\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _tokenIdTracker.increment();\n\n            claimedList[_tokenIdTracker.current()] = msg.sender; // should be checked\n            _allowListClaimed2[msg.sender] += 1;\n            _safeMint(msg.sender, _tokenIdTracker.current());\n            _setTokenURI(_tokenIdTracker.current(), uint2str(_tokenIdTracker.current()));\n        }\n    }","contract":"HighRoller","time":0},{"type":"external-function ","before":"function patronListSale(bytes32[] memory merkleProof, uint256 numberOfTokens) public payable isValidMerkleProof(merkleProof, patronListMerkleRoot) {\n        require(!MINTING_PAUSED, \"Minting is not active\");\n        require(CURRENT_STAGE == STAGE.PRE_SALE, \"Current stage should be PRE_SALE\");\n        require(totalSupply() < MAX_ELEMENTS, 'All tokens have been minted');\n        require(totalSupply() + numberOfTokens < MAX_ELEMENTS, 'Purchase would exceed max supply');\n        require(_allowListClaimed3[msg.sender] + numberOfTokens <= PURCHASE_LIMIT[0], 'Purchase exceeds max allowed');\n        require(STAGE_PRICE[0] * numberOfTokens <= msg.value, 'ETH amount is not sufficient');\n\n        // give one nft free for patron rollerlist\n        if (_allowListClaimed3[msg.sender] == 0) {\n            _tokenIdTracker.increment();\n\n            claimedList[_tokenIdTracker.current()] = msg.sender; // should be checked\n            _allowListClaimed3[msg.sender] += 1;\n            _safeMint(msg.sender, _tokenIdTracker.current());\n            _setTokenURI(_tokenIdTracker.current(), uint2str(_tokenIdTracker.current()));\n        }\n\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _tokenIdTracker.increment();\n\n            claimedList[_tokenIdTracker.current()] = msg.sender; // should be checked\n            _allowListClaimed3[msg.sender] += 1;\n            _safeMint(msg.sender, _tokenIdTracker.current());\n            _setTokenURI(_tokenIdTracker.current(), uint2str(_tokenIdTracker.current()));\n        }\n    }","after":"function patronListSale(bytes32[] calldata merkleProof, uint256 numberOfTokens) public payable isValidMerkleProof(merkleProof, patronListMerkleRoot) {\n        require(!MINTING_PAUSED, \"Minting is not active\");\n        require(CURRENT_STAGE == STAGE.PRE_SALE, \"Current stage should be PRE_SALE\");\n        require(totalSupply() < MAX_ELEMENTS, 'All tokens have been minted');\n        require(totalSupply() + numberOfTokens < MAX_ELEMENTS, 'Purchase would exceed max supply');\n        require(_allowListClaimed3[msg.sender] + numberOfTokens <= PURCHASE_LIMIT[0], 'Purchase exceeds max allowed');\n        require(STAGE_PRICE[0] * numberOfTokens <= msg.value, 'ETH amount is not sufficient');\n\n        // give one nft free for patron rollerlist\n        if (_allowListClaimed3[msg.sender] == 0) {\n            _tokenIdTracker.increment();\n\n            claimedList[_tokenIdTracker.current()] = msg.sender; // should be checked\n            _allowListClaimed3[msg.sender] += 1;\n            _safeMint(msg.sender, _tokenIdTracker.current());\n            _setTokenURI(_tokenIdTracker.current(), uint2str(_tokenIdTracker.current()));\n        }\n\n        for (uint256 i = 0; i < numberOfTokens; i++) {\n            _tokenIdTracker.increment();\n\n            claimedList[_tokenIdTracker.current()] = msg.sender; // should be checked\n            _allowListClaimed3[msg.sender] += 1;\n            _safeMint(msg.sender, _tokenIdTracker.current());\n            _setTokenURI(_tokenIdTracker.current(), uint2str(_tokenIdTracker.current()));\n        }\n    }","contract":"HighRoller","time":0},{"type":"external-function ","before":"function withdraw(bytes32[] memory merkleProof) public onlyowner(merkleProof) {\n        uint256 balance = address(this).balance;\n\n        payable(msg.sender).transfer(balance);\n    }","after":"function withdraw(bytes32[] calldata merkleProof) public onlyowner(merkleProof) {\n        uint256 balance = address(this).balance;\n\n        payable(msg.sender).transfer(balance);\n    }","contract":"HighRoller","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }","after":"function setBaseURI(string calldata baseURI) public onlyOwner {\n        _setBaseURI(baseURI);\n    }","contract":"HighRoller","time":0},{"type":"external-function ","before":"function setContractURI(string memory URI) public onlyOwner {\n        _contractURI = URI;\n    }","after":"function setContractURI(string calldata URI) public onlyOwner {\n        _contractURI = URI;\n    }","contract":"HighRoller","time":0}]}