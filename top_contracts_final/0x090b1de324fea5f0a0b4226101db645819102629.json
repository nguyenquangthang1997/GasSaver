{"time":206,"results":[{"type":"struct-data-arrangement ","before":"\nbool isForSale\nuint tokenId\naddress seller\nuint minValue\naddress onlySellTo","after":"uint tokenId\nuint minValue\naddress seller\naddress onlySellTo\nbool isForSale\n","contract":"ApesPunk","time":0},{"type":"struct-data-arrangement ","before":"\nbool hasBid\nuint tokenId\naddress bidder\nuint value","after":"uint tokenId\nuint value\naddress bidder\nbool hasBid\n","contract":"ApesPunk","time":1},{"type":"external-function ","before":"function seedInitialContractState(\n        address[] memory tokenOwners,\n        uint256[] memory tokens\n    ) public onlyOwner {\n        require(\n            !saleHasBeenStarted,\n            \"cannot initial phunk mint if sale has started\"\n        );\n        require(\n            tokenOwners.length == tokens.length,\n            \"tokenOwners does not match tokens length\"\n        );\n\n        uint256 lastTokenIdMintedInInitialSetCopy = _lastTokenIdMintedInInitialSet;\n        for (uint256 i = 0; i < tokenOwners.length; i++) {\n            uint256 token = tokens[i];\n            require(\n                lastTokenIdMintedInInitialSetCopy > token,\n                \"initial phunk mints must be in decreasing order for our availableToken index to work\"\n            );\n            lastTokenIdMintedInInitialSetCopy = token;\n\n            useAvailableTokenAtIndex(token);\n            _safeMint(tokenOwners[i], token + 10000);\n        }\n        _lastTokenIdMintedInInitialSet = lastTokenIdMintedInInitialSetCopy;\n    }","after":"function seedInitialContractState(\n        address[] calldata tokenOwners,\n        uint256[] calldata tokens\n    ) public onlyOwner {\n        require(\n            !saleHasBeenStarted,\n            \"cannot initial phunk mint if sale has started\"\n        );\n        require(\n            tokenOwners.length == tokens.length,\n            \"tokenOwners does not match tokens length\"\n        );\n\n        uint256 lastTokenIdMintedInInitialSetCopy = _lastTokenIdMintedInInitialSet;\n        for (uint256 i = 0; i < tokenOwners.length; i++) {\n            uint256 token = tokens[i];\n            require(\n                lastTokenIdMintedInInitialSetCopy > token,\n                \"initial phunk mints must be in decreasing order for our availableToken index to work\"\n            );\n            lastTokenIdMintedInInitialSetCopy = token;\n\n            useAvailableTokenAtIndex(token);\n            _safeMint(tokenOwners[i], token + 10000);\n        }\n        _lastTokenIdMintedInInitialSet = lastTokenIdMintedInInitialSetCopy;\n    }","contract":"ApesPunk","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseURI) external onlyOwner {\n        _baseTokenURI = baseURI;\n    }","after":"function setBaseURI(string calldata baseURI) external onlyOwner {\n        _baseTokenURI = baseURI;\n    }","contract":"ApesPunk","time":0},{"type":"external-function ","before":"function setContractURI(string memory _contractURI) external onlyOwner {\n        contractURI = _contractURI;\n    }","after":"function setContractURI(string calldata _contractURI) external onlyOwner {\n        contractURI = _contractURI;\n    }","contract":"ApesPunk","time":0}]}