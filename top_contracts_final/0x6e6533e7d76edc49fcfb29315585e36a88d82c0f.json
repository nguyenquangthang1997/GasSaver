{"time":143,"results":[{"type":"external-function ","before":"function mintToBulkAdmin(address[] memory addresses, uint256 addressCount) public onlyOwner {\n          for(uint i=0; i < addressCount; i++ ) {\n            mintToAdmin(addresses[i]);\n          }\n        }","after":"function mintToBulkAdmin(address[] calldata addresses, uint256 addressCount) public onlyOwner {\n          for(uint i=0; i < addressCount; i++ ) {\n            mintToAdmin(addresses[i]);\n          }\n        }","contract":"MascotSocialClubContract","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n      address userAddress,\n      bytes memory functionSignature,\n      bytes32 sigR,\n      bytes32 sigS,\n      uint8 sigV\n    ) public payable returns(bytes memory) {\n            MetaTransaction memory metaTx = MetaTransaction({\n      nonce: nonces[userAddress],\n      from: userAddress,\n      functionSignature: functionSignature\n    });\n\n      require(\n        verify(userAddress, metaTx, sigR, sigS, sigV),\n        \"Signer and signature do not match\"\n      );\n\n      // increase nonce for user (to avoid re-use)\n      nonces[userAddress] = nonces[userAddress].add(1);\n\n            emit MetaTransactionExecuted(\n        userAddress,\n        payable(msg.sender),\n        functionSignature\n      );\n\n      // Append userAddress and relayer address at the end to extract it from calling context\n      (bool success, bytes memory returnData) = address(this).call(\n        abi.encodePacked(functionSignature, userAddress)\n      );\n      require(success, \"Function call not successful\");\n\n      return returnData;\n    }","after":"function executeMetaTransaction(\n      address userAddress,\n      bytes calldata functionSignature,\n      bytes32 sigR,\n      bytes32 sigS,\n      uint8 sigV\n    ) public payable returns(bytes memory) {\n            MetaTransaction memory metaTx = MetaTransaction({\n      nonce: nonces[userAddress],\n      from: userAddress,\n      functionSignature: functionSignature\n    });\n\n      require(\n        verify(userAddress, metaTx, sigR, sigS, sigV),\n        \"Signer and signature do not match\"\n      );\n\n      // increase nonce for user (to avoid re-use)\n      nonces[userAddress] = nonces[userAddress].add(1);\n\n            emit MetaTransactionExecuted(\n        userAddress,\n        payable(msg.sender),\n        functionSignature\n      );\n\n      // Append userAddress and relayer address at the end to extract it from calling context\n      (bool success, bytes memory returnData) = address(this).call(\n        abi.encodePacked(functionSignature, userAddress)\n      );\n      require(success, \"Function call not successful\");\n\n      return returnData;\n    }","contract":"MascotSocialClubContract","time":0},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"MascotSocialClubContract","time":1},{"type":"constant-restrict-modification  ","before":"address public RAMPPADDRESS = 0xa9dAC8f3aEDC55D0FE707B86B8A45d246858d2E1;","after":"address public constant RAMPPADDRESS = 0xa9dAC8f3aEDC55D0FE707B86B8A45d246858d2E1;","contract":"MascotSocialClubContract","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public SUPPLYCAP = 10000;","after":"uint256 public constant SUPPLYCAP = 10000;","contract":"MascotSocialClubContract","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public payableAddressCount = 2;","after":"uint256 public constant payableAddressCount = 2;","contract":"MascotSocialClubContract","time":1}]}