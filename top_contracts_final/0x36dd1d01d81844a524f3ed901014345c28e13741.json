{"time":267,"results":[{"type":"state-data-arrangement ","before":"\nuint256 public MAX_MINTABLE = 1001;\nbool public mintingComplete = false;\nuint256 public totalNFT = 0;\nuint256 public mintPrice = 0;\nmapping(uint256 => string) private _tokenURIs;\nbool public publicsaleIsActive = false;\nbool public preSaleIsActive = false;\nstring private _baseURIextended;\nmapping(uint => NFTItemRecord) public nftItemRecord;\nmapping(address => Whitelist) public whitelist;\naddress[] public whitelistAddr;","after":"uint256 public MAX_MINTABLE = 1001;\nuint256 public totalNFT = 0;\nuint256 public mintPrice = 0;\nmapping(uint256 => string) private _tokenURIs;\nstring private _baseURIextended;\nmapping(uint => NFTItemRecord) public nftItemRecord;\nmapping(address => Whitelist) public whitelist;\naddress[] public whitelistAddr;\nbool public mintingComplete = false;\nbool public publicsaleIsActive = false;\nbool public preSaleIsActive = false;\n","contract":"MVRSNFT","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseURI_) external onlyOwner {\n        _baseURIextended = baseURI_;\n    }","after":"function setBaseURI(string calldata baseURI_) external onlyOwner {\n        _baseURIextended = baseURI_;\n    }","contract":"MVRSNFT","time":0},{"type":"external-function ","before":"function mintTokens(uint id, string memory ptokenURI)\n        public\n        payable\n        whenNotPaused\n        whenMintingNotComplete\n    {\n    require( msg.value >= nftItemRecord[id].mintPrice,  \"Ether sent is not correct\" );\n    require( nftItemRecord[id].availableCopies > 0,  \"Sold Out\" );\n    require( preSaleIsActive || publicsaleIsActive, \"Sale is not active yet\");\n            if(preSaleIsActive){\n                require(isWhitelisted(msg.sender), \"Is not whitelisted\");\n                mintingTokens(id,ptokenURI);\n                whitelist[msg.sender].hasMinted = whitelist[msg.sender].hasMinted.add(1);\n            }\n           else {\n               mintingTokens(id,ptokenURI);\n            }\n\n        if (totalNFT >= MAX_MINTABLE) {\n            mintingComplete = true;\n        }\n    }","after":"function mintTokens(uint id, string calldata ptokenURI)\n        public\n        payable\n        whenNotPaused\n        whenMintingNotComplete\n    {\n    require( msg.value >= nftItemRecord[id].mintPrice,  \"Ether sent is not correct\" );\n    require( nftItemRecord[id].availableCopies > 0,  \"Sold Out\" );\n    require( preSaleIsActive || publicsaleIsActive, \"Sale is not active yet\");\n            if(preSaleIsActive){\n                require(isWhitelisted(msg.sender), \"Is not whitelisted\");\n                mintingTokens(id,ptokenURI);\n                whitelist[msg.sender].hasMinted = whitelist[msg.sender].hasMinted.add(1);\n            }\n           else {\n               mintingTokens(id,ptokenURI);\n            }\n\n        if (totalNFT >= MAX_MINTABLE) {\n            mintingComplete = true;\n        }\n    }","contract":"MVRSNFT","time":0},{"type":"external-function ","before":"function addAddressesToWhitelist(address[] memory addrs) onlyOwner public{\n        for(uint i = 0; i < addrs.length; i++) {\n            addAddressToWhitelist(addrs[i]);\n        }\n    }","after":"function addAddressesToWhitelist(address[] calldata addrs) onlyOwner public{\n        for(uint i = 0; i < addrs.length; i++) {\n            addAddressToWhitelist(addrs[i]);\n        }\n    }","contract":"MVRSNFT","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public MAX_MINTABLE = 1001;","after":"uint256 public constant MAX_MINTABLE = 1001;","contract":"MVRSNFT","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public mintPrice = 0;","after":"uint256 public constant mintPrice = 0;","contract":"MVRSNFT","time":1}]}