{"time":164,"results":[{"type":"external-function ","before":"function transferNFTs(address[] memory targetAccounts, uint16 startTokenId) public onlyOwner {\n        require(startTokenId == totalSupply().add(1), \"Wrong token id\");\n        require(targetAccounts.length > 0, \"No one to transfer\");\n        for (uint256 k = 0; k < targetAccounts.length; k++) {\n            safeMint(targetAccounts[k]);\n        }\n    }","after":"function transferNFTs(address[] calldata targetAccounts, uint16 startTokenId) public onlyOwner {\n        require(startTokenId == totalSupply().add(1), \"Wrong token id\");\n        require(targetAccounts.length > 0, \"No one to transfer\");\n        for (uint256 k = 0; k < targetAccounts.length; k++) {\n            safeMint(targetAccounts[k]);\n        }\n    }","contract":"Paw","time":0},{"type":"external-function ","before":"function addAccountsToWhitelist(address[] memory accounts) public onlyOwner {\n        require(accounts.length > 0, \"There are not accounts to add\");\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _whitelist[accounts[i]] = true;\n        }\n    }","after":"function addAccountsToWhitelist(address[] calldata accounts) public onlyOwner {\n        require(accounts.length > 0, \"There are not accounts to add\");\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _whitelist[accounts[i]] = true;\n        }\n    }","contract":"Paw","time":0},{"type":"external-function ","before":"function removeAccountsFromWhitelist(address[] memory accounts) public onlyOwner {\n        require(accounts.length > 0, \"There are not accounts to delete\");\n        for (uint256 i = 0; i < accounts.length; i++) {\n            if (whitelistHas(accounts[i])) {\n                delete _whitelist[accounts[i]];\n            }\n        }\n    }","after":"function removeAccountsFromWhitelist(address[] calldata accounts) public onlyOwner {\n        require(accounts.length > 0, \"There are not accounts to delete\");\n        for (uint256 i = 0; i < accounts.length; i++) {\n            if (whitelistHas(accounts[i])) {\n                delete _whitelist[accounts[i]];\n            }\n        }\n    }","contract":"Paw","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"Paw","time":0},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"Paw","time":1}]}