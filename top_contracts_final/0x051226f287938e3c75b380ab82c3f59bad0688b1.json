{"time":145,"results":[{"type":"external-function ","before":"function PublicSale(uint256[] memory tokenId,uint256 amount)\n        public\n        payable \n    {\n        require(currentSupply <= maxSupply,\"ERROR: max limit reached\");\n        require(amount <= 20 && tokenId.length <= 20,\"ERROR: max 20 mint per transaction\");\n        require(amount <= MembershipToken.balanceOf(msg.sender),\"ERROR: not enough MembershipToken\");\n        require(amount == tokenId.length,\"ERROR: wrong token ID or count\");\n        require(msg.value >= amount*basePrice,\"ERROR: wrong price\");\n        require(sale,\"ERROR: not on sale\");\n\n\n        if(block.timestamp < lockedTime){\n            require(amount <= MembershipToken.balanceOf(msg.sender),\"ERROR: not enough MembershipToken\");\n            for(uint256 i=0; i<tokenId.length; i++){\n                require(msg.sender == MembershipToken.ownerOf(tokenId[i]),\"ERROR: u don't have this token ID\");\n                if(usedMembershipToken[tokenId[i]] != 0) require(usedMembershipToken[tokenId[i]] <= block.timestamp ,\"ERROR: this Membership Token is already used\");\n                    usedMembershipToken[tokenId[i]] = lockedTime;\n                    emit NftBought(msg.sender,amount,tokenId[i]);\n            }\n\n            _mint(msg.sender, 0, amount, \"\");\n            currentSupply += amount;\n            \n        }\n        \n    }","after":"function PublicSale(uint256[] calldata tokenId,uint256 amount)\n        public\n        payable \n    {\n        require(currentSupply <= maxSupply,\"ERROR: max limit reached\");\n        require(amount <= 20 && tokenId.length <= 20,\"ERROR: max 20 mint per transaction\");\n        require(amount <= MembershipToken.balanceOf(msg.sender),\"ERROR: not enough MembershipToken\");\n        require(amount == tokenId.length,\"ERROR: wrong token ID or count\");\n        require(msg.value >= amount*basePrice,\"ERROR: wrong price\");\n        require(sale,\"ERROR: not on sale\");\n\n\n        if(block.timestamp < lockedTime){\n            require(amount <= MembershipToken.balanceOf(msg.sender),\"ERROR: not enough MembershipToken\");\n            for(uint256 i=0; i<tokenId.length; i++){\n                require(msg.sender == MembershipToken.ownerOf(tokenId[i]),\"ERROR: u don't have this token ID\");\n                if(usedMembershipToken[tokenId[i]] != 0) require(usedMembershipToken[tokenId[i]] <= block.timestamp ,\"ERROR: this Membership Token is already used\");\n                    usedMembershipToken[tokenId[i]] = lockedTime;\n                    emit NftBought(msg.sender,amount,tokenId[i]);\n            }\n\n            _mint(msg.sender, 0, amount, \"\");\n            currentSupply += amount;\n            \n        }\n        \n    }","contract":"NightRider","time":0},{"type":"external-function ","before":"function changeTokenUri(string memory _newUri) public onlyOwner {\n        _setURI(_newUri);\n    }","after":"function changeTokenUri(string calldata _newUri) public onlyOwner {\n        _setURI(_newUri);\n    }","contract":"NightRider","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"NightRider","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"NightRider","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public maxSupply;","after":"uint256 public immutable maxSupply;","contract":"NightRider","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public basePrice;","after":"uint256 public immutable basePrice;","contract":"NightRider","time":1},{"type":"immutable-restrict-modification ","before":"address public artist;","after":"address public immutable artist;","contract":"NightRider","time":1}]}