{"time":1671,"results":[{"type":"struct-data-arrangement ","before":"\naddress staker\nuint256 stakeAmount\nuint256 interestAmount\nuint256 withdrawnInterestAmount\nuint256 stakeTimestamp\nuint256 stakeTimeInDays\nbool active","after":"uint256 stakeAmount\nuint256 interestAmount\nuint256 withdrawnInterestAmount\nuint256 stakeTimestamp\nuint256 stakeTimeInDays\naddress staker\nbool active\n","contract":"PeakStaking","time":0},{"type":"external-function ","before":"function approveAndCall(address _spender, uint256 _amount, bytes memory _extraData\n  ) public returns (bool success) {\n    require(approve(_spender, _amount));\n\n    ApproveAndCallFallBack(_spender).receiveApproval(\n      msg.sender,\n      _amount,\n      address(this),\n      _extraData\n    );\n\n    return true;\n  }","after":"function approveAndCall(address _spender, uint256 _amount, bytes calldata _extraData\n  ) public returns (bool success) {\n    require(approve(_spender, _amount));\n\n    ApproveAndCallFallBack(_spender).receiveApproval(\n      msg.sender,\n      _amount,\n      address(this),\n      _extraData\n    );\n\n    return true;\n  }","contract":"MiniMeToken","time":0},{"type":"external-function ","before":"function createCloneToken(\n    string memory _cloneTokenName,\n    uint8 _cloneDecimalUnits,\n    string memory _cloneTokenSymbol,\n    uint _snapshotBlock,\n    bool _transfersEnabled\n  ) public returns(address) {\n    uint snapshotBlock = _snapshotBlock;\n    if (snapshotBlock == 0) snapshotBlock = block.number;\n    MiniMeToken cloneToken = tokenFactory.createCloneToken(\n      address(this),\n      snapshotBlock,\n      _cloneTokenName,\n      _cloneDecimalUnits,\n      _cloneTokenSymbol,\n      _transfersEnabled\n    );\n\n    cloneToken.transferOwnership(msg.sender);\n\n    // An event to make the token easy to find on the blockchain\n    emit NewCloneToken(address(cloneToken), snapshotBlock);\n    return address(cloneToken);\n  }","after":"function createCloneToken(\n    string calldata _cloneTokenName,\n    uint8 _cloneDecimalUnits,\n    string calldata _cloneTokenSymbol,\n    uint _snapshotBlock,\n    bool _transfersEnabled\n  ) public returns(address) {\n    uint snapshotBlock = _snapshotBlock;\n    if (snapshotBlock == 0) snapshotBlock = block.number;\n    MiniMeToken cloneToken = tokenFactory.createCloneToken(\n      address(this),\n      snapshotBlock,\n      _cloneTokenName,\n      _cloneDecimalUnits,\n      _cloneTokenSymbol,\n      _transfersEnabled\n    );\n\n    cloneToken.transferOwnership(msg.sender);\n\n    // An event to make the token easy to find on the blockchain\n    emit NewCloneToken(address(cloneToken), snapshotBlock);\n    return address(cloneToken);\n  }","contract":"MiniMeToken","time":0},{"type":"constant-restrict-modification  ","before":"string public version = \"MMT_0.2\";","after":"string public constant version = \"MMT_0.2\";","contract":"MiniMeToken","time":1},{"type":"external-function ","before":"function createCloneToken(\n    address payable _parentToken,\n    uint _snapshotBlock,\n    string memory _tokenName,\n    uint8 _decimalUnits,\n    string memory _tokenSymbol,\n    bool _transfersEnabled\n  ) public returns (MiniMeToken) {\n    MiniMeToken newToken = new MiniMeToken(\n      address(this),\n      _parentToken,\n      _snapshotBlock,\n      _tokenName,\n      _decimalUnits,\n      _tokenSymbol,\n      _transfersEnabled\n    );\n\n    newToken.transferOwnership(msg.sender);\n    emit CreatedToken(_tokenSymbol, address(newToken));\n    return newToken;\n  }","after":"function createCloneToken(\n    address payable _parentToken,\n    uint _snapshotBlock,\n    string calldata _tokenName,\n    uint8 _decimalUnits,\n    string calldata _tokenSymbol,\n    bool _transfersEnabled\n  ) public returns (MiniMeToken) {\n    MiniMeToken newToken = new MiniMeToken(\n      address(this),\n      _parentToken,\n      _snapshotBlock,\n      _tokenName,\n      _decimalUnits,\n      _tokenSymbol,\n      _transfersEnabled\n    );\n\n    newToken.transferOwnership(msg.sender);\n    emit CreatedToken(_tokenSymbol, address(newToken));\n    return newToken;\n  }","contract":"MiniMeTokenFactory","time":0},{"type":"external-function ","before":"function createInvestmentV2(\n        address _sender,\n        address _tokenAddress,\n        uint256 _stake,\n        uint256 _maxPrice,\n        bytes memory _calldata,\n        bool _useKyber\n    ) public {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.createInvestmentV2.selector,\n                _sender,\n                _tokenAddress,\n                _stake,\n                _maxPrice,\n                _calldata,\n                _useKyber\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }","after":"function createInvestmentV2(\n        address _sender,\n        address _tokenAddress,\n        uint256 _stake,\n        uint256 _maxPrice,\n        bytes calldata _calldata,\n        bool _useKyber\n    ) public {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.createInvestmentV2.selector,\n                _sender,\n                _tokenAddress,\n                _stake,\n                _maxPrice,\n                _calldata,\n                _useKyber\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }","contract":"PeakDeFiFund","time":0},{"type":"external-function ","before":"function sellInvestmentAssetV2(\n        address _sender,\n        uint256 _investmentId,\n        uint256 _tokenAmount,\n        uint256 _minPrice,\n        bytes memory _calldata,\n        bool _useKyber\n    ) public {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.sellInvestmentAssetV2.selector,\n                _sender,\n                _investmentId,\n                _tokenAmount,\n                _minPrice,\n                _calldata,\n                _useKyber\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }","after":"function sellInvestmentAssetV2(\n        address _sender,\n        uint256 _investmentId,\n        uint256 _tokenAmount,\n        uint256 _minPrice,\n        bytes calldata _calldata,\n        bool _useKyber\n    ) public {\n        (bool success, ) = peakdefiLogic.delegatecall(\n            abi.encodeWithSelector(\n                this.sellInvestmentAssetV2.selector,\n                _sender,\n                _investmentId,\n                _tokenAmount,\n                _minPrice,\n                _calldata,\n                _useKyber\n            )\n        );\n        if (!success) {\n            revert();\n        }\n    }","contract":"PeakDeFiFund","time":0},{"type":"struct-data-arrangement ","before":"\naddress tokenAddress\nuint256 cycleNumber\nuint256 stake\nuint256 tokenAmount\nuint256 buyPrice\nuint256 sellPrice\nuint256 buyTime\nuint256 buyCostInUSDC\nbool isSold","after":"uint256 cycleNumber\nuint256 stake\nuint256 tokenAmount\nuint256 buyPrice\nuint256 sellPrice\nuint256 buyTime\nuint256 buyCostInUSDC\naddress tokenAddress\nbool isSold\n","contract":"PeakDeFiStorage","time":0},{"type":"constant-restrict-modification  ","before":"\n  uint public _exchangeRateCurrent = 10 ** (18 - 8) * PRECISI","after":"\n  uint public constant _exchangeRateCurrent = 10 ** (18 - 8) * PRECISI","contract":"TestCERC20","time":0},{"type":"constant-restrict-modification  ","before":"\n  uint public _exchangeRateCurrent = 10 ** (18 - 8) * PRECISI","after":"\n  uint public constant _exchangeRateCurrent = 10 ** (18 - 8) * PRECISI","contract":"TestCEther","time":0},{"type":"constant-restrict-modification  ","before":"\n  uint256 internal collateralFactor = 2 * PRECISION /","after":"\n  uint256 internal constant collateralFactor = 2 * PRECISION /","contract":"TestComptroller","time":0},{"type":"external-function ","before":"\n  function setAllTokenPrices(address[] memory _tokens, uint256[] memory _pricesInUSDC) public onlyOwner {\n    for (uint256 i = 0; i < _tokens.length; i = i.add(1)) {\n      priceInUSDC[_tokens[i]] = _pricesInUSDC[i];\n    }\n","after":"\n  function setAllTokenPrices(address[] calldata _tokens, uint256[] calldata _pricesInUSDC) public onlyOwner {\n    for (uint256 i = 0; i < _tokens.length; i = i.add(1)) {\n      priceInUSDC[_tokens[i]] = _pricesInUSDC[i];\n    }\n","contract":"TestKyberNetwork","time":0},{"type":"external-function ","before":"\n  function newToken(string memory name, string memory symbol, uint8 decimals) public returns(address) {\n    bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\n    require(createdTokens[symbolHash] == address(0));\n    \n    TestToken token = new TestToken(name, symbol, decimals);\n    token.addMinter(msg.sender);\n    token.renounceMinter();\n    createdTokens[symbolHash] = address(token);\n    emit CreatedToken(symbol, address(token));\n    return address(token);\n","after":"\n  function newToken(string calldata name, string calldata symbol, uint8 decimals) public returns(address) {\n    bytes32 symbolHash = keccak256(abi.encodePacked(symbol));\n    require(createdTokens[symbolHash] == address(0));\n    \n    TestToken token = new TestToken(name, symbol, decimals);\n    token.addMinter(msg.sender);\n    token.renounceMinter();\n    createdTokens[symbolHash] = address(token);\n    emit CreatedToken(symbol, address(token));\n    return address(token);\n","contract":"TestTokenFactory","time":0}]}