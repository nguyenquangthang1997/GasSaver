{"time":208,"results":[{"type":"external-function ","before":"   function setArtist(string memory artist_)\n        public\n        onlyOwner\n    {\n        artist = artist_;\n  ","after":"   function setArtist(string calldata artist_)\n        public\n        onlyOwner\n    {\n        artist = artist_;\n  ","contract":"GeneticPass","time":0},{"type":"external-function ","before":"   function setDescription(string memory description_)\n        public\n        onlyOwner\n    {\n        description = description_;\n  ","after":"   function setDescription(string calldata description_)\n        public\n        onlyOwner\n    {\n        description = description_;\n  ","contract":"GeneticPass","time":0},{"type":"external-function ","before":"   function setCode(string memory code_)\n        public\n        onlyOwner\n    {\n        code = code_;\n  ","after":"   function setCode(string calldata code_)\n        public\n        onlyOwner\n    {\n        code = code_;\n  ","contract":"GeneticPass","time":0},{"type":"external-function ","before":"   function setTokenIpfsHash(string memory hash)\n        public\n        onlyOwner\n    {\n        _tokenIpfsHash = hash;\n  ","after":"   function setTokenIpfsHash(string calldata hash)\n        public\n        onlyOwner\n    {\n        _tokenIpfsHash = hash;\n  ","contract":"GeneticPass","time":0},{"type":"external-function ","before":"   function addLibrary(string memory name, string memory hash)\n        public\n        onlyOwner\n    {\n        IpfsAsset memory lib = IpfsAsset(name, hash);\n        libraries.push(lib);\n  ","after":"   function addLibrary(string calldata name, string calldata hash)\n        public\n        onlyOwner\n    {\n        IpfsAsset memory lib = IpfsAsset(name, hash);\n        libraries.push(lib);\n  ","contract":"GeneticPass","time":0},{"type":"external-function ","before":"   function addAsset(string memory name, string memory hash)\n        public\n        onlyOwner\n    {\n        IpfsAsset memory lib = IpfsAsset(name, hash);\n        assets.push(lib);\n  ","after":"   function addAsset(string calldata name, string calldata hash)\n        public\n        onlyOwner\n    {\n        IpfsAsset memory lib = IpfsAsset(name, hash);\n        assets.push(lib);\n  ","contract":"GeneticPass","time":0},{"type":"external-function ","before":"   function secureMint(bytes32 msgHash, bytes memory signature, uint256 allocation, uint256 count, string memory nonce)\n        external\n    {\n        require(!_usedNonces[nonce], \"invalid nonce\");\n        require(totalSupply() < tokenMax, \"all tokens minted\");\n        require(totalSupply() + count <= tokenMax, \"exceed token supply\");\n        require(publicMinted + count <= publicMax, \"exceed public supply\");\n        require(_mints[msg.sender] + count <= allocation, \"exceed allocation\");\n        require(validateSigner(msgHash, signature), \"invalid signer\");\n        require(validateHash(msgHash, msg.sender, allocation, count, nonce), \"invalid hash\");\n        publicMinted += count;\n        _mints[msg.sender] += count;\n        _usedNonces[nonce] = true;\n        for (uint256 i = 0; i < count; ++i) {\n            _mintTo(msg.sender);\n        }\n  ","after":"   function secureMint(bytes32 msgHash, bytes calldata signature, uint256 allocation, uint256 count, string calldata nonce)\n        external\n    {\n        require(!_usedNonces[nonce], \"invalid nonce\");\n        require(totalSupply() < tokenMax, \"all tokens minted\");\n        require(totalSupply() + count <= tokenMax, \"exceed token supply\");\n        require(publicMinted + count <= publicMax, \"exceed public supply\");\n        require(_mints[msg.sender] + count <= allocation, \"exceed allocation\");\n        require(validateSigner(msgHash, signature), \"invalid signer\");\n        require(validateHash(msgHash, msg.sender, allocation, count, nonce), \"invalid hash\");\n        publicMinted += count;\n        _mints[msg.sender] += count;\n        _usedNonces[nonce] = true;\n        for (uint256 i = 0; i < count; ++i) {\n            _mintTo(msg.sender);\n        }\n  ","contract":"GeneticPass","time":0},{"type":"external-function ","before":"   function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n  ","after":"   function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n  ","contract":"GeneticPass","time":0},{"type":"immutable-restrict-modification ","before":"   address _proxyRegistryAddre","after":"   address _proxyRegistryAddre","contract":"GeneticPass","time":1},{"type":"constant-restrict-modification  ","before":"   uint256 private _currentTokenId =","after":"   uint256 private constant _currentTokenId =","contract":"GeneticPass","time":1},{"type":"immutable-restrict-modification ","before":"   address private _sign","after":"   address private _sign","contract":"GeneticPass","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 public publicM","after":"   uint256 public publicM","contract":"GeneticPass","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 public artistM","after":"   uint256 public artistM","contract":"GeneticPass","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 public galleryM","after":"   uint256 public galleryM","contract":"GeneticPass","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 public tokenM","after":"   uint256 public tokenM","contract":"GeneticPass","time":1}]}