{"time":238,"results":[{"type":"state-data-arrangement ","before":"\n� ░░░░ ░░░░�\n░░░░███ ░░░░░░  ░�\n��░      //\r\n//                                          \n                                    \n                                  \n      ███ ░███     \n         //\r\n//                          \n                                              \n                                          \n   ░░██████              \n //\r\n//                                                       \n                                 \n                                  \n��░░░░                      //\n///////////////////////////////////////////\n//////////////////////////////////////////////////\n//////////////////\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppeli\nracts/token/ERC721/ERC721\n\r\nimport \"@openzeppelin/con\nrable.sol\";\r\nimport \"@openzeppelin/contract\nss/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/Re\n \"./TokenSegments.sol\";\r\n\r\n// we whi\n OpenSea so that minters can save on g\n spend it on NFTs\r\ncontract OwnableDe\noxy) public proxies;\r\n}\r\n\r\ncontract Conjured","after":"░░░░███ ░░░░░░  ░�\n��░      //\r\n//                                          \n                                  \n      ███ ░███     \n         //\r\n//                          \n                                              \n                                          \n   ░░██████              \n //\r\n//                                                       \n///////////////////////////////////////////\n//////////////////////////////////////////////////\n//////////////////\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppeli\nracts/token/ERC721/ERC721\nrable.sol\";\r\nimport \"@openzeppelin/contract\nss/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/Re\n \"./TokenSegments.sol\";\r\n\r\n// we whi\n OpenSea so that minters can save on g\n spend it on NFTs\r\ncontract OwnableDe\noxy) public proxies;\r\n}\r\n\r\ncontract Conjured\n� ░░░░ ░░░░�\n                                    \n                                 \n                                  \n��░░░░                      //\n\r\nimport \"@openzeppelin/con\n","contract":"ConjuredLands","time":0},{"type":"external-function ","before":"gnmentFirstIndex;\r\n    // these are URIs for the custom part, single URLs and segmented baseURIs\r\n    mapping(uint256 => string) specialTokenURIs;\r\n\r\n    con","after":"gnmentFirstIndex;\r\n    // these are URIs for the custom part, single URLs and segmented baseURIs\r\n    mapping(uint256 => string) specialTokenURIs;\r\n\r\n    con","contract":"ConjuredLands","time":0},{"type":"external-function ","before":"wtJ39BRGxuA2D37hFME1/\";\r\n        proxyRegistryAddress = _proxyRegistryAddress;\r\n    }\r\n\r\n    function _baseURI() internal view override returns(string memory) {\r\n        return __baseURI;\r\n    }\r\n\r\n    function setBaseURI(","after":"wtJ39BRGxuA2D37hFME1/\";\r\n        proxyRegistryAddress = _proxyRegistryAddress;\r\n    }\r\n\r\n    function _baseURI() internal view override returns(string memory) {\r\n        return __baseURI;\r\n    }\r\n\r\n    function setBaseURI(","contract":"ConjuredLands","time":0},{"type":"external-function ","before":"emory newBaseURI) public onlyOwner(){\r\n        require(!baseURIfrozen, \"BaseURI frozen\");\r\n        __baseURI = newBaseURI;\r\n    }\r\n    \r\n    function baseURI() public view returns(string memory){\r\n        r","after":"emory newBaseURI) public onlyOwner(){\r\n        require(!baseURIfrozen, \"BaseURI frozen\");\r\n        __baseURI = newBaseURI;\r\n    }\r\n    \r\n    function baseURI() public view returns(string memory){\r\n        r","contract":"ConjuredLands","time":0},{"type":"external-function ","before":"baseURI;\r\n    }\r\n\r\n    // calling this function locks the possibility to change the baseURI forever\r\n    function freezeBaseURI() public onlyOwner(){\r\n    ","after":"baseURI;\r\n    }\r\n\r\n    // calling this function locks the possibility to change the baseURI forever\r\n    function freezeBaseURI() public onlyOwner(){\r\n    ","contract":"ConjuredLands","time":0},{"type":"external-function ","before":"Mint(uint8 alignment) public payable nonReentrant{\r\n        require(mintingActive && salesStarted(), \"Minting is not active\");\r\n        require(premiumMintingSlots>0, \"No more premium minting slots\");\r\n        require(totalSupply()<= maxSupply, \"Maximum supply reached\");\r\n        require(msg.value == premiumTokenPrice, \"Wrong payment\");\r\n        premiumOwners[premiumMintingSlots -1] = msg.sender;\r\n        premiumMintingSlots--;\r\n        _internalMintRandom(msg.sender, 1, alignment);\r\n    }\r\n    \r\n    function burn(uint256 tokenId) public nonReentrant{\r\n        require(burningActive, \"Burning not active.\");\r\n        super._burn(tokenId);\r\n        // keep track of burners\r\n        if (burnedTokensByOwners[msg.sender].length","after":"Mint(uint8 alignment) public payable nonReentrant{\r\n        require(mintingActive && salesStarted(), \"Minting is not active\");\r\n        require(premiumMintingSlots>0, \"No more premium minting slots\");\r\n        require(totalSupply()<= maxSupply, \"Maximum supply reached\");\r\n        require(msg.value == premiumTokenPrice, \"Wrong payment\");\r\n        premiumOwners[premiumMintingSlots -1] = msg.sender;\r\n        premiumMintingSlots--;\r\n        _internalMintRandom(msg.sender, 1, alignment);\r\n    }\r\n    \r\n    function burn(uint256 tokenId) public nonReentrant{\r\n        require(burningActive, \"Burning not active.\");\r\n        super._burn(tokenId);\r\n        // keep track of burners\r\n        if (burnedTokensByOwners[msg.sender].length","contract":"ConjuredLands","time":1},{"type":"external-function ","before":"   }\r\n        burnedTokensByOwners[msg.sender].push(tokenId);\r\n    }\r\n    \r\n    function getBurnedTokensByOwner(address owner) public view returns(uint256[] memory){\r\n        return burnedTokensByOwners[owner];\r\n    }\r\n    \r\n    event FundsReceived(address from, uint256 amount, string description);\r\n    // accounting purposes: we need to be able to split the incoming funds between sales and royalty\r\n    receive() external payable {\r\n        emit FundsReceived(msg.sender, msg.value, \"direct payment, no sale\");\r\n    }\r\n    fallback() external payable {\r\n        emit FundsReceived(msg.sender, msg.value, \"direct payment, no sale\");\r\n    }\r\n\r\n    /*\r\n     *  Functions for handling signed messages\r\n     * \r\n     * */\r\n\r\n    function mintById_SignedMessage(uint256 _tokenId, uint256 _setPrice, uint256 expirationTimestamp, uint256 _nonce, bytes memory _sig) public payable{\r\n        // check validity and execute\r\n        re","after":"   }\r\n        burnedTokensByOwners[msg.sender].push(tokenId);\r\n    }\r\n    \r\n    function getBurnedTokensByOwner(address owner) public view returns(uint256[] calldata){\r\n        return burnedTokensByOwners[owner];\r\n    }\r\n    \r\n    event FundsReceived(address from, uint256 amount, string description);\r\n    // accounting purposes: we need to be able to split the incoming funds between sales and royalty\r\n    receive() external payable {\r\n        emit FundsReceived(msg.sender, msg.value, \"direct payment, no sale\");\r\n    }\r\n    fallback() external payable {\r\n        emit FundsReceived(msg.sender, msg.value, \"direct payment, no sale\");\r\n    }\r\n\r\n    /*\r\n     *  Functions for handling signed messages\r\n     * \r\n     * */\r\n\r\n    function mintById_SignedMessage(uint256 _tokenId, uint256 _setPrice, uint256 expirationTimestamp, uint256 _nonce, bytes memory _sig) public payable{\r\n        // check validity and execute\r\n        re","contract":"ConjuredLands","time":0},{"type":"external-function ","before":"pirationTimestamp <= block.timestamp, \"Expired\");\r\n        bytes32 message = SignedMessages.prefixed(keccak256(abi.encodePacked(msg.sender, _tokenId, _setPrice, expirationTimestamp, _nonce)));\r\n        require(msg.value == _setPrice, \"Wrong payment\");\r\n        require(SignedMessages.consumePass(message, _sig, _nonce), \"Error in signed msg\");\r\n        _internalMintById(msg.sender, _tokenId);\r\n        if (msg.value > 0) {\r\n            emit FundsReceived(msg.sender, msg.value, \"payment by minting sale\");\r\n        }\r\n    }\r\n\r\n    //DAppJS.addSignatureCall('test', 'address', 'uint8', 'uint256', 'uint256', 'uint256','uint256', 'bytes memory');\r\n    function mintByAlignment_SignedMessage(uint8 _alignment, uint256 _numberOfTokens, uint256 _maxAmountOfTokens, uint256 _setPrice, uint256 expirationTimestamp, uint256 _nonce, bytes memory _sig) public payable{\r\n        // check validity and execute\r\n        require(","after":"pirationTimestamp <= block.timestamp, \"Expired\");\r\n        bytes32 message = SignedMessages.prefixed(keccak256(abi.encodePacked(msg.sender, _tokenId, _setPrice, expirationTimestamp, _nonce)));\r\n        require(msg.value == _setPrice, \"Wrong payment\");\r\n        require(SignedMessages.consumePass(message, _sig, _nonce), \"Error in signed msg\");\r\n        _internalMintById(msg.sender, _tokenId);\r\n        if (msg.value > 0) {\r\n            emit FundsReceived(msg.sender, msg.value, \"payment by minting sale\");\r\n        }\r\n    }\r\n\r\n    //DAppJS.addSignatureCall('test', 'address', 'uint8', 'uint256', 'uint256', 'uint256','uint256', 'bytes memory');\r\n    function mintByAlignment_SignedMessage(uint8 _alignment, uint256 _numberOfTokens, uint256 _maxAmountOfTokens, uint256 _setPrice, uint256 expirationTimestamp, uint256 _nonce, bytes memory _sig) public payable{\r\n        // check validity and execute\r\n        require(","contract":"ConjuredLands","time":0},{"type":"external-function ","before":"       _internalMintRandom(msg.sender, _numberOfTokens, _alignment);\r\n        if (msg.value > 0) {\r\n            emit FundsReceived(msg.sender, msg.value, \"payment by minting sale\");\r\n        }\r\n    }\r\n\r\n    function mintAnyAlignment_Sign","after":"       _internalMintRandom(msg.sender, _numberOfTokens, _alignment);\r\n        if (msg.value > 0) {\r\n            emit FundsReceived(msg.sender, msg.value, \"payment by minting sale\");\r\n        }\r\n    }\r\n\r\n    function mintAnyAlignment_Sign","contract":"ConjuredLands","time":0},{"type":"external-function ","before":";\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a l","after":";\n\n        (bool success, bytes calldata returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a l","contract":"ConjuredLands","time":0},{"type":"external-function ","before":"   assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that","after":"   assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that","contract":"ConjuredLands","time":0},{"type":"external-function ","before":"lled before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is ze","after":"lled before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is ze","contract":"ConjuredLands","time":0},{"type":"constant-restrict-modification  ","before":"                                    ","after":"                                    ","contract":"ConjuredLands","time":1}]}