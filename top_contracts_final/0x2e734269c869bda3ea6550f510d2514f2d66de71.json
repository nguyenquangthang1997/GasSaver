{"time":204,"results":[{"type":"external-function ","before":"function mint(\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes memory data\n  ) public virtual {\n    require(hasRole(MINTER_ROLE, _msgSender()), 'ERC1155: must have minter role to mint');\n\n    _mint(to, id, amount, data);\n  }","after":"function mint(\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes calldata data\n  ) public virtual {\n    require(hasRole(MINTER_ROLE, _msgSender()), 'ERC1155: must have minter role to mint');\n\n    _mint(to, id, amount, data);\n  }","contract":"StrongNFTV2","time":0},{"type":"external-function ","before":"function mintBatch(\n    address to,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    bytes memory data\n  ) public virtual {\n    require(hasRole(MINTER_ROLE, _msgSender()), 'ERC1155: must have minter role to mint');\n\n    _mintBatch(to, ids, amounts, data);\n  }","after":"function mintBatch(\n    address to,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata data\n  ) public virtual {\n    require(hasRole(MINTER_ROLE, _msgSender()), 'ERC1155: must have minter role to mint');\n\n    _mintBatch(to, ids, amounts, data);\n  }","contract":"StrongNFTV2","time":0},{"type":"external-function ","before":"function burnBatch(address account, uint256[] memory ids, uint256[] memory values) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }","after":"function burnBatch(address account, uint256[] calldata ids, uint256[] calldata values) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }","contract":"StrongNFTV2","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n    address from,\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes memory data\n  ) public virtual override {\n    require(to != address(0), 'ERC1155: transfer to the zero address');\n    require(from == _msgSender() || isApprovedForAll(from, _msgSender()), 'ERC1155: caller is not owner nor approved');\n\n    address operator = _msgSender();\n\n    _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n    _balances[id][from] = _balances[id][from].sub(amount, 'ERC1155: insufficient balance for transfer');\n    if (_balances[id][from] == 0 && _ownerIdExists(from, id)) {\n      _deleteOwnerId(from, id);\n    }\n    _balances[id][to] = _balances[id][to].add(amount);\n    if (!_ownerIdExists(to, id)) {\n      _addOwnerId(to, id);\n    }\n\n    emit TransferSingle(operator, from, to, id, amount);\n\n    _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n  }","after":"function safeTransferFrom(\n    address from,\n    address to,\n    uint256 id,\n    uint256 amount,\n    bytes calldata data\n  ) public virtual override {\n    require(to != address(0), 'ERC1155: transfer to the zero address');\n    require(from == _msgSender() || isApprovedForAll(from, _msgSender()), 'ERC1155: caller is not owner nor approved');\n\n    address operator = _msgSender();\n\n    _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n    _balances[id][from] = _balances[id][from].sub(amount, 'ERC1155: insufficient balance for transfer');\n    if (_balances[id][from] == 0 && _ownerIdExists(from, id)) {\n      _deleteOwnerId(from, id);\n    }\n    _balances[id][to] = _balances[id][to].add(amount);\n    if (!_ownerIdExists(to, id)) {\n      _addOwnerId(to, id);\n    }\n\n    emit TransferSingle(operator, from, to, id, amount);\n\n    _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n  }","contract":"StrongNFTV2","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] memory ids,\n    uint256[] memory amounts,\n    bytes memory data\n  ) public virtual override {\n    require(ids.length == amounts.length, 'ERC1155: ids and amounts length mismatch');\n    require(to != address(0), 'ERC1155: transfer to the zero address');\n    require(\n      from == _msgSender() || isApprovedForAll(from, _msgSender()),\n      'ERC1155: transfer caller is not owner nor approved'\n    );\n\n    address operator = _msgSender();\n\n    _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n    for (uint256 i = 0; i < ids.length; ++i) {\n      uint256 id = ids[i];\n      uint256 amount = amounts[i];\n\n      _balances[id][from] = _balances[id][from].sub(amount, 'ERC1155: insufficient balance for transfer');\n      if (_balances[id][from] == 0 && _ownerIdExists(from, id)) {\n        _deleteOwnerId(from, id);\n      }\n      _balances[id][to] = _balances[id][to].add(amount);\n      if (!_ownerIdExists(to, id)) {\n        _addOwnerId(to, id);\n      }\n    }\n\n    emit TransferBatch(operator, from, to, ids, amounts);\n\n    _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n  }","after":"function safeBatchTransferFrom(\n    address from,\n    address to,\n    uint256[] calldata ids,\n    uint256[] calldata amounts,\n    bytes calldata data\n  ) public virtual override {\n    require(ids.length == amounts.length, 'ERC1155: ids and amounts length mismatch');\n    require(to != address(0), 'ERC1155: transfer to the zero address');\n    require(\n      from == _msgSender() || isApprovedForAll(from, _msgSender()),\n      'ERC1155: transfer caller is not owner nor approved'\n    );\n\n    address operator = _msgSender();\n\n    _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n    for (uint256 i = 0; i < ids.length; ++i) {\n      uint256 id = ids[i];\n      uint256 amount = amounts[i];\n\n      _balances[id][from] = _balances[id][from].sub(amount, 'ERC1155: insufficient balance for transfer');\n      if (_balances[id][from] == 0 && _ownerIdExists(from, id)) {\n        _deleteOwnerId(from, id);\n      }\n      _balances[id][to] = _balances[id][to].add(amount);\n      if (!_ownerIdExists(to, id)) {\n        _addOwnerId(to, id);\n      }\n    }\n\n    emit TransferBatch(operator, from, to, ids, amounts);\n\n    _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n  }","contract":"StrongNFTV2","time":0}]}