{"time":199,"results":[{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"Oddies","time":0},{"type":"constant-restrict-modification  ","before":"              if (_owners[tokenId] != zer","after":"              if (_owners[tokenId] != zer","contract":"Oddies","time":0},{"type":"constant-restrict-modification  ","before":"{\n                    ++supply;\n     ","after":"{\n                    ++supply;\n     ","contract":"Oddies","time":0},{"type":"constant-restrict-modification  ","before":"        }\n            }\n        }\n    }\n\n    /**","after":"        }\n            }\n        }\n    }\n\n    /**","contract":"Oddies","time":0},{"type":"constant-restrict-modification  ","before":" * @dev See {IERC721Enumerable-tokenByIndex}.\n   ","after":" * @dev See {IERC721Enumerable-tokenByIndex}.\n   ","contract":"Oddies","time":0},{"type":"constant-restrict-modification  ","before":"/\n    function tokenByIndex(uint256 index)\n  ","after":"/\n    function tokenByIndex(uint256 index)\n  ","contract":"Oddies","time":0},{"type":"constant-restrict-modification  ","before":"   public\n        view\n        virtual\n     ","after":"   public\n        view\n        virtual\n     ","contract":"Oddies","time":0},{"type":"constant-restrict-modification  ","before":"override\n        returns (uint256 tokenId)","after":"override\n        returns (uint256 tokenId)","contract":"Oddies","time":0},{"type":"constant-restrict-modification  ","before":"  {\n        uint256 length = _owners.len","after":"  {\n        uint256 length = _owners.len","contract":"Oddies","time":0}]}