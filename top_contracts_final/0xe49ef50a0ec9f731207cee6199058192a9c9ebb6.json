{"time":171,"results":[{"type":"state-data-arrangement ","before":"\naddress constant WALLET1 = 0xc4eeB8020e539C70Ecbd6464F7dB3Fe61de91986;\naddress constant WALLET2 = 0x60EAbA940B9d10A8c3C8165079629794e7354dc9;\nuint256 constant public MAX_SUPPLY = 9999;\nbool public saleIsActive = false;\nbool public preSaleIsActive = true;\nuint256 public mintPrice = 69000000000000000;\nuint256 public maxToMint = 10;\nuint256 public maxToMintWhitelist = 20;\nstring _baseTokenURI;\nstring _contractURI;\naddress[] whitelistAddr;\nmapping(address => Whitelist) public whitelist;","after":"uint256 constant public MAX_SUPPLY = 9999;\nuint256 public mintPrice = 69000000000000000;\nuint256 public maxToMint = 10;\nuint256 public maxToMintWhitelist = 20;\nstring _baseTokenURI;\nstring _contractURI;\naddress[] whitelistAddr;\nmapping(address => Whitelist) public whitelist;\naddress constant WALLET1 = 0xc4eeB8020e539C70Ecbd6464F7dB3Fe61de91986;\naddress constant WALLET2 = 0x60EAbA940B9d10A8c3C8165079629794e7354dc9;\nbool public saleIsActive = false;\nbool public preSaleIsActive = true;\n","contract":"ProfessorElonNFT","time":0},{"type":"external-function ","before":"function setBaseTokenURI(string memory _uri) public onlyOwner {\n        _baseTokenURI = _uri;\n    }","after":"function setBaseTokenURI(string calldata _uri) public onlyOwner {\n        _baseTokenURI = _uri;\n    }","contract":"ProfessorElonNFT","time":0},{"type":"external-function ","before":"function setContractURI(string memory _uri) public onlyOwner {\n        _contractURI = _uri;\n    }","after":"function setContractURI(string calldata _uri) public onlyOwner {\n        _contractURI = _uri;\n    }","contract":"ProfessorElonNFT","time":0},{"type":"external-function ","before":"function addAddressesToWhitelist(address[] memory addrs) onlyOwner public returns(bool success) {\n        whitelistAddr = addrs;\n        for(uint i = 0; i < whitelistAddr.length; i++) {\n            addAddressToWhitelist(whitelistAddr[i]);\n        }\n        success = true;\n    }","after":"function addAddressesToWhitelist(address[] calldata addrs) onlyOwner public returns(bool success) {\n        whitelistAddr = addrs;\n        for(uint i = 0; i < whitelistAddr.length; i++) {\n            addAddressToWhitelist(whitelistAddr[i]);\n        }\n        success = true;\n    }","contract":"ProfessorElonNFT","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"ProfessorElonNFT","time":0},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"ProfessorElonNFT","time":1}]}