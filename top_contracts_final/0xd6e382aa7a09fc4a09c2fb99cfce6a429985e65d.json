{"time":134,"results":[{"type":"state-data-arrangement ","before":"\naddress public owner;\naddress earlyAccessHolders;\nmapping(address => uint256) internal balances;\nmapping (uint256 => address) internal allowance;\nmapping (address => mapping (address => bool)) internal authorised;\nuint16[] tokenIndexToCity;\nmapping(uint256 => address) owners;\nstring private __name = \"Doomsday NFT\";\nstring private __symbol = \"BUNKER\";\nbytes private __uriBase = bytes(\"https://gateway.pinata.cloud/ipfs/QmUwPH9PmTQrT67M633AJRXACsecmRTihf4DUbJZb9y83M/\");\nbytes private __uriSuffix = bytes(\".json\");\nuint constant MAX_CITIES = 38611;\nint64 constant MAP_WIDTH         = 4320000;\nint64 constant MAP_HEIGHT        = 2588795;\nint64 constant BASE_BLAST_RADIUS = 100000;\nuint constant MINT_COST = 0.04 ether;\nuint constant MINT_PERCENT_WINNER       = 50;\nuint constant MINT_PERCENT_CALLER       = 25;\nuint constant MINT_PERCENT_CREATOR      = 25;\nuint constant REINFORCE_PERCENT_WINNER  = 90;\nuint constant REINFORCE_PERCENT_CREATOR = 10;\nuint constant IMPACT_BLOCK_INTERVAL = 120;\nmapping(uint16 => uint) public cityToToken;\nmapping(uint16 => int64[2]) coordinates;\nbytes32 cityRoot;\nmapping(uint => bytes32) structuralData;\nuint public reinforcements;\nuint public destroyed;\nuint public evacuatedFunds;\nuint ownerWithdrawn;\nbool winnerWithdrawn;\nuint public startTime;\nuint SALE_TIME = 7 days;\nuint EARLY_ACCESS_TIME = 1 days;\nmapping (bytes4 => bool) internal supportedInterfaces;","after":"mapping(address => uint256) internal balances;\nmapping (uint256 => address) internal allowance;\nmapping (address => mapping (address => bool)) internal authorised;\nuint16[] tokenIndexToCity;\nmapping(uint256 => address) owners;\nstring private __name = \"Doomsday NFT\";\nstring private __symbol = \"BUNKER\";\nbytes private __uriBase = bytes(\"https://gateway.pinata.cloud/ipfs/QmUwPH9PmTQrT67M633AJRXACsecmRTihf4DUbJZb9y83M/\");\nbytes private __uriSuffix = bytes(\".json\");\nuint constant MAX_CITIES = 38611;\nuint constant MINT_COST = 0.04 ether;\nuint constant MINT_PERCENT_WINNER       = 50;\nuint constant MINT_PERCENT_CALLER       = 25;\nuint constant MINT_PERCENT_CREATOR      = 25;\nuint constant REINFORCE_PERCENT_WINNER  = 90;\nuint constant REINFORCE_PERCENT_CREATOR = 10;\nuint constant IMPACT_BLOCK_INTERVAL = 120;\nmapping(uint16 => uint) public cityToToken;\nmapping(uint16 => int64[2]) coordinates;\nbytes32 cityRoot;\nmapping(uint => bytes32) structuralData;\nuint public reinforcements;\nuint public destroyed;\nuint public evacuatedFunds;\nuint ownerWithdrawn;\nuint public startTime;\nuint SALE_TIME = 7 days;\nuint EARLY_ACCESS_TIME = 1 days;\nmapping (bytes4 => bool) internal supportedInterfaces;\naddress public owner;\naddress earlyAccessHolders;\nint64 constant MAP_WIDTH         = 4320000;\nint64 constant MAP_HEIGHT        = 2588795;\nint64 constant BASE_BLAST_RADIUS = 100000;\nbool winnerWithdrawn;\n","contract":"Doomsday","time":1},{"type":"external-function ","before":"function inhabit(uint16 _cityId, int64[2] calldata _coordinates, bytes32[] memory proof) public payable{\r\n        require(stage() == Stage.PreApocalypse,\"stage\");\r\n        if(block.timestamp < startTime + EARLY_ACCESS_TIME){\r\n            //First day is insiders list\r\n            require(IERC721(earlyAccessHolders).balanceOf(msg.sender) > 0,\"early\");\r\n        }\r\n\r\n\r\n        bytes32 leaf = keccak256(abi.encodePacked(_cityId,_coordinates[0],_coordinates[1]));\r\n\r\n        require(MerkleProof.verify(proof, cityRoot, leaf),\"proof\");\r\n\r\n        require(cityToToken[_cityId] == 0 && coordinates[_cityId][0] == 0 && coordinates[_cityId][1] == 0,\"inhabited\");\r\n\r\n        require(\r\n            _coordinates[0] >= -MAP_WIDTH/2 &&\r\n            _coordinates[0] <= MAP_WIDTH/2 &&\r\n\r\n            _coordinates[1] >= -MAP_HEIGHT/2 &&\r\n            _coordinates[1] <= MAP_HEIGHT/2,\r\n            \"off map\"\r\n        );  //Not strictly necessary but proves the whitelist hasnt been fucked with\r\n\r\n\r\n        require(msg.value == MINT_COST,\"cost\");\r\n\r\n        coordinates[_cityId] = _coordinates;\r\n\r\n        tokenIndexToCity.push(_cityId);\r\n\r\n        uint _tokenId = tokenIndexToCity.length;\r\n\r\n        balances[msg.sender]++;\r\n        owners[_tokenId] = msg.sender;\r\n        cityToToken[_cityId] = _tokenId;\r\n\r\n        emit Inhabit(_cityId, _tokenId);\r\n        emit Transfer(address(0),msg.sender,_tokenId);\r\n    }","after":"function inhabit(uint16 _cityId, int64[2] calldata _coordinates, bytes32[] calldata proof) public payable{\r\n        require(stage() == Stage.PreApocalypse,\"stage\");\r\n        if(block.timestamp < startTime + EARLY_ACCESS_TIME){\r\n            //First day is insiders list\r\n            require(IERC721(earlyAccessHolders).balanceOf(msg.sender) > 0,\"early\");\r\n        }\r\n\r\n\r\n        bytes32 leaf = keccak256(abi.encodePacked(_cityId,_coordinates[0],_coordinates[1]));\r\n\r\n        require(MerkleProof.verify(proof, cityRoot, leaf),\"proof\");\r\n\r\n        require(cityToToken[_cityId] == 0 && coordinates[_cityId][0] == 0 && coordinates[_cityId][1] == 0,\"inhabited\");\r\n\r\n        require(\r\n            _coordinates[0] >= -MAP_WIDTH/2 &&\r\n            _coordinates[0] <= MAP_WIDTH/2 &&\r\n\r\n            _coordinates[1] >= -MAP_HEIGHT/2 &&\r\n            _coordinates[1] <= MAP_HEIGHT/2,\r\n            \"off map\"\r\n        );  //Not strictly necessary but proves the whitelist hasnt been fucked with\r\n\r\n\r\n        require(msg.value == MINT_COST,\"cost\");\r\n\r\n        coordinates[_cityId] = _coordinates;\r\n\r\n        tokenIndexToCity.push(_cityId);\r\n\r\n        uint _tokenId = tokenIndexToCity.length;\r\n\r\n        balances[msg.sender]++;\r\n        owners[_tokenId] = msg.sender;\r\n        cityToToken[_cityId] = _tokenId;\r\n\r\n        emit Inhabit(_cityId, _tokenId);\r\n        emit Transfer(address(0),msg.sender,_tokenId);\r\n    }","contract":"Doomsday","time":0},{"type":"immutable-restrict-modification ","before":"address earlyAccessHolders;","after":"address immutable earlyAccessHolders;","contract":"Doomsday","time":0},{"type":"constant-restrict-modification  ","before":"string private __name = \"Doomsday NFT\";","after":"string private constant __name = \"Doomsday NFT\";","contract":"Doomsday","time":0},{"type":"constant-restrict-modification  ","before":"string private __symbol = \"BUNKER\";","after":"string private constant __symbol = \"BUNKER\";","contract":"Doomsday","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 cityRoot;","after":"bytes32 immutable cityRoot;","contract":"Doomsday","time":0},{"type":"constant-restrict-modification  ","before":"uint SALE_TIME = 7 days;","after":"uint constant SALE_TIME = 7 days;","contract":"Doomsday","time":0},{"type":"constant-restrict-modification  ","before":"uint EARLY_ACCESS_TIME = 1 days;","after":"uint constant EARLY_ACCESS_TIME = 1 days;","contract":"Doomsday","time":0}]}