{"time":215,"results":[{"type":"external-function ","before":"function intializeContract(address[] memory accounts, uint256[] memory amounts, uint256[] memory amountsD, address _antiSnipe) external onlyOwner {\n        require(!contractInitialized, \"1\");\n        require(accounts.length < 200, \"2\");\n        require(accounts.length == amounts.length, \"3\");\n        require(amounts.length == amountsD.length, \"4\");\n        startingSupply = 666_000_000_000_000;\n        antiSnipe = AntiSnipe(_antiSnipe);\n        if(address(antiSnipe) == address(0)){\n            antiSnipe = AntiSnipe(address(this));\n        }\n        try antiSnipe.transfer(address(this)) {} catch {}\n        if (startingSupply < 10000000000) {\n            _decimals = 18;\n        } else {\n            _decimals = 9;\n        }\n        _tTotal = startingSupply * (10**_decimals);\n        _rTotal = (~uint256(0) - (~uint256(0) % _tTotal));\n        _name = \"MonstaVerse\";\n        _symbol = \"MONSTR\";\n        dexRouter = IRouter02(currentRouter);\n        lpPair = IFactoryV2(dexRouter.factory()).createPair(dexRouter.WETH(), address(this));\n        lpPairs[lpPair] = true;        \n        path = new address[](2);\n        path[0] = address(this);\n        path[1] = dexRouter.WETH();\n        _maxTxAmount = (_tTotal * 5) / 1000;\n        _maxWalletSize = (_tTotal * 15) / 1000;\n        swapThreshold = (_tTotal * 5) / 10000;\n        swapAmount = (_tTotal * 25) / 10000;\n        contractInitialized = true;     \n        _rOwned[owner()] = _rTotal;\n        emit Transfer(address(0), owner(), _tTotal);\n\n        _approve(address(this), address(dexRouter), type(uint256).max);\n\n        for(uint256 i = 0; i < accounts.length; i++){\n            uint256 amount = (_tTotal*amounts[i]) / amountsD[i];\n            _transfer(owner(), accounts[i], amount);\n        }\n\n        _transfer(owner(), address(this), balanceOf(owner()));\n\n        dexRouter.addLiquidityETH{value: address(this).balance}(\n            address(this),\n            balanceOf(address(this)),\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner(),\n            block.timestamp\n        );\n\n        enableTrading();\n    }","after":"function intializeContract(address[] calldata accounts, uint256[] calldata amounts, uint256[] calldata amountsD, address _antiSnipe) external onlyOwner {\n        require(!contractInitialized, \"1\");\n        require(accounts.length < 200, \"2\");\n        require(accounts.length == amounts.length, \"3\");\n        require(amounts.length == amountsD.length, \"4\");\n        startingSupply = 666_000_000_000_000;\n        antiSnipe = AntiSnipe(_antiSnipe);\n        if(address(antiSnipe) == address(0)){\n            antiSnipe = AntiSnipe(address(this));\n        }\n        try antiSnipe.transfer(address(this)) {} catch {}\n        if (startingSupply < 10000000000) {\n            _decimals = 18;\n        } else {\n            _decimals = 9;\n        }\n        _tTotal = startingSupply * (10**_decimals);\n        _rTotal = (~uint256(0) - (~uint256(0) % _tTotal));\n        _name = \"MonstaVerse\";\n        _symbol = \"MONSTR\";\n        dexRouter = IRouter02(currentRouter);\n        lpPair = IFactoryV2(dexRouter.factory()).createPair(dexRouter.WETH(), address(this));\n        lpPairs[lpPair] = true;        \n        path = new address[](2);\n        path[0] = address(this);\n        path[1] = dexRouter.WETH();\n        _maxTxAmount = (_tTotal * 5) / 1000;\n        _maxWalletSize = (_tTotal * 15) / 1000;\n        swapThreshold = (_tTotal * 5) / 10000;\n        swapAmount = (_tTotal * 25) / 10000;\n        contractInitialized = true;     \n        _rOwned[owner()] = _rTotal;\n        emit Transfer(address(0), owner(), _tTotal);\n\n        _approve(address(this), address(dexRouter), type(uint256).max);\n\n        for(uint256 i = 0; i < accounts.length; i++){\n            uint256 amount = (_tTotal*amounts[i]) / amountsD[i];\n            _transfer(owner(), accounts[i], amount);\n        }\n\n        _transfer(owner(), address(this), balanceOf(owner()));\n\n        dexRouter.addLiquidityETH{value: address(this).balance}(\n            address(this),\n            balanceOf(address(this)),\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner(),\n            block.timestamp\n        );\n\n        enableTrading();\n    }","contract":"MonstaVerse","time":0},{"type":"external-function ","before":"function setBlacklistEnabledMultiple(address[] memory accounts, bool enabled) external onlyOwner {\n        antiSnipe.setBlacklistEnabledMultiple(accounts, enabled);\n    }","after":"function setBlacklistEnabledMultiple(address[] calldata accounts, bool enabled) external onlyOwner {\n        antiSnipe.setBlacklistEnabledMultiple(accounts, enabled);\n    }","contract":"MonstaVerse","time":0},{"type":"constant-restrict-modification  ","before":"address private pcsV2Router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;","after":"address private constant pcsV2Router = 0x10ED43C718714eb63d5aA57B78B54704E256024E;","contract":"MonstaVerse","time":1},{"type":"constant-restrict-modification  ","before":"address private uniswapV2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;","after":"address private constant uniswapV2Router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;","contract":"MonstaVerse","time":1}]}