{"time":201,"results":[{"type":"external-function ","before":"function mint(address to, uint numberOfTokens, bytes32[] memory proof) public payable {\n        // Gas optimization\n        uint256 _nowTokenId = nowTokenId;\n        // address operator = _msgSender();\n\n        require(SaleIsActive, \"Sale must be active to mint NFT\");\n        require(_nowTokenId + numberOfTokens <= MAX_NFT, \"Purchase would exceed max NFT supply\");\n        require(NFTPrice.mul(numberOfTokens) <= msg.value, \"Ether value sent is not correct\");\n        if (!ForAllIsActive) {\n            require(numberOfTokens <= maxNFTPurchase, \"Can only mint 2 tokens at a time\");\n            require(listPurchases[to] + numberOfTokens <= maxNFTPurchase, 'Error: Error: Each person can mint only 2 in one phase');\n            require(MerkleProof.verify(proof, root, keccak256(abi.encodePacked(to))), \"You are not allowed to mint\");\n        }\n\n        // The contract never holds any Ether. Everything gets redirected to treasury directly.\n        treasury.transfer(msg.value);\n        \n        for(uint i = 1; i <= numberOfTokens; i++) {\n            listPurchases[to]++;\n            _safeMint(to, _nowTokenId + i);\n        }\n        nowTokenId += numberOfTokens;\n    }","after":"function mint(address to, uint numberOfTokens, bytes32[] calldata proof) public payable {\n        // Gas optimization\n        uint256 _nowTokenId = nowTokenId;\n        // address operator = _msgSender();\n\n        require(SaleIsActive, \"Sale must be active to mint NFT\");\n        require(_nowTokenId + numberOfTokens <= MAX_NFT, \"Purchase would exceed max NFT supply\");\n        require(NFTPrice.mul(numberOfTokens) <= msg.value, \"Ether value sent is not correct\");\n        if (!ForAllIsActive) {\n            require(numberOfTokens <= maxNFTPurchase, \"Can only mint 2 tokens at a time\");\n            require(listPurchases[to] + numberOfTokens <= maxNFTPurchase, 'Error: Error: Each person can mint only 2 in one phase');\n            require(MerkleProof.verify(proof, root, keccak256(abi.encodePacked(to))), \"You are not allowed to mint\");\n        }\n\n        // The contract never holds any Ether. Everything gets redirected to treasury directly.\n        treasury.transfer(msg.value);\n        \n        for(uint i = 1; i <= numberOfTokens; i++) {\n            listPurchases[to]++;\n            _safeMint(to, _nowTokenId + i);\n        }\n        nowTokenId += numberOfTokens;\n    }","contract":"BMW","time":0},{"type":"external-function ","before":"�完\n\n    function presaleMint(address to, uint numberOfTokens, bytes32[] memory proof) public payable {\n        // Gas optimization\n        uint256 _nowTokenId = nowTokenId;\n        // address operator = _msgSender();\n\n        require(PresaleIsActive, \"Presale must be active to mint NFT\");\n        require(numberOfTokens <= maxNFTPurchase, \"Can only mint 2 tokens at a time\");\n        require((_nowTokenId + numberOfTokens) <= (airdropSupply + presaleSupply), \"Purchase would exceed max supply of presale\");\n        require(NFTPrice.mul(numberOfTokens) <= msg.value, \"Ether value sent is not correct\");\n        require(presaleListPurchases[to] + numberOfTokens <= maxNFTPurchase, 'Error: Each person can mint only 2 tokens in one phase');\n        require(MerkleProof.verify(proof, presaleRoot, keccak256(abi.encodePacked(to))), \"You are not allowed to mint during presale\");\n\n        // The contract never holds any Ether. Everything gets redirected to treasury directly.\n        treasury.transfer(msg.value);\n        \n        for(uint i = 1; i <= numberOfTokens; i++) {\n            presaleListPurchases[to]++;\n            _safeMint(to, _nowTokenId + i);\n        }\n        nowTokenId += numberOfTok","after":"�完\n\n    function presaleMint(address to, uint numberOfTokens, bytes32[] memory proof) public payable {\n        // Gas optimization\n        uint256 _nowTokenId = nowTokenId;\n        // address operator = _msgSender();\n\n        require(PresaleIsActive, \"Presale must be active to mint NFT\");\n        require(numberOfTokens <= maxNFTPurchase, \"Can only mint 2 tokens at a time\");\n        require((_nowTokenId + numberOfTokens) <= (airdropSupply + presaleSupply), \"Purchase would exceed max supply of presale\");\n        require(NFTPrice.mul(numberOfTokens) <= msg.value, \"Ether value sent is not correct\");\n        require(presaleListPurchases[to] + numberOfTokens <= maxNFTPurchase, 'Error: Each person can mint only 2 tokens in one phase');\n        require(MerkleProof.verify(proof, presaleRoot, keccak256(abi.encodePacked(to))), \"You are not allowed to mint during presale\");\n\n        // The contract never holds any Ether. Everything gets redirected to treasury directly.\n        treasury.transfer(msg.value);\n        \n        for(uint i = 1; i <= numberOfTokens; i++) {\n            presaleListPurchases[to]++;\n            _safeMint(to, _nowTokenId + i);\n        }\n        nowTokenId += numberOfTok","contract":"BMW","time":0},{"type":"external-function ","before":"   }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _setBaseURI(baseU","after":"   }\n\n    function setBaseURI(string memory baseURI) public onlyOwner {\n        _setBaseURI(baseU","contract":"BMW","time":0},{"type":"immutable-restrict-modification ","before":"address payable public treasury;","after":"address payable public immutable treasury;","contract":"BMW","time":0}]}