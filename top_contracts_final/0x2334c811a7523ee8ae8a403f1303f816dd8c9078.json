{"time":629,"results":[{"type":"external-function ","before":"function claimAirdrop(\n    uint16[] calldata tokenIds,\n    uint8[] calldata tiers,\n    bytes32[][] memory tierProof\n  ) \n    external\n  {\n    uint16 tokenId;\n    uint256 earned = 0;\n\n    for (uint i = 0; i < tokenIds.length; i++) {\n      tokenId = tokenIds[i];\n      require(!airdropClaimed[tokenId], \"Already claimed\");\n      require(nft.ownerOf(tokenId) == msg.sender, \"Not your token\");\n\n      /**\n       * Verify the tier is correct\n       * @dev to align with merkle tree, use string token instead of int\n       */\n      string memory tokenStr = Strings.toString(tokenId);\n      uint8 tier = tiers[i];\n      bytes32[] memory proof = tierProof[i];\n      bytes32 root = tierRoot[tier];\n      bytes32 leaf = keccak256(abi.encodePacked(tokenStr));\n      bool proofed = MerkleProof.verify(proof, root, leaf);\n      require(proofed, \"Tier not match\");\n      \n      airdropClaimed[tokenId] = true;\n      uint256 claimForDays = (block.timestamp - genesisBirthday) / 1 days;\n      if (claimForDays > 19) claimForDays = 19;\n      earned += baseRate * tier / 10 * claimForDays;\n    }\n\n    if (earned > 0) {\n      token.mint(msg.sender, earned);\n      emit Claimed(msg.sender, earned);\n    }\n  }","after":"function claimAirdrop(\n    uint16[] calldata tokenIds,\n    uint8[] calldata tiers,\n    bytes32[][] calldata tierProof\n  ) \n    external\n  {\n    uint16 tokenId;\n    uint256 earned = 0;\n\n    for (uint i = 0; i < tokenIds.length; i++) {\n      tokenId = tokenIds[i];\n      require(!airdropClaimed[tokenId], \"Already claimed\");\n      require(nft.ownerOf(tokenId) == msg.sender, \"Not your token\");\n\n      /**\n       * Verify the tier is correct\n       * @dev to align with merkle tree, use string token instead of int\n       */\n      string memory tokenStr = Strings.toString(tokenId);\n      uint8 tier = tiers[i];\n      bytes32[] memory proof = tierProof[i];\n      bytes32 root = tierRoot[tier];\n      bytes32 leaf = keccak256(abi.encodePacked(tokenStr));\n      bool proofed = MerkleProof.verify(proof, root, leaf);\n      require(proofed, \"Tier not match\");\n      \n      airdropClaimed[tokenId] = true;\n      uint256 claimForDays = (block.timestamp - genesisBirthday) / 1 days;\n      if (claimForDays > 19) claimForDays = 19;\n      earned += baseRate * tier / 10 * claimForDays;\n    }\n\n    if (earned > 0) {\n      token.mint(msg.sender, earned);\n      emit Claimed(msg.sender, earned);\n    }\n  }","contract":"GenesisVault","time":0},{"type":"external-function ","before":"function stake(\n    uint16[] calldata tokenIds,\n    uint8[] calldata tiers,\n    bytes32[][] memory tierProof\n  ) \n    external\n  {\n    require(nft.isApprovedForAll(msg.sender, address(this)), \"Staking contract not approved\");\n\n    uint16 tokenId;\n    totalStaked += tokenIds.length;\n\n    for (uint i = 0; i < tokenIds.length; i++) {\n      tokenId = tokenIds[i];\n\n      require(airdropClaimed[tokenId], \"Airdrop not claimed\");\n      require(nft.ownerOf(tokenId) == msg.sender, \"Not your token\");\n      require(vault[tokenId].tokenId == 0, \"Already staked\");\n\n      /**\n       * Verify the tier is correct\n       * @dev to align with merkle tree, use string token instead of int\n       */\n      string memory tokenStr = Strings.toString(tokenId);\n      uint8 tier = tiers[i];\n      bytes32[] memory proof = tierProof[i];\n      bytes32 root = tierRoot[tier];\n      bytes32 leaf = keccak256(abi.encodePacked(tokenStr));\n      bool proofed = MerkleProof.verify(proof, root, leaf);\n      require(proofed, \"Tier not match\");\n      \n      nft.transferFrom(msg.sender, address(this), tokenId);\n      emit BlockStaked(msg.sender, tokenId, block.timestamp);\n\n      vault[tokenId] = Stake({\n        owner: msg.sender,\n        tokenId: uint24(tokenId),\n        timestamp: uint48(block.timestamp),\n        tier: tier\n      });\n    }\n  }","after":"function stake(\n    uint16[] calldata tokenIds,\n    uint8[] calldata tiers,\n    bytes32[][] calldata tierProof\n  ) \n    external\n  {\n    require(nft.isApprovedForAll(msg.sender, address(this)), \"Staking contract not approved\");\n\n    uint16 tokenId;\n    totalStaked += tokenIds.length;\n\n    for (uint i = 0; i < tokenIds.length; i++) {\n      tokenId = tokenIds[i];\n\n      require(airdropClaimed[tokenId], \"Airdrop not claimed\");\n      require(nft.ownerOf(tokenId) == msg.sender, \"Not your token\");\n      require(vault[tokenId].tokenId == 0, \"Already staked\");\n\n      /**\n       * Verify the tier is correct\n       * @dev to align with merkle tree, use string token instead of int\n       */\n      string memory tokenStr = Strings.toString(tokenId);\n      uint8 tier = tiers[i];\n      bytes32[] memory proof = tierProof[i];\n      bytes32 root = tierRoot[tier];\n      bytes32 leaf = keccak256(abi.encodePacked(tokenStr));\n      bool proofed = MerkleProof.verify(proof, root, leaf);\n      require(proofed, \"Tier not match\");\n      \n      nft.transferFrom(msg.sender, address(this), tokenId);\n      emit BlockStaked(msg.sender, tokenId, block.timestamp);\n\n      vault[tokenId] = Stake({\n        owner: msg.sender,\n        tokenId: uint24(tokenId),\n        timestamp: uint48(block.timestamp),\n        tier: tier\n      });\n    }\n  }","contract":"GenesisVault","time":0},{"type":"state-data-arrangement ","before":"\n   uint256 constant CAP = 3000000000 * 10 ** \n   uint256 public treasuryClaimed =\n   uint8 public reserveRate = \n   mapping(address => bool) public controlle\n   address public isoTreasu\n   bool public freezeControllers = fal\n   bool public freezeReserveRate = fal","after":"   uint256 constant CAP = 3000000000 * 10 ** \n   uint256 public treasuryClaimed =\n   mapping(address => bool) public controlle\n   address public isoTreasu\n   uint8 public reserveRate = \n   bool public freezeControllers = fal\n   bool public freezeReserveRate = fal\n","contract":"IsoToken","time":0}]}