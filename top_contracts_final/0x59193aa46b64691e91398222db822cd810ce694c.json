{"time":66,"results":[{"type":"external-function ","before":"function mint(\n      uint256[] memory _poolType,\n      uint256[] memory _amount, \n      bool[] memory _useUnicorns, \n      address[] memory _rainbowPools, \n      address[] memory _unicornPools,\n      bytes memory sig, \n      uint256 maxMints\n    ) external {\n\n    require(checkSigniture(_msgSender(), sig, maxMints), 'invalid sig');\n\n    require(numberMintedByAddress[_msgSender()] + _amount[0] <= maxMints);\n    numberMintedByAddress[_msgSender()] += _amount[0];\n\n\n    uint256 _nextTokenToMint = nextTokenToMint;\n    require(_amount[0] + _nextTokenToMint <= maxTokenId + 1, 'max reached');\n\n    for (uint256 i = 0; i < _amount[0]; i++) {\n      nftContract.mint(_msgSender(), _nextTokenToMint);\n      _nextTokenToMint++;\n    }\n    nextTokenToMint = _nextTokenToMint;\n  }","after":"function mint(\n      uint256[] calldata _poolType,\n      uint256[] calldata _amount, \n      bool[] calldata _useUnicorns, \n      address[] calldata _rainbowPools, \n      address[] calldata _unicornPools,\n      bytes calldata sig, \n      uint256 maxMints\n    ) external {\n\n    require(checkSigniture(_msgSender(), sig, maxMints), 'invalid sig');\n\n    require(numberMintedByAddress[_msgSender()] + _amount[0] <= maxMints);\n    numberMintedByAddress[_msgSender()] += _amount[0];\n\n\n    uint256 _nextTokenToMint = nextTokenToMint;\n    require(_amount[0] + _nextTokenToMint <= maxTokenId + 1, 'max reached');\n\n    for (uint256 i = 0; i < _amount[0]; i++) {\n      nftContract.mint(_msgSender(), _nextTokenToMint);\n      _nextTokenToMint++;\n    }\n    nextTokenToMint = _nextTokenToMint;\n  }","contract":"MasksWhitelistMinter","time":0}]}