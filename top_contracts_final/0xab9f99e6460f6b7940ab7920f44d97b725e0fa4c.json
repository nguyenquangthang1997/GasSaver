{"time":145,"results":[{"type":"external-function ","before":"function setProvenance(string memory _provenance) public onlyOwner {\n        PROVENANCE = _provenance;\n        emit ProvenanceSet(_provenance);\n    }","after":"function setProvenance(string calldata _provenance) public onlyOwner {\n        PROVENANCE = _provenance;\n        emit ProvenanceSet(_provenance);\n    }","contract":"SorasDreamworldLucidDreaming","time":0},{"type":"external-function ","before":"function setBaseURI(string memory _baseURI) public onlyOwner {\n        baseURI = _baseURI;\n    }","after":"function setBaseURI(string calldata _baseURI) public onlyOwner {\n        baseURI = _baseURI;\n    }","contract":"SorasDreamworldLucidDreaming","time":0},{"type":"external-function ","before":"function forceMint(address[] memory _addresses) public onlyOwner { \n        for (uint i = 0; i < _addresses.length; ++i) {\n            mintOne(_addresses[i]);\n        }\n    }","after":"function forceMint(address[] calldata _addresses) public onlyOwner { \n        for (uint i = 0; i < _addresses.length; ++i) {\n            mintOne(_addresses[i]);\n        }\n    }","contract":"SorasDreamworldLucidDreaming","time":0},{"type":"external-function ","before":"function setLicense(string memory _license) public onlyOwner {\n        LICENSE = _license;\n        emit LicenseSet(_license);\n    }","after":"function setLicense(string calldata _license) public onlyOwner {\n        LICENSE = _license;\n        emit LicenseSet(_license);\n    }","contract":"SorasDreamworldLucidDreaming","time":0},{"type":"external-function ","before":"function genesisClaim(uint[] memory _genesisIds) public nonReentrant {\n        require(saleState == 3, \"Not open.\");\n        uint n = _genesisIds.length;\n        require(n > 0 && n % 3 == 0, \"Please submit a positive multiple of 3.\");\n        address sender = msg.sender;\n        uint qPrevInitial = 1 << 255;\n        uint qPrev = qPrevInitial;\n        uint m;\n        for (uint i = 0; i < n; i += 3) {\n            for (uint j = 0; j < 3; ++j) {\n                uint t = _genesisIds[i + j];\n                uint q = t >> 8;\n                uint r = t & 255;\n                if (q != qPrev) {\n                    if (qPrev != qPrevInitial) {\n                        genesisClaimedMap[qPrev] = m;\n                    } \n                    m = genesisClaimedMap[q];\n                } \n                qPrev = q;\n                uint b = 1 << r;\n                // Token must be unused and owned.\n                require(m & b == 0 && genesisContract.ownerOf(t) == sender, \"Invalid submission.\");\n                // Modifying the map and checking will ensure that there \n                // are no duplicates in _genesisIds.\n                m = m | b;\n            }\n            mintOne(sender);\n        }\n        genesisClaimedMap[qPrev] = m;    \n    }","after":"function genesisClaim(uint[] calldata _genesisIds) public nonReentrant {\n        require(saleState == 3, \"Not open.\");\n        uint n = _genesisIds.length;\n        require(n > 0 && n % 3 == 0, \"Please submit a positive multiple of 3.\");\n        address sender = msg.sender;\n        uint qPrevInitial = 1 << 255;\n        uint qPrev = qPrevInitial;\n        uint m;\n        for (uint i = 0; i < n; i += 3) {\n            for (uint j = 0; j < 3; ++j) {\n                uint t = _genesisIds[i + j];\n                uint q = t >> 8;\n                uint r = t & 255;\n                if (q != qPrev) {\n                    if (qPrev != qPrevInitial) {\n                        genesisClaimedMap[qPrev] = m;\n                    } \n                    m = genesisClaimedMap[q];\n                } \n                qPrev = q;\n                uint b = 1 << r;\n                // Token must be unused and owned.\n                require(m & b == 0 && genesisContract.ownerOf(t) == sender, \"Invalid submission.\");\n                // Modifying the map and checking will ensure that there \n                // are no duplicates in _genesisIds.\n                m = m | b;\n            }\n            mintOne(sender);\n        }\n        genesisClaimedMap[qPrev] = m;    \n    }","contract":"SorasDreamworldLucidDreaming","time":0},{"type":"external-function ","before":"function genesisBurn(uint[] memory _genesisIds) public nonReentrant {\n        require(saleState == 4, \"Not open.\");\n        uint n = _genesisIds.length;\n        require(n > 0 && n & 1 == 0, \"Please submit a positive multiple of 2.\");\n        address sender = msg.sender;\n        for (uint i = 0; i < n; i += 2) {\n            // Transfer from requires that the token must be owned.\n            // Calling it in sequence will ensure that no are no \n            // duplicates in _genesisIds.\n            genesisContract.transferFrom(sender, GENESIS_BURN_ADDRESS, _genesisIds[i]);\n            genesisContract.transferFrom(sender, GENESIS_BURN_ADDRESS, _genesisIds[i + 1]);\n            mintOne(sender);\n        }   \n    }","after":"function genesisBurn(uint[] calldata _genesisIds) public nonReentrant {\n        require(saleState == 4, \"Not open.\");\n        uint n = _genesisIds.length;\n        require(n > 0 && n & 1 == 0, \"Please submit a positive multiple of 2.\");\n        address sender = msg.sender;\n        for (uint i = 0; i < n; i += 2) {\n            // Transfer from requires that the token must be owned.\n            // Calling it in sequence will ensure that no are no \n            // duplicates in _genesisIds.\n            genesisContract.transferFrom(sender, GENESIS_BURN_ADDRESS, _genesisIds[i]);\n            genesisContract.transferFrom(sender, GENESIS_BURN_ADDRESS, _genesisIds[i + 1]);\n            mintOne(sender);\n        }   \n    }","contract":"SorasDreamworldLucidDreaming","time":0},{"type":"external-function ","before":"function changeTokenName(uint _id, string memory _name) public {\n        require(ownerOf(_id) == msg.sender, \"You do not own this token.\");\n        require(sha256(bytes(_name)) != sha256(bytes(tokenNames[_id])), \"Name unchanged.\");\n        tokenNames[_id] = _name;\n        emit TokenNameChanged(msg.sender, _id, _name);\n    }","after":"function changeTokenName(uint _id, string calldata _name) public {\n        require(ownerOf(_id) == msg.sender, \"You do not own this token.\");\n        require(sha256(bytes(_name)) != sha256(bytes(tokenNames[_id])), \"Name unchanged.\");\n        tokenNames[_id] = _name;\n        emit TokenNameChanged(msg.sender, _id, _name);\n    }","contract":"SorasDreamworldLucidDreaming","time":0}]}