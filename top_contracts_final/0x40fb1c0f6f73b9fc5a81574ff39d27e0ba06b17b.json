{"time":168,"results":[{"type":"external-function ","before":"function setTokenURI(string memory _uri) external onlyOwner {\n        _tokenURI = _uri;\n    }","after":"function setTokenURI(string calldata _uri) external onlyOwner {\n        _tokenURI = _uri;\n    }","contract":"Token","time":0},{"type":"external-function ","before":"function setContractURI(string memory _uri) external onlyOwner {\n        _contractURI = _uri;\n    }","after":"function setContractURI(string calldata _uri) external onlyOwner {\n        _contractURI = _uri;\n    }","contract":"Token","time":0},{"type":"external-function ","before":"function addSeries(\n        string[]    memory  _names,\n        string[]    memory  baseURIs,\n        uint256[]   memory  _starts,\n        uint256[]   memory  _supplys\n    ) external onlyOwner {\n        require (_names.length == baseURIs.length, \"len 1 & 2 not equal\");\n        require (_names.length == _starts.length, \"len 1 & 3 not equal\");\n        require (_names.length == _supplys.length, \"len 1 & 4 not equal\");\n        for (uint j = 0; j < _names.length; j++){\n            collections.push(Series(_names[j],baseURIs[j],_starts[j],0, _supplys[j]));\n            emit NewCollection(collections.length-1,_names[j],baseURIs[j],_starts[j],  _supplys[j]);\n        }\n    }","after":"function addSeries(\n        string[]    calldata  _names,\n        string[]    calldata  baseURIs,\n        uint256[]   calldata  _starts,\n        uint256[]   calldata  _supplys\n    ) external onlyOwner {\n        require (_names.length == baseURIs.length, \"len 1 & 2 not equal\");\n        require (_names.length == _starts.length, \"len 1 & 3 not equal\");\n        require (_names.length == _supplys.length, \"len 1 & 4 not equal\");\n        for (uint j = 0; j < _names.length; j++){\n            collections.push(Series(_names[j],baseURIs[j],_starts[j],0, _supplys[j]));\n            emit NewCollection(collections.length-1,_names[j],baseURIs[j],_starts[j],  _supplys[j]);\n        }\n    }","contract":"Token","time":0},{"type":"external-function ","before":"function preMintTo(address _to, uint256[] memory _seriesz) public ownerOrOperator {\n        for (uint j = 0; j < _seriesz.length; j++){\n            uint256 collection = _seriesz[j];\n            require(collection < collections.length, \"Invalid Collection\");\n            uint256 newTokenId = _getNextTokenId(collection);\n            _mint(_to, newTokenId);\n            tokenToSeries[newTokenId] = collection;\n        }\n    }","after":"function preMintTo(address _to, uint256[] calldata _seriesz) public ownerOrOperator {\n        for (uint j = 0; j < _seriesz.length; j++){\n            uint256 collection = _seriesz[j];\n            require(collection < collections.length, \"Invalid Collection\");\n            uint256 newTokenId = _getNextTokenId(collection);\n            _mint(_to, newTokenId);\n            tokenToSeries[newTokenId] = collection;\n        }\n    }","contract":"Token","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"Token","time":0},{"type":"constant-restrict-modification  ","before":"uint256      public       HG2G = 42;","after":"uint256      public       constant HG2G = 42;","contract":"Token","time":1},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"Token","time":1}]}