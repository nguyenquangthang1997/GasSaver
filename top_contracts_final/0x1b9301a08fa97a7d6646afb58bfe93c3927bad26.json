{"time":203,"results":[{"type":"external-function ","before":"function stake( uint256[] memory  tokenIdList) public nonReentrant whenNotPaused {\n\n        require(IERC721(stakeNft).isApprovedForAll(_msgSender(),address(this)),\"Not approve nft to staker address\");\n\n        UserInfo storage user = userInfo[_msgSender()];\n        user.rewards = earned(_msgSender());\n        user.lastUpdated = block.timestamp;\n\n        for (uint256 i = 0; i < tokenIdList.length; i++) {\n            IERC721(stakeNft).safeTransferFrom(_msgSender(), address(this), tokenIdList[i]);\n\n            userBlanaces[_msgSender()].add(tokenIdList[i]);\n\n            emit Staked( _msgSender(), tokenIdList[i]);\n        }\n    }","after":"function stake( uint256[] calldata  tokenIdList) public nonReentrant whenNotPaused {\n\n        require(IERC721(stakeNft).isApprovedForAll(_msgSender(),address(this)),\"Not approve nft to staker address\");\n\n        UserInfo storage user = userInfo[_msgSender()];\n        user.rewards = earned(_msgSender());\n        user.lastUpdated = block.timestamp;\n\n        for (uint256 i = 0; i < tokenIdList.length; i++) {\n            IERC721(stakeNft).safeTransferFrom(_msgSender(), address(this), tokenIdList[i]);\n\n            userBlanaces[_msgSender()].add(tokenIdList[i]);\n\n            emit Staked( _msgSender(), tokenIdList[i]);\n        }\n    }","contract":"BACStaking","time":0},{"type":"external-function ","before":"function withdraw( uint256[] memory  tokenIdList) public nonReentrant {\n        UserInfo storage user = userInfo[_msgSender()];\n        user.rewards = earned(_msgSender());\n        user.lastUpdated = block.timestamp;\n\n        for (uint256 i = 0; i < tokenIdList.length; i++) {\n            require(tokenIdList[i] > 0, \"Invaild token id\");\n\n            require(isStaked(_msgSender(), tokenIdList[i]), \"Not staked this nft\");        \n\n            IERC721(stakeNft).safeTransferFrom(address(this) , _msgSender(), tokenIdList[i]);\n\n            userBlanaces[_msgSender()].remove(tokenIdList[i]);\n\n            emit Withdrawn(_msgSender(), tokenIdList[i]);    \n        }\n    }","after":"function withdraw( uint256[] calldata  tokenIdList) public nonReentrant {\n        UserInfo storage user = userInfo[_msgSender()];\n        user.rewards = earned(_msgSender());\n        user.lastUpdated = block.timestamp;\n\n        for (uint256 i = 0; i < tokenIdList.length; i++) {\n            require(tokenIdList[i] > 0, \"Invaild token id\");\n\n            require(isStaked(_msgSender(), tokenIdList[i]), \"Not staked this nft\");        \n\n            IERC721(stakeNft).safeTransferFrom(address(this) , _msgSender(), tokenIdList[i]);\n\n            userBlanaces[_msgSender()].remove(tokenIdList[i]);\n\n            emit Withdrawn(_msgSender(), tokenIdList[i]);    \n        }\n    }","contract":"BACStaking","time":0},{"type":"external-function ","before":"function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }","after":"function onERC721Received(address, address, uint256, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }","contract":"BACStaking","time":0},{"type":"immutable-restrict-modification ","before":"address public stakeNft;","after":"address public immutable stakeNft;","contract":"BACStaking","time":1}]}