{"time":249,"results":[{"type":"state-data-arrangement ","before":"\nuint256 public constant PROMO_CREATION_LIMIT = 5200;\nuint256 public constant GEN0_EGG_CREATION_LIMIT = 44800;\nuint256 public promoCreatedCount;\nuint256 public gen0CreatedCount;\nbool public allowMinting = false;\nbool public requireMintPass = false;\nuint public requiredHoldings = 0;\nuint256 public gen0PromoPrice = 0 wei;\nuint256 public currentGen0Cap = 100;\nuint public mintEventStarted = block.timestamp;\nuint public currentMintLimit = 0;\nmapping (address => uint) tokensAllowed;\nmapping (address => uint) lastMintParticipated;\nmapping (address => uint) tokensMintedThisPeriod;\nuint8 public currentPromoGene = 0;\nbool public currentPromoActive = false;","after":"uint256 public constant PROMO_CREATION_LIMIT = 5200;\nuint256 public constant GEN0_EGG_CREATION_LIMIT = 44800;\nuint256 public promoCreatedCount;\nuint256 public gen0CreatedCount;\nuint public requiredHoldings = 0;\nuint256 public gen0PromoPrice = 0 wei;\nuint256 public currentGen0Cap = 100;\nuint public mintEventStarted = block.timestamp;\nuint public currentMintLimit = 0;\nmapping (address => uint) tokensAllowed;\nmapping (address => uint) lastMintParticipated;\nmapping (address => uint) tokensMintedThisPeriod;\nbool public allowMinting = false;\nbool public requireMintPass = false;\nuint8 public currentPromoGene = 0;\nbool public currentPromoActive = false;\n","contract":"BitKoiMinting","time":1},{"type":"external-function ","before":"function setBaseTokenURI(string memory _newBaseURI) public onlyCLevel {\n        baseURI = _newBaseURI;\n    }","after":"function setBaseTokenURI(string calldata _newBaseURI) public onlyCLevel {\n        baseURI = _newBaseURI;\n    }","contract":"BitKoiCore","time":0},{"type":"external-function ","before":"function setContractURI(string memory _newContractURI) public onlyCLevel {\n        contractMainURI = _newContractURI;\n    }","after":"function setContractURI(string calldata _newContractURI) public onlyCLevel {\n        contractMainURI = _newContractURI;\n    }","contract":"BitKoiCore","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"BitKoiCore","time":0},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"BitKoiCore","time":1},{"type":"constant-restrict-modification  ","before":"uint256 private _currentTokenId = 0;","after":"uint256 private constant _currentTokenId = 0;","contract":"BitKoiCore","time":1}]}