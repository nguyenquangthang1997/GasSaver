{"time":60,"results":[{"type":"external-function ","before":"function submitValue(\n        bytes32 _queryId,\n        bytes calldata _value,\n        uint256 _nonce,\n        bytes memory _queryData\n    ) external {\n        Report storage rep = reports[_queryId];\n        require(\n            _nonce == rep.timestamps.length,\n            \"nonce must match timestamp index\"\n        );\n        // Require reporter to abide by given reporting lock\n        require(\n            block.timestamp - reporterLastTimestamp[msg.sender] > reportingLock,\n            \"still in reporter time lock, please wait!\"\n        );\n        require(\n            address(this) ==\n                IController(TELLOR_ADDRESS).addresses(_ORACLE_CONTRACT),\n            \"can only submit to current oracle contract\"\n        );\n        require(\n            _queryId == keccak256(_queryData) || uint256(_queryId) <= 100,\n            \"id must be hash of bytes data\"\n        );\n        reporterLastTimestamp[msg.sender] = block.timestamp;\n        IController _tellor = IController(TELLOR_ADDRESS);\n        // Checks that reporter is not already staking TRB\n        (uint256 _status, ) = _tellor.getStakerInfo(msg.sender);\n        require(_status == 1, \"Reporter status is not staker\");\n        // Check is in case the stake amount increases\n        require(\n            _tellor.balanceOf(msg.sender) >= _tellor.uints(_STAKE_AMOUNT),\n            \"balance must be greater than stake amount\"\n        );\n        // Checks for no double reporting of timestamps\n        require(\n            rep.reporterByTimestamp[block.timestamp] == address(0),\n            \"timestamp already reported for\"\n        );\n        // Update number of timestamps, value for given timestamp, and reporter for timestamp\n        rep.timestampIndex[block.timestamp] = rep.timestamps.length;\n        rep.timestamps.push(block.timestamp);\n        rep.timestampToBlockNum[block.timestamp] = block.number;\n        rep.valueByTimestamp[block.timestamp] = _value;\n        rep.reporterByTimestamp[block.timestamp] = msg.sender;\n        // Send tips + timeBasedReward to reporter of value, and reset tips for ID\n        (uint256 _tip, uint256 _reward) = getCurrentReward(_queryId);\n        tipsInContract -= _tip;\n        if (_reward + _tip > 0) {\n            _tellor.transfer(msg.sender, _reward + _tip);\n        }\n        tips[_queryId] = 0;\n        // Update last oracle value and number of values submitted by a reporter\n        timeOfLastNewValue = block.timestamp;\n        reportsSubmittedByAddress[msg.sender]++;\n        emit NewReport(\n            _queryId,\n            block.timestamp,\n            _value,\n            _tip + _reward,\n            _nonce,\n            _queryData,\n            msg.sender\n        );\n    }","after":"function submitValue(\n        bytes32 _queryId,\n        bytes calldata _value,\n        uint256 _nonce,\n        bytes calldata _queryData\n    ) external {\n        Report storage rep = reports[_queryId];\n        require(\n            _nonce == rep.timestamps.length,\n            \"nonce must match timestamp index\"\n        );\n        // Require reporter to abide by given reporting lock\n        require(\n            block.timestamp - reporterLastTimestamp[msg.sender] > reportingLock,\n            \"still in reporter time lock, please wait!\"\n        );\n        require(\n            address(this) ==\n                IController(TELLOR_ADDRESS).addresses(_ORACLE_CONTRACT),\n            \"can only submit to current oracle contract\"\n        );\n        require(\n            _queryId == keccak256(_queryData) || uint256(_queryId) <= 100,\n            \"id must be hash of bytes data\"\n        );\n        reporterLastTimestamp[msg.sender] = block.timestamp;\n        IController _tellor = IController(TELLOR_ADDRESS);\n        // Checks that reporter is not already staking TRB\n        (uint256 _status, ) = _tellor.getStakerInfo(msg.sender);\n        require(_status == 1, \"Reporter status is not staker\");\n        // Check is in case the stake amount increases\n        require(\n            _tellor.balanceOf(msg.sender) >= _tellor.uints(_STAKE_AMOUNT),\n            \"balance must be greater than stake amount\"\n        );\n        // Checks for no double reporting of timestamps\n        require(\n            rep.reporterByTimestamp[block.timestamp] == address(0),\n            \"timestamp already reported for\"\n        );\n        // Update number of timestamps, value for given timestamp, and reporter for timestamp\n        rep.timestampIndex[block.timestamp] = rep.timestamps.length;\n        rep.timestamps.push(block.timestamp);\n        rep.timestampToBlockNum[block.timestamp] = block.number;\n        rep.valueByTimestamp[block.timestamp] = _value;\n        rep.reporterByTimestamp[block.timestamp] = msg.sender;\n        // Send tips + timeBasedReward to reporter of value, and reset tips for ID\n        (uint256 _tip, uint256 _reward) = getCurrentReward(_queryId);\n        tipsInContract -= _tip;\n        if (_reward + _tip > 0) {\n            _tellor.transfer(msg.sender, _reward + _tip);\n        }\n        tips[_queryId] = 0;\n        // Update last oracle value and number of values submitted by a reporter\n        timeOfLastNewValue = block.timestamp;\n        reportsSubmittedByAddress[msg.sender]++;\n        emit NewReport(\n            _queryId,\n            block.timestamp,\n            _value,\n            _tip + _reward,\n            _nonce,\n            _queryData,\n            msg.sender\n        );\n    }","contract":"Oracle","time":0},{"type":"external-function ","before":"function tipQuery(\n        bytes32 _queryId,\n        uint256 _tip,\n        bytes memory _queryData\n    ) external {\n        // Require tip to be greater than 1 and be paid\n        require(_tip > 1, \"Tip should be greater than 1\");\n        require(\n            IController(TELLOR_ADDRESS).approveAndTransferFrom(\n                msg.sender,\n                address(this),\n                _tip\n            ),\n            \"tip must be paid\"\n        );\n        require(\n            _queryId == keccak256(_queryData) ||\n                uint256(_queryId) <= 100 ||\n                msg.sender ==\n                IController(TELLOR_ADDRESS).addresses(_GOVERNANCE_CONTRACT),\n            \"id must be hash of bytes data\"\n        );\n        // Burn half the tip\n        _tip = _tip / 2;\n        IController(TELLOR_ADDRESS).burn(_tip);\n        // Update total tip amount for user, data ID, and in total contract\n        tips[_queryId] += _tip;\n        tipsByUser[msg.sender] += _tip;\n        tipsInContract += _tip;\n        emit TipAdded(msg.sender, _queryId, _tip, tips[_queryId], _queryData);\n    }","after":"function tipQuery(\n        bytes32 _queryId,\n        uint256 _tip,\n        bytes calldata _queryData\n    ) external {\n        // Require tip to be greater than 1 and be paid\n        require(_tip > 1, \"Tip should be greater than 1\");\n        require(\n            IController(TELLOR_ADDRESS).approveAndTransferFrom(\n                msg.sender,\n                address(this),\n                _tip\n            ),\n            \"tip must be paid\"\n        );\n        require(\n            _queryId == keccak256(_queryData) ||\n                uint256(_queryId) <= 100 ||\n                msg.sender ==\n                IController(TELLOR_ADDRESS).addresses(_GOVERNANCE_CONTRACT),\n            \"id must be hash of bytes data\"\n        );\n        // Burn half the tip\n        _tip = _tip / 2;\n        IController(TELLOR_ADDRESS).burn(_tip);\n        // Update total tip amount for user, data ID, and in total contract\n        tips[_queryId] += _tip;\n        tipsByUser[msg.sender] += _tip;\n        tipsInContract += _tip;\n        emit TipAdded(msg.sender, _queryId, _tip, tips[_queryId], _queryData);\n    }","contract":"Oracle","time":0}]}