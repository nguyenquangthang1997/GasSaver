{"time":57,"results":[{"type":"external-function ","before":"function depositWithExpiry(address payable vault, address asset, uint amount, string memory memo, uint expiration) external payable {\n        require(block.timestamp < expiration, \"THORChain_Router: expired\");\n        deposit(vault, asset, amount, memo);\n    }","after":"function depositWithExpiry(address payable vault, address asset, uint amount, string calldata memo, uint expiration) external payable {\n        require(block.timestamp < expiration, \"THORChain_Router: expired\");\n        deposit(vault, asset, amount, memo);\n    }","contract":"THORChain_Router","time":0},{"type":"external-function ","before":"function transferAllowance(address router, address newVault, address asset, uint amount, string memory memo) external nonReentrant {\n        if (router == address(this)){\n            _adjustAllowances(newVault, asset, amount);\n            emit TransferAllowance(msg.sender, newVault, asset, amount, memo);\n        } else {\n            _routerDeposit(router, newVault, asset, amount, memo);\n        }\n    }","after":"function transferAllowance(address router, address newVault, address asset, uint amount, string calldata memo) external nonReentrant {\n        if (router == address(this)){\n            _adjustAllowances(newVault, asset, amount);\n            emit TransferAllowance(msg.sender, newVault, asset, amount, memo);\n        } else {\n            _routerDeposit(router, newVault, asset, amount, memo);\n        }\n    }","contract":"THORChain_Router","time":0},{"type":"external-function ","before":"function transferOut(address payable to, address asset, uint amount, string memory memo) public payable nonReentrant {\n    uint safeAmount;\n    if(asset == address(0)){\n        safeAmount = msg.value;\n        bool success = to.send(safeAmount); // Send ETH. \n        if (!success) {\n            payable(address(msg.sender)).transfer(safeAmount); //For failure, bounce back to Yggdrasil & continue.\n        }\n    } else {\n        _vaultAllowance[msg.sender][asset] -= amount; // Reduce allowance\n        (bool success, bytes memory data) = asset.call(abi.encodeWithSignature(\"transfer(address,uint256)\" , to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n        safeAmount = amount;\n    }\n    emit TransferOut(msg.sender, to, asset, safeAmount, memo);\n}","after":"function transferOut(address payable to, address asset, uint amount, string calldata memo) public payable nonReentrant {\n    uint safeAmount;\n    if(asset == address(0)){\n        safeAmount = msg.value;\n        bool success = to.send(safeAmount); // Send ETH. \n        if (!success) {\n            payable(address(msg.sender)).transfer(safeAmount); //For failure, bounce back to Yggdrasil & continue.\n        }\n    } else {\n        _vaultAllowance[msg.sender][asset] -= amount; // Reduce allowance\n        (bool success, bytes memory data) = asset.call(abi.encodeWithSignature(\"transfer(address,uint256)\" , to, amount));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n        safeAmount = amount;\n    }\n    emit TransferOut(msg.sender, to, asset, safeAmount, memo);\n}","contract":"THORChain_Router","time":0},{"type":"external-function ","before":"function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable nonReentrant {\n        if (router == address(this)){\n            for(uint i = 0; i < coins.length; i++){\n                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n            }\n            emit VaultTransfer(msg.sender, asgard, coins, memo); // Does not include ETH.           \n        } else {\n            for(uint i = 0; i < coins.length; i++){\n                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n            }\n        }\n        bool success = asgard.send(msg.value);\n        require(success);\n    }","after":"function returnVaultAssets(address router, address payable asgard, Coin[] calldata coins, string calldata memo) external payable nonReentrant {\n        if (router == address(this)){\n            for(uint i = 0; i < coins.length; i++){\n                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n            }\n            emit VaultTransfer(msg.sender, asgard, coins, memo); // Does not include ETH.           \n        } else {\n            for(uint i = 0; i < coins.length; i++){\n                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n            }\n        }\n        bool success = asgard.send(msg.value);\n        require(success);\n    }","contract":"THORChain_Router","time":0},{"type":"immutable-restrict-modification ","before":"address public RUNE;","after":"address public immutable RUNE;","contract":"THORChain_Router","time":0}]}