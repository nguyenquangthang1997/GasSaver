{"time":171,"results":[{"type":"state-data-arrangement ","before":"\nuint256 private price = 0.06 ether;\nuint16 constant MAX_TOTAL_SUPPLY = 4999;\nuint16 internal currentID = 0;\nuint16[MAX_TOTAL_SUPPLY] internal indices;\nbytes4 private constant INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\nbytes4 private constant INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\nbytes4 private constant INTERFACE_SIGNATURE_URI = 0x0e89341c;\nbool public presaleActive = false;\nbool public saleActive = false;\nstring internal constant NAME = \"Robotars\";\nstring internal constant SYMBOL = \"Robotars\";\nstring internal constant _CONTRACT = \"ERC1155\";\nstring private URI_BASE =\n        \"https://robotars.s3.us-west-1.amazonaws.com/metadata/robotars-metadata-\";\nmapping(address => uint16) public presaleWhitelist;","after":"uint256 private price = 0.06 ether;\nuint16[MAX_TOTAL_SUPPLY] internal indices;\nstring internal constant NAME = \"Robotars\";\nstring internal constant SYMBOL = \"Robotars\";\nstring internal constant _CONTRACT = \"ERC1155\";\nstring private URI_BASE =\n        \"https://robotars.s3.us-west-1.amazonaws.com/metadata/robotars-metadata-\";\nmapping(address => uint16) public presaleWhitelist;\nbytes4 private constant INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\nbytes4 private constant INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\nbytes4 private constant INTERFACE_SIGNATURE_URI = 0x0e89341c;\nuint16 constant MAX_TOTAL_SUPPLY = 4999;\nuint16 internal currentID = 0;\nbool public presaleActive = false;\nbool public saleActive = false;\n","contract":"Robotars","time":2},{"type":"external-function ","before":"function setBaseUri(string memory _uri) public onlyOwner {\n         URI_BASE = _uri;\n    }","after":"function setBaseUri(string calldata _uri) public onlyOwner {\n         URI_BASE = _uri;\n    }","contract":"Robotars","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"Robotars","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"Robotars","time":0},{"type":"external-function ","before":"function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","after":"function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","contract":"Robotars","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","after":"function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] calldata,\n        uint256[] calldata,\n        bytes calldata\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","contract":"Robotars","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"Robotars","time":0}]}