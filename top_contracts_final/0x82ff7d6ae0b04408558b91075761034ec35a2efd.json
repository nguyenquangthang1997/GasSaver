{"time":147,"results":[{"type":"external-function ","before":"function mint(uint256 _mintAmount, bytes memory _signature) external payable {\r\n    require(!paused, \"Minting is not active\");\r\n    uint256 supply = totalSupply();\r\n    require(_mintAmount > 0, \"At least one NFT needs to be minted\");\r\n    require(_mintAmount <= maxMintAmount, \"Max mint amount exceeded\");\r\n    require(supply + _mintAmount + reserveAmount - amountReserved <= maxSupply, \"Max Supply exceeded\");\r\n    require(numberOfMints[msg.sender] + _mintAmount <= maxNftPerAddress, \"Max mint per wallet exceeded\");\r\n    require(verifySigner(msg.sender, _signature) == _signerAddress, \"Direct mint is not allowed\");\r\n    if (msg.sender != owner()) {\r\n      uint256 ownerTokenCount = balanceOf(msg.sender);\r\n      require(ownerTokenCount <= maxNftPerAddress - _mintAmount, \"Max NFT per address exceeded\");\r\n      require(msg.value >= cost * _mintAmount, \"Insufficient funds\");\r\n    }\r\n\r\n    for (uint256 i = 0; i < _mintAmount; i++) {\r\n      numberOfMints[msg.sender]++;\r\n      _safeMint(msg.sender, supply + i);\r\n    }\r\n  }","after":"function mint(uint256 _mintAmount, bytes calldata _signature) external payable {\r\n    require(!paused, \"Minting is not active\");\r\n    uint256 supply = totalSupply();\r\n    require(_mintAmount > 0, \"At least one NFT needs to be minted\");\r\n    require(_mintAmount <= maxMintAmount, \"Max mint amount exceeded\");\r\n    require(supply + _mintAmount + reserveAmount - amountReserved <= maxSupply, \"Max Supply exceeded\");\r\n    require(numberOfMints[msg.sender] + _mintAmount <= maxNftPerAddress, \"Max mint per wallet exceeded\");\r\n    require(verifySigner(msg.sender, _signature) == _signerAddress, \"Direct mint is not allowed\");\r\n    if (msg.sender != owner()) {\r\n      uint256 ownerTokenCount = balanceOf(msg.sender);\r\n      require(ownerTokenCount <= maxNftPerAddress - _mintAmount, \"Max NFT per address exceeded\");\r\n      require(msg.value >= cost * _mintAmount, \"Insufficient funds\");\r\n    }\r\n\r\n    for (uint256 i = 0; i < _mintAmount; i++) {\r\n      numberOfMints[msg.sender]++;\r\n      _safeMint(msg.sender, supply + i);\r\n    }\r\n  }","contract":"SmartContract","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public maxSupply = 10000;","after":"uint256 public constant maxSupply = 10000;","contract":"SmartContract","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public reserveAmount = 30;","after":"uint256 public constant reserveAmount = 30;","contract":"SmartContract","time":1},{"type":"constant-restrict-modification  ","before":"address private _advisorAddress = 0x5F058DCcffB7862566aBe44F85d409823F5ce921;","after":"address private constant _advisorAddress = 0x5F058DCcffB7862566aBe44F85d409823F5ce921;","contract":"SmartContract","time":1}]}