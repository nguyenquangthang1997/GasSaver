{"time":252,"results":[{"type":"external-function ","before":"function callExecute(address _owner, address _compoundSaverProxy, bytes memory _data) public payable onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute{value: msg.value}(_compoundSaverProxy, _data);\n\n        // return if anything left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }","after":"function callExecute(address _owner, address _compoundSaverProxy, bytes calldata _data) public payable onlyMonitor {\n        // execute reverts if calling specific method fails\n        DSProxyInterface(_owner).execute{value: msg.value}(_compoundSaverProxy, _data);\n\n        // return if anything left\n        if (address(this).balance > 0) {\n            msg.sender.transfer(address(this).balance);\n        }\n    }","contract":"CompoundMonitorProxy","time":0},{"type":"struct-data-arrangement ","before":"\naddress user\nuint128 minRatio\nuint128 maxRatio\nuint128 optimalRatioBoost\nuint128 optimalRatioRepay\nbool boostEnabled","after":"address user\nuint128 minRatio\nuint128 maxRatio\nuint128 optimalRatioBoost\nuint128 optimalRatioRepay\nbool boostEnabled\n","contract":"CompoundSubscriptions","time":0},{"type":"external-function ","before":"function Log(address _contract, address _caller, string memory _logName, bytes memory _data)\n        public\n    {\n        emit LogEvent(_contract, _caller, _logName, _data);\n    }","after":"function Log(address _contract, address _caller, string calldata _logName, bytes calldata _data)\n        public\n    {\n        emit LogEvent(_contract, _caller, _logName, _data);\n    }","contract":"DefisaverLogger","time":0},{"type":"external-function ","before":"function repayFor(\n        DFSExchangeData.ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        address _user,\n        FLHelper.FLType _flType\n    ) public payable onlyApproved {\n        bool isAllowed;\n        uint256 ratioBefore;\n        string memory errReason;\n\n        CompoundSubscriptions.CompoundHolder memory holder = subscriptionsContract.getHolder(_user);\n\n        (isAllowed, ratioBefore, errReason) = checkPreconditions(holder, Method.Repay, _user);\n        require(isAllowed, errReason); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(REPAY_GAS_COST);\n\n        compoundMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            compoundFlashLoanTakerAddress,\n            abi.encodeWithSignature(\n                \"repayWithLoan((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),address[2],uint256,uint8,address)\",\n                _exData,\n                _cAddresses,\n                gasCost,\n                _flType,\n                compoundSaverFlashLoan\n            )\n        );\n\n        bool isGoodRatio;\n        uint256 ratioAfter;\n\n        (isGoodRatio, ratioAfter, errReason) = ratioGoodAfter(\n            holder,\n            Method.Repay,\n            _user,\n            ratioBefore\n        );\n        require(isGoodRatio, errReason); // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(\n            address(this),\n            _user,\n            \"AutomaticCompoundRepay\",\n            abi.encode(ratioBefore, ratioAfter)\n        );\n    }","after":"function repayFor(\n        DFSExchangeData.ExchangeData calldata _exData,\n        address[2] calldata _cAddresses, // cCollAddress, cBorrowAddress\n        address _user,\n        FLHelper.FLType _flType\n    ) public payable onlyApproved {\n        bool isAllowed;\n        uint256 ratioBefore;\n        string memory errReason;\n\n        CompoundSubscriptions.CompoundHolder memory holder = subscriptionsContract.getHolder(_user);\n\n        (isAllowed, ratioBefore, errReason) = checkPreconditions(holder, Method.Repay, _user);\n        require(isAllowed, errReason); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(REPAY_GAS_COST);\n\n        compoundMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            compoundFlashLoanTakerAddress,\n            abi.encodeWithSignature(\n                \"repayWithLoan((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),address[2],uint256,uint8,address)\",\n                _exData,\n                _cAddresses,\n                gasCost,\n                _flType,\n                compoundSaverFlashLoan\n            )\n        );\n\n        bool isGoodRatio;\n        uint256 ratioAfter;\n\n        (isGoodRatio, ratioAfter, errReason) = ratioGoodAfter(\n            holder,\n            Method.Repay,\n            _user,\n            ratioBefore\n        );\n        require(isGoodRatio, errReason); // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(\n            address(this),\n            _user,\n            \"AutomaticCompoundRepay\",\n            abi.encode(ratioBefore, ratioAfter)\n        );\n    }","contract":"CompoundMonitor","time":0},{"type":"external-function ","before":"function boostFor(\n        DFSExchangeData.ExchangeData memory _exData,\n        address[2] memory _cAddresses, // cCollAddress, cBorrowAddress\n        address _user,\n        FLHelper.FLType _flType\n    ) public payable onlyApproved {\n        string memory errReason;\n        bool isAllowed;\n        uint256 ratioBefore;\n\n        CompoundSubscriptions.CompoundHolder memory holder = subscriptionsContract.getHolder(_user);\n\n        (isAllowed, ratioBefore, errReason) = checkPreconditions(holder, Method.Boost, _user);\n        require(isAllowed, errReason); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(BOOST_GAS_COST);\n\n        compoundMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            compoundFlashLoanTakerAddress,\n            abi.encodeWithSignature(\n                \"boostWithLoan((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),address[2],uint256,uint8,address)\",\n                _exData,\n                _cAddresses,\n                gasCost,\n                _flType,\n                compoundSaverFlashLoan\n            )\n        );\n\n        bool isGoodRatio;\n        uint256 ratioAfter;\n\n        (isGoodRatio, ratioAfter, errReason) = ratioGoodAfter(\n            holder,\n            Method.Boost,\n            _user,\n            ratioBefore\n        );\n        require(isGoodRatio, errReason); // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(\n            address(this),\n            _user,\n            \"AutomaticCompoundBoost\",\n            abi.encode(ratioBefore, ratioAfter)\n        );\n    }","after":"function boostFor(\n        DFSExchangeData.ExchangeData calldata _exData,\n        address[2] calldata _cAddresses, // cCollAddress, cBorrowAddress\n        address _user,\n        FLHelper.FLType _flType\n    ) public payable onlyApproved {\n        string memory errReason;\n        bool isAllowed;\n        uint256 ratioBefore;\n\n        CompoundSubscriptions.CompoundHolder memory holder = subscriptionsContract.getHolder(_user);\n\n        (isAllowed, ratioBefore, errReason) = checkPreconditions(holder, Method.Boost, _user);\n        require(isAllowed, errReason); // check if conditions are met\n\n        uint256 gasCost = calcGasCost(BOOST_GAS_COST);\n\n        compoundMonitorProxy.callExecute{value: msg.value}(\n            _user,\n            compoundFlashLoanTakerAddress,\n            abi.encodeWithSignature(\n                \"boostWithLoan((address,address,uint256,uint256,uint256,uint256,address,address,bytes,(address,address,address,uint256,uint256,bytes)),address[2],uint256,uint8,address)\",\n                _exData,\n                _cAddresses,\n                gasCost,\n                _flType,\n                compoundSaverFlashLoan\n            )\n        );\n\n        bool isGoodRatio;\n        uint256 ratioAfter;\n\n        (isGoodRatio, ratioAfter, errReason) = ratioGoodAfter(\n            holder,\n            Method.Boost,\n            _user,\n            ratioBefore\n        );\n        require(isGoodRatio, errReason); // check if the after result of the actions is good\n\n        returnEth();\n\n        logger.Log(\n            address(this),\n            _user,\n            \"AutomaticCompoundBoost\",\n            abi.encode(ratioBefore, ratioAfter)\n        );\n    }","contract":"CompoundMonitor","time":0}]}