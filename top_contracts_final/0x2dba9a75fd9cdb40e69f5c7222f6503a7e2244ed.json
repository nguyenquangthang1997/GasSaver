{"time":184,"results":[{"type":"state-data-arrangement ","before":"\n/contracts/token/ERC721/extensions/ERC7\nmerable.sol\";\nimport \"@openzeppelin/contra\nccess/Ownable.sol\";\nimport \"@openzeppelin/contracts/util\nptography/ECDSA.sol\";\n\n\ncontract PBCNFT is ERC7\nmerable, Ownable {\n    using Strings for \n   using ECDSA for bytes32;\n\n    uint256 pub\nnt PBC_GIFT = 499;\n    uint2\nblic constant PBC_PUBLIC = 9500;\n    uint256 public constant P\nX = PBC_PUBLIC + PBC_GIFT;\n    uint256 public constant PBC_PRICE = 0.08 ethe\n uint256 public cons\nPBC_PER_MINT = 5;\n    \n    m\ng(string => bool) private _usedNon\n    \n    string priva\nontractURI;\n    str","after":"/contracts/token/ERC721/extensions/ERC7\nmerable.sol\";\nimport \"@openzeppelin/contra\nccess/Ownable.sol\";\nimport \"@openzeppelin/contracts/util\nptography/ECDSA.sol\";\n\n\ncontract PBCNFT is ERC7\nmerable, Ownable {\n    using Strings for \n   using ECDSA for bytes32;\n\n    uint256 pub\nnt PBC_GIFT = 499;\n    uint2\nblic constant PBC_PUBLIC = 9500;\n    uint256 public constant P\n uint256 public cons\nPBC_PER_MINT = 5;\n    \n    m\ng(string => bool) private _usedNon\nX = PBC_PUBLIC + PBC_GIFT;\n    uint256 public constant PBC_PRICE = 0.08 ethe\n    \n    string priva\nontractURI;\n    str\n","contract":"PBCNFT","time":0},{"type":"external-function ","before":"          keccak256(abi.encodePacked(sender, qty, nonce)))\n          );\n          \n          return hash;\n    }\n    \n    function matchAddresSigner(bytes32 hash, bytes memory signature) private view returns(bool) {\n        return _signerAddress == hash.recover(signature);\n    }\n    \n    function buy(bytes32 hash, bytes memory signature, string memory nonce, uint256 tokenQuantity) external payable {\n        require(saleLive, \"SALE_CLOSED\");\n        require(matchAddresSigner(hash, signature), \"DIRECT_MINT_DISALLOWED\");\n        require(!_usedNonces[nonce], \"HASH_USED\");\n        require(hashTransaction(msg.sender, tokenQuantity, nonce) == hash, \"HASH_FAIL\");\n        require(totalSupply() < PBC_MAX, \"OUT_OF_STOCK\");\n        require(publicAmountMinted + tokenQuantity <= PBC_PUBLIC, \"EXCEED_PUBLIC\");\n        require(tokenQuantity <= PBC_PER_MINT, \"EXCEED_PBC_PER_MINT\")","after":"          keccak256(abi.encodePacked(sender, qty, nonce)))\n          );\n          \n          return hash;\n    }\n    \n    function matchAddresSigner(bytes32 hash, bytes memory signature) private view returns(bool) {\n        return _signerAddress == hash.recover(signature);\n    }\n    \n    function buy(bytes32 hash, bytes memory signature, string memory nonce, uint256 tokenQuantity) external payable {\n        require(saleLive, \"SALE_CLOSED\");\n        require(matchAddresSigner(hash, signature), \"DIRECT_MINT_DISALLOWED\");\n        require(!_usedNonces[nonce], \"HASH_USED\");\n        require(hashTransaction(msg.sender, tokenQuantity, nonce) == hash, \"HASH_FAIL\");\n        require(totalSupply() < PBC_MAX, \"OUT_OF_STOCK\");\n        require(publicAmountMinted + tokenQuantity <= PBC_PUBLIC, \"EXCEED_PUBLIC\");\n        require(tokenQuantity <= PBC_PER_MINT, \"EXCEED_PBC_PER_MINT\")","contract":"PBCNFT","time":0}]}