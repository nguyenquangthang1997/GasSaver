{"time":146,"results":[{"type":"state-data-arrangement ","before":"\nbool public earlyMintIsActive = false;\nbool public mintIsActive = false;\nuint256 public freeMintCount = 0;\nuint256 public earlyMintCount = 0;\nuint256 constant public MAX_SUPPLY = 1111;\nuint256 constant public FREE_MINT_SUPPLY = 111;\nuint256 constant public EARLY_MINT_SUPPLY = 500;\nuint256 constant public BRUSHSTROKES_PRICE = 0.05 ether;\nmapping(bytes32 => bool) private usedHashes;\nmapping(address => uint256) private walletMintNumber;\nmapping(uint256 => bytes32) public tokenIdToHash;\nstring public script;\nstring private _tokenBaseURI;\naddress private _signatureVerifier = 0x805c057A31B31c84F7759698298aD4dC6F8fA622;","after":"uint256 public freeMintCount = 0;\nuint256 public earlyMintCount = 0;\nuint256 constant public MAX_SUPPLY = 1111;\nuint256 constant public FREE_MINT_SUPPLY = 111;\nuint256 constant public EARLY_MINT_SUPPLY = 500;\nuint256 constant public BRUSHSTROKES_PRICE = 0.05 ether;\nmapping(bytes32 => bool) private usedHashes;\nmapping(address => uint256) private walletMintNumber;\nmapping(uint256 => bytes32) public tokenIdToHash;\nstring public script;\nstring private _tokenBaseURI;\naddress private _signatureVerifier = 0x805c057A31B31c84F7759698298aD4dC6F8fA622;\nbool public earlyMintIsActive = false;\nbool public mintIsActive = false;\n","contract":"BrushStrokes","time":0},{"type":"external-function ","before":"function setScript(string memory genScript) public onlyOwner {\n        script = genScript;\n    }","after":"function setScript(string calldata genScript) public onlyOwner {\n        script = genScript;\n    }","contract":"BrushStrokes","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseURI_) external onlyOwner {\n        _tokenBaseURI = baseURI_;\n    }","after":"function setBaseURI(string calldata baseURI_) external onlyOwner {\n        _tokenBaseURI = baseURI_;\n    }","contract":"BrushStrokes","time":0},{"type":"external-function ","before":"function earlyMint(bytes memory signature, uint256 nonce) public payable {\n        require(earlyMintIsActive, \"Early minting is not active at the moment\");\n        require(totalSupply() + 1 <= MAX_SUPPLY, \"Purchase would exceed max supply\");\n        require(earlyMintCount + 1 <= EARLY_MINT_SUPPLY, \"Early mint is over\");\n        require(walletMintNumber[msg.sender] + 1 <= 1, \"Mint would exceed max mint for wallet during early mint\");\n        require(BRUSHSTROKES_PRICE == msg.value, \"Sent ether value is incorrect\");\n\n        bytes32 messageHash = hashMessage(msg.sender, nonce);\n        require(messageHash.recover(signature) == _signatureVerifier, \"Unrecognizable Hash\");\n        require(!usedHashes[messageHash], \"Reused Hash\");\n        usedHashes[messageHash] = true;\n\n        walletMintNumber[msg.sender] += 1;\n        earlyMintCount += 1;\n        setTokenIdToHash(totalSupply() + 1);\n        _safeMint(msg.sender, totalSupply() + 1);\n    }","after":"function earlyMint(bytes calldata signature, uint256 nonce) public payable {\n        require(earlyMintIsActive, \"Early minting is not active at the moment\");\n        require(totalSupply() + 1 <= MAX_SUPPLY, \"Purchase would exceed max supply\");\n        require(earlyMintCount + 1 <= EARLY_MINT_SUPPLY, \"Early mint is over\");\n        require(walletMintNumber[msg.sender] + 1 <= 1, \"Mint would exceed max mint for wallet during early mint\");\n        require(BRUSHSTROKES_PRICE == msg.value, \"Sent ether value is incorrect\");\n\n        bytes32 messageHash = hashMessage(msg.sender, nonce);\n        require(messageHash.recover(signature) == _signatureVerifier, \"Unrecognizable Hash\");\n        require(!usedHashes[messageHash], \"Reused Hash\");\n        usedHashes[messageHash] = true;\n\n        walletMintNumber[msg.sender] += 1;\n        earlyMintCount += 1;\n        setTokenIdToHash(totalSupply() + 1);\n        _safeMint(msg.sender, totalSupply() + 1);\n    }","contract":"BrushStrokes","time":0},{"type":"external-function ","before":"function freeMint(bytes memory signature, uint256 nonce) public {\n        require(mintIsActive, \"Minting is not active at the moment\");\n        require(totalSupply() + 1 <= MAX_SUPPLY, \"Purchase would exceed max supply\");\n        require(freeMintCount + 1 <= FREE_MINT_SUPPLY, \"Free mint is over\");\n        require(walletMintNumber[msg.sender] + 1 <= 3, \"Mint would exceed max mint for wallet\");\n\n        bytes32 messageHash = hashMessage(msg.sender, nonce);\n        require(messageHash.recover(signature) == _signatureVerifier, \"Unrecognizable Hash\");\n        require(!usedHashes[messageHash], \"Reused Hash\");\n        usedHashes[messageHash] = true;\n\n        walletMintNumber[msg.sender] += 1;\n        freeMintCount += 1;\n        setTokenIdToHash(totalSupply() + 1);\n        _safeMint(msg.sender, totalSupply() + 1);\n    }","after":"function freeMint(bytes calldata signature, uint256 nonce) public {\n        require(mintIsActive, \"Minting is not active at the moment\");\n        require(totalSupply() + 1 <= MAX_SUPPLY, \"Purchase would exceed max supply\");\n        require(freeMintCount + 1 <= FREE_MINT_SUPPLY, \"Free mint is over\");\n        require(walletMintNumber[msg.sender] + 1 <= 3, \"Mint would exceed max mint for wallet\");\n\n        bytes32 messageHash = hashMessage(msg.sender, nonce);\n        require(messageHash.recover(signature) == _signatureVerifier, \"Unrecognizable Hash\");\n        require(!usedHashes[messageHash], \"Reused Hash\");\n        usedHashes[messageHash] = true;\n\n        walletMintNumber[msg.sender] += 1;\n        freeMintCount += 1;\n        setTokenIdToHash(totalSupply() + 1);\n        _safeMint(msg.sender, totalSupply() + 1);\n    }","contract":"BrushStrokes","time":0},{"type":"external-function ","before":"function mint(bytes memory signature, uint256 nonce) public payable {\n        require(mintIsActive, \"Minting is not active at the moment\");\n        require(totalSupply() + 1 <= MAX_SUPPLY, \"Purchase would exceed max supply\");\n        require(walletMintNumber[msg.sender] + 1 <= 3, \"Mint would exceed max mint for wallet\");\n        require(BRUSHSTROKES_PRICE == msg.value, \"Sent ether value is incorrect\");\n        \n        bytes32 messageHash = hashMessage(msg.sender, nonce);\n        require(messageHash.recover(signature) == _signatureVerifier, \"Unrecognizable Hash\");\n        require(!usedHashes[messageHash], \"Reused Hash\");\n        usedHashes[messageHash] = true;\n\n        walletMintNumber[msg.sender] += 1;\n        setTokenIdToHash(totalSupply() + 1);\n        _safeMint(msg.sender, totalSupply() + 1);\n    }","after":"function mint(bytes calldata signature, uint256 nonce) public payable {\n        require(mintIsActive, \"Minting is not active at the moment\");\n        require(totalSupply() + 1 <= MAX_SUPPLY, \"Purchase would exceed max supply\");\n        require(walletMintNumber[msg.sender] + 1 <= 3, \"Mint would exceed max mint for wallet\");\n        require(BRUSHSTROKES_PRICE == msg.value, \"Sent ether value is incorrect\");\n        \n        bytes32 messageHash = hashMessage(msg.sender, nonce);\n        require(messageHash.recover(signature) == _signatureVerifier, \"Unrecognizable Hash\");\n        require(!usedHashes[messageHash], \"Reused Hash\");\n        usedHashes[messageHash] = true;\n\n        walletMintNumber[msg.sender] += 1;\n        setTokenIdToHash(totalSupply() + 1);\n        _safeMint(msg.sender, totalSupply() + 1);\n    }","contract":"BrushStrokes","time":0},{"type":"constant-restrict-modification  ","before":"address private _signatureVerifier = 0x805c057A31B31c84F7759698298aD4dC6F8fA622;","after":"address private constant _signatureVerifier = 0x805c057A31B31c84F7759698298aD4dC6F8fA622;","contract":"BrushStrokes","time":0}]}