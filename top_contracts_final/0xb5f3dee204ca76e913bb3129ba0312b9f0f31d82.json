{"time":141,"results":[{"type":"state-data-arrangement ","before":"\nuint256 public constant TOKEN_PRICE = 0.08 ether;\nuint public constant MAX_PURCHASE = 5;\nuint256 public constant MAX_TOTAL_SUPPLY = 10000;\nstring public provenanceHash;\naddress public signer;\nmapping(string => bool) private usedNonces;\nbool public saleIsActive = false;\nuint public presaleActiveUntil = 0;\nmapping(address => uint) private presaleAccessList;\nmapping(address => uint) private presaleTokensClaimed;\naddress public omniFusionAddress;\nstring public baseURI;\naddress payable public member1Address;\naddress payable public member2Address;\naddress payable public member3Address;","after":"uint256 public constant TOKEN_PRICE = 0.08 ether;\nuint public constant MAX_PURCHASE = 5;\nuint256 public constant MAX_TOTAL_SUPPLY = 10000;\nstring public provenanceHash;\nmapping(string => bool) private usedNonces;\nuint public presaleActiveUntil = 0;\nmapping(address => uint) private presaleAccessList;\nmapping(address => uint) private presaleTokensClaimed;\nstring public baseURI;\naddress public signer;\naddress public omniFusionAddress;\naddress payable public member1Address;\naddress payable public member2Address;\naddress payable public member3Address;\nbool public saleIsActive = false;\n","contract":"Omnimorphs","time":0},{"type":"external-function ","before":"function setBaseURI(string memory newBaseURI) external onlyOwner {\n        baseURI = newBaseURI;\n    }","after":"function setBaseURI(string calldata newBaseURI) external onlyOwner {\n        baseURI = newBaseURI;\n    }","contract":"Omnimorphs","time":0},{"type":"external-function ","before":"function setProvenanceHash(string memory hash) external onlyOwner {\n        provenanceHash = hash;\n    }","after":"function setProvenanceHash(string calldata hash) external onlyOwner {\n        provenanceHash = hash;\n    }","contract":"Omnimorphs","time":0},{"type":"external-function ","before":"function mintTokens(bytes32 hash, bytes memory signature, string memory nonce, uint numberOfTokens) external payable {\n        require(saleIsActive, \"Sale is not currently active\");\n        require(totalSupply() + numberOfTokens <= MAX_TOTAL_SUPPLY, \"Minting would exceed MAX_TOTAL_SUPPLY\");\n        require(numberOfTokens <= MAX_PURCHASE, \"Trying to mint too many tokens\");\n        require(numberOfTokens > 0, \"Number of tokens cannot be lower than, or equal to 0\");\n        require(TOKEN_PRICE * numberOfTokens == msg.value, \"Ether value sent is not correct\");\n        require(matchAddressSigner(hash, signature), \"Direct minting is not allowed\");\n        require(!usedNonces[nonce], \"Nonce was already used\");\n        require(hashTransaction(msg.sender, numberOfTokens, nonce) == hash, \"Hash mismatch\");\n\n        usedNonces[nonce] = true;\n        _mintTokens(numberOfTokens);\n    }","after":"function mintTokens(bytes32 hash, bytes calldata signature, string calldata nonce, uint numberOfTokens) external payable {\n        require(saleIsActive, \"Sale is not currently active\");\n        require(totalSupply() + numberOfTokens <= MAX_TOTAL_SUPPLY, \"Minting would exceed MAX_TOTAL_SUPPLY\");\n        require(numberOfTokens <= MAX_PURCHASE, \"Trying to mint too many tokens\");\n        require(numberOfTokens > 0, \"Number of tokens cannot be lower than, or equal to 0\");\n        require(TOKEN_PRICE * numberOfTokens == msg.value, \"Ether value sent is not correct\");\n        require(matchAddressSigner(hash, signature), \"Direct minting is not allowed\");\n        require(!usedNonces[nonce], \"Nonce was already used\");\n        require(hashTransaction(msg.sender, numberOfTokens, nonce) == hash, \"Hash mismatch\");\n\n        usedNonces[nonce] = true;\n        _mintTokens(numberOfTokens);\n    }","contract":"Omnimorphs","time":0},{"type":"external-function ","before":"function fuseTokens(uint toFuse, uint toBurn, bytes memory payload) external {\n        IOmniFusion(omniFusionAddress).fuseTokens(msg.sender, toFuse, toBurn, payload);\n        _burn(toBurn);\n    }","after":"function fuseTokens(uint toFuse, uint toBurn, bytes calldata payload) external {\n        IOmniFusion(omniFusionAddress).fuseTokens(msg.sender, toFuse, toBurn, payload);\n        _burn(toBurn);\n    }","contract":"Omnimorphs","time":0}]}