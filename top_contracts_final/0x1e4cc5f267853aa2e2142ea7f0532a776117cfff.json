{"time":158,"results":[{"type":"state-data-arrangement ","before":"\nbytes32 public constant RECEIPT_SIGNER_ROLE = keccak256('RECEIPT_SIGNER_ROLE');\nbytes32 public constant SETTLER_ROLE = keccak256('SETTLER_ROLE');\nbytes32 public constant MANAGER_ROLE = keccak256('MANAGER_ROLE');\nuint256 private constant MIN_BID = 0.01 ether;\nstring private baseURI = 'https://marsmaiers.com/tokenURI/';\nbool private baseURILocked = false;\nuint256 private winnings;\nmapping(string => uint256) private bids;\nmapping(string => address) private bidders;\nbool private projectConcluded = false;","after":"bytes32 public constant RECEIPT_SIGNER_ROLE = keccak256('RECEIPT_SIGNER_ROLE');\nbytes32 public constant SETTLER_ROLE = keccak256('SETTLER_ROLE');\nbytes32 public constant MANAGER_ROLE = keccak256('MANAGER_ROLE');\nuint256 private constant MIN_BID = 0.01 ether;\nstring private baseURI = 'https://marsmaiers.com/tokenURI/';\nuint256 private winnings;\nmapping(string => uint256) private bids;\nmapping(string => address) private bidders;\nbool private baseURILocked = false;\nbool private projectConcluded = false;\n","contract":"MarsMaiers","time":0},{"type":"external-function ","before":"function setBaseURI(string memory uri, bool lock) external onlyRole(MANAGER_ROLE) {\n    require(!baseURILocked, 'baseURI is locked');\n\n    baseURI = uri;\n\n    if (lock) {\n      baseURILocked = true;\n    }\n  }","after":"function setBaseURI(string calldata uri, bool lock) external onlyRole(MANAGER_ROLE) {\n    require(!baseURILocked, 'baseURI is locked');\n\n    baseURI = uri;\n\n    if (lock) {\n      baseURILocked = true;\n    }\n  }","contract":"MarsMaiers","time":0},{"type":"external-function ","before":"function settle(uint256 tokenId, string memory bidToken) public onlyRole(SETTLER_ROLE) {\n    // validate input\n    bytes memory bidTokenCheck = bytes(bidToken);\n    require(tokenId >= 1 && tokenId <= 365 && bidTokenCheck.length > 0, 'invalid input');\n\n    // no more winners allowed\n    require(!projectConcluded, 'project has concluded');\n\n    // look up bid total and winner by bidToken\n    address winner = bidders[bidToken];\n    uint256 amount = bids[bidToken];\n\n    // ensure bidToken is not zero\n    require(winner != address(0x0) && amount > 0, 'unknown bidToken');\n\n    // zero bid\n    bids[bidToken] = 0;\n\n    // add amount to winnings\n    winnings = winnings + amount;\n\n    // close it up after final mint\n    if (tokenId == 365) {\n      projectConcluded = true;\n    }\n\n    // mint NFT to winner\n    _safeMint(winner, tokenId);\n  }","after":"function settle(uint256 tokenId, string calldata bidToken) public onlyRole(SETTLER_ROLE) {\n    // validate input\n    bytes memory bidTokenCheck = bytes(bidToken);\n    require(tokenId >= 1 && tokenId <= 365 && bidTokenCheck.length > 0, 'invalid input');\n\n    // no more winners allowed\n    require(!projectConcluded, 'project has concluded');\n\n    // look up bid total and winner by bidToken\n    address winner = bidders[bidToken];\n    uint256 amount = bids[bidToken];\n\n    // ensure bidToken is not zero\n    require(winner != address(0x0) && amount > 0, 'unknown bidToken');\n\n    // zero bid\n    bids[bidToken] = 0;\n\n    // add amount to winnings\n    winnings = winnings + amount;\n\n    // close it up after final mint\n    if (tokenId == 365) {\n      projectConcluded = true;\n    }\n\n    // mint NFT to winner\n    _safeMint(winner, tokenId);\n  }","contract":"MarsMaiers","time":0},{"type":"external-function ","before":"function signedRefund(\n    string memory bidToken,\n    string memory nonce,\n    bytes memory signature\n  ) public nonReentrant {\n    // infer message by hashing input params. signature must contain a hash with the same message\n    bytes32 message = keccak256(abi.encode(bidToken, nonce));\n\n    // validate inferred message matches input params, and was signed by an address with RECEIPT_SIGNER_ROLE\n    // if this passes we can trust the input params match\n    require(hasRole(RECEIPT_SIGNER_ROLE, message.toEthSignedMessageHash().recover(signature)), 'invalid receipt');\n\n    // execute refund\n    _refund(bidToken);\n  }","after":"function signedRefund(\n    string calldata bidToken,\n    string calldata nonce,\n    bytes calldata signature\n  ) public nonReentrant {\n    // infer message by hashing input params. signature must contain a hash with the same message\n    bytes32 message = keccak256(abi.encode(bidToken, nonce));\n\n    // validate inferred message matches input params, and was signed by an address with RECEIPT_SIGNER_ROLE\n    // if this passes we can trust the input params match\n    require(hasRole(RECEIPT_SIGNER_ROLE, message.toEthSignedMessageHash().recover(signature)), 'invalid receipt');\n\n    // execute refund\n    _refund(bidToken);\n  }","contract":"MarsMaiers","time":0},{"type":"external-function ","before":"function refund(string[] memory bidTokens) public nonReentrant {\n    // only allow unsigned refunds once project is concluded\n    require(projectConcluded, 'project has not concluded');\n\n    // execute refund for each bidToken\n    for (uint256 i = 0; i < bidTokens.length; i++) {\n      _refund(bidTokens[i]);\n    }\n  }","after":"function refund(string[] calldata bidTokens) public nonReentrant {\n    // only allow unsigned refunds once project is concluded\n    require(projectConcluded, 'project has not concluded');\n\n    // execute refund for each bidToken\n    for (uint256 i = 0; i < bidTokens.length; i++) {\n      _refund(bidTokens[i]);\n    }\n  }","contract":"MarsMaiers","time":0}]}