{"time":195,"results":[{"type":"external-function ","before":"ETH directly\n    receive() external payable {\n        revert();\n    }\n\n    // prevent callers from sending ETH directly\n    fallback(","after":"ETH directly\n    receive() external payable {\n        revert();\n    }\n\n    // prevent callers from sending ETH directly\n    fallback(","contract":"The90sArchives","time":0},{"type":"external-function ","before":"blic onlyOwner {\n        The90s_PACK_LIMIT = limit;\n    }\n\n    function startPreSale() public onlyOwner {\n        // will also restart when on pause\n        if (!preSaleStarted) {\n            preSaleStarted = true;\n            emit PreSaleStarted();\n        }\n    }\n\n    function setTransfer(bool tran) public onlyOwner {\n        onTransfer = tran;\n    }\n\n    function setArchivePartsOwner(uint256[] memory partIDs, address[] memory _owner, uint256[] memory bodySection) public onlyOwner {\n        require(partIDs.length == _owner.length, \"Number of body parts a","after":"blic onlyOwner {\n        The90s_PACK_LIMIT = limit;\n    }\n\n    function startPreSale() public onlyOwner {\n        // will also restart when on pause\n        if (!preSaleStarted) {\n            preSaleStarted = true;\n            emit PreSaleStarted();\n        }\n    }\n\n    function setTransfer(bool tran) public onlyOwner {\n        onTransfer = tran;\n    }\n\n    function setArchivePartsOwner(uint256[] memory partIDs, address[] memory _owner, uint256[] memory bodySection) public onlyOwner {\n        require(partIDs.length == _owner.length, \"Number of body parts a","contract":"The90sArchives","time":0},{"type":"external-function ","before":"ers must be equal\");\n        require(partIDs.length == bodySection.length, \"Number of body parts and bodySection must be equal\");\n        for (uint256 i = 0; i < partIDs.length; i++) {\n            deadpart[partIDs[i]] = The90sArchiveParts({\n                owner : _owner[i],\n                partInTheBody : bodySection[i]\n            });\n        }\n    }\n\n    function preSetTraitNFTs(uint256[] memory tokenIDs, uint256[] memory archiveTraits) public onlyOwner {\n        require(tokenIDs.length * 10 == archiveTraits.length, \"Number of traits must equal to number of tokens*attr\");\n\n        uint256 j = 0;\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\n            deadbod[tokenIDs[i]] = The90sArchivesStruct({\n                    bg : archiveTraits[j],\n                    skin : archiveTraits[j+1],\n                    mouth : archiveTraits[j+2],\n                    cloth1 : archiveTraits[j+3],\n                    cloth2 : archiveTraits[j+4],\n                    cloth3 : archiveTraits[j+5],\n                    hair : archiveTraits","after":"ers must be equal\");\n        require(partIDs.length == bodySection.length, \"Number of body parts and bodySection must be equal\");\n        for (uint256 i = 0; i < partIDs.length; i++) {\n            deadpart[partIDs[i]] = The90sArchiveParts({\n                owner : _owner[i],\n                partInTheBody : bodySection[i]\n            });\n        }\n    }\n\n    function preSetTraitNFTs(uint256[] memory tokenIDs, uint256[] memory archiveTraits) public onlyOwner {\n        require(tokenIDs.length * 10 == archiveTraits.length, \"Number of traits must equal to number of tokens*attr\");\n\n        uint256 j = 0;\n        for (uint256 i = 0; i < tokenIDs.length; i++) {\n            deadbod[tokenIDs[i]] = The90sArchivesStruct({\n                    bg : archiveTraits[j],\n                    skin : archiveTraits[j+1],\n                    mouth : archiveTraits[j+2],\n                    cloth1 : archiveTraits[j+3],\n                    cloth2 : archiveTraits[j+4],\n                    cloth3 : archiveTraits[j+5],\n                    hair : archiveTraits","contract":"The90sArchives","time":0},{"type":"external-function ","before":"== 0) {\n            saleStartedAt = block.timestamp;\n        }\n    }\n\n    /*\n     * @dev If sale is on, pause it and emit {SalePaused}; otherwise, do nothing.\n     *   Only callable by the owner.\n     */\n    function pauseSale() public onlyOw","after":"== 0) {\n            saleStartedAt = block.timestamp;\n        }\n    }\n\n    /*\n     * @dev If sale is on, pause it and emit {SalePaused}; otherwise, do nothing.\n     *   Only callable by the owner.\n     */\n    function pauseSale() public onlyOw","contract":"The90sArchives","time":0},{"type":"external-function ","before":"        if (saleStarted) {\n            saleStarted = false;\n            emit SalePaused();\n        }\n    }\n\n    function setPresaleWhitelist(address[] memory account, bool isAdd) external onlyOwner {\n        for(uint256 i=0; i < account.lengt","after":"        if (saleStarted) {\n            saleStarted = false;\n            emit SalePaused();\n        }\n    }\n\n    function setPresaleWhitelist(address[] memory account, bool isAdd) external onlyOwner {\n        for(uint256 i=0; i < account.lengt","contract":"The90sArchives","time":0},{"type":"external-function ","before":"preSaleWhitelist[account[i]] = isAdd;\n        }\n\n        emit SetPresaleWhitelist();\n    }\n\n    function setSpecialWhitelist(address[] memory account, bool isAdd) external onlyOwner {\n        for(uint256 i=0; i < account.length; i++) {\n            specialWhitelist[account[i]] = isAdd;\n        }\n\n        emit SetSpecialWhitelist();\n    }\n\n    //Obsoleted\n ","after":"preSaleWhitelist[account[i]] = isAdd;\n        }\n\n        emit SetPresaleWhitelist();\n    }\n\n    function setSpecialWhitelist(address[] memory account, bool isAdd) external onlyOwner {\n        for(uint256 i=0; i < account.length; i++) {\n            specialWhitelist[account[i]] = isAdd;\n        }\n\n        emit SetSpecialWhitelist();\n    }\n\n    //Obsoleted\n ","contract":"The90sArchives","time":0},{"type":"external-function ","before":"FTWhitelist(address[] memory account, uint256[] memory tokenId) external onlyOwner {\n        require(account.length == tokenId.length, \"No of accounts & tokens don't match\");\n        for(uint256 i=0; i < tokenId.length; i++) {\n            targetNFTWhitelist[tokenId[i]] = account[i];\n        }\n\n        emit SetTargetNFTWhitelist();\n    }\n\n    //Obsoleted\n    fun","after":"FTWhitelist(address[] calldata account, uint256[] calldata tokenId) external onlyOwner {\n        require(account.length == tokenId.length, \"No of accounts & tokens don't match\");\n        for(uint256 i=0; i < tokenId.length; i++) {\n            targetNFTWhitelist[tokenId[i]] = account[i];\n        }\n\n        emit SetTargetNFTWhitelist();\n    }\n\n    //Obsoleted\n    fun","contract":"The90sArchives","time":0},{"type":"external-function ","before":"setPriorityNFTWhitelist(address[] memory account, uint256[] memory tokenId) external onlyOwner {\n        require(account.length == tokenId.length, \"No of accounts & tokens don't match\");\n        for(uint256 i=0; i < tokenId.length; i++) {\n            priorityNFTWhitelist[tokenId[i]] = account[i];\n        }\n\n        emit SetPriorityNFTWhitelist();\n   ","after":"setPriorityNFTWhitelist(address[] calldata account, uint256[] calldata tokenId) external onlyOwner {\n        require(account.length == tokenId.length, \"No of accounts & tokens don't match\");\n        for(uint256 i=0; i < tokenId.length; i++) {\n            priorityNFTWhitelist[tokenId[i]] = account[i];\n        }\n\n        emit SetPriorityNFTWhitelist();\n   ","contract":"The90sArchives","time":0},{"type":"external-function ","before":"/ _safeMint(msg.sender, totalSupply() + 1);\n            uint256 tokenId = totalSupply() + startingIndex + 1;\n            _safeMint(msg.sender, tokenId);\n            OGNFTWhitelistLimit[msg.sender] = OGNFTWhitelistLimit[msg.sender] - 1;\n            resultIDs[i] = tokenId;\n        }\n\n        emit MintInfluencerArchives();\n        return resultIDs;\n\n    }\n\n    function mintThe90sAdmin(uint256[] memory archiveIDs, address[] memory receivers) public onlyOwner {\n        require(totalSupply() <= MAX_The90s_SUPPLY, \"Archieves sold out\");\n        require(archiveIDs.length > 0, \"N","after":"/ _safeMint(msg.sender, totalSupply() + 1);\n            uint256 tokenId = totalSupply() + startingIndex + 1;\n            _safeMint(msg.sender, tokenId);\n            OGNFTWhitelistLimit[msg.sender] = OGNFTWhitelistLimit[msg.sender] - 1;\n            resultIDs[i] = tokenId;\n        }\n\n        emit MintInfluencerArchives();\n        return resultIDs;\n\n    }\n\n    function mintThe90sAdmin(uint256[] memory archiveIDs, address[] memory receivers) public onlyOwner {\n        require(totalSupply() <= MAX_The90s_SUPPLY, \"Archieves sold out\");\n        require(archiveIDs.length > 0, \"N","contract":"The90sArchives","time":0},{"type":"external-function ","before":"+) {\n            require(!_exists(archiveIDs[i]), \"ERC721: token already minted\");\n            _safeMint(receivers[i], archiveIDs[i]);\n        }\n\n    }\n\n    /**\n     * @dev Change traits of the minted 90Archives NFT\n     *\n     * @param tokenId Token id of the 90Archives NFTs to be changed.\n     * @param traits traits of the 90Archives deadbods.\n     */\n    function changeTraits(uint256 tokenId, uint256[] memory traits) public payable {\n        _enforceSaleStarted();\n        require(ownerOf(tokenId) == msg.sender , \"Need to be the archive owner to change traits\");\n        //Add available traits conditions\n        require(traits.length == 10, \"Invalid number of traits\");\n            deadbod[tokenId] = The90sArchivesStruct({\n                bg : traits[0],\n                skin : traits[1],\n                mouth : traits[2],\n                cl","after":"+) {\n            require(!_exists(archiveIDs[i]), \"ERC721: token already minted\");\n            _safeMint(receivers[i], archiveIDs[i]);\n        }\n\n    }\n\n    /**\n     * @dev Change traits of the minted 90Archives NFT\n     *\n     * @param tokenId Token id of the 90Archives NFTs to be changed.\n     * @param traits traits of the 90Archives deadbods.\n     */\n    function changeTraits(uint256 tokenId, uint256[] memory traits) public payable {\n        _enforceSaleStarted();\n        require(ownerOf(tokenId) == msg.sender , \"Need to be the archive owner to change traits\");\n        //Add available traits conditions\n        require(traits.length == 10, \"Invalid number of traits\");\n            deadbod[tokenId] = The90sArchivesStruct({\n                bg : traits[0],\n                skin : traits[1],\n                mouth : traits[2],\n                cl","contract":"The90sArchives","time":0},{"type":"external-function ","before":"11],\n                extra : traits[12]\n            });\n    }\n\n    /**\n     * @dev Set base token URI. Only callable by the owner and only\n     * if token URI hasn't been locked through","after":"11],\n                extra : traits[12]\n            });\n    }\n\n    /**\n     * @dev Set base token URI. Only callable by the owner and only\n     * if token URI hasn't been locked through","contract":"The90sArchives","time":0},{"type":"constant-restrict-modification  ","before":"es();\n\n    IERC721 public BAYC = IERC721(0xBC4CA0EdA","after":"es();\n\n    IERC721 public BAYC = IERC721(0xBC4CA0EdA","contract":"The90sArchives","time":1},{"type":"constant-restrict-modification  ","before":"t256 public The90s_PACK_LIMIT =","after":"t256 public The90s_PACK_LIMIT =","contract":"The90sArchives","time":1}]}