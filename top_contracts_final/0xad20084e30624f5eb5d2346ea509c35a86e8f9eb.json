{"time":200,"results":[{"type":"external-function ","before":"function setBaseURI(string memory newBaseURI) external onlyOwner {\n    baseURI = newBaseURI;\n  }","after":"function setBaseURI(string calldata newBaseURI) external onlyOwner {\n    baseURI = newBaseURI;\n  }","contract":"Y2123","time":0},{"type":"external-function ","before":"function freeMint(bytes32[] memory proof) public payable nonReentrant {\n    uint256 totalMinted = totalSupply();\n\n    require(msg.sender == tx.origin);\n    require(freeMintEnabled, \"Free mint not enabled\");\n    require(proof.verify(freeRoot, keccak256(abi.encodePacked(msg.sender))), \"You are not on the free list\");\n    require(freeMintCount + 1 <= MAX_FREE_MINT, \"No more supply\");\n    require(freeMintMinted[msg.sender] < 1, \"You already minted your free nft\");\n\n    _safeMint(msg.sender, totalMinted);\n    addressMinted[msg.sender]++;\n\n    freeMintMinted[msg.sender] = 1;\n    freeMintCount += 1;\n  }","after":"function freeMint(bytes32[] calldata proof) public payable nonReentrant {\n    uint256 totalMinted = totalSupply();\n\n    require(msg.sender == tx.origin);\n    require(freeMintEnabled, \"Free mint not enabled\");\n    require(proof.verify(freeRoot, keccak256(abi.encodePacked(msg.sender))), \"You are not on the free list\");\n    require(freeMintCount + 1 <= MAX_FREE_MINT, \"No more supply\");\n    require(freeMintMinted[msg.sender] < 1, \"You already minted your free nft\");\n\n    _safeMint(msg.sender, totalMinted);\n    addressMinted[msg.sender]++;\n\n    freeMintMinted[msg.sender] = 1;\n    freeMintCount += 1;\n  }","contract":"Y2123","time":0},{"type":"external-function ","before":"function paidMint(uint256 amount, bytes32[] memory proof) public payable nonReentrant {\n    uint256 totalMinted = totalSupply();\n\n    require(msg.sender == tx.origin);\n    require(saleEnabled, \"Sale not enabled\");\n    require(amount * mintPrice <= msg.value, \"More ETH please\");\n    require(amount + totalMinted <= availableSupplyIndex(), \"Please try minting with less, not enough supply!\");\n\n    if (presaleEnabled == true) {\n      require(proof.verify(merkleRoot, keccak256(abi.encodePacked(msg.sender))), \"You are not on the whitelist\");\n      require(amount + whitelistMinted[msg.sender] <= maxMintPerAddress, \"Exceeded max mint per address for whitelist, try minting with less\");\n    } else {\n      require(amount <= maxMintPerTx, \"Exceeded max mint per transaction\");\n    }\n\n    for (uint256 i = 0; i < amount; i++) {\n      _safeMint(msg.sender, totalMinted + i);\n      addressMinted[msg.sender]++;\n      if (presaleEnabled == true) {\n        whitelistMinted[msg.sender]++;\n      }\n    }\n  }","after":"function paidMint(uint256 amount, bytes32[] calldata proof) public payable nonReentrant {\n    uint256 totalMinted = totalSupply();\n\n    require(msg.sender == tx.origin);\n    require(saleEnabled, \"Sale not enabled\");\n    require(amount * mintPrice <= msg.value, \"More ETH please\");\n    require(amount + totalMinted <= availableSupplyIndex(), \"Please try minting with less, not enough supply!\");\n\n    if (presaleEnabled == true) {\n      require(proof.verify(merkleRoot, keccak256(abi.encodePacked(msg.sender))), \"You are not on the whitelist\");\n      require(amount + whitelistMinted[msg.sender] <= maxMintPerAddress, \"Exceeded max mint per address for whitelist, try minting with less\");\n    } else {\n      require(amount <= maxMintPerTx, \"Exceeded max mint per transaction\");\n    }\n\n    for (uint256 i = 0; i < amount; i++) {\n      _safeMint(msg.sender, totalMinted + i);\n      addressMinted[msg.sender]++;\n      if (presaleEnabled == true) {\n        whitelistMinted[msg.sender]++;\n      }\n    }\n  }","contract":"Y2123","time":0},{"type":"external-function ","before":"function updateOriginAccess(uint256[] memory tokenIds) external override {\n    require(admins[_msgSender()], \"Admins only!\");\n    uint64 timestamp = uint64(block.timestamp);\n    uint64 blockNumber = uint64(block.number);\n    lastWriteAddress[tx.origin] = LastWrite(timestamp, blockNumber);\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      lastWriteToken[tokenIds[i]] = LastWrite(timestamp, blockNumber);\n    }\n  }","after":"function updateOriginAccess(uint256[] calldata tokenIds) external override {\n    require(admins[_msgSender()], \"Admins only!\");\n    uint64 timestamp = uint64(block.timestamp);\n    uint64 blockNumber = uint64(block.number);\n    lastWriteAddress[tx.origin] = LastWrite(timestamp, blockNumber);\n    for (uint256 i = 0; i < tokenIds.length; i++) {\n      lastWriteToken[tokenIds[i]] = LastWrite(timestamp, blockNumber);\n    }\n  }","contract":"Y2123","time":0}]}