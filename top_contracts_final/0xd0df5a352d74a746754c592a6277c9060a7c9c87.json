{"time":331,"results":[{"type":"external-function ","before":"function deposit(TokenData calldata tokenInfo, bytes32[] memory proof)\n        external\n        payable\n        override\n    {\n        require(currentStage == STAGES.STAGE_1, \"DEPOSITS_NOT_ACCEPTED\");\n        require(!stage1Locked, \"DEPOSITS_LOCKED\");\n\n        if (whitelistSettings.enabled) {\n            require(\n                verifyDepositor(msg.sender, whitelistSettings.root, proof),\n                \"PROOF_INVALID\"\n            );\n        }\n\n        TokenData memory data = tokenInfo;\n        address token = data.token;\n        uint256 tokenAmount = data.amount;\n        require(supportedTokens.contains(token), \"UNSUPPORTED_TOKEN\");\n        require(tokenAmount > 0, \"INVALID_AMOUNT\");\n\n        // Convert ETH to WETH if ETH is passed in, otherwise treat WETH as a regular ERC20\n        if (token == WETH && msg.value > 0) {\n            require(tokenAmount == msg.value, \"INVALID_MSG_VALUE\");\n            IWETH(WETH).deposit{value: tokenAmount}();\n        } else {\n            require(msg.value == 0, \"NO_ETH\");\n        }\n\n        AccountData storage tokenAccountData = accountData[msg.sender];\n\n        if (tokenAccountData.token == address(0)) {\n            tokenAccountData.token = token;\n        }\n\n        require(tokenAccountData.token == token, \"SINGLE_ASSET_DEPOSITS\");\n\n        tokenAccountData.initialDeposit = tokenAccountData.initialDeposit.add(\n            tokenAmount\n        );\n        tokenAccountData.currentBalance = tokenAccountData.currentBalance.add(\n            tokenAmount\n        );\n\n        require(\n            tokenAccountData.currentBalance <= tokenSettings[token].maxLimit,\n            \"MAX_LIMIT_EXCEEDED\"\n        );\n\n        // No need to transfer from msg.sender since is ETH was converted to WETH\n        if (!(token == WETH && msg.value > 0)) {\n            IERC20(token).safeTransferFrom(\n                msg.sender,\n                address(this),\n                tokenAmount\n            );\n        }\n\n        if (_totalValue() >= maxTotalValue) {\n            stage1Locked = true;\n        }\n\n        emit Deposited(msg.sender, tokenInfo);\n    }","after":"function deposit(TokenData calldata tokenInfo, bytes32[] calldata proof)\n        external\n        payable\n        override\n    {\n        require(currentStage == STAGES.STAGE_1, \"DEPOSITS_NOT_ACCEPTED\");\n        require(!stage1Locked, \"DEPOSITS_LOCKED\");\n\n        if (whitelistSettings.enabled) {\n            require(\n                verifyDepositor(msg.sender, whitelistSettings.root, proof),\n                \"PROOF_INVALID\"\n            );\n        }\n\n        TokenData memory data = tokenInfo;\n        address token = data.token;\n        uint256 tokenAmount = data.amount;\n        require(supportedTokens.contains(token), \"UNSUPPORTED_TOKEN\");\n        require(tokenAmount > 0, \"INVALID_AMOUNT\");\n\n        // Convert ETH to WETH if ETH is passed in, otherwise treat WETH as a regular ERC20\n        if (token == WETH && msg.value > 0) {\n            require(tokenAmount == msg.value, \"INVALID_MSG_VALUE\");\n            IWETH(WETH).deposit{value: tokenAmount}();\n        } else {\n            require(msg.value == 0, \"NO_ETH\");\n        }\n\n        AccountData storage tokenAccountData = accountData[msg.sender];\n\n        if (tokenAccountData.token == address(0)) {\n            tokenAccountData.token = token;\n        }\n\n        require(tokenAccountData.token == token, \"SINGLE_ASSET_DEPOSITS\");\n\n        tokenAccountData.initialDeposit = tokenAccountData.initialDeposit.add(\n            tokenAmount\n        );\n        tokenAccountData.currentBalance = tokenAccountData.currentBalance.add(\n            tokenAmount\n        );\n\n        require(\n            tokenAccountData.currentBalance <= tokenSettings[token].maxLimit,\n            \"MAX_LIMIT_EXCEEDED\"\n        );\n\n        // No need to transfer from msg.sender since is ETH was converted to WETH\n        if (!(token == WETH && msg.value > 0)) {\n            IERC20(token).safeTransferFrom(\n                msg.sender,\n                address(this),\n                tokenAmount\n            );\n        }\n\n        if (_totalValue() >= maxTotalValue) {\n            stage1Locked = true;\n        }\n\n        emit Deposited(msg.sender, tokenInfo);\n    }","contract":"DefiRound","time":0},{"type":"external-function ","before":"function configureWhitelist(WhitelistSettings memory settings)\n        external\n        override\n        onlyOwner\n    {\n        whitelistSettings = settings;\n        emit WhitelistConfigured(settings);\n    }","after":"function configureWhitelist(WhitelistSettings calldata settings)\n        external\n        override\n        onlyOwner\n    {\n        whitelistSettings = settings;\n        emit WhitelistConfigured(settings);\n    }","contract":"DefiRound","time":0},{"type":"external-function ","before":"function publishRates(\n        RateData[] calldata ratesData,\n        OversubscriptionRate memory oversubRate,\n        uint256 lastLookDuration\n    ) external override onlyOwner {\n        // check rates havent been published before\n        require(currentStage == STAGES.STAGE_1, \"RATES_ALREADY_SET\");\n        //require(lastLookDuration > 0, \"INVALID_DURATION\");\n        require(oversubRate.overDenominator > 0, \"INVALID_DENOMINATOR\");\n        require(oversubRate.overNumerator > 0, \"INVALID_NUMERATOR\");\n\n        uint256 ratesLength = ratesData.length;\n        for (uint256 i = 0; i < ratesLength; i++) {\n            RateData memory data = ratesData[i];\n            require(data.numerator > 0, \"INVALID_NUMERATOR\");\n            require(data.denominator > 0, \"INVALID_DENOMINATOR\");\n            require(\n                tokenRates[data.token].token == address(0),\n                \"RATE_ALREADY_SET\"\n            );\n            require(configuredTokenRates.add(data.token), \"ALREADY_CONFIGURED\");\n            tokenRates[data.token] = data;\n        }\n\n        require(\n            configuredTokenRates.length() == supportedTokens.length(),\n            \"MISSING_RATE\"\n        );\n\n        // Stage only moves forward when prices are published\n        currentStage = STAGES.STAGE_2;\n        lastLookExpiration = block.number + lastLookDuration;\n        overSubscriptionRate = oversubRate;\n\n        emit RatesPublished(ratesData);\n    }","after":"function publishRates(\n        RateData[] calldata ratesData,\n        OversubscriptionRate calldata oversubRate,\n        uint256 lastLookDuration\n    ) external override onlyOwner {\n        // check rates havent been published before\n        require(currentStage == STAGES.STAGE_1, \"RATES_ALREADY_SET\");\n        //require(lastLookDuration > 0, \"INVALID_DURATION\");\n        require(oversubRate.overDenominator > 0, \"INVALID_DENOMINATOR\");\n        require(oversubRate.overNumerator > 0, \"INVALID_NUMERATOR\");\n\n        uint256 ratesLength = ratesData.length;\n        for (uint256 i = 0; i < ratesLength; i++) {\n            RateData memory data = ratesData[i];\n            require(data.numerator > 0, \"INVALID_NUMERATOR\");\n            require(data.denominator > 0, \"INVALID_DENOMINATOR\");\n            require(\n                tokenRates[data.token].token == address(0),\n                \"RATE_ALREADY_SET\"\n            );\n            require(configuredTokenRates.add(data.token), \"ALREADY_CONFIGURED\");\n            tokenRates[data.token] = data;\n        }\n\n        require(\n            configuredTokenRates.length() == supportedTokens.length(),\n            \"MISSING_RATE\"\n        );\n\n        // Stage only moves forward when prices are published\n        currentStage = STAGES.STAGE_2;\n        lastLookExpiration = block.number + lastLookDuration;\n        overSubscriptionRate = oversubRate;\n\n        emit RatesPublished(ratesData);\n    }","contract":"DefiRound","time":0},{"type":"constant-restrict-modification  ","before":"string public name = \"WETH\";","after":"string public constant name = \"WETH\";","contract":"WETHMock","time":0},{"type":"constant-restrict-modification  ","before":"string public symbol = \"WETH\";","after":"string public constant symbol = \"WETH\";","contract":"WETHMock","time":0},{"type":"constant-restrict-modification  ","before":"uint8 public decimals = 18;","after":"uint8 public constant decimals = 18;","contract":"WETHMock","time":0},{"type":"constant-restrict-modification  ","before":"string public name = \"USDC\";","after":"string public constant name = \"USDC\";","contract":"USDCMock","time":0},{"type":"constant-restrict-modification  ","before":"string public symbol = \"USDC\";","after":"string public constant symbol = \"USDC\";","contract":"USDCMock","time":0},{"type":"constant-restrict-modification  ","before":"uint8 public decimals = 6;","after":"uint8 public constant decimals = 6;","contract":"USDCMock","time":0},{"type":"external-function ","before":"function set_name(string memory _name, string memory _symbol) external {\n        /***\n         *@notice Change the token name and symbol to `_name` and `_symbol`\n         *@dev Only callable by the admin account\n         *@param _name New token name\n         *@param _symbol New token symbol\n         */\n        require(msg.sender == admin, \"Only admin is allowed to change name\");\n        name = _name;\n        symbol = _symbol;\n    }","after":"function set_name(string calldata _name, string calldata _symbol) external {\n        /***\n         *@notice Change the token name and symbol to `_name` and `_symbol`\n         *@dev Only callable by the admin account\n         *@param _name New token name\n         *@param _symbol New token symbol\n         */\n        require(msg.sender == admin, \"Only admin is allowed to change name\");\n        name = _name;\n        symbol = _symbol;\n    }","contract":"InsureToken","time":0}]}