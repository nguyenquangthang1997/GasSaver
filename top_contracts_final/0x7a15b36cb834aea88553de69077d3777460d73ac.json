{"time":142,"results":[{"type":"external-function ","before":"function createArtwork(\n        string memory fingerprint,\n        string memory title,\n        string memory artistName,\n        uint256 editionSize\n    ) external onlyAuthorized {\n        require(bytes(title).length != 0, \"title can not be empty\");\n        require(bytes(artistName).length != 0, \"artist can not be empty\");\n        require(bytes(fingerprint).length != 0, \"fingerprint can not be empty\");\n        require(editionSize > 0, \"edition size needs to be at least 1\");\n        require(\n            editionSize <= maxEditionPerArtwork,\n            \"artwork edition size exceeds the maximum edition size of the exhibition\"\n        );\n\n        uint256 artworkID = uint256(keccak256(abi.encode(fingerprint)));\n\n        /// @notice make sure the artwork have not been registered\n        require(\n            bytes(artworks[artworkID].fingerprint).length == 0,\n            \"an artwork with the same fingerprint has already registered\"\n        );\n\n        Artwork memory artwork = Artwork(\n            fingerprint,\n            title,\n            artistName,\n            editionSize\n        );\n\n        _allArtworks.push(artworkID);\n        artworks[artworkID] = artwork;\n\n        emit NewArtwork(artworkID);\n    }","after":"function createArtwork(\n        string calldata fingerprint,\n        string calldata title,\n        string calldata artistName,\n        uint256 editionSize\n    ) external onlyAuthorized {\n        require(bytes(title).length != 0, \"title can not be empty\");\n        require(bytes(artistName).length != 0, \"artist can not be empty\");\n        require(bytes(fingerprint).length != 0, \"fingerprint can not be empty\");\n        require(editionSize > 0, \"edition size needs to be at least 1\");\n        require(\n            editionSize <= maxEditionPerArtwork,\n            \"artwork edition size exceeds the maximum edition size of the exhibition\"\n        );\n\n        uint256 artworkID = uint256(keccak256(abi.encode(fingerprint)));\n\n        /// @notice make sure the artwork have not been registered\n        require(\n            bytes(artworks[artworkID].fingerprint).length == 0,\n            \"an artwork with the same fingerprint has already registered\"\n        );\n\n        Artwork memory artwork = Artwork(\n            fingerprint,\n            title,\n            artistName,\n            editionSize\n        );\n\n        _allArtworks.push(artworkID);\n        artworks[artworkID] = artwork;\n\n        emit NewArtwork(artworkID);\n    }","contract":"FeralfileExhibitionV2","time":0},{"type":"external-function ","before":"function swapArtworkFromBitmark(\n        uint256 artworkID,\n        uint256 bitmarkID,\n        uint256 editionNumber,\n        address owner,\n        string memory ipfsCID\n    ) external onlyAuthorized {\n        /// @notice the edition size is not set implies the artwork is not created\n        require(artworks[artworkID].editionSize > 0, \"artwork is not found\");\n        /// @notice The range of editionNumber should be between 0 (AP) ~ artwork.editionSize\n        require(\n            editionNumber <= artworks[artworkID].editionSize,\n            \"edition number exceed the edition size of the artwork\"\n        );\n        require(owner != address(0), \"invalid owner address\");\n        require(!registeredBitmarks[bitmarkID], \"bitmark id has registered\");\n        require(!registeredIPFSCIDs[ipfsCID], \"ipfs id has registered\");\n\n        uint256 editionID = artworkID + editionNumber;\n        require(\n            artworkEditions[editionID].editionID == 0,\n            \"the edition is existent\"\n        );\n\n        ArtworkEdition memory edition = ArtworkEdition(editionID, ipfsCID);\n\n        artworkEditions[editionID] = edition;\n        allArtworkEditions[artworkID].push(editionID);\n\n        registeredBitmarks[bitmarkID] = true;\n        registeredIPFSCIDs[ipfsCID] = true;\n\n        _safeMint(owner, editionID);\n        emit NewArtworkEdition(owner, artworkID, editionID);\n    }","after":"function swapArtworkFromBitmark(\n        uint256 artworkID,\n        uint256 bitmarkID,\n        uint256 editionNumber,\n        address owner,\n        string calldata ipfsCID\n    ) external onlyAuthorized {\n        /// @notice the edition size is not set implies the artwork is not created\n        require(artworks[artworkID].editionSize > 0, \"artwork is not found\");\n        /// @notice The range of editionNumber should be between 0 (AP) ~ artwork.editionSize\n        require(\n            editionNumber <= artworks[artworkID].editionSize,\n            \"edition number exceed the edition size of the artwork\"\n        );\n        require(owner != address(0), \"invalid owner address\");\n        require(!registeredBitmarks[bitmarkID], \"bitmark id has registered\");\n        require(!registeredIPFSCIDs[ipfsCID], \"ipfs id has registered\");\n\n        uint256 editionID = artworkID + editionNumber;\n        require(\n            artworkEditions[editionID].editionID == 0,\n            \"the edition is existent\"\n        );\n\n        ArtworkEdition memory edition = ArtworkEdition(editionID, ipfsCID);\n\n        artworkEditions[editionID] = edition;\n        allArtworkEditions[artworkID].push(editionID);\n\n        registeredBitmarks[bitmarkID] = true;\n        registeredIPFSCIDs[ipfsCID] = true;\n\n        _safeMint(owner, editionID);\n        emit NewArtworkEdition(owner, artworkID, editionID);\n    }","contract":"FeralfileExhibitionV2","time":0},{"type":"external-function ","before":"function updateArtworkEditionIPFSCid(uint256 tokenId, string memory ipfsCID)\n        external\n        onlyAuthorized\n    {\n        require(_exists(tokenId), \"artwork edition is not found\");\n        require(!registeredIPFSCIDs[ipfsCID], \"ipfs id has registered\");\n\n        ArtworkEdition storage edition = artworkEditions[tokenId];\n        delete registeredIPFSCIDs[edition.ipfsCID];\n        registeredIPFSCIDs[ipfsCID] = true;\n        edition.ipfsCID = ipfsCID;\n    }","after":"function updateArtworkEditionIPFSCid(uint256 tokenId, string calldata ipfsCID)\n        external\n        onlyAuthorized\n    {\n        require(_exists(tokenId), \"artwork edition is not found\");\n        require(!registeredIPFSCIDs[ipfsCID], \"ipfs id has registered\");\n\n        ArtworkEdition storage edition = artworkEditions[tokenId];\n        delete registeredIPFSCIDs[edition.ipfsCID];\n        registeredIPFSCIDs[ipfsCID] = true;\n        edition.ipfsCID = ipfsCID;\n    }","contract":"FeralfileExhibitionV2","time":0},{"type":"external-function ","before":"function setTokenBaseURI(string memory baseURI_) external onlyAuthorized {\n        _tokenBaseURI = baseURI_;\n    }","after":"function setTokenBaseURI(string calldata baseURI_) external onlyAuthorized {\n        _tokenBaseURI = baseURI_;\n    }","contract":"FeralfileExhibitionV2","time":0}]}