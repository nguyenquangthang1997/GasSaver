{"time":820,"results":[{"type":"loop-duplication","before":"\nstart line 687 column 4, end line 699 column 4\nfor (uint256 i = 0; i < probabilitiesLength; i++) {\n      string memory rerollCandidate = rerollCandidates[i];\n      // can't give any attribute already off limits, if it makes a zunk/punk, or their current attribute\n      if (\n        attributeProbabilities[i] == 0 ||\n        isInvalidZunk(rerollCandidate) ||\n        i == attribute\n      ) {\n        invalidProbabilitiesToDistribute += attributeProbabilities[i];\n      } else {\n        validAttribute[i] = true;\n      }\n    }\nstart line 701 column 4, end line 713 column 4\nfor (uint256 i = 0; i < probabilitiesLength; i++) {\n      if (validAttribute[i]) {\n        // the math here is to calculate how much of the invalidProbabilitiesToDistribute to\n        // give to each validProbability. If we are removing 2000 from the pool and giving\n        // 1000 its share, the additional probability for 1000 is 1000/8000 * 2000\n        adjustedProbabilities[i] =\n          ((attributeProbabilities[i] * invalidProbabilitiesToDistribute) /\n            (10000 - invalidProbabilitiesToDistribute)) +\n          attributeProbabilities[i];\n      } else {\n        adjustedProbabilities[i] = 0;\n      }\n    }","after":"// merge loop\n\nstart line 687 column 4, end line 699 column 4\nfor (uint256 i = 0; i < probabilitiesLength; i++) {\n      string memory rerollCandidate = rerollCandidates[i];\n      // can't give any attribute already off limits, if it makes a zunk/punk, or their current attribute\n      if (\n        attributeProbabilities[i] == 0 ||\n        isInvalidZunk(rerollCandidate) ||\n        i == attribute\n      ) {\n        invalidProbabilitiesToDistribute += attributeProbabilities[i];\n      } else {\n        validAttribute[i] = true;\n      }\n    }\nstart line 701 column 4, end line 713 column 4\nfor (uint256 i = 0; i < probabilitiesLength; i++) {\n      if (validAttribute[i]) {\n        // the math here is to calculate how much of the invalidProbabilitiesToDistribute to\n        // give to each validProbability. If we are removing 2000 from the pool and giving\n        // 1000 its share, the additional probability for 1000 is 1000/8000 * 2000\n        adjustedProbabilities[i] =\n          ((attributeProbabilities[i] * invalidProbabilitiesToDistribute) /\n            (10000 - invalidProbabilitiesToDistribute)) +\n          attributeProbabilities[i];\n      } else {\n        adjustedProbabilities[i] = 0;\n      }\n    }","contract":"CryptoZunks","time":0},{"type":"external-function ","before":"function seedPunks(string[] memory punks) public onlyOwner {\n    for (uint256 i = 0; i < punks.length; i++) {\n      unavailableZunks[punks[i]] = true;\n    }\n  }","after":"function seedPunks(string[] calldata punks) public onlyOwner {\n    for (uint256 i = 0; i < punks.length; i++) {\n      unavailableZunks[punks[i]] = true;\n    }\n  }","contract":"CryptoZunks","time":0},{"type":"external-function ","before":"function addFreeMintsAllocatedByDevs(\n    address[] memory addresses,\n    uint256[] memory numOfFreeMints\n  ) public onlyOwner {\n    require(\n      addresses.length == numOfFreeMints.length,\n      \"tokenOwners does not match numOfFreeRolls length\"\n    );\n    uint256 freeMintsFromThisSeed = 0;\n    for (uint256 i = 0; i < addresses.length; i++) {\n      freeMintsAllocatedByDevs[addresses[i]] =\n        freeMintsAllocatedByDevs[addresses[i]] +\n        numOfFreeMints[i];\n      freeMintsFromThisSeed += numOfFreeMints[i];\n    }\n    require(\n      freeMintsFromThisSeed < freeMintsAllocatedByDevsCap,\n      \"too many freemints allocated by devs\"\n    );\n  }","after":"function addFreeMintsAllocatedByDevs(\n    address[] calldata addresses,\n    uint256[] calldata numOfFreeMints\n  ) public onlyOwner {\n    require(\n      addresses.length == numOfFreeMints.length,\n      \"tokenOwners does not match numOfFreeRolls length\"\n    );\n    uint256 freeMintsFromThisSeed = 0;\n    for (uint256 i = 0; i < addresses.length; i++) {\n      freeMintsAllocatedByDevs[addresses[i]] =\n        freeMintsAllocatedByDevs[addresses[i]] +\n        numOfFreeMints[i];\n      freeMintsFromThisSeed += numOfFreeMints[i];\n    }\n    require(\n      freeMintsFromThisSeed < freeMintsAllocatedByDevsCap,\n      \"too many freemints allocated by devs\"\n    );\n  }","contract":"CryptoZunks","time":0},{"type":"constant-restrict-modification  ","before":"string NO_OPTIONS = \"no options\";","after":"string constant NO_OPTIONS = \"no options\";","contract":"CryptoZunks","time":1},{"type":"constant-restrict-modification  ","before":"uint256 NO_REROLL_OPTIONS = 99999;","after":"uint256 constant NO_REROLL_OPTIONS = 99999;","contract":"CryptoZunks","time":1},{"type":"constant-restrict-modification  ","before":"uint256 private MAX_SUPPLY = 10000;","after":"uint256 private constant MAX_SUPPLY = 10000;","contract":"CryptoZunks","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public freeMintsAllocatedByDevsCap = 300;","after":"uint256 public constant freeMintsAllocatedByDevsCap = 300;","contract":"CryptoZunks","time":1}]}