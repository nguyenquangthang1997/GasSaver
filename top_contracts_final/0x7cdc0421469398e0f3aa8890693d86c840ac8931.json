{"time":179,"results":[{"type":"external-function ","before":"function setBaseURI(string memory baseUri) public onlyOwner {\n        _setBaseURI(baseUri);\n    }","after":"function setBaseURI(string calldata baseUri) public onlyOwner {\n        _setBaseURI(baseUri);\n    }","contract":"MomijiToken","time":0},{"type":"external-function ","before":"function create(uint256 tokenId, uint256 maxSupply, string memory uri, bytes calldata data) external {\n        if (onlyWhitelist) {\n            require(whitelist[msg.sender], \"Open to only whitelist.\");\n        }\n        tokenQuantityWithId[tokenId] = 0;\n        tokenMaxQuantityWithId[tokenId] = maxSupply;\n        tokenIds.push(tokenId);\n        tokenIdAmount = tokenIdAmount.add(1);\n        _setTokenURI(tokenId, uri);\n        creators[tokenId] = msg.sender;\n        mintManuallyQuantityWithId[tokenId] = maxSupply;\n        emit Create(maxSupply, tokenId, uri, data);\n    }","after":"function create(uint256 tokenId, uint256 maxSupply, string calldata uri, bytes calldata data) external {\n        if (onlyWhitelist) {\n            require(whitelist[msg.sender], \"Open to only whitelist.\");\n        }\n        tokenQuantityWithId[tokenId] = 0;\n        tokenMaxQuantityWithId[tokenId] = maxSupply;\n        tokenIds.push(tokenId);\n        tokenIdAmount = tokenIdAmount.add(1);\n        _setTokenURI(tokenId, uri);\n        creators[tokenId] = msg.sender;\n        mintManuallyQuantityWithId[tokenId] = maxSupply;\n        emit Create(maxSupply, tokenId, uri, data);\n    }","contract":"MomijiToken","time":0},{"type":"external-function ","before":"function mint(uint256 tokenId, address to, uint256 quantity, bytes memory data) public {\n        require(creators[tokenId] == msg.sender || minters[tokenId][msg.sender], \"You are not the creator or minter of this NFT.\");\n        require(_isTokenIdExist(tokenId), \"Token is is not exist.\");\n        require(tokenMaxQuantityWithId[tokenId] >= tokenQuantityWithId[tokenId] + quantity, \"NFT quantity is greater than max supply.\");\n        if (!address(msg.sender).isContract()) {\n            require(mintManuallyQuantityWithId[tokenId] >= quantity, \"You mint too many cards manually\" );\n            mintManuallyQuantityWithId[tokenId] = mintManuallyQuantityWithId[tokenId].sub(quantity);\n        }\n        _mint(to, tokenId, quantity, data);\n        tokenQuantityWithId[tokenId] = tokenQuantityWithId[tokenId].add(quantity);\n        emit Mint(tokenId, to, quantity, data, tokenMaxQuantityWithId[tokenId], tokenQuantityWithId[tokenId]);\n    }","after":"function mint(uint256 tokenId, address to, uint256 quantity, bytes calldata data) public {\n        require(creators[tokenId] == msg.sender || minters[tokenId][msg.sender], \"You are not the creator or minter of this NFT.\");\n        require(_isTokenIdExist(tokenId), \"Token is is not exist.\");\n        require(tokenMaxQuantityWithId[tokenId] >= tokenQuantityWithId[tokenId] + quantity, \"NFT quantity is greater than max supply.\");\n        if (!address(msg.sender).isContract()) {\n            require(mintManuallyQuantityWithId[tokenId] >= quantity, \"You mint too many cards manually\" );\n            mintManuallyQuantityWithId[tokenId] = mintManuallyQuantityWithId[tokenId].sub(quantity);\n        }\n        _mint(to, tokenId, quantity, data);\n        tokenQuantityWithId[tokenId] = tokenQuantityWithId[tokenId].add(quantity);\n        emit Mint(tokenId, to, quantity, data, tokenMaxQuantityWithId[tokenId], tokenQuantityWithId[tokenId]);\n    }","contract":"MomijiToken","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"MomijiToken","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"MomijiToken","time":0},{"type":"external-function ","before":"function burnBatch(address account, uint256[] memory ids, uint256[] memory values) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }","after":"function burnBatch(address account, uint256[] calldata ids, uint256[] calldata values) public virtual {\n        require(\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        _burnBatch(account, ids, values);\n    }","contract":"MomijiToken","time":0}]}