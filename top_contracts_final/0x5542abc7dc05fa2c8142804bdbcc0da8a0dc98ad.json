{"time":202,"results":[{"type":"external-function ","before":"function mintAndSell721(\r\n    uint256 vaultId, \r\n    uint256[] memory ids, \r\n    uint256 minWethOut, \r\n    address[] calldata path,\r\n    address to\r\n  ) public nonReentrant {\r\n    require(to != address(0));\r\n    require(ids.length != 0);\r\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\r\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);\r\n    emit Sell(ids.length, amounts[1], to);\r\n  }","after":"function mintAndSell721(\r\n    uint256 vaultId, \r\n    uint256[] calldata ids, \r\n    uint256 minWethOut, \r\n    address[] calldata path,\r\n    address to\r\n  ) public nonReentrant {\r\n    require(to != address(0));\r\n    require(ids.length != 0);\r\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\r\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultBalance, path, to);\r\n    emit Sell(ids.length, amounts[1], to);\r\n  }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function mintAndSell721WETH(\r\n    uint256 vaultId, \r\n    uint256[] memory ids, \r\n    uint256 minWethOut, \r\n    address[] calldata path,\r\n    address to\r\n  ) public nonReentrant {\r\n    require(to != address(0));\r\n    require(ids.length != 0);\r\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\r\n    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);\r\n    emit Sell(ids.length, amounts[1], to);\r\n  }","after":"function mintAndSell721WETH(\r\n    uint256 vaultId, \r\n    uint256[] calldata ids, \r\n    uint256 minWethOut, \r\n    address[] calldata path,\r\n    address to\r\n  ) public nonReentrant {\r\n    require(to != address(0));\r\n    require(ids.length != 0);\r\n    (address vault, uint256 vaultBalance) = _mint721(vaultId, ids);\r\n    uint256[] memory amounts = _sellVaultTokenWETH(vault, minWethOut, vaultBalance, path, to);\r\n    emit Sell(ids.length, amounts[1], to);\r\n  }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function buyAndSwap721(\r\n    uint256 vaultId, \r\n    uint256[] memory idsIn, \r\n    uint256[] memory specificIds, \r\n    address[] calldata path,\r\n    address to\r\n  ) public payable nonReentrant {\r\n    require(to != address(0));\r\n    require(idsIn.length != 0);\r\n    WETH.deposit{value: msg.value}();\r\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\r\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\r\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\r\n    );\r\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\r\n    _swap721(vaultId, idsIn, specificIds, to);\r\n\r\n    emit Swap(idsIn.length, amounts[0], to);\r\n\r\n    // Return extras.\r\n    uint256 remaining = WETH.balanceOf(address(this));\r\n    WETH.withdraw(remaining);\r\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\r\n    require(success, \"Address: unable to send value, recipient may have reverted\");\r\n  }","after":"function buyAndSwap721(\r\n    uint256 vaultId, \r\n    uint256[] calldata idsIn, \r\n    uint256[] calldata specificIds, \r\n    address[] calldata path,\r\n    address to\r\n  ) public payable nonReentrant {\r\n    require(to != address(0));\r\n    require(idsIn.length != 0);\r\n    WETH.deposit{value: msg.value}();\r\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\r\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\r\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\r\n    );\r\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\r\n    _swap721(vaultId, idsIn, specificIds, to);\r\n\r\n    emit Swap(idsIn.length, amounts[0], to);\r\n\r\n    // Return extras.\r\n    uint256 remaining = WETH.balanceOf(address(this));\r\n    WETH.withdraw(remaining);\r\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\r\n    require(success, \"Address: unable to send value, recipient may have reverted\");\r\n  }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function buyAndSwap721WETH(\r\n    uint256 vaultId, \r\n    uint256[] memory idsIn, \r\n    uint256[] memory specificIds, \r\n    uint256 maxWethIn, \r\n    address[] calldata path,\r\n    address to\r\n  ) public nonReentrant {\r\n    require(to != address(0));\r\n    require(idsIn.length != 0);\r\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\r\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\r\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\r\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\r\n    );\r\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\r\n    _swap721(vaultId, idsIn, specificIds, to);\r\n\r\n    emit Swap(idsIn.length, amounts[0], to);\r\n\r\n    // Return extras.\r\n    uint256 remaining = WETH.balanceOf(address(this));\r\n    WETH.transfer(to, remaining);\r\n  }","after":"function buyAndSwap721WETH(\r\n    uint256 vaultId, \r\n    uint256[] calldata idsIn, \r\n    uint256[] calldata specificIds, \r\n    uint256 maxWethIn, \r\n    address[] calldata path,\r\n    address to\r\n  ) public nonReentrant {\r\n    require(to != address(0));\r\n    require(idsIn.length != 0);\r\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\r\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\r\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\r\n        vault.randomSwapFee() * (idsIn.length - specificIds.length)\r\n    );\r\n    uint256[] memory amounts = _buyVaultToken(address(vault), redeemFees, maxWethIn, path);\r\n    _swap721(vaultId, idsIn, specificIds, to);\r\n\r\n    emit Swap(idsIn.length, amounts[0], to);\r\n\r\n    // Return extras.\r\n    uint256 remaining = WETH.balanceOf(address(this));\r\n    WETH.transfer(to, remaining);\r\n  }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function buyAndSwap1155(\r\n    uint256 vaultId, \r\n    uint256[] memory idsIn, \r\n    uint256[] memory amounts, \r\n    uint256[] memory specificIds, \r\n    address[] calldata path,\r\n    address to\r\n  ) public payable nonReentrant {\r\n    require(to != address(0));\r\n    require(idsIn.length != 0);\r\n    WETH.deposit{value: msg.value}();\r\n    uint256 count;\r\n    for (uint256 i = 0; i < idsIn.length; i++) {\r\n        uint256 amount = amounts[i];\r\n        require(amount > 0, \"Transferring < 1\");\r\n        count += amount;\r\n    }\r\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\r\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\r\n        vault.randomSwapFee() * (count - specificIds.length)\r\n    );\r\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\r\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\r\n\r\n    emit Swap(count, swapAmounts[0], to);\r\n\r\n    // Return extras.\r\n    uint256 remaining = WETH.balanceOf(address(this));\r\n    WETH.withdraw(remaining);\r\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\r\n    require(success, \"Address: unable to send value, recipient may have reverted\");\r\n  }","after":"function buyAndSwap1155(\r\n    uint256 vaultId, \r\n    uint256[] calldata idsIn, \r\n    uint256[] calldata amounts, \r\n    uint256[] calldata specificIds, \r\n    address[] calldata path,\r\n    address to\r\n  ) public payable nonReentrant {\r\n    require(to != address(0));\r\n    require(idsIn.length != 0);\r\n    WETH.deposit{value: msg.value}();\r\n    uint256 count;\r\n    for (uint256 i = 0; i < idsIn.length; i++) {\r\n        uint256 amount = amounts[i];\r\n        require(amount > 0, \"Transferring < 1\");\r\n        count += amount;\r\n    }\r\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\r\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\r\n        vault.randomSwapFee() * (count - specificIds.length)\r\n    );\r\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\r\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\r\n\r\n    emit Swap(count, swapAmounts[0], to);\r\n\r\n    // Return extras.\r\n    uint256 remaining = WETH.balanceOf(address(this));\r\n    WETH.withdraw(remaining);\r\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\r\n    require(success, \"Address: unable to send value, recipient may have reverted\");\r\n  }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function buyAndSwap1155WETH(\r\n    uint256 vaultId, \r\n    uint256[] memory idsIn, \r\n    uint256[] memory amounts, \r\n    uint256[] memory specificIds, \r\n    uint256 maxWethIn, \r\n    address[] calldata path,\r\n    address to\r\n  ) public payable nonReentrant {\r\n    require(to != address(0));\r\n    require(idsIn.length != 0);\r\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\r\n    uint256 count;\r\n    for (uint256 i = 0; i < idsIn.length; i++) {\r\n        uint256 amount = amounts[i];\r\n        require(amount > 0, \"Transferring < 1\");\r\n        count += amount;\r\n    }\r\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\r\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\r\n        vault.randomSwapFee() * (count - specificIds.length)\r\n    );\r\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\r\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\r\n\r\n    emit Swap(count, swapAmounts[0], to);\r\n\r\n    // Return extras.\r\n    uint256 remaining = WETH.balanceOf(address(this));\r\n    WETH.transfer(to, remaining);\r\n  }","after":"function buyAndSwap1155WETH(\r\n    uint256 vaultId, \r\n    uint256[] calldata idsIn, \r\n    uint256[] calldata amounts, \r\n    uint256[] calldata specificIds, \r\n    uint256 maxWethIn, \r\n    address[] calldata path,\r\n    address to\r\n  ) public payable nonReentrant {\r\n    require(to != address(0));\r\n    require(idsIn.length != 0);\r\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\r\n    uint256 count;\r\n    for (uint256 i = 0; i < idsIn.length; i++) {\r\n        uint256 amount = amounts[i];\r\n        require(amount > 0, \"Transferring < 1\");\r\n        count += amount;\r\n    }\r\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\r\n    uint256 redeemFees = (vault.targetSwapFee() * specificIds.length) + (\r\n        vault.randomSwapFee() * (count - specificIds.length)\r\n    );\r\n    uint256[] memory swapAmounts = _buyVaultToken(address(vault), redeemFees, msg.value, path);\r\n    _swap1155(vaultId, idsIn, amounts, specificIds, to);\r\n\r\n    emit Swap(count, swapAmounts[0], to);\r\n\r\n    // Return extras.\r\n    uint256 remaining = WETH.balanceOf(address(this));\r\n    WETH.transfer(to, remaining);\r\n  }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function buyAndRedeem(\r\n    uint256 vaultId, \r\n    uint256 amount,\r\n    uint256[] memory specificIds, \r\n    address[] calldata path,\r\n    address to\r\n  ) public payable nonReentrant {\r\n    require(to != address(0));\r\n    require(amount != 0);\r\n    WETH.deposit{value: msg.value}();\r\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\r\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\r\n        vault.randomRedeemFee() * (amount - specificIds.length)\r\n    );\r\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);\r\n    _redeem(vaultId, amount, specificIds, to);\r\n\r\n    emit Buy(amount, amounts[0], to);\r\n\r\n    uint256 remaining = WETH.balanceOf(address(this));\r\n    WETH.withdraw(remaining);\r\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\r\n    require(success, \"Address: unable to send value, recipient may have reverted\");\r\n  }","after":"function buyAndRedeem(\r\n    uint256 vaultId, \r\n    uint256 amount,\r\n    uint256[] calldata specificIds, \r\n    address[] calldata path,\r\n    address to\r\n  ) public payable nonReentrant {\r\n    require(to != address(0));\r\n    require(amount != 0);\r\n    WETH.deposit{value: msg.value}();\r\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\r\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\r\n        vault.randomRedeemFee() * (amount - specificIds.length)\r\n    );\r\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE)+totalFee, msg.value, path);\r\n    _redeem(vaultId, amount, specificIds, to);\r\n\r\n    emit Buy(amount, amounts[0], to);\r\n\r\n    uint256 remaining = WETH.balanceOf(address(this));\r\n    WETH.withdraw(remaining);\r\n    (bool success, ) = payable(to).call{value: remaining}(\"\");\r\n    require(success, \"Address: unable to send value, recipient may have reverted\");\r\n  }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function buyAndRedeemWETH(\r\n    uint256 vaultId, \r\n    uint256 amount,\r\n    uint256[] memory specificIds, \r\n    uint256 maxWethIn, \r\n    address[] calldata path,\r\n    address to\r\n  ) public nonReentrant {\r\n    require(to != address(0));\r\n    require(amount != 0);\r\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\r\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\r\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\r\n        vault.randomRedeemFee() * (amount - specificIds.length)\r\n    );\r\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);\r\n    _redeem(vaultId, amount, specificIds, to);\r\n\r\n    emit Buy(amount, amounts[0], to);\r\n\r\n    uint256 remaining = WETH.balanceOf(address(this));\r\n    WETH.transfer(to, remaining);\r\n  }","after":"function buyAndRedeemWETH(\r\n    uint256 vaultId, \r\n    uint256 amount,\r\n    uint256[] calldata specificIds, \r\n    uint256 maxWethIn, \r\n    address[] calldata path,\r\n    address to\r\n  ) public nonReentrant {\r\n    require(to != address(0));\r\n    require(amount != 0);\r\n    IERC20Upgradeable(address(WETH)).transferFrom(msg.sender, address(this), maxWethIn);\r\n    INFTXVault vault = INFTXVault(nftxFactory.vault(vaultId));\r\n    uint256 totalFee = (vault.targetRedeemFee() * specificIds.length) + (\r\n        vault.randomRedeemFee() * (amount - specificIds.length)\r\n    );\r\n    uint256[] memory amounts = _buyVaultToken(address(vault), (amount*BASE) + totalFee, maxWethIn, path);\r\n    _redeem(vaultId, amount, specificIds, to);\r\n\r\n    emit Buy(amount, amounts[0], to);\r\n\r\n    uint256 remaining = WETH.balanceOf(address(this));\r\n    WETH.transfer(to, remaining);\r\n  }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function mintAndSell1155(\r\n    uint256 vaultId, \r\n    uint256[] memory ids, \r\n    uint256[] memory amounts,\r\n    uint256 minWethOut, \r\n    address[] calldata path,\r\n    address to\r\n  ) public nonReentrant {\r\n    require(to != address(0));\r\n    require(ids.length != 0);\r\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\r\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);\r\n\r\n    uint256 count;\r\n    for (uint256 i = 0; i < ids.length; i++) {\r\n        count += amounts[i];\r\n    }\r\n    emit Sell(count, amounts[1], to);\r\n  }","after":"function mintAndSell1155(\r\n    uint256 vaultId, \r\n    uint256[] calldata ids, \r\n    uint256[] memory amounts,\r\n    uint256 minWethOut, \r\n    address[] calldata path,\r\n    address to\r\n  ) public nonReentrant {\r\n    require(to != address(0));\r\n    require(ids.length != 0);\r\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\r\n    uint256[] memory amounts = _sellVaultTokenETH(vault, minWethOut, vaultTokenBalance, path, to);\r\n\r\n    uint256 count;\r\n    for (uint256 i = 0; i < ids.length; i++) {\r\n        count += amounts[i];\r\n    }\r\n    emit Sell(count, amounts[1], to);\r\n  }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function mintAndSell1155WETH(\r\n    uint256 vaultId, \r\n    uint256[] memory ids, \r\n    uint256[] memory amounts,\r\n    uint256 minWethOut, \r\n    address[] calldata path,\r\n    address to\r\n  ) public nonReentrant {\r\n    require(to != address(0));\r\n    require(ids.length != 0);\r\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\r\n    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);\r\n\r\n    uint256 count;\r\n    for (uint256 i = 0; i < ids.length; i++) {\r\n        count += amounts[i];\r\n    }\r\n    emit Sell(count, amounts[1], to);\r\n  }","after":"function mintAndSell1155WETH(\r\n    uint256 vaultId, \r\n    uint256[] calldata ids, \r\n    uint256[] calldata amounts,\r\n    uint256 minWethOut, \r\n    address[] calldata path,\r\n    address to\r\n  ) public nonReentrant {\r\n    require(to != address(0));\r\n    require(ids.length != 0);\r\n    (address vault, uint256 vaultTokenBalance) = _mint1155(vaultId, ids, amounts);\r\n    _sellVaultTokenWETH(vault, minWethOut, vaultTokenBalance, path, to);\r\n\r\n    uint256 count;\r\n    for (uint256 i = 0; i < ids.length; i++) {\r\n        count += amounts[i];\r\n    }\r\n    emit Sell(count, amounts[1], to);\r\n  }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }","after":"function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes calldata\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }","after":"function onERC1155Received(address, address, uint256, uint256, bytes calldata) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }","contract":"NFTXMarketplaceZap","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }","after":"function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }","contract":"NFTXMarketplaceZap","time":0}]}