{"time":138,"results":[{"type":"struct-data-arrangement ","before":"\naddress sender\nuint value\nbytes data\nbytes4 sig","after":"uint value\nbytes data\naddress sender\nbytes4 sig\n","contract":"ERC223Receiver","time":0},{"type":"state-data-arrangement ","before":"\nbyte public constant EIP191_VERSION_DATA = byte(0);\nbyte public constant EIP191_PREFIX = byte(0x19);\nstring public constant VERSION = \"1.1.0\";\naddress public constant COMPOSITE_PLACEHOLDER = address(1);\nuint256 public constant AUTH_VERSION_INCREMENTOR = (1 << 160);\nuint256 public authVersion;\nmapping(uint256 => uint256) public authorizations;\nmapping(address => uint256) public nonces;\nmapping(bytes4 => address) public delegates;\naddress public recoveryAddress;\nbool public initialized;","after":"string public constant VERSION = \"1.1.0\";\nuint256 public constant AUTH_VERSION_INCREMENTOR = (1 << 160);\nuint256 public authVersion;\nmapping(uint256 => uint256) public authorizations;\nmapping(address => uint256) public nonces;\nmapping(bytes4 => address) public delegates;\naddress public constant COMPOSITE_PLACEHOLDER = address(1);\naddress public recoveryAddress;\nbyte public constant EIP191_VERSION_DATA = byte(0);\nbyte public constant EIP191_PREFIX = byte(0x19);\nbool public initialized;\n","contract":"CoreWallet","time":0},{"type":"external-function ","before":"function init2(bytes memory _authorizedAddresses, uint256 _cosigner, address _recoveryAddress) public onlyOnce {\n        address[] memory addresses = bytesToAddresses(_authorizedAddresses);\n        for (uint i=0; i < addresses.length; i++) {\n            address _authorizedAddress = addresses[i];\n            require(_authorizedAddress != _recoveryAddress, \"Do not use the recovery address as an authorized address.\");\n            require(address(_cosigner) != _recoveryAddress, \"Do not use the recovery address as a cosigner.\");\n            require(_authorizedAddress != address(0), \"Authorized addresses must not be zero.\");\n            require(address(_cosigner) != address(0), \"Initial cosigner must not be zero.\");\n\n            recoveryAddress = _recoveryAddress;\n            // set initial authorization value\n            authVersion = AUTH_VERSION_INCREMENTOR;\n            // add initial authorized address\n            authorizations[authVersion + uint256(_authorizedAddress)] = _cosigner;\n\n            emit Authorized(_authorizedAddress, _cosigner);\n        }\n    }","after":"function init2(bytes calldata _authorizedAddresses, uint256 _cosigner, address _recoveryAddress) public onlyOnce {\n        address[] memory addresses = bytesToAddresses(_authorizedAddresses);\n        for (uint i=0; i < addresses.length; i++) {\n            address _authorizedAddress = addresses[i];\n            require(_authorizedAddress != _recoveryAddress, \"Do not use the recovery address as an authorized address.\");\n            require(address(_cosigner) != _recoveryAddress, \"Do not use the recovery address as a cosigner.\");\n            require(_authorizedAddress != address(0), \"Authorized addresses must not be zero.\");\n            require(address(_cosigner) != address(0), \"Initial cosigner must not be zero.\");\n\n            recoveryAddress = _recoveryAddress;\n            // set initial authorization value\n            authVersion = AUTH_VERSION_INCREMENTOR;\n            // add initial authorized address\n            authorizations[authVersion + uint256(_authorizedAddress)] = _cosigner;\n\n            emit Authorized(_authorizedAddress, _cosigner);\n        }\n    }","contract":"CloneableWallet","time":0},{"type":"external-function ","before":"function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes memory _data\n    )\n        public\n        returns(bytes4)\n    {\n        _operator;\n        _from;\n        _tokenId;\n        _data;\n\n        // emit ERC721Received(_operator, _from, _tokenId, _data, gasleft());\n\n        return ERC721_RECEIVED_FINAL;\n    }","after":"function onERC721Received(\n        address _operator,\n        address _from,\n        uint256 _tokenId,\n        bytes calldata _data\n    )\n        public\n        returns(bytes4)\n    {\n        _operator;\n        _from;\n        _tokenId;\n        _data;\n\n        // emit ERC721Received(_operator, _from, _tokenId, _data, gasleft());\n\n        return ERC721_RECEIVED_FINAL;\n    }","contract":"CloneableWallet","time":0},{"type":"external-function ","before":"function deployCloneWallet2WithMultiAuthorizedAddress(\n            address _recoveryAddress,\n            bytes memory _authorizedAddresses,\n            uint256 _cosigner,\n            bytes32 _salt\n        )\n            public\n        {\n            require(_authorizedAddresses.length / 20 > 0 && _authorizedAddresses.length % 20 == 0, \"invalid address byte array\");\n            address[] memory addresses = bytesToAddresses(_authorizedAddresses);\n\n            // calculate our own salt based off of args\n            bytes32 salt = keccak256(abi.encodePacked(_salt, addresses[0], _cosigner, _recoveryAddress));\n            // create the clone counterfactually\n            address payable clone = createClone2(cloneWalletAddress, salt);\n            // ensure we get an address\n            require(clone != address(0), \"wallet must have address\");\n\n            // check size\n            uint256 size;\n            // note this takes an additional 700 gas\n            assembly {\n                size := extcodesize(clone)\n            }\n\n            require(size > 0, \"wallet must have code\");\n\n            // init the clone\n            CloneableWallet(clone).init2(_authorizedAddresses, _cosigner, _recoveryAddress);\n            // emit event\n            emit WalletCreated(clone, addresses[0], false);\n        }","after":"function deployCloneWallet2WithMultiAuthorizedAddress(\n            address _recoveryAddress,\n            bytes calldata _authorizedAddresses,\n            uint256 _cosigner,\n            bytes32 _salt\n        )\n            public\n        {\n            require(_authorizedAddresses.length / 20 > 0 && _authorizedAddresses.length % 20 == 0, \"invalid address byte array\");\n            address[] memory addresses = bytesToAddresses(_authorizedAddresses);\n\n            // calculate our own salt based off of args\n            bytes32 salt = keccak256(abi.encodePacked(_salt, addresses[0], _cosigner, _recoveryAddress));\n            // create the clone counterfactually\n            address payable clone = createClone2(cloneWalletAddress, salt);\n            // ensure we get an address\n            require(clone != address(0), \"wallet must have address\");\n\n            // check size\n            uint256 size;\n            // note this takes an additional 700 gas\n            assembly {\n                size := extcodesize(clone)\n            }\n\n            require(size > 0, \"wallet must have code\");\n\n            // init the clone\n            CloneableWallet(clone).init2(_authorizedAddresses, _cosigner, _recoveryAddress);\n            // emit event\n            emit WalletCreated(clone, addresses[0], false);\n        }","contract":"WalletFactory","time":0}]}