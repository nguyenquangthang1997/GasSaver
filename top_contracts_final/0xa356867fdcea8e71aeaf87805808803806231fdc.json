{"time":333,"results":[{"type":"external-function ","before":"function init(address owner, address[] memory proxies) external {\n        initOwner(owner);\n        for(uint i = 0; i < proxies.length; i++) \n            _IS_ALLOWED_PROXY_[proxies[i]] = true;\n    }","after":"function init(address owner, address[] calldata proxies) external {\n        initOwner(owner);\n        for(uint i = 0; i < proxies.length; i++) \n            _IS_ALLOWED_PROXY_[proxies[i]] = true;\n    }","contract":"DODOApproveProxy","time":0},{"type":"external-function ","before":"function resetDODOPrivatePool(\n        address dppAddress,\n        uint256[] memory paramList,  //0 - newLpFeeRate, 1 - newI, 2 - newK\n        uint256[] memory amountList, //0 - baseInAmount, 1 - quoteInAmount, 2 - baseOutAmount, 3- quoteOutAmount\n        uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH, 3 - baseOutETH, 4 - quoteOutETH\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve,\n        uint256 deadLine\n    ) external override payable preventReentrant judgeExpired(deadLine) {\n        _deposit(\n            msg.sender,\n            dppAddress,\n            IDODOV2(dppAddress)._BASE_TOKEN_(),\n            amountList[0],\n            flag == 1\n        );\n        _deposit(\n            msg.sender,\n            dppAddress,\n            IDODOV2(dppAddress)._QUOTE_TOKEN_(),\n            amountList[1],\n            flag == 2\n        );\n\n        require(IDODOV2(IDODOV2(dppAddress)._OWNER_()).reset(\n            msg.sender,\n            paramList[0],\n            paramList[1],\n            paramList[2],\n            amountList[2],\n            amountList[3],\n            minBaseReserve,\n            minQuoteReserve\n        ), \"Reset Failed\");\n\n        _withdraw(msg.sender, IDODOV2(dppAddress)._BASE_TOKEN_(), amountList[2], flag == 3);\n        _withdraw(msg.sender, IDODOV2(dppAddress)._QUOTE_TOKEN_(), amountList[3], flag == 4);\n    }","after":"function resetDODOPrivatePool(\n        address dppAddress,\n        uint256[] calldata paramList,  //0 - newLpFeeRate, 1 - newI, 2 - newK\n        uint256[] calldata amountList, //0 - baseInAmount, 1 - quoteInAmount, 2 - baseOutAmount, 3- quoteOutAmount\n        uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH, 3 - baseOutETH, 4 - quoteOutETH\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve,\n        uint256 deadLine\n    ) external override payable preventReentrant judgeExpired(deadLine) {\n        _deposit(\n            msg.sender,\n            dppAddress,\n            IDODOV2(dppAddress)._BASE_TOKEN_(),\n            amountList[0],\n            flag == 1\n        );\n        _deposit(\n            msg.sender,\n            dppAddress,\n            IDODOV2(dppAddress)._QUOTE_TOKEN_(),\n            amountList[1],\n            flag == 2\n        );\n\n        require(IDODOV2(IDODOV2(dppAddress)._OWNER_()).reset(\n            msg.sender,\n            paramList[0],\n            paramList[1],\n            paramList[2],\n            amountList[2],\n            amountList[3],\n            minBaseReserve,\n            minQuoteReserve\n        ), \"Reset Failed\");\n\n        _withdraw(msg.sender, IDODOV2(dppAddress)._BASE_TOKEN_(), amountList[2], flag == 3);\n        _withdraw(msg.sender, IDODOV2(dppAddress)._QUOTE_TOKEN_(), amountList[3], flag == 4);\n    }","contract":"DODOV2Proxy02","time":0},{"type":"external-function ","before":"function dodoSwapV2ETHToToken(\n        address toToken,\n        uint256 minReturnAmount,\n        address[] memory dodoPairs,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    )\n        external\n        override\n        payable\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n        uint256 originGas = gasleft();\n        \n        uint256 originToTokenBalance = IERC20(toToken).balanceOf(msg.sender);\n        IWETH(_WETH_).deposit{value: msg.value}();\n        IWETH(_WETH_).transfer(dodoPairs[0], msg.value);\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n            if (i == dodoPairs.length - 1) {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(msg.sender);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(msg.sender);\n                }\n            } else {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n                }\n            }\n            directions = directions >> 1;\n        }\n\n        returnAmount = IERC20(toToken).balanceOf(msg.sender).sub(originToTokenBalance);\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n        _dodoGasReturn(originGas);\n\n        _execIncentive(isIncentive, _ETH_ADDRESS_, toToken);\n\n        emit OrderHistory(\n            _ETH_ADDRESS_,\n            toToken,\n            msg.sender,\n            msg.value,\n            returnAmount\n        );\n    }","after":"function dodoSwapV2ETHToToken(\n        address toToken,\n        uint256 minReturnAmount,\n        address[] calldata dodoPairs,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    )\n        external\n        override\n        payable\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n        uint256 originGas = gasleft();\n        \n        uint256 originToTokenBalance = IERC20(toToken).balanceOf(msg.sender);\n        IWETH(_WETH_).deposit{value: msg.value}();\n        IWETH(_WETH_).transfer(dodoPairs[0], msg.value);\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n            if (i == dodoPairs.length - 1) {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(msg.sender);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(msg.sender);\n                }\n            } else {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n                }\n            }\n            directions = directions >> 1;\n        }\n\n        returnAmount = IERC20(toToken).balanceOf(msg.sender).sub(originToTokenBalance);\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n        _dodoGasReturn(originGas);\n\n        _execIncentive(isIncentive, _ETH_ADDRESS_, toToken);\n\n        emit OrderHistory(\n            _ETH_ADDRESS_,\n            toToken,\n            msg.sender,\n            msg.value,\n            returnAmount\n        );\n    }","contract":"DODOV2Proxy02","time":0},{"type":"external-function ","before":"function dodoSwapV2TokenToETH(\n        address fromToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory dodoPairs,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    )\n        external\n        override\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n        uint256 originGas = gasleft();\n        \n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(fromToken, msg.sender, dodoPairs[0], fromTokenAmount);\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n            if (i == dodoPairs.length - 1) {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(address(this));\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(address(this));\n                }\n            } else {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n                }\n            }\n            directions = directions >> 1;\n        }\n        returnAmount = IWETH(_WETH_).balanceOf(address(this));\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n        IWETH(_WETH_).withdraw(returnAmount);\n        msg.sender.transfer(returnAmount);\n\n        _dodoGasReturn(originGas);\n\n        _execIncentive(isIncentive, fromToken, _ETH_ADDRESS_);\n\n        emit OrderHistory(\n            fromToken,\n            _ETH_ADDRESS_,\n            msg.sender,\n            fromTokenAmount,\n            returnAmount\n        );\n    }","after":"function dodoSwapV2TokenToETH(\n        address fromToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] calldata dodoPairs,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    )\n        external\n        override\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n        uint256 originGas = gasleft();\n        \n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(fromToken, msg.sender, dodoPairs[0], fromTokenAmount);\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n            if (i == dodoPairs.length - 1) {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(address(this));\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(address(this));\n                }\n            } else {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n                }\n            }\n            directions = directions >> 1;\n        }\n        returnAmount = IWETH(_WETH_).balanceOf(address(this));\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n        IWETH(_WETH_).withdraw(returnAmount);\n        msg.sender.transfer(returnAmount);\n\n        _dodoGasReturn(originGas);\n\n        _execIncentive(isIncentive, fromToken, _ETH_ADDRESS_);\n\n        emit OrderHistory(\n            fromToken,\n            _ETH_ADDRESS_,\n            msg.sender,\n            fromTokenAmount,\n            returnAmount\n        );\n    }","contract":"DODOV2Proxy02","time":0},{"type":"external-function ","before":"function dodoSwapV2TokenToToken(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory dodoPairs,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    )\n        external\n        override\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n        uint256 originGas = gasleft();\n\n        uint256 originToTokenBalance = IERC20(toToken).balanceOf(msg.sender);\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(fromToken, msg.sender, dodoPairs[0], fromTokenAmount);\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n            if (i == dodoPairs.length - 1) {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(msg.sender);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(msg.sender);\n                }\n            } else {\n                if (directions& 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n                }\n            }\n            directions = directions >> 1;\n        }\n        returnAmount = IERC20(toToken).balanceOf(msg.sender).sub(originToTokenBalance);\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n        \n        _dodoGasReturn(originGas);\n\n        _execIncentive(isIncentive, fromToken, toToken);\n\n        emit OrderHistory(\n            fromToken,\n            toToken,\n            msg.sender,\n            fromTokenAmount,\n            returnAmount\n        );\n    }","after":"function dodoSwapV2TokenToToken(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] calldata dodoPairs,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    )\n        external\n        override\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n        uint256 originGas = gasleft();\n\n        uint256 originToTokenBalance = IERC20(toToken).balanceOf(msg.sender);\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(fromToken, msg.sender, dodoPairs[0], fromTokenAmount);\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n            if (i == dodoPairs.length - 1) {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(msg.sender);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(msg.sender);\n                }\n            } else {\n                if (directions& 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n                }\n            }\n            directions = directions >> 1;\n        }\n        returnAmount = IERC20(toToken).balanceOf(msg.sender).sub(originToTokenBalance);\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n        \n        _dodoGasReturn(originGas);\n\n        _execIncentive(isIncentive, fromToken, toToken);\n\n        emit OrderHistory(\n            fromToken,\n            toToken,\n            msg.sender,\n            fromTokenAmount,\n            returnAmount\n        );\n    }","contract":"DODOV2Proxy02","time":0},{"type":"external-function ","before":"function externalSwap(\n        address fromToken,\n        address toToken,\n        address approveTarget,\n        address swapTarget,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        bytes memory callDataConcat,\n        bool isIncentive,\n        uint256 deadLine\n    )\n        external\n        override\n        payable\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n        require(fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\n        require(toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\n        \n        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);\n        if (fromToken != _ETH_ADDRESS_) {\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n                fromToken,\n                msg.sender,\n                address(this),\n                fromTokenAmount\n            );\n            IERC20(fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n        }\n\n        require(isWhiteListed[swapTarget], \"DODOV2Proxy02: Not Whitelist Contract\");\n        (bool success, ) = swapTarget.call{value: fromToken == _ETH_ADDRESS_ ? msg.value : 0}(callDataConcat);\n\n        require(success, \"DODOV2Proxy02: External Swap execution Failed\");\n\n        IERC20(toToken).universalTransfer(\n            msg.sender,\n            IERC20(toToken).universalBalanceOf(address(this))\n        );\n\n        returnAmount = IERC20(toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n        _externalGasReturn();\n\n        _execIncentive(isIncentive, fromToken, toToken);\n\n        emit OrderHistory(\n            fromToken,\n            toToken,\n            msg.sender,\n            fromTokenAmount,\n            returnAmount\n        );\n    }","after":"function externalSwap(\n        address fromToken,\n        address toToken,\n        address approveTarget,\n        address swapTarget,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        bytes calldata callDataConcat,\n        bool isIncentive,\n        uint256 deadLine\n    )\n        external\n        override\n        payable\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n        require(fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\n        require(toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\n        \n        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);\n        if (fromToken != _ETH_ADDRESS_) {\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n                fromToken,\n                msg.sender,\n                address(this),\n                fromTokenAmount\n            );\n            IERC20(fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n        }\n\n        require(isWhiteListed[swapTarget], \"DODOV2Proxy02: Not Whitelist Contract\");\n        (bool success, ) = swapTarget.call{value: fromToken == _ETH_ADDRESS_ ? msg.value : 0}(callDataConcat);\n\n        require(success, \"DODOV2Proxy02: External Swap execution Failed\");\n\n        IERC20(toToken).universalTransfer(\n            msg.sender,\n            IERC20(toToken).universalBalanceOf(address(this))\n        );\n\n        returnAmount = IERC20(toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n        _externalGasReturn();\n\n        _execIncentive(isIncentive, fromToken, toToken);\n\n        emit OrderHistory(\n            fromToken,\n            toToken,\n            msg.sender,\n            fromTokenAmount,\n            returnAmount\n        );\n    }","contract":"DODOV2Proxy02","time":0},{"type":"external-function ","before":"function dodoSwapV1(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory dodoPairs,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    )\n        external\n        override\n        payable\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n        require(fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\n        require(toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\n        \n        uint256 originGas = gasleft();\n\n        address _fromToken = fromToken;\n        address _toToken = toToken;\n        \n        _deposit(msg.sender, address(this), _fromToken, fromTokenAmount, _fromToken == _ETH_ADDRESS_);\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n            address curDodoPair = dodoPairs[i];\n            if (directions & 1 == 0) {\n                address curDodoBase = IDODOV1(curDodoPair)._BASE_TOKEN_();\n                require(curDodoBase != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_CHI\");\n                uint256 curAmountIn = IERC20(curDodoBase).balanceOf(address(this));\n                IERC20(curDodoBase).universalApproveMax(curDodoPair, curAmountIn);\n                IDODOV1(curDodoPair).sellBaseToken(curAmountIn, 0, \"\");\n            } else {\n                address curDodoQuote = IDODOV1(curDodoPair)._QUOTE_TOKEN_();\n                require(curDodoQuote != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_CHI\");\n                uint256 curAmountIn = IERC20(curDodoQuote).balanceOf(address(this));\n                IERC20(curDodoQuote).universalApproveMax(curDodoPair, curAmountIn);\n                uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n                    curDodoPair,\n                    curAmountIn\n                );\n                IDODOV1(curDodoPair).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\n            }\n            directions = directions >> 1;\n        }\n\n        \n        if (_toToken == _ETH_ADDRESS_) {\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n            IWETH(_WETH_).withdraw(returnAmount);\n        } else {\n            returnAmount = IERC20(_toToken).tokenBalanceOf(address(this));\n        }\n        \n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n        IERC20(_toToken).universalTransfer(msg.sender, returnAmount);\n\n        _dodoGasReturn(originGas);\n\n        _execIncentive(isIncentive, _fromToken, _toToken);\n\n        emit OrderHistory(_fromToken, _toToken, msg.sender, fromTokenAmount, returnAmount);\n    }","after":"function dodoSwapV1(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] calldata dodoPairs,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    )\n        external\n        override\n        payable\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n        require(fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\n        require(toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\n        \n        uint256 originGas = gasleft();\n\n        address _fromToken = fromToken;\n        address _toToken = toToken;\n        \n        _deposit(msg.sender, address(this), _fromToken, fromTokenAmount, _fromToken == _ETH_ADDRESS_);\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n            address curDodoPair = dodoPairs[i];\n            if (directions & 1 == 0) {\n                address curDodoBase = IDODOV1(curDodoPair)._BASE_TOKEN_();\n                require(curDodoBase != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_CHI\");\n                uint256 curAmountIn = IERC20(curDodoBase).balanceOf(address(this));\n                IERC20(curDodoBase).universalApproveMax(curDodoPair, curAmountIn);\n                IDODOV1(curDodoPair).sellBaseToken(curAmountIn, 0, \"\");\n            } else {\n                address curDodoQuote = IDODOV1(curDodoPair)._QUOTE_TOKEN_();\n                require(curDodoQuote != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_CHI\");\n                uint256 curAmountIn = IERC20(curDodoQuote).balanceOf(address(this));\n                IERC20(curDodoQuote).universalApproveMax(curDodoPair, curAmountIn);\n                uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n                    curDodoPair,\n                    curAmountIn\n                );\n                IDODOV1(curDodoPair).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\n            }\n            directions = directions >> 1;\n        }\n\n        \n        if (_toToken == _ETH_ADDRESS_) {\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n            IWETH(_WETH_).withdraw(returnAmount);\n        } else {\n            returnAmount = IERC20(_toToken).tokenBalanceOf(address(this));\n        }\n        \n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n        IERC20(_toToken).universalTransfer(msg.sender, returnAmount);\n\n        _dodoGasReturn(originGas);\n\n        _execIncentive(isIncentive, _fromToken, _toToken);\n\n        emit OrderHistory(_fromToken, _toToken, msg.sender, fromTokenAmount, returnAmount);\n    }","contract":"DODOV2Proxy02","time":0},{"type":"external-function ","before":"function mixSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory mixAdapters,\n        address[] memory mixPairs,\n        address[] memory assetTo,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n        require(mixPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n        require(mixPairs.length == mixAdapters.length, \"DODOV2Proxy02: PAIR_ADAPTER_NOT_MATCH\");\n        require(mixPairs.length == assetTo.length - 1, \"DODOV2Proxy02: PAIR_ASSETTO_NOT_MATCH\");\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n        address _fromToken = fromToken;\n        address _toToken = toToken;\n        uint256 _fromTokenAmount = fromTokenAmount;\n\n        require(_fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\n        require(_toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\n        \n        uint256 originGas = gasleft();\n        uint256 toTokenOriginBalance = IERC20(_toToken).universalBalanceOf(msg.sender);\n        \n        _deposit(msg.sender, assetTo[0], _fromToken, _fromTokenAmount, _fromToken == _ETH_ADDRESS_);\n\n        for (uint256 i = 0; i < mixPairs.length; i++) {\n            if (directions & 1 == 0) {\n                IDODOAdapter(mixAdapters[i]).sellBase(assetTo[i + 1],mixPairs[i]);\n            } else {\n                IDODOAdapter(mixAdapters[i]).sellQuote(assetTo[i + 1],mixPairs[i]);\n            }\n            directions = directions >> 1;\n        }\n\n        if(_toToken == _ETH_ADDRESS_) {\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n            IWETH(_WETH_).withdraw(returnAmount);\n            msg.sender.transfer(returnAmount);\n        }else {\n            returnAmount = IERC20(_toToken).tokenBalanceOf(msg.sender).sub(toTokenOriginBalance);\n        }\n\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n        \n        _dodoGasReturn(originGas);\n\n        _execIncentive(isIncentive, _fromToken, _toToken);\n\n        emit OrderHistory(\n            _fromToken,\n            _toToken,\n            msg.sender,\n            _fromTokenAmount,\n            returnAmount\n        );\n    }","after":"function mixSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] calldata mixAdapters,\n        address[] calldata mixPairs,\n        address[] calldata assetTo,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    ) external override payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n        require(mixPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n        require(mixPairs.length == mixAdapters.length, \"DODOV2Proxy02: PAIR_ADAPTER_NOT_MATCH\");\n        require(mixPairs.length == assetTo.length - 1, \"DODOV2Proxy02: PAIR_ASSETTO_NOT_MATCH\");\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n        address _fromToken = fromToken;\n        address _toToken = toToken;\n        uint256 _fromTokenAmount = fromTokenAmount;\n\n        require(_fromToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_SELL_CHI\");\n        require(_toToken != _CHI_TOKEN_, \"DODOV2Proxy02: NOT_SUPPORT_BUY_CHI\");\n        \n        uint256 originGas = gasleft();\n        uint256 toTokenOriginBalance = IERC20(_toToken).universalBalanceOf(msg.sender);\n        \n        _deposit(msg.sender, assetTo[0], _fromToken, _fromTokenAmount, _fromToken == _ETH_ADDRESS_);\n\n        for (uint256 i = 0; i < mixPairs.length; i++) {\n            if (directions & 1 == 0) {\n                IDODOAdapter(mixAdapters[i]).sellBase(assetTo[i + 1],mixPairs[i]);\n            } else {\n                IDODOAdapter(mixAdapters[i]).sellQuote(assetTo[i + 1],mixPairs[i]);\n            }\n            directions = directions >> 1;\n        }\n\n        if(_toToken == _ETH_ADDRESS_) {\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n            IWETH(_WETH_).withdraw(returnAmount);\n            msg.sender.transfer(returnAmount);\n        }else {\n            returnAmount = IERC20(_toToken).tokenBalanceOf(msg.sender).sub(toTokenOriginBalance);\n        }\n\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n        \n        _dodoGasReturn(originGas);\n\n        _execIncentive(isIncentive, _fromToken, _toToken);\n\n        emit OrderHistory(\n            _fromToken,\n            _toToken,\n            msg.sender,\n            _fromTokenAmount,\n            returnAmount\n        );\n    }","contract":"DODOV2Proxy02","time":0},{"type":"external-function ","before":"function createCrowdPooling(\n        address baseToken,\n        address quoteToken,\n        uint256 baseInAmount,\n        uint256[] memory timeLine,\n        uint256[] memory valueList,\n        bool isOpenTWAP,\n        uint256 deadLine\n    ) external override payable preventReentrant judgeExpired(deadLine) returns (address payable newCrowdPooling) {\n        address _baseToken = baseToken;\n        address _quoteToken = quoteToken == _ETH_ADDRESS_ ? _WETH_ : quoteToken;\n        \n        newCrowdPooling = IDODOV2(_CP_FACTORY_).createCrowdPooling();\n\n        _deposit(\n            msg.sender,\n            newCrowdPooling,\n            _baseToken,\n            baseInAmount,\n            false\n        );\n\n        newCrowdPooling.transfer(msg.value);\n\n        IDODOV2(_CP_FACTORY_).initCrowdPooling(\n            newCrowdPooling,\n            msg.sender,\n            _baseToken,\n            _quoteToken,\n            timeLine,\n            valueList,\n            isOpenTWAP\n        );\n    }","after":"function createCrowdPooling(\n        address baseToken,\n        address quoteToken,\n        uint256 baseInAmount,\n        uint256[] calldata timeLine,\n        uint256[] calldata valueList,\n        bool isOpenTWAP,\n        uint256 deadLine\n    ) external override payable preventReentrant judgeExpired(deadLine) returns (address payable newCrowdPooling) {\n        address _baseToken = baseToken;\n        address _quoteToken = quoteToken == _ETH_ADDRESS_ ? _WETH_ : quoteToken;\n        \n        newCrowdPooling = IDODOV2(_CP_FACTORY_).createCrowdPooling();\n\n        _deposit(\n            msg.sender,\n            newCrowdPooling,\n            _baseToken,\n            baseInAmount,\n            false\n        );\n\n        newCrowdPooling.transfer(msg.value);\n\n        IDODOV2(_CP_FACTORY_).initCrowdPooling(\n            newCrowdPooling,\n            msg.sender,\n            _baseToken,\n            _quoteToken,\n            timeLine,\n            valueList,\n            isOpenTWAP\n        );\n    }","contract":"DODOV2Proxy02","time":0}]}