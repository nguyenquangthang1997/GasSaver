{"time":61,"results":[{"type":"state-data-arrangement ","before":"\nbytes32 public immutable ATTEST_MESSAGE_PREFIX;\nbytes32 public immutable PAUSE_MESSAGE_PREFIX;\naddress public immutable LIDO;\naddress public immutable DEPOSIT_CONTRACT;\naddress internal nodeOperatorsRegistry;\nuint256 internal maxDepositsPerBlock;\nuint256 internal minDepositBlockDistance;\nuint256 internal pauseIntentValidityPeriodBlocks;\naddress internal owner;\naddress[] internal guardians;\nmapping(address => uint256) internal guardianIndicesOneBased;\nuint256 internal quorum;\nbool internal paused;\nuint256 internal lastDepositBlock;","after":"bytes32 public immutable ATTEST_MESSAGE_PREFIX;\nbytes32 public immutable PAUSE_MESSAGE_PREFIX;\nuint256 internal maxDepositsPerBlock;\nuint256 internal minDepositBlockDistance;\nuint256 internal pauseIntentValidityPeriodBlocks;\naddress[] internal guardians;\nmapping(address => uint256) internal guardianIndicesOneBased;\nuint256 internal quorum;\nuint256 internal lastDepositBlock;\naddress public immutable LIDO;\naddress public immutable DEPOSIT_CONTRACT;\naddress internal nodeOperatorsRegistry;\naddress internal owner;\nbool internal paused;\n","contract":"DepositSecurityModule","time":0},{"type":"external-function ","before":"function addGuardians(address[] memory addresses, uint256 newQuorum) external onlyOwner {\n        for (uint256 i = 0; i < addresses.length; ++i) {\n            _addGuardian(addresses[i]);\n        }\n        _setGuardianQuorum(newQuorum);\n    }","after":"function addGuardians(address[] calldata addresses, uint256 newQuorum) external onlyOwner {\n        for (uint256 i = 0; i < addresses.length; ++i) {\n            _addGuardian(addresses[i]);\n        }\n        _setGuardianQuorum(newQuorum);\n    }","contract":"DepositSecurityModule","time":0},{"type":"external-function ","before":"function pauseDeposits(uint256 blockNumber, Signature memory sig) external {\n        if (paused) {\n            return;\n        }\n\n        address guardianAddr = msg.sender;\n        int256 guardianIndex = _getGuardianIndex(msg.sender);\n\n        if (guardianIndex == -1) {\n            bytes32 msgHash = keccak256(abi.encodePacked(PAUSE_MESSAGE_PREFIX, blockNumber));\n            guardianAddr = ECDSA.recover(msgHash, sig.r, sig.vs);\n            guardianIndex = _getGuardianIndex(guardianAddr);\n            require(guardianIndex != -1, \"invalid signature\");\n        }\n\n        require(\n            block.number - blockNumber <= pauseIntentValidityPeriodBlocks,\n            \"pause intent expired\"\n        );\n\n        paused = true;\n        emit DepositsPaused(guardianAddr);\n    }","after":"function pauseDeposits(uint256 blockNumber, Signature calldata sig) external {\n        if (paused) {\n            return;\n        }\n\n        address guardianAddr = msg.sender;\n        int256 guardianIndex = _getGuardianIndex(msg.sender);\n\n        if (guardianIndex == -1) {\n            bytes32 msgHash = keccak256(abi.encodePacked(PAUSE_MESSAGE_PREFIX, blockNumber));\n            guardianAddr = ECDSA.recover(msgHash, sig.r, sig.vs);\n            guardianIndex = _getGuardianIndex(guardianAddr);\n            require(guardianIndex != -1, \"invalid signature\");\n        }\n\n        require(\n            block.number - blockNumber <= pauseIntentValidityPeriodBlocks,\n            \"pause intent expired\"\n        );\n\n        paused = true;\n        emit DepositsPaused(guardianAddr);\n    }","contract":"DepositSecurityModule","time":0},{"type":"external-function ","before":"function depositBufferedEther(\n        bytes32 depositRoot,\n        uint256 keysOpIndex,\n        uint256 blockNumber,\n        bytes32 blockHash,\n        Signature[] memory sortedGuardianSignatures\n    ) external {\n        bytes32 onchainDepositRoot = IDepositContract(DEPOSIT_CONTRACT).get_deposit_root();\n        require(depositRoot == onchainDepositRoot, \"deposit root changed\");\n\n        require(!paused, \"deposits are paused\");\n        require(quorum > 0 && sortedGuardianSignatures.length >= quorum, \"no guardian quorum\");\n\n        require(block.number - lastDepositBlock >= minDepositBlockDistance, \"too frequent deposits\");\n        require(blockHash != bytes32(0) && blockhash(blockNumber) == blockHash, \"unexpected block hash\");\n\n        uint256 onchainKeysOpIndex = INodeOperatorsRegistry(nodeOperatorsRegistry).getKeysOpIndex();\n        require(keysOpIndex == onchainKeysOpIndex, \"keys op index changed\");\n\n        _verifySignatures(\n            depositRoot,\n            keysOpIndex,\n            blockNumber,\n            blockHash,\n            sortedGuardianSignatures\n        );\n\n        ILido(LIDO).depositBufferedEther(maxDepositsPerBlock);\n        lastDepositBlock = block.number;\n    }","after":"function depositBufferedEther(\n        bytes32 depositRoot,\n        uint256 keysOpIndex,\n        uint256 blockNumber,\n        bytes32 blockHash,\n        Signature[] calldata sortedGuardianSignatures\n    ) external {\n        bytes32 onchainDepositRoot = IDepositContract(DEPOSIT_CONTRACT).get_deposit_root();\n        require(depositRoot == onchainDepositRoot, \"deposit root changed\");\n\n        require(!paused, \"deposits are paused\");\n        require(quorum > 0 && sortedGuardianSignatures.length >= quorum, \"no guardian quorum\");\n\n        require(block.number - lastDepositBlock >= minDepositBlockDistance, \"too frequent deposits\");\n        require(blockHash != bytes32(0) && blockhash(blockNumber) == blockHash, \"unexpected block hash\");\n\n        uint256 onchainKeysOpIndex = INodeOperatorsRegistry(nodeOperatorsRegistry).getKeysOpIndex();\n        require(keysOpIndex == onchainKeysOpIndex, \"keys op index changed\");\n\n        _verifySignatures(\n            depositRoot,\n            keysOpIndex,\n            blockNumber,\n            blockHash,\n            sortedGuardianSignatures\n        );\n\n        ILido(LIDO).depositBufferedEther(maxDepositsPerBlock);\n        lastDepositBlock = block.number;\n    }","contract":"DepositSecurityModule","time":0}]}