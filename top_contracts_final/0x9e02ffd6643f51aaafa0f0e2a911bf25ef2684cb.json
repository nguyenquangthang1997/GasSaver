{"time":303,"results":[{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override whenNotPaused onlyApproved(from) {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            from,\n            to,\n            asSingletonArray(id),\n            asSingletonArray(amount),\n            data\n        );\n\n        uint256 fromBalance = balances[id][from];\n        require(\n            fromBalance >= amount,\n            \"ERC1155: insufficient balance for transfer\"\n        );\n        balances[id][from] = fromBalance - amount;\n        balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override whenNotPaused onlyApproved(from) {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(\n            operator,\n            from,\n            to,\n            asSingletonArray(id),\n            asSingletonArray(amount),\n            data\n        );\n\n        uint256 fromBalance = balances[id][from];\n        require(\n            fromBalance >= amount,\n            \"ERC1155: insufficient balance for transfer\"\n        );\n        balances[id][from] = fromBalance - amount;\n        balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"ERC1155Tradable","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override whenNotPaused onlyApproved(from) {\n        require(\n            ids.length == amounts.length,\n            \"ERC1155: IDS_AMOUNTS_LENGTH_MISMATCH\"\n        );\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = balances[id][from];\n            require(\n                fromBalance >= amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            balances[id][from] = fromBalance - amount;\n            balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        doSafeBatchTransferAcceptanceCheck(\n            operator,\n            from,\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override whenNotPaused onlyApproved(from) {\n        require(\n            ids.length == amounts.length,\n            \"ERC1155: IDS_AMOUNTS_LENGTH_MISMATCH\"\n        );\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = balances[id][from];\n            require(\n                fromBalance >= amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            balances[id][from] = fromBalance - amount;\n            balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        doSafeBatchTransferAcceptanceCheck(\n            operator,\n            from,\n            to,\n            ids,\n            amounts,\n            data\n        );\n    }","contract":"ERC1155Tradable","time":0},{"type":"external-function ","before":"function mint(\n        address _to,\n        uint256 _id,\n        uint256 _quantity,\n        bytes memory _data\n    ) public virtual onlyOwnerOrProxy {\n        _mint(_to, _id, _quantity, _data);\n    }","after":"function mint(\n        address _to,\n        uint256 _id,\n        uint256 _quantity,\n        bytes calldata _data\n    ) public virtual onlyOwnerOrProxy {\n        _mint(_to, _id, _quantity, _data);\n    }","contract":"ERC1155Tradable","time":0},{"type":"external-function ","before":"function batchMint(\n        address _to,\n        uint256[] memory _ids,\n        uint256[] memory _quantities,\n        bytes memory _data\n    ) public virtual onlyOwnerOrProxy {\n        _batchMint(_to, _ids, _quantities, _data);\n    }","after":"function batchMint(\n        address _to,\n        uint256[] calldata _ids,\n        uint256[] calldata _quantities,\n        bytes calldata _data\n    ) public virtual onlyOwnerOrProxy {\n        _batchMint(_to, _ids, _quantities, _data);\n    }","contract":"ERC1155Tradable","time":0},{"type":"external-function ","before":"function batchBurn(\n        address _from,\n        uint256[] memory _ids,\n        uint256[] memory _quantities\n    ) public virtual onlyApproved(_from) {\n        _burnBatch(_from, _ids, _quantities);\n    }","after":"function batchBurn(\n        address _from,\n        uint256[] calldata _ids,\n        uint256[] calldata _quantities\n    ) public virtual onlyApproved(_from) {\n        _burnBatch(_from, _ids, _quantities);\n    }","contract":"ERC1155Tradable","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"ERC1155Tradable","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"ERC1155Tradable","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) external payable returns (bytes memory) {\n        MetaTransaction memory metaTx =\n            MetaTransaction({\n                nonce: nonces[userAddress],\n                from: userAddress,\n                functionSignature: functionSignature\n            });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] += 1;\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) =\n            address(this).call(\n                abi.encodePacked(functionSignature, userAddress)\n            );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) external payable returns (bytes memory) {\n        MetaTransaction memory metaTx =\n            MetaTransaction({\n                nonce: nonces[userAddress],\n                from: userAddress,\n                functionSignature: functionSignature\n            });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] += 1;\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) =\n            address(this).call(\n                abi.encodePacked(functionSignature, userAddress)\n            );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"ERC1155Tradable","time":0},{"type":"immutable-restrict-modification ","before":"address public proxyRegistryAddress;","after":"address public immutable proxyRegistryAddress;","contract":"ERC1155Tradable","time":1}]}