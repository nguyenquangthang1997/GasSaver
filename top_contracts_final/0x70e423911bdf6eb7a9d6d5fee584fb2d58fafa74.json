{"time":85,"results":[{"type":"external-function ","before":"function harvest(\n        uint256 _amount, \n        uint256 _lastBlockNumber, \n        uint256 _currentBlockNumber, \n        bytes32 _msgForSign, \n        bytes memory _signature,\n        address _rewardToken\n\n    ) external \n    {\n        if(block.timestamp > endStageDate[_rewardToken][currentStage[_rewardToken]]) {\n            //change stage\n            while(block.timestamp > endStageDate[_rewardToken][currentStage[_rewardToken]]) {\n                currentStage[_rewardToken]++;\n            }\n        }\n        require(!claimedInStage[_rewardToken][currentStage[_rewardToken]][msg.sender], \"claimed in this stage\");\n        require(_currentBlockNumber <= block.number, \"Harvest::harvest: currentBlockNumber larger than lastBlock\");\n\n        //Double spend check\n        require(getLastBlock(msg.sender, _rewardToken) == _lastBlockNumber, \"Harvest::harvest: lastBlockNumber error\");\n\n        //1. Lets check signer\n        address signedBy = _msgForSign.recover(_signature);\n        require(trustedSigner[_rewardToken][signedBy].isValid == true, \"Harvest::harvest: signature check failed\");\n\n        //2. Check signed msg integrety\n        bytes32 actualMsg = getMsgForSign(\n            _amount,\n            _lastBlockNumber,\n            _currentBlockNumber,\n            msg.sender,\n            _rewardToken\n        );\n        require(actualMsg.toEthSignedMessageHash() == _msgForSign,\"Harvest::harvest: integrety check failed\");\n\n        //Actions\n\n        userRewardInfo[msg.sender][_rewardToken].rewardDebt += _amount;\n        userRewardInfo[msg.sender][_rewardToken].lastBlock = _currentBlockNumber;\n        if (_amount > 0) {\n            IERC20 ERC20Token = IERC20(_rewardToken);\n            ERC20Token.safeTransferFrom(trustedSigner[_rewardToken][signedBy].transferFrom, msg.sender, _amount);\n        }\n        claimedInStage[_rewardToken][currentStage[_rewardToken]][msg.sender]=true;\n        emit UserHarvest(msg.sender, _amount, _lastBlockNumber, _currentBlockNumber, _rewardToken);\n    }","after":"function harvest(\n        uint256 _amount, \n        uint256 _lastBlockNumber, \n        uint256 _currentBlockNumber, \n        bytes32 _msgForSign, \n        bytes calldata _signature,\n        address _rewardToken\n\n    ) external \n    {\n        if(block.timestamp > endStageDate[_rewardToken][currentStage[_rewardToken]]) {\n            //change stage\n            while(block.timestamp > endStageDate[_rewardToken][currentStage[_rewardToken]]) {\n                currentStage[_rewardToken]++;\n            }\n        }\n        require(!claimedInStage[_rewardToken][currentStage[_rewardToken]][msg.sender], \"claimed in this stage\");\n        require(_currentBlockNumber <= block.number, \"Harvest::harvest: currentBlockNumber larger than lastBlock\");\n\n        //Double spend check\n        require(getLastBlock(msg.sender, _rewardToken) == _lastBlockNumber, \"Harvest::harvest: lastBlockNumber error\");\n\n        //1. Lets check signer\n        address signedBy = _msgForSign.recover(_signature);\n        require(trustedSigner[_rewardToken][signedBy].isValid == true, \"Harvest::harvest: signature check failed\");\n\n        //2. Check signed msg integrety\n        bytes32 actualMsg = getMsgForSign(\n            _amount,\n            _lastBlockNumber,\n            _currentBlockNumber,\n            msg.sender,\n            _rewardToken\n        );\n        require(actualMsg.toEthSignedMessageHash() == _msgForSign,\"Harvest::harvest: integrety check failed\");\n\n        //Actions\n\n        userRewardInfo[msg.sender][_rewardToken].rewardDebt += _amount;\n        userRewardInfo[msg.sender][_rewardToken].lastBlock = _currentBlockNumber;\n        if (_amount > 0) {\n            IERC20 ERC20Token = IERC20(_rewardToken);\n            ERC20Token.safeTransferFrom(trustedSigner[_rewardToken][signedBy].transferFrom, msg.sender, _amount);\n        }\n        claimedInStage[_rewardToken][currentStage[_rewardToken]][msg.sender]=true;\n        emit UserHarvest(msg.sender, _amount, _lastBlockNumber, _currentBlockNumber, _rewardToken);\n    }","contract":"Harvest","time":0},{"type":"external-function ","before":"function setEndStageDate(\n            uint[] memory stage, \n            uint[] memory endDate, \n            uint _currentStage, \n            address rewardToken\n            ) public onlyOwner {\n        currentStage[rewardToken] = _currentStage;\n        for(uint i=0;i<stage.length;i++) {\n            endStageDate[rewardToken][stage[i]] = endDate[i];\n        }\n    }","after":"function setEndStageDate(\n            uint[] calldata stage, \n            uint[] calldata endDate, \n            uint _currentStage, \n            address rewardToken\n            ) public onlyOwner {\n        currentStage[rewardToken] = _currentStage;\n        for(uint i=0;i<stage.length;i++) {\n            endStageDate[rewardToken][stage[i]] = endDate[i];\n        }\n    }","contract":"Harvest","time":0},{"type":"immutable-restrict-modification ","before":"address public defaultRewardToken;","after":"address public immutable defaultRewardToken;","contract":"Harvest","time":0}]}