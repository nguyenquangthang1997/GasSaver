{"time":971,"results":[{"type":"immutable-restrict-modification ","before":"address public manager;","after":"address public immutable manager;","contract":"ZeroExTradeWallet","time":0},{"type":"external-function ","before":"function addSchedule(StakingSchedule memory schedule) external override onlyOwner {\n        _addSchedule(schedule);\n    }","after":"function addSchedule(StakingSchedule calldata schedule) external override onlyOwner {\n        _addSchedule(schedule);\n    }","contract":"Staking","time":0},{"type":"struct-data-arrangement ","before":"\nuint256 cliff\nuint256 duration\nuint256 interval\nbool setup\nbool isActive\nuint256 hardStart\nbool isPublic","after":"uint256 cliff\nuint256 duration\nuint256 interval\nuint256 hardStart\nbool setup\nbool isActive\nbool isPublic\n","contract":"IStaking","time":0},{"type":"external-function ","before":"function initialize(\n        ERC20 _underlyer,\n        IManager _manager,\n        string memory _name,\n        string memory _symbol\n    ) public initializer {\n        require(address(_underlyer) != address(0), \"ZERO_ADDRESS\");\n        require(address(_manager) != address(0), \"ZERO_ADDRESS\");\n\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20_init_unchained(_name, _symbol);\n\n        underlyer = _underlyer;\n        manager = _manager;\n    }","after":"function initialize(\n        ERC20 _underlyer,\n        IManager _manager,\n        string calldata _name,\n        string calldata _symbol\n    ) public initializer {\n        require(address(_underlyer) != address(0), \"ZERO_ADDRESS\");\n        require(address(_manager) != address(0), \"ZERO_ADDRESS\");\n\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20_init_unchained(_name, _symbol);\n\n        underlyer = _underlyer;\n        manager = _manager;\n    }","contract":"Pool","time":0},{"type":"external-function ","before":"function initialize(\n        IWETH _weth,\n        IManager _manager,\n        string memory _name,\n        string memory _symbol\n    ) public initializer {\n        require(address(_weth) != address(0), \"ZERO_ADDRESS\");\n        require(address(_manager) != address(0), \"ZERO_ADDRESS\");\n\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20_init_unchained(_name, _symbol);\n        weth = _weth;\n        manager = _manager;\n        withheldLiquidity = 0;\n    }","after":"function initialize(\n        IWETH _weth,\n        IManager _manager,\n        string calldata _name,\n        string calldata _symbol\n    ) public initializer {\n        require(address(_weth) != address(0), \"ZERO_ADDRESS\");\n        require(address(_manager) != address(0), \"ZERO_ADDRESS\");\n\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n        __Pausable_init_unchained();\n        __ERC20_init_unchained(_name, _symbol);\n        weth = _weth;\n        manager = _manager;\n        withheldLiquidity = 0;\n    }","contract":"EthPool","time":0},{"type":"external-function ","before":"function deposit(TokenData calldata tokenInfo, bytes32[] memory proof) external payable override {\n        require(currentStage == STAGES.STAGE_1, \"DEPOSITS_NOT_ACCEPTED\");\n        require(!stage1Locked, \"DEPOSITS_LOCKED\");\n\n        if (whitelistSettings.enabled) {            \n            require(verifyDepositor(msg.sender, whitelistSettings.root, proof), \"PROOF_INVALID\");\n        }\n\n        TokenData memory data = tokenInfo;\n        address token = data.token;\n        uint256 tokenAmount = data.amount;\n        require(supportedTokens.contains(token), \"UNSUPPORTED_TOKEN\");\n        require(tokenAmount > 0, \"INVALID_AMOUNT\");\n\n        // Convert ETH to WETH if ETH is passed in, otherwise treat WETH as a regular ERC20\n        if (token == WETH && msg.value > 0) {\n            require(tokenAmount == msg.value, \"INVALID_MSG_VALUE\"); \n            IWETH(WETH).deposit{value: tokenAmount}();\n        } else {\n            require(msg.value == 0, \"NO_ETH\");\n        }\n\n        AccountData storage tokenAccountData = accountData[msg.sender];\n    \n        if (tokenAccountData.token == address(0)) {\n            tokenAccountData.token = token;\n        }\n        \n        require(tokenAccountData.token == token, \"SINGLE_ASSET_DEPOSITS\");\n\n        tokenAccountData.initialDeposit = tokenAccountData.initialDeposit.add(tokenAmount);\n        tokenAccountData.currentBalance = tokenAccountData.currentBalance.add(tokenAmount);\n        \n        require(tokenAccountData.currentBalance <= tokenSettings[token].maxLimit, \"MAX_LIMIT_EXCEEDED\");       \n\n        // No need to transfer from msg.sender since is ETH was converted to WETH\n        if (!(token == WETH && msg.value > 0)) {\n            IERC20(token).safeTransferFrom(msg.sender, address(this), tokenAmount);    \n        }\n        \n        if(_totalValue() > maxTotalValue) {\n            stage1Locked = true;\n        }\n\n        emit Deposited(msg.sender, tokenInfo);\n    }","after":"function deposit(TokenData calldata tokenInfo, bytes32[] calldata proof) external payable override {\n        require(currentStage == STAGES.STAGE_1, \"DEPOSITS_NOT_ACCEPTED\");\n        require(!stage1Locked, \"DEPOSITS_LOCKED\");\n\n        if (whitelistSettings.enabled) {            \n            require(verifyDepositor(msg.sender, whitelistSettings.root, proof), \"PROOF_INVALID\");\n        }\n\n        TokenData memory data = tokenInfo;\n        address token = data.token;\n        uint256 tokenAmount = data.amount;\n        require(supportedTokens.contains(token), \"UNSUPPORTED_TOKEN\");\n        require(tokenAmount > 0, \"INVALID_AMOUNT\");\n\n        // Convert ETH to WETH if ETH is passed in, otherwise treat WETH as a regular ERC20\n        if (token == WETH && msg.value > 0) {\n            require(tokenAmount == msg.value, \"INVALID_MSG_VALUE\"); \n            IWETH(WETH).deposit{value: tokenAmount}();\n        } else {\n            require(msg.value == 0, \"NO_ETH\");\n        }\n\n        AccountData storage tokenAccountData = accountData[msg.sender];\n    \n        if (tokenAccountData.token == address(0)) {\n            tokenAccountData.token = token;\n        }\n        \n        require(tokenAccountData.token == token, \"SINGLE_ASSET_DEPOSITS\");\n\n        tokenAccountData.initialDeposit = tokenAccountData.initialDeposit.add(tokenAmount);\n        tokenAccountData.currentBalance = tokenAccountData.currentBalance.add(tokenAmount);\n        \n        require(tokenAccountData.currentBalance <= tokenSettings[token].maxLimit, \"MAX_LIMIT_EXCEEDED\");       \n\n        // No need to transfer from msg.sender since is ETH was converted to WETH\n        if (!(token == WETH && msg.value > 0)) {\n            IERC20(token).safeTransferFrom(msg.sender, address(this), tokenAmount);    \n        }\n        \n        if(_totalValue() > maxTotalValue) {\n            stage1Locked = true;\n        }\n\n        emit Deposited(msg.sender, tokenInfo);\n    }","contract":"DefiRound","time":0},{"type":"external-function ","before":"function configureWhitelist(WhitelistSettings memory settings) external override onlyOwner {\n        whitelistSettings = settings;\n        emit WhitelistConfigured(settings);\n    }","after":"function configureWhitelist(WhitelistSettings calldata settings) external override onlyOwner {\n        whitelistSettings = settings;\n        emit WhitelistConfigured(settings);\n    }","contract":"DefiRound","time":0},{"type":"external-function ","before":"function publishRates(RateData[] calldata ratesData, OversubscriptionRate memory oversubRate, uint256 lastLookDuration) external override onlyOwner {\n        // check rates havent been published before\n        require(currentStage == STAGES.STAGE_1, \"RATES_ALREADY_SET\");\n        require(lastLookDuration > 0, \"INVALID_DURATION\");\n        require(oversubRate.overDenominator > 0, \"INVALID_DENOMINATOR\");\n        require(oversubRate.overNumerator > 0, \"INVALID_NUMERATOR\");        \n        \n        uint256 ratesLength = ratesData.length;\n        for (uint256 i = 0; i < ratesLength; i++) {\n            RateData memory data = ratesData[i];\n            require(data.numerator > 0, \"INVALID_NUMERATOR\");\n            require(data.denominator > 0, \"INVALID_DENOMINATOR\");\n            require(tokenRates[data.token].token == address(0), \"RATE_ALREADY_SET\");\n            require(configuredTokenRates.add(data.token), \"ALREADY_CONFIGURED\");\n            tokenRates[data.token] = data;            \n        }\n\n        require(configuredTokenRates.length() == supportedTokens.length(), \"MISSING_RATE\");\n\n        // Stage only moves forward when prices are published\n        currentStage = STAGES.STAGE_2;\n        lastLookExpiration = block.number + lastLookDuration;\n        overSubscriptionRate = oversubRate;\n\n        emit RatesPublished(ratesData);\n    }","after":"function publishRates(RateData[] calldata ratesData, OversubscriptionRate calldata oversubRate, uint256 lastLookDuration) external override onlyOwner {\n        // check rates havent been published before\n        require(currentStage == STAGES.STAGE_1, \"RATES_ALREADY_SET\");\n        require(lastLookDuration > 0, \"INVALID_DURATION\");\n        require(oversubRate.overDenominator > 0, \"INVALID_DENOMINATOR\");\n        require(oversubRate.overNumerator > 0, \"INVALID_NUMERATOR\");        \n        \n        uint256 ratesLength = ratesData.length;\n        for (uint256 i = 0; i < ratesLength; i++) {\n            RateData memory data = ratesData[i];\n            require(data.numerator > 0, \"INVALID_NUMERATOR\");\n            require(data.denominator > 0, \"INVALID_DENOMINATOR\");\n            require(tokenRates[data.token].token == address(0), \"RATE_ALREADY_SET\");\n            require(configuredTokenRates.add(data.token), \"ALREADY_CONFIGURED\");\n            tokenRates[data.token] = data;            \n        }\n\n        require(configuredTokenRates.length() == supportedTokens.length(), \"MISSING_RATE\");\n\n        // Stage only moves forward when prices are published\n        currentStage = STAGES.STAGE_2;\n        lastLookExpiration = block.number + lastLookDuration;\n        overSubscriptionRate = oversubRate;\n\n        emit RatesPublished(ratesData);\n    }","contract":"DefiRound","time":0},{"type":"external-function ","before":"function configureWhitelist(WhitelistSettings memory settings) external override onlyOwner {\n        whitelistSettings = settings;\n        emit WhitelistConfigured(settings);\n    }","after":"function configureWhitelist(WhitelistSettings calldata settings) external override onlyOwner {\n        whitelistSettings = settings;\n        emit WhitelistConfigured(settings);\n    }","contract":"CoreEvent","time":0},{"type":"struct-data-arrangement ","before":"\naddress token\nuint256 maxUserLimit\nbool systemFinalized","after":"uint256 maxUserLimit\naddress token\nbool systemFinalized\n","contract":"ICoreEvent","time":0},{"type":"struct-data-arrangement ","before":"\naddress token\nuint256 depositedBalance\nbool finalized","after":"uint256 depositedBalance\naddress token\nbool finalized\n","contract":"ICoreEvent","time":0},{"type":"external-function ","before":"\n\n\tfunction updateInvocationCount(bytes4 methodId, bytes memory originalMsgData) public {\n\t\trequire(msg.sender == address(this), \"Can only be called from the contract itself\");\n\t\tinvocations += 1;\n\t\tmethodIdInvocations[keccak256(abi.encodePacked(resetCount, methodId))] += 1;\n\t\tcalldataInvocations[keccak256(abi.encodePacked(resetCount, originalMsgData))] += 1;","after":"\n\n\tfunction updateInvocationCount(bytes4 methodId, bytes calldata originalMsgData) public {\n\t\trequire(msg.sender == address(this), \"Can only be called from the contract itself\");\n\t\tinvocations += 1;\n\t\tmethodIdInvocations[keccak256(abi.encodePacked(resetCount, methodId))] += 1;\n\t\tcalldataInvocations[keccak256(abi.encodePacked(resetCount, originalMsgData))] += 1;","contract":"MockContract","time":0}]}