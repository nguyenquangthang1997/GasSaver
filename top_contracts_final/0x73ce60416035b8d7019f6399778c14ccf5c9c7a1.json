{"time":278,"results":[{"type":"external-function ","before":"function closeSwap(\n        IAggregator.SwapDescription calldata swapDesc,\n        bytes memory aggregatorData,\n        uint32 fromChainId,\n        uint256 fromSwapId\n    ) external payable whenNotPaused onlyRole(ROLE_YPOOL_WORKER) approveAggregator(swapDesc.fromToken, swapDesc.amount) {\n        require(YPoolSupoortedToken[address(swapDesc.fromToken)], \"ERR_INVALID_YPOOL_TOKEN\");\n\n        bytes32 universalSwapId = keccak256(abi.encodePacked(fromChainId, fromSwapId));\n        require(!everClosed[universalSwapId], \"ERR_ALREADY_CLOSED\");\n        everClosed[universalSwapId] = true;\n\n        uint256 fromTokenAmount = swapDesc.amount;\n        require(fromTokenAmount <= maxYPoolTokenSwapAmount[address(swapDesc.fromToken)], \"ERR_EXCEED_MAX_SWAP_AMOUNT\");\n        IYPoolVault(YPoolVaults[address(swapDesc.fromToken)]).transferToSwapper(swapDesc.fromToken, fromTokenAmount);\n\n        uint256 toTokenAmountOut;\n        CloseSwapResult swapResult;\n        if (swapDesc.toToken == swapDesc.fromToken) {\n            toTokenAmountOut = fromTokenAmount;\n            swapResult = CloseSwapResult.NonSwapped;\n        } else {\n            uint256 value = (address(swapDesc.fromToken) == ETHER_ADDRESS) ? fromTokenAmount : 0;\n            toTokenAmountOut = _getTokenBalance(swapDesc.toToken, swapDesc.receiver);\n            try IAggregator(aggregator).swap{value: value}(swapDesc, aggregatorData) {\n                toTokenAmountOut = _getTokenBalance(swapDesc.toToken, swapDesc.receiver) - toTokenAmountOut;\n                swapResult = CloseSwapResult.Success;\n            } catch {\n                swapResult = CloseSwapResult.Failed;\n            }\n        }\n        if (swapResult != CloseSwapResult.Success) {\n            _safeTransferAsset(swapDesc.receiver, swapDesc.fromToken, fromTokenAmount);\n        }\n        emit CloseSwapCompleted(swapResult, fromChainId, fromSwapId);\n        emit SwappedForUser(swapDesc.fromToken, fromTokenAmount, swapDesc.toToken, toTokenAmountOut, swapDesc.receiver);\n    }","after":"function closeSwap(\n        IAggregator.SwapDescription calldata swapDesc,\n        bytes calldata aggregatorData,\n        uint32 fromChainId,\n        uint256 fromSwapId\n    ) external payable whenNotPaused onlyRole(ROLE_YPOOL_WORKER) approveAggregator(swapDesc.fromToken, swapDesc.amount) {\n        require(YPoolSupoortedToken[address(swapDesc.fromToken)], \"ERR_INVALID_YPOOL_TOKEN\");\n\n        bytes32 universalSwapId = keccak256(abi.encodePacked(fromChainId, fromSwapId));\n        require(!everClosed[universalSwapId], \"ERR_ALREADY_CLOSED\");\n        everClosed[universalSwapId] = true;\n\n        uint256 fromTokenAmount = swapDesc.amount;\n        require(fromTokenAmount <= maxYPoolTokenSwapAmount[address(swapDesc.fromToken)], \"ERR_EXCEED_MAX_SWAP_AMOUNT\");\n        IYPoolVault(YPoolVaults[address(swapDesc.fromToken)]).transferToSwapper(swapDesc.fromToken, fromTokenAmount);\n\n        uint256 toTokenAmountOut;\n        CloseSwapResult swapResult;\n        if (swapDesc.toToken == swapDesc.fromToken) {\n            toTokenAmountOut = fromTokenAmount;\n            swapResult = CloseSwapResult.NonSwapped;\n        } else {\n            uint256 value = (address(swapDesc.fromToken) == ETHER_ADDRESS) ? fromTokenAmount : 0;\n            toTokenAmountOut = _getTokenBalance(swapDesc.toToken, swapDesc.receiver);\n            try IAggregator(aggregator).swap{value: value}(swapDesc, aggregatorData) {\n                toTokenAmountOut = _getTokenBalance(swapDesc.toToken, swapDesc.receiver) - toTokenAmountOut;\n                swapResult = CloseSwapResult.Success;\n            } catch {\n                swapResult = CloseSwapResult.Failed;\n            }\n        }\n        if (swapResult != CloseSwapResult.Success) {\n            _safeTransferAsset(swapDesc.receiver, swapDesc.fromToken, fromTokenAmount);\n        }\n        emit CloseSwapCompleted(swapResult, fromChainId, fromSwapId);\n        emit SwappedForUser(swapDesc.fromToken, fromTokenAmount, swapDesc.toToken, toTokenAmountOut, swapDesc.receiver);\n    }","contract":"XSwapper","time":0},{"type":"external-function ","before":"function claim(uint256 _swapId, bytes[] memory signatures) external whenNotPaused {\n        require(_swapId < swapId, \"ERR_INVALID_SWAPID\");\n        require(swapRequests[_swapId].status != RequestStatus.Closed, \"ERR_ALREADY_CLOSED\");\n        swapRequests[_swapId].status = RequestStatus.Closed;\n\n        bytes32 sigId = keccak256(abi.encodePacked(supervisor.VALIDATE_SWAP_IDENTIFIER(), address(swapValidatorXYChain), chainId, _swapId));\n        bytes32 sigIdHash = sigId.toEthSignedMessageHash();\n        supervisor.checkSignatures(sigIdHash, signatures);\n\n        SwapRequest memory request = swapRequests[_swapId];\n        IYPoolVault yPoolVault = IYPoolVault(YPoolVaults[address(request.YPoolToken)]);\n        uint256 value = (address(request.YPoolToken) == ETHER_ADDRESS) ? request.YPoolTokenAmount : 0;\n        if (address(request.YPoolToken) != ETHER_ADDRESS) {\n            request.YPoolToken.safeApprove(address(yPoolVault), request.YPoolTokenAmount);\n        }\n        yPoolVault.receiveAssetFromSwapper{value: value}(request.YPoolToken, request.YPoolTokenAmount, request.xyFee, request.gasFee);\n\n        emit SwapCompleted(CompleteSwapType.Claimed, request);\n    }","after":"function claim(uint256 _swapId, bytes[] calldata signatures) external whenNotPaused {\n        require(_swapId < swapId, \"ERR_INVALID_SWAPID\");\n        require(swapRequests[_swapId].status != RequestStatus.Closed, \"ERR_ALREADY_CLOSED\");\n        swapRequests[_swapId].status = RequestStatus.Closed;\n\n        bytes32 sigId = keccak256(abi.encodePacked(supervisor.VALIDATE_SWAP_IDENTIFIER(), address(swapValidatorXYChain), chainId, _swapId));\n        bytes32 sigIdHash = sigId.toEthSignedMessageHash();\n        supervisor.checkSignatures(sigIdHash, signatures);\n\n        SwapRequest memory request = swapRequests[_swapId];\n        IYPoolVault yPoolVault = IYPoolVault(YPoolVaults[address(request.YPoolToken)]);\n        uint256 value = (address(request.YPoolToken) == ETHER_ADDRESS) ? request.YPoolTokenAmount : 0;\n        if (address(request.YPoolToken) != ETHER_ADDRESS) {\n            request.YPoolToken.safeApprove(address(yPoolVault), request.YPoolTokenAmount);\n        }\n        yPoolVault.receiveAssetFromSwapper{value: value}(request.YPoolToken, request.YPoolTokenAmount, request.xyFee, request.gasFee);\n\n        emit SwapCompleted(CompleteSwapType.Claimed, request);\n    }","contract":"XSwapper","time":0},{"type":"external-function ","before":"function batchClaim(uint256[] calldata _swapIds, address _YPoolToken, bytes[] memory signatures) external whenNotPaused {\n        require(YPoolSupoortedToken[_YPoolToken], \"ERR_INVALID_YPOOL_TOKEN\");\n        bytes32 sigId = keccak256(abi.encodePacked(supervisor.BATCH_CLAIM_IDENTIFIER(), address(swapValidatorXYChain), chainId, _swapIds));\n        bytes32 sigIdHash = sigId.toEthSignedMessageHash();\n        supervisor.checkSignatures(sigIdHash, signatures);\n\n        IERC20 YPoolToken = IERC20(_YPoolToken);\n        uint256 totalClaimedAmount;\n        uint256 totalXYFee;\n        uint256 totalGasFee;\n        for (uint256 i; i < _swapIds.length; i++) {\n            uint256 _swapId = _swapIds[i];\n            require(_swapId < swapId, \"ERR_INVALID_SWAPID\");\n            SwapRequest memory request = swapRequests[_swapId];\n            require(request.status != RequestStatus.Closed, \"ERR_ALREADY_CLOSED\");\n            require(request.YPoolToken == YPoolToken, \"ERR_WRONG_YPOOL_TOKEN\");\n            totalClaimedAmount += request.YPoolTokenAmount;\n            totalXYFee += request.xyFee;\n            totalGasFee += request.gasFee;\n            swapRequests[_swapId].status = RequestStatus.Closed;\n            emit SwapCompleted(CompleteSwapType.FreeClaimed, request);\n        }\n\n        IYPoolVault yPoolVault = IYPoolVault(YPoolVaults[_YPoolToken]);\n        uint256 value = (_YPoolToken == ETHER_ADDRESS) ? totalClaimedAmount : 0;\n        if (_YPoolToken != ETHER_ADDRESS) {\n            YPoolToken.safeApprove(address(yPoolVault), totalClaimedAmount);\n        }\n        yPoolVault.receiveAssetFromSwapper{value: value}(YPoolToken, totalClaimedAmount, totalXYFee, totalGasFee);\n    }","after":"function batchClaim(uint256[] calldata _swapIds, address _YPoolToken, bytes[] calldata signatures) external whenNotPaused {\n        require(YPoolSupoortedToken[_YPoolToken], \"ERR_INVALID_YPOOL_TOKEN\");\n        bytes32 sigId = keccak256(abi.encodePacked(supervisor.BATCH_CLAIM_IDENTIFIER(), address(swapValidatorXYChain), chainId, _swapIds));\n        bytes32 sigIdHash = sigId.toEthSignedMessageHash();\n        supervisor.checkSignatures(sigIdHash, signatures);\n\n        IERC20 YPoolToken = IERC20(_YPoolToken);\n        uint256 totalClaimedAmount;\n        uint256 totalXYFee;\n        uint256 totalGasFee;\n        for (uint256 i; i < _swapIds.length; i++) {\n            uint256 _swapId = _swapIds[i];\n            require(_swapId < swapId, \"ERR_INVALID_SWAPID\");\n            SwapRequest memory request = swapRequests[_swapId];\n            require(request.status != RequestStatus.Closed, \"ERR_ALREADY_CLOSED\");\n            require(request.YPoolToken == YPoolToken, \"ERR_WRONG_YPOOL_TOKEN\");\n            totalClaimedAmount += request.YPoolTokenAmount;\n            totalXYFee += request.xyFee;\n            totalGasFee += request.gasFee;\n            swapRequests[_swapId].status = RequestStatus.Closed;\n            emit SwapCompleted(CompleteSwapType.FreeClaimed, request);\n        }\n\n        IYPoolVault yPoolVault = IYPoolVault(YPoolVaults[_YPoolToken]);\n        uint256 value = (_YPoolToken == ETHER_ADDRESS) ? totalClaimedAmount : 0;\n        if (_YPoolToken != ETHER_ADDRESS) {\n            YPoolToken.safeApprove(address(yPoolVault), totalClaimedAmount);\n        }\n        yPoolVault.receiveAssetFromSwapper{value: value}(YPoolToken, totalClaimedAmount, totalXYFee, totalGasFee);\n    }","contract":"XSwapper","time":0},{"type":"external-function ","before":"function lockCloseSwap(uint32 fromChainId, uint256 fromSwapId, bytes[] memory signatures) external whenNotPaused {\n        bytes32 universalSwapId = keccak256(abi.encodePacked(fromChainId, fromSwapId));\n        require(!everClosed[universalSwapId], \"ERR_ALREADY_CLOSED\");\n        bytes32 sigId = keccak256(abi.encodePacked(supervisor.LOCK_CLOSE_SWAP_AND_REFUND_IDENTIFIER(), address(this), fromChainId, fromSwapId));\n        bytes32 sigIdHash = sigId.toEthSignedMessageHash();\n        supervisor.checkSignatures(sigIdHash, signatures);\n\n        everClosed[universalSwapId] = true;\n        emit CloseSwapCompleted(CloseSwapResult.Locked, fromChainId, fromSwapId);\n    }","after":"function lockCloseSwap(uint32 fromChainId, uint256 fromSwapId, bytes[] calldata signatures) external whenNotPaused {\n        bytes32 universalSwapId = keccak256(abi.encodePacked(fromChainId, fromSwapId));\n        require(!everClosed[universalSwapId], \"ERR_ALREADY_CLOSED\");\n        bytes32 sigId = keccak256(abi.encodePacked(supervisor.LOCK_CLOSE_SWAP_AND_REFUND_IDENTIFIER(), address(this), fromChainId, fromSwapId));\n        bytes32 sigIdHash = sigId.toEthSignedMessageHash();\n        supervisor.checkSignatures(sigIdHash, signatures);\n\n        everClosed[universalSwapId] = true;\n        emit CloseSwapCompleted(CloseSwapResult.Locked, fromChainId, fromSwapId);\n    }","contract":"XSwapper","time":0},{"type":"external-function ","before":"function refund(uint256 _swapId, address gasFeeReceiver, bytes[] memory signatures) external whenNotPaused {\n        require(_swapId < swapId, \"ERR_INVALID_SWAPID\");\n        require(swapRequests[_swapId].status != RequestStatus.Closed, \"ERR_ALREADY_CLOSED\");\n        swapRequests[_swapId].status = RequestStatus.Closed;\n\n        bytes32 sigId = keccak256(abi.encodePacked(supervisor.LOCK_CLOSE_SWAP_AND_REFUND_IDENTIFIER(), address(this), chainId, _swapId, gasFeeReceiver));\n        bytes32 sigIdHash = sigId.toEthSignedMessageHash();\n        supervisor.checkSignatures(sigIdHash, signatures);\n\n        SwapRequest memory request = swapRequests[_swapId];\n        (, uint256 refundGasFee) = _calculateFee(chainId, request.YPoolToken, request.YPoolTokenAmount);\n        _safeTransferAsset(request.sender, request.YPoolToken, request.YPoolTokenAmount - refundGasFee);\n        _safeTransferAsset(gasFeeReceiver, request.YPoolToken, refundGasFee);\n\n        emit SwapCompleted(CompleteSwapType.Refunded, request);\n    }","after":"function refund(uint256 _swapId, address gasFeeReceiver, bytes[] calldata signatures) external whenNotPaused {\n        require(_swapId < swapId, \"ERR_INVALID_SWAPID\");\n        require(swapRequests[_swapId].status != RequestStatus.Closed, \"ERR_ALREADY_CLOSED\");\n        swapRequests[_swapId].status = RequestStatus.Closed;\n\n        bytes32 sigId = keccak256(abi.encodePacked(supervisor.LOCK_CLOSE_SWAP_AND_REFUND_IDENTIFIER(), address(this), chainId, _swapId, gasFeeReceiver));\n        bytes32 sigIdHash = sigId.toEthSignedMessageHash();\n        supervisor.checkSignatures(sigIdHash, signatures);\n\n        SwapRequest memory request = swapRequests[_swapId];\n        (, uint256 refundGasFee) = _calculateFee(chainId, request.YPoolToken, request.YPoolTokenAmount);\n        _safeTransferAsset(request.sender, request.YPoolToken, request.YPoolTokenAmount - refundGasFee);\n        _safeTransferAsset(gasFeeReceiver, request.YPoolToken, refundGasFee);\n\n        emit SwapCompleted(CompleteSwapType.Refunded, request);\n    }","contract":"XSwapper","time":0},{"type":"external-function ","before":"function swap(\n        IAggregator.SwapDescription memory swapDesc,\n        bytes memory aggregatorData,\n        ToChainDescription calldata toChainDesc\n    ) external payable approveAggregator(swapDesc.fromToken, swapDesc.amount) whenNotPaused nonReentrant {\n        address receiver = swapDesc.receiver;\n        IERC20 fromToken = swapDesc.fromToken;\n        IERC20 YPoolToken = swapDesc.toToken;\n        require(YPoolSupoortedToken[address(YPoolToken)], \"ERR_INVALID_YPOOL_TOKEN\");\n\n        uint256 fromTokenAmount = swapDesc.amount;\n        uint256 yBalance;\n        _safeTransferFromAsset(fromToken, msg.sender, fromTokenAmount);\n        if (fromToken == YPoolToken) {\n            yBalance = fromTokenAmount;\n        } else {\n            yBalance = _getTokenBalance(YPoolToken, address(this));\n            swapDesc.receiver = address(this);\n            IAggregator(aggregator).swap{value: msg.value}(swapDesc, aggregatorData);\n            yBalance = _getTokenBalance(YPoolToken, address(this)) - yBalance;\n        }\n        require(_checkMinimumSwapAmount(toChainDesc.toChainId, YPoolToken, yBalance), \"ERR_NOT_ENOUGH_SWAP_AMOUNT\");\n        require(yBalance <= maxYPoolTokenSwapAmount[address(YPoolToken)], \"ERR_EXCEED_MAX_SWAP_AMOUNT\");\n\n        // Calculate XY fee and gas fee for closeSwap on toChain\n        // NOTE: XY fee already includes gas fee and gas fee is computed here only for bookkeeping purpose\n        (uint256 xyFee, uint256 closeSwapGasFee) = _calculateFee(toChainDesc.toChainId, YPoolToken, yBalance);\n        SwapRequest memory request = SwapRequest(toChainDesc.toChainId, swapId, receiver, msg.sender, yBalance, xyFee, closeSwapGasFee, YPoolToken, RequestStatus.Open);\n        swapRequests.push(request);\n        emit SwapRequested(swapId++, toChainDesc, fromToken, YPoolToken, yBalance, receiver, xyFee, closeSwapGasFee);\n    }","after":"function swap(\n        IAggregator.SwapDescription calldata swapDesc,\n        bytes memory aggregatorData,\n        ToChainDescription calldata toChainDesc\n    ) external payable approveAggregator(swapDesc.fromToken, swapDesc.amount) whenNotPaused nonReentrant {\n        address receiver = swapDesc.receiver;\n        IERC20 fromToken = swapDesc.fromToken;\n        IERC20 YPoolToken = swapDesc.toToken;\n        require(YPoolSupoortedToken[address(YPoolToken)], \"ERR_INVALID_YPOOL_TOKEN\");\n\n        uint256 fromTokenAmount = swapDesc.amount;\n        uint256 yBalance;\n        _safeTransferFromAsset(fromToken, msg.sender, fromTokenAmount);\n        if (fromToken == YPoolToken) {\n            yBalance = fromTokenAmount;\n        } else {\n            yBalance = _getTokenBalance(YPoolToken, address(this));\n            swapDesc.receiver = address(this);\n            IAggregator(aggregator).swap{value: msg.value}(swapDesc, aggregatorData);\n            yBalance = _getTokenBalance(YPoolToken, address(this)) - yBalance;\n        }\n        require(_checkMinimumSwapAmount(toChainDesc.toChainId, YPoolToken, yBalance), \"ERR_NOT_ENOUGH_SWAP_AMOUNT\");\n        require(yBalance <= maxYPoolTokenSwapAmount[address(YPoolToken)], \"ERR_EXCEED_MAX_SWAP_AMOUNT\");\n\n        // Calculate XY fee and gas fee for closeSwap on toChain\n        // NOTE: XY fee already includes gas fee and gas fee is computed here only for bookkeeping purpose\n        (uint256 xyFee, uint256 closeSwapGasFee) = _calculateFee(toChainDesc.toChainId, YPoolToken, yBalance);\n        SwapRequest memory request = SwapRequest(toChainDesc.toChainId, swapId, receiver, msg.sender, yBalance, xyFee, closeSwapGasFee, YPoolToken, RequestStatus.Open);\n        swapRequests.push(request);\n        emit SwapRequested(swapId++, toChainDesc, fromToken, YPoolToken, yBalance, receiver, xyFee, closeSwapGasFee);\n    }","contract":"XSwapper","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public swapId = 0;","after":"uint256 public constant swapId = 0;","contract":"XSwapper","time":1},{"type":"external-function ","before":"   function setThreshold(uint256 _threshold, uint256 _nonce, bytes[] memory signatures) external {\n        require(signatures.length >= threshold, \"ERR_NOT_ENOUGH_SIGNATURES\");\n        require(_nonce == nonce, \"ERR_INVALID_NONCE\");\n        require(_threshold > 0, \"ERR_INVALID_THRESHOLD\");\n        require(_threshold <= validatorsNum, \"ERR_INVALID_THRESHOLD\");\n\n        bytes32 sigId = keccak256(abi.encodePacked(SET_THRESHOLD_IDENTIFIER, address(this), chainId, _threshold, _nonce));\n        bytes32 sigIdHash = sigId.toEthSignedMessageHash();\n        checkSignatures(sigIdHash, signatures);\n\n        threshold = _threshold;\n        nonce++;\n  ","after":"   function setThreshold(uint256 _threshold, uint256 _nonce, bytes[] calldata signatures) external {\n        require(signatures.length >= threshold, \"ERR_NOT_ENOUGH_SIGNATURES\");\n        require(_nonce == nonce, \"ERR_INVALID_NONCE\");\n        require(_threshold > 0, \"ERR_INVALID_THRESHOLD\");\n        require(_threshold <= validatorsNum, \"ERR_INVALID_THRESHOLD\");\n\n        bytes32 sigId = keccak256(abi.encodePacked(SET_THRESHOLD_IDENTIFIER, address(this), chainId, _threshold, _nonce));\n        bytes32 sigIdHash = sigId.toEthSignedMessageHash();\n        checkSignatures(sigIdHash, signatures);\n\n        threshold = _threshold;\n        nonce++;\n  ","contract":"Supervisor","time":0},{"type":"external-function ","before":"   function setValidator(address _validator, bool flag, uint256 _nonce, bytes[] memory signatures) external {\n        require(_validator != address(0), \"ERR_INVALID_VALIDATOR\");\n        require(signatures.length >= threshold, \"ERR_NOT_ENOUGH_SIGNATURES\");\n        require(_nonce == nonce, \"ERR_INVALID_NONCE\");\n        require(flag != validators[_validator], \"ERR_OPERATION_TO_VALIDATOR\");\n\n        bytes32 sigId = keccak256(abi.encodePacked(SET_VALIDATOR_IDENTIFIER, address(this), chainId, _validator, flag, _nonce));\n        bytes32 sigIdHash = sigId.toEthSignedMessageHash();\n        checkSignatures(sigIdHash, signatures);\n\n        if (validators[_validator]) {\n            validatorsNum--;\n            validators[_validator] = false;\n            if (validatorsNum < threshold) threshold--;\n        } else {\n            validatorsNum++;\n            validators[_validator] = true;\n        }\n        nonce++;\n  ","after":"   function setValidator(address _validator, bool flag, uint256 _nonce, bytes[] calldata signatures) external {\n        require(_validator != address(0), \"ERR_INVALID_VALIDATOR\");\n        require(signatures.length >= threshold, \"ERR_NOT_ENOUGH_SIGNATURES\");\n        require(_nonce == nonce, \"ERR_INVALID_NONCE\");\n        require(flag != validators[_validator], \"ERR_OPERATION_TO_VALIDATOR\");\n\n        bytes32 sigId = keccak256(abi.encodePacked(SET_VALIDATOR_IDENTIFIER, address(this), chainId, _validator, flag, _nonce));\n        bytes32 sigIdHash = sigId.toEthSignedMessageHash();\n        checkSignatures(sigIdHash, signatures);\n\n        if (validators[_validator]) {\n            validatorsNum--;\n            validators[_validator] = false;\n            if (validatorsNum < threshold) threshold--;\n        } else {\n            validatorsNum++;\n            validators[_validator] = true;\n        }\n        nonce++;\n  ","contract":"Supervisor","time":0},{"type":"immutable-restrict-modification ","before":"   uint32 public chain","after":"   uint32 public chain","contract":"Supervisor","time":0}]}