{"time":187,"results":[{"type":"external-function ","before":"function setBaseURI(string memory URI) public onlyOwner {\n        baseURI = URI;\n    }","after":"function setBaseURI(string calldata URI) public onlyOwner {\n        baseURI = URI;\n    }","contract":"Mondrian","time":0},{"type":"external-function ","before":"function mintItem(\n      uint256 numberOfTokens,\n      uint256[] memory tokenIds\n    ) public payable {\n        // First do \"soup hodler\" mode check\n        // Ensure sender is a soup hodler and save tokens to prevent reuse\n        if (soupHodlersMode) {\n            require(tokenIds.length > 0, \"Must provide at least 1 token id\");\n            require(tokenIds.length == numberOfTokens, \"Number of tokens requested must be equal to number of soup token Ids provided\");\n            // Loop through the provided tokens to ensure the sender owns them\n            for(uint256 i = 0; i < tokenIds.length; i++) {\n                uint256 tokenId = tokenIds[i];\n                require(_nfs.ownerOf(tokenId) == msg.sender, \"Sender is not the owner of provided soup\");\n                // Lock in token Id to sender's address and update soup balance\n                if (soupAddressByTokenId[tokenId] == address(0x0)) {\n                    soupAddressByTokenId[tokenId] = msg.sender;\n                    soupBalanceByAddress[msg.sender] = soupBalanceByAddress[msg.sender].add(1);\n                } else {\n                    require(soupAddressByTokenId[tokenId] == msg.sender, \"Token already associated with another sender\");\n                }\n                require(totalSupply().add(numberOfTokens) <= _nfs.totalSupply(), \"Cannot mint more Mondrians than Soups that exist\");\n            }\n\n            uint256 allottedMints = soupBalanceByAddress[msg.sender] - phaseOneMondrianBalanceByAddress[msg.sender];\n            require(numberOfTokens <= allottedMints, \"Minting would exceed allowance set in contract based upon your balance of Soups (NFS)\");\n        } else {\n            if (maxItemsEnforced) {\n                require(phaseTwoMondrianBalanceByAddress[msg.sender].add(numberOfTokens) <= maxItemPurchase, \"Minting would exceed allowance set in contract since the max is being enforced\");\n            }\n        }\n\n        // Ensure other conditions are met before proceeding\n        require(RAND_PRIME > 0, \"Random prime number has not been defined\");\n        require(salesActive, \"Sale must be active\");\n        require(numberOfTokens <= maxItemPurchase, \"Can only mint 3 items at a time\");\n        require(totalSupply().add(numberOfTokens) <= MAX_ITEMS, \"Minting would exceed max supply\");\n\n        // Specify the block timestamp of the first mint to define NFT distribution\n        if (TIMESTAMP == 0) {\n            TIMESTAMP = block.timestamp;\n        }\n\n        // Mint i tokens where i is specified by function invoker\n        for(uint256 i = 0; i < numberOfTokens; i++) {\n            uint256 index = totalSupply() + 1; // Start at 1\n            uint256 seq = RAND_PRIME * index;\n            uint256 seqOffset = seq + TIMESTAMP;\n            uint256 tokenId = (seqOffset % MAX_ITEMS) + 1; // Prevent tokenId 0\n            if (totalSupply() < MAX_ITEMS) {\n                // Add some \"just in case\" checks to prevent collisions\n                require(!checkIndexIsMinted(index), \"Index has already been used to mint\");\n                require(!checkTokenIsMinted(tokenId), \"TokenId has already been minted and transferred\");\n\n                // Mint and transfer to buyer\n                _safeMint(msg.sender, tokenId);\n\n                // Save the respective index and token Id for future reference\n                tokenIdsByIndex[index] = tokenId;\n                tokenIndexesById[tokenId] = index;\n\n                // Tally mints per address - SHM toggle allows for reset to 0 for hodlers\n                if (soupHodlersMode) {\n                    phaseOneMondrianBalanceByAddress[msg.sender] = phaseOneMondrianBalanceByAddress[msg.sender].add(1);\n                } else {\n                    phaseTwoMondrianBalanceByAddress[msg.sender] = phaseTwoMondrianBalanceByAddress[msg.sender].add(1);\n                }\n\n            }\n        }\n    }","after":"function mintItem(\n      uint256 numberOfTokens,\n      uint256[] calldata tokenIds\n    ) public payable {\n        // First do \"soup hodler\" mode check\n        // Ensure sender is a soup hodler and save tokens to prevent reuse\n        if (soupHodlersMode) {\n            require(tokenIds.length > 0, \"Must provide at least 1 token id\");\n            require(tokenIds.length == numberOfTokens, \"Number of tokens requested must be equal to number of soup token Ids provided\");\n            // Loop through the provided tokens to ensure the sender owns them\n            for(uint256 i = 0; i < tokenIds.length; i++) {\n                uint256 tokenId = tokenIds[i];\n                require(_nfs.ownerOf(tokenId) == msg.sender, \"Sender is not the owner of provided soup\");\n                // Lock in token Id to sender's address and update soup balance\n                if (soupAddressByTokenId[tokenId] == address(0x0)) {\n                    soupAddressByTokenId[tokenId] = msg.sender;\n                    soupBalanceByAddress[msg.sender] = soupBalanceByAddress[msg.sender].add(1);\n                } else {\n                    require(soupAddressByTokenId[tokenId] == msg.sender, \"Token already associated with another sender\");\n                }\n                require(totalSupply().add(numberOfTokens) <= _nfs.totalSupply(), \"Cannot mint more Mondrians than Soups that exist\");\n            }\n\n            uint256 allottedMints = soupBalanceByAddress[msg.sender] - phaseOneMondrianBalanceByAddress[msg.sender];\n            require(numberOfTokens <= allottedMints, \"Minting would exceed allowance set in contract based upon your balance of Soups (NFS)\");\n        } else {\n            if (maxItemsEnforced) {\n                require(phaseTwoMondrianBalanceByAddress[msg.sender].add(numberOfTokens) <= maxItemPurchase, \"Minting would exceed allowance set in contract since the max is being enforced\");\n            }\n        }\n\n        // Ensure other conditions are met before proceeding\n        require(RAND_PRIME > 0, \"Random prime number has not been defined\");\n        require(salesActive, \"Sale must be active\");\n        require(numberOfTokens <= maxItemPurchase, \"Can only mint 3 items at a time\");\n        require(totalSupply().add(numberOfTokens) <= MAX_ITEMS, \"Minting would exceed max supply\");\n\n        // Specify the block timestamp of the first mint to define NFT distribution\n        if (TIMESTAMP == 0) {\n            TIMESTAMP = block.timestamp;\n        }\n\n        // Mint i tokens where i is specified by function invoker\n        for(uint256 i = 0; i < numberOfTokens; i++) {\n            uint256 index = totalSupply() + 1; // Start at 1\n            uint256 seq = RAND_PRIME * index;\n            uint256 seqOffset = seq + TIMESTAMP;\n            uint256 tokenId = (seqOffset % MAX_ITEMS) + 1; // Prevent tokenId 0\n            if (totalSupply() < MAX_ITEMS) {\n                // Add some \"just in case\" checks to prevent collisions\n                require(!checkIndexIsMinted(index), \"Index has already been used to mint\");\n                require(!checkTokenIsMinted(tokenId), \"TokenId has already been minted and transferred\");\n\n                // Mint and transfer to buyer\n                _safeMint(msg.sender, tokenId);\n\n                // Save the respective index and token Id for future reference\n                tokenIdsByIndex[index] = tokenId;\n                tokenIndexesById[tokenId] = index;\n\n                // Tally mints per address - SHM toggle allows for reset to 0 for hodlers\n                if (soupHodlersMode) {\n                    phaseOneMondrianBalanceByAddress[msg.sender] = phaseOneMondrianBalanceByAddress[msg.sender].add(1);\n                } else {\n                    phaseTwoMondrianBalanceByAddress[msg.sender] = phaseTwoMondrianBalanceByAddress[msg.sender].add(1);\n                }\n\n            }\n        }\n    }","contract":"Mondrian","time":1},{"type":"external-function ","before":"function setBaseURI(string memory URI) public onlyOwner {\n        baseURI = URI;\n    }","after":"function setBaseURI(string calldata URI) public onlyOwner {\n        baseURI = URI;\n    }","contract":"NonFungibleSoup","time":0}]}