{"time":221,"results":[{"type":"state-data-arrangement ","before":"\nbytes32 public DOMAIN_SEPARATOR;\nuint8 public currentPresaleId;\nuint8 public tokensReserved;\nuint16 public immutable reserveCount;\nuint16 public nextTokenId;\nuint16 public maxMintsPerTransaction = 10;\nuint256 public startingIndex;\nuint256 public startingIndexBlock;\nuint256 public presaleTokenPrice = 0.02 ether;\nuint256 public tokenPrice = 0.04 ether;\nuint256 public immutable maxSupply;\nbool isPresaleActive = false;\nbool isSaleOpen = false;\naddress whitelister;\naddress payable public treasury;\nmapping(uint8 => mapping(address => uint16)) public presaleBoughtCounts;\nbytes32 public constant PRESALE_TYPEHASH =\n        keccak256(\"Presale(address buyer,uint16 maxCount, uint8 presaleId )\");\nstring public baseURI;\nstring public SLAVS_PROVENANCE = \"\";","after":"bytes32 public DOMAIN_SEPARATOR;\nuint256 public startingIndex;\nuint256 public startingIndexBlock;\nuint256 public presaleTokenPrice = 0.02 ether;\nuint256 public tokenPrice = 0.04 ether;\nuint256 public immutable maxSupply;\nmapping(uint8 => mapping(address => uint16)) public presaleBoughtCounts;\nbytes32 public constant PRESALE_TYPEHASH =\n        keccak256(\"Presale(address buyer,uint16 maxCount, uint8 presaleId )\");\nstring public baseURI;\nstring public SLAVS_PROVENANCE = \"\";\naddress whitelister;\naddress payable public treasury;\nuint16 public immutable reserveCount;\nuint16 public nextTokenId;\nuint16 public maxMintsPerTransaction = 10;\nuint8 public currentPresaleId;\nuint8 public tokensReserved;\nbool isPresaleActive = false;\nbool isSaleOpen = false;\n","contract":"Slavs","time":11},{"type":"external-function ","before":"function mintPresaleTokens(\n        uint16 maxCount,\n        uint8 presaleId,\n        uint8 count,\n        bytes memory signature\n    ) external payable presaleIsOpen {\n        bytes32 message = formMessage(maxCount, presaleId, msg.sender);\n\n        address signer = recoverAddress(message, signature);\n        require(whitelister == signer, \"Invalid signature provided\");\n\n        uint16 _nextTokenId = nextTokenId;\n\n        require(treasury != address(0), \"Slavs: treasury not set\");\n        require(presaleTokenPrice > 0, \"Slavs: token price not set\");\n        require(count > 0, \"Slavs: invalid count\");\n\n        require(\n            _nextTokenId + count <= maxSupply,\n            \"Slavs: max supply exceeded\"\n        );\n        require(\n            presaleTokenPrice * count == msg.value,\n            \"Slavs: incorrect Ether value\"\n        );\n\n        require(\n            signer != address(0) && signer == whitelister,\n            \"Slavs: invalid signature\"\n        );\n\n        require(\n            presaleBoughtCounts[currentPresaleId][msg.sender] + count <=\n                maxCount,\n            \"Slavs: presale max count exceeded\"\n        );\n        presaleBoughtCounts[currentPresaleId][msg.sender] += count;\n\n        treasury.transfer(msg.value);\n\n        for (uint256 ind = 0; ind < count; ind++) {\n            _safeMint(msg.sender, _nextTokenId + ind);\n        }\n        nextTokenId += count;\n    }","after":"function mintPresaleTokens(\n        uint16 maxCount,\n        uint8 presaleId,\n        uint8 count,\n        bytes calldata signature\n    ) external payable presaleIsOpen {\n        bytes32 message = formMessage(maxCount, presaleId, msg.sender);\n\n        address signer = recoverAddress(message, signature);\n        require(whitelister == signer, \"Invalid signature provided\");\n\n        uint16 _nextTokenId = nextTokenId;\n\n        require(treasury != address(0), \"Slavs: treasury not set\");\n        require(presaleTokenPrice > 0, \"Slavs: token price not set\");\n        require(count > 0, \"Slavs: invalid count\");\n\n        require(\n            _nextTokenId + count <= maxSupply,\n            \"Slavs: max supply exceeded\"\n        );\n        require(\n            presaleTokenPrice * count == msg.value,\n            \"Slavs: incorrect Ether value\"\n        );\n\n        require(\n            signer != address(0) && signer == whitelister,\n            \"Slavs: invalid signature\"\n        );\n\n        require(\n            presaleBoughtCounts[currentPresaleId][msg.sender] + count <=\n                maxCount,\n            \"Slavs: presale max count exceeded\"\n        );\n        presaleBoughtCounts[currentPresaleId][msg.sender] += count;\n\n        treasury.transfer(msg.value);\n\n        for (uint256 ind = 0; ind < count; ind++) {\n            _safeMint(msg.sender, _nextTokenId + ind);\n        }\n        nextTokenId += count;\n    }","contract":"Slavs","time":0},{"type":"external-function ","before":"function setProvenanceHash(string memory provenanceHash) public onlyOwner {\n        SLAVS_PROVENANCE = provenanceHash;\n    }","after":"function setProvenanceHash(string calldata provenanceHash) public onlyOwner {\n        SLAVS_PROVENANCE = provenanceHash;\n    }","contract":"Slavs","time":0},{"type":"immutable-restrict-modification ","before":"bytes32 public DOMAIN_SEPARATOR;","after":"bytes32 public immutable DOMAIN_SEPARATOR;","contract":"Slavs","time":2}]}