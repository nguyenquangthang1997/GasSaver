{"time":155,"results":[{"type":"state-data-arrangement ","before":"\nuint8 constant RED_BORDER_TOKEN_ID = 0;\nuint8 constant WHITE_BORDER_TOKEN_ID = 1;\nuint8 constant ROBOTO_RED = 0;\nuint8 constant ENTERTAINER_RED = 1;\nuint8 constant BUSINESS_PERSON_RED = 2;\nuint8 constant ATHLETE_RED = 3;\nuint8 constant HERO_RED = 4;\nuint8 constant ROBOTO_WHITE = 5;\nuint8 constant ENTERTAINER_WHITE = 6;\nuint8 constant BUSINESS_PERSON_WHITE = 7;\nuint8 constant ATHLETE_WHITE = 8;\nuint8 constant HERO_WHITE = 9;\nuint16[10] availableTokens;\nmapping(uint8 => uint8[]) availableTokensIds;\nbool private isFrozen = false;\nstring public name = \"TIMEPieces x Robotos\";","after":"uint16[10] availableTokens;\nmapping(uint8 => uint8[]) availableTokensIds;\nstring public name = \"TIMEPieces x Robotos\";\nuint8 constant RED_BORDER_TOKEN_ID = 0;\nuint8 constant WHITE_BORDER_TOKEN_ID = 1;\nuint8 constant ROBOTO_RED = 0;\nuint8 constant ENTERTAINER_RED = 1;\nuint8 constant BUSINESS_PERSON_RED = 2;\nuint8 constant ATHLETE_RED = 3;\nuint8 constant HERO_RED = 4;\nuint8 constant ROBOTO_WHITE = 5;\nuint8 constant ENTERTAINER_WHITE = 6;\nuint8 constant BUSINESS_PERSON_WHITE = 7;\nuint8 constant ATHLETE_WHITE = 8;\nuint8 constant HERO_WHITE = 9;\nbool private isFrozen = false;\n","contract":"TimePiecesRoboto","time":0},{"type":"external-function ","before":"function setURI(string memory _uri) external onlyOwner contractIsNotFrozen {\n        _setURI(_uri);\n    }","after":"function setURI(string calldata _uri) external onlyOwner contractIsNotFrozen {\n        _setURI(_uri);\n    }","contract":"TimePiecesRoboto","time":0},{"type":"external-function ","before":"function devMintTokensToAddresses(uint8 _tokenBorderId, address[] memory _addresses) external onlyOwner contractIsNotFrozen {\n        require(_addresses.length > 0, \"At least one token should be minted\");\n        require(getAvailableTokens(_tokenBorderId) >= _addresses.length, \"Not enough tokens available\");\n\n        uint16[10] memory tmpAvailableTokens = availableTokens;\n\n        for (uint256 i; i < _addresses.length; i++) {\n            uint8 tokenTypeIndex = _getRandomNumber(availableTokensIds[_tokenBorderId].length, i);\n\n            _mint(_addresses[i], availableTokensIds[_tokenBorderId][tokenTypeIndex], 1, \"\");\n\n            tmpAvailableTokens[availableTokensIds[_tokenBorderId][tokenTypeIndex]]--;\n\n            if (tmpAvailableTokens[availableTokensIds[_tokenBorderId][tokenTypeIndex]] == 0) {\n                availableTokensIds[_tokenBorderId][tokenTypeIndex] = availableTokensIds[_tokenBorderId][availableTokensIds[_tokenBorderId].length - 1];\n                availableTokensIds[_tokenBorderId].pop();        \n            }\n        }\n\n        availableTokens = tmpAvailableTokens;\n    }","after":"function devMintTokensToAddresses(uint8 _tokenBorderId, address[] calldata _addresses) external onlyOwner contractIsNotFrozen {\n        require(_addresses.length > 0, \"At least one token should be minted\");\n        require(getAvailableTokens(_tokenBorderId) >= _addresses.length, \"Not enough tokens available\");\n\n        uint16[10] memory tmpAvailableTokens = availableTokens;\n\n        for (uint256 i; i < _addresses.length; i++) {\n            uint8 tokenTypeIndex = _getRandomNumber(availableTokensIds[_tokenBorderId].length, i);\n\n            _mint(_addresses[i], availableTokensIds[_tokenBorderId][tokenTypeIndex], 1, \"\");\n\n            tmpAvailableTokens[availableTokensIds[_tokenBorderId][tokenTypeIndex]]--;\n\n            if (tmpAvailableTokens[availableTokensIds[_tokenBorderId][tokenTypeIndex]] == 0) {\n                availableTokensIds[_tokenBorderId][tokenTypeIndex] = availableTokensIds[_tokenBorderId][availableTokensIds[_tokenBorderId].length - 1];\n                availableTokensIds[_tokenBorderId].pop();        \n            }\n        }\n\n        availableTokens = tmpAvailableTokens;\n    }","contract":"TimePiecesRoboto","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"TimePiecesRoboto","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"TimePiecesRoboto","time":0},{"type":"constant-restrict-modification  ","before":"string public name = \"TIMEPieces x Robotos\";","after":"string public constant name = \"TIMEPieces x Robotos\";","contract":"TimePiecesRoboto","time":1}]}