{"time":420,"results":[{"type":"loop-duplication","before":"\nstart line 391 column 6, end line 394 column 6\nfor (uint256 i = 0; i < outcomesShares.length; i++) {\n        uint256 outcomeShares = outcomesShares[i];\n        if (poolWeight < outcomeShares) poolWeight = outcomeShares;\n      }\nstart line 396 column 6, end line 399 column 6\nfor (uint256 i = 0; i < outcomesShares.length; i++) {\n        uint256 remaining = value.mul(outcomesShares[i]) / poolWeight;\n        sendBackAmounts[i] = value.sub(remaining);\n      }","after":"// merge loop\n\nstart line 391 column 6, end line 394 column 6\nfor (uint256 i = 0; i < outcomesShares.length; i++) {\n        uint256 outcomeShares = outcomesShares[i];\n        if (poolWeight < outcomeShares) poolWeight = outcomeShares;\n      }\nstart line 396 column 6, end line 399 column 6\nfor (uint256 i = 0; i < outcomesShares.length; i++) {\n        uint256 remaining = value.mul(outcomesShares[i]) / poolWeight;\n        sendBackAmounts[i] = value.sub(remaining);\n      }","contract":"PredictionMarket","time":0},{"type":"state-data-arrangement ","before":"\naddress constant NULL_ADDRESS = address(0);\nbytes32 constant NULL_HASH = bytes32(0);\nuint32 constant UNANSWERED = 0;\nuint256 constant COMMITMENT_NON_EXISTENT = 0;\nuint32 constant COMMITMENT_TIMEOUT_RATIO = 8;\nuint256 nextTemplateID = 0;\nmapping(uint256 => uint256) public templates;\nmapping(uint256 => bytes32) public template_hashes;\nmapping(bytes32 => Question) public questions;\nmapping(bytes32 => Claim) public question_claims;\nmapping(bytes32 => Commitment) public commitments;\nmapping(address => uint256) public arbitrator_question_fees;","after":"bytes32 constant NULL_HASH = bytes32(0);\nuint256 constant COMMITMENT_NON_EXISTENT = 0;\nuint256 nextTemplateID = 0;\nmapping(uint256 => uint256) public templates;\nmapping(uint256 => bytes32) public template_hashes;\nmapping(bytes32 => Question) public questions;\nmapping(bytes32 => Claim) public question_claims;\nmapping(bytes32 => Commitment) public commitments;\nmapping(address => uint256) public arbitrator_question_fees;\naddress constant NULL_ADDRESS = address(0);\nuint32 constant UNANSWERED = 0;\nuint32 constant COMMITMENT_TIMEOUT_RATIO = 8;\n","contract":"RealitioERC20","time":0},{"type":"external-function ","before":"function createTemplateAndAskQuestion(\n        string memory content,\n        string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce\n    )\n        // stateNotCreated is enforced by the internal _askQuestion\n    public returns (bytes32) {\n        uint256 template_id = createTemplate(content);\n        return askQuestion(template_id, question, arbitrator, timeout, opening_ts, nonce);\n    }","after":"function createTemplateAndAskQuestion(\n        string calldata content,\n        string calldata question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce\n    )\n        // stateNotCreated is enforced by the internal _askQuestion\n    public returns (bytes32) {\n        uint256 template_id = createTemplate(content);\n        return askQuestion(template_id, question, arbitrator, timeout, opening_ts, nonce);\n    }","contract":"RealitioERC20","time":0},{"type":"external-function ","before":"function askQuestionERC20(uint256 template_id, string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 tokens)\n        // stateNotCreated is enforced by the internal _askQuestion\n    public returns (bytes32) {\n\n        _deductTokensOrRevert(tokens);\n\n        require(templates[template_id] > 0, \"template must exist\");\n\n        bytes32 content_hash = keccak256(abi.encodePacked(template_id, opening_ts, question));\n        bytes32 question_id = keccak256(abi.encodePacked(content_hash, arbitrator, timeout, msg.sender, nonce));\n\n        _askQuestion(question_id, content_hash, arbitrator, timeout, opening_ts, tokens);\n        emit LogNewQuestion(question_id, msg.sender, template_id, question, content_hash, arbitrator, timeout, opening_ts, nonce, now);\n\n        return question_id;\n    }","after":"function askQuestionERC20(uint256 template_id, string calldata question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 tokens)\n        // stateNotCreated is enforced by the internal _askQuestion\n    public returns (bytes32) {\n\n        _deductTokensOrRevert(tokens);\n\n        require(templates[template_id] > 0, \"template must exist\");\n\n        bytes32 content_hash = keccak256(abi.encodePacked(template_id, opening_ts, question));\n        bytes32 question_id = keccak256(abi.encodePacked(content_hash, arbitrator, timeout, msg.sender, nonce));\n\n        _askQuestion(question_id, content_hash, arbitrator, timeout, opening_ts, tokens);\n        emit LogNewQuestion(question_id, msg.sender, template_id, question, content_hash, arbitrator, timeout, opening_ts, nonce, now);\n\n        return question_id;\n    }","contract":"RealitioERC20","time":0},{"type":"external-function ","before":"function claimMultipleAndWithdrawBalance(\n        bytes32[] memory question_ids, uint256[] memory lengths,\n        bytes32[] memory hist_hashes, address[] memory addrs, uint256[] memory bonds, bytes32[] memory answers\n    )\n        stateAny() // The finalization checks are done in the claimWinnings function\n    public {\n\n        uint256 qi;\n        uint256 i;\n        for (qi = 0; qi < question_ids.length; qi++) {\n            bytes32 qid = question_ids[qi];\n            uint256 ln = lengths[qi];\n            bytes32[] memory hh = new bytes32[](ln);\n            address[] memory ad = new address[](ln);\n            uint256[] memory bo = new uint256[](ln);\n            bytes32[] memory an = new bytes32[](ln);\n            uint256 j;\n            for (j = 0; j < ln; j++) {\n                hh[j] = hist_hashes[i];\n                ad[j] = addrs[i];\n                bo[j] = bonds[i];\n                an[j] = answers[i];\n                i++;\n            }\n            claimWinnings(qid, hh, ad, bo, an);\n        }\n        withdraw();\n    }","after":"function claimMultipleAndWithdrawBalance(\n        bytes32[] calldata question_ids, uint256[] calldata lengths,\n        bytes32[] calldata hist_hashes, address[] calldata addrs, uint256[] calldata bonds, bytes32[] calldata answers\n    )\n        stateAny() // The finalization checks are done in the claimWinnings function\n    public {\n\n        uint256 qi;\n        uint256 i;\n        for (qi = 0; qi < question_ids.length; qi++) {\n            bytes32 qid = question_ids[qi];\n            uint256 ln = lengths[qi];\n            bytes32[] memory hh = new bytes32[](ln);\n            address[] memory ad = new address[](ln);\n            uint256[] memory bo = new uint256[](ln);\n            bytes32[] memory an = new bytes32[](ln);\n            uint256 j;\n            for (j = 0; j < ln; j++) {\n                hh[j] = hist_hashes[i];\n                ad[j] = addrs[i];\n                bo[j] = bonds[i];\n                an[j] = answers[i];\n                i++;\n            }\n            claimWinnings(qid, hh, ad, bo, an);\n        }\n        withdraw();\n    }","contract":"RealitioERC20","time":0}]}