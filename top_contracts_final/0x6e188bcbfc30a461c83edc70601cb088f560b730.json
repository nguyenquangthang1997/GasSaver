{"time":172,"results":[{"type":"external-function ","before":"function mint(uint256 _mintAmount, uint256[] memory ids) public payable mintCompliance(_mintAmount) {\n    require(!paused, \"The contract is paused!\");\n    require(saleActive, \"Sale is not Active\" );\n    require(msg.value >= cost * _mintAmount, \"Insufficient funds!\");\n    require(addressMintedBalance[msg.sender] <= maxMintAmountPerTx, \"Max mint amount per wallet reached\");\n    _mintLoop(msg.sender, _mintAmount, ids);\n  }","after":"function mint(uint256 _mintAmount, uint256[] calldata ids) public payable mintCompliance(_mintAmount) {\n    require(!paused, \"The contract is paused!\");\n    require(saleActive, \"Sale is not Active\" );\n    require(msg.value >= cost * _mintAmount, \"Insufficient funds!\");\n    require(addressMintedBalance[msg.sender] <= maxMintAmountPerTx, \"Max mint amount per wallet reached\");\n    _mintLoop(msg.sender, _mintAmount, ids);\n  }","contract":"BATC","time":0},{"type":"external-function ","before":"function mintForAddress(uint256 _mintAmount, address _receiver, uint256[] memory ids) public mintCompliance(_mintAmount) onlyOwner {\n    _mintLoop(_receiver, _mintAmount, ids);\n  }","after":"function mintForAddress(uint256 _mintAmount, address _receiver, uint256[] calldata ids) public mintCompliance(_mintAmount) onlyOwner {\n    _mintLoop(_receiver, _mintAmount, ids);\n  }","contract":"BATC","time":0},{"type":"external-function ","before":"function mintForSelf(uint256 _mintAmount, uint256[] memory ids) public selfMintCompliance(_mintAmount) onlyOwner {\n    _mintLoop(msg.sender, _mintAmount, ids);\n  }","after":"function mintForSelf(uint256 _mintAmount, uint256[] calldata ids) public selfMintCompliance(_mintAmount) onlyOwner {\n    _mintLoop(msg.sender, _mintAmount, ids);\n  }","contract":"BATC","time":0},{"type":"external-function ","before":"function whitelistMint(uint _mintAmount, bytes32 leaf, bytes32[] memory proof, uint allowance, uint256[] memory ids) external payable whitelistMintCompliance(_mintAmount, leaf, allowance) {\n    require(presaleActive, \"Sale is not Active\" );\n    // Verify that (msg.sender, amount) correspond to Merkle leaf\n    // require(keccak256(abi.encodePacked(msg.sender)) == leaf, \"Sender and amount don't match Merkle leaf\");\n\n     // Verify that (leaf, proof) matches the Merkle root\n    require(verify(merkleRoot, leaf, proof), \"Not a valid leaf in the Merkle tree\");\n    require(msg.value >= cost * _mintAmount, \"Insufficient funds!\");\n    uint256 maxMintAmount = isHigherWhitelistMember(allowance) ? maxMintAmountPerTxForHigher : maxMintAmountPerTx;\n    require(addressMintedBalance[msg.sender] + _mintAmount <= maxMintAmount, \"Max mint amount per wallet reached\");\n    _mintLoop(msg.sender, _mintAmount, ids);\n  }","after":"function whitelistMint(uint _mintAmount, bytes32 leaf, bytes32[] calldata proof, uint allowance, uint256[] calldata ids) external payable whitelistMintCompliance(_mintAmount, leaf, allowance) {\n    require(presaleActive, \"Sale is not Active\" );\n    // Verify that (msg.sender, amount) correspond to Merkle leaf\n    // require(keccak256(abi.encodePacked(msg.sender)) == leaf, \"Sender and amount don't match Merkle leaf\");\n\n     // Verify that (leaf, proof) matches the Merkle root\n    require(verify(merkleRoot, leaf, proof), \"Not a valid leaf in the Merkle tree\");\n    require(msg.value >= cost * _mintAmount, \"Insufficient funds!\");\n    uint256 maxMintAmount = isHigherWhitelistMember(allowance) ? maxMintAmountPerTxForHigher : maxMintAmountPerTx;\n    require(addressMintedBalance[msg.sender] + _mintAmount <= maxMintAmount, \"Max mint amount per wallet reached\");\n    _mintLoop(msg.sender, _mintAmount, ids);\n  }","contract":"BATC","time":0},{"type":"external-function ","before":"function setUriSuffix(string memory _uriSuffix) public onlyOwner {\n    uriSuffix = _uriSuffix;\n  }","after":"function setUriSuffix(string calldata _uriSuffix) public onlyOwner {\n    uriSuffix = _uriSuffix;\n  }","contract":"BATC","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public maxSupply = 10000;","after":"uint256 public constant maxSupply = 10000;","contract":"BATC","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public maxMintAmountPerTxForHigher = 4;","after":"uint256 public constant maxMintAmountPerTxForHigher = 4;","contract":"BATC","time":0}]}