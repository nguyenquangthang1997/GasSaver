{"time":92,"results":[{"type":"external-function ","before":"function setPrice(string memory purchaseId, uint256 ethPrice, uint256 erc20TokenPrice) public onlyOwner {\n        _prices[purchaseId] = Price(ethPrice, erc20TokenPrice);\n        emit PriceUpdated(purchaseId, ethPrice, erc20TokenPrice);\n    }","after":"function setPrice(string calldata purchaseId, uint256 ethPrice, uint256 erc20TokenPrice) public onlyOwner {\n        _prices[purchaseId] = Price(ethPrice, erc20TokenPrice);\n        emit PriceUpdated(purchaseId, ethPrice, erc20TokenPrice);\n    }","contract":"SimpleSale","time":0},{"type":"external-function ","before":"function purchaseFor(\n        address destination,\n        string memory purchaseId,\n        uint256 quantity,\n        address paymentToken\n    ) public payable {\n        require(quantity > 0, \"Quantity can't be 0\");\n        require(paymentToken == ETH_ADDRESS || paymentToken == _erc20Token, \"Unsupported payment token\");\n\n        address payable sender = _msgSender();\n\n        Price memory price = _prices[purchaseId];\n\n        if (paymentToken == ETH_ADDRESS) {\n            require(price.ethPrice != 0, \"purchaseId not found\");\n            uint totalPrice = price.ethPrice.mul(quantity);\n            require(msg.value >= totalPrice, \"Insufficient ETH\");\n            _payoutWallet.transfer(totalPrice);\n\n            uint256 change = msg.value.sub(totalPrice);\n            if (change > 0) {\n                sender.transfer(change);\n            }\n            emit Purchased(purchaseId, paymentToken, price.ethPrice, quantity, destination, sender);\n        } else {\n            require(_erc20Token != address(0), \"ERC20 payment not supported\");\n            require(price.erc20Price != 0, \"Price not found\");\n            uint totalPrice = price.erc20Price.mul(quantity);\n            require(ERC20(_erc20Token).transferFrom(sender, _payoutWallet, totalPrice));\n            emit Purchased(purchaseId, paymentToken, price.erc20Price, quantity, destination, sender);\n        }\n    }","after":"function purchaseFor(\n        address destination,\n        string calldata purchaseId,\n        uint256 quantity,\n        address paymentToken\n    ) public payable {\n        require(quantity > 0, \"Quantity can't be 0\");\n        require(paymentToken == ETH_ADDRESS || paymentToken == _erc20Token, \"Unsupported payment token\");\n\n        address payable sender = _msgSender();\n\n        Price memory price = _prices[purchaseId];\n\n        if (paymentToken == ETH_ADDRESS) {\n            require(price.ethPrice != 0, \"purchaseId not found\");\n            uint totalPrice = price.ethPrice.mul(quantity);\n            require(msg.value >= totalPrice, \"Insufficient ETH\");\n            _payoutWallet.transfer(totalPrice);\n\n            uint256 change = msg.value.sub(totalPrice);\n            if (change > 0) {\n                sender.transfer(change);\n            }\n            emit Purchased(purchaseId, paymentToken, price.ethPrice, quantity, destination, sender);\n        } else {\n            require(_erc20Token != address(0), \"ERC20 payment not supported\");\n            require(price.erc20Price != 0, \"Price not found\");\n            uint totalPrice = price.erc20Price.mul(quantity);\n            require(ERC20(_erc20Token).transferFrom(sender, _payoutWallet, totalPrice));\n            emit Purchased(purchaseId, paymentToken, price.erc20Price, quantity, destination, sender);\n        }\n    }","contract":"SimpleSale","time":0},{"type":"constant-restrict-modification  ","before":"address public ETH_ADDRESS = address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);","after":"address public constant ETH_ADDRESS = address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);","contract":"SimpleSale","time":0}]}