{"time":33,"results":[{"type":"external-function ","before":"function distributeAndLock(uint256 _amount, bytes32[]  memory proof, bool need_move) public{\n        require(!userMap[msg.sender], \"MerkleClaim: Account is already claimed\");\n        bytes32 node = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(!claimMap[node], \"MerkleClaim: Account is already claimed\");\n        require(MerkleProof.verify(proof, root, node), \"MerkleClaim: Verify failed\");\n        //update status\n        setClaim(node);\n        // uint256 half_amount = _amount.div(2);\n        // choose the choice\n        if(need_move){\n            new_locking_contract.lock(msg.sender, _amount);\n        }else{\n            dpr.transfer(msg.sender, _amount);\n        }\n        //lockTokens(_addr, _amount.sub(half_amount));\n        userMap[msg.sender] = true;\n        emit distribute(msg.sender, _amount);\n    }","after":"function distributeAndLock(uint256 _amount, bytes32[]  calldata proof, bool need_move) public{\n        require(!userMap[msg.sender], \"MerkleClaim: Account is already claimed\");\n        bytes32 node = keccak256(abi.encodePacked(msg.sender, _amount));\n        require(!claimMap[node], \"MerkleClaim: Account is already claimed\");\n        require(MerkleProof.verify(proof, root, node), \"MerkleClaim: Verify failed\");\n        //update status\n        setClaim(node);\n        // uint256 half_amount = _amount.div(2);\n        // choose the choice\n        if(need_move){\n            new_locking_contract.lock(msg.sender, _amount);\n        }else{\n            dpr.transfer(msg.sender, _amount);\n        }\n        //lockTokens(_addr, _amount.sub(half_amount));\n        userMap[msg.sender] = true;\n        emit distribute(msg.sender, _amount);\n    }","contract":"InstanceClaim","time":0}]}