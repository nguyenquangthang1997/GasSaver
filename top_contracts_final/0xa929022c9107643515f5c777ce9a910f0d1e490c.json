{"time":161,"results":[{"type":"immutable-restrict-modification ","before":"address private caller;","after":"address private immutable caller;","contract":"BridgeStorage","time":0},{"type":"constant-restrict-modification  ","before":"uint256 MaxItemAdressNum = 255;","after":"uint256 constant MaxItemAdressNum = 255;","contract":"BridgeStorage","time":0},{"type":"immutable-restrict-modification ","before":"address private caller;","after":"address private immutable caller;","contract":"BridgeLogic","time":0},{"type":"external-function ","before":"function depositNative(string memory _targetAddress, string memory  chain) public payable {\n        emit DepositNative(msg.sender, msg.value, _targetAddress,chain);\n    }","after":"function depositNative(string calldata _targetAddress, string calldata  chain) public payable {\n        emit DepositNative(msg.sender, msg.value, _targetAddress,chain);\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function depositToken(address _token, uint value, string memory _targetAddress, string memory chain) public payable returns (bool){\n        //deposit(address token, address _from, uint256 _value)\n        bool res = depositTokenLogic(_token,  msg.sender, value);\n        emit DepositToken(msg.sender, value, _token, _targetAddress, chain, msg.value);\n        return res;\n    }","after":"function depositToken(address _token, uint value, string calldata _targetAddress, string calldata chain) public payable returns (bool){\n        //deposit(address token, address _from, uint256 _value)\n        bool res = depositTokenLogic(_token,  msg.sender, value);\n        emit DepositToken(msg.sender, value, _token, _targetAddress, chain, msg.value);\n        return res;\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function withdrawNative(address payable to, uint value, string memory proof, bytes32 taskHash) public\n    onlyOperator\n    whenNotPaused\n    positiveValue(value)\n    returns(bool)\n    {\n        require(address(this).balance >= value, \"not enough native token\");\n        require(taskHash == keccak256((abi.encodePacked(to,value,proof))),\"taskHash is wrong\");\n        uint256 status = logic.supportTask(logic.WITHDRAWTASK(), taskHash, msg.sender, operatorRequireNum);\n\n        if (status == logic.TASKPROCESSING()){\n            emit WithdrawingNative(to, value, proof);\n        }else if (status == logic.TASKDONE()) {\n            emit WithdrawingNative(to, value, proof);\n            emit WithdrawDoneNative(to, value, proof);\n            to.transfer(value);\n            logic.removeTask(taskHash);\n        }\n        return true;\n    }","after":"function withdrawNative(address payable to, uint value, string calldata proof, bytes32 taskHash) public\n    onlyOperator\n    whenNotPaused\n    positiveValue(value)\n    returns(bool)\n    {\n        require(address(this).balance >= value, \"not enough native token\");\n        require(taskHash == keccak256((abi.encodePacked(to,value,proof))),\"taskHash is wrong\");\n        uint256 status = logic.supportTask(logic.WITHDRAWTASK(), taskHash, msg.sender, operatorRequireNum);\n\n        if (status == logic.TASKPROCESSING()){\n            emit WithdrawingNative(to, value, proof);\n        }else if (status == logic.TASKDONE()) {\n            emit WithdrawingNative(to, value, proof);\n            emit WithdrawDoneNative(to, value, proof);\n            to.transfer(value);\n            logic.removeTask(taskHash);\n        }\n        return true;\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function withdrawToken(address _token, address to, uint value, string memory proof, bytes32 taskHash) public\n    onlyOperator\n    whenNotPaused\n    positiveValue(value)\n    returns (bool)\n    {\n        require(taskHash == keccak256((abi.encodePacked(to,value,proof))),\"taskHash is wrong\");\n        uint256 status = logic.supportTask(logic.WITHDRAWTASK(), taskHash, msg.sender, operatorRequireNum);\n\n        if (status == logic.TASKPROCESSING()){\n            emit WithdrawingToken(to, _token, value, proof);\n        }else if (status == logic.TASKDONE()) {\n            // withdraw(address token, address _to, address _value)\n            bool res = withdrawTokenLogic( _token, to, value);\n\n            emit WithdrawingToken(to, _token, value, proof);\n            emit WithdrawDoneToken(to, _token, value, proof);\n            logic.removeTask(taskHash);\n            return res;\n        }\n        return true;\n    }","after":"function withdrawToken(address _token, address to, uint value, string calldata proof, bytes32 taskHash) public\n    onlyOperator\n    whenNotPaused\n    positiveValue(value)\n    returns (bool)\n    {\n        require(taskHash == keccak256((abi.encodePacked(to,value,proof))),\"taskHash is wrong\");\n        uint256 status = logic.supportTask(logic.WITHDRAWTASK(), taskHash, msg.sender, operatorRequireNum);\n\n        if (status == logic.TASKPROCESSING()){\n            emit WithdrawingToken(to, _token, value, proof);\n        }else if (status == logic.TASKDONE()) {\n            // withdraw(address token, address _to, address _value)\n            bool res = withdrawTokenLogic( _token, to, value);\n\n            emit WithdrawingToken(to, _token, value, proof);\n            emit WithdrawDoneToken(to, _token, value, proof);\n            logic.removeTask(taskHash);\n            return res;\n        }\n        return true;\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function modifyAdminAddress(string memory class, address oldAddress, address newAddress) public whenPaused {\n        require(newAddress != address(0x0), \"wrong address\");\n        bool flag = modifyAddress(class, oldAddress, newAddress);\n        if(flag){\n            bytes32 classHash = keccak256(abi.encodePacked(class));\n            if(classHash == LOGICHASH){\n                logic = BridgeLogic(newAddress);\n            }else if(classHash == STOREHASH){\n                logic.resetStoreLogic(newAddress);\n            }\n        }\n    }","after":"function modifyAdminAddress(string calldata class, address oldAddress, address newAddress) public whenPaused {\n        require(newAddress != address(0x0), \"wrong address\");\n        bool flag = modifyAddress(class, oldAddress, newAddress);\n        if(flag){\n            bytes32 classHash = keccak256(abi.encodePacked(class));\n            if(classHash == LOGICHASH){\n                logic = BridgeLogic(newAddress);\n            }else if(classHash == STOREHASH){\n                logic.resetStoreLogic(newAddress);\n            }\n        }\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function setDepositSelector(address token, string memory method, bool _isValueFirst) onlyOperator external{\n        depositSelector[token] = assetSelector(method,_isValueFirst);\n    }","after":"function setDepositSelector(address token, string calldata method, bool _isValueFirst) onlyOperator external{\n        depositSelector[token] = assetSelector(method,_isValueFirst);\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function setWithdrawSelector(address token, string memory method, bool _isValueFirst) onlyOperator external{\n        withdrawSelector[token] = assetSelector(method,_isValueFirst);\n    }","after":"function setWithdrawSelector(address token, string calldata method, bool _isValueFirst) onlyOperator external{\n        withdrawSelector[token] = assetSelector(method,_isValueFirst);\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function resetRequiredNum(string memory class, uint256 requiredNum) public onlyOwner returns (bool){\n        bytes32 classHash = getClassHash(class);\n        require((classHash == OPERATORHASH) || (classHash == OWNERHASH), \"wrong class\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"resetRequiredNum\", class, requiredNum));\n        addItemAddress(taskHash, msg.sender);\n\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            removeItem(taskHash);\n            uint256 previousNum = 0;\n            if (classHash == OWNERHASH) {\n                previousNum = ownerRequireNum;\n                ownerRequireNum = requiredNum;\n            }\n            else if (classHash == OPERATORHASH) {\n                previousNum = operatorRequireNum;\n                operatorRequireNum = requiredNum;\n            } else {\n                revert(\"wrong class\");\n            }\n            emit AdminRequiredNumChanged(\"resetRequiredNum\", class, previousNum, requiredNum);\n        }\n        return true;\n    }","after":"function resetRequiredNum(string calldata class, uint256 requiredNum) public onlyOwner returns (bool){\n        bytes32 classHash = getClassHash(class);\n        require((classHash == OPERATORHASH) || (classHash == OWNERHASH), \"wrong class\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"resetRequiredNum\", class, requiredNum));\n        addItemAddress(taskHash, msg.sender);\n\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            removeItem(taskHash);\n            uint256 previousNum = 0;\n            if (classHash == OWNERHASH) {\n                previousNum = ownerRequireNum;\n                ownerRequireNum = requiredNum;\n            }\n            else if (classHash == OPERATORHASH) {\n                previousNum = operatorRequireNum;\n                operatorRequireNum = requiredNum;\n            } else {\n                revert(\"wrong class\");\n            }\n            emit AdminRequiredNumChanged(\"resetRequiredNum\", class, previousNum, requiredNum);\n        }\n        return true;\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function dropAddress(string memory class, address oneAddress) public onlyOwner returns (bool){\n        bytes32 classHash = getClassHash(class);\n        require(classHash != STOREHASH && classHash != LOGICHASH, \"wrong class\");\n        require(itemAddressExists(classHash, oneAddress), \"no such address exist\");\n\n        if (classHash == OWNERHASH)\n            require(getItemAddressCount(classHash) > ownerRequireNum, \"insuffience addresses\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"dropAddress\", class, oneAddress));\n        addItemAddress(taskHash, msg.sender);\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            removeOneItemAddress(classHash, oneAddress);\n            emit AdminChanged(\"dropAddress\", class, oneAddress, oneAddress);\n            removeItem(taskHash);\n            return true;\n        }\n        return false;\n    }","after":"function dropAddress(string calldata class, address oneAddress) public onlyOwner returns (bool){\n        bytes32 classHash = getClassHash(class);\n        require(classHash != STOREHASH && classHash != LOGICHASH, \"wrong class\");\n        require(itemAddressExists(classHash, oneAddress), \"no such address exist\");\n\n        if (classHash == OWNERHASH)\n            require(getItemAddressCount(classHash) > ownerRequireNum, \"insuffience addresses\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"dropAddress\", class, oneAddress));\n        addItemAddress(taskHash, msg.sender);\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            removeOneItemAddress(classHash, oneAddress);\n            emit AdminChanged(\"dropAddress\", class, oneAddress, oneAddress);\n            removeItem(taskHash);\n            return true;\n        }\n        return false;\n    }","contract":"Bridge","time":0},{"type":"external-function ","before":"function addAddress(string memory class, address oneAddress) public onlyOwner returns (bool){\n        bytes32 classHash = getClassHash(class);\n        require(classHash != STOREHASH && classHash != LOGICHASH, \"wrong class\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"addAddress\", class, oneAddress));\n        addItemAddress(taskHash, msg.sender);\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            addItemAddress(classHash, oneAddress);\n            emit AdminChanged(\"addAddress\", class, oneAddress, oneAddress);\n            removeItem(taskHash);\n            return true;\n        }\n        return false;\n    }","after":"function addAddress(string calldata class, address oneAddress) public onlyOwner returns (bool){\n        bytes32 classHash = getClassHash(class);\n        require(classHash != STOREHASH && classHash != LOGICHASH, \"wrong class\");\n\n        bytes32 taskHash = keccak256(abi.encodePacked(\"addAddress\", class, oneAddress));\n        addItemAddress(taskHash, msg.sender);\n        if (getItemAddressCount(taskHash) >= ownerRequireNum) {\n            addItemAddress(classHash, oneAddress);\n            emit AdminChanged(\"addAddress\", class, oneAddress, oneAddress);\n            removeItem(taskHash);\n            return true;\n        }\n        return false;\n    }","contract":"Bridge","time":0},{"type":"constant-restrict-modification  ","before":"uint256 MaxItemAdressNum = 255;","after":"uint256 constant MaxItemAdressNum = 255;","contract":"Bridge","time":1}]}