{"time":163,"results":[{"type":"state-data-arrangement ","before":"\nuint256 public constant PRE_SALE_NFT_PRICE = 0.076 ether;\nuint256 public constant PUBLIC_SALE_NFT_PRICE = 0.08 ether;\nuint256 public constant MAX_NFT_PURCHASE = 5;\nuint256 public constant MAX_SUPPLY = 10000;\nuint256 public freeClaimStartTime;\nuint256 public freeClaimEndTime;\nbytes32 private _freeClaimMerkleRoot;\nmapping(address => bool) public claimed;\nuint256 public preSaleStartTime;\nuint256 public publicSaleStartTime;\nbytes32 private _merkleRoot;\nmapping(address => bool) public presaleMinted;\nmapping(string => bool) public _usedNonces;\nbool public disabled;\nstring private _baseURIExtended;\naddress private _signerAddress;","after":"uint256 public constant PRE_SALE_NFT_PRICE = 0.076 ether;\nuint256 public constant PUBLIC_SALE_NFT_PRICE = 0.08 ether;\nuint256 public constant MAX_NFT_PURCHASE = 5;\nuint256 public constant MAX_SUPPLY = 10000;\nuint256 public freeClaimStartTime;\nuint256 public freeClaimEndTime;\nbytes32 private _freeClaimMerkleRoot;\nmapping(address => bool) public claimed;\nuint256 public preSaleStartTime;\nuint256 public publicSaleStartTime;\nbytes32 private _merkleRoot;\nmapping(address => bool) public presaleMinted;\nmapping(string => bool) public _usedNonces;\nstring private _baseURIExtended;\naddress private _signerAddress;\nbool public disabled;\n","contract":"GalaXYKats","time":0},{"type":"external-function ","before":"function claim(bytes32[] memory proof, uint256 amount)\n        external\n        nonReentrant\n    {\n        // checks\n        require(freeClaimStartTime != 0, \"start time not set\");\n        require(block.timestamp > freeClaimStartTime, \"free claim hasn't started\");\n        require(block.timestamp < freeClaimEndTime, \"free claim has finished\");\n        \n        require(_freeClaimMerkleRoot != \"\", \"merkleRoot not set\");\n        require(!claimed[msg.sender], \"this address has already claimed\");\n        require(!disabled, \"the contract is disabled\");\n        require(\n            proof.verify(\n                _freeClaimMerkleRoot,\n                keccak256(abi.encodePacked(msg.sender, amount))\n            ),\n            \"failed to verify merkle root\"\n        );\n        // effects\n        claimed[msg.sender] = true;\n        // interaction\n        for (uint256 i = 0; i < amount; i++) {\n            _safeMint(msg.sender, totalSupply());\n        }\n    }","after":"function claim(bytes32[] calldata proof, uint256 amount)\n        external\n        nonReentrant\n    {\n        // checks\n        require(freeClaimStartTime != 0, \"start time not set\");\n        require(block.timestamp > freeClaimStartTime, \"free claim hasn't started\");\n        require(block.timestamp < freeClaimEndTime, \"free claim has finished\");\n        \n        require(_freeClaimMerkleRoot != \"\", \"merkleRoot not set\");\n        require(!claimed[msg.sender], \"this address has already claimed\");\n        require(!disabled, \"the contract is disabled\");\n        require(\n            proof.verify(\n                _freeClaimMerkleRoot,\n                keccak256(abi.encodePacked(msg.sender, amount))\n            ),\n            \"failed to verify merkle root\"\n        );\n        // effects\n        claimed[msg.sender] = true;\n        // interaction\n        for (uint256 i = 0; i < amount; i++) {\n            _safeMint(msg.sender, totalSupply());\n        }\n    }","contract":"GalaXYKats","time":0},{"type":"external-function ","before":"function mintPreSale(\n        bytes32[] memory proof,\n        uint256 merkleProofQuantity,\n        uint256 actualPurchaseQuantity\n    ) external payable nonReentrant {\n        require(preSaleStartTime != 0, \"presaleStartTime not set\");\n        require(block.timestamp > preSaleStartTime, \"presale hasn't started\");\n        require(block.timestamp < publicSaleStartTime, \"presale has finished\");\n        require(_merkleRoot != \"\", \"merkleRoot not set\");\n        require(!disabled, \"the contract is disabled\");\n        require(\n            proof.verify(\n                _merkleRoot,\n                keccak256(abi.encodePacked(msg.sender, merkleProofQuantity))\n            ),\n            \"failed to verify merkle root\"\n        );\n        require(\n            merkleProofQuantity >= actualPurchaseQuantity,\n            \"intended purchase quantity has to be less than or equal to merkle proof token quantity\"\n        );\n        require(\n            !presaleMinted[msg.sender],\n            \"this EOA has minted its presale already\"\n        );\n        require(\n            PRE_SALE_NFT_PRICE * actualPurchaseQuantity == msg.value,\n            \"Sent ether value is incorrect\"\n        );\n        presaleMinted[msg.sender] = true;\n        for (uint256 i = 0; i < actualPurchaseQuantity; i++) {\n            _safeMint(msg.sender, totalSupply());\n        }\n    }","after":"function mintPreSale(\n        bytes32[] calldata proof,\n        uint256 merkleProofQuantity,\n        uint256 actualPurchaseQuantity\n    ) external payable nonReentrant {\n        require(preSaleStartTime != 0, \"presaleStartTime not set\");\n        require(block.timestamp > preSaleStartTime, \"presale hasn't started\");\n        require(block.timestamp < publicSaleStartTime, \"presale has finished\");\n        require(_merkleRoot != \"\", \"merkleRoot not set\");\n        require(!disabled, \"the contract is disabled\");\n        require(\n            proof.verify(\n                _merkleRoot,\n                keccak256(abi.encodePacked(msg.sender, merkleProofQuantity))\n            ),\n            \"failed to verify merkle root\"\n        );\n        require(\n            merkleProofQuantity >= actualPurchaseQuantity,\n            \"intended purchase quantity has to be less than or equal to merkle proof token quantity\"\n        );\n        require(\n            !presaleMinted[msg.sender],\n            \"this EOA has minted its presale already\"\n        );\n        require(\n            PRE_SALE_NFT_PRICE * actualPurchaseQuantity == msg.value,\n            \"Sent ether value is incorrect\"\n        );\n        presaleMinted[msg.sender] = true;\n        for (uint256 i = 0; i < actualPurchaseQuantity; i++) {\n            _safeMint(msg.sender, totalSupply());\n        }\n    }","contract":"GalaXYKats","time":0},{"type":"external-function ","before":"function buy(\n        bytes32 hash,\n        bytes memory signature,\n        string memory nonce,\n        uint256 tokenQuantity\n    ) external payable nonReentrant {\n        require(matchAddresSigner(hash, signature), \"DIRECT_MINT_DISALLOWED\");\n        require(!_usedNonces[nonce], \"HASH_USED\");\n        require(\n            hashTransaction(msg.sender, tokenQuantity, nonce) == hash,\n            \"HASH_FAIL\"\n        );\n\n        require(publicSaleStartTime != 0, \"publicsaleStartTime not set\");\n        require(\n            block.timestamp > publicSaleStartTime,\n            \"publicSale hasn't started\"\n        );\n        require(\n            tokenQuantity > 0,\n            \"Number of tokens can not be less than or equal to 0\"\n        );\n        require(\n            tokenQuantity <= MAX_NFT_PURCHASE,\n            \"Can only mint up to 5 per purchase\"\n        );\n        require(\n            totalSupply() + tokenQuantity <= MAX_SUPPLY,\n            \"Purchase would exceed max supply of tokens\"\n        );\n        require(\n            PUBLIC_SALE_NFT_PRICE * tokenQuantity == msg.value,\n            \"Sent ether value is incorrect\"\n        );\n        require(!disabled, \"the contract is disabled\");\n        _usedNonces[nonce] = true;\n        for (uint256 i = 0; i < tokenQuantity; i++) {\n            _safeMint(msg.sender, totalSupply());\n        }\n    }","after":"function buy(\n        bytes32 hash,\n        bytes calldata signature,\n        string calldata nonce,\n        uint256 tokenQuantity\n    ) external payable nonReentrant {\n        require(matchAddresSigner(hash, signature), \"DIRECT_MINT_DISALLOWED\");\n        require(!_usedNonces[nonce], \"HASH_USED\");\n        require(\n            hashTransaction(msg.sender, tokenQuantity, nonce) == hash,\n            \"HASH_FAIL\"\n        );\n\n        require(publicSaleStartTime != 0, \"publicsaleStartTime not set\");\n        require(\n            block.timestamp > publicSaleStartTime,\n            \"publicSale hasn't started\"\n        );\n        require(\n            tokenQuantity > 0,\n            \"Number of tokens can not be less than or equal to 0\"\n        );\n        require(\n            tokenQuantity <= MAX_NFT_PURCHASE,\n            \"Can only mint up to 5 per purchase\"\n        );\n        require(\n            totalSupply() + tokenQuantity <= MAX_SUPPLY,\n            \"Purchase would exceed max supply of tokens\"\n        );\n        require(\n            PUBLIC_SALE_NFT_PRICE * tokenQuantity == msg.value,\n            \"Sent ether value is incorrect\"\n        );\n        require(!disabled, \"the contract is disabled\");\n        _usedNonces[nonce] = true;\n        for (uint256 i = 0; i < tokenQuantity; i++) {\n            _safeMint(msg.sender, totalSupply());\n        }\n    }","contract":"GalaXYKats","time":0},{"type":"external-function ","before":"function setBaseURI(string memory baseURI_) external onlyOwner {\n        _baseURIExtended = baseURI_;\n    }","after":"function setBaseURI(string calldata baseURI_) external onlyOwner {\n        _baseURIExtended = baseURI_;\n    }","contract":"GalaXYKats","time":0}]}