{"time":205,"results":[{"type":"struct-data-arrangement ","before":"\naddress creator\naddress tokenOwner\nuint256 origTotSupply\nuint256 curRewardsSupply\nuint256 totalTokensStaked\nuint256 creationBlock\nuint256 perBlockNum\nuint256 lockedUntilDate\nuint256 lastRewardBlock\nuint256 accERC20PerShare\nuint256 stakeTimeLockSec\nbool isStakedNft","after":"uint256 origTotSupply\nuint256 curRewardsSupply\nuint256 totalTokensStaked\nuint256 creationBlock\nuint256 perBlockNum\nuint256 lockedUntilDate\nuint256 lastRewardBlock\nuint256 accERC20PerShare\nuint256 stakeTimeLockSec\naddress creator\naddress tokenOwner\nbool isStakedNft\n","contract":"MTGYFaaSToken","time":0},{"type":"external-function ","before":"function stakeTokens(uint256 _amount, uint256[] memory _tokenIds) external {\n    require(\n      getLastStakableBlock() > block.number,\n      'this farm is expired and no more stakers can be added'\n    );\n\n    _updatePool();\n\n    if (balanceOf(msg.sender) > 0) {\n      _harvestTokens(msg.sender);\n    }\n\n    uint256 _finalAmountTransferred;\n    if (pool.isStakedNft) {\n      require(\n        _tokenIds.length > 0,\n        \"you need to provide NFT token IDs you're staking\"\n      );\n      for (uint256 _i = 0; _i < _tokenIds.length; _i++) {\n        _stakedERC721.transferFrom(msg.sender, address(this), _tokenIds[_i]);\n      }\n\n      _finalAmountTransferred = _tokenIds.length;\n    } else {\n      uint256 _contractBalanceBefore = _stakedERC20.balanceOf(address(this));\n      _stakedERC20.transferFrom(msg.sender, address(this), _amount);\n\n      // in the event a token contract on transfer taxes, burns, etc. tokens\n      // the contract might not get the entire amount that the user originally\n      // transferred. Need to calculate from the previous contract balance\n      // so we know how many were actually transferred.\n      _finalAmountTransferred = _stakedERC20.balanceOf(address(this)).sub(\n        _contractBalanceBefore\n      );\n    }\n\n    if (totalSupply() == 0) {\n      pool.creationBlock = block.number;\n      pool.lastRewardBlock = block.number;\n    }\n    _mint(msg.sender, _finalAmountTransferred);\n    StakerInfo storage _staker = stakers[msg.sender];\n    _staker.blockOriginallyStaked = block.number;\n    _staker.timeOriginallyStaked = block.timestamp;\n    _staker.blockLastHarvested = block.number;\n    _staker.rewardDebt = balanceOf(msg.sender).mul(pool.accERC20PerShare).div(\n      1e36\n    );\n    for (uint256 _i = 0; _i < _tokenIds.length; _i++) {\n      _staker.nftTokenIds.push(_tokenIds[_i]);\n    }\n    _updNumStaked(_finalAmountTransferred, 'add');\n    emit Deposit(msg.sender, _finalAmountTransferred);\n  }","after":"function stakeTokens(uint256 _amount, uint256[] calldata _tokenIds) external {\n    require(\n      getLastStakableBlock() > block.number,\n      'this farm is expired and no more stakers can be added'\n    );\n\n    _updatePool();\n\n    if (balanceOf(msg.sender) > 0) {\n      _harvestTokens(msg.sender);\n    }\n\n    uint256 _finalAmountTransferred;\n    if (pool.isStakedNft) {\n      require(\n        _tokenIds.length > 0,\n        \"you need to provide NFT token IDs you're staking\"\n      );\n      for (uint256 _i = 0; _i < _tokenIds.length; _i++) {\n        _stakedERC721.transferFrom(msg.sender, address(this), _tokenIds[_i]);\n      }\n\n      _finalAmountTransferred = _tokenIds.length;\n    } else {\n      uint256 _contractBalanceBefore = _stakedERC20.balanceOf(address(this));\n      _stakedERC20.transferFrom(msg.sender, address(this), _amount);\n\n      // in the event a token contract on transfer taxes, burns, etc. tokens\n      // the contract might not get the entire amount that the user originally\n      // transferred. Need to calculate from the previous contract balance\n      // so we know how many were actually transferred.\n      _finalAmountTransferred = _stakedERC20.balanceOf(address(this)).sub(\n        _contractBalanceBefore\n      );\n    }\n\n    if (totalSupply() == 0) {\n      pool.creationBlock = block.number;\n      pool.lastRewardBlock = block.number;\n    }\n    _mint(msg.sender, _finalAmountTransferred);\n    StakerInfo storage _staker = stakers[msg.sender];\n    _staker.blockOriginallyStaked = block.number;\n    _staker.timeOriginallyStaked = block.timestamp;\n    _staker.blockLastHarvested = block.number;\n    _staker.rewardDebt = balanceOf(msg.sender).mul(pool.accERC20PerShare).div(\n      1e36\n    );\n    for (uint256 _i = 0; _i < _tokenIds.length; _i++) {\n      _staker.nftTokenIds.push(_tokenIds[_i]);\n    }\n    _updNumStaked(_finalAmountTransferred, 'add');\n    emit Deposit(msg.sender, _finalAmountTransferred);\n  }","contract":"MTGYFaaSToken","time":0}]}