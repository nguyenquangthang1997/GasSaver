{"time":416,"results":[{"type":"external-function ","before":"function burnFuel(address from, TokenFuel memory fuel) public override {\n        require(_callerIsDeployTimeKnownContract(), \"PRPS-2\");\n        _burnFuel(from, fuel);\n    }","after":"function burnFuel(address from, TokenFuel calldata fuel) public override {\n        require(_callerIsDeployTimeKnownContract(), \"PRPS-2\");\n        _burnFuel(from, fuel);\n    }","contract":"Purpose","time":0},{"type":"external-function ","before":"function createNewOpHandleShared(\n        IOptIn.OptInStatus memory optInStatus,\n        address user,\n        uint8 opType\n    ) public onlyHodl returns (OpHandle memory) {\n        return _createNewOpHandle(optInStatus, user, opType);\n    }","after":"function createNewOpHandleShared(\n        IOptIn.OptInStatus calldata optInStatus,\n        address user,\n        uint8 opType\n    ) public onlyHodl returns (OpHandle memory) {\n        return _createNewOpHandle(optInStatus, user, opType);\n    }","contract":"Purpose","time":0},{"type":"external-function ","before":"function deleteOpHandleShared(address user, OpHandle memory opHandle)\n        public\n        onlyHodl\n        returns (bool)\n    {\n        _deleteOpHandle(user, opHandle);\n        return true;\n    }","after":"function deleteOpHandleShared(address user, OpHandle calldata opHandle)\n        public\n        onlyHodl\n        returns (bool)\n    {\n        _deleteOpHandle(user, opHandle);\n        return true;\n    }","contract":"Purpose","time":0},{"type":"external-function ","before":"function burn(uint256 amount, bytes memory data) public {\n        // Create pending burn if sender is opted-in and the permaboost is active\n        IOptIn.OptInStatus memory optInStatus = getOptInStatus(msg.sender);\n        if (optInStatus.isOptedIn && optInStatus.permaBoostActive) {\n            _createPendingTransfer({\n                opType: OP_TYPE_BURN,\n                spender: msg.sender,\n                from: msg.sender,\n                to: address(0),\n                amount: amount,\n                data: data,\n                optInStatus: optInStatus\n            });\n\n            return;\n        }\n\n        _burn({\n            from: msg.sender,\n            amount: amount,\n            data: data,\n            incrementNonce: false\n        });\n    }","after":"function burn(uint256 amount, bytes calldata data) public {\n        // Create pending burn if sender is opted-in and the permaboost is active\n        IOptIn.OptInStatus memory optInStatus = getOptInStatus(msg.sender);\n        if (optInStatus.isOptedIn && optInStatus.permaBoostActive) {\n            _createPendingTransfer({\n                opType: OP_TYPE_BURN,\n                spender: msg.sender,\n                from: msg.sender,\n                to: address(0),\n                amount: amount,\n                data: data,\n                optInStatus: optInStatus\n            });\n\n            return;\n        }\n\n        _burn({\n            from: msg.sender,\n            amount: amount,\n            data: data,\n            incrementNonce: false\n        });\n    }","contract":"Purpose","time":0},{"type":"external-function ","before":"function boostedSendBatch(\n        BoostedSend[] memory sends,\n        Signature[] memory signatures\n    ) external {\n        require(\n            sends.length > 0 && sends.length == signatures.length,\n            \"ERC20-6\"\n        );\n\n        for (uint256 i = 0; i < sends.length; i++) {\n            boostedSend(sends[i], signatures[i]);\n        }\n    }","after":"function boostedSendBatch(\n        BoostedSend[] calldata sends,\n        Signature[] calldata signatures\n    ) external {\n        require(\n            sends.length > 0 && sends.length == signatures.length,\n            \"ERC20-6\"\n        );\n\n        for (uint256 i = 0; i < sends.length; i++) {\n            boostedSend(sends[i], signatures[i]);\n        }\n    }","contract":"Purpose","time":0},{"type":"external-function ","before":"function boostedBurnBatch(\n        BoostedBurn[] memory burns,\n        Signature[] memory signatures\n    ) external {\n        require(\n            burns.length > 0 && burns.length == signatures.length,\n            \"ERC20-6\"\n        );\n\n        for (uint256 i = 0; i < burns.length; i++) {\n            boostedBurn(burns[i], signatures[i]);\n        }\n    }","after":"function boostedBurnBatch(\n        BoostedBurn[] calldata burns,\n        Signature[] calldata signatures\n    ) external {\n        require(\n            burns.length > 0 && burns.length == signatures.length,\n            \"ERC20-6\"\n        );\n\n        for (uint256 i = 0; i < burns.length; i++) {\n            boostedBurn(burns[i], signatures[i]);\n        }\n    }","contract":"Purpose","time":0},{"type":"external-function ","before":"function finalizePendingOp(address user, OpHandle memory opHandle) public {\n        uint8 opType = opHandle.opType;\n\n        // Assert that the caller (msg.sender) is allowed to finalize the given op\n        uint32 createdAt = uint32(_assertCanFinalize(user, opHandle));\n\n        // Reverts if opId doesn't exist\n        PendingTransfer storage pendingTransfer = _safeGetPendingTransfer(\n            user,\n            opHandle.opId\n        );\n\n        // Cleanup\n        // NOTE: We do not delete the pending transfer struct, because it only makes it\n        // more expensive since we already hit the gas refund limit.\n        //\n        // delete _pendingTransfers[_getOpKey(user, opHandle.opId)];\n        //\n        // The difference is ~13k gas.\n        //\n        // Deleting the op handle is enough to invalidate an opId forever:\n        _deleteOpHandle(user, opHandle);\n\n        // Call op type specific finalize\n        if (opType == OP_TYPE_SEND) {\n            _finalizeTransferOp(pendingTransfer, user, createdAt);\n        } else if (opType == OP_TYPE_BURN) {\n            _finalizePendingBurn(pendingTransfer, user, createdAt);\n        } else {\n            revert(\"ERC20-15\");\n        }\n\n        // Emit event\n        emit FinalizedOp(user, opHandle.opId, opType);\n    }","after":"function finalizePendingOp(address user, OpHandle calldata opHandle) public {\n        uint8 opType = opHandle.opType;\n\n        // Assert that the caller (msg.sender) is allowed to finalize the given op\n        uint32 createdAt = uint32(_assertCanFinalize(user, opHandle));\n\n        // Reverts if opId doesn't exist\n        PendingTransfer storage pendingTransfer = _safeGetPendingTransfer(\n            user,\n            opHandle.opId\n        );\n\n        // Cleanup\n        // NOTE: We do not delete the pending transfer struct, because it only makes it\n        // more expensive since we already hit the gas refund limit.\n        //\n        // delete _pendingTransfers[_getOpKey(user, opHandle.opId)];\n        //\n        // The difference is ~13k gas.\n        //\n        // Deleting the op handle is enough to invalidate an opId forever:\n        _deleteOpHandle(user, opHandle);\n\n        // Call op type specific finalize\n        if (opType == OP_TYPE_SEND) {\n            _finalizeTransferOp(pendingTransfer, user, createdAt);\n        } else if (opType == OP_TYPE_BURN) {\n            _finalizePendingBurn(pendingTransfer, user, createdAt);\n        } else {\n            revert(\"ERC20-15\");\n        }\n\n        // Emit event\n        emit FinalizedOp(user, opHandle.opId, opType);\n    }","contract":"Purpose","time":0},{"type":"external-function ","before":"function revertPendingOp(\n        address user,\n        OpHandle memory opHandle,\n        bytes memory boosterMessage,\n        Signature memory signature\n    ) public {\n        // Prepare revert, including permission check and prevents reentrancy for same opHandle.\n        _prepareOpRevert({\n            user: user,\n            opHandle: opHandle,\n            boosterMessage: boosterMessage,\n            signature: signature\n        });\n\n        // Now perform the actual revert of the pending op\n        _revertPendingOp(user, opHandle.opType, opHandle.opId);\n    }","after":"function revertPendingOp(\n        address user,\n        OpHandle calldata opHandle,\n        bytes calldata boosterMessage,\n        Signature calldata signature\n    ) public {\n        // Prepare revert, including permission check and prevents reentrancy for same opHandle.\n        _prepareOpRevert({\n            user: user,\n            opHandle: opHandle,\n            boosterMessage: boosterMessage,\n            signature: signature\n        });\n\n        // Now perform the actual revert of the pending op\n        _revertPendingOp(user, opHandle.opType, opHandle.opId);\n    }","contract":"Purpose","time":0},{"type":"external-function ","before":"function burnFuel(address from, TokenFuel memory fuel) public override {\n        require(_callerIsDeployTimeKnownContract(), \"DUBI-1\");\n        _burnFuel(from, fuel);\n    }","after":"function burnFuel(address from, TokenFuel calldata fuel) public override {\n        require(_callerIsDeployTimeKnownContract(), \"DUBI-1\");\n        _burnFuel(from, fuel);\n    }","contract":"Dubi","time":0},{"type":"external-function ","before":"function burn(uint256 amount, bytes memory data) public {\n        // Create pending burn if sender is opted-in and the permaboost is active\n        IOptIn.OptInStatus memory optInStatus = getOptInStatus(msg.sender);\n        if (optInStatus.isOptedIn && optInStatus.permaBoostActive) {\n            _createPendingTransfer({\n                opType: OP_TYPE_BURN,\n                spender: msg.sender,\n                from: msg.sender,\n                to: address(0),\n                amount: amount,\n                data: data,\n                optInStatus: optInStatus\n            });\n\n            return;\n        }\n\n        _burn({\n            from: msg.sender,\n            amount: amount,\n            data: data,\n            incrementNonce: false\n        });\n    }","after":"function burn(uint256 amount, bytes calldata data) public {\n        // Create pending burn if sender is opted-in and the permaboost is active\n        IOptIn.OptInStatus memory optInStatus = getOptInStatus(msg.sender);\n        if (optInStatus.isOptedIn && optInStatus.permaBoostActive) {\n            _createPendingTransfer({\n                opType: OP_TYPE_BURN,\n                spender: msg.sender,\n                from: msg.sender,\n                to: address(0),\n                amount: amount,\n                data: data,\n                optInStatus: optInStatus\n            });\n\n            return;\n        }\n\n        _burn({\n            from: msg.sender,\n            amount: amount,\n            data: data,\n            incrementNonce: false\n        });\n    }","contract":"Dubi","time":0},{"type":"external-function ","before":"function boostedSendBatch(\n        BoostedSend[] memory sends,\n        Signature[] memory signatures\n    ) external {\n        require(\n            sends.length > 0 && sends.length == signatures.length,\n            \"ERC20-6\"\n        );\n\n        for (uint256 i = 0; i < sends.length; i++) {\n            boostedSend(sends[i], signatures[i]);\n        }\n    }","after":"function boostedSendBatch(\n        BoostedSend[] calldata sends,\n        Signature[] calldata signatures\n    ) external {\n        require(\n            sends.length > 0 && sends.length == signatures.length,\n            \"ERC20-6\"\n        );\n\n        for (uint256 i = 0; i < sends.length; i++) {\n            boostedSend(sends[i], signatures[i]);\n        }\n    }","contract":"Dubi","time":0},{"type":"external-function ","before":"function boostedBurnBatch(\n        BoostedBurn[] memory burns,\n        Signature[] memory signatures\n    ) external {\n        require(\n            burns.length > 0 && burns.length == signatures.length,\n            \"ERC20-6\"\n        );\n\n        for (uint256 i = 0; i < burns.length; i++) {\n            boostedBurn(burns[i], signatures[i]);\n        }\n    }","after":"function boostedBurnBatch(\n        BoostedBurn[] calldata burns,\n        Signature[] calldata signatures\n    ) external {\n        require(\n            burns.length > 0 && burns.length == signatures.length,\n            \"ERC20-6\"\n        );\n\n        for (uint256 i = 0; i < burns.length; i++) {\n            boostedBurn(burns[i], signatures[i]);\n        }\n    }","contract":"Dubi","time":0},{"type":"external-function ","before":"function finalizePendingOp(address user, OpHandle memory opHandle) public {\n        uint8 opType = opHandle.opType;\n\n        // Assert that the caller (msg.sender) is allowed to finalize the given op\n        uint32 createdAt = uint32(_assertCanFinalize(user, opHandle));\n\n        // Reverts if opId doesn't exist\n        PendingTransfer storage pendingTransfer = _safeGetPendingTransfer(\n            user,\n            opHandle.opId\n        );\n\n        // Cleanup\n        // NOTE: We do not delete the pending transfer struct, because it only makes it\n        // more expensive since we already hit the gas refund limit.\n        //\n        // delete _pendingTransfers[_getOpKey(user, opHandle.opId)];\n        //\n        // The difference is ~13k gas.\n        //\n        // Deleting the op handle is enough to invalidate an opId forever:\n        _deleteOpHandle(user, opHandle);\n\n        // Call op type specific finalize\n        if (opType == OP_TYPE_SEND) {\n            _finalizeTransferOp(pendingTransfer, user, createdAt);\n        } else if (opType == OP_TYPE_BURN) {\n            _finalizePendingBurn(pendingTransfer, user, createdAt);\n        } else {\n            revert(\"ERC20-15\");\n        }\n\n        // Emit event\n        emit FinalizedOp(user, opHandle.opId, opType);\n    }","after":"function finalizePendingOp(address user, OpHandle calldata opHandle) public {\n        uint8 opType = opHandle.opType;\n\n        // Assert that the caller (msg.sender) is allowed to finalize the given op\n        uint32 createdAt = uint32(_assertCanFinalize(user, opHandle));\n\n        // Reverts if opId doesn't exist\n        PendingTransfer storage pendingTransfer = _safeGetPendingTransfer(\n            user,\n            opHandle.opId\n        );\n\n        // Cleanup\n        // NOTE: We do not delete the pending transfer struct, because it only makes it\n        // more expensive since we already hit the gas refund limit.\n        //\n        // delete _pendingTransfers[_getOpKey(user, opHandle.opId)];\n        //\n        // The difference is ~13k gas.\n        //\n        // Deleting the op handle is enough to invalidate an opId forever:\n        _deleteOpHandle(user, opHandle);\n\n        // Call op type specific finalize\n        if (opType == OP_TYPE_SEND) {\n            _finalizeTransferOp(pendingTransfer, user, createdAt);\n        } else if (opType == OP_TYPE_BURN) {\n            _finalizePendingBurn(pendingTransfer, user, createdAt);\n        } else {\n            revert(\"ERC20-15\");\n        }\n\n        // Emit event\n        emit FinalizedOp(user, opHandle.opId, opType);\n    }","contract":"Dubi","time":0},{"type":"external-function ","before":"function revertPendingOp(\n        address user,\n        OpHandle memory opHandle,\n        bytes memory boosterMessage,\n        Signature memory signature\n    ) public {\n        // Prepare revert, including permission check and prevents reentrancy for same opHandle.\n        _prepareOpRevert({\n            user: user,\n            opHandle: opHandle,\n            boosterMessage: boosterMessage,\n            signature: signature\n        });\n\n        // Now perform the actual revert of the pending op\n        _revertPendingOp(user, opHandle.opType, opHandle.opId);\n    }","after":"function revertPendingOp(\n        address user,\n        OpHandle calldata opHandle,\n        bytes calldata boosterMessage,\n        Signature calldata signature\n    ) public {\n        // Prepare revert, including permission check and prevents reentrancy for same opHandle.\n        _prepareOpRevert({\n            user: user,\n            opHandle: opHandle,\n            boosterMessage: boosterMessage,\n            signature: signature\n        });\n\n        // Now perform the actual revert of the pending op\n        _revertPendingOp(user, opHandle.opType, opHandle.opId);\n    }","contract":"Dubi","time":0},{"type":"external-function ","before":"function deleteOpHandle(\n        address user,\n        OpHandle memory opHandle,\n        OpHandle[] storage opHandles,\n        OpCounter storage opCounter,\n        mapping(bytes32 => OpMetadata) storage opMetadata\n    ) public {\n        uint256 length = opHandles.length;\n        assert(length > 0);\n\n        uint64 minOpId; // becomes next LIFO\n        uint64 maxOpId; // becomes next FIFO\n\n        // Pending ops are capped to MAX_PENDING_OPS. We always perform\n        // MIN(length, MAX_PENDING_OPS) look-ups to do a \"swap-and-pop\" and\n        // for updating the opCounter LIFO/FIFO pointers.\n        for (uint256 i = 0; i < length; i++) {\n            uint64 currOpId = opHandles[i].opId;\n            if (currOpId == opHandle.opId) {\n                // Overwrite item at i with last\n                opHandles[i] = opHandles[length - 1];\n\n                // Continue, to ignore this opId when updating\n                // minOpId and maxOpId.\n                continue;\n            }\n\n            // Update minOpId\n            if (minOpId == 0 || currOpId < minOpId) {\n                minOpId = currOpId;\n            }\n\n            // Update maxOpId\n            if (currOpId > maxOpId) {\n                maxOpId = currOpId;\n            }\n        }\n\n        // Might be 0 when everything got finalized/reverted\n        opCounter.nextFinalize = minOpId;\n        // Might be 0 when everything got finalized/reverted\n        opCounter.nextRevert = maxOpId;\n\n        // Remove the last item\n        opHandles.pop();\n\n        // Remove metadata\n        delete opMetadata[_getOpKey(user, opHandle.opId)];\n    }","after":"function deleteOpHandle(\n        address user,\n        OpHandle calldata opHandle,\n        OpHandle[] storage opHandles,\n        OpCounter storage opCounter,\n        mapping(bytes32 => OpMetadata) storage opMetadata\n    ) public {\n        uint256 length = opHandles.length;\n        assert(length > 0);\n\n        uint64 minOpId; // becomes next LIFO\n        uint64 maxOpId; // becomes next FIFO\n\n        // Pending ops are capped to MAX_PENDING_OPS. We always perform\n        // MIN(length, MAX_PENDING_OPS) look-ups to do a \"swap-and-pop\" and\n        // for updating the opCounter LIFO/FIFO pointers.\n        for (uint256 i = 0; i < length; i++) {\n            uint64 currOpId = opHandles[i].opId;\n            if (currOpId == opHandle.opId) {\n                // Overwrite item at i with last\n                opHandles[i] = opHandles[length - 1];\n\n                // Continue, to ignore this opId when updating\n                // minOpId and maxOpId.\n                continue;\n            }\n\n            // Update minOpId\n            if (minOpId == 0 || currOpId < minOpId) {\n                minOpId = currOpId;\n            }\n\n            // Update maxOpId\n            if (currOpId > maxOpId) {\n                maxOpId = currOpId;\n            }\n        }\n\n        // Might be 0 when everything got finalized/reverted\n        opCounter.nextFinalize = minOpId;\n        // Might be 0 when everything got finalized/reverted\n        opCounter.nextRevert = maxOpId;\n\n        // Remove the last item\n        opHandles.pop();\n\n        // Remove metadata\n        delete opMetadata[_getOpKey(user, opHandle.opId)];\n    }","contract":"ProtectedBoostableLib","time":0},{"type":"external-function ","before":"function verifySignatureForRevert(\n        address user,\n        uint64 opTimestamp,\n        IOptIn.OptInStatus memory optInStatus,\n        bytes memory boosterMessage,\n        address[] memory hasherContracts,\n        Signature memory signature\n    ) public {\n        require(hasherContracts.length > 0, \"PB-12\");\n\n        // Result of hasher contract call\n        uint64 signedAt;\n        bytes32 boosterHash;\n        bool signatureVerified;\n\n        for (uint256 i = 0; i < hasherContracts.length; i++) {\n            // Call into the hasher contract and take the first non-zero result.\n            // The contract must implement the following function:\n            //\n            // decodeAndHashBoosterMessage(\n            //     address targetBooster,\n            //     bytes memory boosterMessage\n            // )\n            //\n            // If it doesn't, then the call will fail (success=false) and we try the next one.\n            // If it succeeds (success = true), then we try to decode the result.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory result) = address(hasherContracts[i])\n                .call(\n                // keccak256(\"decodeAndHashBoosterMessage(address,bytes)\")\n                abi.encodeWithSelector(\n                    0xaf6eec54,\n                    msg.sender, /* msg.sender becomes the target booster */\n                    boosterMessage\n                )\n            );\n\n            if (!success) {\n                continue;\n            }\n\n            // The result is exactly 2 words long = 512 bits = 64 bytes\n            // 32 bytes for the expected message hash\n            // 8 bytes (padded to 32 bytes) for the expected timestamp\n            if (result.length != 64) {\n                continue;\n            }\n\n            // NOTE: A contract with malintent could return any hash that we would\n            // try to recover against. But there is no harm done in doing so since\n            // the user must have signed it.\n            //\n            // However, it might return an unrelated timestamp, that the user hasn't\n            // signed - so it could prolong the expiry of a signature which is a valid\n            // concern whose risk we minimize by using also the op timestamp which guarantees\n            // that a signature eventually expires.\n\n            // Decode and recover signer\n            (boosterHash, signedAt) = abi.decode(result, (bytes32, uint64));\n            address signer = ecrecover(\n                boosterHash,\n                signature.v,\n                signature.r,\n                signature.s\n            );\n\n            if (user != signer) {\n                // NOTE: Currently, hardware wallets (e.g. Ledger, Trezor) do not support EIP712 signing (specifically `signTypedData_v4`).\n                // However, a user can still sign the EIP712 hash with the caveat that it's signed using `personal_sign` which prepends\n                // the prefix '\"\\x19Ethereum Signed Message:\\n\" + len(message)'.\n                //\n                // To still support that, we also add the prefix and try to use the recovered address instead:\n                signer = ecrecover(\n                    boosterHash.toEthSignedMessageHash(),\n                    signature.v,\n                    signature.r,\n                    signature.s\n                );\n            }\n\n            // If we recovered `user` from the signature, then we have a valid signature.\n            if (user == signer) {\n                signatureVerified = true;\n                break;\n            }\n\n            // Keep trying\n        }\n\n        // Revert if signature couldn't be verified with any of the returned hashes\n        require(signatureVerified, \"PB-8\");\n\n        // Lastly, the current time must not be older than:\n        // MIN(opTimestamp, signedAt) + optOutPeriod * 3\n        uint64 _now = uint64(block.timestamp);\n        // The maximum age is equal to whichever is lowest:\n        //      opTimestamp + optOutPeriod * 3\n        //      signedAt + optOutPeriod * 3\n        uint64 maximumAge;\n        if (opTimestamp > signedAt) {\n            maximumAge = signedAt + uint64(optInStatus.optOutPeriod * 3);\n        } else {\n            maximumAge = opTimestamp + uint64(optInStatus.optOutPeriod * 3);\n        }\n\n        require(_now <= maximumAge, \"PB-11\");\n    }","after":"function verifySignatureForRevert(\n        address user,\n        uint64 opTimestamp,\n        IOptIn.OptInStatus calldata optInStatus,\n        bytes calldata boosterMessage,\n        address[] calldata hasherContracts,\n        Signature calldata signature\n    ) public {\n        require(hasherContracts.length > 0, \"PB-12\");\n\n        // Result of hasher contract call\n        uint64 signedAt;\n        bytes32 boosterHash;\n        bool signatureVerified;\n\n        for (uint256 i = 0; i < hasherContracts.length; i++) {\n            // Call into the hasher contract and take the first non-zero result.\n            // The contract must implement the following function:\n            //\n            // decodeAndHashBoosterMessage(\n            //     address targetBooster,\n            //     bytes memory boosterMessage\n            // )\n            //\n            // If it doesn't, then the call will fail (success=false) and we try the next one.\n            // If it succeeds (success = true), then we try to decode the result.\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, bytes memory result) = address(hasherContracts[i])\n                .call(\n                // keccak256(\"decodeAndHashBoosterMessage(address,bytes)\")\n                abi.encodeWithSelector(\n                    0xaf6eec54,\n                    msg.sender, /* msg.sender becomes the target booster */\n                    boosterMessage\n                )\n            );\n\n            if (!success) {\n                continue;\n            }\n\n            // The result is exactly 2 words long = 512 bits = 64 bytes\n            // 32 bytes for the expected message hash\n            // 8 bytes (padded to 32 bytes) for the expected timestamp\n            if (result.length != 64) {\n                continue;\n            }\n\n            // NOTE: A contract with malintent could return any hash that we would\n            // try to recover against. But there is no harm done in doing so since\n            // the user must have signed it.\n            //\n            // However, it might return an unrelated timestamp, that the user hasn't\n            // signed - so it could prolong the expiry of a signature which is a valid\n            // concern whose risk we minimize by using also the op timestamp which guarantees\n            // that a signature eventually expires.\n\n            // Decode and recover signer\n            (boosterHash, signedAt) = abi.decode(result, (bytes32, uint64));\n            address signer = ecrecover(\n                boosterHash,\n                signature.v,\n                signature.r,\n                signature.s\n            );\n\n            if (user != signer) {\n                // NOTE: Currently, hardware wallets (e.g. Ledger, Trezor) do not support EIP712 signing (specifically `signTypedData_v4`).\n                // However, a user can still sign the EIP712 hash with the caveat that it's signed using `personal_sign` which prepends\n                // the prefix '\"\\x19Ethereum Signed Message:\\n\" + len(message)'.\n                //\n                // To still support that, we also add the prefix and try to use the recovered address instead:\n                signer = ecrecover(\n                    boosterHash.toEthSignedMessageHash(),\n                    signature.v,\n                    signature.r,\n                    signature.s\n                );\n            }\n\n            // If we recovered `user` from the signature, then we have a valid signature.\n            if (user == signer) {\n                signatureVerified = true;\n                break;\n            }\n\n            // Keep trying\n        }\n\n        // Revert if signature couldn't be verified with any of the returned hashes\n        require(signatureVerified, \"PB-8\");\n\n        // Lastly, the current time must not be older than:\n        // MIN(opTimestamp, signedAt) + optOutPeriod * 3\n        uint64 _now = uint64(block.timestamp);\n        // The maximum age is equal to whichever is lowest:\n        //      opTimestamp + optOutPeriod * 3\n        //      signedAt + optOutPeriod * 3\n        uint64 maximumAge;\n        if (opTimestamp > signedAt) {\n            maximumAge = signedAt + uint64(optInStatus.optOutPeriod * 3);\n        } else {\n            maximumAge = opTimestamp + uint64(optInStatus.optOutPeriod * 3);\n        }\n\n        require(_now <= maximumAge, \"PB-11\");\n    }","contract":"ProtectedBoostableLib","time":1}]}