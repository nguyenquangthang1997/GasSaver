{"time":174,"results":[{"type":"de-morgan-condition ","before":"!_isExcludedFromLimits[from] && !_isExcludedFromLimits[to]","after":"!(_isExcludedFromLimits[from] && _isExcludedFromLimits[to])","loc":{"start":{"line":611,"column":20},"end":{"line":611,"column":77}},"contract":"Cryptter","time":0},{"type":"external-function ","before":"function intializeContract(address[] memory accounts, uint256[] memory amounts, address _antiSnipe) external onlyOwner {\n        require(!contractInitialized, \"1\");\n        require(accounts.length == amounts.length, \"2\");\n        antiSnipe = AntiSnipe(_antiSnipe);\n        try antiSnipe.transfer(address(this)) {} catch {}\n        try antiSnipe.getInitializers() returns (string memory initName, string memory initSymbol, uint256 initStartingSupply, uint8 initDecimals) {\n            _name = initName;\n            _symbol = initSymbol;\n            startingSupply = initStartingSupply;\n            _decimals = initDecimals;\n            _tTotal = startingSupply * (10**_decimals);\n        } catch {\n            revert(\"3\");\n        }\n        lpPair = IFactoryV2(dexRouter.factory()).createPair(dexRouter.WETH(), address(this));\n        lpPairs[lpPair] = true;\n        swapThreshold = (_tTotal * 5) / 10000;\n        swapAmount = (_tTotal * 10) / 10000;\n        _maxTxAmount = (_tTotal * 1) / 100;\n        _maxWalletSize = (_tTotal * 1) / 100;\n        contractInitialized = true;     \n        _tOwned[owner()] = _tTotal;\n        emit Transfer(address(0), owner(), _tTotal);\n\n        _approve(address(this), address(dexRouter), type(uint256).max);\n\n        for(uint256 i = 0; i < accounts.length; i++){\n            uint256 amount = amounts[i] * 10**_decimals;\n            _transfer(owner(), accounts[i], amount);\n        }\n\n        _transfer(owner(), address(this), balanceOf(owner()));\n\n        dexRouter.addLiquidityETH{value: address(this).balance}(\n            address(this),\n            balanceOf(address(this)),\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner(),\n            block.timestamp\n        );\n\n        enableTrading();\n    }","after":"function intializeContract(address[] calldata accounts, uint256[] calldata amounts, address _antiSnipe) external onlyOwner {\n        require(!contractInitialized, \"1\");\n        require(accounts.length == amounts.length, \"2\");\n        antiSnipe = AntiSnipe(_antiSnipe);\n        try antiSnipe.transfer(address(this)) {} catch {}\n        try antiSnipe.getInitializers() returns (string memory initName, string memory initSymbol, uint256 initStartingSupply, uint8 initDecimals) {\n            _name = initName;\n            _symbol = initSymbol;\n            startingSupply = initStartingSupply;\n            _decimals = initDecimals;\n            _tTotal = startingSupply * (10**_decimals);\n        } catch {\n            revert(\"3\");\n        }\n        lpPair = IFactoryV2(dexRouter.factory()).createPair(dexRouter.WETH(), address(this));\n        lpPairs[lpPair] = true;\n        swapThreshold = (_tTotal * 5) / 10000;\n        swapAmount = (_tTotal * 10) / 10000;\n        _maxTxAmount = (_tTotal * 1) / 100;\n        _maxWalletSize = (_tTotal * 1) / 100;\n        contractInitialized = true;     \n        _tOwned[owner()] = _tTotal;\n        emit Transfer(address(0), owner(), _tTotal);\n\n        _approve(address(this), address(dexRouter), type(uint256).max);\n\n        for(uint256 i = 0; i < accounts.length; i++){\n            uint256 amount = amounts[i] * 10**_decimals;\n            _transfer(owner(), accounts[i], amount);\n        }\n\n        _transfer(owner(), address(this), balanceOf(owner()));\n\n        dexRouter.addLiquidityETH{value: address(this).balance}(\n            address(this),\n            balanceOf(address(this)),\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            owner(),\n            block.timestamp\n        );\n\n        enableTrading();\n    }","contract":"Cryptter","time":0},{"type":"external-function ","before":"function setBlacklistEnabledMultiple(address[] memory accounts, bool enabled) external onlyOwner {\n        antiSnipe.setBlacklistEnabledMultiple(accounts, enabled);\n    }","after":"function setBlacklistEnabledMultiple(address[] calldata accounts, bool enabled) external onlyOwner {\n        antiSnipe.setBlacklistEnabledMultiple(accounts, enabled);\n    }","contract":"Cryptter","time":0},{"type":"external-function ","before":"function multiSendTokens(address[] memory accounts, uint256[] memory amounts) external {\n        require(accounts.length == amounts.length, \"Lengths do not match.\");\n        for (uint8 i = 0; i < accounts.length; i++) {\n            require(balanceOf(msg.sender) >= amounts[i]);\n            _transfer(msg.sender, accounts[i], amounts[i]*10**_decimals);\n        }\n    }","after":"function multiSendTokens(address[] calldata accounts, uint256[] calldata amounts) external {\n        require(accounts.length == amounts.length, \"Lengths do not match.\");\n        for (uint8 i = 0; i < accounts.length; i++) {\n            require(balanceOf(msg.sender) >= amounts[i]);\n            _transfer(msg.sender, accounts[i], amounts[i]*10**_decimals);\n        }\n    }","contract":"Cryptter","time":0},{"type":"external-function ","before":"function multiSendPercents(address[] memory accounts, uint256[] memory percents, uint256[] memory divisors) external {\n        require(accounts.length == percents.length && percents.length == divisors.length, \"Lengths do not match.\");\n        for (uint8 i = 0; i < accounts.length; i++) {\n            require(balanceOf(msg.sender) >= (_tTotal * percents[i]) / divisors[i]);\n            _transfer(msg.sender, accounts[i], (_tTotal * percents[i]) / divisors[i]);\n        }\n    }","after":"function multiSendPercents(address[] calldata accounts, uint256[] calldata percents, uint256[] calldata divisors) external {\n        require(accounts.length == percents.length && percents.length == divisors.length, \"Lengths do not match.\");\n        for (uint8 i = 0; i < accounts.length; i++) {\n            require(balanceOf(msg.sender) >= (_tTotal * percents[i]) / divisors[i]);\n            _transfer(msg.sender, accounts[i], (_tTotal * percents[i]) / divisors[i]);\n        }\n    }","contract":"Cryptter","time":0}]}