{"time":229,"results":[{"type":"struct-data-arrangement ","before":"\nuint64 height\nbytes32 epoch_id\nbytes32 next_epoch_id\nbytes32 prev_state_root\nbytes32 outcome_root\nuint64 timestamp\nbytes32 next_bp_hash\nbytes32 block_merkle_root\nbytes32 hash","after":"bytes32 epoch_id\nbytes32 next_epoch_id\nbytes32 prev_state_root\nbytes32 outcome_root\nbytes32 next_bp_hash\nbytes32 block_merkle_root\nbytes32 hash\nuint64 height\nuint64 timestamp\n","contract":"NearDecoder","time":0},{"type":"external-function ","before":"function lockToken(address ethToken, uint256 amount, string memory accountId)\n        public\n        pausable (PAUSED_LOCK)\n    {\n        require(IERC20(ethToken).balanceOf(address(this)).add(amount) <= ((uint256(1) << 128) - 1), \"Maximum tokens locked exceeded (< 2^128 - 1)\");\n        IERC20(ethToken).safeTransferFrom(msg.sender, address(this), amount);\n        emit Locked(address(ethToken), msg.sender, amount, accountId);\n    }","after":"function lockToken(address ethToken, uint256 amount, string calldata accountId)\n        public\n        pausable (PAUSED_LOCK)\n    {\n        require(IERC20(ethToken).balanceOf(address(this)).add(amount) <= ((uint256(1) << 128) - 1), \"Maximum tokens locked exceeded (< 2^128 - 1)\");\n        IERC20(ethToken).safeTransferFrom(msg.sender, address(this), amount);\n        emit Locked(address(ethToken), msg.sender, amount, accountId);\n    }","contract":"ERC20Locker","time":0},{"type":"external-function ","before":"function unlockToken(bytes memory proofData, uint64 proofBlockHeight)\n        public\n        pausable (PAUSED_UNLOCK)\n    {\n        ProofDecoder.ExecutionStatus memory status = _parseAndConsumeProof(proofData, proofBlockHeight);\n        BurnResult memory result = _decodeBurnResult(status.successValue);\n        IERC20(result.token).safeTransfer(result.recipient, result.amount);\n        emit Unlocked(result.amount, result.recipient);\n    }","after":"function unlockToken(bytes calldata proofData, uint64 proofBlockHeight)\n        public\n        pausable (PAUSED_UNLOCK)\n    {\n        ProofDecoder.ExecutionStatus memory status = _parseAndConsumeProof(proofData, proofBlockHeight);\n        BurnResult memory result = _decodeBurnResult(status.successValue);\n        IERC20(result.token).safeTransfer(result.recipient, result.amount);\n        emit Unlocked(result.amount, result.recipient);\n    }","contract":"ERC20Locker","time":0},{"type":"external-function ","before":"function adminDelegatecall(address target, bytes memory data) public payable onlyAdmin returns (bytes memory) {\n        (bool success, bytes memory rdata) = target.delegatecall(data);\n        require(success);\n        return rdata;\n    }","after":"function adminDelegatecall(address target, bytes calldata data) public payable onlyAdmin returns (bytes memory) {\n        (bool success, bytes memory rdata) = target.delegatecall(data);\n        require(success);\n        return rdata;\n    }","contract":"ERC20Locker","time":0},{"type":"immutable-restrict-modification ","before":"bytes public nearTokenFactory_;","after":"bytes public immutable nearTokenFactory_;","contract":"ERC20Locker","time":0},{"type":"immutable-restrict-modification ","before":"uint64 public minBlockAcceptanceHeight_;","after":"uint64 public immutable minBlockAcceptanceHeight_;","contract":"ERC20Locker","time":0},{"type":"immutable-restrict-modification ","before":"address public admin;","after":"address public immutable admin;","contract":"ERC20Locker","time":0}]}