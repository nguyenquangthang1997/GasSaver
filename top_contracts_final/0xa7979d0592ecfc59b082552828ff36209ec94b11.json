{"time":2416,"results":[{"type":"external-function ","before":"function createPair(\n        address _token0,\n        address _token1,\n        bytes memory data\n    ) external override returns (address _pool) {\n        (uint24 _fee, uint160 _sqrtPriceX96) = abi.decode(data, (uint24, uint160));\n        _pool = IUniswapV3Factory(uniswapFactory).createPool(_token0, _token1, _fee);\n        IUniswapV3Pool(_pool).initialize(_sqrtPriceX96);\n        emit PoolCreated(_token0, _token1, _pool, _fee, _sqrtPriceX96);\n    }","after":"function createPair(\n        address _token0,\n        address _token1,\n        bytes calldata data\n    ) external override returns (address _pool) {\n        (uint24 _fee, uint160 _sqrtPriceX96) = abi.decode(data, (uint24, uint160));\n        _pool = IUniswapV3Factory(uniswapFactory).createPool(_token0, _token1, _fee);\n        IUniswapV3Pool(_pool).initialize(_sqrtPriceX96);\n        emit PoolCreated(_token0, _token1, _pool, _fee, _sqrtPriceX96);\n    }","contract":"UniswapLiquidityManager","time":0},{"type":"external-function ","before":"function deposit(\n        address token0,\n        address token1,\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        uint256 shares,\n        uint256 tokenId,\n        bool isTokenMinted,\n        bytes memory data\n    ) external payable override onlyUnipilot {\n        DepositVars memory b;\n        b.fee = abi.decode(data, (uint24));\n        b.pool = getPoolAddress(token0, token1, b.fee);\n        LiquidityPosition storage poolPosition = liquidityPositions[b.pool];\n\n        // updating the feeGrowthGlobal of pool for new user\n        if (poolPosition.totalLiquidity > 0) _collectPositionFees(b.pool);\n        (\n            b.amount0Base,\n            b.amount1Base,\n            b.amount0Range,\n            b.amount1Range\n        ) = _addLiquidityInManager(\n            AddLiquidityManagerParams({\n                pool: b.pool,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                shares: shares\n            })\n        );\n\n        if (!isTokenMinted) {\n            Position storage userPosition = positions[tokenId];\n            require(b.pool == userPosition.pool);\n            userPosition.tokensOwed0 += FullMath.mulDiv(\n                poolPosition.feeGrowthGlobal0 - userPosition.feeGrowth0,\n                userPosition.liquidity,\n                FixedPoint128.Q128\n            );\n            userPosition.tokensOwed1 += FullMath.mulDiv(\n                poolPosition.feeGrowthGlobal1 - userPosition.feeGrowth1,\n                userPosition.liquidity,\n                FixedPoint128.Q128\n            );\n            userPosition.liquidity += shares;\n            userPosition.feeGrowth0 = poolPosition.feeGrowthGlobal0;\n            userPosition.feeGrowth1 = poolPosition.feeGrowthGlobal1;\n        } else {\n            positions[tokenId] = Position({\n                nonce: 0,\n                pool: b.pool,\n                liquidity: shares,\n                feeGrowth0: poolPosition.feeGrowthGlobal0,\n                feeGrowth1: poolPosition.feeGrowthGlobal1,\n                tokensOwed0: 0,\n                tokensOwed1: 0\n            });\n        }\n\n        _checkDustAmount(\n            b.pool,\n            (b.amount0Base + b.amount0Range),\n            (b.amount1Base + b.amount1Range),\n            amount0Desired,\n            amount1Desired\n        );\n\n        emit Deposited(b.pool, tokenId, amount0Desired, amount1Desired, shares);\n    }","after":"function deposit(\n        address token0,\n        address token1,\n        uint256 amount0Desired,\n        uint256 amount1Desired,\n        uint256 shares,\n        uint256 tokenId,\n        bool isTokenMinted,\n        bytes calldata data\n    ) external payable override onlyUnipilot {\n        DepositVars memory b;\n        b.fee = abi.decode(data, (uint24));\n        b.pool = getPoolAddress(token0, token1, b.fee);\n        LiquidityPosition storage poolPosition = liquidityPositions[b.pool];\n\n        // updating the feeGrowthGlobal of pool for new user\n        if (poolPosition.totalLiquidity > 0) _collectPositionFees(b.pool);\n        (\n            b.amount0Base,\n            b.amount1Base,\n            b.amount0Range,\n            b.amount1Range\n        ) = _addLiquidityInManager(\n            AddLiquidityManagerParams({\n                pool: b.pool,\n                amount0Desired: amount0Desired,\n                amount1Desired: amount1Desired,\n                shares: shares\n            })\n        );\n\n        if (!isTokenMinted) {\n            Position storage userPosition = positions[tokenId];\n            require(b.pool == userPosition.pool);\n            userPosition.tokensOwed0 += FullMath.mulDiv(\n                poolPosition.feeGrowthGlobal0 - userPosition.feeGrowth0,\n                userPosition.liquidity,\n                FixedPoint128.Q128\n            );\n            userPosition.tokensOwed1 += FullMath.mulDiv(\n                poolPosition.feeGrowthGlobal1 - userPosition.feeGrowth1,\n                userPosition.liquidity,\n                FixedPoint128.Q128\n            );\n            userPosition.liquidity += shares;\n            userPosition.feeGrowth0 = poolPosition.feeGrowthGlobal0;\n            userPosition.feeGrowth1 = poolPosition.feeGrowthGlobal1;\n        } else {\n            positions[tokenId] = Position({\n                nonce: 0,\n                pool: b.pool,\n                liquidity: shares,\n                feeGrowth0: poolPosition.feeGrowthGlobal0,\n                feeGrowth1: poolPosition.feeGrowthGlobal1,\n                tokensOwed0: 0,\n                tokensOwed1: 0\n            });\n        }\n\n        _checkDustAmount(\n            b.pool,\n            (b.amount0Base + b.amount0Range),\n            (b.amount1Base + b.amount1Range),\n            amount0Desired,\n            amount1Desired\n        );\n\n        emit Deposited(b.pool, tokenId, amount0Desired, amount1Desired, shares);\n    }","contract":"UniswapLiquidityManager","time":0},{"type":"external-function ","before":"function withdraw(\n        bool pilotToken,\n        bool wethToken,\n        uint256 liquidity,\n        uint256 tokenId,\n        bytes memory data\n    ) external payable override onlyUnipilot nonReentrant {\n        Position storage position = positions[tokenId];\n        require(liquidity > 0);\n        require(liquidity <= position.liquidity);\n        WithdrawVars memory c;\n        c.recipient = abi.decode(data, (address));\n\n        (c.amount0Removed, c.amount1Removed) = _removeLiquidityUniswap(\n            false,\n            position.pool,\n            liquidity\n        );\n\n        (c.userAmount0, c.userAmount1, c.pilotAmount) = _distributeFeesAndLiquidity(\n            DistributeFeesParams({\n                pilotToken: pilotToken,\n                wethToken: wethToken,\n                pool: position.pool,\n                recipient: c.recipient,\n                tokenId: tokenId,\n                liquidity: liquidity,\n                amount0Removed: c.amount0Removed,\n                amount1Removed: c.amount1Removed\n            })\n        );\n\n        emit Withdrawn(\n            position.pool,\n            c.recipient,\n            tokenId,\n            c.amount0Removed,\n            c.amount1Removed\n        );\n    }","after":"function withdraw(\n        bool pilotToken,\n        bool wethToken,\n        uint256 liquidity,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable override onlyUnipilot nonReentrant {\n        Position storage position = positions[tokenId];\n        require(liquidity > 0);\n        require(liquidity <= position.liquidity);\n        WithdrawVars memory c;\n        c.recipient = abi.decode(data, (address));\n\n        (c.amount0Removed, c.amount1Removed) = _removeLiquidityUniswap(\n            false,\n            position.pool,\n            liquidity\n        );\n\n        (c.userAmount0, c.userAmount1, c.pilotAmount) = _distributeFeesAndLiquidity(\n            DistributeFeesParams({\n                pilotToken: pilotToken,\n                wethToken: wethToken,\n                pool: position.pool,\n                recipient: c.recipient,\n                tokenId: tokenId,\n                liquidity: liquidity,\n                amount0Removed: c.amount0Removed,\n                amount1Removed: c.amount1Removed\n            })\n        );\n\n        emit Withdrawn(\n            position.pool,\n            c.recipient,\n            tokenId,\n            c.amount0Removed,\n            c.amount1Removed\n        );\n    }","contract":"UniswapLiquidityManager","time":0},{"type":"external-function ","before":"function collect(\n        bool pilotToken,\n        bool wethToken,\n        uint256 tokenId,\n        bytes memory data\n    ) external payable override onlyUnipilot nonReentrant {\n        Position memory position = positions[tokenId];\n        require(position.liquidity > 0);\n        address recipient = abi.decode(data, (address));\n\n        _collectPositionFees(position.pool);\n\n        _distributeFeesAndLiquidity(\n            DistributeFeesParams({\n                pilotToken: pilotToken,\n                wethToken: wethToken,\n                pool: position.pool,\n                recipient: recipient,\n                tokenId: tokenId,\n                liquidity: 0,\n                amount0Removed: 0,\n                amount1Removed: 0\n            })\n        );\n    }","after":"function collect(\n        bool pilotToken,\n        bool wethToken,\n        uint256 tokenId,\n        bytes calldata data\n    ) external payable override onlyUnipilot nonReentrant {\n        Position memory position = positions[tokenId];\n        require(position.liquidity > 0);\n        address recipient = abi.decode(data, (address));\n\n        _collectPositionFees(position.pool);\n\n        _distributeFeesAndLiquidity(\n            DistributeFeesParams({\n                pilotToken: pilotToken,\n                wethToken: wethToken,\n                pool: position.pool,\n                recipient: recipient,\n                tokenId: tokenId,\n                liquidity: 0,\n                amount0Removed: 0,\n                amount1Removed: 0\n            })\n        );\n    }","contract":"UniswapLiquidityManager","time":0},{"type":"external-function ","before":"function emergencyExit(address recipient, bytes[10] memory data)\n        external\n        onlyGovernance\n    {\n        for (uint256 i = 0; i < data.length; ++i) {\n            (\n                address token,\n                address pool,\n                int24 tickLower,\n                int24 tickUpper,\n                uint128 liquidity\n            ) = abi.decode(data[i], (address, address, int24, int24, uint128));\n\n            if (pool != address(0)) {\n                IUniswapV3Pool(pool).burn(tickLower, tickUpper, liquidity);\n\n                IUniswapV3Pool(pool).collect(\n                    recipient,\n                    tickLower,\n                    tickUpper,\n                    MAX_UINT128,\n                    MAX_UINT128\n                );\n            }\n\n            uint256 balanceToken = IERC20(token).balanceOf(address(this));\n            if (balanceToken > 0) {\n                TransferHelper.safeTransfer(token, recipient, balanceToken);\n            }\n        }\n    }","after":"function emergencyExit(address recipient, bytes[10] calldata data)\n        external\n        onlyGovernance\n    {\n        for (uint256 i = 0; i < data.length; ++i) {\n            (\n                address token,\n                address pool,\n                int24 tickLower,\n                int24 tickUpper,\n                uint128 liquidity\n            ) = abi.decode(data[i], (address, address, int24, int24, uint128));\n\n            if (pool != address(0)) {\n                IUniswapV3Pool(pool).burn(tickLower, tickUpper, liquidity);\n\n                IUniswapV3Pool(pool).collect(\n                    recipient,\n                    tickLower,\n                    tickUpper,\n                    MAX_UINT128,\n                    MAX_UINT128\n                );\n            }\n\n            uint256 balanceToken = IERC20(token).balanceOf(address(this));\n            if (balanceToken > 0) {\n                TransferHelper.safeTransfer(token, recipient, balanceToken);\n            }\n        }\n    }","contract":"UniswapLiquidityManager","time":0},{"type":"struct-data-arrangement ","before":"\nint24 baseTickLower\nint24 baseTickUpper\nuint128 baseLiquidity\nint24 rangeTickLower\nint24 rangeTickUpper\nuint128 rangeLiquidity\nuint256 fees0\nuint256 fees1\nuint256 feeGrowthGlobal0\nuint256 feeGrowthGlobal1\nuint256 totalLiquidity\nbool feesInPilot\naddress oracle0\naddress oracle1\nuint256 timestamp\nuint8 counter\nbool status\nbool managed","after":"uint256 fees0\nuint256 fees1\nuint256 feeGrowthGlobal0\nuint256 feeGrowthGlobal1\nuint256 totalLiquidity\nuint256 timestamp\naddress oracle0\naddress oracle1\nuint128 baseLiquidity\nuint128 rangeLiquidity\nint24 baseTickLower\nint24 baseTickUpper\nint24 rangeTickLower\nint24 rangeTickUpper\nbool feesInPilot\nuint8 counter\nbool status\nbool managed\n","contract":"IUniswapLiquidityManager","time":1848},{"type":"struct-data-arrangement ","before":"\nuint8 swapPercentage\nuint24 swapPriceThreshold\nuint256 premium\nuint256 gasPriceLimit\nuint256 userPilotPercentage\nuint256 feesPercentageIndexFund\nuint24 readjustFrequencyTime\nuint16 poolCardinalityDesired\naddress pilotWethPair\naddress oracle\naddress indexFund\naddress uniStrategy\naddress unipilot","after":"uint256 premium\nuint256 gasPriceLimit\nuint256 userPilotPercentage\nuint256 feesPercentageIndexFund\naddress pilotWethPair\naddress oracle\naddress indexFund\naddress uniStrategy\naddress unipilot\nuint24 swapPriceThreshold\nuint24 readjustFrequencyTime\nuint16 poolCardinalityDesired\nuint8 swapPercentage\n","contract":"IUniswapLiquidityManager","time":11},{"type":"struct-data-arrangement ","before":"\naddress token0\naddress token1\nuint24 fee\nint24 currentTick\nuint128 baseLiquidity\nuint256 baseAmount0\nuint256 baseAmount1\nuint128 rangeLiquidity\nuint256 rangeAmount0\nuint256 rangeAmount1","after":"uint256 baseAmount0\nuint256 baseAmount1\nuint256 rangeAmount0\nuint256 rangeAmount1\naddress token0\naddress token1\nuint128 baseLiquidity\nuint128 rangeLiquidity\nuint24 fee\nint24 currentTick\n","contract":"IUniswapLiquidityManager","time":0}]}