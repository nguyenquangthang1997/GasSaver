{"time":194,"results":[{"type":"state-data-arrangement ","before":"\nuint256 public MAX_TOKEN_SUPPLY;\nuint256 public maxToMint;\nuint256 maxWhitelistMints;\nuint256 maxTeamReserveMints;\nuint256 maxGiveawayMints;\nuint256 numTeamReserveMinted;\nuint256 numGiveawayMinted;\nbool public saleIsActive;\nbool public whitelistIsActive;\nbytes32[] _whitelistRootHash;\nbytes32[] _giveawayRootHash;\nmapping(address => uint256) public numberOfWhitelistMints;\nmapping(address => uint256) public numberOfGiveawayMints;\naddress payoutWallet1;\naddress payoutWallet2;\nuint256 public whitelistMintPrice;\nuint256 public regularMintPrice;\nuint256 bytPayoutPercentage;\nstring private prerevealURI;\nbool public revealIsActive;\nuint256 maxTokenIdRevealed;","after":"uint256 public MAX_TOKEN_SUPPLY;\nuint256 public maxToMint;\nuint256 maxWhitelistMints;\nuint256 maxTeamReserveMints;\nuint256 maxGiveawayMints;\nuint256 numTeamReserveMinted;\nuint256 numGiveawayMinted;\nbytes32[] _whitelistRootHash;\nbytes32[] _giveawayRootHash;\nmapping(address => uint256) public numberOfWhitelistMints;\nmapping(address => uint256) public numberOfGiveawayMints;\nuint256 public whitelistMintPrice;\nuint256 public regularMintPrice;\nuint256 bytPayoutPercentage;\nstring private prerevealURI;\nuint256 maxTokenIdRevealed;\naddress payoutWallet1;\naddress payoutWallet2;\nbool public saleIsActive;\nbool public whitelistIsActive;\nbool public revealIsActive;\n","contract":"RubyMazurLips","time":1},{"type":"external-function ","before":"function setBaseURI(string memory baseURI) external onlyOwner {\n        _setBaseURI(baseURI);\n    }","after":"function setBaseURI(string calldata baseURI) external onlyOwner {\n        _setBaseURI(baseURI);\n    }","contract":"RubyMazurLips","time":0},{"type":"external-function ","before":"function setPrerevealURI(string memory prerevealURI_) external onlyOwner {\n        prerevealURI = prerevealURI_;\n    }","after":"function setPrerevealURI(string calldata prerevealURI_) external onlyOwner {\n        prerevealURI = prerevealURI_;\n    }","contract":"RubyMazurLips","time":0},{"type":"external-function ","before":"function whitelistMint(uint256 numberOfTokens, uint256 spotInWhitelist, bytes32[] memory proof) external payable {\n        require(whitelistIsActive, \"The whitelist is not active yet\");\n        require(saleIsActive == false, \"The whitelist mint has closed\");\n        require(numberOfTokens <= maxToMint, \"Invalid amount to mint per txn\");\n        require(totalSupply().add(numberOfTokens) <= MAX_TOKEN_SUPPLY, \"Purchase would exceed max supply\");\n        require(whitelistValidated(_msgSender(), 1, spotInWhitelist, proof, _whitelistRootHash), \"You're not on the whitelist\");\n        require((numberOfWhitelistMints[_msgSender()] + numberOfTokens) <= maxWhitelistMints, \"This transaction exceeds the max whitelist mints\");\n        require(whitelistMintPrice.mul(numberOfTokens) <= msg.value, \"Ether value set is not correct\");\n\n        numberOfWhitelistMints[_msgSender()] += numberOfTokens;\n\n        uint256 tokenID = totalSupply();\n        uint256 i;\n\n        for (i = 0; i < numberOfTokens; i++) {\n            _safeMint(_msgSender(), tokenID.add(i));\n        }\n    }","after":"function whitelistMint(uint256 numberOfTokens, uint256 spotInWhitelist, bytes32[] calldata proof) external payable {\n        require(whitelistIsActive, \"The whitelist is not active yet\");\n        require(saleIsActive == false, \"The whitelist mint has closed\");\n        require(numberOfTokens <= maxToMint, \"Invalid amount to mint per txn\");\n        require(totalSupply().add(numberOfTokens) <= MAX_TOKEN_SUPPLY, \"Purchase would exceed max supply\");\n        require(whitelistValidated(_msgSender(), 1, spotInWhitelist, proof, _whitelistRootHash), \"You're not on the whitelist\");\n        require((numberOfWhitelistMints[_msgSender()] + numberOfTokens) <= maxWhitelistMints, \"This transaction exceeds the max whitelist mints\");\n        require(whitelistMintPrice.mul(numberOfTokens) <= msg.value, \"Ether value set is not correct\");\n\n        numberOfWhitelistMints[_msgSender()] += numberOfTokens;\n\n        uint256 tokenID = totalSupply();\n        uint256 i;\n\n        for (i = 0; i < numberOfTokens; i++) {\n            _safeMint(_msgSender(), tokenID.add(i));\n        }\n    }","contract":"RubyMazurLips","time":0},{"type":"external-function ","before":"function giveawayMint(uint256 amount, uint256 spotInWhitelist, bytes32[] memory proof) external {\n        require(whitelistIsActive, \"Giveaway must be active to mint\");\n        require(numGiveawayMinted.add(amount) <= maxGiveawayMints, \"Mint would exeed max giveaway mints\");\n        require(totalSupply().add(amount) <= MAX_TOKEN_SUPPLY, \"Mint would exceed max supply\");\n        require(whitelistValidated(_msgSender(), amount, spotInWhitelist, proof, _giveawayRootHash), \"You're not on the giveaway list\");\n        require(numberOfGiveawayMints[_msgSender()] == 0, \"This address already received a giveaway mint\");\n\n        uint256 tokenID = totalSupply();\n        uint256 i;\n\n        numberOfGiveawayMints[_msgSender()] = amount;\n        numGiveawayMinted += amount;\n\n        for (i = 0; i < amount; i++) {\n            _safeMint(_msgSender(), tokenID.add(i));\n        }\n    }","after":"function giveawayMint(uint256 amount, uint256 spotInWhitelist, bytes32[] calldata proof) external {\n        require(whitelistIsActive, \"Giveaway must be active to mint\");\n        require(numGiveawayMinted.add(amount) <= maxGiveawayMints, \"Mint would exeed max giveaway mints\");\n        require(totalSupply().add(amount) <= MAX_TOKEN_SUPPLY, \"Mint would exceed max supply\");\n        require(whitelistValidated(_msgSender(), amount, spotInWhitelist, proof, _giveawayRootHash), \"You're not on the giveaway list\");\n        require(numberOfGiveawayMints[_msgSender()] == 0, \"This address already received a giveaway mint\");\n\n        uint256 tokenID = totalSupply();\n        uint256 i;\n\n        numberOfGiveawayMints[_msgSender()] = amount;\n        numGiveawayMinted += amount;\n\n        for (i = 0; i < amount; i++) {\n            _safeMint(_msgSender(), tokenID.add(i));\n        }\n    }","contract":"RubyMazurLips","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public MAX_TOKEN_SUPPLY;","after":"uint256 public immutable MAX_TOKEN_SUPPLY;","contract":"RubyMazurLips","time":1},{"type":"immutable-restrict-modification ","before":"uint256 maxWhitelistMints;","after":"uint256 immutable maxWhitelistMints;","contract":"RubyMazurLips","time":1},{"type":"immutable-restrict-modification ","before":"uint256 bytPayoutPercentage;","after":"uint256 immutable bytPayoutPercentage;","contract":"RubyMazurLips","time":1}]}