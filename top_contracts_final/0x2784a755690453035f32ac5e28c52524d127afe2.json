{"time":479,"results":[{"type":"external-function ","before":"function handle(\n        uint32 _origin,\n        bytes32 _sender,\n        bytes memory _message\n    ) external override onlyReplica onlyRemoteRouter(_origin, _sender) {\n        // parse tokenId and action from message\n        bytes29 _msg = _message.ref(0).mustBeMessage();\n        bytes29 _tokenId = _msg.tokenId();\n        bytes29 _action = _msg.action();\n        // handle message based on the intended action\n        if (_action.isTransfer()) {\n            _handleTransfer(_tokenId, _action);\n        } else if (_action.isDetails()) {\n            _handleDetails(_tokenId, _action);\n        } else if (_action.isRequestDetails()) {\n            _handleRequestDetails(_origin, _sender, _tokenId);\n        } else {\n            require(false, \"!valid action\");\n        }\n    }","after":"function handle(\n        uint32 _origin,\n        bytes32 _sender,\n        bytes calldata _message\n    ) external override onlyReplica onlyRemoteRouter(_origin, _sender) {\n        // parse tokenId and action from message\n        bytes29 _msg = _message.ref(0).mustBeMessage();\n        bytes29 _tokenId = _msg.tokenId();\n        bytes29 _action = _msg.action();\n        // handle message based on the intended action\n        if (_action.isTransfer()) {\n            _handleTransfer(_tokenId, _action);\n        } else if (_action.isDetails()) {\n            _handleDetails(_tokenId, _action);\n        } else if (_action.isRequestDetails()) {\n            _handleRequestDetails(_origin, _sender, _tokenId);\n        } else {\n            require(false, \"!valid action\");\n        }\n    }","contract":"BridgeRouter","time":0},{"type":"external-function ","before":"function unenrollReplica(\n        uint32 _domain,\n        bytes32 _updater,\n        bytes memory _signature\n    ) external {\n        // ensure that the replica is currently set\n        address _replica = domainToReplica[_domain];\n        require(_replica != address(0), \"!replica exists\");\n        // ensure that the signature is on the proper updater\n        require(\n            Replica(_replica).updater() == TypeCasts.bytes32ToAddress(_updater),\n            \"!current updater\"\n        );\n        // get the watcher address from the signature\n        // and ensure that the watcher has permission to un-enroll this replica\n        address _watcher = _recoverWatcherFromSig(\n            _domain,\n            TypeCasts.addressToBytes32(_replica),\n            _updater,\n            _signature\n        );\n        require(watcherPermissions[_watcher][_domain], \"!valid watcher\");\n        // remove the replica from mappings\n        _unenrollReplica(_replica);\n    }","after":"function unenrollReplica(\n        uint32 _domain,\n        bytes32 _updater,\n        bytes calldata _signature\n    ) external {\n        // ensure that the replica is currently set\n        address _replica = domainToReplica[_domain];\n        require(_replica != address(0), \"!replica exists\");\n        // ensure that the signature is on the proper updater\n        require(\n            Replica(_replica).updater() == TypeCasts.bytes32ToAddress(_updater),\n            \"!current updater\"\n        );\n        // get the watcher address from the signature\n        // and ensure that the watcher has permission to un-enroll this replica\n        address _watcher = _recoverWatcherFromSig(\n            _domain,\n            TypeCasts.addressToBytes32(_replica),\n            _updater,\n            _signature\n        );\n        require(watcherPermissions[_watcher][_domain], \"!valid watcher\");\n        // remove the replica from mappings\n        _unenrollReplica(_replica);\n    }","contract":"XAppConnectionManager","time":0},{"type":"external-function ","before":"function dispatch(\n        uint32 _destinationDomain,\n        bytes32 _recipientAddress,\n        bytes memory _messageBody\n    ) external notFailed {\n        require(_messageBody.length <= MAX_MESSAGE_BODY_BYTES, \"msg too long\");\n        // get the next nonce for the destination domain, then increment it\n        uint32 _nonce = nonces[_destinationDomain];\n        nonces[_destinationDomain] = _nonce + 1;\n        // format the message into packed bytes\n        bytes memory _message = Message.formatMessage(\n            localDomain,\n            bytes32(uint256(uint160(msg.sender))),\n            _nonce,\n            _destinationDomain,\n            _recipientAddress,\n            _messageBody\n        );\n        // insert the hashed message into the Merkle tree\n        bytes32 _messageHash = keccak256(_message);\n        tree.insert(_messageHash);\n        // enqueue the new Merkle root after inserting the message\n        queue.enqueue(root());\n        // Emit Dispatch event with message information\n        // note: leafIndex is count() - 1 since new leaf has already been inserted\n        emit Dispatch(\n            _messageHash,\n            count() - 1,\n            _destinationAndNonce(_destinationDomain, _nonce),\n            committedRoot,\n            _message\n        );\n    }","after":"function dispatch(\n        uint32 _destinationDomain,\n        bytes32 _recipientAddress,\n        bytes calldata _messageBody\n    ) external notFailed {\n        require(_messageBody.length <= MAX_MESSAGE_BODY_BYTES, \"msg too long\");\n        // get the next nonce for the destination domain, then increment it\n        uint32 _nonce = nonces[_destinationDomain];\n        nonces[_destinationDomain] = _nonce + 1;\n        // format the message into packed bytes\n        bytes memory _message = Message.formatMessage(\n            localDomain,\n            bytes32(uint256(uint160(msg.sender))),\n            _nonce,\n            _destinationDomain,\n            _recipientAddress,\n            _messageBody\n        );\n        // insert the hashed message into the Merkle tree\n        bytes32 _messageHash = keccak256(_message);\n        tree.insert(_messageHash);\n        // enqueue the new Merkle root after inserting the message\n        queue.enqueue(root());\n        // Emit Dispatch event with message information\n        // note: leafIndex is count() - 1 since new leaf has already been inserted\n        emit Dispatch(\n            _messageHash,\n            count() - 1,\n            _destinationAndNonce(_destinationDomain, _nonce),\n            committedRoot,\n            _message\n        );\n    }","contract":"Home","time":0},{"type":"external-function ","before":"function update(\n        bytes32 _committedRoot,\n        bytes32 _newRoot,\n        bytes memory _signature\n    ) external notFailed {\n        // check that the update is not fraudulent;\n        // if fraud is detected, Updater is slashed & Home is set to FAILED state\n        if (improperUpdate(_committedRoot, _newRoot, _signature)) return;\n        // clear all of the intermediate roots contained in this update from the queue\n        while (true) {\n            bytes32 _next = queue.dequeue();\n            if (_next == _newRoot) break;\n        }\n        // update the Home state with the latest signed root & emit event\n        committedRoot = _newRoot;\n        emit Update(localDomain, _committedRoot, _newRoot, _signature);\n    }","after":"function update(\n        bytes32 _committedRoot,\n        bytes32 _newRoot,\n        bytes calldata _signature\n    ) external notFailed {\n        // check that the update is not fraudulent;\n        // if fraud is detected, Updater is slashed & Home is set to FAILED state\n        if (improperUpdate(_committedRoot, _newRoot, _signature)) return;\n        // clear all of the intermediate roots contained in this update from the queue\n        while (true) {\n            bytes32 _next = queue.dequeue();\n            if (_next == _newRoot) break;\n        }\n        // update the Home state with the latest signed root & emit event\n        committedRoot = _newRoot;\n        emit Update(localDomain, _committedRoot, _newRoot, _signature);\n    }","contract":"Home","time":0},{"type":"state-data-arrangement ","before":"\nbytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\nuint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\nuint8 constant TWELVE_BYTES = 96;","after":"uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\nbytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\nuint8 constant TWELVE_BYTES = 96;\n","contract":"TypedMemView","time":0},{"type":"state-data-arrangement ","before":"\n   uint256 public immutable PROCESS_G\n   uint256 public immutable RESERVE_G\n   uint32 public remoteDoma\n   uint256 public optimisticSecon\n   uint8 private enter\n   mapping(bytes32 => uint256) public confirm\n   mapping(bytes32 => MessageStatus) public messag\n   uint256[44] private __G","after":"   uint256 public immutable PROCESS_G\n   uint256 public immutable RESERVE_G\n   uint256 public optimisticSecon\n   mapping(bytes32 => uint256) public confirm\n   mapping(bytes32 => MessageStatus) public messag\n   uint256[44] private __G\n   uint32 public remoteDoma\n   uint8 private enter\n","contract":"Replica","time":0},{"type":"external-function ","before":"   function update(\n        bytes32 _oldRoot,\n        bytes32 _newRoot,\n        bytes memory _signature\n    ) external notFailed {\n        // ensure that update is building off the last submitted root\n        require(_oldRoot == committedRoot, \"not current update\");\n        // validate updater signature\n        require(\n            _isUpdaterSignature(_oldRoot, _newRoot, _signature),\n            \"!updater sig\"\n        );\n        // Hook for future use\n        _beforeUpdate();\n        // set the new root's confirmation timer\n        confirmAt[_newRoot] = block.timestamp + optimisticSeconds;\n        // update committedRoot\n        committedRoot = _newRoot;\n        emit Update(remoteDomain, _oldRoot, _newRoot, _signature);\n  ","after":"   function update(\n        bytes32 _oldRoot,\n        bytes32 _newRoot,\n        bytes calldata _signature\n    ) external notFailed {\n        // ensure that update is building off the last submitted root\n        require(_oldRoot == committedRoot, \"not current update\");\n        // validate updater signature\n        require(\n            _isUpdaterSignature(_oldRoot, _newRoot, _signature),\n            \"!updater sig\"\n        );\n        // Hook for future use\n        _beforeUpdate();\n        // set the new root's confirmation timer\n        confirmAt[_newRoot] = block.timestamp + optimisticSeconds;\n        // update committedRoot\n        committedRoot = _newRoot;\n        emit Update(remoteDomain, _oldRoot, _newRoot, _signature);\n  ","contract":"Replica","time":0},{"type":"external-function ","before":"   function proveAndProcess(\n        bytes memory _message,\n        bytes32[32] calldata _proof,\n        uint256 _index\n    ) external {\n        require(prove(keccak256(_message), _proof, _index), \"!prove\");\n        process(_message);\n  ","after":"   function proveAndProcess(\n        bytes calldata _message,\n        bytes32[32] calldata _proof,\n        uint256 _index\n    ) external {\n        require(prove(keccak256(_message), _proof, _index), \"!prove\");\n        process(_message);\n  ","contract":"Replica","time":0}]}