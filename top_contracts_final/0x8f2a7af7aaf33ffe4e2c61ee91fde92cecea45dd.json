{"time":184,"results":[{"type":"external-function ","before":"function mintSelectedIdFor(\n        uint256 _id,\n        uint256 _price,\n        bytes memory _signature,\n        address _receiver\n    ) external {\n        require(verifySignature(_id, _price, _signature), \"Signature mismatch\");\n        require(\n            IERC20(_tokenAddress).transferFrom(\n                msg.sender,\n                address(this),\n                _price\n            )\n        );\n        _safeMint(_receiver, _id);\n    }","after":"function mintSelectedIdFor(\n        uint256 _id,\n        uint256 _price,\n        bytes calldata _signature,\n        address _receiver\n    ) external {\n        require(verifySignature(_id, _price, _signature), \"Signature mismatch\");\n        require(\n            IERC20(_tokenAddress).transferFrom(\n                msg.sender,\n                address(this),\n                _price\n            )\n        );\n        _safeMint(_receiver, _id);\n    }","contract":"UniqCollections","time":0},{"type":"external-function ","before":"function batchMintSelectedIds(\n        uint[] memory _ids,\n        address[] memory _addresses\n    ) external onlyOwner {\n        uint len = _ids.length;\n        require(len == _addresses.length, \"Arrays length\");\n        uint256 i = 0;\n        for (i = 0; i < len; i++) {\n            _safeMint(_addresses[i], _ids[i]);\n        }\n    }","after":"function batchMintSelectedIds(\n        uint[] calldata _ids,\n        address[] calldata _addresses\n    ) external onlyOwner {\n        uint len = _ids.length;\n        require(len == _addresses.length, \"Arrays length\");\n        uint256 i = 0;\n        for (i = 0; i < len; i++) {\n            _safeMint(_addresses[i], _ids[i]);\n        }\n    }","contract":"UniqCollections","time":0},{"type":"external-function ","before":"function editTokenUri(string memory _ttokenUri) external onlyOwner {\n        _token_uri = _ttokenUri;\n    }","after":"function editTokenUri(string calldata _ttokenUri) external onlyOwner {\n        _token_uri = _ttokenUri;\n    }","contract":"UniqCollections","time":0},{"type":"external-function ","before":"function setProvenanceHash(string memory _hash) external onlyOwner {\n        METADATA_PROVENANCE_HASH = _hash;\n    }","after":"function setProvenanceHash(string calldata _hash) external onlyOwner {\n        METADATA_PROVENANCE_HASH = _hash;\n    }","contract":"UniqCollections","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress]++;\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress]++;\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"UniqCollections","time":0},{"type":"immutable-restrict-modification ","before":"address internal _vestingAddress;","after":"address internal immutable _vestingAddress;","contract":"UniqCollections","time":0},{"type":"immutable-restrict-modification ","before":"address internal _vestingAddress2;","after":"address internal immutable _vestingAddress2;","contract":"UniqCollections","time":0},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"UniqCollections","time":0}]}