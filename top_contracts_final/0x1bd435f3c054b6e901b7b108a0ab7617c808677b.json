{"time":228,"results":[{"type":"struct-data-arrangement ","before":"\naddress fromToken\nuint256 fromAmount\nuint256 toAmount\nuint256 expectedAmount\naddress payable beneficiary\nstring referrer\nbool useReduxToken\nUtils.Path[] path","after":"uint256 fromAmount\nuint256 toAmount\nuint256 expectedAmount\nstring referrer\nUtils.Path[] path\naddress fromToken\naddress payable beneficiary\nbool useReduxToken\n","contract":"Utils","time":0},{"type":"struct-data-arrangement ","before":"\naddress fromToken\nuint256 fromAmount\nuint256 toAmount\nuint256 expectedAmount\naddress payable beneficiary\nstring referrer\nbool useReduxToken\nUtils.MegaSwapPath[] path","after":"uint256 fromAmount\nuint256 toAmount\nuint256 expectedAmount\nstring referrer\nUtils.MegaSwapPath[] path\naddress fromToken\naddress payable beneficiary\nbool useReduxToken\n","contract":"Utils","time":0},{"type":"struct-data-arrangement ","before":"\naddress fromToken\naddress toToken\nuint256 fromAmount\nuint256 toAmount\naddress payable beneficiary\nstring referrer\nbool useReduxToken\nUtils.BuyRoute[] route","after":"uint256 fromAmount\nuint256 toAmount\nstring referrer\nUtils.BuyRoute[] route\naddress fromToken\naddress toToken\naddress payable beneficiary\nbool useReduxToken\n","contract":"Utils","time":0},{"type":"external-function ","before":"function simplBuy(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        address[] memory callees,\n        bytes memory exchangeData,\n        uint256[] memory startIndexes,\n        uint256[] memory values,\n        address payable beneficiary,\n        string memory referrer,\n        bool useReduxToken\n    )\n        external\n        payable\n\n    {\n        beneficiary = beneficiary == address(0) ? msg.sender : beneficiary;\n        uint receivedAmount = performSimpleSwap(\n            fromToken,\n            toToken,\n            fromAmount,\n            toAmount,\n            toAmount,//expected amount and to amount are same in case of buy\n            callees,\n            exchangeData,\n            startIndexes,\n            values,\n            beneficiary,\n            referrer,\n            useReduxToken\n        );\n\n        uint256 remainingAmount = Utils.tokenBalance(\n            fromToken,\n            address(this)\n        );\n\n        if (remainingAmount > 0) {\n            Utils.transferTokens(address(fromToken), msg.sender, remainingAmount);\n        }\n\n        emit Bought(\n            msg.sender,\n            beneficiary,\n            fromToken,\n            toToken,\n            fromAmount,\n            receivedAmount,\n            referrer\n        );\n    }","after":"function simplBuy(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        address[] calldata callees,\n        bytes calldata exchangeData,\n        uint256[] calldata startIndexes,\n        uint256[] calldata values,\n        address payable beneficiary,\n        string calldata referrer,\n        bool useReduxToken\n    )\n        external\n        payable\n\n    {\n        beneficiary = beneficiary == address(0) ? msg.sender : beneficiary;\n        uint receivedAmount = performSimpleSwap(\n            fromToken,\n            toToken,\n            fromAmount,\n            toAmount,\n            toAmount,//expected amount and to amount are same in case of buy\n            callees,\n            exchangeData,\n            startIndexes,\n            values,\n            beneficiary,\n            referrer,\n            useReduxToken\n        );\n\n        uint256 remainingAmount = Utils.tokenBalance(\n            fromToken,\n            address(this)\n        );\n\n        if (remainingAmount > 0) {\n            Utils.transferTokens(address(fromToken), msg.sender, remainingAmount);\n        }\n\n        emit Bought(\n            msg.sender,\n            beneficiary,\n            fromToken,\n            toToken,\n            fromAmount,\n            receivedAmount,\n            referrer\n        );\n    }","contract":"AugustusSwapper","time":0},{"type":"external-function ","before":"function simpleSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 expectedAmount,\n        address[] memory callees,\n        bytes memory exchangeData,\n        uint256[] memory startIndexes,\n        uint256[] memory values,\n        address payable beneficiary,\n        string memory referrer,\n        bool useReduxToken\n    )\n        public\n        payable\n        returns (uint256 receivedAmount)\n    {\n        beneficiary = beneficiary == address(0) ? msg.sender : beneficiary;\n        receivedAmount = performSimpleSwap(\n            fromToken,\n            toToken,\n            fromAmount,\n            toAmount,\n            expectedAmount,\n            callees,\n            exchangeData,\n            startIndexes,\n            values,\n            beneficiary,\n            referrer,\n            useReduxToken\n        );\n\n        emit Swapped(\n            msg.sender,\n            beneficiary,\n            fromToken,\n            toToken,\n            fromAmount,\n            receivedAmount,\n            expectedAmount,\n            referrer\n        );\n\n        return receivedAmount;\n    }","after":"function simpleSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        uint256 expectedAmount,\n        address[] calldata callees,\n        bytes calldata exchangeData,\n        uint256[] calldata startIndexes,\n        uint256[] calldata values,\n        address payable beneficiary,\n        string calldata referrer,\n        bool useReduxToken\n    )\n        public\n        payable\n        returns (uint256 receivedAmount)\n    {\n        beneficiary = beneficiary == address(0) ? msg.sender : beneficiary;\n        receivedAmount = performSimpleSwap(\n            fromToken,\n            toToken,\n            fromAmount,\n            toAmount,\n            expectedAmount,\n            callees,\n            exchangeData,\n            startIndexes,\n            values,\n            beneficiary,\n            referrer,\n            useReduxToken\n        );\n\n        emit Swapped(\n            msg.sender,\n            beneficiary,\n            fromToken,\n            toToken,\n            fromAmount,\n            receivedAmount,\n            expectedAmount,\n            referrer\n        );\n\n        return receivedAmount;\n    }","contract":"AugustusSwapper","time":0},{"type":"external-function ","before":"function multiSwap(\n        Utils.SellData memory data\n    )\n        public\n        payable\n        returns (uint256)\n    {\n        uint initialGas = gasleft();\n\n        address fromToken = data.fromToken;\n        uint256 fromAmount = data.fromAmount;\n        uint256 toAmount = data.toAmount;\n        uint256 expectedAmount = data.expectedAmount;\n        address payable beneficiary = data.beneficiary == address(0) ? msg.sender : data.beneficiary;\n        string memory referrer = data.referrer;\n        Utils.Path[] memory path = data.path;\n        address toToken = path[path.length - 1].to;\n        bool useReduxToken = data.useReduxToken;\n\n        //Referral can never be empty\n        require(bytes(referrer).length > 0, \"Invalid referrer\");\n\n        require(toAmount > 0, \"To amount can not be 0\");\n\n        //if fromToken is not ETH then transfer tokens from user to this contract\n        if (fromToken != Utils.ethAddress()) {\n            _tokenTransferProxy.transferFrom(\n                fromToken,\n                msg.sender,\n                address(this),\n                fromAmount\n            );\n        }\n\n        performSwap(\n            fromToken,\n            fromAmount,\n            path\n        );\n\n\n        uint256 receivedAmount = Utils.tokenBalance(\n            toToken,\n            address(this)\n        );\n\n        require(\n            receivedAmount >= toAmount,\n            \"Received amount of tokens are less then expected\"\n        );\n\n\n        takeFeeAndTransferTokens(\n            toToken,\n            expectedAmount,\n            receivedAmount,\n            beneficiary,\n            referrer\n        );\n\n        if (useReduxToken) {\n            Utils.refundGas(msg.sender, address(_tokenTransferProxy), initialGas);\n        }\n\n        emit Swapped(\n            msg.sender,\n            beneficiary,\n            fromToken,\n            toToken,\n            fromAmount,\n            receivedAmount,\n            expectedAmount,\n            referrer\n        );\n\n        return receivedAmount;\n    }","after":"function multiSwap(\n        Utils.SellData calldata data\n    )\n        public\n        payable\n        returns (uint256)\n    {\n        uint initialGas = gasleft();\n\n        address fromToken = data.fromToken;\n        uint256 fromAmount = data.fromAmount;\n        uint256 toAmount = data.toAmount;\n        uint256 expectedAmount = data.expectedAmount;\n        address payable beneficiary = data.beneficiary == address(0) ? msg.sender : data.beneficiary;\n        string memory referrer = data.referrer;\n        Utils.Path[] memory path = data.path;\n        address toToken = path[path.length - 1].to;\n        bool useReduxToken = data.useReduxToken;\n\n        //Referral can never be empty\n        require(bytes(referrer).length > 0, \"Invalid referrer\");\n\n        require(toAmount > 0, \"To amount can not be 0\");\n\n        //if fromToken is not ETH then transfer tokens from user to this contract\n        if (fromToken != Utils.ethAddress()) {\n            _tokenTransferProxy.transferFrom(\n                fromToken,\n                msg.sender,\n                address(this),\n                fromAmount\n            );\n        }\n\n        performSwap(\n            fromToken,\n            fromAmount,\n            path\n        );\n\n\n        uint256 receivedAmount = Utils.tokenBalance(\n            toToken,\n            address(this)\n        );\n\n        require(\n            receivedAmount >= toAmount,\n            \"Received amount of tokens are less then expected\"\n        );\n\n\n        takeFeeAndTransferTokens(\n            toToken,\n            expectedAmount,\n            receivedAmount,\n            beneficiary,\n            referrer\n        );\n\n        if (useReduxToken) {\n            Utils.refundGas(msg.sender, address(_tokenTransferProxy), initialGas);\n        }\n\n        emit Swapped(\n            msg.sender,\n            beneficiary,\n            fromToken,\n            toToken,\n            fromAmount,\n            receivedAmount,\n            expectedAmount,\n            referrer\n        );\n\n        return receivedAmount;\n    }","contract":"AugustusSwapper","time":0},{"type":"external-function ","before":"function megaSwap(\n        Utils.MegaSwapSellData memory data\n    )\n        public\n        payable\n        returns (uint256)\n    {\n        uint initialGas = gasleft();\n\n        address fromToken = data.fromToken;\n        uint256 fromAmount = data.fromAmount;\n        uint256 toAmount = data.toAmount;\n        uint256 expectedAmount = data.expectedAmount;\n        address payable beneficiary = data.beneficiary == address(0) ? msg.sender : data.beneficiary;\n        string memory referrer = data.referrer;\n        Utils.MegaSwapPath[] memory path = data.path;\n        address toToken = path[0].path[path[0].path.length - 1].to;\n        bool useReduxToken = data.useReduxToken;\n\n        //Referral can never be empty\n        require(bytes(referrer).length > 0, \"Invalid referrer\");\n\n        require(toAmount > 0, \"To amount can not be 0\");\n\n        //if fromToken is not ETH then transfer tokens from user to this contract\n        if (fromToken != Utils.ethAddress()) {\n            _tokenTransferProxy.transferFrom(\n                fromToken,\n                msg.sender,\n                address(this),\n                fromAmount\n            );\n        }\n\n        for (uint8 i = 0; i < uint8(path.length); i++) {\n            uint256 _fromAmount = fromAmount.mul(path[i].fromAmountPercent).div(10000);\n            if (i == path.length - 1) {\n                _fromAmount = Utils.tokenBalance(address(fromToken), address(this));\n            }\n            performSwap(\n                fromToken,\n                _fromAmount,\n                path[i].path\n            );\n        }\n\n        uint256 receivedAmount = Utils.tokenBalance(\n            toToken,\n            address(this)\n        );\n\n        require(\n            receivedAmount >= toAmount,\n            \"Received amount of tokens are less then expected\"\n        );\n\n\n        takeFeeAndTransferTokens(\n            toToken,\n            expectedAmount,\n            receivedAmount,\n            beneficiary,\n            referrer\n        );\n\n        if (useReduxToken) {\n            Utils.refundGas(msg.sender, address(_tokenTransferProxy), initialGas);\n        }\n\n        emit Swapped(\n            msg.sender,\n            beneficiary,\n            fromToken,\n            toToken,\n            fromAmount,\n            receivedAmount,\n            expectedAmount,\n            referrer\n        );\n\n        return receivedAmount;\n    }","after":"function megaSwap(\n        Utils.MegaSwapSellData calldata data\n    )\n        public\n        payable\n        returns (uint256)\n    {\n        uint initialGas = gasleft();\n\n        address fromToken = data.fromToken;\n        uint256 fromAmount = data.fromAmount;\n        uint256 toAmount = data.toAmount;\n        uint256 expectedAmount = data.expectedAmount;\n        address payable beneficiary = data.beneficiary == address(0) ? msg.sender : data.beneficiary;\n        string memory referrer = data.referrer;\n        Utils.MegaSwapPath[] memory path = data.path;\n        address toToken = path[0].path[path[0].path.length - 1].to;\n        bool useReduxToken = data.useReduxToken;\n\n        //Referral can never be empty\n        require(bytes(referrer).length > 0, \"Invalid referrer\");\n\n        require(toAmount > 0, \"To amount can not be 0\");\n\n        //if fromToken is not ETH then transfer tokens from user to this contract\n        if (fromToken != Utils.ethAddress()) {\n            _tokenTransferProxy.transferFrom(\n                fromToken,\n                msg.sender,\n                address(this),\n                fromAmount\n            );\n        }\n\n        for (uint8 i = 0; i < uint8(path.length); i++) {\n            uint256 _fromAmount = fromAmount.mul(path[i].fromAmountPercent).div(10000);\n            if (i == path.length - 1) {\n                _fromAmount = Utils.tokenBalance(address(fromToken), address(this));\n            }\n            performSwap(\n                fromToken,\n                _fromAmount,\n                path[i].path\n            );\n        }\n\n        uint256 receivedAmount = Utils.tokenBalance(\n            toToken,\n            address(this)\n        );\n\n        require(\n            receivedAmount >= toAmount,\n            \"Received amount of tokens are less then expected\"\n        );\n\n\n        takeFeeAndTransferTokens(\n            toToken,\n            expectedAmount,\n            receivedAmount,\n            beneficiary,\n            referrer\n        );\n\n        if (useReduxToken) {\n            Utils.refundGas(msg.sender, address(_tokenTransferProxy), initialGas);\n        }\n\n        emit Swapped(\n            msg.sender,\n            beneficiary,\n            fromToken,\n            toToken,\n            fromAmount,\n            receivedAmount,\n            expectedAmount,\n            referrer\n        );\n\n        return receivedAmount;\n    }","contract":"AugustusSwapper","time":0},{"type":"external-function ","before":"function buy(\n        Utils.BuyData memory data\n    )\n        public\n        payable\n        returns (uint256)\n    {\n\n        address fromToken = data.fromToken;\n        uint256 fromAmount = data.fromAmount;\n        uint256 toAmount = data.toAmount;\n        address payable beneficiary = data.beneficiary == address(0) ? msg.sender : data.beneficiary;\n        string memory referrer = data.referrer;\n        Utils.BuyRoute[] memory route = data.route;\n        address toToken = data.toToken;\n        bool useReduxToken = data.useReduxToken;\n\n        //Referral id can never be empty\n        require(bytes(referrer).length > 0, \"Invalid referrer\");\n\n        require(toAmount > 0, \"To amount can not be 0\");\n\n        uint256 receivedAmount = performBuy(\n            fromToken,\n            toToken,\n            fromAmount,\n            toAmount,\n            route,\n            useReduxToken\n        );\n\n        takeFeeAndTransferTokens(\n            toToken,\n            toAmount,\n            receivedAmount,\n            beneficiary,\n            referrer\n        );\n\n        uint256 remainingAmount = Utils.tokenBalance(\n            fromToken,\n            address(this)\n        );\n\n        if (remainingAmount > 0) {\n            Utils.transferTokens(fromToken, msg.sender, remainingAmount);\n        }\n\n        emit Bought(\n            msg.sender,\n            beneficiary,\n            fromToken,\n            toToken,\n            fromAmount,\n            receivedAmount,\n            referrer\n        );\n\n        return receivedAmount;\n    }","after":"function buy(\n        Utils.BuyData calldata data\n    )\n        public\n        payable\n        returns (uint256)\n    {\n\n        address fromToken = data.fromToken;\n        uint256 fromAmount = data.fromAmount;\n        uint256 toAmount = data.toAmount;\n        address payable beneficiary = data.beneficiary == address(0) ? msg.sender : data.beneficiary;\n        string memory referrer = data.referrer;\n        Utils.BuyRoute[] memory route = data.route;\n        address toToken = data.toToken;\n        bool useReduxToken = data.useReduxToken;\n\n        //Referral id can never be empty\n        require(bytes(referrer).length > 0, \"Invalid referrer\");\n\n        require(toAmount > 0, \"To amount can not be 0\");\n\n        uint256 receivedAmount = performBuy(\n            fromToken,\n            toToken,\n            fromAmount,\n            toAmount,\n            route,\n            useReduxToken\n        );\n\n        takeFeeAndTransferTokens(\n            toToken,\n            toAmount,\n            receivedAmount,\n            beneficiary,\n            referrer\n        );\n\n        uint256 remainingAmount = Utils.tokenBalance(\n            fromToken,\n            address(this)\n        );\n\n        if (remainingAmount > 0) {\n            Utils.transferTokens(fromToken, msg.sender, remainingAmount);\n        }\n\n        emit Bought(\n            msg.sender,\n            beneficiary,\n            fromToken,\n            toToken,\n            fromAmount,\n            receivedAmount,\n            referrer\n        );\n\n        return receivedAmount;\n    }","contract":"AugustusSwapper","time":0}]}