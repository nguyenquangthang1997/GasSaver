{"time":242,"results":[{"type":"external-function ","before":"function deposit(\n        address depositToken, \n        uint amountToStake, \n        uint[] memory minAmounts,\n        // uint _amountOutMin_25Percent, // 0\n        // uint _amountOutMin_stakingReferralFee, // 1\n        // uint amountLiquidityMin_rewardTokenReceived, // 2\n        // uint amountLiquidityMin_baseTokenReceived, // 3\n        // uint _amountOutMin_rewardTokenReceived, // 4\n        // uint _amountOutMin_baseTokenReceived, // 5\n        // uint _amountOutMin_claimAsToken_dyp, // 6\n        // uint _amountOutMin_attemptSwap, // 7\n        uint _deadline\n    ) public noContractsAllowed notDuringEmergency {\n        require(minAmounts.length == 8, \"Invalid minAmounts length!\");\n        \n        require(trustedClaimableTokens[depositToken], \"Invalid deposit token!\");\n\n        // can deposit reward token directly\n        // require(depositToken != trustedRewardTokenAddress, \"Cannot deposit reward token!\");\n        \n        require(depositToken != trustedDepositTokenAddress, \"Cannot deposit LP directly!\");\n        require(depositToken != address(0), \"Deposit token cannot be 0!\");\n\n        require(amountToStake > 0, \"Invalid amount to Stake!\");\n\n        IERC20(depositToken).safeTransferFrom(msg.sender, address(this), amountToStake);\n\n        uint fee = amountToStake.mul(STAKING_FEE_RATE_X_100).div(100e2);\n        uint amountAfterFee = amountToStake.sub(fee);\n        if (fee > 0) {\n            IERC20(depositToken).safeTransfer(feeRecipientAddress, fee);\n        }\n\n        uint _75Percent = amountAfterFee.mul(75e2).div(100e2);\n        uint _25Percent = amountAfterFee.sub(_75Percent);\n\n        uint amountToDepositByContract = doSwap(depositToken, trustedPlatformTokenAddress, _25Percent, /*_amountOutMin_25Percent*/minAmounts[0], _deadline);\n\n        IERC20(trustedPlatformTokenAddress).safeApprove(address(trustedStakingContractAddress), 0);\n        IERC20(trustedPlatformTokenAddress).safeApprove(address(trustedStakingContractAddress), amountToDepositByContract);\n\n        StakingContract(trustedStakingContractAddress).depositByContract(msg.sender, amountToDepositByContract, /*_amountOutMin_stakingReferralFee*/minAmounts[1], _deadline);\n\n        uint half = _75Percent.div(2);\n        uint otherHalf = _75Percent.sub(half);\n\n        uint _rewardTokenReceived = doSwap(depositToken, trustedRewardTokenAddress, half, /*_amountOutMin_rewardTokenReceived*/minAmounts[4], _deadline);\n        uint _baseTokenReceived = doSwap(depositToken, trustedBaseTokenAddress, otherHalf, /*_amountOutMin_baseTokenReceived*/minAmounts[5], _deadline);\n\n        uint amountToDeposit = addLiquidityAndGetAmountToDeposit(\n            _rewardTokenReceived, \n            _baseTokenReceived,\n            minAmounts,\n            _deadline\n        );\n\n        require(amountToDeposit > 0, \"Cannot deposit 0 Tokens\");\n\n        updateAccount(msg.sender, /*_amountOutMin_claimAsToken_dyp*/minAmounts[6], /*_amountOutMin_attemptSwap*/minAmounts[7], _deadline);\n        \n        depositedTokens[msg.sender] = depositedTokens[msg.sender].add(amountToDeposit);\n        totalTokens = totalTokens.add(amountToDeposit);\n\n        holders.add(msg.sender);\n        depositTime[msg.sender] = now;\n    }","after":"function deposit(\n        address depositToken, \n        uint amountToStake, \n        uint[] calldata minAmounts,\n        // uint _amountOutMin_25Percent, // 0\n        // uint _amountOutMin_stakingReferralFee, // 1\n        // uint amountLiquidityMin_rewardTokenReceived, // 2\n        // uint amountLiquidityMin_baseTokenReceived, // 3\n        // uint _amountOutMin_rewardTokenReceived, // 4\n        // uint _amountOutMin_baseTokenReceived, // 5\n        // uint _amountOutMin_claimAsToken_dyp, // 6\n        // uint _amountOutMin_attemptSwap, // 7\n        uint _deadline\n    ) public noContractsAllowed notDuringEmergency {\n        require(minAmounts.length == 8, \"Invalid minAmounts length!\");\n        \n        require(trustedClaimableTokens[depositToken], \"Invalid deposit token!\");\n\n        // can deposit reward token directly\n        // require(depositToken != trustedRewardTokenAddress, \"Cannot deposit reward token!\");\n        \n        require(depositToken != trustedDepositTokenAddress, \"Cannot deposit LP directly!\");\n        require(depositToken != address(0), \"Deposit token cannot be 0!\");\n\n        require(amountToStake > 0, \"Invalid amount to Stake!\");\n\n        IERC20(depositToken).safeTransferFrom(msg.sender, address(this), amountToStake);\n\n        uint fee = amountToStake.mul(STAKING_FEE_RATE_X_100).div(100e2);\n        uint amountAfterFee = amountToStake.sub(fee);\n        if (fee > 0) {\n            IERC20(depositToken).safeTransfer(feeRecipientAddress, fee);\n        }\n\n        uint _75Percent = amountAfterFee.mul(75e2).div(100e2);\n        uint _25Percent = amountAfterFee.sub(_75Percent);\n\n        uint amountToDepositByContract = doSwap(depositToken, trustedPlatformTokenAddress, _25Percent, /*_amountOutMin_25Percent*/minAmounts[0], _deadline);\n\n        IERC20(trustedPlatformTokenAddress).safeApprove(address(trustedStakingContractAddress), 0);\n        IERC20(trustedPlatformTokenAddress).safeApprove(address(trustedStakingContractAddress), amountToDepositByContract);\n\n        StakingContract(trustedStakingContractAddress).depositByContract(msg.sender, amountToDepositByContract, /*_amountOutMin_stakingReferralFee*/minAmounts[1], _deadline);\n\n        uint half = _75Percent.div(2);\n        uint otherHalf = _75Percent.sub(half);\n\n        uint _rewardTokenReceived = doSwap(depositToken, trustedRewardTokenAddress, half, /*_amountOutMin_rewardTokenReceived*/minAmounts[4], _deadline);\n        uint _baseTokenReceived = doSwap(depositToken, trustedBaseTokenAddress, otherHalf, /*_amountOutMin_baseTokenReceived*/minAmounts[5], _deadline);\n\n        uint amountToDeposit = addLiquidityAndGetAmountToDeposit(\n            _rewardTokenReceived, \n            _baseTokenReceived,\n            minAmounts,\n            _deadline\n        );\n\n        require(amountToDeposit > 0, \"Cannot deposit 0 Tokens\");\n\n        updateAccount(msg.sender, /*_amountOutMin_claimAsToken_dyp*/minAmounts[6], /*_amountOutMin_attemptSwap*/minAmounts[7], _deadline);\n        \n        depositedTokens[msg.sender] = depositedTokens[msg.sender].add(amountToDeposit);\n        totalTokens = totalTokens.add(amountToDeposit);\n\n        holders.add(msg.sender);\n        depositTime[msg.sender] = now;\n    }","contract":"FarmProRata","time":0},{"type":"external-function ","before":"function withdraw(\n        address withdrawAsToken,  \n        uint amountToWithdraw, \n        uint[] memory minAmounts,\n        // uint _amountLiquidityMin_rewardToken, // 0\n        // uint _amountLiquidityMin_baseToken, // 1\n        // uint _amountOutMin_withdrawAsToken_rewardTokenReceived, // 2\n        // uint _amountOutMin_withdrawAsToken_baseTokenReceived, // 3\n        // uint _amountOutMin_claimAsToken_dyp,  // 4\n        // uint _amountOutMin_attemptSwap, // 5\n        uint _deadline\n    ) public noContractsAllowed {\n        require(minAmounts.length == 6, \"Invalid minAmounts!\");\n        require(withdrawAsToken != address(0), \"Invalid withdraw token!\");\n        require(trustedClaimableTokens[withdrawAsToken], \"Withdraw token not trusted!\");\n        require(amountToWithdraw > 0, \"Cannot withdraw 0 Tokens!\");\n\n        require(depositedTokens[msg.sender] >= amountToWithdraw, \"Invalid amount to withdraw\");\n        require(now.sub(depositTime[msg.sender]) > cliffTime, \"You recently deposited, please wait before withdrawing.\");\n        \n        updateAccount(msg.sender, /*_amountOutMin_claimAsToken_dyp*/ minAmounts[4] , /*_amountOutMin_attemptSwap*/ minAmounts[5], _deadline);\n        \n        uint fee = amountToWithdraw.mul(UNSTAKING_FEE_RATE_X_100).div(100e2);\n        uint amountAfterFee = amountToWithdraw.sub(fee);\n        if (fee > 0) {\n            IERC20(trustedDepositTokenAddress).safeTransfer(feeRecipientAddress, fee);\n        }\n\n        uint withdrawTokenReceived = removeLiquidityAndGetWithdrawTokenReceived(withdrawAsToken, amountAfterFee, minAmounts, _deadline);\n\n        IERC20(withdrawAsToken).safeTransfer(msg.sender, withdrawTokenReceived);\n\n        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountToWithdraw);\n        totalTokens = totalTokens.sub(amountToWithdraw);\n\n        if (holders.contains(msg.sender) && depositedTokens[msg.sender] == 0) {\n            holders.remove(msg.sender);\n        }\n    }","after":"function withdraw(\n        address withdrawAsToken,  \n        uint amountToWithdraw, \n        uint[] calldata minAmounts,\n        // uint _amountLiquidityMin_rewardToken, // 0\n        // uint _amountLiquidityMin_baseToken, // 1\n        // uint _amountOutMin_withdrawAsToken_rewardTokenReceived, // 2\n        // uint _amountOutMin_withdrawAsToken_baseTokenReceived, // 3\n        // uint _amountOutMin_claimAsToken_dyp,  // 4\n        // uint _amountOutMin_attemptSwap, // 5\n        uint _deadline\n    ) public noContractsAllowed {\n        require(minAmounts.length == 6, \"Invalid minAmounts!\");\n        require(withdrawAsToken != address(0), \"Invalid withdraw token!\");\n        require(trustedClaimableTokens[withdrawAsToken], \"Withdraw token not trusted!\");\n        require(amountToWithdraw > 0, \"Cannot withdraw 0 Tokens!\");\n\n        require(depositedTokens[msg.sender] >= amountToWithdraw, \"Invalid amount to withdraw\");\n        require(now.sub(depositTime[msg.sender]) > cliffTime, \"You recently deposited, please wait before withdrawing.\");\n        \n        updateAccount(msg.sender, /*_amountOutMin_claimAsToken_dyp*/ minAmounts[4] , /*_amountOutMin_attemptSwap*/ minAmounts[5], _deadline);\n        \n        uint fee = amountToWithdraw.mul(UNSTAKING_FEE_RATE_X_100).div(100e2);\n        uint amountAfterFee = amountToWithdraw.sub(fee);\n        if (fee > 0) {\n            IERC20(trustedDepositTokenAddress).safeTransfer(feeRecipientAddress, fee);\n        }\n\n        uint withdrawTokenReceived = removeLiquidityAndGetWithdrawTokenReceived(withdrawAsToken, amountAfterFee, minAmounts, _deadline);\n\n        IERC20(withdrawAsToken).safeTransfer(msg.sender, withdrawTokenReceived);\n\n        depositedTokens[msg.sender] = depositedTokens[msg.sender].sub(amountToWithdraw);\n        totalTokens = totalTokens.sub(amountToWithdraw);\n\n        if (holders.contains(msg.sender) && depositedTokens[msg.sender] == 0) {\n            holders.remove(msg.sender);\n        }\n    }","contract":"FarmProRata","time":0},{"type":"immutable-restrict-modification ","before":"uint public contractDeployTime;","after":"uint public immutable contractDeployTime;","contract":"FarmProRata","time":1}]}