{"time":162,"results":[{"type":"external-function ","before":"function buyNFTNormal(\n        address[4] memory _tradeAddress,\n        uint256[3] memory _attributes,\n        uint256 nonce,\n        bytes memory signature\n    ) external verifySignature(nonce, _tradeAddress, _attributes, signature) {\n        // check allowance of buyer\n        require(\n            IERC20(_tradeAddress[2]).allowance(msg.sender, address(this)) >=\n                _attributes[0],\n            \"token allowance too low\"\n        );\n        (uint256 amount, uint256 feeProduct) = checkFeeProductExits(\n            _tradeAddress[3],\n            _attributes\n        );\n\n        if (feeProduct != 0) {\n            // transfer token to fee address\n            ERC20(_tradeAddress[2]).safeTransferFrom(\n                msg.sender,\n                _tradeAddress[3],\n                feeProduct\n            );\n        }\n        // transfer token from buyer to seller\n        ERC20(_tradeAddress[2]).safeTransferFrom(\n            msg.sender,\n            _tradeAddress[1],\n            amount\n        );\n        IERC721(ERC721).safeTransferFrom(\n            _tradeAddress[1],\n            msg.sender,\n            _attributes[1]\n        );\n        emit BuyNFTNormal(\n            [msg.sender, _tradeAddress[1], _tradeAddress[2]],\n            _attributes[1],\n            _attributes[0]\n        );\n    }","after":"function buyNFTNormal(\n        address[4] calldata _tradeAddress,\n        uint256[3] calldata _attributes,\n        uint256 nonce,\n        bytes calldata signature\n    ) external verifySignature(nonce, _tradeAddress, _attributes, signature) {\n        // check allowance of buyer\n        require(\n            IERC20(_tradeAddress[2]).allowance(msg.sender, address(this)) >=\n                _attributes[0],\n            \"token allowance too low\"\n        );\n        (uint256 amount, uint256 feeProduct) = checkFeeProductExits(\n            _tradeAddress[3],\n            _attributes\n        );\n\n        if (feeProduct != 0) {\n            // transfer token to fee address\n            ERC20(_tradeAddress[2]).safeTransferFrom(\n                msg.sender,\n                _tradeAddress[3],\n                feeProduct\n            );\n        }\n        // transfer token from buyer to seller\n        ERC20(_tradeAddress[2]).safeTransferFrom(\n            msg.sender,\n            _tradeAddress[1],\n            amount\n        );\n        IERC721(ERC721).safeTransferFrom(\n            _tradeAddress[1],\n            msg.sender,\n            _attributes[1]\n        );\n        emit BuyNFTNormal(\n            [msg.sender, _tradeAddress[1], _tradeAddress[2]],\n            _attributes[1],\n            _attributes[0]\n        );\n    }","contract":"ExchangeNFT","time":0},{"type":"external-function ","before":"function buyNFTETH(\n        address[4] memory _tradeAddress,\n        uint256[3] memory _attributes,\n        uint256 nonce,\n        bytes memory signature\n    )\n        external\n        payable\n        verifySignature(nonce, _tradeAddress, _attributes, signature)\n    {\n        (uint256 amount, uint256 feeProduct) = checkFeeProductExits(\n            _tradeAddress[3],\n            _attributes\n        );\n        // transfer token to fee address\n        if (feeProduct != 0) {\n            TransferHelper.safeTransferETH(_tradeAddress[3], feeProduct);\n        }\n        TransferHelper.safeTransferETH(_tradeAddress[1], amount);\n\n        IERC721(ERC721).safeTransferFrom(\n            _tradeAddress[1],\n            msg.sender,\n            _attributes[1]\n        );\n        // refund dust eth, if any\n        if (msg.value > _attributes[0])\n            TransferHelper.safeTransferETH(\n                msg.sender,\n                msg.value - _attributes[0]\n            );\n        emit BuyNFTETH(\n            [msg.sender, _tradeAddress[1], _tradeAddress[2]],\n            _attributes[1],\n            _attributes[0]\n        );\n    }","after":"function buyNFTETH(\n        address[4] calldata _tradeAddress,\n        uint256[3] calldata _attributes,\n        uint256 nonce,\n        bytes calldata signature\n    )\n        external\n        payable\n        verifySignature(nonce, _tradeAddress, _attributes, signature)\n    {\n        (uint256 amount, uint256 feeProduct) = checkFeeProductExits(\n            _tradeAddress[3],\n            _attributes\n        );\n        // transfer token to fee address\n        if (feeProduct != 0) {\n            TransferHelper.safeTransferETH(_tradeAddress[3], feeProduct);\n        }\n        TransferHelper.safeTransferETH(_tradeAddress[1], amount);\n\n        IERC721(ERC721).safeTransferFrom(\n            _tradeAddress[1],\n            msg.sender,\n            _attributes[1]\n        );\n        // refund dust eth, if any\n        if (msg.value > _attributes[0])\n            TransferHelper.safeTransferETH(\n                msg.sender,\n                msg.value - _attributes[0]\n            );\n        emit BuyNFTETH(\n            [msg.sender, _tradeAddress[1], _tradeAddress[2]],\n            _attributes[1],\n            _attributes[0]\n        );\n    }","contract":"ExchangeNFT","time":0},{"type":"external-function ","before":"function auctionNFT(\n        address[4] memory _tradeAddress,\n        uint256[3] memory _attributes\n    ) external {\n        // Check address execute auction\n        require(\n            whitelistAddress[msg.sender] == true,\n            \"Address is not in whitelist\"\n        );\n        // check allowance of buyer\n        require(\n            IERC20(_tradeAddress[2]).allowance(\n                _tradeAddress[0],\n                address(this)\n            ) >= _attributes[0],\n            \"token allowance too low\"\n        );\n        if (_tradeAddress[1] == admin) {\n            require(\n                IERC721(ERC721).isApprovedForAll(admin, address(this)),\n                \"tokenId do not approve for contract\"\n            );\n        } else {\n            require(\n                IERC721(ERC721).getApproved(_attributes[1]) == address(this),\n                \"tokenId do not approve for contract\"\n            );\n        }\n\n        (uint256 amount, uint256 feeProduct) = checkFeeProductExits(\n            _tradeAddress[3],\n            _attributes\n        );\n        if (feeProduct != 0) {\n            // transfer token to fee address\n            ERC20(_tradeAddress[2]).safeTransferFrom(\n                _tradeAddress[0],\n                _tradeAddress[3],\n                feeProduct\n            );\n        }\n\n        // transfer token from buyer to seller\n        ERC20(_tradeAddress[2]).safeTransferFrom(\n            _tradeAddress[0],\n            _tradeAddress[1],\n            amount\n        );\n        IERC721(ERC721).safeTransferFrom(\n            _tradeAddress[1],\n            _tradeAddress[0],\n            _attributes[1]\n        );\n        emit AuctionNFT(\n            [msg.sender, _tradeAddress[1], _tradeAddress[2]],\n            _attributes[1],\n            _attributes[0]\n        );\n    }","after":"function auctionNFT(\n        address[4] calldata _tradeAddress,\n        uint256[3] calldata _attributes\n    ) external {\n        // Check address execute auction\n        require(\n            whitelistAddress[msg.sender] == true,\n            \"Address is not in whitelist\"\n        );\n        // check allowance of buyer\n        require(\n            IERC20(_tradeAddress[2]).allowance(\n                _tradeAddress[0],\n                address(this)\n            ) >= _attributes[0],\n            \"token allowance too low\"\n        );\n        if (_tradeAddress[1] == admin) {\n            require(\n                IERC721(ERC721).isApprovedForAll(admin, address(this)),\n                \"tokenId do not approve for contract\"\n            );\n        } else {\n            require(\n                IERC721(ERC721).getApproved(_attributes[1]) == address(this),\n                \"tokenId do not approve for contract\"\n            );\n        }\n\n        (uint256 amount, uint256 feeProduct) = checkFeeProductExits(\n            _tradeAddress[3],\n            _attributes\n        );\n        if (feeProduct != 0) {\n            // transfer token to fee address\n            ERC20(_tradeAddress[2]).safeTransferFrom(\n                _tradeAddress[0],\n                _tradeAddress[3],\n                feeProduct\n            );\n        }\n\n        // transfer token from buyer to seller\n        ERC20(_tradeAddress[2]).safeTransferFrom(\n            _tradeAddress[0],\n            _tradeAddress[1],\n            amount\n        );\n        IERC721(ERC721).safeTransferFrom(\n            _tradeAddress[1],\n            _tradeAddress[0],\n            _attributes[1]\n        );\n        emit AuctionNFT(\n            [msg.sender, _tradeAddress[1], _tradeAddress[2]],\n            _attributes[1],\n            _attributes[0]\n        );\n    }","contract":"ExchangeNFT","time":0},{"type":"external-function ","before":"function acceptOfferNFT(\n        address[4] memory _tradeAddress,\n        uint256[3] memory _attributes,\n        uint256 nonce,\n        bytes memory signature\n    ) external verifySignature(nonce, _tradeAddress, _attributes, signature) {\n        require(\n            IERC721(ERC721).getApproved(_attributes[1]) == address(this),\n            \"tokenId do not approve for contract\"\n        );\n        // check allowance of buyer\n        require(\n            IERC20(_tradeAddress[2]).allowance(\n                _tradeAddress[0],\n                address(this)\n            ) >= _attributes[0],\n            \"token allowance too low\"\n        );\n\n        (uint256 amount, uint256 feeProduct) = checkFeeProductExits(\n            _tradeAddress[3],\n            _attributes\n        );\n        if (feeProduct != 0) {\n            // transfer token to fee address\n            ERC20(_tradeAddress[2]).safeTransferFrom(\n                _tradeAddress[0],\n                _tradeAddress[3],\n                feeProduct\n            );\n        }\n\n        // transfer token from buyer to seller\n        ERC20(_tradeAddress[2]).safeTransferFrom(\n            _tradeAddress[0],\n            msg.sender,\n            amount\n        );\n\n        IERC721(ERC721).safeTransferFrom(\n            _tradeAddress[1],\n            _tradeAddress[0],\n            _attributes[1]\n        );\n        emit AcceptOfferNFT(\n            [msg.sender, _tradeAddress[1], _tradeAddress[2]],\n            _attributes[1],\n            _attributes[0]\n        );\n    }","after":"function acceptOfferNFT(\n        address[4] calldata _tradeAddress,\n        uint256[3] calldata _attributes,\n        uint256 nonce,\n        bytes calldata signature\n    ) external verifySignature(nonce, _tradeAddress, _attributes, signature) {\n        require(\n            IERC721(ERC721).getApproved(_attributes[1]) == address(this),\n            \"tokenId do not approve for contract\"\n        );\n        // check allowance of buyer\n        require(\n            IERC20(_tradeAddress[2]).allowance(\n                _tradeAddress[0],\n                address(this)\n            ) >= _attributes[0],\n            \"token allowance too low\"\n        );\n\n        (uint256 amount, uint256 feeProduct) = checkFeeProductExits(\n            _tradeAddress[3],\n            _attributes\n        );\n        if (feeProduct != 0) {\n            // transfer token to fee address\n            ERC20(_tradeAddress[2]).safeTransferFrom(\n                _tradeAddress[0],\n                _tradeAddress[3],\n                feeProduct\n            );\n        }\n\n        // transfer token from buyer to seller\n        ERC20(_tradeAddress[2]).safeTransferFrom(\n            _tradeAddress[0],\n            msg.sender,\n            amount\n        );\n\n        IERC721(ERC721).safeTransferFrom(\n            _tradeAddress[1],\n            _tradeAddress[0],\n            _attributes[1]\n        );\n        emit AcceptOfferNFT(\n            [msg.sender, _tradeAddress[1], _tradeAddress[2]],\n            _attributes[1],\n            _attributes[0]\n        );\n    }","contract":"ExchangeNFT","time":0}]}