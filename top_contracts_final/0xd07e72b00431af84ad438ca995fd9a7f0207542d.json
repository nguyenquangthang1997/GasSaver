{"time":451,"results":[{"type":"external-function ","before":"function setBaseTokenURI(string memory _baseTokenURI) external onlyOwner {\n        baseTokenURI = _baseTokenURI;\n        emit BaseTokenURISet(_baseTokenURI);\n    }","after":"function setBaseTokenURI(string calldata _baseTokenURI) external onlyOwner {\n        baseTokenURI = _baseTokenURI;\n        emit BaseTokenURISet(_baseTokenURI);\n    }","contract":"TestHashes","time":0},{"type":"external-function ","before":"function deactivateTokens(address _tokenOwner, uint256 _proposalId, bytes memory _signature) external override nonReentrant onlyOwner returns (uint256 deactivationCount) {\n        // Ensure that the token owner has approved the deactivation.\n        require(lastProposalIds[_tokenOwner] < _proposalId, \"Hashes: can't re-use an old proposal ID.\");\n        lastProposalIds[_tokenOwner] = _proposalId;\n        bytes32 eip712DomainHash = LibEIP712.hashEIP712Domain(name(), version, getChainId(), address(this));\n        bytes32 deactivateHash =\n            LibDeactivateToken.getDeactivateTokenHash(\n                LibDeactivateToken.DeactivateToken({ proposalId: _proposalId }),\n                eip712DomainHash\n            );\n        require(LibSignature.getSignerOfHash(deactivateHash, _signature) == _tokenOwner, \"Hashes: The token owner must approve the deactivation.\");\n\n        // Deactivate as many tokens as possible.\n        for (uint256 i = 0; i < balanceOf(_tokenOwner); i++) {\n            uint256 tokenId = tokenOfOwnerByIndex(_tokenOwner, i);\n            if (tokenId >= reservedAmount && tokenId < governanceCap && !deactivated[tokenId]) {\n                deactivated[tokenId] = true;\n                deactivationCount++;\n\n                // Emit a deactivation event.\n                emit Deactivated(_tokenOwner, tokenId, _proposalId);\n            }\n        }\n\n        // Decrease the voter's governance power.\n        _moveDelegates(_tokenOwner, address(0), deactivationCount);\n\n        return deactivationCount;\n    }","after":"function deactivateTokens(address _tokenOwner, uint256 _proposalId, bytes calldata _signature) external override nonReentrant onlyOwner returns (uint256 deactivationCount) {\n        // Ensure that the token owner has approved the deactivation.\n        require(lastProposalIds[_tokenOwner] < _proposalId, \"Hashes: can't re-use an old proposal ID.\");\n        lastProposalIds[_tokenOwner] = _proposalId;\n        bytes32 eip712DomainHash = LibEIP712.hashEIP712Domain(name(), version, getChainId(), address(this));\n        bytes32 deactivateHash =\n            LibDeactivateToken.getDeactivateTokenHash(\n                LibDeactivateToken.DeactivateToken({ proposalId: _proposalId }),\n                eip712DomainHash\n            );\n        require(LibSignature.getSignerOfHash(deactivateHash, _signature) == _tokenOwner, \"Hashes: The token owner must approve the deactivation.\");\n\n        // Deactivate as many tokens as possible.\n        for (uint256 i = 0; i < balanceOf(_tokenOwner); i++) {\n            uint256 tokenId = tokenOfOwnerByIndex(_tokenOwner, i);\n            if (tokenId >= reservedAmount && tokenId < governanceCap && !deactivated[tokenId]) {\n                deactivated[tokenId] = true;\n                deactivationCount++;\n\n                // Emit a deactivation event.\n                emit Deactivated(_tokenOwner, tokenId, _proposalId);\n            }\n        }\n\n        // Decrease the voter's governance power.\n        _moveDelegates(_tokenOwner, address(0), deactivationCount);\n\n        return deactivationCount;\n    }","contract":"TestHashes","time":0},{"type":"external-function ","before":"function generate(string memory _phrase) external nonReentrant payable {\n        // Ensure that the hash can be generated.\n        require(bytes(_phrase).length > 0, \"Hashes: Can't generate hash with the empty string.\");\n\n        // Ensure token minter is passing in a sufficient minting fee.\n        require(msg.value >= mintFee, \"Hashes: Must pass sufficient mint fee.\");\n\n        // Compute and save the hash\n        nonceToHash[nonce] = keccak256(abi.encodePacked(nonce, _msgSender(), _phrase));\n\n        // Mint the token\n        _safeMint(_msgSender(), nonce++);\n\n        uint256 mintFeePaid;\n        if (mintFee > 0) {\n            // If the minting fee is non-zero\n\n            // Send the fee to HashesDAO.\n            (bool sent,) = owner().call{value: mintFee}(\"\");\n            require(sent, \"Hashes: failed to send ETH to HashesDAO\");\n\n            // Set the mintFeePaid to the current minting fee\n            mintFeePaid = mintFee;\n        }\n\n        if (msg.value > mintFeePaid) {\n            // If minter passed ETH value greater than the minting\n            // fee paid/computed above\n\n            // Refund the remaining ether balance to the sender. Since there are no\n            // other payable functions, this remainder will always be the senders.\n            (bool sent,) = _msgSender().call{value: msg.value - mintFeePaid}(\"\");\n            require(sent, \"Hashes: failed to refund ETH.\");\n        }\n\n        if (nonce == governanceCap) {\n            // Set mint fee to 0 now that governance cap has been hit.\n            // The minting fee can only be increased from here via\n            // governance.\n            mintFee = 0;\n        }\n\n        emit Generated(_msgSender(), nonce - 1, _phrase);\n    }","after":"function generate(string calldata _phrase) external nonReentrant payable {\n        // Ensure that the hash can be generated.\n        require(bytes(_phrase).length > 0, \"Hashes: Can't generate hash with the empty string.\");\n\n        // Ensure token minter is passing in a sufficient minting fee.\n        require(msg.value >= mintFee, \"Hashes: Must pass sufficient mint fee.\");\n\n        // Compute and save the hash\n        nonceToHash[nonce] = keccak256(abi.encodePacked(nonce, _msgSender(), _phrase));\n\n        // Mint the token\n        _safeMint(_msgSender(), nonce++);\n\n        uint256 mintFeePaid;\n        if (mintFee > 0) {\n            // If the minting fee is non-zero\n\n            // Send the fee to HashesDAO.\n            (bool sent,) = owner().call{value: mintFee}(\"\");\n            require(sent, \"Hashes: failed to send ETH to HashesDAO\");\n\n            // Set the mintFeePaid to the current minting fee\n            mintFeePaid = mintFee;\n        }\n\n        if (msg.value > mintFeePaid) {\n            // If minter passed ETH value greater than the minting\n            // fee paid/computed above\n\n            // Refund the remaining ether balance to the sender. Since there are no\n            // other payable functions, this remainder will always be the senders.\n            (bool sent,) = _msgSender().call{value: msg.value - mintFeePaid}(\"\");\n            require(sent, \"Hashes: failed to refund ETH.\");\n        }\n\n        if (nonce == governanceCap) {\n            // Set mint fee to 0 now that governance cap has been hit.\n            // The minting fee can only be increased from here via\n            // governance.\n            mintFee = 0;\n        }\n\n        emit Generated(_msgSender(), nonce - 1, _phrase);\n    }","contract":"TestHashes","time":0},{"type":"external-function ","before":"function redeem(uint256 _tokenId, string memory _phrase) external nonReentrant {\n        // Ensure redeemer is the token owner.\n        require(_msgSender() == ownerOf(_tokenId), \"Hashes: must be owner.\");\n\n        // Ensure that redeemed token is a reserved token.\n        require(_tokenId < reservedAmount, \"Hashes: must be a reserved token.\");\n\n        // Ensure the token hasn't been redeemed before.\n        require(!redeemed[_tokenId], \"Hashes: already redeemed.\");\n\n        // Mark the token as redeemed.\n        redeemed[_tokenId] = true;\n\n        // Update the hash.\n        nonceToHash[_tokenId] = keccak256(abi.encodePacked(_tokenId, _msgSender(), _phrase));\n\n        emit Redeemed(_msgSender(), _tokenId, _phrase);\n    }","after":"function redeem(uint256 _tokenId, string calldata _phrase) external nonReentrant {\n        // Ensure redeemer is the token owner.\n        require(_msgSender() == ownerOf(_tokenId), \"Hashes: must be owner.\");\n\n        // Ensure that redeemed token is a reserved token.\n        require(_tokenId < reservedAmount, \"Hashes: must be a reserved token.\");\n\n        // Ensure the token hasn't been redeemed before.\n        require(!redeemed[_tokenId], \"Hashes: already redeemed.\");\n\n        // Mark the token as redeemed.\n        redeemed[_tokenId] = true;\n\n        // Update the hash.\n        nonceToHash[_tokenId] = keccak256(abi.encodePacked(_tokenId, _msgSender(), _phrase));\n\n        emit Redeemed(_msgSender(), _tokenId, _phrase);\n    }","contract":"TestHashes","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public reservedAmount;","after":"uint256 public immutable reservedAmount;","contract":"TestHashes","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public governanceCap;","after":"uint256 public immutable governanceCap;","contract":"TestHashes","time":1},{"type":"external-function ","before":"   function propose(\n        address[] memory _targets,\n        uint256[] memory _values,\n        string[] memory _signatures,\n        bytes[] memory _calldatas,\n        string memory _description\n    ) external returns (uint128) {\n        // Ensure proposer has sufficient token holdings to propose\n        require(\n            hashesToken.getPriorVotes(msg.sender, block.number.sub(1)) >= proposalThreshold,\n            \"HashesDAO: proposer votes below proposal threshold.\"\n        );\n        require(\n            _targets.length == _values.length &&\n            _targets.length == _signatures.length &&\n            _targets.length == _calldatas.length,\n            \"HashesDAO: proposal function information parity mismatch.\"\n        );\n        require(_targets.length != 0, \"HashesDAO: must provide actions.\");\n        require(_targets.length <= proposalMaxOperations, \"HashesDAO: too many actions.\");\n\n        if (latestProposalIds[msg.sender] != 0) {\n            // Ensure proposer doesn't already have one active/pending\n            ProposalState proposersLatestProposalState =\n                state(latestProposalIds[msg.sender]);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                \"HashesDAO: one live proposal per proposer, found an already active proposal.\"\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                \"HashesDAO: one live proposal per proposer, found an already pending proposal.\"\n            );\n        }\n\n        // Proposal voting starts votingDelay after proposal is made\n        uint256 startBlock = block.number.add(votingDelay);\n\n        // Increment count of proposals\n        proposalCount++;\n\n        Proposal storage newProposal = proposals[proposalCount];\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.delay = timelockDelay;\n        newProposal.targets = _targets;\n        newProposal.values = _values;\n        newProposal.signatures = _signatures;\n        newProposal.calldatas = _calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = startBlock.add(votingPeriod);\n\n        // Update proposer's latest proposal\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            _targets,\n            _values,\n            _signatures,\n            _calldatas,\n            startBlock,\n            startBlock.add(votingPeriod),\n            _description\n        );\n        return newProposal.id;\n  ","after":"   function propose(\n        address[] calldata _targets,\n        uint256[] calldata _values,\n        string[] calldata _signatures,\n        bytes[] calldata _calldatas,\n        string calldata _description\n    ) external returns (uint128) {\n        // Ensure proposer has sufficient token holdings to propose\n        require(\n            hashesToken.getPriorVotes(msg.sender, block.number.sub(1)) >= proposalThreshold,\n            \"HashesDAO: proposer votes below proposal threshold.\"\n        );\n        require(\n            _targets.length == _values.length &&\n            _targets.length == _signatures.length &&\n            _targets.length == _calldatas.length,\n            \"HashesDAO: proposal function information parity mismatch.\"\n        );\n        require(_targets.length != 0, \"HashesDAO: must provide actions.\");\n        require(_targets.length <= proposalMaxOperations, \"HashesDAO: too many actions.\");\n\n        if (latestProposalIds[msg.sender] != 0) {\n            // Ensure proposer doesn't already have one active/pending\n            ProposalState proposersLatestProposalState =\n                state(latestProposalIds[msg.sender]);\n            require(\n                proposersLatestProposalState != ProposalState.Active,\n                \"HashesDAO: one live proposal per proposer, found an already active proposal.\"\n            );\n            require(\n                proposersLatestProposalState != ProposalState.Pending,\n                \"HashesDAO: one live proposal per proposer, found an already pending proposal.\"\n            );\n        }\n\n        // Proposal voting starts votingDelay after proposal is made\n        uint256 startBlock = block.number.add(votingDelay);\n\n        // Increment count of proposals\n        proposalCount++;\n\n        Proposal storage newProposal = proposals[proposalCount];\n        newProposal.id = proposalCount;\n        newProposal.proposer = msg.sender;\n        newProposal.delay = timelockDelay;\n        newProposal.targets = _targets;\n        newProposal.values = _values;\n        newProposal.signatures = _signatures;\n        newProposal.calldatas = _calldatas;\n        newProposal.startBlock = startBlock;\n        newProposal.endBlock = startBlock.add(votingPeriod);\n\n        // Update proposer's latest proposal\n        latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            _targets,\n            _values,\n            _signatures,\n            _calldatas,\n            startBlock,\n            startBlock.add(votingPeriod),\n            _description\n        );\n        return newProposal.id;\n  ","contract":"HashesDAO","time":0},{"type":"external-function ","before":"   function castVote(uint128 _proposalId, bool _support, bool _deactivate, bytes memory _deactivateSignature) external {\n        return _castVote(msg.sender, _proposalId, _support, _deactivate, _deactivateSignature);\n  ","after":"   function castVote(uint128 _proposalId, bool _support, bool _deactivate, bytes calldata _deactivateSignature) external {\n        return _castVote(msg.sender, _proposalId, _support, _deactivate, _deactivateSignature);\n  ","contract":"HashesDAO","time":0},{"type":"external-function ","before":"   function castVoteBySig(\n        uint128 _proposalId,\n        bool _support,\n        bool _deactivate,\n        bytes memory _deactivateSignature,\n        bytes memory _signature\n    ) external {\n        // EIP712 hashing logic\n        bytes32 eip712DomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 voteCastHash =\n        LibVoteCast.getVoteCastHash(\n            LibVoteCast.VoteCast({ proposalId: _proposalId, support: _support, deactivate: _deactivate }),\n            eip712DomainHash\n        );\n\n        // Recover the signature and EIP712 hash\n        address recovered = LibSignature.getSignerOfHash(voteCastHash, _signature);\n\n        // Cast the vote and return the result\n        return _castVote(recovered, _proposalId, _support, _deactivate, _deactivateSignature);\n  ","after":"   function castVoteBySig(\n        uint128 _proposalId,\n        bool _support,\n        bool _deactivate,\n        bytes calldata _deactivateSignature,\n        bytes calldata _signature\n    ) external {\n        // EIP712 hashing logic\n        bytes32 eip712DomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 voteCastHash =\n        LibVoteCast.getVoteCastHash(\n            LibVoteCast.VoteCast({ proposalId: _proposalId, support: _support, deactivate: _deactivate }),\n            eip712DomainHash\n        );\n\n        // Recover the signature and EIP712 hash\n        address recovered = LibSignature.getSignerOfHash(voteCastHash, _signature);\n\n        // Cast the vote and return the result\n        return _castVote(recovered, _proposalId, _support, _deactivate, _deactivateSignature);\n  ","contract":"HashesDAO","time":0},{"type":"external-function ","before":"   function veto(uint128 _proposalId, bytes[] memory _signatures) external onlyAuthoritiesActive {\n        ProposalState proposalState = state(_proposalId);\n\n        // Ensure proposal hasn't executed\n        require(proposalState != ProposalState.Executed, \"HashesDAO: cannot cancel executed proposal.\");\n\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Ensure that a sufficient amount of authorities have signed to veto\n        // this proposal.\n        bytes32 eip712DomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 vetoHash =\n            LibVeto.getVetoHash(\n                LibVeto.Veto({ proposalId: _proposalId }),\n                eip712DomainHash\n            );\n        _verifyAuthorityAction(vetoHash, _signatures);\n\n        // Cancel the proposal.\n        proposal.canceled = true;\n\n        // Loop through each of the proposal's actions\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            bytes32 txHash =\n            keccak256(\n                abi.encode(\n                    proposal.targets[i],\n                    proposal.values[i],\n                    proposal.signatures[i],\n                    proposal.calldatas[i],\n                    proposal.eta\n                )\n            );\n            queuedTransactions[txHash] = false;\n            emit CancelTransaction(\n                txHash,\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalVetoed(_proposalId, _signatures.length);\n  ","after":"   function veto(uint128 _proposalId, bytes[] calldata _signatures) external onlyAuthoritiesActive {\n        ProposalState proposalState = state(_proposalId);\n\n        // Ensure proposal hasn't executed\n        require(proposalState != ProposalState.Executed, \"HashesDAO: cannot cancel executed proposal.\");\n\n        Proposal storage proposal = proposals[_proposalId];\n\n        // Ensure that a sufficient amount of authorities have signed to veto\n        // this proposal.\n        bytes32 eip712DomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 vetoHash =\n            LibVeto.getVetoHash(\n                LibVeto.Veto({ proposalId: _proposalId }),\n                eip712DomainHash\n            );\n        _verifyAuthorityAction(vetoHash, _signatures);\n\n        // Cancel the proposal.\n        proposal.canceled = true;\n\n        // Loop through each of the proposal's actions\n        for (uint256 i = 0; i < proposal.targets.length; i++) {\n            bytes32 txHash =\n            keccak256(\n                abi.encode(\n                    proposal.targets[i],\n                    proposal.values[i],\n                    proposal.signatures[i],\n                    proposal.calldatas[i],\n                    proposal.eta\n                )\n            );\n            queuedTransactions[txHash] = false;\n            emit CancelTransaction(\n                txHash,\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                proposal.eta\n            );\n        }\n\n        emit ProposalVetoed(_proposalId, _signatures.length);\n  ","contract":"HashesDAO","time":0},{"type":"external-function ","before":"   function deactivateAuthorities(bytes[] memory _signatures, address[] memory _authorities) external onlyAuthoritiesActive {\n        // Ensure that a sufficient amount of authorities have signed to\n        // deactivate the authority system.\n        bytes32 eip712DomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 deactivateHash =\n            LibDeactivateAuthority.getDeactivateAuthorityHash(\n                LibDeactivateAuthority.DeactivateAuthority({ support: true }),\n                eip712DomainHash\n            );\n        _verifyAuthorityAction(deactivateHash, _signatures);\n\n        // Deactivate the authority system.\n        authoritiesActive = false;\n        quorumAuthorities = 0;\n        for (uint256 i = 0; i < _authorities.length; i++) {\n            authorities[_authorities[i]] = false;\n        }\n\n        emit AuthoritiesDeactivated();\n  ","after":"   function deactivateAuthorities(bytes[] calldata _signatures, address[] calldata _authorities) external onlyAuthoritiesActive {\n        // Ensure that a sufficient amount of authorities have signed to\n        // deactivate the authority system.\n        bytes32 eip712DomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 deactivateHash =\n            LibDeactivateAuthority.getDeactivateAuthorityHash(\n                LibDeactivateAuthority.DeactivateAuthority({ support: true }),\n                eip712DomainHash\n            );\n        _verifyAuthorityAction(deactivateHash, _signatures);\n\n        // Deactivate the authority system.\n        authoritiesActive = false;\n        quorumAuthorities = 0;\n        for (uint256 i = 0; i < _authorities.length; i++) {\n            authorities[_authorities[i]] = false;\n        }\n\n        emit AuthoritiesDeactivated();\n  ","contract":"HashesDAO","time":0}]}