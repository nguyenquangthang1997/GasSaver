{"time":69,"results":[{"type":"external-function ","before":"function newEmpire(string memory _name, string memory _motto) public {\n    require(empires[msg.sender].exists == false, \"Only one empire per wallet.\");\n    require(ethereanContract.balanceOf(msg.sender) >= ETHEREAN_MIN, \"Did not meet minimum ethereans requirement.\");\n    empires[msg.sender] = Empire(_name, _motto, true);\n    empireAddresses.push(msg.sender);\n    emit EmpireCreated(msg.sender, _name, _motto);\n}","after":"function newEmpire(string calldata _name, string calldata _motto) public {\n    require(empires[msg.sender].exists == false, \"Only one empire per wallet.\");\n    require(ethereanContract.balanceOf(msg.sender) >= ETHEREAN_MIN, \"Did not meet minimum ethereans requirement.\");\n    empires[msg.sender] = Empire(_name, _motto, true);\n    empireAddresses.push(msg.sender);\n    emit EmpireCreated(msg.sender, _name, _motto);\n}","contract":"EthereanEmpire","time":0},{"type":"external-function ","before":"function newDrop(uint _tokenId, string memory _title, string memory _description, string memory _artist, uint _cost, uint _supply, uint _end) external onlyOwner() {\n    require(_tokenId >= 0, \"Must supply a tokenId\");\n    require(_supply > 0, \"Supply must be greater than 1.\");\n    require(block.timestamp < _end, \"End date must be set in the future\");\n    numDrops = numDrops.add(1);\n    drops[numDrops] = Drop(_tokenId, _title, _description, _artist, _cost, _supply, _end, true, 0);\n    emit DropCreated(_tokenId, _title, _description, _artist, _cost, _supply, _end);\n}","after":"function newDrop(uint _tokenId, string calldata _title, string calldata _description, string calldata _artist, uint _cost, uint _supply, uint _end) external onlyOwner() {\n    require(_tokenId >= 0, \"Must supply a tokenId\");\n    require(_supply > 0, \"Supply must be greater than 1.\");\n    require(block.timestamp < _end, \"End date must be set in the future\");\n    numDrops = numDrops.add(1);\n    drops[numDrops] = Drop(_tokenId, _title, _description, _artist, _cost, _supply, _end, true, 0);\n    emit DropCreated(_tokenId, _title, _description, _artist, _cost, _supply, _end);\n}","contract":"EthereanEmpire","time":0},{"type":"external-function ","before":"function customizeEmpire(string memory _newName, string memory _newMotto) external hasEmpire(){\n    invaderContract.burnFrom(msg.sender, EMPIRE_EDIT_FEE);\n    empires[msg.sender].name = _newName;\n    empires[msg.sender].motto = _newMotto;\n    emit EmpireCustomized(msg.sender, _newName, _newMotto);\n}","after":"function customizeEmpire(string calldata _newName, string calldata _newMotto) external hasEmpire(){\n    invaderContract.burnFrom(msg.sender, EMPIRE_EDIT_FEE);\n    empires[msg.sender].name = _newName;\n    empires[msg.sender].motto = _newMotto;\n    emit EmpireCustomized(msg.sender, _newName, _newMotto);\n}","contract":"EthereanEmpire","time":0},{"type":"external-function ","before":"function claimReward(uint[] memory _tokenIds) external hasEmpire() {\n    uint ethereanBalance = ethereanContract.balanceOf(msg.sender);\n    require(ethereanBalance >= ETHEREAN_MIN, \"Did not meet minimum ethereans requirement to claim rewards.\");\n    uint currentTime = min(block.timestamp, END_REWARDS);\n    uint totalElapsedTime;\n    for (uint i=0; i<_tokenIds.length; i++) {\n        uint tokenId = _tokenIds[i];\n        uint lastUpdated = tokenToLastUpdated[tokenId];\n        require(ethereanContract.ownerOf(tokenId) == msg.sender, \"Etherean does not belong to you.\");\n        if (lastUpdated == 0) {\n            tokenToLastUpdated[tokenId] = currentTime;\n        } else if (lastUpdated > 0) {\n            totalElapsedTime += currentTime.sub(lastUpdated);\n            tokenToLastUpdated[tokenId] = currentTime;\n        }\n    }\n    if (totalElapsedTime > 0) {\n        uint multiplier = getMultiplier(ethereanBalance);\n        uint rewardAmount = totalElapsedTime.mul(multiplier).mul(10**18).div(86400);\n        invaderContract.claimReward(msg.sender, rewardAmount);\n        emit RewardClaimed(msg.sender, rewardAmount);\n    }\n}","after":"function claimReward(uint[] calldata _tokenIds) external hasEmpire() {\n    uint ethereanBalance = ethereanContract.balanceOf(msg.sender);\n    require(ethereanBalance >= ETHEREAN_MIN, \"Did not meet minimum ethereans requirement to claim rewards.\");\n    uint currentTime = min(block.timestamp, END_REWARDS);\n    uint totalElapsedTime;\n    for (uint i=0; i<_tokenIds.length; i++) {\n        uint tokenId = _tokenIds[i];\n        uint lastUpdated = tokenToLastUpdated[tokenId];\n        require(ethereanContract.ownerOf(tokenId) == msg.sender, \"Etherean does not belong to you.\");\n        if (lastUpdated == 0) {\n            tokenToLastUpdated[tokenId] = currentTime;\n        } else if (lastUpdated > 0) {\n            totalElapsedTime += currentTime.sub(lastUpdated);\n            tokenToLastUpdated[tokenId] = currentTime;\n        }\n    }\n    if (totalElapsedTime > 0) {\n        uint multiplier = getMultiplier(ethereanBalance);\n        uint rewardAmount = totalElapsedTime.mul(multiplier).mul(10**18).div(86400);\n        invaderContract.claimReward(msg.sender, rewardAmount);\n        emit RewardClaimed(msg.sender, rewardAmount);\n    }\n}","contract":"EthereanEmpire","time":0},{"type":"constant-restrict-modification  ","before":"uint public ETHEREAN_MIN = 3;","after":"uint public constant ETHEREAN_MIN = 3;","contract":"EthereanEmpire","time":0},{"type":"immutable-restrict-modification ","before":"address public INVADER_CONTRACT_ADDRESS;","after":"address public immutable INVADER_CONTRACT_ADDRESS;","contract":"EthereanEmpire","time":0}]}