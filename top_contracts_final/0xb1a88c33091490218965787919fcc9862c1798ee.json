{"time":243,"results":[{"type":"de-morgan-condition ","before":"!_isExcludedFromFee[from] && !_isExcludedFromFee[to]","after":"!(_isExcludedFromFee[from] && _isExcludedFromFee[to])","loc":{"start":{"line":1073,"column":12},"end":{"line":1073,"column":63}},"contract":"StudioShibli","time":0},{"type":"external-function ","before":"function airdropToWallets(address[] memory airdropWallets, uint256[] memory amount) external onlyOwner() {\n        require(airdropWallets.length == amount.length, \"airdropToWallets:: Arrays must be the same length\");\n        removeAllFee();\n        buyOrSellSwitch = TRANSFER;\n        for(uint256 i = 0; i < airdropWallets.length; i++){\n            address wallet = airdropWallets[i];\n            uint256 airdropAmount = amount[i];\n            _tokenTransfer(msg.sender, wallet, airdropAmount);\n        }\n        restoreAllFee();\n    }","after":"function airdropToWallets(address[] calldata airdropWallets, uint256[] calldata amount) external onlyOwner() {\n        require(airdropWallets.length == amount.length, \"airdropToWallets:: Arrays must be the same length\");\n        removeAllFee();\n        buyOrSellSwitch = TRANSFER;\n        for(uint256 i = 0; i < airdropWallets.length; i++){\n            address wallet = airdropWallets[i];\n            uint256 airdropAmount = amount[i];\n            _tokenTransfer(msg.sender, wallet, airdropAmount);\n        }\n        restoreAllFee();\n    }","contract":"StudioShibli","time":0},{"type":"external-function ","before":"function launch(address[] memory airdropWallets) external onlyOwner {\n        require(!tradingActive, \"Trading is already active, cannot relaunch.\");\n        require(airdropWallets.length < 200, \"Can only airdrop 200 wallets per txn due to gas limits\"); // allows for airdrop + launch at the same exact time, reducing delays and reducing sniper input.\n        \n        // airdrop all private sale\n        removeAllFee();\n        buyOrSellSwitch = TRANSFER;\n        for(uint256 i = 0; i < airdropWallets.length; i++){\n            address wallet = airdropWallets[i];\n            uint256 amount = _tTotal * 5 / 1000; // each wallet gets 0.5%\n            _isAirdoppedWallet[wallet] = true;\n            _airDroppedTokenAmount[wallet] = amount;\n            _airDropTokensRemaining[wallet] = amount;\n            _airDropAddressNextSellDate[wallet] = block.timestamp.sub(1);\n            _tokenTransfer(msg.sender, wallet, amount);\n        }\n        \n        // send remainder of tokens to the contract\n        _tokenTransfer(msg.sender, address(this), balanceOf(msg.sender));\n                \n        // set liquidity pair and router\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        excludeFromMaxTransaction(address(_uniswapV2Router), true);\n        uniswapV2Router = _uniswapV2Router;\n        _approve(address(this), address(uniswapV2Router), balanceOf(address(this)));\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n        excludeFromMaxTransaction(address(uniswapV2Pair), true);\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\n        \n        // add liquidity\n        require(address(this).balance > 0, \"Must have ETH on contract to launch\");\n        liquidityAddress = payable(msg.sender); // send initial liquidity to owner to ensure project is functioning before burning / locking LP.\n        addLiquidity(balanceOf(address(this)), address(this).balance);\n        \n        // all new liquidity goes to the dead address\n        liquidityAddress = payable(address(0xdead));\n        restoreAllFee();\n        // enable trading\n        enableTrading();\n    }","after":"function launch(address[] calldata airdropWallets) external onlyOwner {\n        require(!tradingActive, \"Trading is already active, cannot relaunch.\");\n        require(airdropWallets.length < 200, \"Can only airdrop 200 wallets per txn due to gas limits\"); // allows for airdrop + launch at the same exact time, reducing delays and reducing sniper input.\n        \n        // airdrop all private sale\n        removeAllFee();\n        buyOrSellSwitch = TRANSFER;\n        for(uint256 i = 0; i < airdropWallets.length; i++){\n            address wallet = airdropWallets[i];\n            uint256 amount = _tTotal * 5 / 1000; // each wallet gets 0.5%\n            _isAirdoppedWallet[wallet] = true;\n            _airDroppedTokenAmount[wallet] = amount;\n            _airDropTokensRemaining[wallet] = amount;\n            _airDropAddressNextSellDate[wallet] = block.timestamp.sub(1);\n            _tokenTransfer(msg.sender, wallet, amount);\n        }\n        \n        // send remainder of tokens to the contract\n        _tokenTransfer(msg.sender, address(this), balanceOf(msg.sender));\n                \n        // set liquidity pair and router\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\n        excludeFromMaxTransaction(address(_uniswapV2Router), true);\n        uniswapV2Router = _uniswapV2Router;\n        _approve(address(this), address(uniswapV2Router), balanceOf(address(this)));\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory()).createPair(address(this), _uniswapV2Router.WETH());\n        excludeFromMaxTransaction(address(uniswapV2Pair), true);\n        _setAutomatedMarketMakerPair(address(uniswapV2Pair), true);\n        \n        // add liquidity\n        require(address(this).balance > 0, \"Must have ETH on contract to launch\");\n        liquidityAddress = payable(msg.sender); // send initial liquidity to owner to ensure project is functioning before burning / locking LP.\n        addLiquidity(balanceOf(address(this)), address(this).balance);\n        \n        // all new liquidity goes to the dead address\n        liquidityAddress = payable(address(0xdead));\n        restoreAllFee();\n        // enable trading\n        enableTrading();\n    }","contract":"StudioShibli","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public liquidityActiveBlock = 0;","after":"uint256 public constant liquidityActiveBlock = 0;","contract":"StudioShibli","time":1},{"type":"constant-restrict-modification  ","before":"bool public swapEnabled = false;","after":"bool public constant swapEnabled = false;","contract":"StudioShibli","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public airDropLimitLiftDate;","after":"uint256 public immutable airDropLimitLiftDate;","contract":"StudioShibli","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public airDropDailySellPerc;","after":"uint256 public immutable airDropDailySellPerc;","contract":"StudioShibli","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public minimumTokensBeforeSwap = _tTotal * 5 / 10000;","after":"uint256 public constant minimumTokensBeforeSwap = _tTotal * 5 / 10000;","contract":"StudioShibli","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public maxTransactionAmount;","after":"uint256 public immutable maxTransactionAmount;","contract":"StudioShibli","time":1}]}