{"time":101,"results":[{"type":"external-function ","before":"}.\n\t */\n\tfunction deposit(\n\t\tuint256 toChain,\n\t\taddress token,\n\t\taddress toWallet,\n\t\tuint256 amount,\n\t\tbytes memory bridgeSig,\n\t\tuint256 sigExpire\n\t)\n\t\texternal\n\t\tpayable\n\t\toverride\n\t\tuseSignature(bridgeSig, sigExpire)\n\t\twhenNotPaused\n\t{\n\t\trequire(!tokenPaused[token], \"token is paused\");\n\t\trequire(tokenSigners[token] != address(0), \"token not registered\");\n\n\t\t// check signature\n\t\tbytes32 messageHash =\n\t\t\tkeccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\taddress(this),\n\t\t\t\t\ttoChain,\n\t\t\t\t\ttoken,\n\t\t\t\t\ttoWallet,\n\t\t\t\t\tamount,\n\t\t\t\t\tmsg.value,\n\t\t\t\t\tsigExpire\n\t\t\t\t)\n\t\t\t);\n\t\tbytes32 ethHash = messageHash.toEthSignedMessageHash();\n\t\trequire(\n\t\t\tethHash.recover(bridgeSig) == bridgeSigner,\n\t\t\t\"invalid bridge signature\"\n\t\t);\n\n\t\t// Deposit the amount of token frmo user to the agent contract\n\t\tIERC20(token).safeTransferFrom(_msgSender(), address(this), amount);\n\n\t\t// User pays fee to the bridge\n\t\tif (msg.value > 0) {\n\t\t\ttreasurer.transfer(msg.value);\n\t\t}\n\n\t\temit Deposit(toChain, token, _msgSender(), toWallet, amount, msg.v","after":"}.\n\t */\n\tfunction deposit(\n\t\tuint256 toChain,\n\t\taddress token,\n\t\taddress toWallet,\n\t\tuint256 amount,\n\t\tbytes calldata bridgeSig,\n\t\tuint256 sigExpire\n\t)\n\t\texternal\n\t\tpayable\n\t\toverride\n\t\tuseSignature(bridgeSig, sigExpire)\n\t\twhenNotPaused\n\t{\n\t\trequire(!tokenPaused[token], \"token is paused\");\n\t\trequire(tokenSigners[token] != address(0), \"token not registered\");\n\n\t\t// check signature\n\t\tbytes32 messageHash =\n\t\t\tkeccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\taddress(this),\n\t\t\t\t\ttoChain,\n\t\t\t\t\ttoken,\n\t\t\t\t\ttoWallet,\n\t\t\t\t\tamount,\n\t\t\t\t\tmsg.value,\n\t\t\t\t\tsigExpire\n\t\t\t\t)\n\t\t\t);\n\t\tbytes32 ethHash = messageHash.toEthSignedMessageHash();\n\t\trequire(\n\t\t\tethHash.recover(bridgeSig) == bridgeSigner,\n\t\t\t\"invalid bridge signature\"\n\t\t);\n\n\t\t// Deposit the amount of token frmo user to the agent contract\n\t\tIERC20(token).safeTransferFrom(_msgSender(), address(this), amount);\n\n\t\t// User pays fee to the bridge\n\t\tif (msg.value > 0) {\n\t\t\ttreasurer.transfer(msg.value);\n\t\t}\n\n\t\temit Deposit(toChain, token, _msgSender(), toWallet, amount, msg.v","contract":"ETHBridgeAgent","time":0},{"type":"external-function ","before":"ce\n\t */\n\tfunction claim(\n\t\tbytes32 depositTx,\n\t\taddress token,\n\t\tuint256 amount,\n\t\tbytes memory tokenSig,\n\t\tbytes memory bridgeSig\n\t)\n\t\texternal\n\t\toverride\n\t\tuseSignature(tokenSig, 0)\n\t\tuseSignature(bridgeSig, 0)\n\t\twhenNotPaused\n\t{\n\t\trequire(!tokenPaused[token], \"token is paused\");\n\t\trequire(tokenSigners[token] != address(0), \"token not registered\");\n\n\t\t// check signature\n\t\t{\n\t\t\tbytes32 messageHash =\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encode(\n\t\t\t\t\t\taddress(this),\n\t\t\t\t\t\tdepositTx,\n\t\t\t\t\t\ttoken,\n\t\t\t\t\t\tblock.chainid,\n\t\t\t\t\t\t_msgSender(),\n\t\t\t\t\t\tamount\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tbytes32 ethHash = messageHash.toEthSignedMessageHash();\n\t\t\trequire(\n\t\t\t\tethHash.recover(tokenSig) == tokenSigners[token],\n\t\t\t\t\"invalid token signature\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\tethHash.recover(bridgeSig) == bridgeSigner,\n\t\t\t\t\"invalid bridge signature\"\n\t\t\t);\n\t\t}\n\n\t\t// Transfer the withhold amount of token back to a user\n\t\tIERC20(token).safeTransfer(_msgSender(), amount);\n\n\t\temit Claim(depositTx, token, _msgSender(), am","after":"ce\n\t */\n\tfunction claim(\n\t\tbytes32 depositTx,\n\t\taddress token,\n\t\tuint256 amount,\n\t\tbytes calldata tokenSig,\n\t\tbytes calldata bridgeSig\n\t)\n\t\texternal\n\t\toverride\n\t\tuseSignature(tokenSig, 0)\n\t\tuseSignature(bridgeSig, 0)\n\t\twhenNotPaused\n\t{\n\t\trequire(!tokenPaused[token], \"token is paused\");\n\t\trequire(tokenSigners[token] != address(0), \"token not registered\");\n\n\t\t// check signature\n\t\t{\n\t\t\tbytes32 messageHash =\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encode(\n\t\t\t\t\t\taddress(this),\n\t\t\t\t\t\tdepositTx,\n\t\t\t\t\t\ttoken,\n\t\t\t\t\t\tblock.chainid,\n\t\t\t\t\t\t_msgSender(),\n\t\t\t\t\t\tamount\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\tbytes32 ethHash = messageHash.toEthSignedMessageHash();\n\t\t\trequire(\n\t\t\t\tethHash.recover(tokenSig) == tokenSigners[token],\n\t\t\t\t\"invalid token signature\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\tethHash.recover(bridgeSig) == bridgeSigner,\n\t\t\t\t\"invalid bridge signature\"\n\t\t\t);\n\t\t}\n\n\t\t// Transfer the withhold amount of token back to a user\n\t\tIERC20(token).safeTransfer(_msgSender(), amount);\n\n\t\temit Claim(depositTx, token, _msgSender(), am","contract":"ETHBridgeAgent","time":0},{"type":"external-function ","before":"\n\t */\n\tfunction register(\n\t\taddress token,\n\t\taddress baseToken,\n\t\taddress signer,\n\t\tbytes memory bridgeSig,\n\t\tuint256 sigExpire\n\t) external payable useSignature(bridgeSig, sigExpire) whenNotPaused {\n\t\trequire(token != address(0), \"token is empty\");\n\t\trequire(baseToken != address(0), \"baseToken is empty\");\n\t\trequire(!tokenPaused[token], \"token is paused\");\n\n\t\t// Check signature\n\t\t{\n\t\t\tbytes32 messageHash = keccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\taddress(this),\n\t\t\t\t\t_msgSender(),\n\t\t\t\t\ttoken,\n\t\t\t\t\tbaseToken,\n\t\t\t\t\tsigner,\n\t\t\t\t\tmsg.value,\n\t\t\t\t\tsigExpire\n\t\t\t\t)\n\t\t\t);\n\t\t\tbytes32 ethHash = messageHash.toEthSignedMessageHash();\n\t\t\trequire(\n\t\t\t\tethHash.recover(bridgeSig) == bridgeSigner,\n\t\t\t\t\"invalid bridge signature\"\n\t\t\t);\n\t\t}\n\n\t\ttokenSigners[token] = signer;\n\n\t\t// User pays fee to the bridge\n\t\tif (msg.value > 0) {\n\t\t\ttreasurer.transfer(msg.value);\n\t\t}\n\n\t\temit Register(token, baseToken, sign","after":"\n\t */\n\tfunction register(\n\t\taddress token,\n\t\taddress baseToken,\n\t\taddress signer,\n\t\tbytes calldata bridgeSig,\n\t\tuint256 sigExpire\n\t) external payable useSignature(bridgeSig, sigExpire) whenNotPaused {\n\t\trequire(token != address(0), \"token is empty\");\n\t\trequire(baseToken != address(0), \"baseToken is empty\");\n\t\trequire(!tokenPaused[token], \"token is paused\");\n\n\t\t// Check signature\n\t\t{\n\t\t\tbytes32 messageHash = keccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\taddress(this),\n\t\t\t\t\t_msgSender(),\n\t\t\t\t\ttoken,\n\t\t\t\t\tbaseToken,\n\t\t\t\t\tsigner,\n\t\t\t\t\tmsg.value,\n\t\t\t\t\tsigExpire\n\t\t\t\t)\n\t\t\t);\n\t\t\tbytes32 ethHash = messageHash.toEthSignedMessageHash();\n\t\t\trequire(\n\t\t\t\tethHash.recover(bridgeSig) == bridgeSigner,\n\t\t\t\t\"invalid bridge signature\"\n\t\t\t);\n\t\t}\n\n\t\ttokenSigners[token] = signer;\n\n\t\t// User pays fee to the bridge\n\t\tif (msg.value > 0) {\n\t\t\ttreasurer.transfer(msg.value);\n\t\t}\n\n\t\temit Register(token, baseToken, sign","contract":"ETHBridgeAgent","time":0},{"type":"external-function ","before":"e.\n\t */\n\tfunction migrate(\n\t\taddress token,\n\t\taddress newAgent,\n\t\tbytes memory tokenSig,\n\t\tbytes memory bridgeSig,\n\t\tuint256 sigExpire\n\t)\n\t\texternal\n\t\tuseSignature(tokenSig, sigExpire)\n\t\tuseSignature(bridgeSig, sigExpire)\n\t\twhenNotPaused\n\t{\n\t\trequire(!tokenPaused[token], \"token is paused\");\n\t\trequire(tokenSigners[token] != address(0), \"token not registered\");\n\n\t\t// check signature\n\t\t{\n\t\t\tbytes32 messageHash = keccak256(\n\t\t\t\tabi.encode(address(this), token, newAgent, sigExpire)\n\t\t\t);\n\t\t\tbytes32 ethHash = messageHash.toEthSignedMessageHash();\n\t\t\trequire(\n\t\t\t\tethHash.recover(tokenSig) == tokenSigners[token],\n\t\t\t\t\"invalid token signature\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\tethHash.recover(bridgeSig) == bridgeSigner,\n\t\t\t\t\"invalid bridge signature\"\n\t\t\t);\n\t\t}\n\n\t\t_pauseToken(token);\n\n\t\t// Transfer all the withhold balance of token to the new agent\n\t\tuint256 amount = IERC20(token).balanceOf(address(this));\n\t\tif (amount > 0) {\n\t\t\tIERC20(token).safeTransfer(newAgent, amount);\n\t\t}\n\n\t\temit Migrate(token, newAgent, am","after":"e.\n\t */\n\tfunction migrate(\n\t\taddress token,\n\t\taddress newAgent,\n\t\tbytes calldata tokenSig,\n\t\tbytes calldata bridgeSig,\n\t\tuint256 sigExpire\n\t)\n\t\texternal\n\t\tuseSignature(tokenSig, sigExpire)\n\t\tuseSignature(bridgeSig, sigExpire)\n\t\twhenNotPaused\n\t{\n\t\trequire(!tokenPaused[token], \"token is paused\");\n\t\trequire(tokenSigners[token] != address(0), \"token not registered\");\n\n\t\t// check signature\n\t\t{\n\t\t\tbytes32 messageHash = keccak256(\n\t\t\t\tabi.encode(address(this), token, newAgent, sigExpire)\n\t\t\t);\n\t\t\tbytes32 ethHash = messageHash.toEthSignedMessageHash();\n\t\t\trequire(\n\t\t\t\tethHash.recover(tokenSig) == tokenSigners[token],\n\t\t\t\t\"invalid token signature\"\n\t\t\t);\n\t\t\trequire(\n\t\t\t\tethHash.recover(bridgeSig) == bridgeSigner,\n\t\t\t\t\"invalid bridge signature\"\n\t\t\t);\n\t\t}\n\n\t\t_pauseToken(token);\n\n\t\t// Transfer all the withhold balance of token to the new agent\n\t\tuint256 amount = IERC20(token).balanceOf(address(this));\n\t\tif (amount > 0) {\n\t\t\tIERC20(token).safeTransfer(newAgent, amount);\n\t\t}\n\n\t\temit Migrate(token, newAgent, am","contract":"ETHBridgeAgent","time":0}]}