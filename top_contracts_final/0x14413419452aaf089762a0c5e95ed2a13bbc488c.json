{"time":266,"results":[{"type":"external-function ","before":"function setFromContractWhiteList(address[] memory fromContractWhiteList) public onlyWhiteLister {\n        for (uint i=0;i<fromContractWhiteList.length;i++) {\n            whiteListFromContract[fromContractWhiteList[i]] = true;\n        }\n    }","after":"function setFromContractWhiteList(address[] calldata fromContractWhiteList) public onlyWhiteLister {\n        for (uint i=0;i<fromContractWhiteList.length;i++) {\n            whiteListFromContract[fromContractWhiteList[i]] = true;\n        }\n    }","contract":"EthCrossChainManager","time":0},{"type":"external-function ","before":"function removeFromContractWhiteList(address[] memory fromContractWhiteList) public onlyWhiteLister {\n        for (uint i=0;i<fromContractWhiteList.length;i++) {\n            whiteListFromContract[fromContractWhiteList[i]] = false;\n        }\n    }","after":"function removeFromContractWhiteList(address[] calldata fromContractWhiteList) public onlyWhiteLister {\n        for (uint i=0;i<fromContractWhiteList.length;i++) {\n            whiteListFromContract[fromContractWhiteList[i]] = false;\n        }\n    }","contract":"EthCrossChainManager","time":0},{"type":"external-function ","before":"function setContractMethodWhiteList(bytes[] memory contractMethodWhiteList) public onlyWhiteLister {\n        for (uint i=0;i<contractMethodWhiteList.length;i++) {\n            (address toContract,bytes[] memory methods) = abi.decode(contractMethodWhiteList[i],(address,bytes[]));\n            for (uint j=0;j<methods.length;j++) {\n                whiteListContractMethodMap[toContract][methods[j]] = true;\n            }\n        }\n    }","after":"function setContractMethodWhiteList(bytes[] calldata contractMethodWhiteList) public onlyWhiteLister {\n        for (uint i=0;i<contractMethodWhiteList.length;i++) {\n            (address toContract,bytes[] memory methods) = abi.decode(contractMethodWhiteList[i],(address,bytes[]));\n            for (uint j=0;j<methods.length;j++) {\n                whiteListContractMethodMap[toContract][methods[j]] = true;\n            }\n        }\n    }","contract":"EthCrossChainManager","time":0},{"type":"external-function ","before":"function removeContractMethodWhiteList(bytes[] memory contractMethodWhiteList) public onlyWhiteLister {\n        for (uint i=0;i<contractMethodWhiteList.length;i++) {\n            (address toContract,bytes[] memory methods) = abi.decode(contractMethodWhiteList[i],(address,bytes[]));\n            for (uint j=0;j<methods.length;j++) {\n                whiteListContractMethodMap[toContract][methods[j]] = false;\n            }\n        }\n    }","after":"function removeContractMethodWhiteList(bytes[] calldata contractMethodWhiteList) public onlyWhiteLister {\n        for (uint i=0;i<contractMethodWhiteList.length;i++) {\n            (address toContract,bytes[] memory methods) = abi.decode(contractMethodWhiteList[i],(address,bytes[]));\n            for (uint j=0;j<methods.length;j++) {\n                whiteListContractMethodMap[toContract][methods[j]] = false;\n            }\n        }\n    }","contract":"EthCrossChainManager","time":0},{"type":"external-function ","before":"function initGenesisBlock(bytes memory rawHeader, bytes memory pubKeyList) whenNotPaused public returns(bool) {\n        // Load Ethereum cross chain data contract\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n        \n        // Make sure the contract has not been initialized before\n        require(eccd.getCurEpochConPubKeyBytes().length == 0, \"EthCrossChainData contract has already been initialized!\");\n        \n        // Parse header and convit the public keys into nextBookKeeper and compare it with header.nextBookKeeper to verify the validity of signature\n        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n        (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList);\n        require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n        \n        // Record current epoch start height and public keys (by storing them in address format)\n        require(eccd.putCurEpochStartHeight(header.height), \"Save Poly chain current epoch start height to Data contract failed!\");\n        require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain current epoch book keepers to Data contract failed!\");\n        \n        // Fire the event\n        emit InitGenesisBlockEvent(header.height, rawHeader);\n        return true;\n    }","after":"function initGenesisBlock(bytes calldata rawHeader, bytes calldata pubKeyList) whenNotPaused public returns(bool) {\n        // Load Ethereum cross chain data contract\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n        \n        // Make sure the contract has not been initialized before\n        require(eccd.getCurEpochConPubKeyBytes().length == 0, \"EthCrossChainData contract has already been initialized!\");\n        \n        // Parse header and convit the public keys into nextBookKeeper and compare it with header.nextBookKeeper to verify the validity of signature\n        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n        (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList);\n        require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n        \n        // Record current epoch start height and public keys (by storing them in address format)\n        require(eccd.putCurEpochStartHeight(header.height), \"Save Poly chain current epoch start height to Data contract failed!\");\n        require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain current epoch book keepers to Data contract failed!\");\n        \n        // Fire the event\n        emit InitGenesisBlockEvent(header.height, rawHeader);\n        return true;\n    }","contract":"EthCrossChainManager","time":1},{"type":"external-function ","before":"function changeBookKeeper(bytes memory rawHeader, bytes memory pubKeyList, bytes memory sigList) whenNotPaused public returns(bool) {\n        // Load Ethereum cross chain data contract\n        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n        \n        // Make sure rawHeader.height is higher than recorded current epoch start height\n        uint64 curEpochStartHeight = eccd.getCurEpochStartHeight();\n        require(header.height > curEpochStartHeight, \"The height of header is lower than current epoch start height!\");\n        \n        // Ensure the rawHeader is the key header including info of switching consensus peers by containing non-empty nextBookKeeper field\n        require(header.nextBookkeeper != bytes20(0), \"The nextBookKeeper of header is empty\");\n        \n        // Verify signature of rawHeader comes from pubKeyList\n        address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());\n        uint n = polyChainBKs.length;\n        require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), \"Verify signature failed!\");\n        \n        // Convert pubKeyList into ethereum address format and make sure the compound address from the converted ethereum addresses\n        // equals passed in header.nextBooker\n        (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList);\n        require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n        \n        // update current epoch start height of Poly chain and current epoch consensus peers book keepers addresses\n        require(eccd.putCurEpochStartHeight(header.height), \"Save MC LatestHeight to Data contract failed!\");\n        require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain book keepers bytes to Data contract failed!\");\n        \n        // Fire the change book keeper event\n        emit ChangeBookKeeperEvent(header.height, rawHeader);\n        return true;\n    }","after":"function changeBookKeeper(bytes calldata rawHeader, bytes calldata pubKeyList, bytes calldata sigList) whenNotPaused public returns(bool) {\n        // Load Ethereum cross chain data contract\n        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n        \n        // Make sure rawHeader.height is higher than recorded current epoch start height\n        uint64 curEpochStartHeight = eccd.getCurEpochStartHeight();\n        require(header.height > curEpochStartHeight, \"The height of header is lower than current epoch start height!\");\n        \n        // Ensure the rawHeader is the key header including info of switching consensus peers by containing non-empty nextBookKeeper field\n        require(header.nextBookkeeper != bytes20(0), \"The nextBookKeeper of header is empty\");\n        \n        // Verify signature of rawHeader comes from pubKeyList\n        address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());\n        uint n = polyChainBKs.length;\n        require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), \"Verify signature failed!\");\n        \n        // Convert pubKeyList into ethereum address format and make sure the compound address from the converted ethereum addresses\n        // equals passed in header.nextBooker\n        (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList);\n        require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\n        \n        // update current epoch start height of Poly chain and current epoch consensus peers book keepers addresses\n        require(eccd.putCurEpochStartHeight(header.height), \"Save MC LatestHeight to Data contract failed!\");\n        require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain book keepers bytes to Data contract failed!\");\n        \n        // Fire the change book keeper event\n        emit ChangeBookKeeperEvent(header.height, rawHeader);\n        return true;\n    }","contract":"EthCrossChainManager","time":0},{"type":"external-function ","before":"function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool){\n        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n        // Load ehereum cross chain data contract\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n        \n        // Get stored consensus public key bytes of current poly chain epoch and deserialize Poly chain consensus public key bytes to address[]\n        address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());\n\n        uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();\n\n        uint n = polyChainBKs.length;\n        if (header.height >= curEpochStartHeight) {\n            // It's enough to verify rawHeader signature\n            require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");\n        } else {\n            // We need to verify the signature of curHeader \n            require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");\n\n            // Then use curHeader.StateRoot and headerProof to verify rawHeader.CrossStateRoot\n            ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader);\n            bytes memory proveValue = ECCUtils.merkleProve(headerProof, curHeader.blockRoot);\n            require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");\n        }\n        \n        // Through rawHeader.CrossStatesRoot, the toMerkleValue or cross chain msg can be verified and parsed from proof\n        bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot);\n        \n        // Parse the toMerkleValue struct and make sure the tx has not been processed, then mark this tx as processed\n        ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);\n        require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");\n        require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");\n        \n        // Ethereum ChainId is 2, we need to check the transaction is for Ethereum network\n        require(toMerkleValue.makeTxParam.toChainId == chainId, \"This Tx is not aiming at this network!\");\n        \n        // Obtain the targeting contract, so that Ethereum cross chain manager contract can trigger the executation of cross chain tx on Ethereum side\n        address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract);\n        \n        // only invoke PreWhiteListed Contract and method For Now\n        require(whiteListContractMethodMap[toContract][toMerkleValue.makeTxParam.method],\"Invalid to contract or method\");\n\n        //TODO: check this part to make sure we commit the next line when doing local net UT test\n        require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");\n\n        // Fire the cross chain event denoting the executation of cross chain tx is successful,\n        // and this tx is coming from other public chains to current Ethereum network\n        emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash);\n\n        return true;\n    }","after":"function verifyHeaderAndExecuteTx(bytes calldata proof, bytes calldata rawHeader, bytes calldata headerProof, bytes calldata curRawHeader,bytes calldata headerSig) whenNotPaused public returns (bool){\n        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\n        // Load ehereum cross chain data contract\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\n        \n        // Get stored consensus public key bytes of current poly chain epoch and deserialize Poly chain consensus public key bytes to address[]\n        address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());\n\n        uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();\n\n        uint n = polyChainBKs.length;\n        if (header.height >= curEpochStartHeight) {\n            // It's enough to verify rawHeader signature\n            require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");\n        } else {\n            // We need to verify the signature of curHeader \n            require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");\n\n            // Then use curHeader.StateRoot and headerProof to verify rawHeader.CrossStateRoot\n            ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader);\n            bytes memory proveValue = ECCUtils.merkleProve(headerProof, curHeader.blockRoot);\n            require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");\n        }\n        \n        // Through rawHeader.CrossStatesRoot, the toMerkleValue or cross chain msg can be verified and parsed from proof\n        bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot);\n        \n        // Parse the toMerkleValue struct and make sure the tx has not been processed, then mark this tx as processed\n        ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);\n        require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");\n        require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");\n        \n        // Ethereum ChainId is 2, we need to check the transaction is for Ethereum network\n        require(toMerkleValue.makeTxParam.toChainId == chainId, \"This Tx is not aiming at this network!\");\n        \n        // Obtain the targeting contract, so that Ethereum cross chain manager contract can trigger the executation of cross chain tx on Ethereum side\n        address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract);\n        \n        // only invoke PreWhiteListed Contract and method For Now\n        require(whiteListContractMethodMap[toContract][toMerkleValue.makeTxParam.method],\"Invalid to contract or method\");\n\n        //TODO: check this part to make sure we commit the next line when doing local net UT test\n        require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");\n\n        // Fire the cross chain event denoting the executation of cross chain tx is successful,\n        // and this tx is coming from other public chains to current Ethereum network\n        emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash);\n\n        return true;\n    }","contract":"EthCrossChainManager","time":0}]}