{"time":299,"results":[{"type":"external-function ","before":"function initialize(\r\n        address _tokenContract,\r\n        address[] memory payees,\r\n        uint256[] memory shares_\r\n    )\r\n        public\r\n        initializer\r\n    {\r\n\r\n        __Context_init_unchained();\r\n        __ERC165_init_unchained();\r\n        __AccessControl_init_unchained();\r\n        __AccessControlEnumerable_init_unchained();\r\n\r\n        __PaymentSplitter_init_unchained(payees, shares_);\r\n\r\n        tokenContract = _tokenContract;\r\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\r\n        registry = _msgSender();\r\n        projectTokenNeeded = address(0);\r\n    }","after":"function initialize(\r\n        address _tokenContract,\r\n        address[] calldata payees,\r\n        uint256[] calldata shares_\r\n    )\r\n        public\r\n        initializer\r\n    {\r\n\r\n        __Context_init_unchained();\r\n        __ERC165_init_unchained();\r\n        __AccessControl_init_unchained();\r\n        __AccessControlEnumerable_init_unchained();\r\n\r\n        __PaymentSplitter_init_unchained(payees, shares_);\r\n\r\n        tokenContract = _tokenContract;\r\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\r\n        registry = _msgSender();\r\n        projectTokenNeeded = address(0);\r\n    }","contract":"Minter","time":0},{"type":"external-function ","before":"function signedMint(\r\n        uint256 numberOfTokens,\r\n        uint256 maxPermitted,\r\n        bytes memory signature,\r\n        bytes32 nonce\r\n    )\r\n        public\r\n        payable\r\n    {\r\n\r\n        require(\r\n            IRegistry(registry).getProjectStatus(tokenContract) == IRegistry.ProjectStatus.Whitelist,\r\n            \"Minter: signedMint is not active\"\r\n        );\r\n        require(numberOfTokens <= maxPermitted, \"Minter: numberOfTokens exceeds maxPermitted\");\r\n\r\n        bool signatureIsValid = SignatureCheckerUpgradeable.isValidSignatureNow(\r\n            mintSigner,\r\n            hashTransaction(msg.sender, maxPermitted, nonce, address(this)),\r\n            signature\r\n        );\r\n        require(signatureIsValid, \"Minter: invalid signature\");\r\n        require(!nonces[nonce], \"Minter: nonce already used\");\r\n\r\n        nonces[nonce] = true;\r\n\r\n        sharedMintBehavior(numberOfTokens);\r\n    }","after":"function signedMint(\r\n        uint256 numberOfTokens,\r\n        uint256 maxPermitted,\r\n        bytes calldata signature,\r\n        bytes32 nonce\r\n    )\r\n        public\r\n        payable\r\n    {\r\n\r\n        require(\r\n            IRegistry(registry).getProjectStatus(tokenContract) == IRegistry.ProjectStatus.Whitelist,\r\n            \"Minter: signedMint is not active\"\r\n        );\r\n        require(numberOfTokens <= maxPermitted, \"Minter: numberOfTokens exceeds maxPermitted\");\r\n\r\n        bool signatureIsValid = SignatureCheckerUpgradeable.isValidSignatureNow(\r\n            mintSigner,\r\n            hashTransaction(msg.sender, maxPermitted, nonce, address(this)),\r\n            signature\r\n        );\r\n        require(signatureIsValid, \"Minter: invalid signature\");\r\n        require(!nonces[nonce], \"Minter: nonce already used\");\r\n\r\n        nonces[nonce] = true;\r\n\r\n        sharedMintBehavior(numberOfTokens);\r\n    }","contract":"Minter","time":0}]}