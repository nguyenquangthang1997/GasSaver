{"time":87,"results":[{"type":"external-function ","before":"function stake(uint _pid, uint _amount, bool _type, address _rewardToken, bytes32 _msgForSign, bytes memory _signature) external {\n        require(!_type, \"Signature for withdaw\");\n        require(!positionExists(msg.sender, _pid), \"staked before\");\n         // 1. Check signer\n        address signedBy = _msgForSign.recover(_signature);\n        require(trustedSigner[_rewardToken][signedBy].isValid == true, \"signature check failed\");\n\n        //2. Check signed msg integrety\n        bytes32 actualMsg = getMsgForSign(\n            msg.sender,\n            _pid,\n            _amount,\n            _type,\n            _rewardToken\n        );\n        require(actualMsg.toEthSignedMessageHash() == _msgForSign,\"integrety check failed\");\n       \n\n        IERC20(_rewardToken).safeTransferFrom(msg.sender, trustedSigner[_rewardToken][signedBy].paymentAddress, _amount);\n     \n        //stake\n        userPositions[msg.sender].push(Position({\n            closed: 0,\n            pId: _pid\n        }));\n        emit OpenPosition(msg.sender, _pid);\n        \n    }","after":"function stake(uint _pid, uint _amount, bool _type, address _rewardToken, bytes32 _msgForSign, bytes calldata _signature) external {\n        require(!_type, \"Signature for withdaw\");\n        require(!positionExists(msg.sender, _pid), \"staked before\");\n         // 1. Check signer\n        address signedBy = _msgForSign.recover(_signature);\n        require(trustedSigner[_rewardToken][signedBy].isValid == true, \"signature check failed\");\n\n        //2. Check signed msg integrety\n        bytes32 actualMsg = getMsgForSign(\n            msg.sender,\n            _pid,\n            _amount,\n            _type,\n            _rewardToken\n        );\n        require(actualMsg.toEthSignedMessageHash() == _msgForSign,\"integrety check failed\");\n       \n\n        IERC20(_rewardToken).safeTransferFrom(msg.sender, trustedSigner[_rewardToken][signedBy].paymentAddress, _amount);\n     \n        //stake\n        userPositions[msg.sender].push(Position({\n            closed: 0,\n            pId: _pid\n        }));\n        emit OpenPosition(msg.sender, _pid);\n        \n    }","contract":"AdvancedShadowStaking","time":0},{"type":"external-function ","before":"function withdraw(uint _pid, uint _amount, bool _type, address _rewardToken, bytes32 _msgForSign, bytes memory _signature) external {\n        require(_type == true, \"Signature for stake\");\n        require(getClosedDate(msg.sender, _pid) == 0, \"Already closed\");\n         // 1. Check signer\n        address signedBy = _msgForSign.recover(_signature);\n        require(trustedSigner[_rewardToken][signedBy].isValid == true, \"signature check failed\");\n         //2. Check signed msg integrety\n        bytes32 actualMsg = getMsgForSign(\n            msg.sender,\n            _pid,\n            _amount,\n            _type,\n            _rewardToken\n        );\n        require(actualMsg.toEthSignedMessageHash() == _msgForSign,\"integrety check failed\");\n        userPositions[msg.sender][_getPositionIndexByPid(msg.sender, _pid)].closed = block.timestamp; \n        \n        // withdraw\n        IERC20(_rewardToken).safeTransferFrom(trustedSigner[_rewardToken][signedBy].paymentAddress, msg.sender, _amount);\n        emit ClosePosition(msg.sender, _pid);\n    }","after":"function withdraw(uint _pid, uint _amount, bool _type, address _rewardToken, bytes32 _msgForSign, bytes calldata _signature) external {\n        require(_type == true, \"Signature for stake\");\n        require(getClosedDate(msg.sender, _pid) == 0, \"Already closed\");\n         // 1. Check signer\n        address signedBy = _msgForSign.recover(_signature);\n        require(trustedSigner[_rewardToken][signedBy].isValid == true, \"signature check failed\");\n         //2. Check signed msg integrety\n        bytes32 actualMsg = getMsgForSign(\n            msg.sender,\n            _pid,\n            _amount,\n            _type,\n            _rewardToken\n        );\n        require(actualMsg.toEthSignedMessageHash() == _msgForSign,\"integrety check failed\");\n        userPositions[msg.sender][_getPositionIndexByPid(msg.sender, _pid)].closed = block.timestamp; \n        \n        // withdraw\n        IERC20(_rewardToken).safeTransferFrom(trustedSigner[_rewardToken][signedBy].paymentAddress, msg.sender, _amount);\n        emit ClosePosition(msg.sender, _pid);\n    }","contract":"AdvancedShadowStaking","time":0}]}