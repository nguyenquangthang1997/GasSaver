{"time":173,"results":[{"type":"state-data-arrangement ","before":"\nstring public constant name = \"S16NFT\";\nstring public constant symbol = \"S16NFT\";\nuint256 public constant totalSupply = 4000;\nstring _baseTokenURI = \"https://s16nft.io/\";\nbytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\nbytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\nuint256 internal tokenCap = 160;\nuint256 internal editionCap = 25;\nuint256 public royaltyValue = 60000000000000000;\naddress public royaltyRecipient = 0xAED9A27255a3a177B88E7baa0065B214A5e3786A;\nmapping(uint256 => uint256) public mintedEditionsToken;\nmapping(uint256 => bool) public isNFTMinted;\nmapping(uint256 => string) private _tokenURIs;","after":"string public constant name = \"S16NFT\";\nstring public constant symbol = \"S16NFT\";\nuint256 public constant totalSupply = 4000;\nstring _baseTokenURI = \"https://s16nft.io/\";\nbytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\nuint256 internal tokenCap = 160;\nuint256 internal editionCap = 25;\nuint256 public royaltyValue = 60000000000000000;\nmapping(uint256 => uint256) public mintedEditionsToken;\nmapping(uint256 => bool) public isNFTMinted;\nmapping(uint256 => string) private _tokenURIs;\naddress public royaltyRecipient = 0xAED9A27255a3a177B88E7baa0065B214A5e3786A;\nbytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\n","contract":"S16NFT","time":0},{"type":"external-function ","before":"function setNewBaseURI(string memory baseURI) public {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, _msgSender()),\n            \"Caller is not a admin\"\n        );\n\n        _setURI(baseURI);\n    }","after":"function setNewBaseURI(string calldata baseURI) public {\n        require(\n            hasRole(DEFAULT_ADMIN_ROLE, _msgSender()),\n            \"Caller is not a admin\"\n        );\n\n        _setURI(baseURI);\n    }","contract":"S16NFT","time":0},{"type":"external-function ","before":"function mintEditionsUser(\n        address _to,\n        uint256[] memory tokenIds,\n        uint256[] memory quantity\n    ) external returns (bool) {\n        //this check will ensure only the S16Distributor contract can call this function\n        require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n        require(_to != address(0), \"S16NFT: mint to the zero address\");\n        require(\n            tokenIds.length == quantity.length,\n            \"S16NFT: tokenIds length must be equal to quantity\"\n        );\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                isNFTMinted[tokenIds[i]] == false,\n                \"S16NFT: one or more token already minted\"\n            );\n            require(tokenIds[i] <= tokenCap, \"S16NFT: token cap reached\");\n            require(quantity[i] > 0, \"S16NFT: quantity 0 not allowed\");\n            require(\n                quantity[i] + mintedEditionsToken[tokenIds[i]] <= editionCap,\n                \"S16NFT: quantity exceed limit\"\n            );\n\n            mintedEditionsToken[tokenIds[i]] += quantity[i];\n\n            if (mintedEditionsToken[tokenIds[i]] == editionCap) {\n                isNFTMinted[tokenIds[i]] = true;\n            }\n        }\n        _mintBatch(_to, tokenIds, quantity, \"\");\n\n        return true;\n    }","after":"function mintEditionsUser(\n        address _to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata quantity\n    ) external returns (bool) {\n        //this check will ensure only the S16Distributor contract can call this function\n        require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n        require(_to != address(0), \"S16NFT: mint to the zero address\");\n        require(\n            tokenIds.length == quantity.length,\n            \"S16NFT: tokenIds length must be equal to quantity\"\n        );\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            require(\n                isNFTMinted[tokenIds[i]] == false,\n                \"S16NFT: one or more token already minted\"\n            );\n            require(tokenIds[i] <= tokenCap, \"S16NFT: token cap reached\");\n            require(quantity[i] > 0, \"S16NFT: quantity 0 not allowed\");\n            require(\n                quantity[i] + mintedEditionsToken[tokenIds[i]] <= editionCap,\n                \"S16NFT: quantity exceed limit\"\n            );\n\n            mintedEditionsToken[tokenIds[i]] += quantity[i];\n\n            if (mintedEditionsToken[tokenIds[i]] == editionCap) {\n                isNFTMinted[tokenIds[i]] = true;\n            }\n        }\n        _mintBatch(_to, tokenIds, quantity, \"\");\n\n        return true;\n    }","contract":"S16NFT","time":0},{"type":"external-function ","before":"function updateIdsEdition(\n        uint256[] memory tokenIds,\n        uint256[] memory quantity\n    ) external {\n        require(\n            hasRole(MINTER_ROLE, msg.sender),\n            \"S16NFT: Caller is not a minter\"\n        );\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            mintedEditionsToken[tokenIds[i]] += quantity[i];\n            if (mintedEditionsToken[tokenIds[i]] == editionCap) {\n                isNFTMinted[tokenIds[i]] = true;\n            }\n        }\n    }","after":"function updateIdsEdition(\n        uint256[] calldata tokenIds,\n        uint256[] calldata quantity\n    ) external {\n        require(\n            hasRole(MINTER_ROLE, msg.sender),\n            \"S16NFT: Caller is not a minter\"\n        );\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            mintedEditionsToken[tokenIds[i]] += quantity[i];\n            if (mintedEditionsToken[tokenIds[i]] == editionCap) {\n                isNFTMinted[tokenIds[i]] = true;\n            }\n        }\n    }","contract":"S16NFT","time":0},{"type":"external-function ","before":"function claimNfts(\n        address _to,\n        uint256[] memory tokenIds,\n        uint256[] memory quantity\n    ) external returns (bool) {\n        //this check will ensure only the S16Distributor contract can call this function\n        require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n        require(_to != address(0), \"S16NFT: minting to zero address\");\n        require(\n            tokenIds.length == quantity.length,\n            \"S16NFT: tokenIds and quantity length mismatch\"\n        );\n\n        _mintBatch(_to, tokenIds, quantity, \"\");\n\n        return true;\n    }","after":"function claimNfts(\n        address _to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata quantity\n    ) external returns (bool) {\n        //this check will ensure only the S16Distributor contract can call this function\n        require(hasRole(MINTER_ROLE, msg.sender), \"Caller is not a minter\");\n        require(_to != address(0), \"S16NFT: minting to zero address\");\n        require(\n            tokenIds.length == quantity.length,\n            \"S16NFT: tokenIds and quantity length mismatch\"\n        );\n\n        _mintBatch(_to, tokenIds, quantity, \"\");\n\n        return true;\n    }","contract":"S16NFT","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"S16NFT","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"S16NFT","time":0},{"type":"constant-restrict-modification  ","before":"string _baseTokenURI = \"https://s16nft.io/\";","after":"string constant _baseTokenURI = \"https://s16nft.io/\";","contract":"S16NFT","time":1},{"type":"constant-restrict-modification  ","before":"uint256 internal tokenCap = 160;","after":"uint256 internal constant tokenCap = 160;","contract":"S16NFT","time":1},{"type":"constant-restrict-modification  ","before":"uint256 internal editionCap = 25;","after":"uint256 internal constant editionCap = 25;","contract":"S16NFT","time":1}]}