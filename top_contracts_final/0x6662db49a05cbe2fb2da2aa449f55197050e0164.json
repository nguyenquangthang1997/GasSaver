{"time":220,"results":[{"type":"external-function ","before":"   function settleSpentStake(\n        StakeCommitment[] memory _commitments\n    ) external {\n        uint256 claimableRookToAccrue = 0;\n        uint256 claimableRookToRefund = 0;\n        for (uint i=0; i< _commitments.length; i++) {\n            StakeCommitment memory commitment = _commitments[i];\n            // initiating withdrawal settles the spent stake in the payment channel, so as long as the withdrawal\n            // is initiated using the latest commitment, there's no point in calling this method to settle \n            require(getCurrentWithdrawalTimelock(commitment.stakeAddress) == 0, \"cannot settle while in withdrawal\");\n            require(commitment.stakeSpent <= stakedAmount[commitment.stakeAddress], \"cannot spend more than is staked\");\n            require(commitment.stakeNonce > stakeNonce[commitment.stakeAddress], \"stake nonce is too old\");\n            require(commitment.channelNonce == channelNonce[commitment.stakeAddress], \"incorrect channel nonce\");\n\n            address recoveredStakeAddress = ECDSA.recover(\n                ECDSA.toEthSignedMessageHash(stakeCommitmentHash(commitment)), \n                commitment.stakeAddressSignature);\n            require(recoveredStakeAddress == commitment.stakeAddress, \"recovered address is not the stake address\");\n            address recoveredCoordinatorAddress =  ECDSA.recover(\n                ECDSA.toEthSignedMessageHash(stakeCommitmentHash(commitment)), \n                commitment.coordinatorSignature);\n            require(recoveredCoordinatorAddress == coordinator, \"recovered address is not the coordinator\");\n\n            if (commitment.stakeSpent < stakeSpent[commitment.stakeAddress]) {\n                // if a stake address's new stakeSpent is less than their previously stored stakeSpent, then a refund was \n                // issued to the stakeAddress. we \"refund\" this rook to the stakeAddress by subtracting \n                // the difference from totalClaimableAmount\n                claimableRookToRefund += stakeSpent[commitment.stakeAddress] - commitment.stakeSpent;\n            } else {\n                // otherwise we accrue any unaccounted for spent stake to totalClaimableAmount\n                claimableRookToAccrue += commitment.stakeSpent - stakeSpent[commitment.stakeAddress];\n            }\n            stakeNonce[commitment.stakeAddress] = commitment.stakeNonce;\n            stakeSpent[commitment.stakeAddress] = commitment.stakeSpent;\n        }\n        adjustTotalClaimableAmountByStakeSpentChange(claimableRookToRefund, claimableRookToAccrue);\n  ","after":"   function settleSpentStake(\n        StakeCommitment[] calldata _commitments\n    ) external {\n        uint256 claimableRookToAccrue = 0;\n        uint256 claimableRookToRefund = 0;\n        for (uint i=0; i< _commitments.length; i++) {\n            StakeCommitment memory commitment = _commitments[i];\n            // initiating withdrawal settles the spent stake in the payment channel, so as long as the withdrawal\n            // is initiated using the latest commitment, there's no point in calling this method to settle \n            require(getCurrentWithdrawalTimelock(commitment.stakeAddress) == 0, \"cannot settle while in withdrawal\");\n            require(commitment.stakeSpent <= stakedAmount[commitment.stakeAddress], \"cannot spend more than is staked\");\n            require(commitment.stakeNonce > stakeNonce[commitment.stakeAddress], \"stake nonce is too old\");\n            require(commitment.channelNonce == channelNonce[commitment.stakeAddress], \"incorrect channel nonce\");\n\n            address recoveredStakeAddress = ECDSA.recover(\n                ECDSA.toEthSignedMessageHash(stakeCommitmentHash(commitment)), \n                commitment.stakeAddressSignature);\n            require(recoveredStakeAddress == commitment.stakeAddress, \"recovered address is not the stake address\");\n            address recoveredCoordinatorAddress =  ECDSA.recover(\n                ECDSA.toEthSignedMessageHash(stakeCommitmentHash(commitment)), \n                commitment.coordinatorSignature);\n            require(recoveredCoordinatorAddress == coordinator, \"recovered address is not the coordinator\");\n\n            if (commitment.stakeSpent < stakeSpent[commitment.stakeAddress]) {\n                // if a stake address's new stakeSpent is less than their previously stored stakeSpent, then a refund was \n                // issued to the stakeAddress. we \"refund\" this rook to the stakeAddress by subtracting \n                // the difference from totalClaimableAmount\n                claimableRookToRefund += stakeSpent[commitment.stakeAddress] - commitment.stakeSpent;\n            } else {\n                // otherwise we accrue any unaccounted for spent stake to totalClaimableAmount\n                claimableRookToAccrue += commitment.stakeSpent - stakeSpent[commitment.stakeAddress];\n            }\n            stakeNonce[commitment.stakeAddress] = commitment.stakeNonce;\n            stakeSpent[commitment.stakeAddress] = commitment.stakeSpent;\n        }\n        adjustTotalClaimableAmountByStakeSpentChange(claimableRookToRefund, claimableRookToAccrue);\n  ","contract":"Stake","time":0},{"type":"external-function ","before":"   function initiateTimelockedWithdrawal(\n        StakeCommitment memory _commitment\n    ) external {\n        if (getCurrentWithdrawalTimelock(_commitment.stakeAddress) == 0) {\n            require(msg.sender == _commitment.stakeAddress, \"only stakeAddress can start the withdrawal process\");\n        }\n        require(_commitment.stakeSpent <= stakedAmount[_commitment.stakeAddress], \"cannot spend more than is staked\");\n        // the stakeNonce may have been seen in settleSpentStake so we must allow greater than or equals to here.\n        // note this means a malicious or compromised coordinator has the ability to indefinitely reset the timelock.\n        // this is fine since we can just change the coordinator address.\n        require(_commitment.stakeNonce >= stakeNonce[_commitment.stakeAddress], \"stake nonce is too old\");\n        require(_commitment.channelNonce == channelNonce[_commitment.stakeAddress], \"incorrect channel nonce\");\n        require(msg.sender == _commitment.stakeAddress || msg.sender == coordinator, \n            \"only callable by stakeAdddress or coordinator\");\n        \n        address recoveredStakeAddress = ECDSA.recover(\n            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)), \n            _commitment.stakeAddressSignature);\n        require(recoveredStakeAddress == _commitment.stakeAddress, \"recovered address is not the stake address\");\n        address recoveredCoordinatorAddress =  ECDSA.recover(\n            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)), \n            _commitment.coordinatorSignature);\n        require(recoveredCoordinatorAddress == coordinator, \"recovered address is not the coordinator\");\n\n        adjustTotalClaimableAmountByStakeSpentChange(stakeSpent[_commitment.stakeAddress], _commitment.stakeSpent);\n        stakeNonce[_commitment.stakeAddress] = _commitment.stakeNonce;\n        stakeSpent[_commitment.stakeAddress] = _commitment.stakeSpent;\n\n        withdrawalTimelockTimestamp[\n            withdrawalTimelockKey(\n                _commitment.stakeAddress, \n                _commitment.stakeSpent, \n                _commitment.stakeNonce, \n                _commitment.channelNonce\n            )] = block.timestamp + 7 days;\n\n        emit TimelockedWithdrawalInitiated(\n            _commitment.stakeAddress, \n            _commitment.stakeSpent, \n            _commitment.stakeNonce, \n            _commitment.channelNonce, \n            block.timestamp + 7 days);\n  ","after":"   function initiateTimelockedWithdrawal(\n        StakeCommitment calldata _commitment\n    ) external {\n        if (getCurrentWithdrawalTimelock(_commitment.stakeAddress) == 0) {\n            require(msg.sender == _commitment.stakeAddress, \"only stakeAddress can start the withdrawal process\");\n        }\n        require(_commitment.stakeSpent <= stakedAmount[_commitment.stakeAddress], \"cannot spend more than is staked\");\n        // the stakeNonce may have been seen in settleSpentStake so we must allow greater than or equals to here.\n        // note this means a malicious or compromised coordinator has the ability to indefinitely reset the timelock.\n        // this is fine since we can just change the coordinator address.\n        require(_commitment.stakeNonce >= stakeNonce[_commitment.stakeAddress], \"stake nonce is too old\");\n        require(_commitment.channelNonce == channelNonce[_commitment.stakeAddress], \"incorrect channel nonce\");\n        require(msg.sender == _commitment.stakeAddress || msg.sender == coordinator, \n            \"only callable by stakeAdddress or coordinator\");\n        \n        address recoveredStakeAddress = ECDSA.recover(\n            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)), \n            _commitment.stakeAddressSignature);\n        require(recoveredStakeAddress == _commitment.stakeAddress, \"recovered address is not the stake address\");\n        address recoveredCoordinatorAddress =  ECDSA.recover(\n            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)), \n            _commitment.coordinatorSignature);\n        require(recoveredCoordinatorAddress == coordinator, \"recovered address is not the coordinator\");\n\n        adjustTotalClaimableAmountByStakeSpentChange(stakeSpent[_commitment.stakeAddress], _commitment.stakeSpent);\n        stakeNonce[_commitment.stakeAddress] = _commitment.stakeNonce;\n        stakeSpent[_commitment.stakeAddress] = _commitment.stakeSpent;\n\n        withdrawalTimelockTimestamp[\n            withdrawalTimelockKey(\n                _commitment.stakeAddress, \n                _commitment.stakeSpent, \n                _commitment.stakeNonce, \n                _commitment.channelNonce\n            )] = block.timestamp + 7 days;\n\n        emit TimelockedWithdrawalInitiated(\n            _commitment.stakeAddress, \n            _commitment.stakeSpent, \n            _commitment.stakeNonce, \n            _commitment.channelNonce, \n            block.timestamp + 7 days);\n  ","contract":"Stake","time":0},{"type":"external-function ","before":"   function executeInstantWithdrawal(\n        StakeCommitment memory _commitment\n    ) external {\n        require(msg.sender == _commitment.stakeAddress, \"only stakeAddress can perform instant withdrawal\");\n        require(_commitment.stakeSpent <= stakedAmount[_commitment.stakeAddress], \"cannot use more than staked amount\");\n        require(_commitment.stakeNonce >= stakeNonce[_commitment.stakeAddress], \"nonce is too old\");\n        require(_commitment.channelNonce == channelNonce[_commitment.stakeAddress], \"incorrect channel nonce\");\n        require(keccak256(_commitment.data) == keccak256(INSTANT_WITHDRAWAL_COMMITMENT_DATA), \"incorrect data payload\");\n\n        address recoveredStakeAddress =  ECDSA.recover(\n            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)), \n            _commitment.stakeAddressSignature);\n        require(recoveredStakeAddress == _commitment.stakeAddress, \"recovered address is not the stake address\");\n        address recoveredCoordinatorAddress =  ECDSA.recover(\n            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)), \n            _commitment.coordinatorSignature);\n        require(recoveredCoordinatorAddress == coordinator, \"recovered address is not the coordinator\");\n        \n        adjustTotalClaimableAmountByStakeSpentChange(stakeSpent[_commitment.stakeAddress], _commitment.stakeSpent);\n        uint256 withdrawalAmount = stakedAmount[_commitment.stakeAddress] - _commitment.stakeSpent;\n        stakeNonce[_commitment.stakeAddress] = 0;\n        stakeSpent[_commitment.stakeAddress] = 0;\n        stakedAmount[_commitment.stakeAddress] = 0;\n        channelNonce[_commitment.stakeAddress] += 1;\n\n        ROOK.safeTransfer(_commitment.stakeAddress, withdrawalAmount);\n\n        emit StakeWithdrawn(_commitment.stakeAddress, _commitment.channelNonce, withdrawalAmount);\n  ","after":"   function executeInstantWithdrawal(\n        StakeCommitment calldata _commitment\n    ) external {\n        require(msg.sender == _commitment.stakeAddress, \"only stakeAddress can perform instant withdrawal\");\n        require(_commitment.stakeSpent <= stakedAmount[_commitment.stakeAddress], \"cannot use more than staked amount\");\n        require(_commitment.stakeNonce >= stakeNonce[_commitment.stakeAddress], \"nonce is too old\");\n        require(_commitment.channelNonce == channelNonce[_commitment.stakeAddress], \"incorrect channel nonce\");\n        require(keccak256(_commitment.data) == keccak256(INSTANT_WITHDRAWAL_COMMITMENT_DATA), \"incorrect data payload\");\n\n        address recoveredStakeAddress =  ECDSA.recover(\n            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)), \n            _commitment.stakeAddressSignature);\n        require(recoveredStakeAddress == _commitment.stakeAddress, \"recovered address is not the stake address\");\n        address recoveredCoordinatorAddress =  ECDSA.recover(\n            ECDSA.toEthSignedMessageHash(stakeCommitmentHash(_commitment)), \n            _commitment.coordinatorSignature);\n        require(recoveredCoordinatorAddress == coordinator, \"recovered address is not the coordinator\");\n        \n        adjustTotalClaimableAmountByStakeSpentChange(stakeSpent[_commitment.stakeAddress], _commitment.stakeSpent);\n        uint256 withdrawalAmount = stakedAmount[_commitment.stakeAddress] - _commitment.stakeSpent;\n        stakeNonce[_commitment.stakeAddress] = 0;\n        stakeSpent[_commitment.stakeAddress] = 0;\n        stakedAmount[_commitment.stakeAddress] = 0;\n        channelNonce[_commitment.stakeAddress] += 1;\n\n        ROOK.safeTransfer(_commitment.stakeAddress, withdrawalAmount);\n\n        emit StakeWithdrawn(_commitment.stakeAddress, _commitment.channelNonce, withdrawalAmount);\n  ","contract":"Stake","time":1},{"type":"external-function ","before":"   function claim(\n        address _claimAddress, \n        uint256 _earningsToDate,\n        bytes memory _claimGeneratorSignature\n    ) external {\n        require(_earningsToDate > userClaimedAmount[_claimAddress], \"nothing to claim\");\n\n        address recoveredClaimGeneratorAddress = ECDSA.recover(\n            ECDSA.toEthSignedMessageHash(claimCommitmentHash(_claimAddress, _earningsToDate)), \n            _claimGeneratorSignature);\n        require(recoveredClaimGeneratorAddress == claimGenerator, \"recoveredClaimGeneratorAddress is not the account manager\");\n\n        uint256 claimAmount = _earningsToDate - userClaimedAmount[_claimAddress];\n        require(claimAmount <= totalClaimableAmount, \"claim amount exceeds balance on contract\");\n        userClaimedAmount[_claimAddress] = _earningsToDate;\n        totalClaimableAmount -= claimAmount;\n\n        ROOK.safeTransfer(_claimAddress, claimAmount);\n        emit Claimed(_claimAddress, claimAmount);\n  ","after":"   function claim(\n        address _claimAddress, \n        uint256 _earningsToDate,\n        bytes calldata _claimGeneratorSignature\n    ) external {\n        require(_earningsToDate > userClaimedAmount[_claimAddress], \"nothing to claim\");\n\n        address recoveredClaimGeneratorAddress = ECDSA.recover(\n            ECDSA.toEthSignedMessageHash(claimCommitmentHash(_claimAddress, _earningsToDate)), \n            _claimGeneratorSignature);\n        require(recoveredClaimGeneratorAddress == claimGenerator, \"recoveredClaimGeneratorAddress is not the account manager\");\n\n        uint256 claimAmount = _earningsToDate - userClaimedAmount[_claimAddress];\n        require(claimAmount <= totalClaimableAmount, \"claim amount exceeds balance on contract\");\n        userClaimedAmount[_claimAddress] = _earningsToDate;\n        totalClaimableAmount -= claimAmount;\n\n        ROOK.safeTransfer(_claimAddress, claimAmount);\n        emit Claimed(_claimAddress, claimAmount);\n  ","contract":"Stake","time":0}]}