{"time":353,"results":[{"type":"external-function ","before":"function relayAndSpeedUp(DepositData memory depositData, uint64 realizedLpFeePct) public nonReentrant() {\n        // If no pending relay for this deposit, then associate the caller's relay attempt with it.\n        uint32 priceRequestTime = uint32(getCurrentTime());\n\n        // The realizedLPFeePct should never be greater than 0.5e18 and the slow and instant relay fees should never be\n        // more than 0.25e18 each. Therefore, the sum of all fee types can never exceed 1e18 (or 100%).\n        require(\n            depositData.slowRelayFeePct <= 0.25e18 &&\n                depositData.instantRelayFeePct <= 0.25e18 &&\n                realizedLpFeePct <= 0.5e18,\n            \"Invalid fees\"\n        );\n\n        // Check if there is a pending relay for this deposit.\n        bytes32 depositHash = _getDepositHash(depositData);\n\n        // Note: A disputed relay deletes the stored relay hash and enables this require statement to pass.\n        require(relays[depositHash] == bytes32(0), \"Pending relay exists\");\n\n        uint256 proposerBond = _getProposerBond(depositData.amount);\n\n        // Save hash of new relay attempt parameters.\n        // Note: The liveness for this relay can be changed in the BridgeAdmin, which means that each relay has a\n        // potentially variable liveness time. This should not provide any exploit opportunities, especially because\n        // the BridgeAdmin state (including the liveness value) is permissioned to the cross domained owner.\n        RelayData memory relayData =\n            RelayData({\n                relayState: RelayState.Pending,\n                slowRelayer: msg.sender,\n                relayId: numberOfRelays++, // Note: Increment numberOfRelays at the same time as setting relayId to its current value.\n                realizedLpFeePct: realizedLpFeePct,\n                priceRequestTime: priceRequestTime,\n                proposerBond: proposerBond,\n                finalFee: l1TokenFinalFee\n            });\n        bytes32 relayHash = _getRelayHash(depositData, relayData);\n        relays[depositHash] = _getRelayDataHash(relayData);\n\n        bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);\n        require(\n            // Can only speed up a pending relay without an existing instant relay associated with it.\n            instantRelays[instantRelayHash] == address(0),\n            \"Relay cannot be sped up\"\n        );\n\n        // Sanity check that pool has enough balance to cover relay amount + proposer reward. Reward amount will be\n        // paid on settlement after the OptimisticOracle price request has passed the challenge period.\n        // Note: liquidReserves should always be <= balance - bonds.\n        require(liquidReserves - pendingReserves >= depositData.amount, \"Insufficient pool balance\");\n\n        // Compute total proposal bond and pull from caller so that the OptimisticOracle can pull it from here.\n        uint256 totalBond = proposerBond + l1TokenFinalFee;\n\n        // Pull relay amount minus fees from caller and send to the deposit l1Recipient. The total fees paid is the sum\n        // of the LP fees, the relayer fees and the instant relay fee.\n        uint256 feesTotal =\n            _getAmountFromPct(\n                relayData.realizedLpFeePct + depositData.slowRelayFeePct + depositData.instantRelayFeePct,\n                depositData.amount\n            );\n        // If the L1 token is WETH then: a) pull WETH from instant relayer b) unwrap WETH c) send ETH to recipient.\n        uint256 recipientAmount = depositData.amount - feesTotal;\n\n        bonds += totalBond;\n        pendingReserves += depositData.amount; // Book off maximum liquidity used by this relay in the pending reserves.\n\n        instantRelays[instantRelayHash] = msg.sender;\n\n        l1Token.safeTransferFrom(msg.sender, address(this), recipientAmount + totalBond);\n\n        // If this is a weth pool then unwrap and send eth.\n        if (isWethPool) {\n            _unwrapWETHTo(depositData.l1Recipient, recipientAmount);\n            // Else, this is a normal ERC20 token. Send to recipient.\n        } else l1Token.safeTransfer(depositData.l1Recipient, recipientAmount);\n\n        emit DepositRelayed(depositHash, depositData, relayData, relayHash);\n        emit RelaySpedUp(depositHash, msg.sender, relayData);\n    }","after":"function relayAndSpeedUp(DepositData calldata depositData, uint64 realizedLpFeePct) public nonReentrant() {\n        // If no pending relay for this deposit, then associate the caller's relay attempt with it.\n        uint32 priceRequestTime = uint32(getCurrentTime());\n\n        // The realizedLPFeePct should never be greater than 0.5e18 and the slow and instant relay fees should never be\n        // more than 0.25e18 each. Therefore, the sum of all fee types can never exceed 1e18 (or 100%).\n        require(\n            depositData.slowRelayFeePct <= 0.25e18 &&\n                depositData.instantRelayFeePct <= 0.25e18 &&\n                realizedLpFeePct <= 0.5e18,\n            \"Invalid fees\"\n        );\n\n        // Check if there is a pending relay for this deposit.\n        bytes32 depositHash = _getDepositHash(depositData);\n\n        // Note: A disputed relay deletes the stored relay hash and enables this require statement to pass.\n        require(relays[depositHash] == bytes32(0), \"Pending relay exists\");\n\n        uint256 proposerBond = _getProposerBond(depositData.amount);\n\n        // Save hash of new relay attempt parameters.\n        // Note: The liveness for this relay can be changed in the BridgeAdmin, which means that each relay has a\n        // potentially variable liveness time. This should not provide any exploit opportunities, especially because\n        // the BridgeAdmin state (including the liveness value) is permissioned to the cross domained owner.\n        RelayData memory relayData =\n            RelayData({\n                relayState: RelayState.Pending,\n                slowRelayer: msg.sender,\n                relayId: numberOfRelays++, // Note: Increment numberOfRelays at the same time as setting relayId to its current value.\n                realizedLpFeePct: realizedLpFeePct,\n                priceRequestTime: priceRequestTime,\n                proposerBond: proposerBond,\n                finalFee: l1TokenFinalFee\n            });\n        bytes32 relayHash = _getRelayHash(depositData, relayData);\n        relays[depositHash] = _getRelayDataHash(relayData);\n\n        bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);\n        require(\n            // Can only speed up a pending relay without an existing instant relay associated with it.\n            instantRelays[instantRelayHash] == address(0),\n            \"Relay cannot be sped up\"\n        );\n\n        // Sanity check that pool has enough balance to cover relay amount + proposer reward. Reward amount will be\n        // paid on settlement after the OptimisticOracle price request has passed the challenge period.\n        // Note: liquidReserves should always be <= balance - bonds.\n        require(liquidReserves - pendingReserves >= depositData.amount, \"Insufficient pool balance\");\n\n        // Compute total proposal bond and pull from caller so that the OptimisticOracle can pull it from here.\n        uint256 totalBond = proposerBond + l1TokenFinalFee;\n\n        // Pull relay amount minus fees from caller and send to the deposit l1Recipient. The total fees paid is the sum\n        // of the LP fees, the relayer fees and the instant relay fee.\n        uint256 feesTotal =\n            _getAmountFromPct(\n                relayData.realizedLpFeePct + depositData.slowRelayFeePct + depositData.instantRelayFeePct,\n                depositData.amount\n            );\n        // If the L1 token is WETH then: a) pull WETH from instant relayer b) unwrap WETH c) send ETH to recipient.\n        uint256 recipientAmount = depositData.amount - feesTotal;\n\n        bonds += totalBond;\n        pendingReserves += depositData.amount; // Book off maximum liquidity used by this relay in the pending reserves.\n\n        instantRelays[instantRelayHash] = msg.sender;\n\n        l1Token.safeTransferFrom(msg.sender, address(this), recipientAmount + totalBond);\n\n        // If this is a weth pool then unwrap and send eth.\n        if (isWethPool) {\n            _unwrapWETHTo(depositData.l1Recipient, recipientAmount);\n            // Else, this is a normal ERC20 token. Send to recipient.\n        } else l1Token.safeTransfer(depositData.l1Recipient, recipientAmount);\n\n        emit DepositRelayed(depositHash, depositData, relayData, relayHash);\n        emit RelaySpedUp(depositHash, msg.sender, relayData);\n    }","contract":"BridgePoolProd","time":0},{"type":"external-function ","before":"function disputeRelay(DepositData memory depositData, RelayData memory relayData) public nonReentrant() {\n        require(relayData.priceRequestTime + optimisticOracleLiveness > getCurrentTime(), \"Past liveness\");\n        require(relayData.relayState == RelayState.Pending, \"Not disputable\");\n        // Validate the input data.\n        bytes32 depositHash = _getDepositHash(depositData);\n        _validateRelayDataHash(depositHash, relayData);\n\n        // Submit the proposal and dispute to the OO.\n        bytes32 relayHash = _getRelayHash(depositData, relayData);\n\n        // Note: in some cases this will fail due to changes in the OO and the method will refund the relayer.\n        bool success =\n            _requestProposeDispute(\n                relayData.slowRelayer,\n                msg.sender,\n                relayData.proposerBond,\n                relayData.finalFee,\n                _getRelayAncillaryData(relayHash)\n            );\n\n        // Drop the relay and remove the bond from the tracked bonds.\n        bonds -= relayData.finalFee + relayData.proposerBond;\n        pendingReserves -= depositData.amount;\n        delete relays[depositHash];\n        if (success) emit RelayDisputed(depositHash, _getRelayDataHash(relayData), msg.sender);\n        else emit RelayCanceled(depositHash, _getRelayDataHash(relayData), msg.sender);\n    }","after":"function disputeRelay(DepositData calldata depositData, RelayData calldata relayData) public nonReentrant() {\n        require(relayData.priceRequestTime + optimisticOracleLiveness > getCurrentTime(), \"Past liveness\");\n        require(relayData.relayState == RelayState.Pending, \"Not disputable\");\n        // Validate the input data.\n        bytes32 depositHash = _getDepositHash(depositData);\n        _validateRelayDataHash(depositHash, relayData);\n\n        // Submit the proposal and dispute to the OO.\n        bytes32 relayHash = _getRelayHash(depositData, relayData);\n\n        // Note: in some cases this will fail due to changes in the OO and the method will refund the relayer.\n        bool success =\n            _requestProposeDispute(\n                relayData.slowRelayer,\n                msg.sender,\n                relayData.proposerBond,\n                relayData.finalFee,\n                _getRelayAncillaryData(relayHash)\n            );\n\n        // Drop the relay and remove the bond from the tracked bonds.\n        bonds -= relayData.finalFee + relayData.proposerBond;\n        pendingReserves -= depositData.amount;\n        delete relays[depositHash];\n        if (success) emit RelayDisputed(depositHash, _getRelayDataHash(relayData), msg.sender);\n        else emit RelayCanceled(depositHash, _getRelayDataHash(relayData), msg.sender);\n    }","contract":"BridgePoolProd","time":0},{"type":"external-function ","before":"function relayDeposit(DepositData memory depositData, uint64 realizedLpFeePct) public nonReentrant() {\n        // The realizedLPFeePct should never be greater than 0.5e18 and the slow and instant relay fees should never be\n        // more than 0.25e18 each. Therefore, the sum of all fee types can never exceed 1e18 (or 100%).\n        require(\n            depositData.slowRelayFeePct <= 0.25e18 &&\n                depositData.instantRelayFeePct <= 0.25e18 &&\n                realizedLpFeePct <= 0.5e18,\n            \"Invalid fees\"\n        );\n\n        // Check if there is a pending relay for this deposit.\n        bytes32 depositHash = _getDepositHash(depositData);\n\n        // Note: A disputed relay deletes the stored relay hash and enables this require statement to pass.\n        require(relays[depositHash] == bytes32(0), \"Pending relay exists\");\n\n        // If no pending relay for this deposit, then associate the caller's relay attempt with it.\n        uint32 priceRequestTime = uint32(getCurrentTime());\n\n        uint256 proposerBond = _getProposerBond(depositData.amount);\n\n        // Save hash of new relay attempt parameters.\n        // Note: The liveness for this relay can be changed in the BridgeAdmin, which means that each relay has a\n        // potentially variable liveness time. This should not provide any exploit opportunities, especially because\n        // the BridgeAdmin state (including the liveness value) is permissioned to the cross domained owner.\n        RelayData memory relayData =\n            RelayData({\n                relayState: RelayState.Pending,\n                slowRelayer: msg.sender,\n                relayId: numberOfRelays++, // Note: Increment numberOfRelays at the same time as setting relayId to its current value.\n                realizedLpFeePct: realizedLpFeePct,\n                priceRequestTime: priceRequestTime,\n                proposerBond: proposerBond,\n                finalFee: l1TokenFinalFee\n            });\n        relays[depositHash] = _getRelayDataHash(relayData);\n\n        bytes32 relayHash = _getRelayHash(depositData, relayData);\n\n        // Sanity check that pool has enough balance to cover relay amount + proposer reward. Reward amount will be\n        // paid on settlement after the OptimisticOracle price request has passed the challenge period.\n        // Note: liquidReserves should always be <= balance - bonds.\n        require(liquidReserves - pendingReserves >= depositData.amount, \"Insufficient pool balance\");\n\n        // Compute total proposal bond and pull from caller so that the OptimisticOracle can pull it from here.\n        uint256 totalBond = proposerBond + l1TokenFinalFee;\n        pendingReserves += depositData.amount; // Book off maximum liquidity used by this relay in the pending reserves.\n        bonds += totalBond;\n\n        l1Token.safeTransferFrom(msg.sender, address(this), totalBond);\n        emit DepositRelayed(depositHash, depositData, relayData, relayHash);\n    }","after":"function relayDeposit(DepositData calldata depositData, uint64 realizedLpFeePct) public nonReentrant() {\n        // The realizedLPFeePct should never be greater than 0.5e18 and the slow and instant relay fees should never be\n        // more than 0.25e18 each. Therefore, the sum of all fee types can never exceed 1e18 (or 100%).\n        require(\n            depositData.slowRelayFeePct <= 0.25e18 &&\n                depositData.instantRelayFeePct <= 0.25e18 &&\n                realizedLpFeePct <= 0.5e18,\n            \"Invalid fees\"\n        );\n\n        // Check if there is a pending relay for this deposit.\n        bytes32 depositHash = _getDepositHash(depositData);\n\n        // Note: A disputed relay deletes the stored relay hash and enables this require statement to pass.\n        require(relays[depositHash] == bytes32(0), \"Pending relay exists\");\n\n        // If no pending relay for this deposit, then associate the caller's relay attempt with it.\n        uint32 priceRequestTime = uint32(getCurrentTime());\n\n        uint256 proposerBond = _getProposerBond(depositData.amount);\n\n        // Save hash of new relay attempt parameters.\n        // Note: The liveness for this relay can be changed in the BridgeAdmin, which means that each relay has a\n        // potentially variable liveness time. This should not provide any exploit opportunities, especially because\n        // the BridgeAdmin state (including the liveness value) is permissioned to the cross domained owner.\n        RelayData memory relayData =\n            RelayData({\n                relayState: RelayState.Pending,\n                slowRelayer: msg.sender,\n                relayId: numberOfRelays++, // Note: Increment numberOfRelays at the same time as setting relayId to its current value.\n                realizedLpFeePct: realizedLpFeePct,\n                priceRequestTime: priceRequestTime,\n                proposerBond: proposerBond,\n                finalFee: l1TokenFinalFee\n            });\n        relays[depositHash] = _getRelayDataHash(relayData);\n\n        bytes32 relayHash = _getRelayHash(depositData, relayData);\n\n        // Sanity check that pool has enough balance to cover relay amount + proposer reward. Reward amount will be\n        // paid on settlement after the OptimisticOracle price request has passed the challenge period.\n        // Note: liquidReserves should always be <= balance - bonds.\n        require(liquidReserves - pendingReserves >= depositData.amount, \"Insufficient pool balance\");\n\n        // Compute total proposal bond and pull from caller so that the OptimisticOracle can pull it from here.\n        uint256 totalBond = proposerBond + l1TokenFinalFee;\n        pendingReserves += depositData.amount; // Book off maximum liquidity used by this relay in the pending reserves.\n        bonds += totalBond;\n\n        l1Token.safeTransferFrom(msg.sender, address(this), totalBond);\n        emit DepositRelayed(depositHash, depositData, relayData, relayHash);\n    }","contract":"BridgePoolProd","time":0},{"type":"external-function ","before":"function speedUpRelay(DepositData memory depositData, RelayData memory relayData) public nonReentrant() {\n        bytes32 depositHash = _getDepositHash(depositData);\n        _validateRelayDataHash(depositHash, relayData);\n        bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);\n        require(\n            // Can only speed up a pending relay without an existing instant relay associated with it.\n            getCurrentTime() < relayData.priceRequestTime + optimisticOracleLiveness &&\n                relayData.relayState == RelayState.Pending &&\n                instantRelays[instantRelayHash] == address(0),\n            \"Relay cannot be sped up\"\n        );\n        instantRelays[instantRelayHash] = msg.sender;\n\n        // Pull relay amount minus fees from caller and send to the deposit l1Recipient. The total fees paid is the sum\n        // of the LP fees, the relayer fees and the instant relay fee.\n        uint256 feesTotal =\n            _getAmountFromPct(\n                relayData.realizedLpFeePct + depositData.slowRelayFeePct + depositData.instantRelayFeePct,\n                depositData.amount\n            );\n        // If the L1 token is WETH then: a) pull WETH from instant relayer b) unwrap WETH c) send ETH to recipient.\n        uint256 recipientAmount = depositData.amount - feesTotal;\n        if (isWethPool) {\n            l1Token.safeTransferFrom(msg.sender, address(this), recipientAmount);\n            _unwrapWETHTo(depositData.l1Recipient, recipientAmount);\n            // Else, this is a normal ERC20 token. Send to recipient.\n        } else l1Token.safeTransferFrom(msg.sender, depositData.l1Recipient, recipientAmount);\n\n        emit RelaySpedUp(depositHash, msg.sender, relayData);\n    }","after":"function speedUpRelay(DepositData calldata depositData, RelayData calldata relayData) public nonReentrant() {\n        bytes32 depositHash = _getDepositHash(depositData);\n        _validateRelayDataHash(depositHash, relayData);\n        bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);\n        require(\n            // Can only speed up a pending relay without an existing instant relay associated with it.\n            getCurrentTime() < relayData.priceRequestTime + optimisticOracleLiveness &&\n                relayData.relayState == RelayState.Pending &&\n                instantRelays[instantRelayHash] == address(0),\n            \"Relay cannot be sped up\"\n        );\n        instantRelays[instantRelayHash] = msg.sender;\n\n        // Pull relay amount minus fees from caller and send to the deposit l1Recipient. The total fees paid is the sum\n        // of the LP fees, the relayer fees and the instant relay fee.\n        uint256 feesTotal =\n            _getAmountFromPct(\n                relayData.realizedLpFeePct + depositData.slowRelayFeePct + depositData.instantRelayFeePct,\n                depositData.amount\n            );\n        // If the L1 token is WETH then: a) pull WETH from instant relayer b) unwrap WETH c) send ETH to recipient.\n        uint256 recipientAmount = depositData.amount - feesTotal;\n        if (isWethPool) {\n            l1Token.safeTransferFrom(msg.sender, address(this), recipientAmount);\n            _unwrapWETHTo(depositData.l1Recipient, recipientAmount);\n            // Else, this is a normal ERC20 token. Send to recipient.\n        } else l1Token.safeTransferFrom(msg.sender, depositData.l1Recipient, recipientAmount);\n\n        emit RelaySpedUp(depositHash, msg.sender, relayData);\n    }","contract":"BridgePoolProd","time":0},{"type":"external-function ","before":"function settleRelay(DepositData memory depositData, RelayData memory relayData) public nonReentrant() {\n        bytes32 depositHash = _getDepositHash(depositData);\n        _validateRelayDataHash(depositHash, relayData);\n        require(relayData.relayState == RelayState.Pending, \"Already settled\");\n        uint32 expirationTime = relayData.priceRequestTime + optimisticOracleLiveness;\n        require(expirationTime <= getCurrentTime(), \"Not settleable yet\");\n\n        // Note: this check is to give the relayer a small, but reasonable amount of time to complete the relay before\n        // before it can be \"stolen\" by someone else. This is to ensure there is an incentive to settle relays quickly.\n        require(\n            msg.sender == relayData.slowRelayer || getCurrentTime() > expirationTime + 15 minutes,\n            \"Not slow relayer\"\n        );\n\n        // Update the relay state to Finalized. This prevents any re-settling of a relay.\n        relays[depositHash] = _getRelayDataHash(\n            RelayData({\n                relayState: RelayState.Finalized,\n                slowRelayer: relayData.slowRelayer,\n                relayId: relayData.relayId,\n                realizedLpFeePct: relayData.realizedLpFeePct,\n                priceRequestTime: relayData.priceRequestTime,\n                proposerBond: relayData.proposerBond,\n                finalFee: relayData.finalFee\n            })\n        );\n\n        // Reward relayers and pay out l1Recipient.\n        // At this point there are two possible cases:\n        // - This was a slow relay: In this case, a) pay the slow relayer their reward and b) pay the l1Recipient of the\n        //      amount minus the realized LP fee and the slow Relay fee. The transfer was not sped up so no instant fee.\n        // - This was an instant relay: In this case, a) pay the slow relayer their reward and b) pay the instant relayer\n        //      the full bridging amount, minus the realized LP fee and minus the slow relay fee. When the instant\n        //      relayer called speedUpRelay they were docked this same amount, minus the instant relayer fee. As a\n        //      result, they are effectively paid what they spent when speeding up the relay + the instantRelayFee.\n\n        uint256 instantRelayerOrRecipientAmount =\n            depositData.amount -\n                _getAmountFromPct(relayData.realizedLpFeePct + depositData.slowRelayFeePct, depositData.amount);\n\n        // Refund the instant relayer iff the instant relay params match the approved relay.\n        bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);\n        address instantRelayer = instantRelays[instantRelayHash];\n\n        // If this is the WETH pool and the instant relayer is is address 0x0 (i.e the relay was not sped up) then:\n        // a) withdraw WETH to ETH and b) send the ETH to the recipient.\n        if (isWethPool && instantRelayer == address(0)) {\n            _unwrapWETHTo(depositData.l1Recipient, instantRelayerOrRecipientAmount);\n            // Else, this is a normal slow relay being finalizes where the contract sends ERC20 to the recipient OR this\n            // is the finalization of an instant relay where we need to reimburse the instant relayer in WETH.\n        } else\n            l1Token.safeTransfer(\n                instantRelayer != address(0) ? instantRelayer : depositData.l1Recipient,\n                instantRelayerOrRecipientAmount\n            );\n\n        // There is a fee and a bond to pay out. The fee goes to whoever settles. The bond always goes back to the\n        // slow relayer.\n        // Note: for gas efficiency, we use an if so we can combine these transfers in the event that they are the same\n        // address.\n        uint256 slowRelayerReward = _getAmountFromPct(depositData.slowRelayFeePct, depositData.amount);\n        uint256 totalBond = relayData.finalFee + relayData.proposerBond;\n        if (relayData.slowRelayer == msg.sender)\n            l1Token.safeTransfer(relayData.slowRelayer, slowRelayerReward + totalBond);\n        else {\n            l1Token.safeTransfer(relayData.slowRelayer, totalBond);\n            l1Token.safeTransfer(msg.sender, slowRelayerReward);\n        }\n\n        uint256 totalReservesSent = instantRelayerOrRecipientAmount + slowRelayerReward;\n\n        // Update reserves by amounts changed and allocated LP fees.\n        pendingReserves -= depositData.amount;\n        liquidReserves -= totalReservesSent;\n        utilizedReserves += int256(totalReservesSent);\n        bonds -= totalBond;\n        _updateAccumulatedLpFees();\n        _allocateLpFees(_getAmountFromPct(relayData.realizedLpFeePct, depositData.amount));\n\n        emit RelaySettled(depositHash, msg.sender, relayData);\n\n        // Clean up state storage and receive gas refund. This also prevents `priceDisputed()` from being able to reset\n        // this newly Finalized relay state.\n        delete instantRelays[instantRelayHash];\n    }","after":"function settleRelay(DepositData calldata depositData, RelayData calldata relayData) public nonReentrant() {\n        bytes32 depositHash = _getDepositHash(depositData);\n        _validateRelayDataHash(depositHash, relayData);\n        require(relayData.relayState == RelayState.Pending, \"Already settled\");\n        uint32 expirationTime = relayData.priceRequestTime + optimisticOracleLiveness;\n        require(expirationTime <= getCurrentTime(), \"Not settleable yet\");\n\n        // Note: this check is to give the relayer a small, but reasonable amount of time to complete the relay before\n        // before it can be \"stolen\" by someone else. This is to ensure there is an incentive to settle relays quickly.\n        require(\n            msg.sender == relayData.slowRelayer || getCurrentTime() > expirationTime + 15 minutes,\n            \"Not slow relayer\"\n        );\n\n        // Update the relay state to Finalized. This prevents any re-settling of a relay.\n        relays[depositHash] = _getRelayDataHash(\n            RelayData({\n                relayState: RelayState.Finalized,\n                slowRelayer: relayData.slowRelayer,\n                relayId: relayData.relayId,\n                realizedLpFeePct: relayData.realizedLpFeePct,\n                priceRequestTime: relayData.priceRequestTime,\n                proposerBond: relayData.proposerBond,\n                finalFee: relayData.finalFee\n            })\n        );\n\n        // Reward relayers and pay out l1Recipient.\n        // At this point there are two possible cases:\n        // - This was a slow relay: In this case, a) pay the slow relayer their reward and b) pay the l1Recipient of the\n        //      amount minus the realized LP fee and the slow Relay fee. The transfer was not sped up so no instant fee.\n        // - This was an instant relay: In this case, a) pay the slow relayer their reward and b) pay the instant relayer\n        //      the full bridging amount, minus the realized LP fee and minus the slow relay fee. When the instant\n        //      relayer called speedUpRelay they were docked this same amount, minus the instant relayer fee. As a\n        //      result, they are effectively paid what they spent when speeding up the relay + the instantRelayFee.\n\n        uint256 instantRelayerOrRecipientAmount =\n            depositData.amount -\n                _getAmountFromPct(relayData.realizedLpFeePct + depositData.slowRelayFeePct, depositData.amount);\n\n        // Refund the instant relayer iff the instant relay params match the approved relay.\n        bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);\n        address instantRelayer = instantRelays[instantRelayHash];\n\n        // If this is the WETH pool and the instant relayer is is address 0x0 (i.e the relay was not sped up) then:\n        // a) withdraw WETH to ETH and b) send the ETH to the recipient.\n        if (isWethPool && instantRelayer == address(0)) {\n            _unwrapWETHTo(depositData.l1Recipient, instantRelayerOrRecipientAmount);\n            // Else, this is a normal slow relay being finalizes where the contract sends ERC20 to the recipient OR this\n            // is the finalization of an instant relay where we need to reimburse the instant relayer in WETH.\n        } else\n            l1Token.safeTransfer(\n                instantRelayer != address(0) ? instantRelayer : depositData.l1Recipient,\n                instantRelayerOrRecipientAmount\n            );\n\n        // There is a fee and a bond to pay out. The fee goes to whoever settles. The bond always goes back to the\n        // slow relayer.\n        // Note: for gas efficiency, we use an if so we can combine these transfers in the event that they are the same\n        // address.\n        uint256 slowRelayerReward = _getAmountFromPct(depositData.slowRelayFeePct, depositData.amount);\n        uint256 totalBond = relayData.finalFee + relayData.proposerBond;\n        if (relayData.slowRelayer == msg.sender)\n            l1Token.safeTransfer(relayData.slowRelayer, slowRelayerReward + totalBond);\n        else {\n            l1Token.safeTransfer(relayData.slowRelayer, totalBond);\n            l1Token.safeTransfer(msg.sender, slowRelayerReward);\n        }\n\n        uint256 totalReservesSent = instantRelayerOrRecipientAmount + slowRelayerReward;\n\n        // Update reserves by amounts changed and allocated LP fees.\n        pendingReserves -= depositData.amount;\n        liquidReserves -= totalReservesSent;\n        utilizedReserves += int256(totalReservesSent);\n        bonds -= totalBond;\n        _updateAccumulatedLpFees();\n        _allocateLpFees(_getAmountFromPct(relayData.realizedLpFeePct, depositData.amount));\n\n        emit RelaySettled(depositHash, msg.sender, relayData);\n\n        // Clean up state storage and receive gas refund. This also prevents `priceDisputed()` from being able to reset\n        // this newly Finalized relay state.\n        delete instantRelays[instantRelayHash];\n    }","contract":"BridgePoolProd","time":0},{"type":"immutable-restrict-modification ","before":"bool public isWethPool;","after":"bool public immutable isWethPool;","contract":"BridgePoolProd","time":2},{"type":"immutable-restrict-modification ","before":"uint64 public lpFeeRatePerSecond;","after":"uint64 public immutable lpFeeRatePerSecond;","contract":"BridgePoolProd","time":2},{"type":"immutable-restrict-modification ","before":"address public timerAddress;","after":"address public immutable timerAddress;","contract":"BridgePoolProd","time":2}]}