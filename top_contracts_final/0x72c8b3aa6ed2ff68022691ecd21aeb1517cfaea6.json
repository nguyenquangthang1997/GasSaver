{"time":299,"results":[{"type":"external-function ","before":"er\n    function convertVNL(bytes32[] memory proof) external override {\n        if (block.timestamp >= migrationState.conversionDeadline()) {\n            revert ConversionWindowClosed();\n        }\n\n        uint256 convertedAmount = vnl.balanceOf(msg.sender);\n        if (convertedAmount == 0) {\n            revert NoConvertibleVNL();\n        }\n\n        // because VanillaV1Token01's cannot be burned, the conversion just locks them into this contract permanently\n        address freezer = address(this);\n        uint256 previouslyFrozen = vnl.balanceOf(freezer);\n\n        // we know that OpenZeppelin ERC20 returns always true and reverts on failure, so no need to check the return value\n        vnl.transferFrom(msg.sender, freezer, convertedAmount);\n\n        // These should never fail as we know precisely how VanillaV1Token01.transferFrom is implemented\n        if (vnl.balanceOf(freezer) != previouslyFrozen + convertedAmount) {\n            revert FreezerBalanceMismatch();\n        }\n        if (vnl.balanceOf(msg.sender) > 0) {\n            revert UnexpectedTokensAfterConversion();\n        }\n\n        if (!migrationState.verifyEligibility(proof, msg.sender, convertedAmount)) {\n            revert VerificationFailed();\n        }\n\n        // finally let implementor to mint the converted amount of tokens and log the event\n        mintConverted(msg.sender, convertedAmount);\n        emit VNLConverted(msg.sender, convertedAmount)","after":"er\n    function convertVNL(bytes32[] memory proof) external override {\n        if (block.timestamp >= migrationState.conversionDeadline()) {\n            revert ConversionWindowClosed();\n        }\n\n        uint256 convertedAmount = vnl.balanceOf(msg.sender);\n        if (convertedAmount == 0) {\n            revert NoConvertibleVNL();\n        }\n\n        // because VanillaV1Token01's cannot be burned, the conversion just locks them into this contract permanently\n        address freezer = address(this);\n        uint256 previouslyFrozen = vnl.balanceOf(freezer);\n\n        // we know that OpenZeppelin ERC20 returns always true and reverts on failure, so no need to check the return value\n        vnl.transferFrom(msg.sender, freezer, convertedAmount);\n\n        // These should never fail as we know precisely how VanillaV1Token01.transferFrom is implemented\n        if (vnl.balanceOf(freezer) != previouslyFrozen + convertedAmount) {\n            revert FreezerBalanceMismatch();\n        }\n        if (vnl.balanceOf(msg.sender) > 0) {\n            revert UnexpectedTokensAfterConversion();\n        }\n\n        if (!migrationState.verifyEligibility(proof, msg.sender, convertedAmount)) {\n            revert VerificationFailed();\n        }\n\n        // finally let implementor to mint the converted amount of tokens and log the event\n        mintConverted(msg.sender, convertedAmount);\n        emit VNLConverted(msg.sender, convertedAmount)","contract":"VanillaV1Token02","time":0},{"type":"struct-data-arrangement ","before":"\n       addres\n       bool \n       uint256\n       uint256 n\n       uint256 blockTimeD\n       uin","after":"       uint256\n       uint256 n\n       uint256 blockTimeD\n       addres\n       uin\n       bool \n","contract":"IVanillaV1Router02","time":0}]}