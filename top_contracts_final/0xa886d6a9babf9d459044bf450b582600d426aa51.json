{"time":136,"results":[{"type":"external-function ","before":"function transferToOtherBlockchain(uint128 blockchain, uint256 amount, string memory newAddress) external whenNotPaused\n    {\n        require( \n            amount >= minTokenAmount,\n            \"swapContract: Less than required minimum of tokens requested\"\n        );\n        require(\n            bytes(newAddress).length > 0,\n            \"swapContract: No destination address provided\"\n        );\n        require(\n            existingOtherBlockchain[blockchain] && blockchain != numOfThisBlockchain,\n            \"swapContract: Wrong choose of blockchain\"\n        );\n        require(\n            amount >= feeAmountOfBlockchain[blockchain],\n            \"swapContract: Not enough amount of tokens\"\n        );\n        address sender = _msgSender();\n\n        TransferHelper.safeTransferFrom(address(tokenAddress), sender, address(this), amount);\n        emit TransferToOtherBlockchain(blockchain, sender, amount, newAddress);\n    }","after":"function transferToOtherBlockchain(uint128 blockchain, uint256 amount, string calldata newAddress) external whenNotPaused\n    {\n        require( \n            amount >= minTokenAmount,\n            \"swapContract: Less than required minimum of tokens requested\"\n        );\n        require(\n            bytes(newAddress).length > 0,\n            \"swapContract: No destination address provided\"\n        );\n        require(\n            existingOtherBlockchain[blockchain] && blockchain != numOfThisBlockchain,\n            \"swapContract: Wrong choose of blockchain\"\n        );\n        require(\n            amount >= feeAmountOfBlockchain[blockchain],\n            \"swapContract: Not enough amount of tokens\"\n        );\n        address sender = _msgSender();\n\n        TransferHelper.safeTransferFrom(address(tokenAddress), sender, address(this), amount);\n        emit TransferToOtherBlockchain(blockchain, sender, amount, newAddress);\n    }","contract":"SwapContract","time":0},{"type":"external-function ","before":"function transferToUserWithFee(\n        address user,\n        uint256 amountWithFee,\n        bytes32 originalTxHash,\n        bytes memory concatSignatures\n    ) \n        external\n        onlyRelayer\n        whenNotPaused\n    {\n        require(\n            user != address(0),\n            \"swapContract: Address cannot be zero address\"  \n        );\n        uint256 signatureLength = SIGNATURE_LENGTH;\n        require(\n            concatSignatures.length % signatureLength == 0,\n            \"swapContract: Signatures lengths must be divisible by 65\"\n        );\n        require(\n            concatSignatures.length / signatureLength >= minConfirmationSignatures,\n            \"swapContract: Not enough signatures passed\"\n        );\n\n        bytes32 hashedParams = getHashPacked(user, amountWithFee, originalTxHash);\n        (bool processed, bytes32 savedHash) = isProcessedTransaction(originalTxHash);\n        require(!processed && savedHash != hashedParams, \"swapContract: Transaction already processed\");\n        \n        uint256 signaturesCount = concatSignatures.length / signatureLength;\n        address[] memory validatorAddresses = new address[](signaturesCount);\n        for (uint256 i = 0; i < signaturesCount; i++) {\n            address validatorAddress = ecOffsetRecover(hashedParams, concatSignatures, i * signatureLength);\n            require(isValidator(validatorAddress), \"swapContract: Validator address not in whitelist\");\n            for (uint256 j = 0; j < i; j++) {\n                require(validatorAddress != validatorAddresses[j], \"swapContract: Validator address is duplicated\");\n            }\n            validatorAddresses[i] = validatorAddress;\n        }\n\n        processedTransactions[originalTxHash] = hashedParams;\n\n        uint256 fee = feeAmountOfBlockchain[numOfThisBlockchain];\n        uint256 amountWithoutFee = amountWithFee - fee;\n        TransferHelper.safeTransfer(address(tokenAddress), user, amountWithoutFee);\n        accumulatedFee += fee;\n        emit TransferFromOtherBlockchain(user, amountWithFee, amountWithoutFee, originalTxHash);\n    }","after":"function transferToUserWithFee(\n        address user,\n        uint256 amountWithFee,\n        bytes32 originalTxHash,\n        bytes calldata concatSignatures\n    ) \n        external\n        onlyRelayer\n        whenNotPaused\n    {\n        require(\n            user != address(0),\n            \"swapContract: Address cannot be zero address\"  \n        );\n        uint256 signatureLength = SIGNATURE_LENGTH;\n        require(\n            concatSignatures.length % signatureLength == 0,\n            \"swapContract: Signatures lengths must be divisible by 65\"\n        );\n        require(\n            concatSignatures.length / signatureLength >= minConfirmationSignatures,\n            \"swapContract: Not enough signatures passed\"\n        );\n\n        bytes32 hashedParams = getHashPacked(user, amountWithFee, originalTxHash);\n        (bool processed, bytes32 savedHash) = isProcessedTransaction(originalTxHash);\n        require(!processed && savedHash != hashedParams, \"swapContract: Transaction already processed\");\n        \n        uint256 signaturesCount = concatSignatures.length / signatureLength;\n        address[] memory validatorAddresses = new address[](signaturesCount);\n        for (uint256 i = 0; i < signaturesCount; i++) {\n            address validatorAddress = ecOffsetRecover(hashedParams, concatSignatures, i * signatureLength);\n            require(isValidator(validatorAddress), \"swapContract: Validator address not in whitelist\");\n            for (uint256 j = 0; j < i; j++) {\n                require(validatorAddress != validatorAddresses[j], \"swapContract: Validator address is duplicated\");\n            }\n            validatorAddresses[i] = validatorAddress;\n        }\n\n        processedTransactions[originalTxHash] = hashedParams;\n\n        uint256 fee = feeAmountOfBlockchain[numOfThisBlockchain];\n        uint256 amountWithoutFee = amountWithFee - fee;\n        TransferHelper.safeTransfer(address(tokenAddress), user, amountWithoutFee);\n        accumulatedFee += fee;\n        emit TransferFromOtherBlockchain(user, amountWithFee, amountWithoutFee, originalTxHash);\n    }","contract":"SwapContract","time":0},{"type":"immutable-restrict-modification ","before":"uint128 public numOfThisBlockchain;","after":"uint128 public immutable numOfThisBlockchain;","contract":"SwapContract","time":0}]}