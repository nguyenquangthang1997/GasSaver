{"time":168,"results":[{"type":"external-function ","before":"function tokenAllow(\n        address[] memory tokensToApprove, \n        uint256[] memory approvalAmounts, \n        address spender\n    ) external onlyOwner {\n        require(tokensToApprove.length == approvalAmounts.length, \"RM::tokenAllow: not same length\");\n        for(uint i = 0; i < tokensToApprove.length; i++) {\n            IERC20Extended token = IERC20Extended(tokensToApprove[i]);\n            if (token.allowance(address(this), spender) != type(uint256).max) {\n                token.safeApprove(spender, approvalAmounts[i]);\n            }\n        }\n    }","after":"function tokenAllow(\n        address[] calldata tokensToApprove, \n        uint256[] calldata approvalAmounts, \n        address spender\n    ) external onlyOwner {\n        require(tokensToApprove.length == approvalAmounts.length, \"RM::tokenAllow: not same length\");\n        for(uint i = 0; i < tokensToApprove.length; i++) {\n            IERC20Extended token = IERC20Extended(tokensToApprove[i]);\n            if (token.allowance(address(this), spender) != type(uint256).max) {\n                token.safeApprove(spender, approvalAmounts[i]);\n            }\n        }\n    }","contract":"RewardsManager","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public startBlock;","after":"uint256 public immutable startBlock;","contract":"RewardsManager","time":0}]}