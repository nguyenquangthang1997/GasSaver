{"time":201,"results":[{"type":"state-data-arrangement ","before":"\nbool    private _active;\nuint256 private _activeTime;\nuint256 private cycled = 0;\nuint256 private used_brots = 0;\nuint256 private used_FMJ = 0;\nuint256 private constant max_cycles = 244;\nuint256 public  constant PRICE = 197800000000000000;\nuint32  public  constant PRESALE_TIME = 172800;\nuint8   public  constant MAX_QUANTITY = 20;\nuint8   public  constant COMMUNITY_QUOTA = 10;\nmapping (uint256 => uint256) claimed;\nmapping (uint256 => uint8  ) cycles;\naddress public  MANDELBROT_ADDRESS = 0x6E96Fb1f6D8cb1463E018A2Cc6E09C64eD474deA;\naddress public  COMMUNITY_WALLET   = 0x229ddBd9A20e3Df3ab7f540Ec77bEB258476fEe5;\naddress public  VIP_PASS_ADDRESS   = 0x5645E72bcBCb9f218268e5DB15F62F016f885984;\naddress public  FREE_MINT_ADDRESS  = 0xdd665AFF8C98ee39e4D581caB1e48A1DbE8B055d;","after":"uint256 private _activeTime;\nuint256 private cycled = 0;\nuint256 private used_brots = 0;\nuint256 private used_FMJ = 0;\nuint256 private constant max_cycles = 244;\nuint256 public  constant PRICE = 197800000000000000;\nmapping (uint256 => uint256) claimed;\nmapping (uint256 => uint8  ) cycles;\naddress public  MANDELBROT_ADDRESS = 0x6E96Fb1f6D8cb1463E018A2Cc6E09C64eD474deA;\naddress public  COMMUNITY_WALLET   = 0x229ddBd9A20e3Df3ab7f540Ec77bEB258476fEe5;\naddress public  VIP_PASS_ADDRESS   = 0x5645E72bcBCb9f218268e5DB15F62F016f885984;\naddress public  FREE_MINT_ADDRESS  = 0xdd665AFF8C98ee39e4D581caB1e48A1DbE8B055d;\nuint32  public  constant PRESALE_TIME = 172800;\nbool    private _active;\nuint8   public  constant MAX_QUANTITY = 20;\nuint8   public  constant COMMUNITY_QUOTA = 10;\n","contract":"Julia","time":4},{"type":"external-function ","before":"function claim_from_brots(uint256[] memory brots) external {\n        require(_active, \"Inactive\");\n        require(block.timestamp < _activeTime + PRESALE_TIME, \"Too late!\");\n        require(brots.length>0, \"Please input the ids of your Mandelbrots\");\n        \n        uint256 verified = 0;\n\n        for (uint i = 0; i < brots.length; i++) {\n            require(brots[i]>0 && brots[i]<=1978, \"Invalid Mandelbrot id\");\n            require(claimed[brots[i]]==0, \"Mandelbrot already claimed\");\n            mintTo(msg.sender);\n            iterate(_currentTokenId);\n            used_brots++;\n        }   \n\n        uint256 owned;\n        uint256 j = 0;\n        while (verified < brots.length) {\n            owned = IERC721Enumerable(MANDELBROT_ADDRESS).tokenOfOwnerByIndex(msg.sender, j);\n            for (uint k = 0; k < brots.length; k++) {\n                if (brots[k]==owned && claimed[owned]==0){\n                    verified++;\n                    claimed[owned] = _currentTokenId;\n                    k = brots.length;\n                }\n            }\n            j++;\n        }\n\n        require(verified==brots.length, \"You don't own all the Mandelbrots you are claiming\");\n    }","after":"function claim_from_brots(uint256[] calldata brots) external {\n        require(_active, \"Inactive\");\n        require(block.timestamp < _activeTime + PRESALE_TIME, \"Too late!\");\n        require(brots.length>0, \"Please input the ids of your Mandelbrots\");\n        \n        uint256 verified = 0;\n\n        for (uint i = 0; i < brots.length; i++) {\n            require(brots[i]>0 && brots[i]<=1978, \"Invalid Mandelbrot id\");\n            require(claimed[brots[i]]==0, \"Mandelbrot already claimed\");\n            mintTo(msg.sender);\n            iterate(_currentTokenId);\n            used_brots++;\n        }   \n\n        uint256 owned;\n        uint256 j = 0;\n        while (verified < brots.length) {\n            owned = IERC721Enumerable(MANDELBROT_ADDRESS).tokenOfOwnerByIndex(msg.sender, j);\n            for (uint k = 0; k < brots.length; k++) {\n                if (brots[k]==owned && claimed[owned]==0){\n                    verified++;\n                    claimed[owned] = _currentTokenId;\n                    k = brots.length;\n                }\n            }\n            j++;\n        }\n\n        require(verified==brots.length, \"You don't own all the Mandelbrots you are claiming\");\n    }","contract":"Julia","time":0},{"type":"external-function ","before":"function activale(uint256[] memory ids) external onlyOwner {\n        for (uint i=0; i < ids.length; i++) {\n              cycles[ids[i]] = 1;\n          }\n    }","after":"function activale(uint256[] calldata ids) external onlyOwner {\n        for (uint i=0; i < ids.length; i++) {\n              cycles[ids[i]] = 1;\n          }\n    }","contract":"Julia","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"Julia","time":0},{"type":"constant-restrict-modification  ","before":"address public  MANDELBROT_ADDRESS = 0x6E96Fb1f6D8cb1463E018A2Cc6E09C64eD474deA;","after":"address public  constant MANDELBROT_ADDRESS = 0x6E96Fb1f6D8cb1463E018A2Cc6E09C64eD474deA;","contract":"Julia","time":1},{"type":"constant-restrict-modification  ","before":"address public  COMMUNITY_WALLET   = 0x229ddBd9A20e3Df3ab7f540Ec77bEB258476fEe5;","after":"address public  constant COMMUNITY_WALLET   = 0x229ddBd9A20e3Df3ab7f540Ec77bEB258476fEe5;","contract":"Julia","time":1},{"type":"constant-restrict-modification  ","before":"address public  VIP_PASS_ADDRESS   = 0x5645E72bcBCb9f218268e5DB15F62F016f885984;","after":"address public  constant VIP_PASS_ADDRESS   = 0x5645E72bcBCb9f218268e5DB15F62F016f885984;","contract":"Julia","time":1},{"type":"constant-restrict-modification  ","before":"address public  FREE_MINT_ADDRESS  = 0xdd665AFF8C98ee39e4D581caB1e48A1DbE8B055d;","after":"address public  constant FREE_MINT_ADDRESS  = 0xdd665AFF8C98ee39e4D581caB1e48A1DbE8B055d;","contract":"Julia","time":1},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"Julia","time":1}]}