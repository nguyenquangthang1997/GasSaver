{"time":1532,"results":[{"type":"external-function ","before":"function makeCoverBegin(\n    address smartCAdd,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public payable onlyMember whenNotPaused {\n\n    require(coverCurr == \"ETH\", \"Pool: Unexpected asset type\");\n    require(msg.value == coverDetails[1], \"Pool: ETH amount does not match premium\");\n\n    quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n  }","after":"function makeCoverBegin(\n    address smartCAdd,\n    bytes4 coverCurr,\n    uint[] calldata coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public payable onlyMember whenNotPaused {\n\n    require(coverCurr == \"ETH\", \"Pool: Unexpected asset type\");\n    require(msg.value == coverDetails[1], \"Pool: ETH amount does not match premium\");\n\n    quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n  }","contract":"Pool","time":0},{"type":"external-function ","before":"function makeCoverUsingCA(\n    address smartCAdd,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public onlyMember whenNotPaused {\n    require(coverCurr != \"ETH\", \"Pool: Unexpected asset type\");\n    quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n  }","after":"function makeCoverUsingCA(\n    address smartCAdd,\n    bytes4 coverCurr,\n    uint[] calldata coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public onlyMember whenNotPaused {\n    require(coverCurr != \"ETH\", \"Pool: Unexpected asset type\");\n    quotation.verifyCoverDetails(msg.sender, smartCAdd, coverCurr, coverDetails, coverPeriod, _v, _r, _s);\n  }","contract":"Pool","time":0},{"type":"external-function ","before":"s\n   */\n  function verifyCoverDetails(\n    address payable from,\n    address scAddress,\n    bytes4 coverCurr,\n    uint[] memory coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public onlyInternal {\n    _verifyCoverDetails(\n      from,\n      scAddress,\n      coverCurr,\n      coverDetails,\n      coverPeriod,\n      _v,\n      _r,\n      _s,\n      false\n","after":"s\n   */\n  function verifyCoverDetails(\n    address payable from,\n    address scAddress,\n    bytes4 coverCurr,\n    uint[] calldata coverDetails,\n    uint16 coverPeriod,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) public onlyInternal {\n    _verifyCoverDetails(\n      from,\n      scAddress,\n      coverCurr,\n      coverDetails,\n      coverPeriod,\n      _v,\n      _r,\n      _s,\n      false\n","contract":"Quotation","time":0},{"type":"constant-restrict-modification  ","before":"upply;\n\n  string public nam","after":"upply;\n\n  string public nam","contract":"NXMToken","time":0},{"type":"constant-restrict-modification  ","before":" \"NXM\";\n  string public symbo","after":" \"NXM\";\n  string public symbo","contract":"NXMToken","time":0},{"type":"constant-restrict-modification  ","before":" \"NXM\";\n  uint8 public deci","after":" \"NXM\";\n  uint8 public deci","contract":"NXMToken","time":0},{"type":"struct-data-arrangement ","before":"\nver {\n    address payable mem\nress;\n    bytes4 cu\nCode;\n    uint \nured;\n    uint16 c\nriod;\n    uint \nntil;\n    address\nress;\n    uint ","after":"Code;\n    uint \nriod;\n    uint \nress;\n    uint \nver {\n    address payable mem\nntil;\n    address\nress;\n    bytes4 cu\nured;\n    uint16 c\n","contract":"QuotationData","time":0},{"type":"struct-data-arrangement ","before":"\nver {\n    uint h\nerId;\n    address payable u\nress;\n    address\nress;\n    bytes4\nCurr;\n    uint[] co\nails;\n    uint16 c","after":"ver {\n    uint h\nCurr;\n    uint[] co\nerId;\n    address payable u\nress;\n    address\nress;\n    bytes4\nails;\n    uint16 c\n","contract":"QuotationData","time":0},{"type":"struct-data-arrangement ","before":"\note {\n    add\noter;\n    u\nkens;\n    ui\nimId;\n    in\ndict;\n    bool rew","after":"oter;\n    u\nkens;\n    ui\note {\n    add\nimId;\n    in\ndict;\n    bool rew\n","contract":"ClaimsData","time":0},{"type":"external-function ","before":"role id\n  function addRole(//solhint-disable-line\n    bytes32 _roleName,\n    string memory _roleDescription,\n    address _authorized\n  )\n  public\n  onlyAuthorizedToGovern {\n    _addRole(_roleName, _roleDescription, _author","after":"role id\n  function addRole(//solhint-disable-line\n    bytes32 _roleName,\n    string calldata _roleDescription,\n    address _authorized\n  )\n  public\n  onlyAuthorizedToGovern {\n    _addRole(_roleName, _roleDescription, _author","contract":"MemberRoles","time":0},{"type":"external-function ","before":"t\n   */\n  function addMembersBeforeLaunch(address[] memory userArray, uint[] memory tokens) public onlyOwner {\n    require(!launched);\n\n    for (uint i = 0; i < userArray.length; i++) {\n      require(!ms.isMember(userArray[i]));\n      tc.addToWhitelist(userArray[i]);\n      _updateRole(userArray[i], uint(Role.Member), true);\n      tc.mint(userArray[i], tokens[i]);\n    }\n    launched = true;\n    launchedOn =","after":"t\n   */\n  function addMembersBeforeLaunch(address[] calldata userArray, uint[] memory tokens) public onlyOwner {\n    require(!launched);\n\n    for (uint i = 0; i < userArray.length; i++) {\n      require(!ms.isMember(userArray[i]));\n      tc.addToWhitelist(userArray[i]);\n      _updateRole(userArray[i], uint(Role.Member), true);\n      tc.mint(userArray[i], tokens[i]);\n    }\n    launched = true;\n    launchedOn =","contract":"MemberRoles","time":0},{"type":"external-function ","before":"ed\n  */\n  function newCategory(\n    string memory _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] memory _allowedToCreateProposal,\n    uint _closingTime,\n    string memory _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] memory _incentives,\n    string memory _functionHash\n  )\n  public\n  onlyAuthorizedToGovern\n  {\n\n    require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n    require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n    require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n    //If category is special resolution role authorized should be member\n    if (_incentives[3] == 1) {\n      require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n      _majorityVotePerc = 0;\n      _quorumPerc = 0;\n    }\n\n    _addCategory(\n      _name,\n      _memberRoleToVote,\n      _majorityVotePerc,\n      _quorumPerc,\n      _allowedToCreateProposal,\n      _closingTime,\n      _actionHash,\n      _contractAddress,\n      _contractName,\n      _incentives\n    );\n\n\n    if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n      categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);","after":"ed\n  */\n  function newCategory(\n    string calldata _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] calldata _allowedToCreateProposal,\n    uint _closingTime,\n    string calldata _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] calldata _incentives,\n    string calldata _functionHash\n  )\n  public\n  onlyAuthorizedToGovern\n  {\n\n    require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n    require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n    require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n    //If category is special resolution role authorized should be member\n    if (_incentives[3] == 1) {\n      require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n      _majorityVotePerc = 0;\n      _quorumPerc = 0;\n    }\n\n    _addCategory(\n      _name,\n      _memberRoleToVote,\n      _majorityVotePerc,\n      _quorumPerc,\n      _allowedToCreateProposal,\n      _closingTime,\n      _actionHash,\n      _contractAddress,\n      _contractName,\n      _incentives\n    );\n\n\n    if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n      categoryActionHashes[allCategory.length - 1] = abi.encodeWithSignature(_functionHash);","contract":"ProposalCategory","time":0},{"type":"external-function ","before":"ed\n  */\n  function editCategory(\n    uint _categoryId,\n    string memory _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] memory _allowedToCreateProposal,\n    uint _closingTime,\n    string memory _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] memory _incentives,\n    string memory _functionHash\n  )\n  public\n  onlyAuthorizedToGovern\n  {\n    require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\n\n    require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n    require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n    require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n    //If category is special resolution role authorized should be member\n    if (_incentives[3] == 1) {\n      require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n      _majorityVotePerc = 0;\n      _quorumPerc = 0;\n    }\n\n    delete categoryActionHashes[_categoryId];\n    if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n      categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\n    }\n    allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\n    allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\n    allCategory[_categoryId].closingTime = _closingTime;\n    allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\n    allCategory[_categoryId].minStake = _incentives[0];\n    allCategory[_categoryId].quorumPerc = _quorumPerc;\n    categoryActionData[_categoryId].defaultIncentive = _incentives[1];\n    categoryActionData[_categoryId].contractName = _contractName;\n    categoryActionData[_categoryId].contractAddress = _contractAddress;\n    categoryABReq[_categoryId] = _incentives[2];\n    isSpecialResolution[_categoryId] = _incentives[3];\n    emit Category(_categoryId, _name, _action","after":"ed\n  */\n  function editCategory(\n    uint _categoryId,\n    string calldata _name,\n    uint _memberRoleToVote,\n    uint _majorityVotePerc,\n    uint _quorumPerc,\n    uint[] calldata _allowedToCreateProposal,\n    uint _closingTime,\n    string calldata _actionHash,\n    address _contractAddress,\n    bytes2 _contractName,\n    uint[] calldata _incentives,\n    string calldata _functionHash\n  )\n  public\n  onlyAuthorizedToGovern\n  {\n    require(_verifyMemberRoles(_memberRoleToVote, _allowedToCreateProposal) == 1, \"Invalid Role\");\n\n    require(_quorumPerc <= 100 && _majorityVotePerc <= 100, \"Invalid percentage\");\n\n    require((_contractName == \"EX\" && _contractAddress == address(0)) || bytes(_functionHash).length > 0);\n\n    require(_incentives[3] <= 1, \"Invalid special resolution flag\");\n\n    //If category is special resolution role authorized should be member\n    if (_incentives[3] == 1) {\n      require(_memberRoleToVote == uint(MemberRoles.Role.Member));\n      _majorityVotePerc = 0;\n      _quorumPerc = 0;\n    }\n\n    delete categoryActionHashes[_categoryId];\n    if (bytes(_functionHash).length > 0 && abi.encodeWithSignature(_functionHash).length == 4) {\n      categoryActionHashes[_categoryId] = abi.encodeWithSignature(_functionHash);\n    }\n    allCategory[_categoryId].memberRoleToVote = _memberRoleToVote;\n    allCategory[_categoryId].majorityVotePerc = _majorityVotePerc;\n    allCategory[_categoryId].closingTime = _closingTime;\n    allCategory[_categoryId].allowedToCreateProposal = _allowedToCreateProposal;\n    allCategory[_categoryId].minStake = _incentives[0];\n    allCategory[_categoryId].quorumPerc = _quorumPerc;\n    categoryActionData[_categoryId].defaultIncentive = _incentives[1];\n    categoryActionData[_categoryId].contractName = _contractName;\n    categoryActionData[_categoryId].contractAddress = _contractAddress;\n    categoryABReq[_categoryId] = _incentives[2];\n    isSpecialResolution[_categoryId] = _incentives[3];\n    emit Category(_categoryId, _name, _action","contract":"ProposalCategory","time":0}]}