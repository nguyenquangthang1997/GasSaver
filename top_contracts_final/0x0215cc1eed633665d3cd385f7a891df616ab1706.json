{"time":119,"results":[{"type":"external-function ","before":"   function withdrawTransfer(bytes32  substrateSender, address recipient, uint availableAmount,bytes memory sig)  public\n        updateContractWithdrawInfo(availableAmount)\n         {  \n            //require(msg.value == fee, \"DPRBridge: Fee not match\");\n            require(token.balanceOf(address(this)) >= availableAmount, \"DPRBridge: Balance is not enough\");\n            bytes32 messageID = keccak256(abi.encodePacked(substrateSender, recipient, availableAmount, block.timestamp));\n            setMessageAndEmitEvent(messageID, substrateSender, recipient, availableAmount, sig);\n      ","after":"   function withdrawTransfer(bytes32  substrateSender, address recipient, uint availableAmount,bytes calldata sig)  public\n        updateContractWithdrawInfo(availableAmount)\n         {  \n            //require(msg.value == fee, \"DPRBridge: Fee not match\");\n            require(token.balanceOf(address(this)) >= availableAmount, \"DPRBridge: Balance is not enough\");\n            bytes32 messageID = keccak256(abi.encodePacked(substrateSender, recipient, availableAmount, block.timestamp));\n            setMessageAndEmitEvent(messageID, substrateSender, recipient, availableAmount, sig);\n      ","contract":"DPRBridge","time":0},{"type":"external-function ","before":"   function confirmWithdrawTransfer(bytes32 messageID, bytes memory signature) public withdrawMessage(messageID) \n        //onlyManyValidatorsConfirm(messageID, msg.sender) \n        {\n            bytes32 data = keccak256(abi.encodePacked(messageID));\n            bytes32 sign_data = keccak256(abi.encodePacked(SIGN_HASH_PREFIX, data));\n            address recover_address = ECDSA.recover(sign_data, signature);\n            require(recover_address == submiter, \"DPRBridge: Address not match\");\n            Message storage message = messages[messageID];\n            uint256 withdraw_amount = message.availableAmount;\n            //setWithdrawData(message.spender, withdraw_amount);\n            message.status = Status.CONFIRMED_WITHDRAW;\n            token.safeTransfer(message.spender, withdraw_amount);\n            emit ConfirmWithdrawMessage(messageID);\n            \n            \n      ","after":"   function confirmWithdrawTransfer(bytes32 messageID, bytes calldata signature) public withdrawMessage(messageID) \n        //onlyManyValidatorsConfirm(messageID, msg.sender) \n        {\n            bytes32 data = keccak256(abi.encodePacked(messageID));\n            bytes32 sign_data = keccak256(abi.encodePacked(SIGN_HASH_PREFIX, data));\n            address recover_address = ECDSA.recover(sign_data, signature);\n            require(recover_address == submiter, \"DPRBridge: Address not match\");\n            Message storage message = messages[messageID];\n            uint256 withdraw_amount = message.availableAmount;\n            //setWithdrawData(message.spender, withdraw_amount);\n            message.status = Status.CONFIRMED_WITHDRAW;\n            token.safeTransfer(message.spender, withdraw_amount);\n            emit ConfirmWithdrawMessage(messageID);\n            \n            \n      ","contract":"DPRBridge","time":0}]}