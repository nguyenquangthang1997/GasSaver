{"time":206,"results":[{"type":"struct-data-arrangement ","before":"\nta {\r\n        \n    \r\n        \n    \r\n       \n    \r\n        \nying\r\n       \nken \r\n       \nice \r\n     \n    \r\n       \ner, 최종구\n time]    u\nme]  unit : sec\nr or no bidder","after":"    \r\n       \n    \r\n        \nken \r\n       \nice \r\n     \ner, 최종구\n time]    u\nta {\r\n        \nying\r\n       \n    \r\n       \n    \r\n        \nme]  unit : sec\nr or no bidder\n","contract":"NFTMarket","time":0},{"type":"external-function ","before":"     *\r\n     * Requirements:\r\n     *\r\n     *    MINTER_ROLE을 보유하고 있는 address\r\n     *    DEFAULT_ADMIN_ROLE DEFAULT_ADMIN_ROLE 보유해야 \r\n     *\r\n     * Event : RoleRevoked\r\n     *\r\n     */\r\n    function removeWhiteList(address minter)  external {\r\n        require(hasRole(MINTER_ROLE,minter),\"NFTBase/minter_has_not_role\");\r\n        revokeRole(MINTER_ROLE,minter);\r\n    }\r\n    \r\n    /**\r\n     * @dev mint :   NFT Token 발행\r\n     *\r\n     * Requirements:\r\n     *\r\n     *    supply > 0, uri != \"\", creator != address(0)\r\n     *    royalty : royalty Range안에 \r\n     *    Private Market의 경우 msg.seder는 MINTER_ROLE을 보유해야 \r\n     *\r\n     * Event : TransferSingle\r\n     */\r\n\r\n    /**\r\n     * Only incaseof private market, check if caller has a minter role \r\n     */\r\n    function mint(uint256 supply, string memory uri, address creator, uint256 royaltyRatio) public returns(uint256 id) ","after":"     *\r\n     * Requirements:\r\n     *\r\n     *    MINTER_ROLE을 보유하고 있는 address\r\n     *    DEFAULT_ADMIN_ROLE DEFAULT_ADMIN_ROLE 보유해야 \r\n     *\r\n     * Event : RoleRevoked\r\n     *\r\n     */\r\n    function removeWhiteList(address minter)  external {\r\n        require(hasRole(MINTER_ROLE,minter),\"NFTBase/minter_has_not_role\");\r\n        revokeRole(MINTER_ROLE,minter);\r\n    }\r\n    \r\n    /**\r\n     * @dev mint :   NFT Token 발행\r\n     *\r\n     * Requirements:\r\n     *\r\n     *    supply > 0, uri != \"\", creator != address(0)\r\n     *    royalty : royalty Range안에 \r\n     *    Private Market의 경우 msg.seder는 MINTER_ROLE을 보유해야 \r\n     *\r\n     * Event : TransferSingle\r\n     */\r\n\r\n    /**\r\n     * Only incaseof private market, check if caller has a minter role \r\n     */\r\n    function mint(uint256 supply, string memory uri, address creator, uint256 royaltyRatio) public returns(uint256 id) ","contract":"NFTBase","time":0},{"type":"external-function ","before":"256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address account, a","after":"256[] calldata batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address account, a","contract":"NFTBase","time":0},{"type":"external-function ","before":"n _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    )\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n\r\n        address operator = _msgSender();\r\n\r\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\r\n        _balances[id][to] = _balances[id][to].add(amount);\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeBatchTransferFrom}.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] mem","after":"n _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    )\r\n        public\r\n        virtual\r\n        override\r\n    {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n\r\n        address operator = _msgSender();\r\n\r\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\r\n        _balances[id][to] = _balances[id][to].add(amount);\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeBatchTransferFrom}.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] mem","contract":"NFTBase","time":0}]}