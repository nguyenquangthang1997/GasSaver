{"time":163,"results":[{"type":"external-function ","before":"function setPreRevealURI(string memory _value) public onlyOwner {\r\n    _prerevealMetaURI = _value;\r\n  }","after":"function setPreRevealURI(string calldata _value) public onlyOwner {\r\n    _prerevealMetaURI = _value;\r\n  }","contract":"DreamGardensNFT","time":0},{"type":"external-function ","before":"function setRevealedURI(string memory _value) public onlyOwner {\r\n    _revealedMetaURI = _value;\r\n  }","after":"function setRevealedURI(string calldata _value) public onlyOwner {\r\n    _revealedMetaURI = _value;\r\n  }","contract":"DreamGardensNFT","time":0},{"type":"external-function ","before":"function setNightmareURI(string memory _value) public onlyOwner {\r\n    _nightmareMetaURI = _value;\r\n  }","after":"function setNightmareURI(string calldata _value) public onlyOwner {\r\n    _nightmareMetaURI = _value;\r\n  }","contract":"DreamGardensNFT","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\r\n        address userAddress,\r\n        bytes memory functionSignature,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        uint8 sigV\r\n    ) public payable returns (bytes memory) {\r\n        MetaTransaction memory metaTx = MetaTransaction({\r\n            nonce: nonces[userAddress],\r\n            from: userAddress,\r\n            functionSignature: functionSignature\r\n        });\r\n\r\n        require(\r\n            verify(userAddress, metaTx, sigR, sigS, sigV),\r\n            \"Signer and signature do not match\"\r\n        );\r\n\r\n        // increase nonce for user (to avoid re-use)\r\n        nonces[userAddress] = nonces[userAddress].add(1);\r\n\r\n        emit MetaTransactionExecuted(\r\n            userAddress,\r\n            payable(msg.sender),\r\n            functionSignature\r\n        );\r\n\r\n        // Append userAddress and relayer address at the end to extract it from calling context\r\n        (bool success, bytes memory returnData) = address(this).call(\r\n            abi.encodePacked(functionSignature, userAddress)\r\n        );\r\n        require(success, \"Function call not successful\");\r\n\r\n        return returnData;\r\n    }","after":"function executeMetaTransaction(\r\n        address userAddress,\r\n        bytes calldata functionSignature,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        uint8 sigV\r\n    ) public payable returns (bytes memory) {\r\n        MetaTransaction memory metaTx = MetaTransaction({\r\n            nonce: nonces[userAddress],\r\n            from: userAddress,\r\n            functionSignature: functionSignature\r\n        });\r\n\r\n        require(\r\n            verify(userAddress, metaTx, sigR, sigS, sigV),\r\n            \"Signer and signature do not match\"\r\n        );\r\n\r\n        // increase nonce for user (to avoid re-use)\r\n        nonces[userAddress] = nonces[userAddress].add(1);\r\n\r\n        emit MetaTransactionExecuted(\r\n            userAddress,\r\n            payable(msg.sender),\r\n            functionSignature\r\n        );\r\n\r\n        // Append userAddress and relayer address at the end to extract it from calling context\r\n        (bool success, bytes memory returnData) = address(this).call(\r\n            abi.encodePacked(functionSignature, userAddress)\r\n        );\r\n        require(success, \"Function call not successful\");\r\n\r\n        return returnData;\r\n    }","contract":"DreamGardensNFT","time":0},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"DreamGardensNFT","time":1}]}