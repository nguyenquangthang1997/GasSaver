{"time":940,"results":[{"type":"external-function ","before":"function addInsuranceFundCollateral(\n        string memory _collateralName,\n        string memory _collateralSymbol,\n        address _underlyingToken,\n        address _collateralToken,\n        InsuranceFundDefs.Flavor _flavor\n    ) external onlyAdmin insuranceMiningOngoing isNotPaused {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        // Obtain bytes32 representation of collateral name\n        bytes32 result;\n        assembly {\n            result := mload(add(_collateralName, 32))\n        }\n\n        // Ensure collateral has not already been added\n        require(\n            dsInsuranceFund.stakeCollaterals[result].collateralToken == address(0),\n            \"IFund: collateral already added.\"\n        );\n\n        require(_collateralToken != address(0), \"IFund: collateral address must be non-zero.\");\n        require(!isCollateralTokenPresent(_collateralToken), \"IFund: collateral token already present.\");\n        require(_underlyingToken != _collateralToken, \"IFund: token addresses are same.\");\n        if (_flavor == InsuranceFundDefs.Flavor.Vanilla) {\n            // If collateral is of vanilla flavor, there should only be\n            // a value for collateral token, and underlying token should\n            // be empty\n            require(_underlyingToken == address(0), \"IFund: underlying address non-zero for Vanilla.\");\n        }\n\n        // Add collateral type to storage, including its underlying\n        // token and collateral token addresses, and its flavor\n        dsInsuranceFund.stakeCollaterals[result].underlyingToken = _underlyingToken;\n        dsInsuranceFund.stakeCollaterals[result].collateralToken = _collateralToken;\n        dsInsuranceFund.stakeCollaterals[result].flavor = _flavor;\n\n        // Create a DerivaDEX Insurance Fund token contract associated\n        // with this supported collateral\n        dsInsuranceFund.stakeCollaterals[result].diFundToken = IDIFundToken(\n            dsInsuranceFund.diFundTokenFactory.createNewDIFundToken(\n                _collateralName,\n                _collateralSymbol,\n                IERCCustom(_collateralToken).decimals()\n            )\n        );\n        dsInsuranceFund.collateralNames.push(result);\n\n        emit InsuranceFundCollateralAdded(result, _underlyingToken, _collateralToken, _flavor);\n    }","after":"function addInsuranceFundCollateral(\n        string calldata _collateralName,\n        string calldata _collateralSymbol,\n        address _underlyingToken,\n        address _collateralToken,\n        InsuranceFundDefs.Flavor _flavor\n    ) external onlyAdmin insuranceMiningOngoing isNotPaused {\n        LibDiamondStorageInsuranceFund.DiamondStorageInsuranceFund storage dsInsuranceFund =\n            LibDiamondStorageInsuranceFund.diamondStorageInsuranceFund();\n\n        // Obtain bytes32 representation of collateral name\n        bytes32 result;\n        assembly {\n            result := mload(add(_collateralName, 32))\n        }\n\n        // Ensure collateral has not already been added\n        require(\n            dsInsuranceFund.stakeCollaterals[result].collateralToken == address(0),\n            \"IFund: collateral already added.\"\n        );\n\n        require(_collateralToken != address(0), \"IFund: collateral address must be non-zero.\");\n        require(!isCollateralTokenPresent(_collateralToken), \"IFund: collateral token already present.\");\n        require(_underlyingToken != _collateralToken, \"IFund: token addresses are same.\");\n        if (_flavor == InsuranceFundDefs.Flavor.Vanilla) {\n            // If collateral is of vanilla flavor, there should only be\n            // a value for collateral token, and underlying token should\n            // be empty\n            require(_underlyingToken == address(0), \"IFund: underlying address non-zero for Vanilla.\");\n        }\n\n        // Add collateral type to storage, including its underlying\n        // token and collateral token addresses, and its flavor\n        dsInsuranceFund.stakeCollaterals[result].underlyingToken = _underlyingToken;\n        dsInsuranceFund.stakeCollaterals[result].collateralToken = _collateralToken;\n        dsInsuranceFund.stakeCollaterals[result].flavor = _flavor;\n\n        // Create a DerivaDEX Insurance Fund token contract associated\n        // with this supported collateral\n        dsInsuranceFund.stakeCollaterals[result].diFundToken = IDIFundToken(\n            dsInsuranceFund.diFundTokenFactory.createNewDIFundToken(\n                _collateralName,\n                _collateralSymbol,\n                IERCCustom(_collateralToken).decimals()\n            )\n        );\n        dsInsuranceFund.collateralNames.push(result);\n\n        emit InsuranceFundCollateralAdded(result, _underlyingToken, _collateralToken, _flavor);\n    }","contract":"InsuranceFund","time":0},{"type":"external-function ","before":"function permit(\n        address _spender,\n        uint256 _value,\n        uint256 _nonce,\n        uint256 _expiry,\n        bytes memory _signature\n    ) external {\n        // Perform EIP712 hashing logic\n        bytes32 eip712OrderParamsDomainHash = LibEIP712.hashEIP712Domain(_name, _version, getChainId(), address(this));\n        bytes32 permitHash =\n            LibPermit.getPermitHash(\n                LibPermit.Permit({ spender: _spender, value: _value, nonce: _nonce, expiry: _expiry }),\n                eip712OrderParamsDomainHash\n            );\n\n        // Perform sig recovery\n        uint8 v = uint8(_signature[0]);\n        bytes32 r = _signature.readBytes32(1);\n        bytes32 s = _signature.readBytes32(33);\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n\n        address recovered = ecrecover(permitHash, v, r, s);\n\n        require(recovered != address(0), \"DIFT: invalid signature.\");\n        require(_nonce == nonces[recovered]++, \"DIFT: invalid nonce.\");\n        require(block.timestamp <= _expiry, \"DIFT: signature expired.\");\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_value == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_value, \"DIFT: amount exceeds 96 bits.\");\n        }\n\n        // Set allowance\n        allowances[recovered][_spender] = amount;\n        emit Approval(recovered, _spender, _value);\n  ","after":"function permit(\n        address _spender,\n        uint256 _value,\n        uint256 _nonce,\n        uint256 _expiry,\n        bytes calldata _signature\n    ) external {\n        // Perform EIP712 hashing logic\n        bytes32 eip712OrderParamsDomainHash = LibEIP712.hashEIP712Domain(_name, _version, getChainId(), address(this));\n        bytes32 permitHash =\n            LibPermit.getPermitHash(\n                LibPermit.Permit({ spender: _spender, value: _value, nonce: _nonce, expiry: _expiry }),\n                eip712OrderParamsDomainHash\n            );\n\n        // Perform sig recovery\n        uint8 v = uint8(_signature[0]);\n        bytes32 r = _signature.readBytes32(1);\n        bytes32 s = _signature.readBytes32(33);\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n\n        address recovered = ecrecover(permitHash, v, r, s);\n\n        require(recovered != address(0), \"DIFT: invalid signature.\");\n        require(_nonce == nonces[recovered]++, \"DIFT: invalid nonce.\");\n        require(block.timestamp <= _expiry, \"DIFT: signature expired.\");\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_value == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_value, \"DIFT: amount exceeds 96 bits.\");\n        }\n\n        // Set allowance\n        allowances[recovered][_spender] = amount;\n        emit Approval(recovered, _spender, _value);\n  ","contract":"DIFundToken","time":0},{"type":"immutable-restrict-modification ","before":"uint8 private _decimals;","after":"uint8 private immutable _decimals;","contract":"DIFundToken","time":0},{"type":"immutable-restrict-modification ","before":"address public issuer;","after":"address public immutable issuer;","contract":"DIFundToken","time":0},{"type":"immutable-restrict-modification ","before":"   address public issu","after":"   address public issu","contract":"DIFundTokenFactory","time":0},{"type":"state-data-arrangement ","before":"\n   string public constant name = \"DerivaDA\n   string public constant symbol = \"DD\n   uint8 public constant decimals = \n   string public constant version = \"\n   uint96 public constant MAX_SUPPLY = 100000000e\n   uint96 public constant PRE_MINE_SUPPLY = 50000000e\n   uint96 public issuedSupp\n   uint96 public totalSupp\n   bool public ownershipTransferr\n   address public issu\n   mapping(address => mapping(address => uint96)) internal allowanc\n   mapping(address => uint96) internal balanc\n   mapping(address => address) public delegat\n   mapping(address => mapping(uint256 => Checkpoint)) public checkpoin\n   mapping(address => uint256) public numCheckpoin\n   mapping(address => uint256) public nonc","after":"   string public constant name = \"DerivaDA\n   string public constant symbol = \"DD\n   string public constant version = \"\n   mapping(address => mapping(address => uint96)) internal allowanc\n   mapping(address => uint96) internal balanc\n   mapping(address => address) public delegat\n   mapping(address => mapping(uint256 => Checkpoint)) public checkpoin\n   mapping(address => uint256) public numCheckpoin\n   mapping(address => uint256) public nonc\n   address public issu\n   uint96 public constant MAX_SUPPLY = 100000000e\n   uint96 public constant PRE_MINE_SUPPLY = 50000000e\n   uint96 public issuedSupp\n   uint96 public totalSupp\n   uint8 public constant decimals = \n   bool public ownershipTransferr\n","contract":"DDX","time":2},{"type":"external-function ","before":"   function delegateBySig(\n        address _delegatee,\n        uint256 _nonce,\n        uint256 _expiry,\n        bytes memory _signature\n    ) external {\n        // Perform EIP712 hashing logic\n        bytes32 eip712OrderParamsDomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 delegationHash =\n            LibDelegation.getDelegationHash(\n                LibDelegation.Delegation({ delegatee: _delegatee, nonce: _nonce, expiry: _expiry }),\n                eip712OrderParamsDomainHash\n            );\n\n        // Perform sig recovery\n        uint8 v = uint8(_signature[0]);\n        bytes32 r = _signature.readBytes32(1);\n        bytes32 s = _signature.readBytes32(33);\n        address recovered = ecrecover(delegationHash, v, r, s);\n\n        require(recovered != address(0), \"DDX: invalid signature.\");\n        require(_nonce == nonces[recovered]++, \"DDX: invalid nonce.\");\n        require(block.timestamp <= _expiry, \"DDX: signature expired.\");\n\n        // Delegate votes from recovered address to delegatee\n        _delegate(recovered, _delegatee);\n  ","after":"   function delegateBySig(\n        address _delegatee,\n        uint256 _nonce,\n        uint256 _expiry,\n        bytes calldata _signature\n    ) external {\n        // Perform EIP712 hashing logic\n        bytes32 eip712OrderParamsDomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 delegationHash =\n            LibDelegation.getDelegationHash(\n                LibDelegation.Delegation({ delegatee: _delegatee, nonce: _nonce, expiry: _expiry }),\n                eip712OrderParamsDomainHash\n            );\n\n        // Perform sig recovery\n        uint8 v = uint8(_signature[0]);\n        bytes32 r = _signature.readBytes32(1);\n        bytes32 s = _signature.readBytes32(33);\n        address recovered = ecrecover(delegationHash, v, r, s);\n\n        require(recovered != address(0), \"DDX: invalid signature.\");\n        require(_nonce == nonces[recovered]++, \"DDX: invalid nonce.\");\n        require(block.timestamp <= _expiry, \"DDX: signature expired.\");\n\n        // Delegate votes from recovered address to delegatee\n        _delegate(recovered, _delegatee);\n  ","contract":"DDX","time":0},{"type":"external-function ","before":"   function permit(\n        address _spender,\n        uint256 _value,\n        uint256 _nonce,\n        uint256 _expiry,\n        bytes memory _signature\n    ) external {\n        // Perform EIP712 hashing logic\n        bytes32 eip712OrderParamsDomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 permitHash =\n            LibPermit.getPermitHash(\n                LibPermit.Permit({ spender: _spender, value: _value, nonce: _nonce, expiry: _expiry }),\n                eip712OrderParamsDomainHash\n            );\n\n        // Perform sig recovery\n        uint8 v = uint8(_signature[0]);\n        bytes32 r = _signature.readBytes32(1);\n        bytes32 s = _signature.readBytes32(33);\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n\n        address recovered = ecrecover(permitHash, v, r, s);\n\n        require(recovered != address(0), \"DDX: invalid signature.\");\n        require(_nonce == nonces[recovered]++, \"DDX: invalid nonce.\");\n        require(block.timestamp <= _expiry, \"DDX: signature expired.\");\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_value == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_value, \"DDX: amount exceeds 96 bits.\");\n        }\n\n        // Set allowance\n        allowances[recovered][_spender] = amount;\n        emit Approval(recovered, _spender, _value);","after":"   function permit(\n        address _spender,\n        uint256 _value,\n        uint256 _nonce,\n        uint256 _expiry,\n        bytes calldata _signature\n    ) external {\n        // Perform EIP712 hashing logic\n        bytes32 eip712OrderParamsDomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 permitHash =\n            LibPermit.getPermitHash(\n                LibPermit.Permit({ spender: _spender, value: _value, nonce: _nonce, expiry: _expiry }),\n                eip712OrderParamsDomainHash\n            );\n\n        // Perform sig recovery\n        uint8 v = uint8(_signature[0]);\n        bytes32 r = _signature.readBytes32(1);\n        bytes32 s = _signature.readBytes32(33);\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n\n        address recovered = ecrecover(permitHash, v, r, s);\n\n        require(recovered != address(0), \"DDX: invalid signature.\");\n        require(_nonce == nonces[recovered]++, \"DDX: invalid nonce.\");\n        require(block.timestamp <= _expiry, \"DDX: signature expired.\");\n\n        // Convert amount to uint96\n        uint96 amount;\n        if (_value == uint256(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(_value, \"DDX: amount exceeds 96 bits.\");\n        }\n\n        // Set allowance\n        allowances[recovered][_spender] = amount;\n        emit Approval(recovered, _spender, _value);","contract":"DDX","time":0},{"type":"external-function ","before":"/\n    function propose(\n        address[] memory _targets,\n        uint256[] memory _values,\n        string[] memory _signatures,\n        bytes[] memory _calldatas,\n        string memory _description\n    ) external returns (uint128) {\n        LibDiamondStorageDerivaDEX.DiamondStorageDerivaDEX storage dsDerivaDEX =\n            LibDiamondStorageDerivaDEX.diamondStorageDerivaDEX();\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n\n        // Ensure proposer has sufficient token holdings to propose\n        require(\n            dsDerivaDEX.ddxToken.getPriorVotes(msg.sender, block.number.sub(1)) >= getProposerThresholdCount(),\n            \"Governance: proposer votes below proposal threshold.\"\n        );\n        require(\n            _targets.length == _values.length &&\n                _targets.length == _signatures.length &&\n                _targets.length == _calldatas.length,\n            \"Governance: proposal function information parity mismatch.\"\n        );\n        require(_targets.length != 0, \"Governance: must provide actions.\");\n        require(_targets.length <= dsGovernance.proposalMaxOperations, \"Governance: too many actions.\");\n\n        if (dsGovernance.latestProposalIds[msg.sender] != 0) {\n            // Ensure proposer doesn't already have one active/pending\n            GovernanceDefs.ProposalState proposersLatestProposalState =\n                state(dsGovernance.latestProposalIds[msg.sender]);\n            require(\n                proposersLatestProposalState != GovernanceDefs.ProposalState.Active,\n                \"Governance: one live proposal per proposer, found an already active proposal.\"\n            );\n            require(\n                proposersLatestProposalState != GovernanceDefs.ProposalState.Pending,\n                \"Governance: one live proposal per proposer, found an already pending proposal.\"\n            );\n        }\n\n        // Proposal voting starts votingDelay after proposal is made\n        uint256 startBlock = block.number.add(dsGovernance.votingDelay);\n\n        // Increment count of proposals\n        dsGovernance.proposalCount++;\n\n        // Create new proposal struct and add to mapping\n        GovernanceDefs.Proposal memory newProposal =\n            GovernanceDefs.Proposal({\n                id: dsGovernance.proposalCount,\n                proposer: msg.sender,\n                delay: getTimelockDelayForSignatures(_signatures),\n                eta: 0,\n                targets: _targets,\n                values: _values,\n                signatures: _signatures,\n                calldatas: _calldatas,\n                startBlock: startBlock,\n                endBlock: startBlock.add(dsGovernance.votingPeriod),\n                forVotes: 0,\n                againstVotes: 0,\n                canceled: false,\n                executed: false\n            });\n\n        dsGovernance.proposals[newProposal.id] = newProposal;\n\n        // Update proposer's latest proposal\n        dsGovernance.latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            _targets,\n            _values,\n            _signatures,\n            _calldatas,\n            startBlock,\n            startBlock.add(dsGovernance.votingPeriod),\n            _description\n        );\n        return newProposal.id;","after":"/\n    function propose(\n        address[] calldata _targets,\n        uint256[] calldata _values,\n        string[] calldata _signatures,\n        bytes[] calldata _calldatas,\n        string calldata _description\n    ) external returns (uint128) {\n        LibDiamondStorageDerivaDEX.DiamondStorageDerivaDEX storage dsDerivaDEX =\n            LibDiamondStorageDerivaDEX.diamondStorageDerivaDEX();\n        LibDiamondStorageGovernance.DiamondStorageGovernance storage dsGovernance =\n            LibDiamondStorageGovernance.diamondStorageGovernance();\n\n        // Ensure proposer has sufficient token holdings to propose\n        require(\n            dsDerivaDEX.ddxToken.getPriorVotes(msg.sender, block.number.sub(1)) >= getProposerThresholdCount(),\n            \"Governance: proposer votes below proposal threshold.\"\n        );\n        require(\n            _targets.length == _values.length &&\n                _targets.length == _signatures.length &&\n                _targets.length == _calldatas.length,\n            \"Governance: proposal function information parity mismatch.\"\n        );\n        require(_targets.length != 0, \"Governance: must provide actions.\");\n        require(_targets.length <= dsGovernance.proposalMaxOperations, \"Governance: too many actions.\");\n\n        if (dsGovernance.latestProposalIds[msg.sender] != 0) {\n            // Ensure proposer doesn't already have one active/pending\n            GovernanceDefs.ProposalState proposersLatestProposalState =\n                state(dsGovernance.latestProposalIds[msg.sender]);\n            require(\n                proposersLatestProposalState != GovernanceDefs.ProposalState.Active,\n                \"Governance: one live proposal per proposer, found an already active proposal.\"\n            );\n            require(\n                proposersLatestProposalState != GovernanceDefs.ProposalState.Pending,\n                \"Governance: one live proposal per proposer, found an already pending proposal.\"\n            );\n        }\n\n        // Proposal voting starts votingDelay after proposal is made\n        uint256 startBlock = block.number.add(dsGovernance.votingDelay);\n\n        // Increment count of proposals\n        dsGovernance.proposalCount++;\n\n        // Create new proposal struct and add to mapping\n        GovernanceDefs.Proposal memory newProposal =\n            GovernanceDefs.Proposal({\n                id: dsGovernance.proposalCount,\n                proposer: msg.sender,\n                delay: getTimelockDelayForSignatures(_signatures),\n                eta: 0,\n                targets: _targets,\n                values: _values,\n                signatures: _signatures,\n                calldatas: _calldatas,\n                startBlock: startBlock,\n                endBlock: startBlock.add(dsGovernance.votingPeriod),\n                forVotes: 0,\n                againstVotes: 0,\n                canceled: false,\n                executed: false\n            });\n\n        dsGovernance.proposals[newProposal.id] = newProposal;\n\n        // Update proposer's latest proposal\n        dsGovernance.latestProposalIds[newProposal.proposer] = newProposal.id;\n\n        emit ProposalCreated(\n            newProposal.id,\n            msg.sender,\n            _targets,\n            _values,\n            _signatures,\n            _calldatas,\n            startBlock,\n            startBlock.add(dsGovernance.votingPeriod),\n            _description\n        );\n        return newProposal.id;","contract":"Governance","time":0},{"type":"external-function ","before":"/\n    function castVoteBySig(\n        uint128 _proposalId,\n        bool _support,\n        bytes memory _signature\n    ) external {\n        // EIP712 hashing logic\n        bytes32 eip712OrderParamsDomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 voteCastHash =\n            LibVoteCast.getVoteCastHash(\n                LibVoteCast.VoteCast({ proposalId: _proposalId, support: _support }),\n                eip712OrderParamsDomainHash\n            );\n\n        // Recover the signature and EIP712 hash\n        uint8 v = uint8(_signature[0]);\n        bytes32 r = _signature.readBytes32(1);\n        bytes32 s = _signature.readBytes32(33);\n        address recovered = ecrecover(voteCastHash, v, r, s);\n\n        require(recovered != address(0), \"Governance: invalid signature.\");\n        return _castVote(recovered, _proposalId, _support);","after":"/\n    function castVoteBySig(\n        uint128 _proposalId,\n        bool _support,\n        bytes calldata _signature\n    ) external {\n        // EIP712 hashing logic\n        bytes32 eip712OrderParamsDomainHash = LibEIP712.hashEIP712Domain(name, version, getChainId(), address(this));\n        bytes32 voteCastHash =\n            LibVoteCast.getVoteCastHash(\n                LibVoteCast.VoteCast({ proposalId: _proposalId, support: _support }),\n                eip712OrderParamsDomainHash\n            );\n\n        // Recover the signature and EIP712 hash\n        uint8 v = uint8(_signature[0]);\n        bytes32 r = _signature.readBytes32(1);\n        bytes32 s = _signature.readBytes32(33);\n        address recovered = ecrecover(voteCastHash, v, r, s);\n\n        require(recovered != address(0), \"Governance: invalid signature.\");\n        return _castVote(recovered, _proposalId, _support);","contract":"Governance","time":1},{"type":"external-function ","before":"\n\n    function addBlacklist(address[] memory accounts) public onlyBlacklistAdmin returns (bool) {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _addBlacklist(accounts[i]);\n        }","after":"\n\n    function addBlacklist(address[] calldata accounts) public onlyBlacklistAdmin returns (bool) {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _addBlacklist(accounts[i]);\n        }","contract":"HDUMToken","time":0},{"type":"external-function ","before":"\n\n    function removeBlacklist(address[] memory accounts) public onlyBlacklistAdmin returns (bool) {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _removeBlacklist(accounts[i]);\n        }","after":"\n\n    function removeBlacklist(address[] calldata accounts) public onlyBlacklistAdmin returns (bool) {\n        for (uint256 i = 0; i < accounts.length; i++) {\n            _removeBlacklist(accounts[i]);\n        }","contract":"HDUMToken","time":0},{"type":"immutable-restrict-modification ","before":";\n    uint8 public dec","after":";\n    uint8 public dec","contract":"HDUMToken","time":2}]}