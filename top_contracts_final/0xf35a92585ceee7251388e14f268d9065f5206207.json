{"time":931,"results":[{"type":"constant-restrict-modification  ","before":"uint256 public version = 1;","after":"uint256 public constant version = 1;","contract":"FarmItemRecords","time":0},{"type":"immutable-restrict-modification ","before":"address public proxyRegistryAddress;","after":"address public immutable proxyRegistryAddress;","contract":"FarmItemRecords","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public version = 1;","after":"uint256 public constant version = 1;","contract":"FeeOwner","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public maximumFee;","after":"uint256 public immutable maximumFee;","contract":"FeeOwner","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"Fee1155","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"Fee1155","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public version = 1;","after":"uint256 public constant version = 1;","contract":"Fee1155","time":0},{"type":"immutable-restrict-modification ","before":"address public proxyRegistryAddress;","after":"address public immutable proxyRegistryAddress;","contract":"Fee1155","time":0},{"type":"external-function ","before":"function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","after":"function onERC1155Received(address, address, uint256, uint256, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","contract":"ShopEtherMinter1155Curated","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","after":"function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","contract":"ShopEtherMinter1155Curated","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public version = 1;","after":"uint256 public constant version = 1;","contract":"ShopEtherMinter1155Curated","time":0},{"type":"external-function ","before":"function addPool(PoolInput calldata pool, uint256[] calldata _groupIds, uint256[] calldata _amounts, PricePair[][] memory _pricePairs) external onlyOwner {\n    updatePool(nextPoolId, pool, _groupIds, _amounts, _pricePairs);\n\n    // Increment the ID which will be used by the next pool added.\n    nextPoolId = nextPoolId.add(1);\n  }","after":"function addPool(PoolInput calldata pool, uint256[] calldata _groupIds, uint256[] calldata _amounts, PricePair[][] calldata _pricePairs) external onlyOwner {\n    updatePool(nextPoolId, pool, _groupIds, _amounts, _pricePairs);\n\n    // Increment the ID which will be used by the next pool added.\n    nextPoolId = nextPoolId.add(1);\n  }","contract":"ShopPlatformLaunchpad1155","time":0},{"type":"external-function ","before":"function addWhitelist(WhitelistInput memory whitelist) external onlyOwner {\n    updateWhitelist(nextWhitelistId, whitelist);\n\n    // Increment the ID which will be used by the next whitelist added.\n    nextWhitelistId = nextWhitelistId.add(1);\n  }","after":"function addWhitelist(WhitelistInput calldata whitelist) external onlyOwner {\n    updateWhitelist(nextWhitelistId, whitelist);\n\n    // Increment the ID which will be used by the next whitelist added.\n    nextWhitelistId = nextWhitelistId.add(1);\n  }","contract":"ShopPlatformLaunchpad1155","time":0},{"type":"external-function ","before":"function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","after":"function onERC1155Received(address, address, uint256, uint256, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","contract":"ShopPlatformLaunchpad1155","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","after":"function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","contract":"ShopPlatformLaunchpad1155","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public version = 2;","after":"uint256 public constant version = 2;","contract":"ShopPlatformLaunchpad1155","time":1},{"type":"immutable-restrict-modification ","before":"uint256 public globalPurchaseLimit;","after":"uint256 public immutable globalPurchaseLimit;","contract":"ShopPlatformLaunchpad1155","time":1},{"type":"immutable-restrict-modification ","before":"address public originalOwner;","after":"address public immutable originalOwner;","contract":"ShopPlatformLaunchpad1155","time":1},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"Fee1155NFTLockable","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"Fee1155NFTLockable","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public version = 1;","after":"uint256 public constant version = 1;","contract":"Fee1155NFTLockable","time":0},{"type":"immutable-restrict-modification ","before":"address public proxyRegistryAddress;","after":"address public immutable proxyRegistryAddress;","contract":"Fee1155NFTLockable","time":0},{"type":"external-function ","before":"function setEmissions(EmissionPoint[] memory _tokenSchedule, EmissionPoint[] memory _pointSchedule) external onlyOwner {\n    if (_tokenSchedule.length > 0) {\n      require(canAlterTokenEmissionSchedule,\n        \"This Staker has locked the alteration of token emissions.\");\n      tokenEmissionBlockCount = _tokenSchedule.length;\n      for (uint256 i = 0; i < tokenEmissionBlockCount; i++) {\n        tokenEmissionBlocks[i] = _tokenSchedule[i];\n        if (earliestTokenEmissionBlock > _tokenSchedule[i].blockNumber) {\n          earliestTokenEmissionBlock = _tokenSchedule[i].blockNumber;\n        }\n      }\n    }\n    require(tokenEmissionBlockCount > 0,\n      \"You must set the token emission schedule.\");\n\n    if (_pointSchedule.length > 0) {\n      require(canAlterPointEmissionSchedule,\n        \"This Staker has locked the alteration of point emissions.\");\n      pointEmissionBlockCount = _pointSchedule.length;\n      for (uint256 i = 0; i < pointEmissionBlockCount; i++) {\n        pointEmissionBlocks[i] = _pointSchedule[i];\n        if (earliestPointEmissionBlock > _pointSchedule[i].blockNumber) {\n          earliestPointEmissionBlock = _pointSchedule[i].blockNumber;\n        }\n      }\n    }\n    require(tokenEmissionBlockCount > 0,\n      \"You must set the point emission schedule.\");\n  }","after":"function setEmissions(EmissionPoint[] calldata _tokenSchedule, EmissionPoint[] calldata _pointSchedule) external onlyOwner {\n    if (_tokenSchedule.length > 0) {\n      require(canAlterTokenEmissionSchedule,\n        \"This Staker has locked the alteration of token emissions.\");\n      tokenEmissionBlockCount = _tokenSchedule.length;\n      for (uint256 i = 0; i < tokenEmissionBlockCount; i++) {\n        tokenEmissionBlocks[i] = _tokenSchedule[i];\n        if (earliestTokenEmissionBlock > _tokenSchedule[i].blockNumber) {\n          earliestTokenEmissionBlock = _tokenSchedule[i].blockNumber;\n        }\n      }\n    }\n    require(tokenEmissionBlockCount > 0,\n      \"You must set the token emission schedule.\");\n\n    if (_pointSchedule.length > 0) {\n      require(canAlterPointEmissionSchedule,\n        \"This Staker has locked the alteration of point emissions.\");\n      pointEmissionBlockCount = _pointSchedule.length;\n      for (uint256 i = 0; i < pointEmissionBlockCount; i++) {\n        pointEmissionBlocks[i] = _pointSchedule[i];\n        if (earliestPointEmissionBlock > _pointSchedule[i].blockNumber) {\n          earliestPointEmissionBlock = _pointSchedule[i].blockNumber;\n        }\n      }\n    }\n    require(tokenEmissionBlockCount > 0,\n      \"You must set the point emission schedule.\");\n  }","contract":"Staker","time":0},{"type":"constant-restrict-modification  ","before":"uint256 MAX_INT = 2**256 - 1;","after":"uint256 constant MAX_INT = 2**256 - 1;","contract":"Staker","time":1},{"type":"external-function ","before":"function createFarm(string calldata _name, IERC20 _token, Staker.EmissionPoint[] memory _tokenSchedule, Staker.EmissionPoint[] memory _pointSchedule, PoolData[] calldata _initialPools) nonReentrant external returns (Staker) {\n    Staker newStaker = new Staker(_name, _token);\n\n    // Establish the emissions schedule and add the token pools.\n    newStaker.setEmissions(_tokenSchedule, _pointSchedule);\n    for (uint256 i = 0; i < _initialPools.length; i++) {\n      newStaker.addPool(_initialPools[i].poolToken, _initialPools[i].tokenStrength, _initialPools[i].pointStrength);\n    }\n\n    // Transfer ownership of the new Staker to the user then store a reference.\n    newStaker.transferOwnership(msg.sender);\n    address stakerAddress = address(newStaker);\n    farmRecords[msg.sender].push(stakerAddress);\n    emit FarmCreated(stakerAddress, msg.sender);\n    return newStaker;\n  }","after":"function createFarm(string calldata _name, IERC20 _token, Staker.EmissionPoint[] calldata _tokenSchedule, Staker.EmissionPoint[] calldata _pointSchedule, PoolData[] calldata _initialPools) nonReentrant external returns (Staker) {\n    Staker newStaker = new Staker(_name, _token);\n\n    // Establish the emissions schedule and add the token pools.\n    newStaker.setEmissions(_tokenSchedule, _pointSchedule);\n    for (uint256 i = 0; i < _initialPools.length; i++) {\n      newStaker.addPool(_initialPools[i].poolToken, _initialPools[i].tokenStrength, _initialPools[i].pointStrength);\n    }\n\n    // Transfer ownership of the new Staker to the user then store a reference.\n    newStaker.transferOwnership(msg.sender);\n    address stakerAddress = address(newStaker);\n    farmRecords[msg.sender].push(stakerAddress);\n    emit FarmCreated(stakerAddress, msg.sender);\n    return newStaker;\n  }","contract":"FarmStakerRecords","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public version = 1;","after":"uint256 public constant version = 1;","contract":"FarmStakerRecords","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public version = 1;","after":"uint256 public constant version = 1;","contract":"Token","time":0},{"type":"immutable-restrict-modification ","before":"uint256 private _cap;","after":"uint256 private immutable _cap;","contract":"Token","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public version = 1;","after":"uint256 public constant version = 1;","contract":"TokenVault","time":0},{"type":"immutable-restrict-modification ","before":"uint256 public panicLimit;","after":"uint256 public immutable panicLimit;","contract":"TokenVault","time":0},{"type":"external-function ","before":"function createClaim(address[] memory _beneficiaries, uint256[] memory _totalAmounts, uint64 _startTime, uint64 _endTime) external onlyOwner {\n    require(_beneficiaries.length > 0, \"You must specify at least one beneficiary for a claim.\");\n    require(_beneficiaries.length == _totalAmounts.length, \"Beneficiaries and their amounts may not be mismatched.\");\n    require(_endTime >= _startTime, \"You may not create a claim which ends before it starts.\");\n\n    // After validating the details for this token claim, initialize a claim for\n    // each specified beneficiary.\n    for (uint i = 0; i < _beneficiaries.length; i++) {\n      address _beneficiary = _beneficiaries[i];\n      uint256 _totalAmount = _totalAmounts[i];\n      require(_beneficiary != address(0), \"The zero address may not be a beneficiary.\");\n      require(_totalAmount > 0, \"You may not create a zero-token claim.\");\n\n      // Establish a claim for this particular beneficiary.\n      Claim memory claim = Claim({\n        totalAmount: _totalAmount,\n        startTime: _startTime,\n        endTime: _endTime,\n        lastClaimTime: _startTime,\n        amountClaimed: 0\n      });\n      claims[_beneficiary] = claim;\n      emit ClaimCreated(msg.sender, _beneficiary);\n    }\n  }","after":"function createClaim(address[] calldata _beneficiaries, uint256[] calldata _totalAmounts, uint64 _startTime, uint64 _endTime) external onlyOwner {\n    require(_beneficiaries.length > 0, \"You must specify at least one beneficiary for a claim.\");\n    require(_beneficiaries.length == _totalAmounts.length, \"Beneficiaries and their amounts may not be mismatched.\");\n    require(_endTime >= _startTime, \"You may not create a claim which ends before it starts.\");\n\n    // After validating the details for this token claim, initialize a claim for\n    // each specified beneficiary.\n    for (uint i = 0; i < _beneficiaries.length; i++) {\n      address _beneficiary = _beneficiaries[i];\n      uint256 _totalAmount = _totalAmounts[i];\n      require(_beneficiary != address(0), \"The zero address may not be a beneficiary.\");\n      require(_totalAmount > 0, \"You may not create a zero-token claim.\");\n\n      // Establish a claim for this particular beneficiary.\n      Claim memory claim = Claim({\n        totalAmount: _totalAmount,\n        startTime: _startTime,\n        endTime: _endTime,\n        lastClaimTime: _startTime,\n        amountClaimed: 0\n      });\n      claims[_beneficiary] = claim;\n      emit ClaimCreated(msg.sender, _beneficiary);\n    }\n  }","contract":"VestStream","time":0},{"type":"external-function ","before":"function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","after":"function onERC1155Received(address, address, uint256, uint256, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","contract":"ShopEtherMinter1155","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","after":"function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","contract":"ShopEtherMinter1155","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public version = 1;","after":"uint256 public constant version = 1;","contract":"ShopEtherMinter1155","time":0},{"type":"external-function ","before":"function createClaim(\n        address _beneficiary,\n        uint256[] memory _timePeriods,\n        uint256[] memory _tokenAmounts\n    ) public returns (bool) {\n        require(\n            _timePeriods.length == _tokenAmounts.length,\n            \"_timePeriods & _tokenAmounts length mismatch\"\n        );\n        require(tokenAddress.isContract(), \"Invalid tokenAddress\");\n        require(_beneficiary != address(0), \"Cannot Vest to address 0\");\n        // Calculate total amount\n        uint256 _totalAmount = 0;\n        for (uint256 i = 0; i < _tokenAmounts.length; i++) {\n            _totalAmount = _totalAmount.add(_tokenAmounts[i]);\n        }\n        require(_totalAmount > 0, \"Provide Token Amounts to Vest\");\n        require(\n            ERC20(tokenAddress).allowance(msg.sender, address(this)) >=\n                _totalAmount,\n            \"Provide token allowance to SuperVestCliff contract\"\n        );\n        // Transfer Tokens to SuperStreamClaim\n        ERC20(tokenAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _totalAmount\n        );\n        // Create Claim\n        Claim memory claim =\n            Claim({\n                owner: msg.sender,\n                beneficiary: _beneficiary,\n                timePeriods: _timePeriods,\n                tokenAmounts: _tokenAmounts,\n                totalAmount: _totalAmount,\n                amountClaimed: 0,\n                periodsClaimed: 0\n            });\n        claims.push(claim);\n        uint256 index = claims.length - 1;\n        // Map Claim Index to Owner & Beneficiary\n        _ownerClaims[msg.sender].push(index);\n        _beneficiaryClaims[_beneficiary].push(index);\n        emit ClaimCreated(msg.sender, _beneficiary, index);\n        return true;\n    }","after":"function createClaim(\n        address _beneficiary,\n        uint256[] calldata _timePeriods,\n        uint256[] calldata _tokenAmounts\n    ) public returns (bool) {\n        require(\n            _timePeriods.length == _tokenAmounts.length,\n            \"_timePeriods & _tokenAmounts length mismatch\"\n        );\n        require(tokenAddress.isContract(), \"Invalid tokenAddress\");\n        require(_beneficiary != address(0), \"Cannot Vest to address 0\");\n        // Calculate total amount\n        uint256 _totalAmount = 0;\n        for (uint256 i = 0; i < _tokenAmounts.length; i++) {\n            _totalAmount = _totalAmount.add(_tokenAmounts[i]);\n        }\n        require(_totalAmount > 0, \"Provide Token Amounts to Vest\");\n        require(\n            ERC20(tokenAddress).allowance(msg.sender, address(this)) >=\n                _totalAmount,\n            \"Provide token allowance to SuperVestCliff contract\"\n        );\n        // Transfer Tokens to SuperStreamClaim\n        ERC20(tokenAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _totalAmount\n        );\n        // Create Claim\n        Claim memory claim =\n            Claim({\n                owner: msg.sender,\n                beneficiary: _beneficiary,\n                timePeriods: _timePeriods,\n                tokenAmounts: _tokenAmounts,\n                totalAmount: _totalAmount,\n                amountClaimed: 0,\n                periodsClaimed: 0\n            });\n        claims.push(claim);\n        uint256 index = claims.length - 1;\n        // Map Claim Index to Owner & Beneficiary\n        _ownerClaims[msg.sender].push(index);\n        _beneficiaryClaims[_beneficiary].push(index);\n        emit ClaimCreated(msg.sender, _beneficiary, index);\n        return true;\n    }","contract":"SuperVestCliff","time":0},{"type":"immutable-restrict-modification ","before":"address public tokenAddress;","after":"address public immutable tokenAddress;","contract":"SuperVestCliff","time":0},{"type":"immutable-restrict-modification ","before":"address public tokenAddress;","after":"address public immutable tokenAddress;","contract":"SuperNFTVestStream","time":0},{"type":"immutable-restrict-modification ","before":"address public nftAddress;","after":"address public immutable nftAddress;","contract":"SuperNFTVestStream","time":0},{"type":"external-function ","before":"function createClaim(\n        uint256 _nftId,\n        uint256[] memory _timePeriods,\n        uint256[] memory _tokenAmounts\n    ) public returns (bool) {\n        require(_nftId != 0, \"Cannot Vest to NFT 0\");\n        require(\n            _timePeriods.length == _tokenAmounts.length,\n            \"_timePeriods & _tokenAmounts length mismatch\"\n        );\n        // Calculate total amount\n        uint256 _totalAmount = 0;\n        for (uint256 i = 0; i < _tokenAmounts.length; i++) {\n            _totalAmount = _totalAmount.add(_tokenAmounts[i]);\n        }\n        require(_totalAmount > 0, \"Provide Token Amounts to Vest\");\n        require(\n            ERC20(tokenAddress).allowance(msg.sender, address(this)) >=\n                _totalAmount,\n            \"Provide token allowance to SuperStreamClaim contract\"\n        );\n        // Transfer Tokens to SuperStreamClaim\n        ERC20(tokenAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _totalAmount\n        );\n        // Create Claim\n        Claim memory claim =\n            Claim({\n                owner: msg.sender,\n                nftId: _nftId,\n                timePeriods: _timePeriods,\n                tokenAmounts: _tokenAmounts,\n                totalAmount: _totalAmount,\n                amountClaimed: 0,\n                periodsClaimed: 0\n            });\n        claims.push(claim);\n        uint256 index = claims.length.sub(1);\n        // Map Claim Index to Owner & Beneficiary\n        _ownerClaims[msg.sender].push(index);\n        _nftClaims[_nftId].push(index);\n        emit ClaimCreated(msg.sender, _nftId, _totalAmount, index);\n        return true;\n    }","after":"function createClaim(\n        uint256 _nftId,\n        uint256[] calldata _timePeriods,\n        uint256[] calldata _tokenAmounts\n    ) public returns (bool) {\n        require(_nftId != 0, \"Cannot Vest to NFT 0\");\n        require(\n            _timePeriods.length == _tokenAmounts.length,\n            \"_timePeriods & _tokenAmounts length mismatch\"\n        );\n        // Calculate total amount\n        uint256 _totalAmount = 0;\n        for (uint256 i = 0; i < _tokenAmounts.length; i++) {\n            _totalAmount = _totalAmount.add(_tokenAmounts[i]);\n        }\n        require(_totalAmount > 0, \"Provide Token Amounts to Vest\");\n        require(\n            ERC20(tokenAddress).allowance(msg.sender, address(this)) >=\n                _totalAmount,\n            \"Provide token allowance to SuperStreamClaim contract\"\n        );\n        // Transfer Tokens to SuperStreamClaim\n        ERC20(tokenAddress).transferFrom(\n            msg.sender,\n            address(this),\n            _totalAmount\n        );\n        // Create Claim\n        Claim memory claim =\n            Claim({\n                owner: msg.sender,\n                nftId: _nftId,\n                timePeriods: _timePeriods,\n                tokenAmounts: _tokenAmounts,\n                totalAmount: _totalAmount,\n                amountClaimed: 0,\n                periodsClaimed: 0\n            });\n        claims.push(claim);\n        uint256 index = claims.length.sub(1);\n        // Map Claim Index to Owner & Beneficiary\n        _ownerClaims[msg.sender].push(index);\n        _nftClaims[_nftId].push(index);\n        emit ClaimCreated(msg.sender, _nftId, _totalAmount, index);\n        return true;\n    }","contract":"SuperNFTVestCliff","time":0},{"type":"immutable-restrict-modification ","before":"address public tokenAddress;","after":"address public immutable tokenAddress;","contract":"SuperNFTVestCliff","time":0},{"type":"immutable-restrict-modification ","before":"address public nftAddress;","after":"address public immutable nftAddress;","contract":"SuperNFTVestCliff","time":0},{"type":"external-function ","before":"function issueToken(\n        address recipient,\n        string memory hash,\n        string memory data\n    ) public returns (uint256) {\n        require(hashes[hash] != 1);\n        hashes[hash] = 1;\n        _tokenIds.increment();\n        uint256 newTokenId = _tokenIds.current();\n        _mint(recipient, newTokenId);\n        _setTokenURI(newTokenId, data);\n        return newTokenId;\n    }","after":"function issueToken(\n        address recipient,\n        string calldata hash,\n        string calldata data\n    ) public returns (uint256) {\n        require(hashes[hash] != 1);\n        hashes[hash] = 1;\n        _tokenIds.increment();\n        uint256 newTokenId = _tokenIds.current();\n        _mint(recipient, newTokenId);\n        _setTokenURI(newTokenId, data);\n        return newTokenId;\n    }","contract":"SuperNFT","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][from] = _balances[id][from].sub(amount, \"ERC1155: insufficient balance for transfer\");\n        _balances[id][to] = _balances[id][to].add(amount);\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }","contract":"Fee1155NFT","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    )\n        public\n        virtual\n        override\n    {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            _balances[id][from] = _balances[id][from].sub(\n                amount,\n                \"ERC1155: insufficient balance for transfer\"\n            );\n            _balances[id][to] = _balances[id][to].add(amount);\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }","contract":"Fee1155NFT","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public version = 1;","after":"uint256 public constant version = 1;","contract":"Fee1155NFT","time":0},{"type":"immutable-restrict-modification ","before":"address public proxyRegistryAddress;","after":"address public immutable proxyRegistryAddress;","contract":"Fee1155NFT","time":0},{"type":"external-function ","before":"function addStakers(Staker[] memory _stakers) external onlyOwner {\n    for (uint256 i = 0; i < _stakers.length; i++) {\n      stakers.push(_stakers[i]);\n    }\n  }","after":"function addStakers(Staker[] calldata _stakers) external onlyOwner {\n    for (uint256 i = 0; i < _stakers.length; i++) {\n      stakers.push(_stakers[i]);\n    }\n  }","contract":"Shop1155","time":0},{"type":"external-function ","before":"function listItems(PricePair[] memory _pricePairs, Fee1155[] calldata _items, uint256[][] calldata _ids, uint256[][] calldata _amounts) external nonReentrant onlyOwner {\n    require(_items.length > 0,\n      \"You must list at least one item.\");\n    require(_items.length == _ids.length,\n      \"Items length cannot be mismatched with IDs length.\");\n    require(_items.length == _amounts.length,\n      \"Items length cannot be mismatched with amounts length.\");\n\n    // Iterate through every specified Fee1155 contract to list items.\n    for (uint256 i = 0; i < _items.length; i++) {\n      Fee1155 item = _items[i];\n      uint256[] memory ids = _ids[i];\n      uint256[] memory amounts = _amounts[i];\n      require(ids.length > 0,\n        \"You must specify at least one item ID.\");\n      require(ids.length == amounts.length,\n        \"Item IDs length cannot be mismatched with amounts length.\");\n\n      // For each Fee1155 contract, add the requested item IDs to the Shop.\n      for (uint256 j = 0; j < ids.length; j++) {\n        uint256 id = ids[j];\n        uint256 amount = amounts[j];\n        require(amount > 0,\n          \"You cannot list an item with no starting amount.\");\n        inventory[nextItemId + j] = ShopItem({\n          token: item,\n          id: id,\n          amount: amount\n        });\n        for (uint k = 0; k < _pricePairs.length; k++) {\n          prices[nextItemId + j][k] = _pricePairs[k];\n        }\n        pricePairLengths[nextItemId + j] = _pricePairs.length;\n      }\n      nextItemId = nextItemId.add(ids.length);\n\n      // Batch transfer the listed items to the Shop contract.\n      item.safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    }\n  }","after":"function listItems(PricePair[] calldata _pricePairs, Fee1155[] calldata _items, uint256[][] calldata _ids, uint256[][] calldata _amounts) external nonReentrant onlyOwner {\n    require(_items.length > 0,\n      \"You must list at least one item.\");\n    require(_items.length == _ids.length,\n      \"Items length cannot be mismatched with IDs length.\");\n    require(_items.length == _amounts.length,\n      \"Items length cannot be mismatched with amounts length.\");\n\n    // Iterate through every specified Fee1155 contract to list items.\n    for (uint256 i = 0; i < _items.length; i++) {\n      Fee1155 item = _items[i];\n      uint256[] memory ids = _ids[i];\n      uint256[] memory amounts = _amounts[i];\n      require(ids.length > 0,\n        \"You must specify at least one item ID.\");\n      require(ids.length == amounts.length,\n        \"Item IDs length cannot be mismatched with amounts length.\");\n\n      // For each Fee1155 contract, add the requested item IDs to the Shop.\n      for (uint256 j = 0; j < ids.length; j++) {\n        uint256 id = ids[j];\n        uint256 amount = amounts[j];\n        require(amount > 0,\n          \"You cannot list an item with no starting amount.\");\n        inventory[nextItemId + j] = ShopItem({\n          token: item,\n          id: id,\n          amount: amount\n        });\n        for (uint k = 0; k < _pricePairs.length; k++) {\n          prices[nextItemId + j][k] = _pricePairs[k];\n        }\n        pricePairLengths[nextItemId + j] = _pricePairs.length;\n      }\n      nextItemId = nextItemId.add(ids.length);\n\n      // Batch transfer the listed items to the Shop contract.\n      item.safeBatchTransferFrom(msg.sender, address(this), ids, amounts, \"\");\n    }\n  }","contract":"Shop1155","time":0},{"type":"external-function ","before":"function changeItemPrice(uint256 _itemId, PricePair[] memory _pricePairs) external onlyOwner {\n    for (uint i = 0; i < _pricePairs.length; i++) {\n      prices[_itemId][i] = _pricePairs[i];\n    }\n    pricePairLengths[_itemId] = _pricePairs.length;\n  }","after":"function changeItemPrice(uint256 _itemId, PricePair[] calldata _pricePairs) external onlyOwner {\n    for (uint i = 0; i < _pricePairs.length; i++) {\n      prices[_itemId][i] = _pricePairs[i];\n    }\n    pricePairLengths[_itemId] = _pricePairs.length;\n  }","contract":"Shop1155","time":0},{"type":"external-function ","before":"function onERC1155Received(address, address, uint256, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","after":"function onERC1155Received(address, address, uint256, uint256, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }","contract":"Shop1155","time":0},{"type":"external-function ","before":"function onERC1155BatchReceived(address, address, uint256[] memory, uint256[] memory, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","after":"function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }","contract":"Shop1155","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public version = 1;","after":"uint256 public constant version = 1;","contract":"Shop1155","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public version = 1;","after":"uint256 public constant version = 1;","contract":"FarmShopRecords","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public version = 1;","after":"uint256 public constant version = 1;","contract":"FarmTokenRecords","time":0},{"type":"external-function ","before":"function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n    require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n    require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }","after":"function queueTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) public returns (bytes32) {\n    require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n    require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }","contract":"Timelock","time":0},{"type":"external-function ","before":"function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n    require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }","after":"function cancelTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) public {\n    require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }","contract":"Timelock","time":0},{"type":"external-function ","before":"function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n    require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n    require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n    require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n        callData = data;\n    } else {\n        callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n    require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }","after":"function executeTransaction(address target, uint value, string calldata signature, bytes calldata data, uint eta) public payable returns (bytes memory) {\n    require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n    require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n    require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n        callData = data;\n    } else {\n        callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n    require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }","contract":"Timelock","time":0}]}