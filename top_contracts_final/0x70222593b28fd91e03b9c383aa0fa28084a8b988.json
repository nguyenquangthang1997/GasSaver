{"time":205,"results":[{"type":"external-function ","before":"ng ECDSA for bytes32; \n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIdCounter;\n\n    address private signerAddress;\n\n    struct Blocker {\n        string handle;\n        string asset;\n        string image;\n        string name;\n        bool exists;\n        uint id;\n        uint numBlocks;\n        mapping (uint => Block) blocks;\n    }\n\n    struct Block {\n        bool exists;\n        uint tokenId;\n        uint blockNum;\n        string timeString;\n    }\n\n    struct Token {\n        uint blockerId;\n        uint b","after":"ng ECDSA for bytes32; \n    using Counters for Counters.Counter;\n\n    Counters.Counter private _tokenIdCounter;\n\n    address private signerAddress;\n\n    struct Blocker {\n        string handle;\n        string asset;\n        string image;\n        string name;\n        bool exists;\n        uint id;\n        uint numBlocks;\n        mapping (uint => Block) blocks;\n    }\n\n    struct Block {\n        bool exists;\n        uint tokenId;\n        uint blockNum;\n        string timeString;\n    }\n\n    struct Token {\n        uint blockerId;\n        uint b","contract":"Blockedchain","time":0},{"type":"external-function ","before":"ner{\n        signerAddress = newSigner;\n    }\n\n    function addBlockers(NewBlocker[] memory newBlockers) public onlyOwner{\n        for(uint i=0; i<newBlockers.length; i++){\n            Blocker storage blocker = blockers[newBlockers[i].id];\n            blocker.handle = newBlockers[i].handle;\n            blocker.asset = newBlockers[i].asset;\n            blocker.image = newBlockers[i].image;\n            blocker.name = newBlockers[i].name;\n            if(!blocker.exists){\n                blocker.exists = true;\n                blocker.numBlocks = 0;\n            }\n            \n        }\n    }\n\n    function pauseBlocker(uint256 id) public onlyOwner {\n        blockers[id].exists = false;\n    }\n\n    function unpauseBlocker(uint256 id) public onlyOwner {\n        blockers[id].exists = true;\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    function mint(\n        uint blockeeId,\n        uint blockerId,\n        uint deadline,\n        string memory timeString,\n        bytes memory signature\n    ) public whenNotPaused {\n        // Check signature is valid\n        require(verifyMessage(blockeeId, blockerId, deadline, timeString, signature), 'INVALID_SIG');\n        // Check deadline hasn't passed\n        require(deadline >= block.timestamp, 'DEADLINE_","after":"ner{\n        signerAddress = newSigner;\n    }\n\n    function addBlockers(NewBlocker[] calldata newBlockers) public onlyOwner{\n        for(uint i=0; i<newBlockers.length; i++){\n            Blocker storage blocker = blockers[newBlockers[i].id];\n            blocker.handle = newBlockers[i].handle;\n            blocker.asset = newBlockers[i].asset;\n            blocker.image = newBlockers[i].image;\n            blocker.name = newBlockers[i].name;\n            if(!blocker.exists){\n                blocker.exists = true;\n                blocker.numBlocks = 0;\n            }\n            \n        }\n    }\n\n    function pauseBlocker(uint256 id) public onlyOwner {\n        blockers[id].exists = false;\n    }\n\n    function unpauseBlocker(uint256 id) public onlyOwner {\n        blockers[id].exists = true;\n    }\n\n    function pause() public onlyOwner {\n        _pause();\n    }\n\n    function unpause() public onlyOwner {\n        _unpause();\n    }\n\n    function mint(\n        uint blockeeId,\n        uint blockerId,\n        uint deadline,\n        string memory timeString,\n        bytes memory signature\n    ) public whenNotPaused {\n        // Check signature is valid\n        require(verifyMessage(blockeeId, blockerId, deadline, timeString, signature), 'INVALID_SIG');\n        // Check deadline hasn't passed\n        require(deadline >= block.timestamp, 'DEADLINE_","contract":"Blockedchain","time":0}]}