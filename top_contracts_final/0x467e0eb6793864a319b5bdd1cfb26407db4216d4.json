{"time":284,"results":[{"type":"external-function ","before":"function redeemCoupon(\n        DaoRegistry dao,\n        address authorizedMember,\n        uint256 amount,\n        uint256 nonce,\n        bytes memory signature\n    ) external reentrancyGuard(dao) {\n        uint256 currentFlag = flags[address(dao)][nonce / 256];\n        require(\n            getFlag(currentFlag, nonce % 256) == false,\n            \"coupon has already been redeemed\"\n        );\n\n        address signerAddress =\n            dao.getAddressConfiguration(SignerAddressConfig);\n\n        Coupon memory coupon = Coupon(authorizedMember, amount, nonce);\n        bytes32 hash = hashCouponMessage(dao, coupon);\n\n        address recoveredKey = ECDSA.recover(hash, signature);\n\n        require(recoveredKey == signerAddress, \"invalid sig\");\n\n        flags[address(dao)][nonce / 256] = setFlag(\n            currentFlag,\n            nonce % 256,\n            true\n        );\n\n        address tokenAddrToMint =\n            address(dao.getAddressConfiguration(TokenAddrToMint));\n\n        BankExtension bank = BankExtension(dao.getExtensionAddress(BANK));\n\n        bank.addToBalance(authorizedMember, tokenAddrToMint, amount);\n        // address needs to be added to the members mappings\n        potentialNewMember(authorizedMember, dao, bank);\n        emit CouponRedeemed(address(dao), nonce, authorizedMember, amount);\n    }","after":"function redeemCoupon(\n        DaoRegistry dao,\n        address authorizedMember,\n        uint256 amount,\n        uint256 nonce,\n        bytes calldata signature\n    ) external reentrancyGuard(dao) {\n        uint256 currentFlag = flags[address(dao)][nonce / 256];\n        require(\n            getFlag(currentFlag, nonce % 256) == false,\n            \"coupon has already been redeemed\"\n        );\n\n        address signerAddress =\n            dao.getAddressConfiguration(SignerAddressConfig);\n\n        Coupon memory coupon = Coupon(authorizedMember, amount, nonce);\n        bytes32 hash = hashCouponMessage(dao, coupon);\n\n        address recoveredKey = ECDSA.recover(hash, signature);\n\n        require(recoveredKey == signerAddress, \"invalid sig\");\n\n        flags[address(dao)][nonce / 256] = setFlag(\n            currentFlag,\n            nonce % 256,\n            true\n        );\n\n        address tokenAddrToMint =\n            address(dao.getAddressConfiguration(TokenAddrToMint));\n\n        BankExtension bank = BankExtension(dao.getExtensionAddress(BANK));\n\n        bank.addToBalance(authorizedMember, tokenAddrToMint, amount);\n        // address needs to be added to the members mappings\n        potentialNewMember(authorizedMember, dao, bank);\n        emit CouponRedeemed(address(dao), nonce, authorizedMember, amount);\n    }","contract":"CouponOnboardingContract","time":0},{"type":"immutable-restrict-modification ","before":"uint256 chainId;","after":"uint256 immutable chainId;","contract":"CouponOnboardingContract","time":0}]}