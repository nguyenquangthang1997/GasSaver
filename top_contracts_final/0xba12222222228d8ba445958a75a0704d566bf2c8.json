{"time":734,"results":[{"type":"external-function ","before":"function flashLoan(\n        IFlashLoanRecipient recipient,\n        IERC20[] memory tokens,\n        uint256[] memory amounts,\n        bytes memory userData\n    ) external override nonReentrant whenNotPaused {\n        InputHelpers.ensureInputLengthMatch(tokens.length, amounts.length);\n\n        uint256[] memory feeAmounts = new uint256[](tokens.length);\n        uint256[] memory preLoanBalances = new uint256[](tokens.length);\n\n        // Used to ensure `tokens` is sorted in ascending order, which ensures token uniqueness.\n        IERC20 previousToken = IERC20(0);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            uint256 amount = amounts[i];\n\n            _require(token > previousToken, token == IERC20(0) ? Errors.ZERO_TOKEN : Errors.UNSORTED_TOKENS);\n            previousToken = token;\n\n            preLoanBalances[i] = token.balanceOf(address(this));\n            feeAmounts[i] = _calculateFlashLoanFeeAmount(amount);\n\n            _require(preLoanBalances[i] >= amount, Errors.INSUFFICIENT_FLASH_LOAN_BALANCE);\n            token.safeTransfer(address(recipient), amount);\n        }\n\n        recipient.receiveFlashLoan(tokens, amounts, feeAmounts, userData);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            uint256 preLoanBalance = preLoanBalances[i];\n\n            // Checking for loan repayment first (without accounting for fees) makes for simpler debugging, and results\n            // in more accurate revert reasons if the flash loan protocol fee percentage is zero.\n            uint256 postLoanBalance = token.balanceOf(address(this));\n            _require(postLoanBalance >= preLoanBalance, Errors.INVALID_POST_LOAN_BALANCE);\n\n            // No need for checked arithmetic since we know the loan was fully repaid.\n            uint256 receivedFeeAmount = postLoanBalance - preLoanBalance;\n            _require(receivedFeeAmount >= feeAmounts[i], Errors.INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT);\n\n            _payFeeAmount(token, receivedFeeAmount);\n            emit FlashLoan(recipient, token, amounts[i], receivedFeeAmount);\n        }\n    }","after":"function flashLoan(\n        IFlashLoanRecipient recipient,\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes calldata userData\n    ) external override nonReentrant whenNotPaused {\n        InputHelpers.ensureInputLengthMatch(tokens.length, amounts.length);\n\n        uint256[] memory feeAmounts = new uint256[](tokens.length);\n        uint256[] memory preLoanBalances = new uint256[](tokens.length);\n\n        // Used to ensure `tokens` is sorted in ascending order, which ensures token uniqueness.\n        IERC20 previousToken = IERC20(0);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            uint256 amount = amounts[i];\n\n            _require(token > previousToken, token == IERC20(0) ? Errors.ZERO_TOKEN : Errors.UNSORTED_TOKENS);\n            previousToken = token;\n\n            preLoanBalances[i] = token.balanceOf(address(this));\n            feeAmounts[i] = _calculateFlashLoanFeeAmount(amount);\n\n            _require(preLoanBalances[i] >= amount, Errors.INSUFFICIENT_FLASH_LOAN_BALANCE);\n            token.safeTransfer(address(recipient), amount);\n        }\n\n        recipient.receiveFlashLoan(tokens, amounts, feeAmounts, userData);\n\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            uint256 preLoanBalance = preLoanBalances[i];\n\n            // Checking for loan repayment first (without accounting for fees) makes for simpler debugging, and results\n            // in more accurate revert reasons if the flash loan protocol fee percentage is zero.\n            uint256 postLoanBalance = token.balanceOf(address(this));\n            _require(postLoanBalance >= preLoanBalance, Errors.INVALID_POST_LOAN_BALANCE);\n\n            // No need for checked arithmetic since we know the loan was fully repaid.\n            uint256 receivedFeeAmount = postLoanBalance - preLoanBalance;\n            _require(receivedFeeAmount >= feeAmounts[i], Errors.INSUFFICIENT_FLASH_LOAN_FEE_AMOUNT);\n\n            _payFeeAmount(token, receivedFeeAmount);\n            emit FlashLoan(recipient, token, amounts[i], receivedFeeAmount);\n        }\n    }","contract":"Vault","time":0},{"type":"external-function ","before":"function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        nonReentrant\n        whenNotPaused\n        authenticateFor(funds.sender)\n        returns (uint256 amountCalculated)\n    {\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\n        // solhint-disable-next-line not-rely-on-time\n        _require(block.timestamp <= deadline, Errors.SWAP_DEADLINE);\n\n        // This revert reason is for consistency with `batchSwap`: an equivalent `swap` performed using that function\n        // would result in this error.\n        _require(singleSwap.amount > 0, Errors.UNKNOWN_AMOUNT_IN_FIRST_SWAP);\n\n        IERC20 tokenIn = _translateToIERC20(singleSwap.assetIn);\n        IERC20 tokenOut = _translateToIERC20(singleSwap.assetOut);\n        _require(tokenIn != tokenOut, Errors.CANNOT_SWAP_SAME_TOKEN);\n\n        // Initializing each struct field one-by-one uses less gas than setting all at once.\n        IPoolSwapStructs.SwapRequest memory poolRequest;\n        poolRequest.poolId = singleSwap.poolId;\n        poolRequest.kind = singleSwap.kind;\n        poolRequest.tokenIn = tokenIn;\n        poolRequest.tokenOut = tokenOut;\n        poolRequest.amount = singleSwap.amount;\n        poolRequest.userData = singleSwap.userData;\n        poolRequest.from = funds.sender;\n        poolRequest.to = funds.recipient;\n        // The lastChangeBlock field is left uninitialized.\n\n        uint256 amountIn;\n        uint256 amountOut;\n\n        (amountCalculated, amountIn, amountOut) = _swapWithPool(poolRequest);\n        _require(singleSwap.kind == SwapKind.GIVEN_IN ? amountOut >= limit : amountIn <= limit, Errors.SWAP_LIMIT);\n\n        _receiveAsset(singleSwap.assetIn, amountIn, funds.sender, funds.fromInternalBalance);\n        _sendAsset(singleSwap.assetOut, amountOut, funds.recipient, funds.toInternalBalance);\n\n        // If the asset in is ETH, then `amountIn` ETH was wrapped into WETH.\n        _handleRemainingEth(_isETH(singleSwap.assetIn) ? amountIn : 0);\n    }","after":"function swap(\n        SingleSwap calldata singleSwap,\n        FundManagement calldata funds,\n        uint256 limit,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        nonReentrant\n        whenNotPaused\n        authenticateFor(funds.sender)\n        returns (uint256 amountCalculated)\n    {\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\n        // solhint-disable-next-line not-rely-on-time\n        _require(block.timestamp <= deadline, Errors.SWAP_DEADLINE);\n\n        // This revert reason is for consistency with `batchSwap`: an equivalent `swap` performed using that function\n        // would result in this error.\n        _require(singleSwap.amount > 0, Errors.UNKNOWN_AMOUNT_IN_FIRST_SWAP);\n\n        IERC20 tokenIn = _translateToIERC20(singleSwap.assetIn);\n        IERC20 tokenOut = _translateToIERC20(singleSwap.assetOut);\n        _require(tokenIn != tokenOut, Errors.CANNOT_SWAP_SAME_TOKEN);\n\n        // Initializing each struct field one-by-one uses less gas than setting all at once.\n        IPoolSwapStructs.SwapRequest memory poolRequest;\n        poolRequest.poolId = singleSwap.poolId;\n        poolRequest.kind = singleSwap.kind;\n        poolRequest.tokenIn = tokenIn;\n        poolRequest.tokenOut = tokenOut;\n        poolRequest.amount = singleSwap.amount;\n        poolRequest.userData = singleSwap.userData;\n        poolRequest.from = funds.sender;\n        poolRequest.to = funds.recipient;\n        // The lastChangeBlock field is left uninitialized.\n\n        uint256 amountIn;\n        uint256 amountOut;\n\n        (amountCalculated, amountIn, amountOut) = _swapWithPool(poolRequest);\n        _require(singleSwap.kind == SwapKind.GIVEN_IN ? amountOut >= limit : amountIn <= limit, Errors.SWAP_LIMIT);\n\n        _receiveAsset(singleSwap.assetIn, amountIn, funds.sender, funds.fromInternalBalance);\n        _sendAsset(singleSwap.assetOut, amountOut, funds.recipient, funds.toInternalBalance);\n\n        // If the asset in is ETH, then `amountIn` ETH was wrapped into WETH.\n        _handleRemainingEth(_isETH(singleSwap.assetIn) ? amountIn : 0);\n    }","contract":"Vault","time":0},{"type":"external-function ","before":"function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        nonReentrant\n        whenNotPaused\n        authenticateFor(funds.sender)\n        returns (int256[] memory assetDeltas)\n    {\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\n        // solhint-disable-next-line not-rely-on-time\n        _require(block.timestamp <= deadline, Errors.SWAP_DEADLINE);\n\n        InputHelpers.ensureInputLengthMatch(assets.length, limits.length);\n\n        // Perform the swaps, updating the Pool token balances and computing the net Vault asset deltas.\n        assetDeltas = _swapWithPools(swaps, assets, funds, kind);\n\n        // Process asset deltas, by either transferring assets from the sender (for positive deltas) or to the recipient\n        // (for negative deltas).\n        uint256 wrappedEth = 0;\n        for (uint256 i = 0; i < assets.length; ++i) {\n            IAsset asset = assets[i];\n            int256 delta = assetDeltas[i];\n            _require(delta <= limits[i], Errors.SWAP_LIMIT);\n\n            if (delta > 0) {\n                uint256 toReceive = uint256(delta);\n                _receiveAsset(asset, toReceive, funds.sender, funds.fromInternalBalance);\n\n                if (_isETH(asset)) {\n                    wrappedEth = wrappedEth.add(toReceive);\n                }\n            } else if (delta < 0) {\n                uint256 toSend = uint256(-delta);\n                _sendAsset(asset, toSend, funds.recipient, funds.toInternalBalance);\n            }\n        }\n\n        // Handle any used and remaining ETH.\n        _handleRemainingEth(wrappedEth);\n    }","after":"function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] calldata swaps,\n        IAsset[] calldata assets,\n        FundManagement calldata funds,\n        int256[] calldata limits,\n        uint256 deadline\n    )\n        external\n        payable\n        override\n        nonReentrant\n        whenNotPaused\n        authenticateFor(funds.sender)\n        returns (int256[] memory assetDeltas)\n    {\n        // The deadline is timestamp-based: it should not be relied upon for sub-minute accuracy.\n        // solhint-disable-next-line not-rely-on-time\n        _require(block.timestamp <= deadline, Errors.SWAP_DEADLINE);\n\n        InputHelpers.ensureInputLengthMatch(assets.length, limits.length);\n\n        // Perform the swaps, updating the Pool token balances and computing the net Vault asset deltas.\n        assetDeltas = _swapWithPools(swaps, assets, funds, kind);\n\n        // Process asset deltas, by either transferring assets from the sender (for positive deltas) or to the recipient\n        // (for negative deltas).\n        uint256 wrappedEth = 0;\n        for (uint256 i = 0; i < assets.length; ++i) {\n            IAsset asset = assets[i];\n            int256 delta = assetDeltas[i];\n            _require(delta <= limits[i], Errors.SWAP_LIMIT);\n\n            if (delta > 0) {\n                uint256 toReceive = uint256(delta);\n                _receiveAsset(asset, toReceive, funds.sender, funds.fromInternalBalance);\n\n                if (_isETH(asset)) {\n                    wrappedEth = wrappedEth.add(toReceive);\n                }\n            } else if (delta < 0) {\n                uint256 toSend = uint256(-delta);\n                _sendAsset(asset, toSend, funds.recipient, funds.toInternalBalance);\n            }\n        }\n\n        // Handle any used and remaining ETH.\n        _handleRemainingEth(wrappedEth);\n    }","contract":"Vault","time":0},{"type":"external-function ","before":"function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external override returns (int256[] memory) {\n        // In order to accurately 'simulate' swaps, this function actually does perform the swaps, including calling the\n        // Pool hooks and updating balances in storage. However, once it computes the final Vault Deltas, it\n        // reverts unconditionally, returning this array as the revert data.\n        //\n        // By wrapping this reverting call, we can decode the deltas 'returned' and return them as a normal Solidity\n        // function would. The only caveat is the function becomes non-view, but off-chain clients can still call it\n        // via eth_call to get the expected result.\n        //\n        // This technique was inspired by the work from the Gnosis team in the Gnosis Safe contract:\n        // https://github.com/gnosis/safe-contracts/blob/v1.2.0/contracts/GnosisSafe.sol#L265\n        //\n        // Most of this function is implemented using inline assembly, as the actual work it needs to do is not\n        // significant, and Solidity is not particularly well-suited to generate this behavior, resulting in a large\n        // amount of generated bytecode.\n\n        if (msg.sender != address(this)) {\n            // We perform an external call to ourselves, forwarding the same calldata. In this call, the else clause of\n            // the preceding if statement will be executed instead.\n\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = address(this).call(msg.data);\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // This call should always revert to decode the actual asset deltas from the revert reason\n                switch success\n                    case 0 {\n                        // Note we are manually writing the memory slot 0. We can safely overwrite whatever is\n                        // stored there as we take full control of the execution and then immediately return.\n\n                        // We copy the first 4 bytes to check if it matches with the expected signature, otherwise\n                        // there was another revert reason and we should forward it.\n                        returndatacopy(0, 0, 0x04)\n                        let error := and(mload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n                        // If the first 4 bytes don't match with the expected signature, we forward the revert reason.\n                        if eq(eq(error, 0xfa61cc1200000000000000000000000000000000000000000000000000000000), 0) {\n                            returndatacopy(0, 0, returndatasize())\n                            revert(0, returndatasize())\n                        }\n\n                        // The returndata contains the signature, followed by the raw memory representation of an array:\n                        // length + data. We need to return an ABI-encoded representation of this array.\n                        // An ABI-encoded array contains an additional field when compared to its raw memory\n                        // representation: an offset to the location of the length. The offset itself is 32 bytes long,\n                        // so the smallest value we  can use is 32 for the data to be located immediately after it.\n                        mstore(0, 32)\n\n                        // We now copy the raw memory array from returndata into memory. Since the offset takes up 32\n                        // bytes, we start copying at address 0x20. We also get rid of the error signature, which takes\n                        // the first four bytes of returndata.\n                        let size := sub(returndatasize(), 0x04)\n                        returndatacopy(0x20, 0x04, size)\n\n                        // We finally return the ABI-encoded array, which has a total length equal to that of the array\n                        // (returndata), plus the 32 bytes for the offset.\n                        return(0, add(size, 32))\n                    }\n                    default {\n                        // This call should always revert, but we fail nonetheless if that didn't happen\n                        invalid()\n                    }\n            }\n        } else {\n            int256[] memory deltas = _swapWithPools(swaps, assets, funds, kind);\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // We will return a raw representation of the array in memory, which is composed of a 32 byte length,\n                // followed by the 32 byte int256 values. Because revert expects a size in bytes, we multiply the array\n                // length (stored at `deltas`) by 32.\n                let size := mul(mload(deltas), 32)\n\n                // We send one extra value for the error signature \"QueryError(int256[])\" which is 0xfa61cc12.\n                // We store it in the previous slot to the `deltas` array. We know there will be at least one available\n                // slot due to how the memory scratch space works.\n                // We can safely overwrite whatever is stored in this slot as we will revert immediately after that.\n                mstore(sub(deltas, 0x20), 0x00000000000000000000000000000000000000000000000000000000fa61cc12)\n                let start := sub(deltas, 0x04)\n\n                // When copying from `deltas` into returndata, we copy an additional 36 bytes to also return the array's\n                // length and the error signature.\n                revert(start, add(size, 36))\n            }\n        }\n    }","after":"function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] calldata swaps,\n        IAsset[] calldata assets,\n        FundManagement calldata funds\n    ) external override returns (int256[] memory) {\n        // In order to accurately 'simulate' swaps, this function actually does perform the swaps, including calling the\n        // Pool hooks and updating balances in storage. However, once it computes the final Vault Deltas, it\n        // reverts unconditionally, returning this array as the revert data.\n        //\n        // By wrapping this reverting call, we can decode the deltas 'returned' and return them as a normal Solidity\n        // function would. The only caveat is the function becomes non-view, but off-chain clients can still call it\n        // via eth_call to get the expected result.\n        //\n        // This technique was inspired by the work from the Gnosis team in the Gnosis Safe contract:\n        // https://github.com/gnosis/safe-contracts/blob/v1.2.0/contracts/GnosisSafe.sol#L265\n        //\n        // Most of this function is implemented using inline assembly, as the actual work it needs to do is not\n        // significant, and Solidity is not particularly well-suited to generate this behavior, resulting in a large\n        // amount of generated bytecode.\n\n        if (msg.sender != address(this)) {\n            // We perform an external call to ourselves, forwarding the same calldata. In this call, the else clause of\n            // the preceding if statement will be executed instead.\n\n            // solhint-disable-next-line avoid-low-level-calls\n            (bool success, ) = address(this).call(msg.data);\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // This call should always revert to decode the actual asset deltas from the revert reason\n                switch success\n                    case 0 {\n                        // Note we are manually writing the memory slot 0. We can safely overwrite whatever is\n                        // stored there as we take full control of the execution and then immediately return.\n\n                        // We copy the first 4 bytes to check if it matches with the expected signature, otherwise\n                        // there was another revert reason and we should forward it.\n                        returndatacopy(0, 0, 0x04)\n                        let error := and(mload(0), 0xffffffff00000000000000000000000000000000000000000000000000000000)\n\n                        // If the first 4 bytes don't match with the expected signature, we forward the revert reason.\n                        if eq(eq(error, 0xfa61cc1200000000000000000000000000000000000000000000000000000000), 0) {\n                            returndatacopy(0, 0, returndatasize())\n                            revert(0, returndatasize())\n                        }\n\n                        // The returndata contains the signature, followed by the raw memory representation of an array:\n                        // length + data. We need to return an ABI-encoded representation of this array.\n                        // An ABI-encoded array contains an additional field when compared to its raw memory\n                        // representation: an offset to the location of the length. The offset itself is 32 bytes long,\n                        // so the smallest value we  can use is 32 for the data to be located immediately after it.\n                        mstore(0, 32)\n\n                        // We now copy the raw memory array from returndata into memory. Since the offset takes up 32\n                        // bytes, we start copying at address 0x20. We also get rid of the error signature, which takes\n                        // the first four bytes of returndata.\n                        let size := sub(returndatasize(), 0x04)\n                        returndatacopy(0x20, 0x04, size)\n\n                        // We finally return the ABI-encoded array, which has a total length equal to that of the array\n                        // (returndata), plus the 32 bytes for the offset.\n                        return(0, add(size, 32))\n                    }\n                    default {\n                        // This call should always revert, but we fail nonetheless if that didn't happen\n                        invalid()\n                    }\n            }\n        } else {\n            int256[] memory deltas = _swapWithPools(swaps, assets, funds, kind);\n\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                // We will return a raw representation of the array in memory, which is composed of a 32 byte length,\n                // followed by the 32 byte int256 values. Because revert expects a size in bytes, we multiply the array\n                // length (stored at `deltas`) by 32.\n                let size := mul(mload(deltas), 32)\n\n                // We send one extra value for the error signature \"QueryError(int256[])\" which is 0xfa61cc12.\n                // We store it in the previous slot to the `deltas` array. We know there will be at least one available\n                // slot due to how the memory scratch space works.\n                // We can safely overwrite whatever is stored in this slot as we will revert immediately after that.\n                mstore(sub(deltas, 0x20), 0x00000000000000000000000000000000000000000000000000000000fa61cc12)\n                let start := sub(deltas, 0x04)\n\n                // When copying from `deltas` into returndata, we copy an additional 36 bytes to also return the array's\n                // length and the error signature.\n                revert(start, add(size, 36))\n            }\n        }\n    }","contract":"Vault","time":0},{"type":"external-function ","before":"ion for bytes32[];\n\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable override whenNotPaused {\n        // This function doesn't have the nonReentrant modifier: it is applied to `_joinOrExit` instead.\n\n        // Note that `recipient` is not actually payable in the context of a join - we cast it because we handle both\n        // joins and exits at once.\n        _joinOrExit(PoolBalanceChangeKind.JOIN, poolId, sender, payable(recipient), _toPoolBalanc","after":"ion for bytes32[];\n\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable override whenNotPaused {\n        // This function doesn't have the nonReentrant modifier: it is applied to `_joinOrExit` instead.\n\n        // Note that `recipient` is not actually payable in the context of a join - we cast it because we handle both\n        // joins and exits at once.\n        _joinOrExit(PoolBalanceChangeKind.JOIN, poolId, sender, payable(recipient), _toPoolBalanc","contract":"Vault","time":0},{"type":"external-function ","before":"e(request));\n    }\n\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external override {\n        // This function doesn't have the nonReentrant modifier: it is applied to `_joinOrExit` instead.\n        _joinOrExit(PoolBalanceChangeKind.EXIT, poolId, sender, recipient, _toPoolBalanc","after":"e(request));\n    }\n\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external override {\n        // This function doesn't have the nonReentrant modifier: it is applied to `_joinOrExit` instead.\n        _joinOrExit(PoolBalanceChangeKind.EXIT, poolId, sender, recipient, _toPoolBalanc","contract":"Vault","time":0},{"type":"external-function ","before":"ion for bytes32[];\n\n    function registerTokens(\n        bytes32 poolId,\n        IERC20[] memory tokens,\n        address[] memory assetManagers\n    ) external override nonReentrant whenNotPaused onlyPool(poolId) {\n        InputHelpers.ensureInputLengthMatch(tokens.length, assetManagers.length);\n\n        // Validates token addresses and assigns Asset Managers\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            _require(token != IERC20(0), Errors.INVALID_TOKEN);\n\n            _poolAssetManagers[poolId][token] = assetManagers[i];\n        }\n\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            _require(tokens.length == 2, Errors.TOKENS_LENGTH_MUST_BE_2);\n            _registerTwoTokenPoolTokens(poolId, tokens[0], tokens[1]);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            _registerMinimalSwapInfoPoolTokens(poolId, tokens);\n        } else {\n            // PoolSpecialization.GENERAL\n            _registerGeneralPoolTokens(poolId, tokens);\n        }\n\n        emit TokensRegistered(poolId, token","after":"ion for bytes32[];\n\n    function registerTokens(\n        bytes32 poolId,\n        IERC20[] calldata tokens,\n        address[] memory assetManagers\n    ) external override nonReentrant whenNotPaused onlyPool(poolId) {\n        InputHelpers.ensureInputLengthMatch(tokens.length, assetManagers.length);\n\n        // Validates token addresses and assigns Asset Managers\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            IERC20 token = tokens[i];\n            _require(token != IERC20(0), Errors.INVALID_TOKEN);\n\n            _poolAssetManagers[poolId][token] = assetManagers[i];\n        }\n\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            _require(tokens.length == 2, Errors.TOKENS_LENGTH_MUST_BE_2);\n            _registerTwoTokenPoolTokens(poolId, tokens[0], tokens[1]);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            _registerMinimalSwapInfoPoolTokens(poolId, tokens);\n        } else {\n            // PoolSpecialization.GENERAL\n            _registerGeneralPoolTokens(poolId, tokens);\n        }\n\n        emit TokensRegistered(poolId, token","contract":"Vault","time":1},{"type":"external-function ","before":"etManagers);\n    }\n\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        onlyPool(poolId)\n    {\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            _require(tokens.length == 2, Errors.TOKENS_LENGTH_MUST_BE_2);\n            _deregisterTwoTokenPoolTokens(poolId, tokens[0], tokens[1]);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            _deregisterMinimalSwapInfoPoolTokens(poolId, tokens);\n        } else {\n            // PoolSpecialization.GENERAL\n            _deregisterGeneralPoolTokens(poolId, tokens);\n        }\n\n        // The deregister calls above ensure the total token balance is zero. Therefore it is now safe to remove any\n        // associated Asset Managers, since they hold no Pool balance.\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            delete _poolAssetManagers[poolId][tokens[i]];\n        }\n\n        emit TokensDeregistere","after":"etManagers);\n    }\n\n    function deregisterTokens(bytes32 poolId, IERC20[] memory tokens)\n        external\n        override\n        nonReentrant\n        whenNotPaused\n        onlyPool(poolId)\n    {\n        PoolSpecialization specialization = _getPoolSpecialization(poolId);\n        if (specialization == PoolSpecialization.TWO_TOKEN) {\n            _require(tokens.length == 2, Errors.TOKENS_LENGTH_MUST_BE_2);\n            _deregisterTwoTokenPoolTokens(poolId, tokens[0], tokens[1]);\n        } else if (specialization == PoolSpecialization.MINIMAL_SWAP_INFO) {\n            _deregisterMinimalSwapInfoPoolTokens(poolId, tokens);\n        } else {\n            // PoolSpecialization.GENERAL\n            _deregisterGeneralPoolTokens(poolId, tokens);\n        }\n\n        // The deregister calls above ensure the total token balance is zero. Therefore it is now safe to remove any\n        // associated Asset Managers, since they hold no Pool balance.\n        for (uint256 i = 0; i < tokens.length; ++i) {\n            delete _poolAssetManagers[poolId][tokens[i]];\n        }\n\n        emit TokensDeregistere","contract":"Vault","time":0},{"type":"external-function ","before":"poolAssetManagers;\n\n    function managePoolBalance(PoolBalanceOp[] memory ops) external override nonReentrant whenNotPaused {\n        // This variable could be declared inside the loop, but that causes the compiler to allocate memory on each\n        // loop iteration, increasing gas costs.\n        PoolBalanceOp memory op;\n\n        for (uint256 i = 0; i < ops.length; ++i) {\n            // By indexing the array only once, we don't spend extra gas in the same bounds check.\n            op = ops[i];\n\n            bytes32 poolId = op.poolId;\n            _ensureRegisteredPool(poolId);\n\n            IERC20 token = op.token;\n            _require(_isTokenRegistered(poolId, token), Errors.TOKEN_NOT_REGISTERED);\n            _require(_poolAssetManagers[poolId][token] == msg.sender, Errors.SENDER_NOT_ASSET_MANAGER);\n\n            PoolBalanceOpKind kind = op.kind;\n            uint256 amount = op.amount;\n            (int256 cashDelta, int256 managedDelta) = _performPoolManagementOperation(kind, poolId, token, amount);\n\n            emit PoolBalanceManaged(poolId, msg.sender, token, cashDelta, manage","after":"poolAssetManagers;\n\n    function managePoolBalance(PoolBalanceOp[] memory ops) external override nonReentrant whenNotPaused {\n        // This variable could be declared inside the loop, but that causes the compiler to allocate memory on each\n        // loop iteration, increasing gas costs.\n        PoolBalanceOp memory op;\n\n        for (uint256 i = 0; i < ops.length; ++i) {\n            // By indexing the array only once, we don't spend extra gas in the same bounds check.\n            op = ops[i];\n\n            bytes32 poolId = op.poolId;\n            _ensureRegisteredPool(poolId);\n\n            IERC20 token = op.token;\n            _require(_isTokenRegistered(poolId, token), Errors.TOKEN_NOT_REGISTERED);\n            _require(_poolAssetManagers[poolId][token] == msg.sender, Errors.SENDER_NOT_ASSET_MANAGER);\n\n            PoolBalanceOpKind kind = op.kind;\n            uint256 amount = op.amount;\n            (int256 cashDelta, int256 managedDelta) = _performPoolManagementOperation(kind, poolId, token, amount);\n\n            emit PoolBalanceManaged(poolId, msg.sender, token, cashDelta, manage","contract":"Vault","time":0},{"type":"external-function ","before":");\n        }\n    }\n\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable override nonReentrant {\n        // We need to track how much of the received ETH was used and wrapped into WETH to return any excess.\n        uint256 ethWrapped = 0;\n\n        // Cache for these checks so we only perform them once (if at all).\n        bool checkedCallerIsRelayer = false;\n        bool checkedNotPaused = false;\n\n        for (uint256 i = 0; i < ops.length; i++) {\n            UserBalanceOpKind kind;\n            IAsset asset;\n            uint256 amount;\n            address sender;\n            address payable recipient;\n\n            // This destructuring by calling `_validateUserBalanceOp` seems odd, but results in reduced bytecode size.\n            (kind, asset, amount, sender, recipient, checkedCallerIsRelayer) = _validateUserBalanceOp(\n                ops[i],\n                checkedCallerIsRelayer\n            );\n\n            if (kind == UserBalanceOpKind.WITHDRAW_INTERNAL) {\n                // Internal Balance withdrawals can always be performed by an authorized account.\n                _withdrawFromInternalBalance(asset, sender, recipient, amount);\n            } else {\n                // All other operations are blocked if the contract is paused.\n\n                // We cache the result of the pause check and skip it for other operations in this same transaction\n                // (if any).\n                if (!checkedNotPaused) {\n                    _ensureNotPaused();\n                    checkedNotPaused = true;\n                }\n\n                if (kind == UserBalanceOpKind.DEPOSIT_INTERNAL) {\n                    _depositToInternalBalance(asset, sender, recipient, amount);\n\n                    // Keep track of all ETH wrapped into WETH as part of a deposit.\n                    if (_isETH(asset)) {\n                        ethWrapped = ethWrapped.add(amount);\n                    }\n                } else {\n                    // Transfers don't support ETH.\n                    _require(!_isETH(asset), Errors.CANNOT_USE_ETH_SENTINEL);\n                    IERC20 token = _asIERC20(asset);\n\n                    if (kind == UserBalanceOpKind.TRANSFER_INTERNAL) {\n                        _transferInternalBalance(token, sender, recipient, amount);\n                    } else {\n                        // TRANSFER_EXTERNAL\n                        _transferToExternalBalance(token, sender, recipient, amount);\n                    }\n                }\n            }\n        }\n\n        // Handle any remaining ETH.\n        _handleRemaini","after":");\n        }\n    }\n\n    function manageUserBalance(UserBalanceOp[] memory ops) external payable override nonReentrant {\n        // We need to track how much of the received ETH was used and wrapped into WETH to return any excess.\n        uint256 ethWrapped = 0;\n\n        // Cache for these checks so we only perform them once (if at all).\n        bool checkedCallerIsRelayer = false;\n        bool checkedNotPaused = false;\n\n        for (uint256 i = 0; i < ops.length; i++) {\n            UserBalanceOpKind kind;\n            IAsset asset;\n            uint256 amount;\n            address sender;\n            address payable recipient;\n\n            // This destructuring by calling `_validateUserBalanceOp` seems odd, but results in reduced bytecode size.\n            (kind, asset, amount, sender, recipient, checkedCallerIsRelayer) = _validateUserBalanceOp(\n                ops[i],\n                checkedCallerIsRelayer\n            );\n\n            if (kind == UserBalanceOpKind.WITHDRAW_INTERNAL) {\n                // Internal Balance withdrawals can always be performed by an authorized account.\n                _withdrawFromInternalBalance(asset, sender, recipient, amount);\n            } else {\n                // All other operations are blocked if the contract is paused.\n\n                // We cache the result of the pause check and skip it for other operations in this same transaction\n                // (if any).\n                if (!checkedNotPaused) {\n                    _ensureNotPaused();\n                    checkedNotPaused = true;\n                }\n\n                if (kind == UserBalanceOpKind.DEPOSIT_INTERNAL) {\n                    _depositToInternalBalance(asset, sender, recipient, amount);\n\n                    // Keep track of all ETH wrapped into WETH as part of a deposit.\n                    if (_isETH(asset)) {\n                        ethWrapped = ethWrapped.add(amount);\n                    }\n                } else {\n                    // Transfers don't support ETH.\n                    _require(!_isETH(asset), Errors.CANNOT_USE_ETH_SENTINEL);\n                    IERC20 token = _asIERC20(asset);\n\n                    if (kind == UserBalanceOpKind.TRANSFER_INTERNAL) {\n                        _transferInternalBalance(token, sender, recipient, amount);\n                    } else {\n                        // TRANSFER_EXTERNAL\n                        _transferToExternalBalance(token, sender, recipient, amount);\n                    }\n                }\n            }\n        }\n\n        // Handle any remaining ETH.\n        _handleRemaini","contract":"Vault","time":0}]}