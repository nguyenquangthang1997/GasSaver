{"time":174,"results":[{"type":"external-function ","before":"function serve_IPFS_URI(string memory ipfsTokenURI) external onlyOwner {\n        require(!lock, \"Metadata has been locked and cannot be changed anymore\");\n        metadataTokenURI = ipfsTokenURI;\n    }","after":"function serve_IPFS_URI(string calldata ipfsTokenURI) external onlyOwner {\n        require(!lock, \"Metadata has been locked and cannot be changed anymore\");\n        metadataTokenURI = ipfsTokenURI;\n    }","contract":"ARA","time":0},{"type":"external-function ","before":"function giveAway(address[] memory to) external onlyOwner {\n        for (uint256 i = 0; i < to.length; i++) {\n            giveAwayIdCount.increment();\n            _mint(to[i], giveAwayIdCount.current());\n        }\n    }","after":"function giveAway(address[] calldata to) external onlyOwner {\n        for (uint256 i = 0; i < to.length; i++) {\n            giveAwayIdCount.increment();\n            _mint(to[i], giveAwayIdCount.current());\n        }\n    }","contract":"ARA","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(verify(userAddress, metaTx, sigR, sigS, sigV), \"Signer and signature do not match\");\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(userAddress, payable(msg.sender), functionSignature);\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(abi.encodePacked(functionSignature, userAddress));\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(verify(userAddress, metaTx, sigR, sigS, sigV), \"Signer and signature do not match\");\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(userAddress, payable(msg.sender), functionSignature);\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(abi.encodePacked(functionSignature, userAddress));\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"ARA","time":0},{"type":"immutable-restrict-modification ","before":"address proxyRegistryAddress;","after":"address immutable proxyRegistryAddress;","contract":"ARA","time":1},{"type":"constant-restrict-modification  ","before":"uint256 private _currentTokenId = 0;","after":"uint256 private constant _currentTokenId = 0;","contract":"ARA","time":1}]}