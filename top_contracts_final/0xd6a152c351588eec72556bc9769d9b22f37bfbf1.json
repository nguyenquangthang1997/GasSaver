{"time":181,"results":[{"type":"external-function ","before":"function mintFromShadowBatch(uint256[] memory _tokenID, uint256[] memory _nftAmountForMint, uint _nonce, bytes32 _msgForSign, bytes memory _signature) public {\n        for(uint i=0;i<_tokenID.length;i++) {\n            require(tokenReq[_tokenID[i]].stopMintAfter >= totalSupply(_tokenID[i]) + _nftAmountForMint[i], \"Minting is paused\");\n        }\n        require(nonce[msg.sender] == _nonce, \"nonce error\");\n         //1. Lets check signer\n        address signedBy = _msgForSign.recover(_signature);\n        require(trustedSigner[signedBy], \"signature check failed\");\n        bytes32 actualMsg = getMsgForSignBatch(\n            _tokenID,\n            _nftAmountForMint,\n            _nonce,\n            msg.sender\n        );\n        require(actualMsg.toEthSignedMessageHash() == _msgForSign,\"integrety check failed\");\n\n        nonce[msg.sender]++;\n        _mintBatch(msg.sender, _tokenID, _nftAmountForMint, bytes('0'));\n    }","after":"function mintFromShadowBatch(uint256[] calldata _tokenID, uint256[] calldata _nftAmountForMint, uint _nonce, bytes32 _msgForSign, bytes calldata _signature) public {\n        for(uint i=0;i<_tokenID.length;i++) {\n            require(tokenReq[_tokenID[i]].stopMintAfter >= totalSupply(_tokenID[i]) + _nftAmountForMint[i], \"Minting is paused\");\n        }\n        require(nonce[msg.sender] == _nonce, \"nonce error\");\n         //1. Lets check signer\n        address signedBy = _msgForSign.recover(_signature);\n        require(trustedSigner[signedBy], \"signature check failed\");\n        bytes32 actualMsg = getMsgForSignBatch(\n            _tokenID,\n            _nftAmountForMint,\n            _nonce,\n            msg.sender\n        );\n        require(actualMsg.toEthSignedMessageHash() == _msgForSign,\"integrety check failed\");\n\n        nonce[msg.sender]++;\n        _mintBatch(msg.sender, _tokenID, _nftAmountForMint, bytes('0'));\n    }","contract":"SidusItems","time":0},{"type":"external-function ","before":"function mintFromShadow(uint256 _tokenID, uint256 _nftAmountForMint, uint _nonce, bytes32 _msgForSign, bytes memory _signature) external {\n        require(tokenReq[_tokenID].stopMintAfter >= totalSupply(_tokenID) + _nftAmountForMint, \"Minting is paused\");\n        //Double spend check\n        require(nonce[msg.sender] == _nonce, \"nonce error\");\n\n        address signedBy = _msgForSign.recover(_signature);\n        require(trustedSigner[signedBy], \"signature check failed\");\n        bytes32 actualMsg = getMsgForSign(\n            _tokenID,\n            _nftAmountForMint,\n            _nonce,\n            msg.sender\n        );\n        require(actualMsg.toEthSignedMessageHash() == _msgForSign,\"integrety check failed\");\n\n        nonce[msg.sender]++;\n        _multiMint(msg.sender, _nftAmountForMint, _tokenID, 0);\n    }","after":"function mintFromShadow(uint256 _tokenID, uint256 _nftAmountForMint, uint _nonce, bytes32 _msgForSign, bytes calldata _signature) external {\n        require(tokenReq[_tokenID].stopMintAfter >= totalSupply(_tokenID) + _nftAmountForMint, \"Minting is paused\");\n        //Double spend check\n        require(nonce[msg.sender] == _nonce, \"nonce error\");\n\n        address signedBy = _msgForSign.recover(_signature);\n        require(trustedSigner[signedBy], \"signature check failed\");\n        bytes32 actualMsg = getMsgForSign(\n            _tokenID,\n            _nftAmountForMint,\n            _nonce,\n            msg.sender\n        );\n        require(actualMsg.toEthSignedMessageHash() == _msgForSign,\"integrety check failed\");\n\n        nonce[msg.sender]++;\n        _multiMint(msg.sender, _nftAmountForMint, _tokenID, 0);\n    }","contract":"SidusItems","time":0},{"type":"external-function ","before":"function createNewBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        uint256[] memory _stopMintAfter,\n        uint256[] memory _maxTotalSupply) external onlyOwner {\n        require(ids.length == _stopMintAfter.length, \"stopMintAfter params must have equal length\");\n        require(ids.length == _maxTotalSupply.length, \"maxTotalSupply params must have equal length\");\n        _mintBatch(account, ids, amounts, bytes('0'));\n\n        for(uint256 i=0; i<ids.length; i++) {\n            _editTokenReq(ids[i], _stopMintAfter[i], _maxTotalSupply[i]);\n        }\n\n    }","after":"function createNewBatch(\n        address account,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        uint256[] calldata _stopMintAfter,\n        uint256[] calldata _maxTotalSupply) external onlyOwner {\n        require(ids.length == _stopMintAfter.length, \"stopMintAfter params must have equal length\");\n        require(ids.length == _maxTotalSupply.length, \"maxTotalSupply params must have equal length\");\n        _mintBatch(account, ids, amounts, bytes('0'));\n\n        for(uint256 i=0; i<ids.length; i++) {\n            _editTokenReq(ids[i], _stopMintAfter[i], _maxTotalSupply[i]);\n        }\n\n    }","contract":"SidusItems","time":0},{"type":"external-function ","before":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","after":"function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }","contract":"SidusItems","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","after":"function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }","contract":"SidusItems","time":0}]}