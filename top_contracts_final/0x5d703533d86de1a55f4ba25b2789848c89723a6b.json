{"time":218,"results":[{"type":"state-data-arrangement ","before":"\nuint128 public PUBLIC_SUPPLY = 6904;\nuint128 public MAX_SUPPLY = 6969;\nuint128 public PUBLIC_MINT_LIMIT = 10;\nuint128 public PRESALE_MINT_LIMIT = 5;\nint256 public priceTier;\nuint256 public tierLimit = 1000;\nbool public publicWalletLimit = true;\nbool public isPresale = true;\nbool public isRevealed = false;\nmapping(address => uint256) public mintBalances;\nmapping(uint256 => uint256) public pricelist;\nstring internal baseTokenURI;\naddress[] internal payees;\naddress internal _SIGNER;\nstring public PROVENANCE_HASH;\naddress private immutable _proxyRegistryAddress;","after":"int256 public priceTier;\nuint256 public tierLimit = 1000;\nmapping(address => uint256) public mintBalances;\nmapping(uint256 => uint256) public pricelist;\nstring internal baseTokenURI;\naddress[] internal payees;\nstring public PROVENANCE_HASH;\naddress internal _SIGNER;\naddress private immutable _proxyRegistryAddress;\nuint128 public PUBLIC_SUPPLY = 6904;\nuint128 public MAX_SUPPLY = 6969;\nuint128 public PUBLIC_MINT_LIMIT = 10;\nuint128 public PRESALE_MINT_LIMIT = 5;\nbool public publicWalletLimit = true;\nbool public isPresale = true;\nbool public isRevealed = false;\n","contract":"Etherminators","time":11},{"type":"external-function ","before":"function presalePurchase(\n        uint256 _quantity,\n        bytes32 _hash,\n        bytes memory _signature\n    ) external payable nonReentrant whenNotPaused {\n        require(\n            checkHash(_hash, _signature, _SIGNER),\n            \"Address is not on Presale List\"\n        );\n        // @dev Presale always enforces a per-wallet limit\n        require(\n            _quantity + mintBalances[msg.sender] <= PRESALE_MINT_LIMIT,\n            \"Quantity exceeds per-wallet limit\"\n        );\n\n        _mint(_quantity);\n    }","after":"function presalePurchase(\n        uint256 _quantity,\n        bytes32 _hash,\n        bytes calldata _signature\n    ) external payable nonReentrant whenNotPaused {\n        require(\n            checkHash(_hash, _signature, _SIGNER),\n            \"Address is not on Presale List\"\n        );\n        // @dev Presale always enforces a per-wallet limit\n        require(\n            _quantity + mintBalances[msg.sender] <= PRESALE_MINT_LIMIT,\n            \"Quantity exceeds per-wallet limit\"\n        );\n\n        _mint(_quantity);\n    }","contract":"Etherminators","time":0},{"type":"external-function ","before":"function setProvenance(string memory _provenance) external onlyOwner {\n        PROVENANCE_HASH = _provenance;\n    }","after":"function setProvenance(string calldata _provenance) external onlyOwner {\n        PROVENANCE_HASH = _provenance;\n    }","contract":"Etherminators","time":0},{"type":"external-function ","before":"function setBaseURI(string memory _URI) external onlyOwner {\n        baseTokenURI = _URI;\n    }","after":"function setBaseURI(string calldata _URI) external onlyOwner {\n        baseTokenURI = _URI;\n    }","contract":"Etherminators","time":0},{"type":"external-function ","before":"function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","after":"function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n    }","contract":"Etherminators","time":0},{"type":"constant-restrict-modification  ","before":"uint128 public PUBLIC_SUPPLY = 6904;","after":"uint128 public constant PUBLIC_SUPPLY = 6904;","contract":"Etherminators","time":1},{"type":"constant-restrict-modification  ","before":"uint128 public MAX_SUPPLY = 6969;","after":"uint128 public constant MAX_SUPPLY = 6969;","contract":"Etherminators","time":1}]}