{"time":1220,"results":[{"type":"external-function ","before":"function initCardTypes(\n        string[] memory _typeCids,\n        uint256[] memory _typeTiers\n    ) public {\n        require(hasRole(OWNER_ROLE, _msgSender()), \"Not Owner\");\n        require(_typeCids.length == _typeTiers.length);\n        // incoming types MUST be higher or same\n        // already checked that _typeCids and _typeTiers are of same length\n        require(_typeCids.length >= typeCount);\n\n        // loop through existing to ensure that they are the same\n        for (uint256 i = 0; i < typeCount; i++) {\n            require(_types[i].typeId == i);\n            require(\n                keccak256(bytes(_types[i].cid)) ==\n                    keccak256(bytes(_typeCids[i]))\n            );\n            require(_types[i].tier == _typeTiers[i]);\n        }\n        // copy over new values\n        for (uint256 i = typeCount; i < _typeCids.length; i++) {\n            _types[i] = CardType({\n                typeId: i,\n                cid: _typeCids[i],\n                tier: _typeTiers[i],\n                serialCounter: Counters.Counter({_value: 0})\n            });\n        }\n        // set new typeCount\n        typeCount = _typeCids.length;\n    }","after":"function initCardTypes(\n        string[] calldata _typeCids,\n        uint256[] calldata _typeTiers\n    ) public {\n        require(hasRole(OWNER_ROLE, _msgSender()), \"Not Owner\");\n        require(_typeCids.length == _typeTiers.length);\n        // incoming types MUST be higher or same\n        // already checked that _typeCids and _typeTiers are of same length\n        require(_typeCids.length >= typeCount);\n\n        // loop through existing to ensure that they are the same\n        for (uint256 i = 0; i < typeCount; i++) {\n            require(_types[i].typeId == i);\n            require(\n                keccak256(bytes(_types[i].cid)) ==\n                    keccak256(bytes(_typeCids[i]))\n            );\n            require(_types[i].tier == _typeTiers[i]);\n        }\n        // copy over new values\n        for (uint256 i = typeCount; i < _typeCids.length; i++) {\n            _types[i] = CardType({\n                typeId: i,\n                cid: _typeCids[i],\n                tier: _typeTiers[i],\n                serialCounter: Counters.Counter({_value: 0})\n            });\n        }\n        // set new typeCount\n        typeCount = _typeCids.length;\n    }","contract":"BullrunBabesCoordinator","time":0},{"type":"external-function ","before":"function initAllocation(\n        uint256[] memory _tradeUpThresholds,\n        uint256[][] memory _combinedPoolAllocation,\n        uint256[][] memory _curveVars\n    ) public {\n        require(hasRole(OWNER_ROLE, _msgSender()), \"Not Owner\");\n        require(\n            _tradeUpThresholds.length == _combinedPoolAllocation.length - 1\n        );\n        // combined pools are by [drawTier, ...Tiers][type] = count\n        // require same or mor tiers\n        require(\n            _combinedPoolAllocation.length >= combinedPoolAllocation.length\n        );\n\n        // set tradeUpThreshold\n        tradeUpThresholds = _tradeUpThresholds;\n\n        // verify existing is the same\n        for (uint256 tier = 0; tier < combinedPoolAllocation.length; tier++) {\n            require(\n                _combinedPoolAllocation[tier].length >=\n                    combinedPoolAllocation[tier].length\n            );\n            for (uint256 c = 0; c < combinedPoolAllocation[tier].length; c++) {\n                // any existing allocated values CANNOT be changed\n                require(_combinedPoolAllocation[tier][c] == 0);\n                // ensure that we use the existing allocation values\n                _combinedPoolAllocation[tier][c] = combinedPoolAllocation[tier][\n                    c\n                ];\n            }\n        }\n        combinedPoolAllocation = _combinedPoolAllocation;\n\n        _calculatePoolMax();\n\n        // same size as tiers\n        uint256[] memory newReserves =\n            new uint256[](_combinedPoolAllocation.length);\n        for (uint256 i = 0; i < _inflightReserves.length; i++) {\n            newReserves[i] = _inflightReserves[i];\n        }\n        _inflightReserves = newReserves;\n\n        // no need to initialize _tokenIdTracker since it is always pre-initiated to 0\n        // and we never want to reinitialize it\n\n        // set curveVars\n        curveVars = _curveVars;\n    }","after":"function initAllocation(\n        uint256[] calldata _tradeUpThresholds,\n        uint256[][] calldata _combinedPoolAllocation,\n        uint256[][] memory _curveVars\n    ) public {\n        require(hasRole(OWNER_ROLE, _msgSender()), \"Not Owner\");\n        require(\n            _tradeUpThresholds.length == _combinedPoolAllocation.length - 1\n        );\n        // combined pools are by [drawTier, ...Tiers][type] = count\n        // require same or mor tiers\n        require(\n            _combinedPoolAllocation.length >= combinedPoolAllocation.length\n        );\n\n        // set tradeUpThreshold\n        tradeUpThresholds = _tradeUpThresholds;\n\n        // verify existing is the same\n        for (uint256 tier = 0; tier < combinedPoolAllocation.length; tier++) {\n            require(\n                _combinedPoolAllocation[tier].length >=\n                    combinedPoolAllocation[tier].length\n            );\n            for (uint256 c = 0; c < combinedPoolAllocation[tier].length; c++) {\n                // any existing allocated values CANNOT be changed\n                require(_combinedPoolAllocation[tier][c] == 0);\n                // ensure that we use the existing allocation values\n                _combinedPoolAllocation[tier][c] = combinedPoolAllocation[tier][\n                    c\n                ];\n            }\n        }\n        combinedPoolAllocation = _combinedPoolAllocation;\n\n        _calculatePoolMax();\n\n        // same size as tiers\n        uint256[] memory newReserves =\n            new uint256[](_combinedPoolAllocation.length);\n        for (uint256 i = 0; i < _inflightReserves.length; i++) {\n            newReserves[i] = _inflightReserves[i];\n        }\n        _inflightReserves = newReserves;\n\n        // no need to initialize _tokenIdTracker since it is always pre-initiated to 0\n        // and we never want to reinitialize it\n\n        // set curveVars\n        curveVars = _curveVars;\n    }","contract":"BullrunBabesCoordinator","time":0},{"type":"external-function ","before":"function tradeUp(uint256[] memory tokens)\n        public\n        payable\n        override\n        nonReentrant\n    {\n        uint256 tradeCost = getPrice(0);\n        require(msg.value >= tradeCost, \"Not enough ether to trade\");\n        uint256 excess = msg.value.sub(tradeCost);\n        if (excess > 0) {\n            Address.sendValue(payable(_msgSender()), excess);\n        }\n\n        require(tokens.length > 0, \"Requires tokens to trade\");\n        uint256 firstTier = tierOf(tokens[0]);\n        uint256 cardsRequiredForTradeUp = tradeUpThresholds[firstTier];\n        require(\n            tokens.length == cardsRequiredForTradeUp,\n            \"Selected set does not match trade requirement.\"\n        );\n        address firstOwner = brbToken.ownerOf(tokens[0]);\n        require(firstOwner == _msgSender(), \"Tokens must all be owned by you.\");\n        bool tokensTiersMatches = true;\n        bool tokensOwnerMatches = true;\n        bool tokensNotInflight = true;\n        for (uint256 i = 1; i < tokens.length; i++) {\n            tokensTiersMatches = firstTier == tierOf(tokens[i]);\n            tokensOwnerMatches = firstOwner == brbToken.ownerOf(tokens[i]);\n            tokensNotInflight = _inflightTradeUpTokens[tokens[i]] != 1;\n        }\n        require(tokensNotInflight, \"All tokens must not be in flight\");\n        require(\n            tokensTiersMatches,\n            \"All tokens provided must be of the same tier\"\n        );\n        require(tokensOwnerMatches, \"Tokens must all be owned by you.\");\n        uint256 newTier = firstTier + 1;\n        require(\n            newTier < tradeUpThresholds.length, // new tier still exists within the byte array\n            \"There must higher tiers to trade up to\"\n        );\n\n        require(\n            _getPoolMax(newTier + 1) - _inflightReserves[newTier + 1] > 0,\n            \"Exhausted\"\n        );\n\n        // reserve tokens\n        for (uint256 i = 0; i < tokens.length; i++) {\n            _inflightTradeUpTokens[tokens[i]] = 1;\n        }\n        // reserve newTier tokens\n        _inflightReserves[newTier + 1]++;\n\n        bytes32 queryId =\n            oracle._init_random{value: oracleFee, gas: oracleGas}();\n\n        _inflightTrades[queryId] = TradeUp({\n            tokens: tokens,\n            recipient: _msgSender(),\n            newTier: newTier,\n            tradeCost: tradeCost\n        });\n        emit RandomInitiated(queryId);\n    }","after":"function tradeUp(uint256[] calldata tokens)\n        public\n        payable\n        override\n        nonReentrant\n    {\n        uint256 tradeCost = getPrice(0);\n        require(msg.value >= tradeCost, \"Not enough ether to trade\");\n        uint256 excess = msg.value.sub(tradeCost);\n        if (excess > 0) {\n            Address.sendValue(payable(_msgSender()), excess);\n        }\n\n        require(tokens.length > 0, \"Requires tokens to trade\");\n        uint256 firstTier = tierOf(tokens[0]);\n        uint256 cardsRequiredForTradeUp = tradeUpThresholds[firstTier];\n        require(\n            tokens.length == cardsRequiredForTradeUp,\n            \"Selected set does not match trade requirement.\"\n        );\n        address firstOwner = brbToken.ownerOf(tokens[0]);\n        require(firstOwner == _msgSender(), \"Tokens must all be owned by you.\");\n        bool tokensTiersMatches = true;\n        bool tokensOwnerMatches = true;\n        bool tokensNotInflight = true;\n        for (uint256 i = 1; i < tokens.length; i++) {\n            tokensTiersMatches = firstTier == tierOf(tokens[i]);\n            tokensOwnerMatches = firstOwner == brbToken.ownerOf(tokens[i]);\n            tokensNotInflight = _inflightTradeUpTokens[tokens[i]] != 1;\n        }\n        require(tokensNotInflight, \"All tokens must not be in flight\");\n        require(\n            tokensTiersMatches,\n            \"All tokens provided must be of the same tier\"\n        );\n        require(tokensOwnerMatches, \"Tokens must all be owned by you.\");\n        uint256 newTier = firstTier + 1;\n        require(\n            newTier < tradeUpThresholds.length, // new tier still exists within the byte array\n            \"There must higher tiers to trade up to\"\n        );\n\n        require(\n            _getPoolMax(newTier + 1) - _inflightReserves[newTier + 1] > 0,\n            \"Exhausted\"\n        );\n\n        // reserve tokens\n        for (uint256 i = 0; i < tokens.length; i++) {\n            _inflightTradeUpTokens[tokens[i]] = 1;\n        }\n        // reserve newTier tokens\n        _inflightReserves[newTier + 1]++;\n\n        bytes32 queryId =\n            oracle._init_random{value: oracleFee, gas: oracleGas}();\n\n        _inflightTrades[queryId] = TradeUp({\n            tokens: tokens,\n            recipient: _msgSender(),\n            newTier: newTier,\n            tradeCost: tradeCost\n        });\n        emit RandomInitiated(queryId);\n    }","contract":"BullrunBabesCoordinator","time":0}]}