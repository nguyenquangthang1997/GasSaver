{"time":207,"results":[{"type":"state-data-arrangement ","before":"\n   address constant private _signer = 0xDA9F95f43d4189285fA618Df89f66d9666e806\n   address _proxyRegistryAddre\n   mapping (uint256 => bytes32) private _ha\n   mapping(string => bool) private _usedNonc\n   mapping (address => uint256) private _min\n   uint256 private _currentTokenId =\n   uint256 private _se\n   bool private _locked   = fal\n   bool public publicLive = fal\n   uint256 public memberPrice = 300000000000000\n   uint256 public publicPrice = 500000000000000\n   uint256 public publicM\n   uint256 public artistM\n   uint256 public galleryM\n   uint256 public tokenM\n   uint256 public publicMinted =\n   uint256 public artistMinted =\n   uint256 public galleryMinted =\n   address private _burnerAddre\n   address private _artistAddress = 0xC76cb2613026998b82cEB467134ecFF003Ebbb","after":"   mapping (uint256 => bytes32) private _ha\n   mapping(string => bool) private _usedNonc\n   mapping (address => uint256) private _min\n   uint256 private _currentTokenId =\n   uint256 private _se\n   uint256 public memberPrice = 300000000000000\n   uint256 public publicPrice = 500000000000000\n   uint256 public publicM\n   uint256 public artistM\n   uint256 public galleryM\n   uint256 public tokenM\n   uint256 public publicMinted =\n   uint256 public artistMinted =\n   uint256 public galleryMinted =\n   address constant private _signer = 0xDA9F95f43d4189285fA618Df89f66d9666e806\n   address _proxyRegistryAddre\n   address private _burnerAddre\n   address private _artistAddress = 0xC76cb2613026998b82cEB467134ecFF003Ebbb\n   bool private _locked   = fal\n   bool public publicLive = fal\n","contract":"GeneticChain721","time":1},{"type":"external-function ","before":"   function setCode(string memory code_)\n        public\n        onlyOwner\n        notLocked\n    {\n        code = code_;\n  ","after":"   function setCode(string calldata code_)\n        public\n        onlyOwner\n        notLocked\n    {\n        code = code_;\n  ","contract":"Ikebana","time":0},{"type":"external-function ","before":"   function secureMint(bytes32 msgHash, bytes memory signature, uint256 allocation, uint256 count, string memory nonce)\n        payable\n        external\n        notLocked\n    {\n        require(memberPrice * count == msg.value, \"insufficient funds\");\n        require(!_usedNonces[nonce], \"invalid nonce\");\n        require(totalSupply() < tokenMax, \"all tokens minted\");\n        require(totalSupply() + count <= tokenMax, \"exceed token supply\");\n        require(publicMinted + count <= publicMax, \"exceed public supply\");\n        require(_mints[msg.sender] + count <= allocation, \"exceed allocation\");\n        require(validateSigner(msgHash, signature), \"invalid signer\");\n        require(validateHash(msgHash, msg.sender, allocation, count, nonce), \"invalid hash\");\n        publicMinted += count;\n        _mints[msg.sender] += count;\n        _usedNonces[nonce] = true;\n        for (uint256 i = 0; i < count; ++i) {\n            _mintTo(msg.sender);\n        }\n  ","after":"   function secureMint(bytes32 msgHash, bytes calldata signature, uint256 allocation, uint256 count, string calldata nonce)\n        payable\n        external\n        notLocked\n    {\n        require(memberPrice * count == msg.value, \"insufficient funds\");\n        require(!_usedNonces[nonce], \"invalid nonce\");\n        require(totalSupply() < tokenMax, \"all tokens minted\");\n        require(totalSupply() + count <= tokenMax, \"exceed token supply\");\n        require(publicMinted + count <= publicMax, \"exceed public supply\");\n        require(_mints[msg.sender] + count <= allocation, \"exceed allocation\");\n        require(validateSigner(msgHash, signature), \"invalid signer\");\n        require(validateHash(msgHash, msg.sender, allocation, count, nonce), \"invalid hash\");\n        publicMinted += count;\n        _mints[msg.sender] += count;\n        _usedNonces[nonce] = true;\n        for (uint256 i = 0; i < count; ++i) {\n            _mintTo(msg.sender);\n        }\n  ","contract":"Ikebana","time":0},{"type":"external-function ","before":"   function executeMetaTransaction(\n        address userAddress,\n        bytes memory functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n  ","after":"   function executeMetaTransaction(\n        address userAddress,\n        bytes calldata functionSignature,\n        bytes32 sigR,\n        bytes32 sigS,\n        uint8 sigV\n    ) public payable returns (bytes memory) {\n        MetaTransaction memory metaTx = MetaTransaction({\n            nonce: nonces[userAddress],\n            from: userAddress,\n            functionSignature: functionSignature\n        });\n\n        require(\n            verify(userAddress, metaTx, sigR, sigS, sigV),\n            \"Signer and signature do not match\"\n        );\n\n        // increase nonce for user (to avoid re-use)\n        nonces[userAddress] = nonces[userAddress].add(1);\n\n        emit MetaTransactionExecuted(\n            userAddress,\n            payable(msg.sender),\n            functionSignature\n        );\n\n        // Append userAddress and relayer address at the end to extract it from calling context\n        (bool success, bytes memory returnData) = address(this).call(\n            abi.encodePacked(functionSignature, userAddress)\n        );\n        require(success, \"Function call not successful\");\n\n        return returnData;\n  ","contract":"Ikebana","time":0},{"type":"immutable-restrict-modification ","before":"   address _proxyRegistryAddre","after":"   address _proxyRegistryAddre","contract":"Ikebana","time":1},{"type":"constant-restrict-modification  ","before":"   uint256 private _currentTokenId =","after":"   uint256 private constant _currentTokenId =","contract":"Ikebana","time":1},{"type":"constant-restrict-modification  ","before":"   uint256 public memberPrice = 300000000000000","after":"   uint256 public constant memberPrice = 300000000000000","contract":"Ikebana","time":1},{"type":"constant-restrict-modification  ","before":"   uint256 public publicPrice = 500000000000000","after":"   uint256 public constant publicPrice = 500000000000000","contract":"Ikebana","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 public publicM","after":"   uint256 public publicM","contract":"Ikebana","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 public artistM","after":"   uint256 public artistM","contract":"Ikebana","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 public galleryM","after":"   uint256 public galleryM","contract":"Ikebana","time":1},{"type":"immutable-restrict-modification ","before":"   uint256 public tokenM","after":"   uint256 public tokenM","contract":"Ikebana","time":1}]}