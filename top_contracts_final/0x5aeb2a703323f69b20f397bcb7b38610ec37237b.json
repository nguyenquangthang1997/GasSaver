{"time":161,"results":[{"type":"external-function ","before":"function claimRareToken(bytes32[] memory proof) public {\n        require(ownerRareTokens[address(this)] > 0, \"all claimed\");\n\n        // wallet should be part of the gen1 snapshot\n        uint numGen1sOwned = numGeneration1sOwned();\n\n        require(isAddressAGeneration1Holder(proof, msg.sender, numGen1sOwned), \"not part of snapshot\");\n\n        uint numGen2sOwned = numGeneration2sOwned();\n\n        uint amount = calculateRareMintAmount(numGen1sOwned, numGen2sOwned);\n\n        // not eligible to claim any rares\n        require((amount > 0 && ownerRareTokens[msg.sender] < amount), \"not eligible\");\n\n        // a wallet with a gen 1 and 2 can claim a token.\n        for (uint i = 0; i < amount; i++) {\n            _transfer(address(this), msg.sender, nextRareTokenIdToClaim + i);\n        }\n\n        ownerRareTokens[msg.sender] += amount;\n        ownerRareTokens[address(this)] -= amount;\n        nextRareTokenIdToClaim += amount;\n    }","after":"function claimRareToken(bytes32[] calldata proof) public {\n        require(ownerRareTokens[address(this)] > 0, \"all claimed\");\n\n        // wallet should be part of the gen1 snapshot\n        uint numGen1sOwned = numGeneration1sOwned();\n\n        require(isAddressAGeneration1Holder(proof, msg.sender, numGen1sOwned), \"not part of snapshot\");\n\n        uint numGen2sOwned = numGeneration2sOwned();\n\n        uint amount = calculateRareMintAmount(numGen1sOwned, numGen2sOwned);\n\n        // not eligible to claim any rares\n        require((amount > 0 && ownerRareTokens[msg.sender] < amount), \"not eligible\");\n\n        // a wallet with a gen 1 and 2 can claim a token.\n        for (uint i = 0; i < amount; i++) {\n            _transfer(address(this), msg.sender, nextRareTokenIdToClaim + i);\n        }\n\n        ownerRareTokens[msg.sender] += amount;\n        ownerRareTokens[address(this)] -= amount;\n        nextRareTokenIdToClaim += amount;\n    }","contract":"ChibiGalaxy","time":0},{"type":"external-function ","before":"function specialEventMint(bytes32[] memory proof) external payable {\n        require(!preMintPaused, \"mint paused\");\n        require(isAddressWhitelistedForSpecialEvent(proof, msg.sender), \"not eligible\");\n\n        // verify that the client sent enough eth to pay for the mint\n        uint remainder = msg.value % publicMintPrice;\n        require(remainder == 0, \"send a divisible amount of eth\");\n\n        // calculate the amount of tokens we are minting based on the amount of eth sent\n        uint amount = msg.value / publicMintPrice;\n        require(amount > 0, \"amount to mint is 0\");\n\n        require(specialMintTokens[msg.sender] < maxItemsForSpecialMint, \"already minted max\");\n        require(specialMintTokens[msg.sender] + amount < maxItemsForSpecialMint, \"will surpass special mint cap\");\n\n        _mintWithoutValidation(msg.sender, amount);\n    }","after":"function specialEventMint(bytes32[] calldata proof) external payable {\n        require(!preMintPaused, \"mint paused\");\n        require(isAddressWhitelistedForSpecialEvent(proof, msg.sender), \"not eligible\");\n\n        // verify that the client sent enough eth to pay for the mint\n        uint remainder = msg.value % publicMintPrice;\n        require(remainder == 0, \"send a divisible amount of eth\");\n\n        // calculate the amount of tokens we are minting based on the amount of eth sent\n        uint amount = msg.value / publicMintPrice;\n        require(amount > 0, \"amount to mint is 0\");\n\n        require(specialMintTokens[msg.sender] < maxItemsForSpecialMint, \"already minted max\");\n        require(specialMintTokens[msg.sender] + amount < maxItemsForSpecialMint, \"will surpass special mint cap\");\n\n        _mintWithoutValidation(msg.sender, amount);\n    }","contract":"ChibiGalaxy","time":0},{"type":"external-function ","before":"function publicMint(bytes32[] memory proof) external payable {\n        // publicMintPaused is set by owner calling pausePublicMint and unpausePublicMint\n        require(!publicMintPaused, \"mint paused\");\n        // verify that the client sent enough eth to pay for the mint\n        uint remainder = msg.value % publicMintPrice;\n        require(remainder == 0, \"send a divisible amount of eth\");\n\n        // calculate the amount of tokens we are minting based on the amount of eth sent\n        uint amount = msg.value / publicMintPrice;\n\n        require(amount <= maxItemsPerTx, \"max 5 per tx\");\n\n        // onlyWhitelistedCanMint is set by calling setOnlyWhitelistedCanMint\n        if (onlyWhitelistedCanMint){\n            uint numGen1sOwned = numGeneration1sOwned();\n            uint numGen2sOwned = numGeneration2sOwned();\n            // perform the following only for wallets that don't have a gen 1 or gen 2\n            if (numGen1sOwned == 0 && numGen2sOwned == 0) {\n                // should not throw if user is whitelisted, the amount being minted is equal to their whitelisted value and they\n                // have not minted already.\n                require(isAddressWhitelisted(proof, msg.sender), \"not eligible to mint\");\n            }\n        }\n\n        _mintWithoutValidation(msg.sender, amount);\n    }","after":"function publicMint(bytes32[] calldata proof) external payable {\n        // publicMintPaused is set by owner calling pausePublicMint and unpausePublicMint\n        require(!publicMintPaused, \"mint paused\");\n        // verify that the client sent enough eth to pay for the mint\n        uint remainder = msg.value % publicMintPrice;\n        require(remainder == 0, \"send a divisible amount of eth\");\n\n        // calculate the amount of tokens we are minting based on the amount of eth sent\n        uint amount = msg.value / publicMintPrice;\n\n        require(amount <= maxItemsPerTx, \"max 5 per tx\");\n\n        // onlyWhitelistedCanMint is set by calling setOnlyWhitelistedCanMint\n        if (onlyWhitelistedCanMint){\n            uint numGen1sOwned = numGeneration1sOwned();\n            uint numGen2sOwned = numGeneration2sOwned();\n            // perform the following only for wallets that don't have a gen 1 or gen 2\n            if (numGen1sOwned == 0 && numGen2sOwned == 0) {\n                // should not throw if user is whitelisted, the amount being minted is equal to their whitelisted value and they\n                // have not minted already.\n                require(isAddressWhitelisted(proof, msg.sender), \"not eligible to mint\");\n            }\n        }\n\n        _mintWithoutValidation(msg.sender, amount);\n    }","contract":"ChibiGalaxy","time":0},{"type":"external-function ","before":"function setBaseTokenURI(string memory _baseTokenURI) external onlyOwner {\n        baseTokenURI = _baseTokenURI;\n    }","after":"function setBaseTokenURI(string calldata _baseTokenURI) external onlyOwner {\n        baseTokenURI = _baseTokenURI;\n    }","contract":"ChibiGalaxy","time":0},{"type":"constant-restrict-modification  ","before":"uint public collectionSize = 7000;","after":"uint public constant collectionSize = 7000;","contract":"ChibiGalaxy","time":0},{"type":"constant-restrict-modification  ","before":"uint public giveawayMaxItems = 100;","after":"uint public constant giveawayMaxItems = 100;","contract":"ChibiGalaxy","time":0},{"type":"constant-restrict-modification  ","before":"uint public maxRareTokens = 140;","after":"uint public constant maxRareTokens = 140;","contract":"ChibiGalaxy","time":0}]}