{"time":197,"results":[{"type":"external-function ","before":"function registerSecretBatch(bytes32[] memory secrets) public returns (bool) {\n        bool completeSuccess = true;\n        for(uint i = 0; i < secrets.length; i++) {\n            if(!registerSecret(secrets[i])) {\n                completeSuccess = false;\n            }\n        }\n        return completeSuccess;\n    }","after":"function registerSecretBatch(bytes32[] calldata secrets) public returns (bool) {\n        bool completeSuccess = true;\n        for(uint i = 0; i < secrets.length; i++) {\n            if(!registerSecret(secrets[i])) {\n                completeSuccess = false;\n            }\n        }\n        return completeSuccess;\n    }","contract":"SecretRegistry","time":0},{"type":"external-function ","before":"function closeChannel(\n        uint256 channel_identifier,\n        address non_closing_participant,\n        address closing_participant,\n        // The next four arguments form a balance proof.\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes memory non_closing_signature,\n        bytes memory closing_signature\n    )\n        public\n        isOpen(channel_identifier)\n    {\n        require(channel_identifier == getChannelIdentifier(closing_participant, non_closing_participant));\n\n        address recovered_non_closing_participant_address;\n\n        Channel storage channel = channels[channel_identifier];\n\n        channel.state = ChannelState.Closed;\n        channel.participants[closing_participant].is_the_closer = true;\n\n        // This is the block number at which the channel can be settled.\n        channel.settle_block_number += uint256(block.number);\n\n        // The closing participant must have signed the balance proof.\n        address recovered_closing_participant_address = recoverAddressFromBalanceProofCounterSignature(\n            MessageTypeId.BalanceProof,\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash,\n            non_closing_signature,\n            closing_signature\n        );\n        require(closing_participant == recovered_closing_participant_address);\n\n        // Nonce 0 means that the closer never received a transfer, therefore\n        // never received a balance proof, or he is intentionally not providing\n        // the latest transfer, in which case the closing party is going to\n        // lose the tokens that were transferred to him.\n        if (nonce > 0) {\n            recovered_non_closing_participant_address = recoverAddressFromBalanceProof(\n                channel_identifier,\n                balance_hash,\n                nonce,\n                additional_hash,\n                non_closing_signature\n            );\n            // Signature must be from the channel partner\n            require(non_closing_participant == recovered_non_closing_participant_address);\n\n            updateBalanceProofData(\n                channel,\n                recovered_non_closing_participant_address,\n                nonce,\n                balance_hash\n            );\n        }\n\n        emit ChannelClosed(channel_identifier, closing_participant, nonce, balance_hash);\n    }","after":"function closeChannel(\n        uint256 channel_identifier,\n        address non_closing_participant,\n        address closing_participant,\n        // The next four arguments form a balance proof.\n        bytes32 balance_hash,\n        uint256 nonce,\n        bytes32 additional_hash,\n        bytes calldata non_closing_signature,\n        bytes calldata closing_signature\n    )\n        public\n        isOpen(channel_identifier)\n    {\n        require(channel_identifier == getChannelIdentifier(closing_participant, non_closing_participant));\n\n        address recovered_non_closing_participant_address;\n\n        Channel storage channel = channels[channel_identifier];\n\n        channel.state = ChannelState.Closed;\n        channel.participants[closing_participant].is_the_closer = true;\n\n        // This is the block number at which the channel can be settled.\n        channel.settle_block_number += uint256(block.number);\n\n        // The closing participant must have signed the balance proof.\n        address recovered_closing_participant_address = recoverAddressFromBalanceProofCounterSignature(\n            MessageTypeId.BalanceProof,\n            channel_identifier,\n            balance_hash,\n            nonce,\n            additional_hash,\n            non_closing_signature,\n            closing_signature\n        );\n        require(closing_participant == recovered_closing_participant_address);\n\n        // Nonce 0 means that the closer never received a transfer, therefore\n        // never received a balance proof, or he is intentionally not providing\n        // the latest transfer, in which case the closing party is going to\n        // lose the tokens that were transferred to him.\n        if (nonce > 0) {\n            recovered_non_closing_participant_address = recoverAddressFromBalanceProof(\n                channel_identifier,\n                balance_hash,\n                nonce,\n                additional_hash,\n                non_closing_signature\n            );\n            // Signature must be from the channel partner\n            require(non_closing_participant == recovered_non_closing_participant_address);\n\n            updateBalanceProofData(\n                channel,\n                recovered_non_closing_participant_address,\n                nonce,\n                balance_hash\n            );\n        }\n\n        emit ChannelClosed(channel_identifier, closing_participant, nonce, balance_hash);\n    }","contract":"TokenNetwork","time":1},{"type":"external-function ","before":"function unlock(\n        uint256 channel_identifier,\n        address receiver,\n        address sender,\n        bytes memory locks\n    )\n        public\n    {\n        // Channel represented by channel_identifier must be settled and\n        // channel data deleted\n        require(channel_identifier != getChannelIdentifier(receiver, sender));\n\n        // After the channel is settled the storage is cleared, therefore the\n        // value will be NonExistent and not Settled. The value Settled is used\n        // for the external APIs\n        require(channels[channel_identifier].state == ChannelState.NonExistent);\n\n        bytes32 unlock_key;\n        bytes32 computed_locksroot;\n        uint256 unlocked_amount;\n        uint256 locked_amount;\n        uint256 returned_tokens;\n\n        // Calculate the locksroot for the pending transfers and the amount of\n        // tokens corresponding to the locked transfers with secrets revealed\n        // on chain.\n        (computed_locksroot, unlocked_amount) = getHashAndUnlockedAmount(\n            locks\n        );\n\n        // The sender must have a non-empty locksroot on-chain that must be\n        // the same as the computed locksroot.\n        // Get the amount of tokens that have been left in the contract, to\n        // account for the pending transfers `sender` -> `receiver`.\n        unlock_key = getUnlockIdentifier(channel_identifier, sender, receiver);\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[unlock_key];\n        locked_amount = unlock_data.locked_amount;\n\n        // Locksroot must be the same as the computed locksroot\n        require(unlock_data.locksroot == computed_locksroot);\n\n        // There are no pending transfers if the locked_amount is 0.\n        // Transaction must fail\n        require(locked_amount > 0);\n\n        // Make sure we don't transfer more tokens than previously reserved in\n        // the smart contract.\n        unlocked_amount = min(unlocked_amount, locked_amount);\n\n        // Transfer the rest of the tokens back to the sender\n        returned_tokens = locked_amount - unlocked_amount;\n\n        // Remove sender's unlock data\n        delete unlock_identifier_to_unlock_data[unlock_key];\n\n        emit ChannelUnlocked(\n            channel_identifier,\n            receiver,\n            sender,\n            computed_locksroot,\n            unlocked_amount,\n            returned_tokens\n        );\n\n        // Transfer the unlocked tokens to the receiver. unlocked_amount can\n        // be 0\n        if (unlocked_amount > 0) {\n            require(token.transfer(receiver, unlocked_amount));\n        }\n\n        // Transfer the rest of the tokens back to the sender\n        if (returned_tokens > 0) {\n            require(token.transfer(sender, returned_tokens));\n        }\n\n        // At this point, this should always be true\n        assert(locked_amount >= returned_tokens);\n        assert(locked_amount >= unlocked_amount);\n    }","after":"function unlock(\n        uint256 channel_identifier,\n        address receiver,\n        address sender,\n        bytes calldata locks\n    )\n        public\n    {\n        // Channel represented by channel_identifier must be settled and\n        // channel data deleted\n        require(channel_identifier != getChannelIdentifier(receiver, sender));\n\n        // After the channel is settled the storage is cleared, therefore the\n        // value will be NonExistent and not Settled. The value Settled is used\n        // for the external APIs\n        require(channels[channel_identifier].state == ChannelState.NonExistent);\n\n        bytes32 unlock_key;\n        bytes32 computed_locksroot;\n        uint256 unlocked_amount;\n        uint256 locked_amount;\n        uint256 returned_tokens;\n\n        // Calculate the locksroot for the pending transfers and the amount of\n        // tokens corresponding to the locked transfers with secrets revealed\n        // on chain.\n        (computed_locksroot, unlocked_amount) = getHashAndUnlockedAmount(\n            locks\n        );\n\n        // The sender must have a non-empty locksroot on-chain that must be\n        // the same as the computed locksroot.\n        // Get the amount of tokens that have been left in the contract, to\n        // account for the pending transfers `sender` -> `receiver`.\n        unlock_key = getUnlockIdentifier(channel_identifier, sender, receiver);\n        UnlockData storage unlock_data = unlock_identifier_to_unlock_data[unlock_key];\n        locked_amount = unlock_data.locked_amount;\n\n        // Locksroot must be the same as the computed locksroot\n        require(unlock_data.locksroot == computed_locksroot);\n\n        // There are no pending transfers if the locked_amount is 0.\n        // Transaction must fail\n        require(locked_amount > 0);\n\n        // Make sure we don't transfer more tokens than previously reserved in\n        // the smart contract.\n        unlocked_amount = min(unlocked_amount, locked_amount);\n\n        // Transfer the rest of the tokens back to the sender\n        returned_tokens = locked_amount - unlocked_amount;\n\n        // Remove sender's unlock data\n        delete unlock_identifier_to_unlock_data[unlock_key];\n\n        emit ChannelUnlocked(\n            channel_identifier,\n            receiver,\n            sender,\n            computed_locksroot,\n            unlocked_amount,\n            returned_tokens\n        );\n\n        // Transfer the unlocked tokens to the receiver. unlocked_amount can\n        // be 0\n        if (unlocked_amount > 0) {\n            require(token.transfer(receiver, unlocked_amount));\n        }\n\n        // Transfer the rest of the tokens back to the sender\n        if (returned_tokens > 0) {\n            require(token.transfer(sender, returned_tokens));\n        }\n\n        // At this point, this should always be true\n        assert(locked_amount >= returned_tokens);\n        assert(locked_amount >= unlocked_amount);\n    }","contract":"TokenNetwork","time":0}]}