{"time":147,"results":[{"type":"state-data-arrangement ","before":"\naddress private _upgradeAgent;\nuint256 private _totalUpgraded = 0;\nbool private _upgradeReady = false;","after":"uint256 private _totalUpgraded = 0;\naddress private _upgradeAgent;\nbool private _upgradeReady = false;\n","contract":"ERC223Upgradeable","time":0},{"type":"state-data-arrangement ","before":"\naddress private _odrAddress;\nuint private _releaseDate;\nbool private _released = false;","after":"uint private _releaseDate;\naddress private _odrAddress;\nbool private _released = false;\n","contract":"OdrToken","time":0},{"type":"external-function ","before":"function transferFrom(address sender, address recipient, uint256 amount, bytes memory data) public returns (bool) {\n        _transfer(sender, recipient, amount, data); //has fallback if recipient isn't msg.sender\n         //has fallback if not msg sender:\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC223: transfer amount exceeds allowance\"), data);\n        return true;\n    }","after":"function transferFrom(address sender, address recipient, uint256 amount, bytes calldata data) public returns (bool) {\n        _transfer(sender, recipient, amount, data); //has fallback if recipient isn't msg.sender\n         //has fallback if not msg sender:\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC223: transfer amount exceeds allowance\"), data);\n        return true;\n    }","contract":"IownToken","time":0},{"type":"external-function ","before":"function transfer(address recipient, uint256 amount, bytes memory data) public returns (bool success){\n        _transfer(_msgSender(), recipient, amount, data);\n        return true;\n    }","after":"function transfer(address recipient, uint256 amount, bytes calldata data) public returns (bool success){\n        _transfer(_msgSender(), recipient, amount, data);\n        return true;\n    }","contract":"IownToken","time":0},{"type":"external-function ","before":"function approve(address spender, uint256 amount, bytes memory data) public returns (bool) {\n        _approve(_msgSender(), spender, amount, data);\n        return true;\n    }","after":"function approve(address spender, uint256 amount, bytes calldata data) public returns (bool) {\n        _approve(_msgSender(), spender, amount, data);\n        return true;\n    }","contract":"IownToken","time":0},{"type":"external-function ","before":"function transferFor(address beneficiary, address recipient, uint256 amount, bytes memory data) public returns (bool) {\n        address sender = _msgSender();\n        require(beneficiary != address(0), \"ERC223E: transfer for the zero address\");\n        require(recipient != address(0), \"ERC223: transfer to the zero address\");\n        require(beneficiary != sender, \"ERC223: sender and beneficiary cannot be the same\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC223: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        //ERC223 Extra logic:\n        if(Address.isContract(recipient) && _msgSender() != recipient) {\n            IERC223ExtendedRecipient receiver = IERC223ExtendedRecipient(recipient);\n            receiver.tokenForFallback(sender, beneficiary, amount, data);\n        }\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }","after":"function transferFor(address beneficiary, address recipient, uint256 amount, bytes calldata data) public returns (bool) {\n        address sender = _msgSender();\n        require(beneficiary != address(0), \"ERC223E: transfer for the zero address\");\n        require(recipient != address(0), \"ERC223: transfer to the zero address\");\n        require(beneficiary != sender, \"ERC223: sender and beneficiary cannot be the same\");\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC223: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        //ERC223 Extra logic:\n        if(Address.isContract(recipient) && _msgSender() != recipient) {\n            IERC223ExtendedRecipient receiver = IERC223ExtendedRecipient(recipient);\n            receiver.tokenForFallback(sender, beneficiary, amount, data);\n        }\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }","contract":"IownToken","time":0},{"type":"external-function ","before":"function approveFor(address beneficiary, address spender, uint256 amount, bytes memory data) public returns (bool) {\n        address agent = _msgSender();\n        require(agent != address(0), \"ERC223: approve from the zero address\");\n        require(spender != address(0), \"ERC223: approve to the zero address\");\n        require(beneficiary != agent, \"ERC223: sender and beneficiary cannot be the same\");\n\n        _allowances[agent][spender] = amount;\n        //ERC223 Extra logic:\n        if(Address.isContract(spender) && _msgSender() != spender) {\n            IERC223ExtendedRecipient receiver = IERC223ExtendedRecipient(spender);\n            receiver.approveForFallback(agent, beneficiary, amount, data);\n        }\n        emit Approval(agent, spender, amount);\n        return true;\n    }","after":"function approveFor(address beneficiary, address spender, uint256 amount, bytes calldata data) public returns (bool) {\n        address agent = _msgSender();\n        require(agent != address(0), \"ERC223: approve from the zero address\");\n        require(spender != address(0), \"ERC223: approve to the zero address\");\n        require(beneficiary != agent, \"ERC223: sender and beneficiary cannot be the same\");\n\n        _allowances[agent][spender] = amount;\n        //ERC223 Extra logic:\n        if(Address.isContract(spender) && _msgSender() != spender) {\n            IERC223ExtendedRecipient receiver = IERC223ExtendedRecipient(spender);\n            receiver.approveForFallback(agent, beneficiary, amount, data);\n        }\n        emit Approval(agent, spender, amount);\n        return true;\n    }","contract":"IownToken","time":0},{"type":"external-function ","before":"function transfer(address recipient, uint256 amount, bytes memory data) public whenNotPaused returns (bool success) {\n        return super.transfer(recipient, amount, data);\n    }","after":"function transfer(address recipient, uint256 amount, bytes calldata data) public whenNotPaused returns (bool success) {\n        return super.transfer(recipient, amount, data);\n    }","contract":"IownToken","time":0},{"type":"external-function ","before":"function approve(address spender, uint256 amount, bytes memory data) public whenNotPaused returns (bool) {\n        return super.approve(spender, amount, data);\n    }","after":"function approve(address spender, uint256 amount, bytes calldata data) public whenNotPaused returns (bool) {\n        return super.approve(spender, amount, data);\n    }","contract":"IownToken","time":0},{"type":"external-function ","before":"function transferFor(address beneficiary, address recipient, uint256 amount, bytes memory data) public whenNotPaused returns (bool) {\n        return super.transferFor(beneficiary, recipient, amount, data);\n    }","after":"function transferFor(address beneficiary, address recipient, uint256 amount, bytes calldata data) public whenNotPaused returns (bool) {\n        return super.transferFor(beneficiary, recipient, amount, data);\n    }","contract":"IownToken","time":0},{"type":"external-function ","before":"function approveFor(address beneficiary, address spender, uint256 amount, bytes memory data) public whenNotPaused returns (bool) {\n        return super.approveFor(beneficiary, spender, amount, data);\n    }","after":"function approveFor(address beneficiary, address spender, uint256 amount, bytes calldata data) public whenNotPaused returns (bool) {\n        return super.approveFor(beneficiary, spender, amount, data);\n    }","contract":"IownToken","time":0}]}