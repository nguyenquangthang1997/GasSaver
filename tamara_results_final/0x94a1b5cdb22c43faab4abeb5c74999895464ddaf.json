{"time":48,"results":[{"type":"state-data-arrangement ","before":"\nuint256 public levels;\nuint8 constant ROOT_HISTORY_SIZE = 100;\nuint256[] private _roots;\nuint256 public current_root = 0;\nuint256[] private _filled_subtrees;\nuint256[] private _zeros;\nuint32 public next_index = 0;","after":"uint256 public levels;\nuint256[] private _roots;\nuint256 public current_root = 0;\nuint256[] private _filled_subtrees;\nuint256[] private _zeros;\nuint32 public next_index = 0;\nuint8 constant ROOT_HISTORY_SIZE = 100;\n","contract":"MerkleTreeWithHistory","time":1},{"type":"external-function ","before":"function withdraw(uint256[2] memory a, uint256[2][2] memory b, uint256[2] memory c, uint256[4] memory input) public {\n    uint256 root = input[0];\n    uint256 nullifierHash = input[1];\n    address payable receiver = address(input[2]);\n    uint256 fee = input[3];\n\n    require(!nullifierHashes[nullifierHash], \"The note has been already spent\");\n    require(fee < transferValue, \"Fee exceeds transfer value\");\n    require(isKnownRoot(root), \"Cannot find your merkle root\"); // Make sure to use a recent one\n    require(verifier.verifyProof(a, b, c, input), \"Invalid withdraw proof\");\n\n    nullifierHashes[nullifierHash] = true;\n    receiver.transfer(transferValue - fee);\n    if (fee > 0) {\n      operator.transfer(fee);\n    }\n    emit Withdraw(receiver, nullifierHash, fee);\n  }","after":"function withdraw(uint256[2] calldata a, uint256[2][2] calldata b, uint256[2] calldata c, uint256[4] calldata input) public {\n    uint256 root = input[0];\n    uint256 nullifierHash = input[1];\n    address payable receiver = address(input[2]);\n    uint256 fee = input[3];\n\n    require(!nullifierHashes[nullifierHash], \"The note has been already spent\");\n    require(fee < transferValue, \"Fee exceeds transfer value\");\n    require(isKnownRoot(root), \"Cannot find your merkle root\"); // Make sure to use a recent one\n    require(verifier.verifyProof(a, b, c, input), \"Invalid withdraw proof\");\n\n    nullifierHashes[nullifierHash] = true;\n    receiver.transfer(transferValue - fee);\n    if (fee > 0) {\n      operator.transfer(fee);\n    }\n    emit Withdraw(receiver, nullifierHash, fee);\n  }","contract":"Mixer","time":0}]}