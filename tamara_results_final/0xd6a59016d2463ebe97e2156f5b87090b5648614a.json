{"time":18,"results":[{"type":"external-function ","before":"function trade(address input_asset,\n                 uint256 input_amount,\n                 address output_asset,\n                 uint256 min_output_amount,\n                 address trade_contract,\n                 bytes memory trade_data) public  {\n    \n    uint256[3] memory m_in;\n    \n    uint256[1] memory m_out;\n    uint256 output_amount;\n    assembly {\n      if xor(caller, sload(_owner_slot)) {\n        mstore(32, 0)\n        revert(63, 1)\n      }\n      {\n        if xor(sload(_run_state_slot), 1) {\n          mstore(32, 1)\n          revert(63, 1)\n        }\n        sstore(_run_state_slot, 2)\n      }\n      let capital_source := sload(_parent_address_slot)\n      {\n        mstore(m_in, /* fn_hash(\"getCapital(address,uint256)\") */ 0x0a681c5900000000000000000000000000000000000000000000000000000000)\n        mstore(add(m_in, 0x04), input_asset)\n        mstore(add(m_in, 0x24), input_amount)\n        let res := call(gas, capital_source, 0, m_in, 0x44, 0, 0)\n        if iszero(res) {\n          mstore(32, 2)\n          revert(63, 1)\n        }\n      }\n      if input_asset {\n        {\n          mstore(m_in, /* fn_hash(\"approve(address,uint256)\") */ 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n          mstore(add(m_in, 4), trade_contract)\n          mstore(add(m_in, 0x24), input_amount)\n          mstore(m_out, 0)\n          let res := call(gas, input_asset, 0, m_in, 0x44, m_out, 0x20)\n          if or(iszero(res), iszero(mload(m_out))) {\n            mstore(32, 4)\n            revert(63, 1)\n          }\n        }\n      }\n      let before_balance := balance(address)\n      if output_asset {\n        {\n          mstore(m_in, /* fn_hash(\"balanceOf(address)\") */ 0x70a0823100000000000000000000000000000000000000000000000000000000)\n          mstore(add(m_in, 4), address)\n          mstore(m_out, 0)\n          let res := staticcall(gas, output_asset, m_in, 0x24, m_out, 0x20)\n          if iszero(res) {\n            mstore(32, 5)\n            revert(63, 1)\n          }\n        }\n        before_balance := mload(m_out)\n      }\n      {\n        if iszero(extcodesize(trade_contract)) {\n          mstore(32, 5)\n          revert(63, 1)\n        }\n        let wei_to_send := input_amount\n        if input_asset {\n          wei_to_send := 0\n        }\n        let res := call(gas, trade_contract, wei_to_send, add(trade_data, 0x20), mload(trade_data), 0, 0)\n        if iszero(res) {\n          mstore(32, 7)\n          revert(63, 1)\n        }\n      }\n      if input_asset {\n        {\n          mstore(m_in, /* fn_hash(\"approve(address,uint256)\") */ 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n          mstore(add(m_in, 4), trade_contract)\n          mstore(add(m_in, 0x24), 0)\n          mstore(m_out, 0)\n          let res := call(gas, input_asset, 0, m_in, 0x44, m_out, 0x20)\n          if or(iszero(res), iszero(mload(m_out))) {\n            mstore(32, 8)\n            revert(63, 1)\n          }\n        }\n      }\n      let after_balance := balance(address)\n      if output_asset {\n        {\n          mstore(m_in, /* fn_hash(\"balanceOf(address)\") */ 0x70a0823100000000000000000000000000000000000000000000000000000000)\n          mstore(add(m_in, 4), address)\n          mstore(m_out, 0)\n          let res := staticcall(gas, output_asset, m_in, 0x24, m_out, 0x20)\n          if iszero(res) {\n            mstore(32, 9)\n            revert(63, 1)\n          }\n        }\n        after_balance := mload(m_out)\n      }\n      if lt(after_balance, before_balance) {\n        mstore(32, 10)\n        revert(63, 1)\n      }\n      output_amount := sub(after_balance, before_balance)\n      if lt(output_amount, min_output_amount) {\n        mstore(32, 11)\n        revert(63, 1)\n      }\n    }\n    depositToCompound(output_asset, output_amount);\n    uint256 fee;\n    uint256 return_amount;\n    assembly {\n      fee := div(input_amount, 200)\n      return_amount := add(fee, input_amount)\n    }\n    _withdraw(input_asset, return_amount, address(_parent_address));\n    assembly {\n      sstore(_run_state_slot, 1)\n      \n      /* Log event: Trade */\n      mstore(m_in, input_asset)\n      mstore(add(m_in, 32), output_asset)\n      mstore(add(m_in, 64), input_amount)\n      mstore(add(m_in, 96), output_amount)\n      mstore(add(m_in, 128), fee)\n      log2(m_in, 160, /* Trade */ 0x4a2af5744adbfadba82ab831aea212bad92f5a70fef2079562044f423e999851, trade_contract)\n    }\n  }","after":"function trade(address input_asset,\n                 uint256 input_amount,\n                 address output_asset,\n                 uint256 min_output_amount,\n                 address trade_contract,\n                 bytes calldata trade_data) public  {\n    \n    uint256[3] memory m_in;\n    \n    uint256[1] memory m_out;\n    uint256 output_amount;\n    assembly {\n      if xor(caller, sload(_owner_slot)) {\n        mstore(32, 0)\n        revert(63, 1)\n      }\n      {\n        if xor(sload(_run_state_slot), 1) {\n          mstore(32, 1)\n          revert(63, 1)\n        }\n        sstore(_run_state_slot, 2)\n      }\n      let capital_source := sload(_parent_address_slot)\n      {\n        mstore(m_in, /* fn_hash(\"getCapital(address,uint256)\") */ 0x0a681c5900000000000000000000000000000000000000000000000000000000)\n        mstore(add(m_in, 0x04), input_asset)\n        mstore(add(m_in, 0x24), input_amount)\n        let res := call(gas, capital_source, 0, m_in, 0x44, 0, 0)\n        if iszero(res) {\n          mstore(32, 2)\n          revert(63, 1)\n        }\n      }\n      if input_asset {\n        {\n          mstore(m_in, /* fn_hash(\"approve(address,uint256)\") */ 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n          mstore(add(m_in, 4), trade_contract)\n          mstore(add(m_in, 0x24), input_amount)\n          mstore(m_out, 0)\n          let res := call(gas, input_asset, 0, m_in, 0x44, m_out, 0x20)\n          if or(iszero(res), iszero(mload(m_out))) {\n            mstore(32, 4)\n            revert(63, 1)\n          }\n        }\n      }\n      let before_balance := balance(address)\n      if output_asset {\n        {\n          mstore(m_in, /* fn_hash(\"balanceOf(address)\") */ 0x70a0823100000000000000000000000000000000000000000000000000000000)\n          mstore(add(m_in, 4), address)\n          mstore(m_out, 0)\n          let res := staticcall(gas, output_asset, m_in, 0x24, m_out, 0x20)\n          if iszero(res) {\n            mstore(32, 5)\n            revert(63, 1)\n          }\n        }\n        before_balance := mload(m_out)\n      }\n      {\n        if iszero(extcodesize(trade_contract)) {\n          mstore(32, 5)\n          revert(63, 1)\n        }\n        let wei_to_send := input_amount\n        if input_asset {\n          wei_to_send := 0\n        }\n        let res := call(gas, trade_contract, wei_to_send, add(trade_data, 0x20), mload(trade_data), 0, 0)\n        if iszero(res) {\n          mstore(32, 7)\n          revert(63, 1)\n        }\n      }\n      if input_asset {\n        {\n          mstore(m_in, /* fn_hash(\"approve(address,uint256)\") */ 0x095ea7b300000000000000000000000000000000000000000000000000000000)\n          mstore(add(m_in, 4), trade_contract)\n          mstore(add(m_in, 0x24), 0)\n          mstore(m_out, 0)\n          let res := call(gas, input_asset, 0, m_in, 0x44, m_out, 0x20)\n          if or(iszero(res), iszero(mload(m_out))) {\n            mstore(32, 8)\n            revert(63, 1)\n          }\n        }\n      }\n      let after_balance := balance(address)\n      if output_asset {\n        {\n          mstore(m_in, /* fn_hash(\"balanceOf(address)\") */ 0x70a0823100000000000000000000000000000000000000000000000000000000)\n          mstore(add(m_in, 4), address)\n          mstore(m_out, 0)\n          let res := staticcall(gas, output_asset, m_in, 0x24, m_out, 0x20)\n          if iszero(res) {\n            mstore(32, 9)\n            revert(63, 1)\n          }\n        }\n        after_balance := mload(m_out)\n      }\n      if lt(after_balance, before_balance) {\n        mstore(32, 10)\n        revert(63, 1)\n      }\n      output_amount := sub(after_balance, before_balance)\n      if lt(output_amount, min_output_amount) {\n        mstore(32, 11)\n        revert(63, 1)\n      }\n    }\n    depositToCompound(output_asset, output_amount);\n    uint256 fee;\n    uint256 return_amount;\n    assembly {\n      fee := div(input_amount, 200)\n      return_amount := add(fee, input_amount)\n    }\n    _withdraw(input_asset, return_amount, address(_parent_address));\n    assembly {\n      sstore(_run_state_slot, 1)\n      \n      /* Log event: Trade */\n      mstore(m_in, input_asset)\n      mstore(add(m_in, 32), output_asset)\n      mstore(add(m_in, 64), input_amount)\n      mstore(add(m_in, 96), output_amount)\n      mstore(add(m_in, 128), fee)\n      log2(m_in, 160, /* Trade */ 0x4a2af5744adbfadba82ab831aea212bad92f5a70fef2079562044f423e999851, trade_contract)\n    }\n  }","contract":"MarginSwap","time":1}]}