{"time":288,"results":[{"type":"external-function ","before":"function performNetworkTrades(\n        uint256[] memory _values,\n        address[] memory _addresses,\n        address[] memory _marketDapps\n    )\n        public\n        returns (uint256[] memory)\n    {\n        uint256[] memory increments = new uint256[](_addresses.length / 2);\n        // i = 1 + numOffers * 2\n        uint256 i = 1 + (_values[0] & ~(~uint256(0) << 8)) * 2;\n        uint256 end = _values.length;\n\n        // loop matches\n        for(i; i < end; i++) {\n            uint256[] memory data = new uint256[](9);\n            data[0] = _values[i]; // match data\n            data[1] = data[0] & ~(~uint256(0) << 8); // offerIndex\n            data[2] = (data[0] & ~(~uint256(0) << 24)) >> 16; // operator.surplusAssetIndex\n            data[3] = _values[data[1] * 2 + 1]; // offer.dataA\n            data[4] = _values[data[1] * 2 + 2]; // offer.dataB\n            data[5] = ((data[3] & ~(~uint256(0) << 16)) >> 8); // maker.offerAssetIndex\n            data[6] = ((data[3] & ~(~uint256(0) << 24)) >> 16); // maker.wantAssetIndex\n            // amount of offerAssetId to take from offer is equal to the match.takeAmount\n            data[7] = data[0] >> 128;\n            // expected amount to receive is: matchData.takeAmount * offer.wantAmount / offer.offerAmount\n            data[8] = data[7].mul(data[4] >> 128).div(data[4] & ~(~uint256(0) << 128));\n\n            address[] memory assetIds = new address[](3);\n            assetIds[0] = _addresses[data[5] * 2 + 1]; // offer.offerAssetId\n            assetIds[1] = _addresses[data[6] * 2 + 1]; // offer.wantAssetId\n            assetIds[2] = _addresses[data[2] * 2 + 1]; // surplusAssetId\n\n            uint256[] memory dataValues = new uint256[](3);\n            dataValues[0] = data[7]; // the proportion of offerAmount to offer\n            dataValues[1] = data[8]; // the propotionate wantAmount of the offer\n            dataValues[2] = data[0]; // match data\n\n            increments[data[2]] = _performNetworkTrade(\n                assetIds,\n                dataValues,\n                _marketDapps,\n                _addresses\n            );\n        }\n\n        return increments;\n    }","after":"function performNetworkTrades(\n        uint256[] calldata _values,\n        address[] calldata _addresses,\n        address[] calldata _marketDapps\n    )\n        public\n        returns (uint256[] memory)\n    {\n        uint256[] memory increments = new uint256[](_addresses.length / 2);\n        // i = 1 + numOffers * 2\n        uint256 i = 1 + (_values[0] & ~(~uint256(0) << 8)) * 2;\n        uint256 end = _values.length;\n\n        // loop matches\n        for(i; i < end; i++) {\n            uint256[] memory data = new uint256[](9);\n            data[0] = _values[i]; // match data\n            data[1] = data[0] & ~(~uint256(0) << 8); // offerIndex\n            data[2] = (data[0] & ~(~uint256(0) << 24)) >> 16; // operator.surplusAssetIndex\n            data[3] = _values[data[1] * 2 + 1]; // offer.dataA\n            data[4] = _values[data[1] * 2 + 2]; // offer.dataB\n            data[5] = ((data[3] & ~(~uint256(0) << 16)) >> 8); // maker.offerAssetIndex\n            data[6] = ((data[3] & ~(~uint256(0) << 24)) >> 16); // maker.wantAssetIndex\n            // amount of offerAssetId to take from offer is equal to the match.takeAmount\n            data[7] = data[0] >> 128;\n            // expected amount to receive is: matchData.takeAmount * offer.wantAmount / offer.offerAmount\n            data[8] = data[7].mul(data[4] >> 128).div(data[4] & ~(~uint256(0) << 128));\n\n            address[] memory assetIds = new address[](3);\n            assetIds[0] = _addresses[data[5] * 2 + 1]; // offer.offerAssetId\n            assetIds[1] = _addresses[data[6] * 2 + 1]; // offer.wantAssetId\n            assetIds[2] = _addresses[data[2] * 2 + 1]; // surplusAssetId\n\n            uint256[] memory dataValues = new uint256[](3);\n            dataValues[0] = data[7]; // the proportion of offerAmount to offer\n            dataValues[1] = data[8]; // the propotionate wantAmount of the offer\n            dataValues[2] = data[0]; // match data\n\n            increments[data[2]] = _performNetworkTrade(\n                assetIds,\n                dataValues,\n                _marketDapps,\n                _addresses\n            );\n        }\n\n        return increments;\n    }","contract":"Utils","time":0},{"type":"external-function ","before":"function trade(\n        address[] memory _assetIds,\n        uint256[] memory _dataValues,\n        address[] memory /* _addresses */,\n        address payable _recipient\n    )\n        public\n        payable\n    {\n        // _dataValues[2] bits(24..56): delay\n        uint256 deadline = now.add((_dataValues[2] & ~(~uint256(0) << 56)) >> 24);\n\n        if (_assetIds[0] == ETHER_ADDR) {\n            UniswapExchange exchange = UniswapExchange(factory.getExchange(_assetIds[1]));\n            exchange.ethToTokenTransferInput.value(_dataValues[0])(\n                _dataValues[1],\n                deadline,\n                _recipient\n            );\n            return;\n        }\n\n        UniswapExchange exchange = UniswapExchange(factory.getExchange(_assetIds[0]));\n\n        Utils.transferTokensIn(msg.sender, _assetIds[0], _dataValues[0], _dataValues[0]);\n        Utils.approveTokenTransfer(\n            _assetIds[0],\n            address(exchange),\n            _dataValues[0]\n        );\n\n        if (_assetIds[1] == ETHER_ADDR) {\n            exchange.tokenToEthTransferInput(\n                _dataValues[0],\n                _dataValues[1],\n                deadline,\n                _recipient\n            );\n            return;\n        }\n\n        // Use the minimum of 1 for minEth as the amount of intermediate eth\n        // used for the trade is not important. It is only important that the\n        // final received tokens is more than or equal to the wantAmount.\n        exchange.tokenToTokenTransferInput(\n            _dataValues[0],\n            _dataValues[1],\n            1,\n            deadline,\n            _recipient,\n            _assetIds[1]\n        );\n    }","after":"function trade(\n        address[] calldata _assetIds,\n        uint256[] calldata _dataValues,\n        address[] calldata /* _addresses */,\n        address payable _recipient\n    )\n        public\n        payable\n    {\n        // _dataValues[2] bits(24..56): delay\n        uint256 deadline = now.add((_dataValues[2] & ~(~uint256(0) << 56)) >> 24);\n\n        if (_assetIds[0] == ETHER_ADDR) {\n            UniswapExchange exchange = UniswapExchange(factory.getExchange(_assetIds[1]));\n            exchange.ethToTokenTransferInput.value(_dataValues[0])(\n                _dataValues[1],\n                deadline,\n                _recipient\n            );\n            return;\n        }\n\n        UniswapExchange exchange = UniswapExchange(factory.getExchange(_assetIds[0]));\n\n        Utils.transferTokensIn(msg.sender, _assetIds[0], _dataValues[0], _dataValues[0]);\n        Utils.approveTokenTransfer(\n            _assetIds[0],\n            address(exchange),\n            _dataValues[0]\n        );\n\n        if (_assetIds[1] == ETHER_ADDR) {\n            exchange.tokenToEthTransferInput(\n                _dataValues[0],\n                _dataValues[1],\n                deadline,\n                _recipient\n            );\n            return;\n        }\n\n        // Use the minimum of 1 for minEth as the amount of intermediate eth\n        // used for the trade is not important. It is only important that the\n        // final received tokens is more than or equal to the wantAmount.\n        exchange.tokenToTokenTransferInput(\n            _dataValues[0],\n            _dataValues[1],\n            1,\n            deadline,\n            _recipient,\n            _assetIds[1]\n        );\n    }","contract":"UniswapDapp","time":0}]}