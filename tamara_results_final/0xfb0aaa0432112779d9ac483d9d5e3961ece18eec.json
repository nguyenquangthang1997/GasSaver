{"time":302,"results":[{"type":"external-function ","before":"   function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return true;\n  ","after":"   function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes calldata _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return true;\n  ","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"   function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return true;\n  ","after":"   function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes calldata _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return true;\n  ","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"\n\n    function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return true;","after":"\n\n    function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return true;","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"\n\n    function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return true;","after":"\n\n    function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return true;","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"  }\n\n    function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return tr","after":"  }\n\n    function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return tr","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"  }\n\n    function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return tr","after":"  }\n\n    function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return tr","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"   function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return true;\n  ","after":"   function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes calldata _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return true;\n  ","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"   function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return true;\n  ","after":"   function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes calldata _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return true;\n  ","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"\n\n    function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return true;","after":"\n\n    function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return true;","contract":"Gluwacoin","time":1},{"type":"external-function ","before":"\n\n    function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return true;","after":"\n\n    function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return true;","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"  }\n\n    function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return tr","after":"  }\n\n    function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return tr","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"  }\n\n    function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return tr","after":"  }\n\n    function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return tr","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"   function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return true;\n  ","after":"   function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes calldata _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return true;\n  ","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"   function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return true;\n  ","after":"   function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes calldata _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return true;\n  ","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"\n\n    function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return true;","after":"\n\n    function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return true;","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"\n\n    function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return true;","after":"\n\n    function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return true;","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"  }\n\n    function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return tr","after":"  }\n\n    function transfer(address _from, address _to, uint256 _value, uint256 _fee, uint256 _nonce, bytes memory _sig) public returns (bool success)\n    {\n        require(_to != address(0), \"Can not transfer to zero address\");\n\n        uint256 _valuePlusFee = _value.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _valuePlusFee, \"Insufficient balance for transfer\");\n        \n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _value, _fee, _nonce));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _balances[_from] = _balances[_from].subtract(_valuePlusFee);\n        _balances[_to] = _balances[_to].add(_value);\n        _totalSupply = _totalSupply.subtract(_fee);\n\n        emit Transfer(_from, _to, _value);\n        emit Transfer(_from, address(0), _fee);\n        emit Burnt(_from, _fee);\n\n        return tr","contract":"Gluwacoin","time":0},{"type":"external-function ","before":"  }\n\n    function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return tr","after":"  }\n\n    function reserve(address _from, address _to, address _executor, uint256 _amount, uint256 _fee, uint256 _nonce, uint256 _expiryBlockNum, bytes memory _sig) public returns (bool success)\n    {\n        require(_expiryBlockNum > block.number, \"Invalid block expiry number\");\n        require(_amount > 0, \"Invalid reserve amount\");\n        require(_from != address(0), \"Can't reserve from zero address\");\n        require(_to != address(0), \"Can't reserve to zero address\");\n        require(_executor != address(0), \"Can't execute from zero address\");\n\n        uint256 _amountPlusFee = _amount.add(_fee);\n        require(_balances[_from].subtract(_totalReserved[_from]) >= _amountPlusFee, \"Insufficient funds to create reservation\");\n\n        bytes32 hash = keccak256(abi.encodePacked(address(this), _from, _to, _executor, _amount, _fee, _nonce, _expiryBlockNum));\n        validateSignature(hash, _from, _nonce, _sig);\n\n        _reserved[_from][_nonce] = Reservation(_amount, _fee, _to, _executor, _expiryBlockNum, ReservationStatus.Active);\n        _totalReserved[_from] = _totalReserved[_from].add(_amountPlusFee);\n\n        return tr","contract":"Gluwacoin","time":0}]}