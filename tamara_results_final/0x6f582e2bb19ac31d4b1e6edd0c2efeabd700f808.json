{"time":119,"results":[{"type":"external-function ","before":"   function redeemWinningTicket(\n        Ticket memory _ticket,\n        bytes memory _sig,\n        uint256 _recipientRand\n    )\n        public\n        whenSystemNotPaused\n        currentRoundInitialized\n    {\n        bytes32 ticketHash = getTicketHash(_ticket);\n\n        // Require a valid winning ticket for redemption\n        requireValidWinningTicket(_ticket, ticketHash, _sig, _recipientRand);\n\n        Sender storage sender = senders[_ticket.sender];\n\n        // Require sender to be locked\n        require(\n            isLocked(sender),\n            \"sender is unlocked\"\n        );\n        // Require either a non-zero deposit or non-zero reserve for the sender\n        require(\n            sender.deposit > 0 || remainingReserve(_ticket.sender) > 0,\n            \"sender deposit and reserve are zero\"\n        );\n\n        // Mark ticket as used to prevent replay attacks involving redeeming\n        // the same winning ticket multiple times\n        usedTickets[ticketHash] = true;\n\n        uint256 amountToTransfer = 0;\n\n        if (_ticket.faceValue > sender.deposit) {\n            // If ticket face value > sender's deposit then claim from\n            // the sender's reserve\n\n            amountToTransfer = sender.deposit.add(claimFromReserve(\n                _ticket.sender,\n                _ticket.recipient,\n                _ticket.faceValue.sub(sender.deposit)\n            ));\n\n            sender.deposit = 0;\n        } else {\n            // If ticket face value <= sender's deposit then only deduct\n            // from sender's deposit\n\n            amountToTransfer = _ticket.faceValue;\n            sender.deposit = sender.deposit.sub(_ticket.faceValue);\n        }\n\n        if (amountToTransfer > 0) {\n            winningTicketTransfer(_ticket.recipient, amountToTransfer, _ticket.auxData);\n\n            emit WinningTicketTransfer(_ticket.sender, _ticket.recipient, amountToTransfer);\n        }\n\n        emit WinningTicketRedeemed(\n            _ticket.sender,\n            _ticket.recipient,\n            _ticket.faceValue,\n            _ticket.winProb,\n            _ticket.senderNonce,\n            _recipientRand,\n            _ticket.auxData\n        );\n  ","after":"   function redeemWinningTicket(\n        Ticket calldata _ticket,\n        bytes calldata _sig,\n        uint256 _recipientRand\n    )\n        public\n        whenSystemNotPaused\n        currentRoundInitialized\n    {\n        bytes32 ticketHash = getTicketHash(_ticket);\n\n        // Require a valid winning ticket for redemption\n        requireValidWinningTicket(_ticket, ticketHash, _sig, _recipientRand);\n\n        Sender storage sender = senders[_ticket.sender];\n\n        // Require sender to be locked\n        require(\n            isLocked(sender),\n            \"sender is unlocked\"\n        );\n        // Require either a non-zero deposit or non-zero reserve for the sender\n        require(\n            sender.deposit > 0 || remainingReserve(_ticket.sender) > 0,\n            \"sender deposit and reserve are zero\"\n        );\n\n        // Mark ticket as used to prevent replay attacks involving redeeming\n        // the same winning ticket multiple times\n        usedTickets[ticketHash] = true;\n\n        uint256 amountToTransfer = 0;\n\n        if (_ticket.faceValue > sender.deposit) {\n            // If ticket face value > sender's deposit then claim from\n            // the sender's reserve\n\n            amountToTransfer = sender.deposit.add(claimFromReserve(\n                _ticket.sender,\n                _ticket.recipient,\n                _ticket.faceValue.sub(sender.deposit)\n            ));\n\n            sender.deposit = 0;\n        } else {\n            // If ticket face value <= sender's deposit then only deduct\n            // from sender's deposit\n\n            amountToTransfer = _ticket.faceValue;\n            sender.deposit = sender.deposit.sub(_ticket.faceValue);\n        }\n\n        if (amountToTransfer > 0) {\n            winningTicketTransfer(_ticket.recipient, amountToTransfer, _ticket.auxData);\n\n            emit WinningTicketTransfer(_ticket.sender, _ticket.recipient, amountToTransfer);\n        }\n\n        emit WinningTicketRedeemed(\n            _ticket.sender,\n            _ticket.recipient,\n            _ticket.faceValue,\n            _ticket.winProb,\n            _ticket.senderNonce,\n            _recipientRand,\n            _ticket.auxData\n        );\n  ","contract":"TicketBroker","time":0},{"type":"external-function ","before":"   function batchRedeemWinningTickets(\n        Ticket[] memory _tickets,\n        bytes[] memory _sigs,\n        uint256[] memory _recipientRands\n    )\n        public\n        whenSystemNotPaused\n        currentRoundInitialized\n    {\n        for (uint256 i = 0; i < _tickets.length; i++) {\n            redeemWinningTicketNoRevert(\n                _tickets[i],\n                _sigs[i],\n                _recipientRands[i]\n            );\n        }\n  ","after":"   function batchRedeemWinningTickets(\n        Ticket[] calldata _tickets,\n        bytes[] calldata _sigs,\n        uint256[] calldata _recipientRands\n    )\n        public\n        whenSystemNotPaused\n        currentRoundInitialized\n    {\n        for (uint256 i = 0; i < _tickets.length; i++) {\n            redeemWinningTicketNoRevert(\n                _tickets[i],\n                _sigs[i],\n                _recipientRands[i]\n            );\n        }\n  ","contract":"TicketBroker","time":0}]}