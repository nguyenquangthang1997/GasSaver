{"time":386,"results":[{"type":"loop-duplication","before":"\nstart line 446 column 1, end line 449 column 1\nfor (uint256 i = 0; i < nbOfStrings; i++)\n\t{\n\t\toffsetArr[i] = sliceUint(b, globalOffset + 32 + 32 * i);\n\t}\nstart line 451 column 1, end line 457 column 1\nfor (uint256 i = 0; i < nbOfStrings; i++)\n\t{\n\t\tstringLengths[i] = sliceUint(b, globalOffset + 32 + offsetArr[i]);\n\t\trequire(stringLengths[i] <= 32); // No string more than a bytes32\n\n\t\tstringArr[i] = bytes32ToString(bytesToBytes32(b, globalOffset + 64 + offsetArr[i]),stringLengths[i]);\n\t}","after":"// merge loop\n\nstart line 446 column 1, end line 449 column 1\nfor (uint256 i = 0; i < nbOfStrings; i++)\n\t{\n\t\toffsetArr[i] = sliceUint(b, globalOffset + 32 + 32 * i);\n\t}\nstart line 451 column 1, end line 457 column 1\nfor (uint256 i = 0; i < nbOfStrings; i++)\n\t{\n\t\tstringLengths[i] = sliceUint(b, globalOffset + 32 + offsetArr[i]);\n\t\trequire(stringLengths[i] <= 32); // No string more than a bytes32\n\n\t\tstringArr[i] = bytes32ToString(bytesToBytes32(b, globalOffset + 64 + offsetArr[i]),stringLengths[i]);\n\t}","contract":"Helpers","time":0},{"type":"external-function ","before":"function setNWhitelistedStatus(address[] memory _addresses, bool whitelisted_status) public onlyMultiSigOwners() {\n    for (uint256 i = 0; i < _addresses.length; i++)\n    {\n      whitelisted[_addresses[i]] = whitelisted_status;\n    }\n  }","after":"function setNWhitelistedStatus(address[] calldata _addresses, bool whitelisted_status) public onlyMultiSigOwners() {\n    for (uint256 i = 0; i < _addresses.length; i++)\n    {\n      whitelisted[_addresses[i]] = whitelisted_status;\n    }\n  }","contract":"ProxyForKYCWhitelistOnlySpecifiedPeopleAreWhitelisted","time":0},{"type":"external-function ","before":"function initialCall(bytes memory functionCall) public returns (bytes32) {\n      require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n      \n      Current_functionCallHash = keccak256(functionCall);\n      Current_functionCall = functionCall;\n      \n      delete Current_Approvals;\n\n      Current_Approvals.push(msg.sender);\n      \n      bytes4 funcSelector;\n\n      assembly {\n        funcSelector := mload(add(functionCall, 32))\n      }\n          \n      Current_functionSig = funcSelector;\n        \n      \n      if(nbApprovalsNeeded == 1)\n      {\n        address(this).call(functionCall);\n        \n        if (!isRegistered(funcSelector))\n        {\n          revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n        }\n        \n        emit MultiSigOwnerTransactionCleared(funcSelector);\n      }\n      \n      return Current_functionCallHash;\n    }","after":"function initialCall(bytes calldata functionCall) public returns (bytes32) {\n      require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n      \n      Current_functionCallHash = keccak256(functionCall);\n      Current_functionCall = functionCall;\n      \n      delete Current_Approvals;\n\n      Current_Approvals.push(msg.sender);\n      \n      bytes4 funcSelector;\n\n      assembly {\n        funcSelector := mload(add(functionCall, 32))\n      }\n          \n      Current_functionSig = funcSelector;\n        \n      \n      if(nbApprovalsNeeded == 1)\n      {\n        address(this).call(functionCall);\n        \n        if (!isRegistered(funcSelector))\n        {\n          revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n        }\n        \n        emit MultiSigOwnerTransactionCleared(funcSelector);\n      }\n      \n      return Current_functionCallHash;\n    }","contract":"ProxyForKYCWhitelistOnlySpecifiedPeopleAreWhitelisted","time":0},{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping (uint256 => address) private _tokenOwner;\nmapping (uint256 => address) private _tokenApprovals;\nmapping (address => Counters.Counter) private _ownedTokensCount;\nmapping (address => mapping (address => bool)) private _operatorApprovals;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;","after":"mapping (uint256 => address) private _tokenOwner;\nmapping (uint256 => address) private _tokenApprovals;\nmapping (address => Counters.Counter) private _ownedTokensCount;\nmapping (address => mapping (address => bool)) private _operatorApprovals;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n","contract":"ERC721","time":0},{"type":"external-function ","before":"function setbaseURI (string memory _new_baseURI) public onlyMultiSigOwners() {\n      baseURI = _new_baseURI;\n  }","after":"function setbaseURI (string calldata _new_baseURI) public onlyMultiSigOwners() {\n      baseURI = _new_baseURI;\n  }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public  {\n\t   require(_token == nexiumAddress);\n\t   require(_extraData.length >= 4); // We need at least the functionSelector;\n\t   \n\t    bytes4 funcSelector = 0x0;\n\t    \n        if (_extraData.length == 0) {\n            funcSelector = 0x0;\n        }\n\n        assembly {\n            funcSelector := mload(add(_extraData, 32))\n        }\n        \n        if (funcSelector == bytes4(keccak256(\"createNewOptionID(uint256,address)\")))\n        {\n\t\t\trevert(\"Please put empty keys and values args\");\n\t\t\t/*uint256 nbOfAsset = Helpers.sliceUint(_extraData, 4);\n\t\t\taddress _minter = address(Helpers.sliceUint(_extraData, 36));\n\n\t\t\tcreateNewOptionID(nbOfAsset, _minter);\n\t\t\t\n\t\t\tNxcInterface nexiumContract = NxcInterface(address(nexiumAddress));\n\n\t\t\trequire(_value >= CallProxyForNxCBurn(nbOfAsset), \"Not enough NXC!\");*/\n        }\n\t\telse if (funcSelector == bytes4(keccak256(\"createNewOptionID(uint256,address,string[],string[])\")))\n\t\t{\n\n\t\t\t// Check extraData length\n\t\t\t\n\t\t\tuint256 nbOfAsset = Helpers.sliceUint(_extraData, 4);\n\t\t\taddress _minter = address(Helpers.sliceUint(_extraData, 36));\n\t\t\t\n\t\t\tuint256 keysOffset = Helpers.sliceUint(_extraData, 68) + 4; // we have to account for the bytes4 selector\n\t\t\tuint256 valuesOffset = Helpers.sliceUint(_extraData, 100) + 4;\n\t\t\t\n\t\t\tuint256 nbOfKeys = Helpers.sliceUint(_extraData, keysOffset);\n\t\t\tuint256 nbOfValues = Helpers.sliceUint(_extraData, valuesOffset);\n\t\t\t\n\t\t\trequire(nbOfValues == nbOfKeys);\n\t\t\t\n\t\t\tstring[] memory keys = Helpers.parseBytesToStringArr(_extraData, keysOffset);\n\t\t\tstring[] memory values = Helpers.parseBytesToStringArr(_extraData, valuesOffset);\n\t\t\t\n\t\t\tcreateNewOptionID(nbOfAsset, _minter, keys, values);\n\t\t\t\n\t\t\trequire(_value >= CallProxyForNxCBurn(nbOfAsset, keys, values), \"Not enough NXC!\");\n        }\n        else\n        {\n            revert(\"Unknown function called through receiveApproval\");\n        }\n\t\t\n\t\tNxcInterface nexiumContract = NxcInterface(address(nexiumAddress));\n\t\tif(!nexiumContract.transferFrom(_from, address(this), _value))\n\t\t{\n\t\t\trevert(\"notEnoughNxCSent\");\n\t\t}\n\t\t\t\n\t    return;\n  }","after":"function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) public  {\n\t   require(_token == nexiumAddress);\n\t   require(_extraData.length >= 4); // We need at least the functionSelector;\n\t   \n\t    bytes4 funcSelector = 0x0;\n\t    \n        if (_extraData.length == 0) {\n            funcSelector = 0x0;\n        }\n\n        assembly {\n            funcSelector := mload(add(_extraData, 32))\n        }\n        \n        if (funcSelector == bytes4(keccak256(\"createNewOptionID(uint256,address)\")))\n        {\n\t\t\trevert(\"Please put empty keys and values args\");\n\t\t\t/*uint256 nbOfAsset = Helpers.sliceUint(_extraData, 4);\n\t\t\taddress _minter = address(Helpers.sliceUint(_extraData, 36));\n\n\t\t\tcreateNewOptionID(nbOfAsset, _minter);\n\t\t\t\n\t\t\tNxcInterface nexiumContract = NxcInterface(address(nexiumAddress));\n\n\t\t\trequire(_value >= CallProxyForNxCBurn(nbOfAsset), \"Not enough NXC!\");*/\n        }\n\t\telse if (funcSelector == bytes4(keccak256(\"createNewOptionID(uint256,address,string[],string[])\")))\n\t\t{\n\n\t\t\t// Check extraData length\n\t\t\t\n\t\t\tuint256 nbOfAsset = Helpers.sliceUint(_extraData, 4);\n\t\t\taddress _minter = address(Helpers.sliceUint(_extraData, 36));\n\t\t\t\n\t\t\tuint256 keysOffset = Helpers.sliceUint(_extraData, 68) + 4; // we have to account for the bytes4 selector\n\t\t\tuint256 valuesOffset = Helpers.sliceUint(_extraData, 100) + 4;\n\t\t\t\n\t\t\tuint256 nbOfKeys = Helpers.sliceUint(_extraData, keysOffset);\n\t\t\tuint256 nbOfValues = Helpers.sliceUint(_extraData, valuesOffset);\n\t\t\t\n\t\t\trequire(nbOfValues == nbOfKeys);\n\t\t\t\n\t\t\tstring[] memory keys = Helpers.parseBytesToStringArr(_extraData, keysOffset);\n\t\t\tstring[] memory values = Helpers.parseBytesToStringArr(_extraData, valuesOffset);\n\t\t\t\n\t\t\tcreateNewOptionID(nbOfAsset, _minter, keys, values);\n\t\t\t\n\t\t\trequire(_value >= CallProxyForNxCBurn(nbOfAsset, keys, values), \"Not enough NXC!\");\n        }\n        else\n        {\n            revert(\"Unknown function called through receiveApproval\");\n        }\n\t\t\n\t\tNxcInterface nexiumContract = NxcInterface(address(nexiumAddress));\n\t\tif(!nexiumContract.transferFrom(_from, address(this), _value))\n\t\t{\n\t\t\trevert(\"notEnoughNxCSent\");\n\t\t}\n\t\t\t\n\t    return;\n  }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function setOptionIdPropriety(uint256 _optionID, string memory _key, string memory _value) public\n  {\n    require(msg.sender == minterForOptionID[_optionID]);\n    require(bytes(_key).length > 0);\n    \n    KeyValue memory keyValueForThisKey = KeyValueMappingOptionID[_optionID][_key];\n\n    uint256 index;\n    KeyValue memory newKeyValue;\n    \n    // Check if the key already set or not\n    if (bytes(keyValueForThisKey._key).length == 0)\n    {\n      index = KeyValueArrayOptionID[_optionID].length;\n      newKeyValue = KeyValue(index, _key, _value);\n      KeyValueArrayOptionID[_optionID].push(newKeyValue);\n    }\t\n    else\n    {\n      index = keyValueForThisKey._index;\n      newKeyValue = KeyValue(index, _key, _value);\n      KeyValueArrayOptionID[_optionID][index] = newKeyValue;\n    }\n    \n    KeyValueMappingOptionID[_optionID][_key] = newKeyValue;\n  }","after":"function setOptionIdPropriety(uint256 _optionID, string calldata _key, string calldata _value) public\n  {\n    require(msg.sender == minterForOptionID[_optionID]);\n    require(bytes(_key).length > 0);\n    \n    KeyValue memory keyValueForThisKey = KeyValueMappingOptionID[_optionID][_key];\n\n    uint256 index;\n    KeyValue memory newKeyValue;\n    \n    // Check if the key already set or not\n    if (bytes(keyValueForThisKey._key).length == 0)\n    {\n      index = KeyValueArrayOptionID[_optionID].length;\n      newKeyValue = KeyValue(index, _key, _value);\n      KeyValueArrayOptionID[_optionID].push(newKeyValue);\n    }\t\n    else\n    {\n      index = keyValueForThisKey._index;\n      newKeyValue = KeyValue(index, _key, _value);\n      KeyValueArrayOptionID[_optionID][index] = newKeyValue;\n    }\n    \n    KeyValueMappingOptionID[_optionID][_key] = newKeyValue;\n  }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function deleteOptionIdPropriety(uint256 _optionID, string memory _key) public\n  {\n    require(msg.sender == minterForOptionID[_optionID]);\n\n    KeyValue memory keyValueForThisKey = KeyValueMappingOptionID[_optionID][_key];\n\n    uint256 index = keyValueForThisKey._index;\n    uint256 length = KeyValueArrayOptionID[_optionID].length;\n    \n    KeyValueArrayOptionID[_optionID][index] = KeyValueArrayOptionID[_optionID][length-1];\n    delete KeyValueArrayOptionID[_optionID][length-1];\n    delete KeyValueMappingOptionID[_optionID][_key];\n  }","after":"function deleteOptionIdPropriety(uint256 _optionID, string calldata _key) public\n  {\n    require(msg.sender == minterForOptionID[_optionID]);\n\n    KeyValue memory keyValueForThisKey = KeyValueMappingOptionID[_optionID][_key];\n\n    uint256 index = keyValueForThisKey._index;\n    uint256 length = KeyValueArrayOptionID[_optionID].length;\n    \n    KeyValueArrayOptionID[_optionID][index] = KeyValueArrayOptionID[_optionID][length-1];\n    delete KeyValueArrayOptionID[_optionID][length-1];\n    delete KeyValueMappingOptionID[_optionID][_key];\n  }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function setTokenIdPropriety(uint256 _TokenID, string memory _key, string memory _value) public\n  {\t\n    NFT_Token itemContract = NFT_Token(nftAddress);\n    \n    uint256 _optionId = itemContract.itemTypes(_TokenID);\n    require(msg.sender == minterForOptionID[_optionId]);\n    \n    require(bytes(_key).length > 0);\n      \n    KeyValue memory keyValueForThisKey = KeyValueMappingTokenID[_TokenID][_key];\n\n    uint256 index;\n    KeyValue memory newKeyValue;\n    \n    // Check if the key already set or not\n    \n    if (bytes(keyValueForThisKey._key).length == 0)\n    {\n      index = KeyValueArrayTokenID[_TokenID].length;\n      newKeyValue = KeyValue(index, _key, _value);\n      KeyValueArrayTokenID[_TokenID].push(newKeyValue);\n    }\t\n    else\n    {\n      index = keyValueForThisKey._index;\n      newKeyValue = KeyValue(index, _key, _value);\n      KeyValueArrayTokenID[_TokenID][index] = newKeyValue;\n    }\n    \n    KeyValueMappingTokenID[_TokenID][_key] = newKeyValue;\n  }","after":"function setTokenIdPropriety(uint256 _TokenID, string calldata _key, string calldata _value) public\n  {\t\n    NFT_Token itemContract = NFT_Token(nftAddress);\n    \n    uint256 _optionId = itemContract.itemTypes(_TokenID);\n    require(msg.sender == minterForOptionID[_optionId]);\n    \n    require(bytes(_key).length > 0);\n      \n    KeyValue memory keyValueForThisKey = KeyValueMappingTokenID[_TokenID][_key];\n\n    uint256 index;\n    KeyValue memory newKeyValue;\n    \n    // Check if the key already set or not\n    \n    if (bytes(keyValueForThisKey._key).length == 0)\n    {\n      index = KeyValueArrayTokenID[_TokenID].length;\n      newKeyValue = KeyValue(index, _key, _value);\n      KeyValueArrayTokenID[_TokenID].push(newKeyValue);\n    }\t\n    else\n    {\n      index = keyValueForThisKey._index;\n      newKeyValue = KeyValue(index, _key, _value);\n      KeyValueArrayTokenID[_TokenID][index] = newKeyValue;\n    }\n    \n    KeyValueMappingTokenID[_TokenID][_key] = newKeyValue;\n  }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function deleteTokenIdPropriety(uint256 _TokenID, string memory _key) public\n  {\n    NFT_Token itemContract = NFT_Token(nftAddress);\n    \n    uint256 _optionId = itemContract.itemTypes(_TokenID);\n    require(msg.sender == minterForOptionID[_optionId]);\n\n    KeyValue memory keyValueForThisKey = KeyValueMappingTokenID[_TokenID][_key];\n\n    uint256 index = keyValueForThisKey._index;\n    uint256 length = KeyValueArrayTokenID[_TokenID].length;\n    \n    KeyValueArrayTokenID[_TokenID][index] = KeyValueArrayTokenID[_TokenID][length-1];\n    delete KeyValueArrayTokenID[_TokenID][length-1];\n    delete KeyValueMappingTokenID[_TokenID][_key];\n  }","after":"function deleteTokenIdPropriety(uint256 _TokenID, string calldata _key) public\n  {\n    NFT_Token itemContract = NFT_Token(nftAddress);\n    \n    uint256 _optionId = itemContract.itemTypes(_TokenID);\n    require(msg.sender == minterForOptionID[_optionId]);\n\n    KeyValue memory keyValueForThisKey = KeyValueMappingTokenID[_TokenID][_key];\n\n    uint256 index = keyValueForThisKey._index;\n    uint256 length = KeyValueArrayTokenID[_TokenID].length;\n    \n    KeyValueArrayTokenID[_TokenID][index] = KeyValueArrayTokenID[_TokenID][length-1];\n    delete KeyValueArrayTokenID[_TokenID][length-1];\n    delete KeyValueMappingTokenID[_TokenID][_key];\n  }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function setTokenURI(uint256 tokenID, string memory _tokenURI) public\n    {\n      NFT_Token itemContract = NFT_Token(nftAddress);\n      \n      uint256 optionID = itemContract.itemTypes(tokenID);\n      \n    require(msg.sender == minterForOptionID[optionID]);\n    \n    itemContract.setTokenURI(tokenID, _tokenURI);\n    }","after":"function setTokenURI(uint256 tokenID, string calldata _tokenURI) public\n    {\n      NFT_Token itemContract = NFT_Token(nftAddress);\n      \n      uint256 optionID = itemContract.itemTypes(tokenID);\n      \n    require(msg.sender == minterForOptionID[optionID]);\n    \n    itemContract.setTokenURI(tokenID, _tokenURI);\n    }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function DefineBundle(uint256 optionID, uint256[] memory optionIDList) public \n\t{\n\t\trequire(minterForOptionID[optionID] == msg.sender);\n\t\tfor (uint256 i = 0; i < optionIDList.length; i++)\n\t\t{\n\t\t\trequire(minterForOptionID[optionIDList[i]] == msg.sender);\n\t\t}\n\t\tbundlesDefinition[optionID] = optionIDList;\n\t\tisBundle[optionID] = true;\n\t}","after":"function DefineBundle(uint256 optionID, uint256[] calldata optionIDList) public \n\t{\n\t\trequire(minterForOptionID[optionID] == msg.sender);\n\t\tfor (uint256 i = 0; i < optionIDList.length; i++)\n\t\t{\n\t\t\trequire(minterForOptionID[optionIDList[i]] == msg.sender);\n\t\t}\n\t\tbundlesDefinition[optionID] = optionIDList;\n\t\tisBundle[optionID] = true;\n\t}","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function initialCall(bytes memory functionCall) public returns (bytes32) {\n      require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n      \n      Current_functionCallHash = keccak256(functionCall);\n      Current_functionCall = functionCall;\n      \n      delete Current_Approvals;\n\n      Current_Approvals.push(msg.sender);\n      \n      bytes4 funcSelector;\n\n      assembly {\n        funcSelector := mload(add(functionCall, 32))\n      }\n          \n      Current_functionSig = funcSelector;\n        \n      \n      if(nbApprovalsNeeded == 1)\n      {\n        address(this).call(functionCall);\n        \n        if (!isRegistered(funcSelector))\n        {\n          revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n        }\n        \n        emit MultiSigOwnerTransactionCleared(funcSelector);\n      }\n      \n      return Current_functionCallHash;\n    }","after":"function initialCall(bytes calldata functionCall) public returns (bytes32) {\n      require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n      \n      Current_functionCallHash = keccak256(functionCall);\n      Current_functionCall = functionCall;\n      \n      delete Current_Approvals;\n\n      Current_Approvals.push(msg.sender);\n      \n      bytes4 funcSelector;\n\n      assembly {\n        funcSelector := mload(add(functionCall, 32))\n      }\n          \n      Current_functionSig = funcSelector;\n        \n      \n      if(nbApprovalsNeeded == 1)\n      {\n        address(this).call(functionCall);\n        \n        if (!isRegistered(funcSelector))\n        {\n          revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n        }\n        \n        emit MultiSigOwnerTransactionCleared(funcSelector);\n      }\n      \n      return Current_functionCallHash;\n    }","contract":"NFT_Factory","time":0},{"type":"state-data-arrangement ","before":"\naddress private NexiumAddress;\naddress private FactoryAddress;\nmapping(address => uint256) groupOwners;\nmapping(uint256 => uint256) public NexiumPerTokenId;\nmapping(uint256 => uint256) public EtherPerTokenId;\nstring private _name;\nstring private _symbol;\nuint256 private _total_supply;\nstring private _uri_prefix;\nstring private _route;\nuint256 private _last_id;\nmapping(uint256 => string) tokenURIs;\nmapping(uint256 => bool) private _locked;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\nmapping(uint256 => uint256[]) groupMapping;\naddress payable ProxyContractForMetaTxsAddress;","after":"mapping(address => uint256) groupOwners;\nmapping(uint256 => uint256) public NexiumPerTokenId;\nmapping(uint256 => uint256) public EtherPerTokenId;\nstring private _name;\nstring private _symbol;\nuint256 private _total_supply;\nstring private _uri_prefix;\nstring private _route;\nuint256 private _last_id;\nmapping(uint256 => string) tokenURIs;\nmapping(uint256 => bool) private _locked;\nmapping(uint256 => uint256[]) groupMapping;\naddress private NexiumAddress;\naddress private FactoryAddress;\naddress payable ProxyContractForMetaTxsAddress;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n","contract":"NFT_Token","time":1},{"type":"external-function ","before":"function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public {\n\n\t    require(_token == NexiumAddress);\n\t    require(_extraData.length == 32);\n\n\t    uint256 tokenId = Helpers.bytesToUint(_extraData);\n\n\t    NxcInterface nexiumContract = NxcInterface(NexiumAddress);\n\n\t    if(nexiumContract.transferFrom(_from, address(this), _value) == false)\n\t    {\n\t        revert();\n\t    }\n\t    \n\t    NexiumPerTokenId[tokenId] = NexiumPerTokenId[tokenId].add(_value);\n\n\t    return;\n\t}","after":"function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) public {\n\n\t    require(_token == NexiumAddress);\n\t    require(_extraData.length == 32);\n\n\t    uint256 tokenId = Helpers.bytesToUint(_extraData);\n\n\t    NxcInterface nexiumContract = NxcInterface(NexiumAddress);\n\n\t    if(nexiumContract.transferFrom(_from, address(this), _value) == false)\n\t    {\n\t        revert();\n\t    }\n\t    \n\t    NexiumPerTokenId[tokenId] = NexiumPerTokenId[tokenId].add(_value);\n\n\t    return;\n\t}","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function groupAssets(uint256[] memory tokenIds) public returns (uint256) {\n\n\t    uint256 tokenId = totalSupply().add(1);\n        _mint(msg.sender, tokenId);\n\n\t    for (uint256 i = 0; i < tokenIds.length; i++) {\n\t          transferFrom(msg.sender, address(this), tokenIds[i]);\n\t    }\n\n\t    groupMapping[tokenId] = tokenIds;\n\n\t\temit Grouping(msg.sender, tokenId);\n\n\t    return tokenId;\n\t}","after":"function groupAssets(uint256[] calldata tokenIds) public returns (uint256) {\n\n\t    uint256 tokenId = totalSupply().add(1);\n        _mint(msg.sender, tokenId);\n\n\t    for (uint256 i = 0; i < tokenIds.length; i++) {\n\t          transferFrom(msg.sender, address(this), tokenIds[i]);\n\t    }\n\n\t    groupMapping[tokenId] = tokenIds;\n\n\t\temit Grouping(msg.sender, tokenId);\n\n\t    return tokenId;\n\t}","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function setURI_Prefix(string memory _new_uri_prefix) public onlyMultiSigOwners() returns (bool) {\n        _uri_prefix = _new_uri_prefix;\n        return true;\n    }","after":"function setURI_Prefix(string calldata _new_uri_prefix) public onlyMultiSigOwners() returns (bool) {\n        _uri_prefix = _new_uri_prefix;\n        return true;\n    }","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function setRoute(string memory _new_route) public onlyMultiSigOwners() returns (bool) {\n        _route = _new_route;\n        return true;\n    }","after":"function setRoute(string calldata _new_route) public onlyMultiSigOwners() returns (bool) {\n        _route = _new_route;\n        return true;\n    }","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function setTokenURI(uint256 tokenID, string memory _tokenURI) public returns (bool) {\n\t\trequire(msg.sender == FactoryAddress);\n\t\t\n\t\ttokenURIs[tokenID] = _tokenURI;\n\t\treturn true;\n\t}","after":"function setTokenURI(uint256 tokenID, string calldata _tokenURI) public returns (bool) {\n\t\trequire(msg.sender == FactoryAddress);\n\t\t\n\t\ttokenURIs[tokenID] = _tokenURI;\n\t\treturn true;\n\t}","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function forward(bytes memory sig, address signer, address destination, uint value, bytes memory data, address rewardToken, uint rewardAmount) public\n\t  {\n\t  \tProxyContractForMetaTxs _proxy_contract_MetaTx = ProxyContractForMetaTxs(ProxyContractForMetaTxsAddress);\n\t\treturn _proxy_contract_MetaTx.forward(sig, signer, destination, value, data, rewardToken, rewardAmount);\n\t  }","after":"function forward(bytes calldata sig, address signer, address destination, uint value, bytes calldata data, address rewardToken, uint rewardAmount) public\n\t  {\n\t  \tProxyContractForMetaTxs _proxy_contract_MetaTx = ProxyContractForMetaTxs(ProxyContractForMetaTxsAddress);\n\t\treturn _proxy_contract_MetaTx.forward(sig, signer, destination, value, data, rewardToken, rewardAmount);\n\t  }","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function initialCall(bytes memory functionCall) public returns (bytes32) {\n      require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n      \n      Current_functionCallHash = keccak256(functionCall);\n      Current_functionCall = functionCall;\n      \n      delete Current_Approvals;\n\n      Current_Approvals.push(msg.sender);\n      \n      bytes4 funcSelector;\n\n      assembly {\n        funcSelector := mload(add(functionCall, 32))\n      }\n          \n      Current_functionSig = funcSelector;\n        \n      \n      if(nbApprovalsNeeded == 1)\n      {\n        address(this).call(functionCall);\n        \n        if (!isRegistered(funcSelector))\n        {\n          revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n        }\n        \n        emit MultiSigOwnerTransactionCleared(funcSelector);\n      }\n      \n      return Current_functionCallHash;\n    }","after":"function initialCall(bytes calldata functionCall) public returns (bytes32) {\n      require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n      \n      Current_functionCallHash = keccak256(functionCall);\n      Current_functionCall = functionCall;\n      \n      delete Current_Approvals;\n\n      Current_Approvals.push(msg.sender);\n      \n      bytes4 funcSelector;\n\n      assembly {\n        funcSelector := mload(add(functionCall, 32))\n      }\n          \n      Current_functionSig = funcSelector;\n        \n      \n      if(nbApprovalsNeeded == 1)\n      {\n        address(this).call(functionCall);\n        \n        if (!isRegistered(funcSelector))\n        {\n          revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n        }\n        \n        emit MultiSigOwnerTransactionCleared(funcSelector);\n      }\n      \n      return Current_functionCallHash;\n    }","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function newAsset(uint256 optionID, string memory name, address minter) public {\n\t\t_tokenTypes[optionID] = TokenType(optionID, name, minter);\n\t\temit RegisterNewAsset(optionID, name);\n    }","after":"function newAsset(uint256 optionID, string calldata name, address minter) public {\n\t\t_tokenTypes[optionID] = TokenType(optionID, name, minter);\n\t\temit RegisterNewAsset(optionID, name);\n    }","contract":"NFT_B2E_Listing","time":0},{"type":"external-function ","before":"function replaceAsset(uint256 optionID, string memory name, address minter) public {\n\t\tdelete _tokenTypes[optionID];\n\t\t_tokenTypes[optionID] = TokenType(optionID, name, minter);\n\t\temit UpdateAsset(optionID, name);\n    }","after":"function replaceAsset(uint256 optionID, string calldata name, address minter) public {\n\t\tdelete _tokenTypes[optionID];\n\t\t_tokenTypes[optionID] = TokenType(optionID, name, minter);\n\t\temit UpdateAsset(optionID, name);\n    }","contract":"NFT_B2E_Listing","time":0},{"type":"external-function ","before":"function initialCall(bytes memory functionCall) public returns (bytes32) {\n      require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n      \n      Current_functionCallHash = keccak256(functionCall);\n      Current_functionCall = functionCall;\n      \n      delete Current_Approvals;\n\n      Current_Approvals.push(msg.sender);\n      \n      bytes4 funcSelector;\n\n      assembly {\n        funcSelector := mload(add(functionCall, 32))\n      }\n          \n      Current_functionSig = funcSelector;\n        \n      \n      if(nbApprovalsNeeded == 1)\n      {\n        address(this).call(functionCall);\n        \n        if (!isRegistered(funcSelector))\n        {\n          revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n        }\n        \n        emit MultiSigOwnerTransactionCleared(funcSelector);\n      }\n      \n      return Current_functionCallHash;\n    }","after":"function initialCall(bytes calldata functionCall) public returns (bytes32) {\n      require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n      \n      Current_functionCallHash = keccak256(functionCall);\n      Current_functionCall = functionCall;\n      \n      delete Current_Approvals;\n\n      Current_Approvals.push(msg.sender);\n      \n      bytes4 funcSelector;\n\n      assembly {\n        funcSelector := mload(add(functionCall, 32))\n      }\n          \n      Current_functionSig = funcSelector;\n        \n      \n      if(nbApprovalsNeeded == 1)\n      {\n        address(this).call(functionCall);\n        \n        if (!isRegistered(funcSelector))\n        {\n          revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n        }\n        \n        emit MultiSigOwnerTransactionCleared(funcSelector);\n      }\n      \n      return Current_functionCallHash;\n    }","contract":"NFT_B2E_Listing","time":0},{"type":"constant-restrict-modification  ","before":"uint256 minimum = 100;","after":"uint256 constant minimum = 100;","contract":"ProxyContractForBurn","time":0},{"type":"constant-restrict-modification  ","before":"uint256 divisor = 4;","after":"uint256 constant divisor = 4;","contract":"ProxyContractForBurn","time":0}]}