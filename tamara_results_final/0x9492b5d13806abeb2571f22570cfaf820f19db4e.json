{"time":260,"results":[{"type":"state-data-arrangement ","before":"\nstring public symbol;\nstring public  name;\nuint8 public decimals;\nuint public _totalSupply;\nuint public latestDifficultyPeriodStarted;\nuint public epochCount;\nuint public _BLOCKS_PER_READJUSTMENT = 1024;\nuint public  _MINIMUM_TARGET = 2**16;\nuint public  _MAXIMUM_TARGET = 2**234;\nuint public miningTarget;\nbytes32 public challengeNumber;\nuint public rewardEra;\nuint public maxSupplyForEra;\naddress public lastRewardTo;\nuint public lastRewardAmount;\nuint public lastRewardEthBlockNumber;\nbool locked = false;\nmapping(bytes32 => bytes32) solutionForChallenge;\nuint public tokensMinted;\nmapping(address => uint) balances;\nmapping(address => mapping(address => uint)) allowed;","after":"string public symbol;\nstring public  name;\nuint public _totalSupply;\nuint public latestDifficultyPeriodStarted;\nuint public epochCount;\nuint public _BLOCKS_PER_READJUSTMENT = 1024;\nuint public  _MINIMUM_TARGET = 2**16;\nuint public  _MAXIMUM_TARGET = 2**234;\nuint public miningTarget;\nbytes32 public challengeNumber;\nuint public rewardEra;\nuint public maxSupplyForEra;\nuint public lastRewardAmount;\nuint public lastRewardEthBlockNumber;\nmapping(bytes32 => bytes32) solutionForChallenge;\nuint public tokensMinted;\nmapping(address => uint) balances;\nmapping(address => mapping(address => uint)) allowed;\naddress public lastRewardTo;\nuint8 public decimals;\nbool locked = false;\n","contract":"CARBON","time":0},{"type":"external-function ","before":"function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n        return true;\n    }","after":"function approveAndCall(address spender, uint tokens, bytes calldata data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n        return true;\n    }","contract":"CARBON","time":0},{"type":"constant-restrict-modification  ","before":"uint public _BLOCKS_PER_READJUSTMENT = 1024;","after":"uint public constant _BLOCKS_PER_READJUSTMENT = 1024;","contract":"CARBON","time":1},{"type":"constant-restrict-modification  ","before":"uint public  _MINIMUM_TARGET = 2**16;","after":"uint public  constant _MINIMUM_TARGET = 2**16;","contract":"CARBON","time":1},{"type":"constant-restrict-modification  ","before":"uint public  _MAXIMUM_TARGET = 2**234;","after":"uint public  constant _MAXIMUM_TARGET = 2**234;","contract":"CARBON","time":1},{"type":"state-data-arrangement ","before":"\nstring public symbol;\nstring public  name;\nuint8 public decimals;\nuint public _totalSupply;\nuint public latestDifficultyPeriodStarted;\nuint public epochCount;\nuint public _BLOCKS_PER_READJUSTMENT = 1024;\nuint public  _MINIMUM_TARGET = 2**16;\nuint public  _MAXIMUM_TARGET = 2**234;\nuint public miningTarget;\nbytes32 public challengeNumber;\nuint public rewardEra;\nuint public maxSupplyForEra;\naddress public lastRewardTo;\nuint public lastRewardAmount;\nuint public lastRewardEthBlockNumber;\nbool locked = false;\nmapping(bytes32 => bytes32) solutionForChallenge;\nuint public tokensMinted;\nmapping(address => uint) balances;\nmapping(address => mapping(address => uint)) allowed;","after":"string public symbol;\nstring public  name;\nuint public _totalSupply;\nuint public latestDifficultyPeriodStarted;\nuint public epochCount;\nuint public _BLOCKS_PER_READJUSTMENT = 1024;\nuint public  _MINIMUM_TARGET = 2**16;\nuint public  _MAXIMUM_TARGET = 2**234;\nuint public miningTarget;\nbytes32 public challengeNumber;\nuint public rewardEra;\nuint public maxSupplyForEra;\nuint public lastRewardAmount;\nuint public lastRewardEthBlockNumber;\nmapping(bytes32 => bytes32) solutionForChallenge;\nuint public tokensMinted;\nmapping(address => uint) balances;\nmapping(address => mapping(address => uint)) allowed;\naddress public lastRewardTo;\nuint8 public decimals;\nbool locked = false;\n","contract":"GOLD","time":0},{"type":"external-function ","before":"function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n        return true;\n    }","after":"function approveAndCall(address spender, uint tokens, bytes calldata data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n        return true;\n    }","contract":"GOLD","time":0},{"type":"constant-restrict-modification  ","before":"uint public _BLOCKS_PER_READJUSTMENT = 1024;","after":"uint public constant _BLOCKS_PER_READJUSTMENT = 1024;","contract":"GOLD","time":0},{"type":"constant-restrict-modification  ","before":"uint public  _MINIMUM_TARGET = 2**16;","after":"uint public  constant _MINIMUM_TARGET = 2**16;","contract":"GOLD","time":0},{"type":"constant-restrict-modification  ","before":"uint public  _MAXIMUM_TARGET = 2**234;","after":"uint public  constant _MAXIMUM_TARGET = 2**234;","contract":"GOLD","time":0},{"type":"state-data-arrangement ","before":"\nstring public symbol;\nstring public  name;\nuint8 public decimals;\nuint public _totalSupply;\nuint public latestDifficultyPeriodStarted;\nuint public epochCount;\nuint public _BLOCKS_PER_READJUSTMENT = 1024;\nuint public  _MINIMUM_TARGET = 2**16;\nuint public  _MAXIMUM_TARGET = 2**234;\nuint public miningTarget;\nbytes32 public challengeNumber;\nuint public rewardEra;\nuint public maxSupplyForEra;\naddress public lastRewardTo;\nuint public lastRewardAmount;\nuint public lastRewardEthBlockNumber;\nbool locked = false;\nmapping(bytes32 => bytes32) solutionForChallenge;\nuint public tokensMinted;\nmapping(address => uint) balances;\nmapping(address => mapping(address => uint)) allowed;","after":"string public symbol;\nstring public  name;\nuint public _totalSupply;\nuint public latestDifficultyPeriodStarted;\nuint public epochCount;\nuint public _BLOCKS_PER_READJUSTMENT = 1024;\nuint public  _MINIMUM_TARGET = 2**16;\nuint public  _MAXIMUM_TARGET = 2**234;\nuint public miningTarget;\nbytes32 public challengeNumber;\nuint public rewardEra;\nuint public maxSupplyForEra;\nuint public lastRewardAmount;\nuint public lastRewardEthBlockNumber;\nmapping(bytes32 => bytes32) solutionForChallenge;\nuint public tokensMinted;\nmapping(address => uint) balances;\nmapping(address => mapping(address => uint)) allowed;\naddress public lastRewardTo;\nuint8 public decimals;\nbool locked = false;\n","contract":"SILVER","time":0},{"type":"external-function ","before":"function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n        return true;\n    }","after":"function approveAndCall(address spender, uint tokens, bytes calldata data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n        return true;\n    }","contract":"SILVER","time":0},{"type":"constant-restrict-modification  ","before":"uint public _BLOCKS_PER_READJUSTMENT = 1024;","after":"uint public constant _BLOCKS_PER_READJUSTMENT = 1024;","contract":"SILVER","time":0},{"type":"constant-restrict-modification  ","before":"uint public  _MINIMUM_TARGET = 2**16;","after":"uint public  constant _MINIMUM_TARGET = 2**16;","contract":"SILVER","time":0},{"type":"constant-restrict-modification  ","before":"uint public  _MAXIMUM_TARGET = 2**234;","after":"uint public  constant _MAXIMUM_TARGET = 2**234;","contract":"SILVER","time":0},{"type":"state-data-arrangement ","before":"\nstring public symbol;\nstring public  name;\nuint8 public decimals;\nuint public _totalSupply;\nuint public latestDifficultyPeriodStarted;\nuint public epochCount;\nuint public _BLOCKS_PER_READJUSTMENT = 1024;\nuint public  _MINIMUM_TARGET = 2**16;\nuint public  _MAXIMUM_TARGET = 2**234;\nuint public miningTarget;\nbytes32 public challengeNumber;\nuint public rewardEra;\nuint public maxSupplyForEra;\naddress public lastRewardTo;\nuint public lastRewardAmount;\nuint public lastRewardEthBlockNumber;\nbool locked = false;\nmapping(bytes32 => bytes32) solutionForChallenge;\nuint public tokensMinted;\nmapping(address => uint) balances;\nmapping(address => mapping(address => uint)) allowed;","after":"string public symbol;\nstring public  name;\nuint public _totalSupply;\nuint public latestDifficultyPeriodStarted;\nuint public epochCount;\nuint public _BLOCKS_PER_READJUSTMENT = 1024;\nuint public  _MINIMUM_TARGET = 2**16;\nuint public  _MAXIMUM_TARGET = 2**234;\nuint public miningTarget;\nbytes32 public challengeNumber;\nuint public rewardEra;\nuint public maxSupplyForEra;\nuint public lastRewardAmount;\nuint public lastRewardEthBlockNumber;\nmapping(bytes32 => bytes32) solutionForChallenge;\nuint public tokensMinted;\nmapping(address => uint) balances;\nmapping(address => mapping(address => uint)) allowed;\naddress public lastRewardTo;\nuint8 public decimals;\nbool locked = false;\n","contract":"PLATINUM","time":0},{"type":"external-function ","before":"function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n        return true;\n    }","after":"function approveAndCall(address spender, uint tokens, bytes calldata data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n        return true;\n    }","contract":"PLATINUM","time":0},{"type":"constant-restrict-modification  ","before":"uint public _BLOCKS_PER_READJUSTMENT = 1024;","after":"uint public constant _BLOCKS_PER_READJUSTMENT = 1024;","contract":"PLATINUM","time":0},{"type":"constant-restrict-modification  ","before":"uint public  _MINIMUM_TARGET = 2**16;","after":"uint public  constant _MINIMUM_TARGET = 2**16;","contract":"PLATINUM","time":0},{"type":"constant-restrict-modification  ","before":"uint public  _MAXIMUM_TARGET = 2**234;","after":"uint public  constant _MAXIMUM_TARGET = 2**234;","contract":"PLATINUM","time":0},{"type":"state-data-arrangement ","before":"\nstring public symbol;\nstring public  name;\nuint8 public decimals;\nuint public _totalSupply;\nuint public latestDifficultyPeriodStarted;\nuint public epochCount;\nuint public _BLOCKS_PER_READJUSTMENT = 1024;\nuint public  _MINIMUM_TARGET = 2**16;\nuint public  _MAXIMUM_TARGET = 2**234;\nuint public miningTarget;\nbytes32 public challengeNumber;\nuint public rewardEra;\nuint public maxSupplyForEra;\naddress public lastRewardTo;\nuint public lastRewardAmount;\nuint public lastRewardEthBlockNumber;\nbool locked = false;\nmapping(bytes32 => bytes32) solutionForChallenge;\nuint public tokensMinted;\nmapping(address => uint) balances;\nmapping(address => mapping(address => uint)) allowed;","after":"string public symbol;\nstring public  name;\nuint public _totalSupply;\nuint public latestDifficultyPeriodStarted;\nuint public epochCount;\nuint public _BLOCKS_PER_READJUSTMENT = 1024;\nuint public  _MINIMUM_TARGET = 2**16;\nuint public  _MAXIMUM_TARGET = 2**234;\nuint public miningTarget;\nbytes32 public challengeNumber;\nuint public rewardEra;\nuint public maxSupplyForEra;\nuint public lastRewardAmount;\nuint public lastRewardEthBlockNumber;\nmapping(bytes32 => bytes32) solutionForChallenge;\nuint public tokensMinted;\nmapping(address => uint) balances;\nmapping(address => mapping(address => uint)) allowed;\naddress public lastRewardTo;\nuint8 public decimals;\nbool locked = false;\n","contract":"PALLADIUM","time":0},{"type":"external-function ","before":"function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n        return true;\n    }","after":"function approveAndCall(address spender, uint tokens, bytes calldata data) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n        return true;\n    }","contract":"PALLADIUM","time":0},{"type":"constant-restrict-modification  ","before":"uint public _BLOCKS_PER_READJUSTMENT = 1024;","after":"uint public constant _BLOCKS_PER_READJUSTMENT = 1024;","contract":"PALLADIUM","time":1},{"type":"constant-restrict-modification  ","before":"uint public  _MINIMUM_TARGET = 2**16;","after":"uint public  constant _MINIMUM_TARGET = 2**16;","contract":"PALLADIUM","time":1},{"type":"constant-restrict-modification  ","before":"uint public  _MAXIMUM_TARGET = 2**234;","after":"uint public  constant _MAXIMUM_TARGET = 2**234;","contract":"PALLADIUM","time":1}]}