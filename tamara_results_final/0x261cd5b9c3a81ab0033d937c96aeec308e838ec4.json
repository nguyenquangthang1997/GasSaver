{"time":197,"results":[{"type":"external-function ","before":" function issueRebalancingSetWithEther(\n        address _rebalancingSetAddress,\n        uint256 _rebalancingSetQuantity,\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\n        bytes memory _orderData,\n        bool _keepChangeInVault\n    )\n        public\n        payable\n        nonReentrant\n    {\n        // Wrap all Ether; Wrapped Ether could be a component of the Set being issued.\n        wethInstance.deposit.value(msg.value)();\n\n        // Perform exchange transactions, mint the base SetToken, and issue the Rebalancing Set to the sender\n        issueRebalancingSetInternal(\n            _rebalancingSetAddress,\n            _rebalancingSetQuantity,\n            address(wethInstance),\n            msg.value,\n            _exchangeIssuanceParams,\n            _orderData,\n            _keepChangeInVault\n        );\n\n        // unwrap any leftover WETH and transfer to sender\n        uint256 leftoverWeth = ERC20Wrapper.balanceOf(address(wethInstance), address(this));\n        if (leftoverWeth > 0) {\n            // Withdraw wrapped Ether\n            wethInstance.withdraw(leftoverWeth);\n\n            // Transfer ether to user\n            msg.sender.transfer(leftoverWeth);\n        }\n\n        emit LogPayableExchangeIssue(\n            _rebalancingSetAddress,\n            msg.sender,\n            address(wethInstance),\n            _rebalancingSetQuantity,\n            leftoverWeth\n        );\n    ","after":" function issueRebalancingSetWithEther(\n        address _rebalancingSetAddress,\n        uint256 _rebalancingSetQuantity,\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams calldata _exchangeIssuanceParams,\n        bytes calldata _orderData,\n        bool _keepChangeInVault\n    )\n        public\n        payable\n        nonReentrant\n    {\n        // Wrap all Ether; Wrapped Ether could be a component of the Set being issued.\n        wethInstance.deposit.value(msg.value)();\n\n        // Perform exchange transactions, mint the base SetToken, and issue the Rebalancing Set to the sender\n        issueRebalancingSetInternal(\n            _rebalancingSetAddress,\n            _rebalancingSetQuantity,\n            address(wethInstance),\n            msg.value,\n            _exchangeIssuanceParams,\n            _orderData,\n            _keepChangeInVault\n        );\n\n        // unwrap any leftover WETH and transfer to sender\n        uint256 leftoverWeth = ERC20Wrapper.balanceOf(address(wethInstance), address(this));\n        if (leftoverWeth > 0) {\n            // Withdraw wrapped Ether\n            wethInstance.withdraw(leftoverWeth);\n\n            // Transfer ether to user\n            msg.sender.transfer(leftoverWeth);\n        }\n\n        emit LogPayableExchangeIssue(\n            _rebalancingSetAddress,\n            msg.sender,\n            address(wethInstance),\n            _rebalancingSetQuantity,\n            leftoverWeth\n        );\n    ","contract":"RebalancingSetExchangeIssuanceModule","time":0},{"type":"external-function ","before":" function issueRebalancingSetWithERC20(\n        address _rebalancingSetAddress,\n        uint256 _rebalancingSetQuantity,\n        address _paymentTokenAddress,\n        uint256 _paymentTokenQuantity,\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\n        bytes memory _orderData,\n        bool _keepChangeInVault\n    )\n        public\n        nonReentrant\n    {\n        // Deposit the erc20 to this contract. The token must be approved the caller to the transferProxy\n        coreInstance.transferModule(\n            _paymentTokenAddress,\n            _paymentTokenQuantity,\n            msg.sender,\n            address(this)\n        );\n\n        // Perform exchange transactions, mint the base SetToken, and issue the Rebalancing Set to the sender\n        issueRebalancingSetInternal(\n            _rebalancingSetAddress,\n            _rebalancingSetQuantity,\n            _paymentTokenAddress,\n            _paymentTokenQuantity,\n            _exchangeIssuanceParams,\n            _orderData,\n            _keepChangeInVault\n        );\n\n        // Send back any unused payment token\n        uint256 leftoverPaymentTokenQuantity = ERC20Wrapper.balanceOf(_paymentTokenAddress, address(this));\n        if (leftoverPaymentTokenQuantity > 0) {\n            ERC20Wrapper.transfer(\n                _paymentTokenAddress,\n                msg.sender,\n                leftoverPaymentTokenQuantity\n            );\n        }\n\n        emit LogPayableExchangeIssue(\n            _rebalancingSetAddress,\n            msg.sender,\n            _paymentTokenAddress,\n            _rebalancingSetQuantity,\n            leftoverPaymentTokenQuantity\n        );\n    ","after":" function issueRebalancingSetWithERC20(\n        address _rebalancingSetAddress,\n        uint256 _rebalancingSetQuantity,\n        address _paymentTokenAddress,\n        uint256 _paymentTokenQuantity,\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams calldata _exchangeIssuanceParams,\n        bytes calldata _orderData,\n        bool _keepChangeInVault\n    )\n        public\n        nonReentrant\n    {\n        // Deposit the erc20 to this contract. The token must be approved the caller to the transferProxy\n        coreInstance.transferModule(\n            _paymentTokenAddress,\n            _paymentTokenQuantity,\n            msg.sender,\n            address(this)\n        );\n\n        // Perform exchange transactions, mint the base SetToken, and issue the Rebalancing Set to the sender\n        issueRebalancingSetInternal(\n            _rebalancingSetAddress,\n            _rebalancingSetQuantity,\n            _paymentTokenAddress,\n            _paymentTokenQuantity,\n            _exchangeIssuanceParams,\n            _orderData,\n            _keepChangeInVault\n        );\n\n        // Send back any unused payment token\n        uint256 leftoverPaymentTokenQuantity = ERC20Wrapper.balanceOf(_paymentTokenAddress, address(this));\n        if (leftoverPaymentTokenQuantity > 0) {\n            ERC20Wrapper.transfer(\n                _paymentTokenAddress,\n                msg.sender,\n                leftoverPaymentTokenQuantity\n            );\n        }\n\n        emit LogPayableExchangeIssue(\n            _rebalancingSetAddress,\n            msg.sender,\n            _paymentTokenAddress,\n            _rebalancingSetQuantity,\n            leftoverPaymentTokenQuantity\n        );\n    ","contract":"RebalancingSetExchangeIssuanceModule","time":0},{"type":"external-function ","before":" function redeemRebalancingSetIntoEther(\n        address _rebalancingSetAddress,\n        uint256 _rebalancingSetQuantity,\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\n        bytes memory _orderData,\n        bool _keepChangeInVault\n    )\n        public\n        nonReentrant\n    {\n        // Redeems the rebalancing Set into the base SetToken, redeems the base SetToken into its components,\n        // and exchanges the components into wrapped ether to this contract.\n        redeemRebalancingSetIntoComponentsInternal(\n            _rebalancingSetAddress,\n            _rebalancingSetQuantity,\n            address(wethInstance),\n            _exchangeIssuanceParams,\n            _orderData\n        );\n\n        // In the event that exchangeIssue returns more receiveTokens or wrappedEth than\n        // specified in receiveToken quantity, those tokens are also retrieved into this contract.\n        // We also call this ahead of returnRedemptionChange to allow the unwrapping of the wrappedEther\n        uint256 wethQuantityInVault = vaultInstance.getOwnerBalance(address(wethInstance), address(this));\n        if (wethQuantityInVault > 0) {\n            coreInstance.withdrawModule(\n                address(this),\n                address(this),\n                address(wethInstance),\n                wethQuantityInVault\n            );\n        }\n\n        // Unwrap wrapped Ether and transfer Eth to user\n        uint256 wethBalance = ERC20Wrapper.balanceOf(address(wethInstance), address(this));\n        if (wethBalance > 0) {\n            wethInstance.withdraw(wethBalance);\n            msg.sender.transfer(wethBalance);\n        }\n\n        address baseSetAddress = _exchangeIssuanceParams.setAddress;\n\n        // Send excess base Set to the user\n        returnExcessBaseSetFromContract(\n            baseSetAddress,\n            msg.sender,\n            _keepChangeInVault\n        );\n\n        // Return non-exchanged components to the user\n        returnExcessComponentsFromContract(ISetToken(baseSetAddress), msg.sender);\n\n        emit LogPayableExchangeRedeem(\n            _rebalancingSetAddress,\n            msg.sender,\n            address(wethInstance),\n            _rebalancingSetQuantity,\n            wethBalance\n        );\n    ","after":" function redeemRebalancingSetIntoEther(\n        address _rebalancingSetAddress,\n        uint256 _rebalancingSetQuantity,\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams calldata _exchangeIssuanceParams,\n        bytes calldata _orderData,\n        bool _keepChangeInVault\n    )\n        public\n        nonReentrant\n    {\n        // Redeems the rebalancing Set into the base SetToken, redeems the base SetToken into its components,\n        // and exchanges the components into wrapped ether to this contract.\n        redeemRebalancingSetIntoComponentsInternal(\n            _rebalancingSetAddress,\n            _rebalancingSetQuantity,\n            address(wethInstance),\n            _exchangeIssuanceParams,\n            _orderData\n        );\n\n        // In the event that exchangeIssue returns more receiveTokens or wrappedEth than\n        // specified in receiveToken quantity, those tokens are also retrieved into this contract.\n        // We also call this ahead of returnRedemptionChange to allow the unwrapping of the wrappedEther\n        uint256 wethQuantityInVault = vaultInstance.getOwnerBalance(address(wethInstance), address(this));\n        if (wethQuantityInVault > 0) {\n            coreInstance.withdrawModule(\n                address(this),\n                address(this),\n                address(wethInstance),\n                wethQuantityInVault\n            );\n        }\n\n        // Unwrap wrapped Ether and transfer Eth to user\n        uint256 wethBalance = ERC20Wrapper.balanceOf(address(wethInstance), address(this));\n        if (wethBalance > 0) {\n            wethInstance.withdraw(wethBalance);\n            msg.sender.transfer(wethBalance);\n        }\n\n        address baseSetAddress = _exchangeIssuanceParams.setAddress;\n\n        // Send excess base Set to the user\n        returnExcessBaseSetFromContract(\n            baseSetAddress,\n            msg.sender,\n            _keepChangeInVault\n        );\n\n        // Return non-exchanged components to the user\n        returnExcessComponentsFromContract(ISetToken(baseSetAddress), msg.sender);\n\n        emit LogPayableExchangeRedeem(\n            _rebalancingSetAddress,\n            msg.sender,\n            address(wethInstance),\n            _rebalancingSetQuantity,\n            wethBalance\n        );\n    ","contract":"RebalancingSetExchangeIssuanceModule","time":0},{"type":"external-function ","before":" function redeemRebalancingSetIntoERC20(\n        address _rebalancingSetAddress,\n        uint256 _rebalancingSetQuantity,\n        address _outputTokenAddress,\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams memory _exchangeIssuanceParams,\n        bytes memory _orderData,\n        bool _keepChangeInVault\n    )\n        public\n        nonReentrant\n    {\n        // Redeems the rebalancing Set into the base SetToken, redeems the base SetToken into its components,\n        // and exchanges the components into the receiveToken to this contract.\n        redeemRebalancingSetIntoComponentsInternal(\n            _rebalancingSetAddress,\n            _rebalancingSetQuantity,\n            _outputTokenAddress,\n            _exchangeIssuanceParams,\n            _orderData\n        );\n\n        // In the event that exchangeIssue returns more outputTokens than\n        // specified in receiveToken quantity, those tokens are also retrieved into this contract.\n        uint256 outputTokenInVault = vaultInstance.getOwnerBalance(_outputTokenAddress, address(this));\n        if (outputTokenInVault > 0) {\n            coreInstance.withdrawModule(\n                address(this),\n                address(this),\n                _outputTokenAddress,\n                outputTokenInVault\n            );\n        }\n\n        // Transfer outputToken to the caller\n        uint256 outputTokenBalance = ERC20Wrapper.balanceOf(_outputTokenAddress, address(this));\n        ERC20Wrapper.transfer(\n            _outputTokenAddress,\n            msg.sender,\n            outputTokenBalance\n        );\n\n        address baseSetAddress = _exchangeIssuanceParams.setAddress;\n\n        // Send excess base SetToken to the user\n        returnExcessBaseSetFromContract(\n            baseSetAddress,\n            msg.sender,\n            _keepChangeInVault\n        );\n\n        // Non-exchanged base SetToken components are returned to the user\n        returnExcessComponentsFromContract(ISetToken(baseSetAddress), msg.sender);\n\n        emit LogPayableExchangeRedeem(\n            _rebalancingSetAddress,\n            msg.sender,\n            _outputTokenAddress,\n            _rebalancingSetQuantity,\n            outputTokenBalance\n        );\n    ","after":" function redeemRebalancingSetIntoERC20(\n        address _rebalancingSetAddress,\n        uint256 _rebalancingSetQuantity,\n        address _outputTokenAddress,\n        ExchangeIssuanceLibrary.ExchangeIssuanceParams calldata _exchangeIssuanceParams,\n        bytes calldata _orderData,\n        bool _keepChangeInVault\n    )\n        public\n        nonReentrant\n    {\n        // Redeems the rebalancing Set into the base SetToken, redeems the base SetToken into its components,\n        // and exchanges the components into the receiveToken to this contract.\n        redeemRebalancingSetIntoComponentsInternal(\n            _rebalancingSetAddress,\n            _rebalancingSetQuantity,\n            _outputTokenAddress,\n            _exchangeIssuanceParams,\n            _orderData\n        );\n\n        // In the event that exchangeIssue returns more outputTokens than\n        // specified in receiveToken quantity, those tokens are also retrieved into this contract.\n        uint256 outputTokenInVault = vaultInstance.getOwnerBalance(_outputTokenAddress, address(this));\n        if (outputTokenInVault > 0) {\n            coreInstance.withdrawModule(\n                address(this),\n                address(this),\n                _outputTokenAddress,\n                outputTokenInVault\n            );\n        }\n\n        // Transfer outputToken to the caller\n        uint256 outputTokenBalance = ERC20Wrapper.balanceOf(_outputTokenAddress, address(this));\n        ERC20Wrapper.transfer(\n            _outputTokenAddress,\n            msg.sender,\n            outputTokenBalance\n        );\n\n        address baseSetAddress = _exchangeIssuanceParams.setAddress;\n\n        // Send excess base SetToken to the user\n        returnExcessBaseSetFromContract(\n            baseSetAddress,\n            msg.sender,\n            _keepChangeInVault\n        );\n\n        // Non-exchanged base SetToken components are returned to the user\n        returnExcessComponentsFromContract(ISetToken(baseSetAddress), msg.sender);\n\n        emit LogPayableExchangeRedeem(\n            _rebalancingSetAddress,\n            msg.sender,\n            _outputTokenAddress,\n            _rebalancingSetQuantity,\n            outputTokenBalance\n        );\n    ","contract":"RebalancingSetExchangeIssuanceModule","time":0}]}