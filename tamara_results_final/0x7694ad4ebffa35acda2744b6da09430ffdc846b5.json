{"time":697,"results":[{"type":"external-function ","before":"function initialize(address _logic, address _admin, bytes memory _data) public payable {\n        require(_implementation() == address(0));\n        InitializableUpgradeabilityProxy.initialize(_logic, _data);\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(_admin);\n    }","after":"function initialize(address _logic, address _admin, bytes calldata _data) public payable {\n        require(_implementation() == address(0));\n        InitializableUpgradeabilityProxy.initialize(_logic, _data);\n        assert(ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _setAdmin(_admin);\n    }","contract":"InitializableAdminUpgradeabilityProxy","time":0},{"type":"external-function ","before":"function initialize(address _logic, bytes memory _data) public payable {\n        require(_implementation() == address(0));\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n    }","after":"function initialize(address _logic, bytes calldata _data) public payable {\n        require(_implementation() == address(0));\n        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _setImplementation(_logic);\n        if (_data.length > 0) {\n            (bool success, ) = _logic.delegatecall(_data);\n            require(success);\n        }\n    }","contract":"InitializableAdminUpgradeabilityProxy","time":0},{"type":"de-morgan-condition ","before":"!vars.reserveUsageAsCollateralEnabled ||\n            !core.isUserUseReserveAsCollateralEnabled(_reserve, _user)","after":"!(vars.reserveUsageAsCollateralEnabled ||\n            core.isUserUseReserveAsCollateralEnabled(_reserve, _user))","loc":{"start":{"line":2219,"column":12},"end":{"line":2220,"column":69}},"contract":"LendingPoolDataProvider","time":0},{"type":"de-morgan-condition ","before":"!user.useAsCollateral ||\n            !reserve.usageAsCollateralEnabled","after":"!(user.useAsCollateral ||\n            reserve.usageAsCollateralEnabled)","loc":{"start":{"line":3761,"column":12},"end":{"line":3762,"column":21}},"contract":"LendingPoolCore","time":1},{"type":"external-function ","before":"function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes memory _params)\n        public\n        nonReentrant\n        onlyActiveReserve(_reserve)\n        onlyAmountGreaterThanZero(_amount)\n    {\n        //check that the reserve has enough available liquidity\n        //we avoid using the getAvailableLiquidity() function in LendingPoolCore to save gas\n        uint256 availableLiquidityBefore = _reserve == EthAddressLib.ethAddress()\n            ? address(core).balance\n            : IERC20(_reserve).balanceOf(address(core));\n\n        require(\n            availableLiquidityBefore >= _amount,\n            \"There is not enough liquidity available to borrow\"\n        );\n\n        (uint256 totalFeeBips, uint256 protocolFeeBips) = parametersProvider\n            .getFlashLoanFeesInBips();\n        //calculate amount fee\n        uint256 amountFee = _amount.mul(totalFeeBips).div(10000);\n\n        //protocol fee is the part of the amountFee reserved for the protocol - the rest goes to depositors\n        uint256 protocolFee = amountFee.mul(protocolFeeBips).div(10000);\n        require(\n            amountFee > 0 && protocolFee > 0,\n            \"The requested amount is too small for a flashLoan.\"\n        );\n\n        //get the FlashLoanReceiver instance\n        IFlashLoanReceiver receiver = IFlashLoanReceiver(_receiver);\n\n        address payable userPayable = address(uint160(_receiver));\n\n        //transfer funds to the receiver\n        core.transferToUser(_reserve, userPayable, _amount);\n\n        //execute action of the receiver\n        receiver.executeOperation(_reserve, _amount, amountFee, _params);\n\n        //check that the actual balance of the core contract includes the returned amount\n        uint256 availableLiquidityAfter = _reserve == EthAddressLib.ethAddress()\n            ? address(core).balance\n            : IERC20(_reserve).balanceOf(address(core));\n\n        require(\n            availableLiquidityAfter == availableLiquidityBefore.add(amountFee),\n            \"The actual balance of the protocol is inconsistent\"\n        );\n\n        core.updateStateOnFlashLoan(\n            _reserve,\n            availableLiquidityBefore,\n            amountFee.sub(protocolFee),\n            protocolFee\n        );\n\n        //solium-disable-next-line\n        emit FlashLoan(_receiver, _reserve, _amount, amountFee, protocolFee, block.timestamp);\n    }","after":"function flashLoan(address _receiver, address _reserve, uint256 _amount, bytes calldata _params)\n        public\n        nonReentrant\n        onlyActiveReserve(_reserve)\n        onlyAmountGreaterThanZero(_amount)\n    {\n        //check that the reserve has enough available liquidity\n        //we avoid using the getAvailableLiquidity() function in LendingPoolCore to save gas\n        uint256 availableLiquidityBefore = _reserve == EthAddressLib.ethAddress()\n            ? address(core).balance\n            : IERC20(_reserve).balanceOf(address(core));\n\n        require(\n            availableLiquidityBefore >= _amount,\n            \"There is not enough liquidity available to borrow\"\n        );\n\n        (uint256 totalFeeBips, uint256 protocolFeeBips) = parametersProvider\n            .getFlashLoanFeesInBips();\n        //calculate amount fee\n        uint256 amountFee = _amount.mul(totalFeeBips).div(10000);\n\n        //protocol fee is the part of the amountFee reserved for the protocol - the rest goes to depositors\n        uint256 protocolFee = amountFee.mul(protocolFeeBips).div(10000);\n        require(\n            amountFee > 0 && protocolFee > 0,\n            \"The requested amount is too small for a flashLoan.\"\n        );\n\n        //get the FlashLoanReceiver instance\n        IFlashLoanReceiver receiver = IFlashLoanReceiver(_receiver);\n\n        address payable userPayable = address(uint160(_receiver));\n\n        //transfer funds to the receiver\n        core.transferToUser(_reserve, userPayable, _amount);\n\n        //execute action of the receiver\n        receiver.executeOperation(_reserve, _amount, amountFee, _params);\n\n        //check that the actual balance of the core contract includes the returned amount\n        uint256 availableLiquidityAfter = _reserve == EthAddressLib.ethAddress()\n            ? address(core).balance\n            : IERC20(_reserve).balanceOf(address(core));\n\n        require(\n            availableLiquidityAfter == availableLiquidityBefore.add(amountFee),\n            \"The actual balance of the protocol is inconsistent\"\n        );\n\n        core.updateStateOnFlashLoan(\n            _reserve,\n            availableLiquidityBefore,\n            amountFee.sub(protocolFee),\n            protocolFee\n        );\n\n        //solium-disable-next-line\n        emit FlashLoan(_receiver, _reserve, _amount, amountFee, protocolFee, block.timestamp);\n    }","contract":"LendingPool","time":0},{"type":"external-function ","before":"function initialize(\n        address _recipientBurn,\n        address _tokenToBurn,\n        address _kyberProxy,\n        address[] memory _receivers,\n        uint256[] memory _percentages,\n        IERC20[] memory _tokens\n    ) public initializer {\n        recipientBurn = _recipientBurn;\n        tokenToBurn = _tokenToBurn;\n        kyberProxy = IKyberNetworkProxyInterface(_kyberProxy);\n        internalSetTokenDistribution(_receivers, _percentages);\n        approveKyber(_tokens);\n        emit Setup(_tokenToBurn, _kyberProxy, _recipientBurn);\n    }","after":"function initialize(\n        address _recipientBurn,\n        address _tokenToBurn,\n        address _kyberProxy,\n        address[] calldata _receivers,\n        uint256[] calldata _percentages,\n        IERC20[] calldata _tokens\n    ) public initializer {\n        recipientBurn = _recipientBurn;\n        tokenToBurn = _tokenToBurn;\n        kyberProxy = IKyberNetworkProxyInterface(_kyberProxy);\n        internalSetTokenDistribution(_receivers, _percentages);\n        approveKyber(_tokens);\n        emit Setup(_tokenToBurn, _kyberProxy, _recipientBurn);\n    }","contract":"TokenDistributor","time":0},{"type":"external-function ","before":"function distribute(IERC20[] memory _tokens) public nonReentrant {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _tokenAddress = address(_tokens[i]);\n            uint256 _balanceToDistribute = (_tokenAddress != EthAddressLib.ethAddress())\n                ? _tokens[i].balanceOf(address(this))\n                : address(this).balance;\n            if (_balanceToDistribute <= 0) {\n                continue;\n            }\n\n            Distribution memory _distribution = distribution;\n            for (uint256 j = 0; j < _distribution.receivers.length; j++) {\n                uint256 _amount = _balanceToDistribute.mul(_distribution.percentages[j]).div(DISTRIBUTION_BASE);\n                if (_distribution.receivers[j] != address(0)) {\n                    if (_tokenAddress != EthAddressLib.ethAddress()) {\n                        _tokens[i].safeTransfer(_distribution.receivers[j], _amount);\n                    } else {\n                        (bool _success,) = _distribution.receivers[j].call.value(_amount)(\"\");\n                        require(_success, \"Reverted ETH transfer\");\n                    }\n                    emit Distributed(_distribution.receivers[j], _distribution.percentages[j], _amount);\n                } else {\n                    uint256 _amountToBurn = _amount;\n                    // If the token to burn is already tokenToBurn, we don't trade, burning directly\n                    if (_tokenAddress != tokenToBurn) {\n                        _amountToBurn = internalTrade(_tokenAddress, _amount);\n                    }\n                    internalBurn(_amountToBurn);\n                }\n            }\n        }\n    }","after":"function distribute(IERC20[] calldata _tokens) public nonReentrant {\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            address _tokenAddress = address(_tokens[i]);\n            uint256 _balanceToDistribute = (_tokenAddress != EthAddressLib.ethAddress())\n                ? _tokens[i].balanceOf(address(this))\n                : address(this).balance;\n            if (_balanceToDistribute <= 0) {\n                continue;\n            }\n\n            Distribution memory _distribution = distribution;\n            for (uint256 j = 0; j < _distribution.receivers.length; j++) {\n                uint256 _amount = _balanceToDistribute.mul(_distribution.percentages[j]).div(DISTRIBUTION_BASE);\n                if (_distribution.receivers[j] != address(0)) {\n                    if (_tokenAddress != EthAddressLib.ethAddress()) {\n                        _tokens[i].safeTransfer(_distribution.receivers[j], _amount);\n                    } else {\n                        (bool _success,) = _distribution.receivers[j].call.value(_amount)(\"\");\n                        require(_success, \"Reverted ETH transfer\");\n                    }\n                    emit Distributed(_distribution.receivers[j], _distribution.percentages[j], _amount);\n                } else {\n                    uint256 _amountToBurn = _amount;\n                    // If the token to burn is already tokenToBurn, we don't trade, burning directly\n                    if (_tokenAddress != tokenToBurn) {\n                        _amountToBurn = internalTrade(_tokenAddress, _amount);\n                    }\n                    internalBurn(_amountToBurn);\n                }\n            }\n        }\n    }","contract":"TokenDistributor","time":0}]}