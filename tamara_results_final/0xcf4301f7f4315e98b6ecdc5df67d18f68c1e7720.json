{"time":30,"results":[{"type":"external-function ","before":"function stake(address _userFortmaticAddress, uint _expiryDate, bytes memory _signature) public payable whenNotPaused {\n        bytes32 hashMessage = keccak256(abi.encodePacked(_userFortmaticAddress, msg.value, _expiryDate));\n        address signer = hashMessage.toEthSignedMessageHash().recover(_signature);\n\n        require(signer == grantSigner, \"Signature is not valid\");\n        require(block.timestamp < _expiryDate, \"Grant is expired\");\n        require(userStakedAddress[_userFortmaticAddress] == address(0x0), \"User has already staked!\");\n\n        userStakedAddress[_userFortmaticAddress] = msg.sender;\n        stakedAmount[_userFortmaticAddress] = msg.value;\n\n        emit UserStake(_userFortmaticAddress, msg.sender, msg.value);\n    }","after":"function stake(address _userFortmaticAddress, uint _expiryDate, bytes calldata _signature) public payable whenNotPaused {\n        bytes32 hashMessage = keccak256(abi.encodePacked(_userFortmaticAddress, msg.value, _expiryDate));\n        address signer = hashMessage.toEthSignedMessageHash().recover(_signature);\n\n        require(signer == grantSigner, \"Signature is not valid\");\n        require(block.timestamp < _expiryDate, \"Grant is expired\");\n        require(userStakedAddress[_userFortmaticAddress] == address(0x0), \"User has already staked!\");\n\n        userStakedAddress[_userFortmaticAddress] = msg.sender;\n        stakedAmount[_userFortmaticAddress] = msg.value;\n\n        emit UserStake(_userFortmaticAddress, msg.sender, msg.value);\n    }","contract":"ETHDenverStaking","time":0},{"type":"external-function ","before":"function recoupStake(address _userFortmaticAddress, uint _expiryDate, bytes memory _signature) public whenNotPaused {\n        bytes32 hashMessage = keccak256(abi.encodePacked(_userFortmaticAddress, _expiryDate));\n        address signer = hashMessage.toEthSignedMessageHash().recover(_signature);\n\n        require(signer == grantSigner, \"Signature is not valid\");\n        require(block.timestamp < _expiryDate, \"Grant is expired\");\n        require(userStakedAddress[_userFortmaticAddress] != address(0x0), \"User has not staked!\");\n\n        address payable stakedBy = userStakedAddress[_userFortmaticAddress];\n        uint amount = stakedAmount[_userFortmaticAddress];\n        userStakedAddress[_userFortmaticAddress] = address(0x0);\n        stakedAmount[_userFortmaticAddress] = 0;\n\n        stakedBy.transfer(amount);\n\n        emit UserRecoupStake(_userFortmaticAddress, stakedBy, amount);\n    }","after":"function recoupStake(address _userFortmaticAddress, uint _expiryDate, bytes calldata _signature) public whenNotPaused {\n        bytes32 hashMessage = keccak256(abi.encodePacked(_userFortmaticAddress, _expiryDate));\n        address signer = hashMessage.toEthSignedMessageHash().recover(_signature);\n\n        require(signer == grantSigner, \"Signature is not valid\");\n        require(block.timestamp < _expiryDate, \"Grant is expired\");\n        require(userStakedAddress[_userFortmaticAddress] != address(0x0), \"User has not staked!\");\n\n        address payable stakedBy = userStakedAddress[_userFortmaticAddress];\n        uint amount = stakedAmount[_userFortmaticAddress];\n        userStakedAddress[_userFortmaticAddress] = address(0x0);\n        stakedAmount[_userFortmaticAddress] = 0;\n\n        stakedBy.transfer(amount);\n\n        emit UserRecoupStake(_userFortmaticAddress, stakedBy, amount);\n    }","contract":"ETHDenverStaking","time":0}]}