{"time":298,"results":[{"type":"external-function ","before":"function validateTrades(\n        uint256[] memory _values,\n        bytes32[] memory _hashes,\n        address[] memory _addresses,\n        address _operator\n    )\n        public\n        returns (bytes32[] memory)\n    {\n        _validateTradeInputLengths(_values, _hashes);\n        _validateUniqueOffers(_values);\n        _validateMatches(_values, _addresses);\n        _validateFillAmounts(_values);\n        _validateTradeData(_values, _addresses, _operator);\n\n        // validate signatures of all offers\n        _validateTradeSignatures(\n            _values,\n            _hashes,\n            _addresses,\n            OFFER_TYPEHASH,\n            0,\n            _values[0] & mask8 // numOffers\n        );\n\n        // validate signatures of all fills\n        _validateTradeSignatures(\n            _values,\n            _hashes,\n            _addresses,\n            FILL_TYPEHASH,\n            _values[0] & mask8, // numOffers\n            (_values[0] & mask8) + ((_values[0] & mask16) >> 8) // numOffers + numFills\n        );\n\n        _emitTradeEvents(_values, _addresses, new address[](0), false);\n\n        return _hashes;\n    }","after":"function validateTrades(\n        uint256[] calldata _values,\n        bytes32[] calldata _hashes,\n        address[] calldata _addresses,\n        address _operator\n    )\n        public\n        returns (bytes32[] memory)\n    {\n        _validateTradeInputLengths(_values, _hashes);\n        _validateUniqueOffers(_values);\n        _validateMatches(_values, _addresses);\n        _validateFillAmounts(_values);\n        _validateTradeData(_values, _addresses, _operator);\n\n        // validate signatures of all offers\n        _validateTradeSignatures(\n            _values,\n            _hashes,\n            _addresses,\n            OFFER_TYPEHASH,\n            0,\n            _values[0] & mask8 // numOffers\n        );\n\n        // validate signatures of all fills\n        _validateTradeSignatures(\n            _values,\n            _hashes,\n            _addresses,\n            FILL_TYPEHASH,\n            _values[0] & mask8, // numOffers\n            (_values[0] & mask8) + ((_values[0] & mask16) >> 8) // numOffers + numFills\n        );\n\n        _emitTradeEvents(_values, _addresses, new address[](0), false);\n\n        return _hashes;\n    }","contract":"Utils","time":0},{"type":"external-function ","before":"function performNetworkTrades(\n        uint256[] memory _values,\n        address[] memory _addresses,\n        address[] memory _marketDapps\n    )\n        public\n        returns (uint256[] memory)\n    {\n        uint256[] memory increments = new uint256[](_addresses.length / 2);\n        // i = 1 + numOffers * 2\n        uint256 i = 1 + (_values[0] & mask8) * 2;\n        uint256 end = _values.length;\n\n        // loop matches\n        for(i; i < end; i++) {\n            uint256[] memory data = new uint256[](9);\n            data[0] = _values[i]; // match data\n            data[1] = data[0] & mask8; // offerIndex\n            data[2] = (data[0] & mask24) >> 16; // operator.surplusAssetIndex\n            data[3] = _values[data[1] * 2 + 1]; // offer.dataA\n            data[4] = _values[data[1] * 2 + 2]; // offer.dataB\n            data[5] = ((data[3] & mask16) >> 8); // maker.offerAssetIndex\n            data[6] = ((data[3] & mask24) >> 16); // maker.wantAssetIndex\n            // amount of offerAssetId to take from the offer is equal to the match.takeAmount\n            data[7] = data[0] >> 128;\n            // expected amount to receive is: matchData.takeAmount * offer.wantAmount / offer.offerAmount\n            data[8] = data[7].mul(data[4] >> 128).div(data[4] & mask128);\n\n            address[] memory assetIds = new address[](3);\n            assetIds[0] = _addresses[data[5] * 2 + 1]; // offer.offerAssetId\n            assetIds[1] = _addresses[data[6] * 2 + 1]; // offer.wantAssetId\n            assetIds[2] = _addresses[data[2] * 2 + 1]; // surplusAssetId\n\n            uint256[] memory dataValues = new uint256[](3);\n            dataValues[0] = data[7]; // the proportion of offerAmount to offer\n            dataValues[1] = data[8]; // the proportion of wantAmount to receive for the offer\n            dataValues[2] = data[0]; // match data\n\n            increments[data[2]] = _performNetworkTrade(\n                assetIds,\n                dataValues,\n                _marketDapps,\n                _addresses\n            );\n        }\n\n        _emitTradeEvents(_values, _addresses, _marketDapps, true);\n\n        return increments;\n    }","after":"function performNetworkTrades(\n        uint256[] calldata _values,\n        address[] calldata _addresses,\n        address[] calldata _marketDapps\n    )\n        public\n        returns (uint256[] memory)\n    {\n        uint256[] memory increments = new uint256[](_addresses.length / 2);\n        // i = 1 + numOffers * 2\n        uint256 i = 1 + (_values[0] & mask8) * 2;\n        uint256 end = _values.length;\n\n        // loop matches\n        for(i; i < end; i++) {\n            uint256[] memory data = new uint256[](9);\n            data[0] = _values[i]; // match data\n            data[1] = data[0] & mask8; // offerIndex\n            data[2] = (data[0] & mask24) >> 16; // operator.surplusAssetIndex\n            data[3] = _values[data[1] * 2 + 1]; // offer.dataA\n            data[4] = _values[data[1] * 2 + 2]; // offer.dataB\n            data[5] = ((data[3] & mask16) >> 8); // maker.offerAssetIndex\n            data[6] = ((data[3] & mask24) >> 16); // maker.wantAssetIndex\n            // amount of offerAssetId to take from the offer is equal to the match.takeAmount\n            data[7] = data[0] >> 128;\n            // expected amount to receive is: matchData.takeAmount * offer.wantAmount / offer.offerAmount\n            data[8] = data[7].mul(data[4] >> 128).div(data[4] & mask128);\n\n            address[] memory assetIds = new address[](3);\n            assetIds[0] = _addresses[data[5] * 2 + 1]; // offer.offerAssetId\n            assetIds[1] = _addresses[data[6] * 2 + 1]; // offer.wantAssetId\n            assetIds[2] = _addresses[data[2] * 2 + 1]; // surplusAssetId\n\n            uint256[] memory dataValues = new uint256[](3);\n            dataValues[0] = data[7]; // the proportion of offerAmount to offer\n            dataValues[1] = data[8]; // the proportion of wantAmount to receive for the offer\n            dataValues[2] = data[0]; // match data\n\n            increments[data[2]] = _performNetworkTrade(\n                assetIds,\n                dataValues,\n                _marketDapps,\n                _addresses\n            );\n        }\n\n        _emitTradeEvents(_values, _addresses, _marketDapps, true);\n\n        return increments;\n    }","contract":"Utils","time":0},{"type":"external-function ","before":"function trade(\n        address[] memory _assetIds,\n        uint256[] memory _dataValues,\n        address[] memory _addresses,\n        address payable _recipient\n    )\n        public\n        payable\n        nonReentrant\n    {\n        uint256 ethValue = 0;\n\n        if (_assetIds[0] != ETHER_ADDR) {\n            Utils.transferTokensIn(msg.sender, _assetIds[0], _dataValues[0], _dataValues[0]);\n            Utils.approveTokenTransfer(\n                _assetIds[0],\n                address(kyberNetworkProxy),\n                _dataValues[0]\n            );\n        } else {\n            ethValue = _dataValues[0];\n        }\n\n        address srcAssetId = _assetIds[0] == ETHER_ADDR ? KYBER_ETHER_ADDR : _assetIds[0];\n        address dstAssetId = _assetIds[1] == ETHER_ADDR ? KYBER_ETHER_ADDR : _assetIds[1];\n\n        // _dataValues[2] bits(24..32): fee sharing walletAddressIndex\n        uint256 walletAddressIndex = (_dataValues[2] & ~(~uint256(0) << 32)) >> 24;\n\n        kyberNetworkProxy.trade.value(ethValue)(\n            srcAssetId,\n            _dataValues[0], // srcAmount\n            dstAssetId, // dest\n            _recipient, // destAddress\n            ~uint256(0), // maxDestAmount\n            uint256(0), // minConversionRate\n            _addresses[walletAddressIndex] // walletId\n        );\n    }","after":"function trade(\n        address[] calldata _assetIds,\n        uint256[] calldata _dataValues,\n        address[] calldata _addresses,\n        address payable _recipient\n    )\n        public\n        payable\n        nonReentrant\n    {\n        uint256 ethValue = 0;\n\n        if (_assetIds[0] != ETHER_ADDR) {\n            Utils.transferTokensIn(msg.sender, _assetIds[0], _dataValues[0], _dataValues[0]);\n            Utils.approveTokenTransfer(\n                _assetIds[0],\n                address(kyberNetworkProxy),\n                _dataValues[0]\n            );\n        } else {\n            ethValue = _dataValues[0];\n        }\n\n        address srcAssetId = _assetIds[0] == ETHER_ADDR ? KYBER_ETHER_ADDR : _assetIds[0];\n        address dstAssetId = _assetIds[1] == ETHER_ADDR ? KYBER_ETHER_ADDR : _assetIds[1];\n\n        // _dataValues[2] bits(24..32): fee sharing walletAddressIndex\n        uint256 walletAddressIndex = (_dataValues[2] & ~(~uint256(0) << 32)) >> 24;\n\n        kyberNetworkProxy.trade.value(ethValue)(\n            srcAssetId,\n            _dataValues[0], // srcAmount\n            dstAssetId, // dest\n            _recipient, // destAddress\n            ~uint256(0), // maxDestAmount\n            uint256(0), // minConversionRate\n            _addresses[walletAddressIndex] // walletId\n        );\n    }","contract":"KyberSwapDapp","time":0}]}