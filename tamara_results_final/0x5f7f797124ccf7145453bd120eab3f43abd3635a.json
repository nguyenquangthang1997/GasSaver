{"time":326,"results":[{"type":"external-function ","before":"function notary(uint256 chainId, uint256 notaryStartBlock, uint256 notaryEndBlock, address[] memory validators, uint32[] memory blocksMined,\n                    address[] memory users, uint64[] memory userGas, uint64 largestTx,\n                    uint8[] memory v, bytes32[] memory r, bytes32[] memory s) public {\n                  \n        ChainInfo storage chain = chains[chainId];\n        require(chain.registered    == true,                            \"Invalid chain data: Non-registered chain\");\n        require(validatorExist(chain, msg.sender) == true,              \"Sender must have vesting balance > 0\");\n        require(chain.totalVesting  > 0,                                \"Current chain total_vesting == 0, there are no active validators\");\n        \n        require(validators.length       > 0,                            \"Invalid statistics data: validators.length == 0\");\n        require(validators.length       == blocksMined.length,          \"Invalid statistics data: validators.length != num of block mined\");\n        if (chain.maxNumOfValidators != 0) {\n            require(validators.length   <= chain.maxNumOfValidators,    \"Invalid statistics data: validators.length > maxNumOfValidators\");\n            require(v.length            <= chain.maxNumOfValidators,    \"Invalid statistics data: signatures.length > maxNumOfValidators\");\n        }\n        \n        if (chain.maxNumOfTransactors != 0) {\n            require(users.length    <= chain.maxNumOfTransactors,   \"Invalid statistics data: users.length > maxNumOfTransactors\");\n        }\n        require(users.length        > 0,                            \"Invalid statistics data: users.length == 0\");\n        require(users.length        == userGas.length,              \"Invalid statistics data: users.length != usersGas.length\");\n        \n        require(v.length            == r.length,                    \"Invalid statistics data: v.length != r.length\");\n        require(v.length            == s.length,                    \"Invalid statistics data: v.length != s.length\");\n        require(notaryStartBlock    >  chain.lastNotary.block,      \"Invalid statistics data: notaryBlock_start <= last known notary block\");\n        require(notaryEndBlock      >  notaryStartBlock,            \"Invalid statistics data: notaryEndBlock <= notaryStartBlock\");\n        require(largestTx           >  0,                           \"Invalid statistics data: Largest tx <= 0\");\n        \n        bytes32 signatureHash = keccak256(abi.encodePacked(notaryEndBlock, validators, blocksMined, users, userGas, largestTx));\n        \n        // Validates notary conditions(involvedVesting && participation) to statistics to be accepted\n        validateNotaryConditions(chain, signatureHash, v, r, s);\n        \n        // Calculates total cost based on user's usage durint current notary window\n        uint256 totalCost = processUsersConsumptions(chain, users, userGas, largestTx);\n        \n        // In case totalCost == 0, something is wrong and there is no need for notary to continue as there is no tokens to be distributed to the validators.\n        // There is probably ongoing coordinated attack based on invalid statistics sent to the notary\n        require(totalCost > 0, \"Invalid statistics data: users totalUsageCost == 0\");\n        \n        // How many block could validator mined since the last notary in case he did sign every possible block \n        uint256 maxBlocksMined = (notaryEndBlock - notaryStartBlock) + 1;\n        \n        // Calculates total involved vesting from provided list of validators and removes all validators that did not mine during last 2 notyary windows\n        uint256 totalInvolvedVesting = processNotaryValidators(chain, validators, blocksMined, maxBlocksMined);\n        \n        // In case totalInvolvedVesting == 0, something is wrong and there is no need for notary to continue as rewards cannot be calculated. It might happen\n        // as edge case when the last validator stopped mining durint current notary window or there is ongoing coordinated attack based on invalid statistics sent to the notary\n        require(totalInvolvedVesting > 0, \"totalInvolvedVesting == 0. Invalid statistics or 0 active validators left in the chain\");\n        \n        // Calculates and process validator's rewards based on their participation rate and vesting balance\n        processValidatorsRewards(chain, totalInvolvedVesting, validators, blocksMined, maxBlocksMined, totalCost);\n        \n        // Updates info when the last notary was processed \n        chain.lastNotary.block = notaryEndBlock;\n        chain.lastNotary.timestamp = now;\n        \n        if (chain.active == false) {\n            chain.active = true;\n        }\n        \n        emit Notary(chainId, notaryEndBlock, maxBlocksMined);\n    }","after":"function notary(uint256 chainId, uint256 notaryStartBlock, uint256 notaryEndBlock, address[] calldata validators, uint32[] calldata blocksMined,\n                    address[] calldata users, uint64[] calldata userGas, uint64 largestTx,\n                    uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) public {\n                  \n        ChainInfo storage chain = chains[chainId];\n        require(chain.registered    == true,                            \"Invalid chain data: Non-registered chain\");\n        require(validatorExist(chain, msg.sender) == true,              \"Sender must have vesting balance > 0\");\n        require(chain.totalVesting  > 0,                                \"Current chain total_vesting == 0, there are no active validators\");\n        \n        require(validators.length       > 0,                            \"Invalid statistics data: validators.length == 0\");\n        require(validators.length       == blocksMined.length,          \"Invalid statistics data: validators.length != num of block mined\");\n        if (chain.maxNumOfValidators != 0) {\n            require(validators.length   <= chain.maxNumOfValidators,    \"Invalid statistics data: validators.length > maxNumOfValidators\");\n            require(v.length            <= chain.maxNumOfValidators,    \"Invalid statistics data: signatures.length > maxNumOfValidators\");\n        }\n        \n        if (chain.maxNumOfTransactors != 0) {\n            require(users.length    <= chain.maxNumOfTransactors,   \"Invalid statistics data: users.length > maxNumOfTransactors\");\n        }\n        require(users.length        > 0,                            \"Invalid statistics data: users.length == 0\");\n        require(users.length        == userGas.length,              \"Invalid statistics data: users.length != usersGas.length\");\n        \n        require(v.length            == r.length,                    \"Invalid statistics data: v.length != r.length\");\n        require(v.length            == s.length,                    \"Invalid statistics data: v.length != s.length\");\n        require(notaryStartBlock    >  chain.lastNotary.block,      \"Invalid statistics data: notaryBlock_start <= last known notary block\");\n        require(notaryEndBlock      >  notaryStartBlock,            \"Invalid statistics data: notaryEndBlock <= notaryStartBlock\");\n        require(largestTx           >  0,                           \"Invalid statistics data: Largest tx <= 0\");\n        \n        bytes32 signatureHash = keccak256(abi.encodePacked(notaryEndBlock, validators, blocksMined, users, userGas, largestTx));\n        \n        // Validates notary conditions(involvedVesting && participation) to statistics to be accepted\n        validateNotaryConditions(chain, signatureHash, v, r, s);\n        \n        // Calculates total cost based on user's usage durint current notary window\n        uint256 totalCost = processUsersConsumptions(chain, users, userGas, largestTx);\n        \n        // In case totalCost == 0, something is wrong and there is no need for notary to continue as there is no tokens to be distributed to the validators.\n        // There is probably ongoing coordinated attack based on invalid statistics sent to the notary\n        require(totalCost > 0, \"Invalid statistics data: users totalUsageCost == 0\");\n        \n        // How many block could validator mined since the last notary in case he did sign every possible block \n        uint256 maxBlocksMined = (notaryEndBlock - notaryStartBlock) + 1;\n        \n        // Calculates total involved vesting from provided list of validators and removes all validators that did not mine during last 2 notyary windows\n        uint256 totalInvolvedVesting = processNotaryValidators(chain, validators, blocksMined, maxBlocksMined);\n        \n        // In case totalInvolvedVesting == 0, something is wrong and there is no need for notary to continue as rewards cannot be calculated. It might happen\n        // as edge case when the last validator stopped mining durint current notary window or there is ongoing coordinated attack based on invalid statistics sent to the notary\n        require(totalInvolvedVesting > 0, \"totalInvolvedVesting == 0. Invalid statistics or 0 active validators left in the chain\");\n        \n        // Calculates and process validator's rewards based on their participation rate and vesting balance\n        processValidatorsRewards(chain, totalInvolvedVesting, validators, blocksMined, maxBlocksMined, totalCost);\n        \n        // Updates info when the last notary was processed \n        chain.lastNotary.block = notaryEndBlock;\n        chain.lastNotary.timestamp = now;\n        \n        if (chain.active == false) {\n            chain.active = true;\n        }\n        \n        emit Notary(chainId, notaryEndBlock, maxBlocksMined);\n    }","contract":"LitionRegistry","time":0}]}