{"time":69,"results":[{"type":"external-function ","before":"\tfunction writeLEXScriptWrapper(string memory templateTerms, uint256 LEXRate, address LEXAddress) public onlyScribe {\n\t        require(isReputable(msg.sender));\n\t        address lexScribe = msg.sender;\n\t        uint256 lexID = LSW.add(1); // **reflects new lexScript value for tracking legal wrappers**\n\t        LSW = LSW.add(1); // counts new entry to LSW \n\t    \n\t        lexScript[lexID] = lexScriptWrapper( // populate lexScript data for reference in rddr\n                \tlexScribe,\n                \tLEXAddress,\n                \ttemplateTerms,\n                \tlexID,\n                \tLEXRate);\n                \t\n            emit Enscribed(lexID, lexScribe); \n\t    ","after":"\tfunction writeLEXScriptWrapper(string calldata templateTerms, uint256 LEXRate, address LEXAddress) public onlyScribe {\n\t        require(isReputable(msg.sender));\n\t        address lexScribe = msg.sender;\n\t        uint256 lexID = LSW.add(1); // **reflects new lexScript value for tracking legal wrappers**\n\t        LSW = LSW.add(1); // counts new entry to LSW \n\t    \n\t        lexScript[lexID] = lexScriptWrapper( // populate lexScript data for reference in rddr\n                \tlexScribe,\n                \tLEXAddress,\n                \ttemplateTerms,\n                \tlexID,\n                \tLEXRate);\n                \t\n            emit Enscribed(lexID, lexScribe); \n\t    ","contract":"lexDAORegistry","time":0},{"type":"external-function ","before":"\tfunction editLEXScriptWrapper(uint256 lexID, string memory newTemplateTerms, address newLEXAddress) public {\n\t        lexScriptWrapper storage lS = lexScript[lexID];\n\t        require(address(msg.sender) == lS.lexScribe); // program safety check / authorization\n\t    \n\t        lexScript[lexID] = lexScriptWrapper( // populate updated lexScript data for reference in rddr\n                \tmsg.sender,\n                \tnewLEXAddress,\n                \tnewTemplateTerms,\n                \tlexID,\n                \tlS.lexRate);\n            emit Enscribed(lexID, msg.sender);\n    \t","after":"\tfunction editLEXScriptWrapper(uint256 lexID, string calldata newTemplateTerms, address newLEXAddress) public {\n\t        lexScriptWrapper storage lS = lexScript[lexID];\n\t        require(address(msg.sender) == lS.lexScribe); // program safety check / authorization\n\t    \n\t        lexScript[lexID] = lexScriptWrapper( // populate updated lexScript data for reference in rddr\n                \tmsg.sender,\n                \tnewLEXAddress,\n                \tnewTemplateTerms,\n                \tlexID,\n                \tlS.lexRate);\n            emit Enscribed(lexID, msg.sender);\n    \t","contract":"lexDAORegistry","time":0},{"type":"external-function ","before":"\tfunction registerDDR(\n    \t    address client,\n    \t    address provider,\n    \t    IERC20 ddrToken,\n    \t    string memory deliverable,\n    \t    string memory governingLawForum,\n    \t    uint256 retainerDuration,\n    \t    uint256 deliverableRate,\n    \t    uint256 payCap,\n    \t    uint256 lexID) public {\n            require(deliverableRate <= payCap, \"registerDDR: deliverableRate cannot exceed payCap\"); // **program safety check / economics**\n            uint256 ddrNumber = RDDR.add(1); // **reflects new rddr value for tracking payments**\n            uint256 paid = 0; // **initial zero value for rddr** \n            uint256 timeStamp = now; // **block.timestamp of rddr**\n            uint256 retainerTermination = timeStamp + retainerDuration; // **rddr termination date in UnixTime**\n    \n        \tRDDR = RDDR.add(1); // counts new entry to RDDR\n    \n        \trddr[ddrNumber] = DDR( // populate rddr data \n                \tclient,\n                \tprovider,\n                \tddrToken,\n                \tdeliverable,\n                \tgoverningLawForum,\n                \tddrNumber,\n                \ttimeStamp,\n                \tretainerDuration,\n                \tretainerTermination,\n                \tdeliverableRate,\n                \tpaid,\n                \tpayCap,\n                \tlexID);\n        \t \n            emit Registered(ddrNumber, lexID, client, provider); \n        ","after":"\tfunction registerDDR(\n    \t    address client,\n    \t    address provider,\n    \t    IERC20 ddrToken,\n    \t    string calldata deliverable,\n    \t    string calldata governingLawForum,\n    \t    uint256 retainerDuration,\n    \t    uint256 deliverableRate,\n    \t    uint256 payCap,\n    \t    uint256 lexID) public {\n            require(deliverableRate <= payCap, \"registerDDR: deliverableRate cannot exceed payCap\"); // **program safety check / economics**\n            uint256 ddrNumber = RDDR.add(1); // **reflects new rddr value for tracking payments**\n            uint256 paid = 0; // **initial zero value for rddr** \n            uint256 timeStamp = now; // **block.timestamp of rddr**\n            uint256 retainerTermination = timeStamp + retainerDuration; // **rddr termination date in UnixTime**\n    \n        \tRDDR = RDDR.add(1); // counts new entry to RDDR\n    \n        \trddr[ddrNumber] = DDR( // populate rddr data \n                \tclient,\n                \tprovider,\n                \tddrToken,\n                \tdeliverable,\n                \tgoverningLawForum,\n                \tddrNumber,\n                \ttimeStamp,\n                \tretainerDuration,\n                \tretainerTermination,\n                \tdeliverableRate,\n                \tpaid,\n                \tpayCap,\n                \tlexID);\n        \t \n            emit Registered(ddrNumber, lexID, client, provider); \n        ","contract":"lexDAORegistry","time":0},{"type":"constant-restrict-modification  ","before":"address payable public lexAgonDAO = 0xBBE222Ef97076b786f661246232E41BE0DFf6cc4;","after":"address payable public constant lexAgonDAO = 0xBBE222Ef97076b786f661246232E41BE0DFf6cc4;","contract":"lexDAORegistry","time":0}]}