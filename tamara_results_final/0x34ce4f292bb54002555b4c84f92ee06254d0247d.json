{"time":1085,"results":[{"type":"external-function ","before":"function updateReturns(int[5] memory assetRetNew, int[5] memory assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","after":"function updateReturns(int[5] calldata assetRetNew, int[5] calldata assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","contract":"AssetSwap","time":0},{"type":"external-function ","before":"function updateReturns(int[5] memory assetRetNew, int[5] memory assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","after":"function updateReturns(int[5] calldata assetRetNew, int[5] calldata assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","contract":"AssetSwap","time":0},{"type":"external-function ","before":"function updateReturns(int[5] memory assetRetNew, int[5] memory assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","after":"function updateReturns(int[5] calldata assetRetNew, int[5] calldata assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","contract":"AssetSwap","time":0},{"type":"struct-data-arrangement ","before":"\naddress taker\nuint takerMargin\nuint requiredMargin\nuint16 index\nint16 fundingRate\nuint8 closeFee\nuint8 subkStatus\nuint8 priceDay\nint8 takerSide","after":"uint takerMargin\nuint requiredMargin\naddress taker\nuint16 index\nint16 fundingRate\nuint8 closeFee\nuint8 subkStatus\nuint8 priceDay\nint8 takerSide\n","contract":"Book","time":2},{"type":"external-function ","before":"function settleExpiring(int[5] memory assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleExpiring(int[5] calldata assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleNew(int[5] memory assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleNew(int[5] calldata assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleExpiring(int[5] memory assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleExpiring(int[5] calldata assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleNew(int[5] memory assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleNew(int[5] calldata assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleExpiring(int[5] memory assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleExpiring(int[5] calldata assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleNew(int[5] memory assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleNew(int[5] calldata assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function updateReturns(int[5] memory assetRetNew, int[5] memory assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","after":"function updateReturns(int[5] calldata assetRetNew, int[5] calldata assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","contract":"AssetSwap","time":0},{"type":"external-function ","before":"function updateReturns(int[5] memory assetRetNew, int[5] memory assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","after":"function updateReturns(int[5] calldata assetRetNew, int[5] calldata assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","contract":"AssetSwap","time":0},{"type":"external-function ","before":"function updateReturns(int[5] memory assetRetNew, int[5] memory assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","after":"function updateReturns(int[5] calldata assetRetNew, int[5] calldata assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","contract":"AssetSwap","time":0},{"type":"struct-data-arrangement ","before":"\naddress taker\nuint takerMargin\nuint requiredMargin\nuint16 index\nint16 fundingRate\nuint8 closeFee\nuint8 subkStatus\nuint8 priceDay\nint8 takerSide","after":"uint takerMargin\nuint requiredMargin\naddress taker\nuint16 index\nint16 fundingRate\nuint8 closeFee\nuint8 subkStatus\nuint8 priceDay\nint8 takerSide\n","contract":"Book","time":0},{"type":"external-function ","before":"function settleExpiring(int[5] memory assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleExpiring(int[5] calldata assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleNew(int[5] memory assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleNew(int[5] calldata assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleExpiring(int[5] memory assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleExpiring(int[5] calldata assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleNew(int[5] memory assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleNew(int[5] calldata assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleExpiring(int[5] memory assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleExpiring(int[5] calldata assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleNew(int[5] memory assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleNew(int[5] calldata assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function updateReturns(int[5] memory assetRetNew, int[5] memory assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","after":"function updateReturns(int[5] calldata assetRetNew, int[5] calldata assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","contract":"AssetSwap","time":0},{"type":"external-function ","before":"function updateReturns(int[5] memory assetRetNew, int[5] memory assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","after":"function updateReturns(int[5] calldata assetRetNew, int[5] calldata assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","contract":"AssetSwap","time":0},{"type":"external-function ","before":"function updateReturns(int[5] memory assetRetNew, int[5] memory assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","after":"function updateReturns(int[5] calldata assetRetNew, int[5] calldata assetRetExp)\r\n            public\r\n        {\r\n        require(msg.sender == address(oracle));\r\n        assetReturns[0] = assetRetNew;\r\n        assetReturns[1] = assetRetExp;\r\n        lastOracleSettleTime = now;\r\n    }","contract":"AssetSwap","time":0},{"type":"struct-data-arrangement ","before":"\naddress taker\nuint takerMargin\nuint requiredMargin\nuint16 index\nint16 fundingRate\nuint8 closeFee\nuint8 subkStatus\nuint8 priceDay\nint8 takerSide","after":"uint takerMargin\nuint requiredMargin\naddress taker\nuint16 index\nint16 fundingRate\nuint8 closeFee\nuint8 subkStatus\nuint8 priceDay\nint8 takerSide\n","contract":"Book","time":1},{"type":"external-function ","before":"function settleExpiring(int[5] memory assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleExpiring(int[5] calldata assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleNew(int[5] memory assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleNew(int[5] calldata assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleExpiring(int[5] memory assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleExpiring(int[5] calldata assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleNew(int[5] memory assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleNew(int[5] calldata assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleExpiring(int[5] memory assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleExpiring(int[5] calldata assetRetExp)\r\n        public\r\n        onlyAdmin\r\n        {\r\n        require(bookStatus != 3 && settleNum < 1e4, \"done with expiry settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        uint loopCap = min(settleNum + 200, tempContracts[1].length);\r\n        for (uint i = settleNum; i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[1][i]];\r\n            takerRetTemp = int(k.takerSide) * assetRetExp[k.priceDay - 1] * int(k.requiredMargin) / 1 ether -\r\n            (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n            lpTemp -= takerRetTemp;\r\n            if (takerRetTemp < 0) {\r\n                k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n            } else {\r\n                k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n            }\r\n            if (k.takerSide == 1)\r\n                margin[2] = subzero(margin[2], k.requiredMargin);\r\n            else\r\n                margin[1] = subzero(margin[1], k.requiredMargin);\r\n            k.subkStatus = 7;\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[1].length)\r\n            settleNum = 1e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0},{"type":"external-function ","before":"function settleNew(int[5] memory assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","after":"function settleNew(int[5] calldata assetRets)\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(settleNum < 3e4, \"done with new settle\");\r\n        int takerRetTemp;\r\n        int lpTemp;\r\n        /// after running the second settlement function, settleRolling, it is set to 2e4\r\n        uint loopCap = min(settleNum - 2e4 + 200, tempContracts[0].length);\r\n        for (uint i = (settleNum - 2e4); i < loopCap; i++) {\r\n            Subcontract storage k = subcontracts[tempContracts[0][i]];\r\n            /// subkStatus set to 'active' which means it can be cancelled\r\n            /// it will also be settled in the settleRolling if not cancelled\r\n            /// using the more efficient settlement that uses just one return, from last to most recent settlement\r\n            k.subkStatus = 1;\r\n            if (k.priceDay != 5) {\r\n                takerRetTemp = int(k.takerSide) * assetRets[k.priceDay] * int(k.requiredMargin) / 1\r\n                ether - (int(k.fundingRate) * int(k.requiredMargin) / 1e4);\r\n                lpTemp = lpTemp - takerRetTemp;\r\n                if (takerRetTemp < 0) {\r\n                    k.takerMargin = subzero(k.takerMargin, uint(-takerRetTemp));\r\n                } else {\r\n                    k.takerMargin += uint(takerRetTemp) * burnFactor / 1 ether;\r\n                }\r\n                if (k.takerMargin < k.requiredMargin) {\r\n                    k.subkStatus = 6;\r\n                    if (k.takerSide == 1)\r\n                        margin[2] = subzero(margin[2], k.requiredMargin);\r\n                    else\r\n                        margin[1] = subzero(margin[1], k.requiredMargin);\r\n                }\r\n                k.priceDay = 5;\r\n            }\r\n        }\r\n        settleNum += 200;\r\n        if (settleNum >= tempContracts[0].length)\r\n            settleNum = 3e4;\r\n        lpSettleDebitAcct += lpTemp;\r\n    }","contract":"Book","time":0}]}