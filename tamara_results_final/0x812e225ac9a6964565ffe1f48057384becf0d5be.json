{"time":330,"results":[{"type":"external-function ","before":"function addProjects(\n        bytes32[10] memory _titles,\n        bytes32[10] memory _ipfsData,\n        uint8[10] memory _ipfsHashFunction,\n        uint8[10] memory _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","after":"function addProjects(\n        bytes32[10] calldata _titles,\n        bytes32[10] calldata _ipfsData,\n        uint8[10] calldata _ipfsHashFunction,\n        uint8[10] calldata _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","after":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function returnFunds(uint256[] memory _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","after":"function returnFunds(uint256[] calldata _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function executeClear(uint256[] memory _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","after":"function executeClear(uint256[] calldata _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function addProjects(\n        bytes32[10] memory _titles,\n        bytes32[10] memory _ipfsData,\n        uint8[10] memory _ipfsHashFunction,\n        uint8[10] memory _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","after":"function addProjects(\n        bytes32[10] calldata _titles,\n        bytes32[10] calldata _ipfsData,\n        uint8[10] calldata _ipfsHashFunction,\n        uint8[10] calldata _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","after":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function returnFunds(uint256[] memory _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","after":"function returnFunds(uint256[] calldata _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function executeClear(uint256[] memory _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","after":"function executeClear(uint256[] calldata _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function addProjects(\n        bytes32[10] memory _titles,\n        bytes32[10] memory _ipfsData,\n        uint8[10] memory _ipfsHashFunction,\n        uint8[10] memory _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","after":"function addProjects(\n        bytes32[10] calldata _titles,\n        bytes32[10] calldata _ipfsData,\n        uint8[10] calldata _ipfsHashFunction,\n        uint8[10] calldata _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","after":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function returnFunds(uint256[] memory _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","after":"function returnFunds(uint256[] calldata _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function executeClear(uint256[] memory _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","after":"function executeClear(uint256[] calldata _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function addProjects(\n        bytes32[10] memory _titles,\n        bytes32[10] memory _ipfsData,\n        uint8[10] memory _ipfsHashFunction,\n        uint8[10] memory _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","after":"function addProjects(\n        bytes32[10] calldata _titles,\n        bytes32[10] calldata _ipfsData,\n        uint8[10] calldata _ipfsHashFunction,\n        uint8[10] calldata _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","after":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function returnFunds(uint256[] memory _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","after":"function returnFunds(uint256[] calldata _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function executeClear(uint256[] memory _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","after":"function executeClear(uint256[] calldata _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function addProjects(\n        bytes32[10] memory _titles,\n        bytes32[10] memory _ipfsData,\n        uint8[10] memory _ipfsHashFunction,\n        uint8[10] memory _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","after":"function addProjects(\n        bytes32[10] calldata _titles,\n        bytes32[10] calldata _ipfsData,\n        uint8[10] calldata _ipfsHashFunction,\n        uint8[10] calldata _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","after":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function returnFunds(uint256[] memory _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","after":"function returnFunds(uint256[] calldata _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function executeClear(uint256[] memory _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","after":"function executeClear(uint256[] calldata _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function addProjects(\n        bytes32[10] memory _titles,\n        bytes32[10] memory _ipfsData,\n        uint8[10] memory _ipfsHashFunction,\n        uint8[10] memory _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","after":"function addProjects(\n        bytes32[10] calldata _titles,\n        bytes32[10] calldata _ipfsData,\n        uint8[10] calldata _ipfsHashFunction,\n        uint8[10] calldata _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","after":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function returnFunds(uint256[] memory _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","after":"function returnFunds(uint256[] calldata _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function executeClear(uint256[] memory _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","after":"function executeClear(uint256[] calldata _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function addProjects(\n        bytes32[10] memory _titles,\n        bytes32[10] memory _ipfsData,\n        uint8[10] memory _ipfsHashFunction,\n        uint8[10] memory _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","after":"function addProjects(\n        bytes32[10] calldata _titles,\n        bytes32[10] calldata _ipfsData,\n        uint8[10] calldata _ipfsHashFunction,\n        uint8[10] calldata _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","after":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function returnFunds(uint256[] memory _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","after":"function returnFunds(uint256[] calldata _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function executeClear(uint256[] memory _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","after":"function executeClear(uint256[] calldata _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function addProjects(\n        bytes32[10] memory _titles,\n        bytes32[10] memory _ipfsData,\n        uint8[10] memory _ipfsHashFunction,\n        uint8[10] memory _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","after":"function addProjects(\n        bytes32[10] calldata _titles,\n        bytes32[10] calldata _ipfsData,\n        uint8[10] calldata _ipfsHashFunction,\n        uint8[10] calldata _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","contract":"ProjectVoting","time":1},{"type":"external-function ","before":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","after":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function returnFunds(uint256[] memory _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","after":"function returnFunds(uint256[] calldata _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function executeClear(uint256[] memory _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","after":"function executeClear(uint256[] calldata _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function addProjects(\n        bytes32[10] memory _titles,\n        bytes32[10] memory _ipfsData,\n        uint8[10] memory _ipfsHashFunction,\n        uint8[10] memory _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","after":"function addProjects(\n        bytes32[10] calldata _titles,\n        bytes32[10] calldata _ipfsData,\n        uint8[10] calldata _ipfsHashFunction,\n        uint8[10] calldata _ipfsSize\n    )\n    public\n    onlyOwner\n    onlyAddProjectsState\n    {\n        uint256 loopMax = noOfProjects.sub(noOfProjectsAdded);\n\n        if (loopMax > 10) loopMax = 10;\n\n        for (uint256 i = 0; i < loopMax; i++) {  //cannot overflow, because addition using SafeMath\n            noOfProjectsAdded = noOfProjectsAdded.add(1);\n            Ipfs memory ipfs = Ipfs(_ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i]);\n            Project memory project;\n            project.title = _titles[i];\n            project.id = noOfProjectsAdded;\n\n            emit ProjectAdded(_titles[i], _ipfsData[i], _ipfsHashFunction[i], _ipfsSize[i], noOfProjectsAdded, round);\n\n            projects[noOfProjectsAdded] = project;\n            ipfses[noOfProjectsAdded] = ipfs;\n        }\n\n        if (noOfProjectsAdded == noOfProjects) {\n            noOfProjectsAdded = 0;\n            _startVoteState(now.add(votingTime)); // solhint-disable-line not-rely-on-time\n        }\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","after":"function tokensReceived(\n        address operator, // solhint-disable no-unused-vars\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    )  // solhint-enable no-unused-vars\n    public\n    onlyCall\n    {\n        require(userData[0] <= bytes1(uint8(noOfProjects)) && userData[0] > 0x00, \"ProjectVoting: Wrong Id\");\n        _vote(from, amount,  uint8(userData[0]));\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function returnFunds(uint256[] memory _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","after":"function returnFunds(uint256[] calldata _positions)\n    public\n    onlyRefundState\n    onlyInRefundTime\n    {\n        uint256 size;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (_positions[pos] < totalVoters && powerOf[voters[_positions[pos]]] != 0) size = size.add(1);\n        }\n\n        address[] memory addresses = new address[](size);\n        uint256[] memory amounts = new uint256[](size);\n\n        uint256 counter;\n\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            if (powerOf[voters[_positions[pos]]] != 0 && _positions[pos] < totalVoters) {\n                addresses[counter] = voters[_positions[pos]];\n                amounts[counter] = powerOf[addresses[counter]];\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addresses[counter]] = 0;\n                counter = counter.add(1);\n            }\n        }\n        callObj.multiPartySend(addresses, amounts, \"\");\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0},{"type":"external-function ","before":"function executeClear(uint256[] memory _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","after":"function executeClear(uint256[] calldata _positions) public onlyClearState {\n        for (uint256 pos = 0; pos < _positions.length; pos++) {\n            address addr = voters[_positions[pos]];\n            if (powerOf[addr] != 0) {\n                totalToRefund = totalToRefund.sub(1);\n                powerOf[addr] = 0;\n            }\n        }\n        _startAddProjectsState();\n    }","contract":"ProjectVoting","time":0}]}