{"time":413,"results":[{"type":"struct-data-arrangement ","before":"\nbool usingDepositContract\nuint positionId\nuint expirationDays\nuint depositMarketId\nuint depositAmount\naddress trader","after":"uint positionId\nuint expirationDays\nuint depositMarketId\nuint depositAmount\naddress trader\nbool usingDepositContract\n","contract":"Order","time":0},{"type":"external-function ","before":"function callFunction(\n    address sender,\n    DydxPosition.Info memory accountInfo,\n    bytes memory data\n  ) public noEntry {\n    require(msg.sender == address(DYDX_PROTOCOL), \"INVALID_CALLER: IDyDxCallee caller must be dYdX protocol\");\n    (bool isTypeSafe, bytes memory ringData) = abi.decode(data, (bool, bytes));\n    if(isTypeSafe) {\n      revert(\"Submitting rings with type safety is not enabled!\");\n//      LOOPRING_PROTOCOL.submitRings(abi.decode(ringData, (Data.SubmitRingsRequest)));\n    } else {\n      LOOPRING_PROTOCOL.submitRings(ringData);\n    }\n  }","after":"function callFunction(\n    address sender,\n    DydxPosition.Info calldata accountInfo,\n    bytes calldata data\n  ) public noEntry {\n    require(msg.sender == address(DYDX_PROTOCOL), \"INVALID_CALLER: IDyDxCallee caller must be dYdX protocol\");\n    (bool isTypeSafe, bytes memory ringData) = abi.decode(data, (bool, bytes));\n    if(isTypeSafe) {\n      revert(\"Submitting rings with type safety is not enabled!\");\n//      LOOPRING_PROTOCOL.submitRings(abi.decode(ringData, (Data.SubmitRingsRequest)));\n    } else {\n      LOOPRING_PROTOCOL.submitRings(ringData);\n    }\n  }","contract":"DolomiteMarginProtocol","time":0},{"type":"external-function ","before":"function brokerRequestAllowance(LoopringTypes.BrokerApprovalRequest memory request) public noEntry returns (bool) {\n    require(msg.sender == address(TRADE_DELEGATE), \"INVALID_CALLER: Caller of broker impl must be Loopring Delegate\");\n\n    for (uint i = 0; i < request.orders.length; i++) {\n      LoopringTypes.BrokerOrder memory order = request.orders[i];\n\n      require(order.tokenRecipient == address(this), \"INVALID_RECIPIENT: Token recipient must be set to margin protocol\");\n      require(order.requestedFeeAmount == 0, \"INVALID_ORDER_FEE: FeeToken must be in tokenB of Loopring order\");\n\n      runtimeIncomingAmount[order.orderHash][request.tokenB] = order.fillAmountB;\n    }\n\n    return false;\n  }","after":"function brokerRequestAllowance(LoopringTypes.BrokerApprovalRequest calldata request) public noEntry returns (bool) {\n    require(msg.sender == address(TRADE_DELEGATE), \"INVALID_CALLER: Caller of broker impl must be Loopring Delegate\");\n\n    for (uint i = 0; i < request.orders.length; i++) {\n      LoopringTypes.BrokerOrder memory order = request.orders[i];\n\n      require(order.tokenRecipient == address(this), \"INVALID_RECIPIENT: Token recipient must be set to margin protocol\");\n      require(order.requestedFeeAmount == 0, \"INVALID_ORDER_FEE: FeeToken must be in tokenB of Loopring order\");\n\n      runtimeIncomingAmount[order.orderHash][request.tokenB] = order.fillAmountB;\n    }\n\n    return false;\n  }","contract":"DolomiteMarginProtocol","time":0},{"type":"external-function ","before":"function exchange(\n    address tradeOriginator,\n    address receiver,\n    address makerToken,\n    address takerToken,\n    uint256 requestedFillAmount,\n    bytes memory orderData\n  ) public noEntry returns (uint256) {\n    require(msg.sender == address(DYDX_PROTOCOL), \"INVALID_EXCHANGE_CALLER\");\n    bytes32 orderHash = abi.decode(orderData, (bytes32));\n    return runtimeIncomingAmount[orderHash][makerToken];\n  }","after":"function exchange(\n    address tradeOriginator,\n    address receiver,\n    address makerToken,\n    address takerToken,\n    uint256 requestedFillAmount,\n    bytes calldata orderData\n  ) public noEntry returns (uint256) {\n    require(msg.sender == address(DYDX_PROTOCOL), \"INVALID_EXCHANGE_CALLER\");\n    bytes32 orderHash = abi.decode(orderData, (bytes32));\n    return runtimeIncomingAmount[orderHash][makerToken];\n  }","contract":"DolomiteMarginProtocol","time":0}]}