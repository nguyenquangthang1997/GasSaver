{"time":211,"results":[{"type":"state-data-arrangement ","before":"\nbytes32 constant private FILE = \"StopLimitOrders\";\nbytes2 constant private EIP191_HEADER = 0x1901;\nstring constant private EIP712_DOMAIN_NAME = \"StopLimitOrders\";\nstring constant private EIP712_DOMAIN_VERSION = \"1.1\";\nbytes32 constant private EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"EIP712Domain(\",\n        \"string name,\",\n        \"string version,\",\n        \"uint256 chainId,\",\n        \"address verifyingContract\",\n        \")\"\n    ));\nbytes32 constant private EIP712_ORDER_STRUCT_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"StopLimitOrder(\",\n        \"uint256 makerMarket,\",\n        \"uint256 takerMarket,\",\n        \"uint256 makerAmount,\",\n        \"uint256 takerAmount,\",\n        \"address makerAccountOwner,\",\n        \"uint256 makerAccountNumber,\",\n        \"address takerAccountOwner,\",\n        \"uint256 takerAccountNumber,\",\n        \"uint256 triggerPrice,\",\n        \"bool decreaseOnly,\",\n        \"uint256 expiration,\",\n        \"uint256 salt\",\n        \")\"\n    ));\nuint256 constant private NUM_ORDER_BYTES = 384;\nuint256 constant private NUM_SIGNATURE_BYTES = 66;\nuint256 constant private NUM_CALLFUNCTIONDATA_BYTES = 32 + NUM_ORDER_BYTES;\nuint256 PRICE_BASE = 10 ** 18;\nbytes32 public EIP712_DOMAIN_HASH;\nbool public g_isOperational;\nmapping (bytes32 => uint256) public g_makerFilledAmount;\nmapping (bytes32 => OrderStatus) public g_status;","after":"bytes32 constant private FILE = \"StopLimitOrders\";\nstring constant private EIP712_DOMAIN_NAME = \"StopLimitOrders\";\nstring constant private EIP712_DOMAIN_VERSION = \"1.1\";\nbytes32 constant private EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"EIP712Domain(\",\n        \"string name,\",\n        \"string version,\",\n        \"uint256 chainId,\",\n        \"address verifyingContract\",\n        \")\"\n    ));\nbytes32 constant private EIP712_ORDER_STRUCT_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"StopLimitOrder(\",\n        \"uint256 makerMarket,\",\n        \"uint256 takerMarket,\",\n        \"uint256 makerAmount,\",\n        \"uint256 takerAmount,\",\n        \"address makerAccountOwner,\",\n        \"uint256 makerAccountNumber,\",\n        \"address takerAccountOwner,\",\n        \"uint256 takerAccountNumber,\",\n        \"uint256 triggerPrice,\",\n        \"bool decreaseOnly,\",\n        \"uint256 expiration,\",\n        \"uint256 salt\",\n        \")\"\n    ));\nuint256 constant private NUM_ORDER_BYTES = 384;\nuint256 constant private NUM_SIGNATURE_BYTES = 66;\nuint256 constant private NUM_CALLFUNCTIONDATA_BYTES = 32 + NUM_ORDER_BYTES;\nuint256 PRICE_BASE = 10 ** 18;\nbytes32 public EIP712_DOMAIN_HASH;\nmapping (bytes32 => uint256) public g_makerFilledAmount;\nmapping (bytes32 => OrderStatus) public g_status;\nbytes2 constant private EIP191_HEADER = 0x1901;\nbool public g_isOperational;\n","contract":"StopLimitOrders","time":0},{"type":"struct-data-arrangement ","before":"\nuint256 makerMarket\nuint256 takerMarket\nuint256 makerAmount\nuint256 takerAmount\naddress makerAccountOwner\nuint256 makerAccountNumber\naddress takerAccountOwner\nuint256 takerAccountNumber\nuint256 triggerPrice\nbool decreaseOnly\nuint256 expiration\nuint256 salt","after":"uint256 makerMarket\nuint256 takerMarket\nuint256 makerAmount\nuint256 takerAmount\nuint256 makerAccountNumber\nuint256 takerAccountNumber\nuint256 triggerPrice\nuint256 expiration\nuint256 salt\naddress makerAccountOwner\naddress takerAccountOwner\nbool decreaseOnly\n","contract":"StopLimitOrders","time":0},{"type":"external-function ","before":"function cancelOrder(\n        Order memory order\n    )\n        public\n    {\n        cancelOrderInternal(msg.sender, order);\n    }","after":"function cancelOrder(\n        Order calldata order\n    )\n        public\n    {\n        cancelOrderInternal(msg.sender, order);\n    }","contract":"StopLimitOrders","time":0},{"type":"external-function ","before":"function approveOrder(\n        Order memory order\n    )\n        public\n    {\n        approveOrderInternal(msg.sender, order);\n    }","after":"function approveOrder(\n        Order calldata order\n    )\n        public\n    {\n        approveOrderInternal(msg.sender, order);\n    }","contract":"StopLimitOrders","time":0},{"type":"external-function ","before":"function getTradeCost(\n        uint256 inputMarketId,\n        uint256 outputMarketId,\n        Account.Info memory makerAccount,\n        Account.Info memory takerAccount,\n        Types.Par memory oldInputPar,\n        Types.Par memory newInputPar,\n        Types.Wei memory inputWei,\n        bytes memory data\n    )\n        public\n        onlySolo(msg.sender)\n        returns (Types.AssetAmount memory)\n    {\n        Require.that(\n            g_isOperational,\n            FILE,\n            \"Contract is not operational\"\n        );\n\n        OrderInfo memory orderInfo = getOrderAndValidateSignature(data);\n\n        verifyOrderAndAccountsAndMarkets(\n            orderInfo,\n            makerAccount,\n            takerAccount,\n            inputMarketId,\n            outputMarketId,\n            inputWei\n        );\n\n        Types.AssetAmount memory assetAmount = getOutputAssetAmount(\n            inputMarketId,\n            outputMarketId,\n            inputWei,\n            orderInfo\n        );\n\n        if (orderInfo.order.decreaseOnly) {\n            verifyDecreaseOnly(\n                oldInputPar,\n                newInputPar,\n                assetAmount,\n                makerAccount,\n                outputMarketId\n            );\n        }\n\n        return assetAmount;\n    }","after":"function getTradeCost(\n        uint256 inputMarketId,\n        uint256 outputMarketId,\n        Account.Info calldata makerAccount,\n        Account.Info calldata takerAccount,\n        Types.Par calldata oldInputPar,\n        Types.Par calldata newInputPar,\n        Types.Wei calldata inputWei,\n        bytes calldata data\n    )\n        public\n        onlySolo(msg.sender)\n        returns (Types.AssetAmount memory)\n    {\n        Require.that(\n            g_isOperational,\n            FILE,\n            \"Contract is not operational\"\n        );\n\n        OrderInfo memory orderInfo = getOrderAndValidateSignature(data);\n\n        verifyOrderAndAccountsAndMarkets(\n            orderInfo,\n            makerAccount,\n            takerAccount,\n            inputMarketId,\n            outputMarketId,\n            inputWei\n        );\n\n        Types.AssetAmount memory assetAmount = getOutputAssetAmount(\n            inputMarketId,\n            outputMarketId,\n            inputWei,\n            orderInfo\n        );\n\n        if (orderInfo.order.decreaseOnly) {\n            verifyDecreaseOnly(\n                oldInputPar,\n                newInputPar,\n                assetAmount,\n                makerAccount,\n                outputMarketId\n            );\n        }\n\n        return assetAmount;\n    }","contract":"StopLimitOrders","time":0},{"type":"external-function ","before":"function callFunction(\n        address /* sender */,\n        Account.Info memory accountInfo,\n        bytes memory data\n    )\n        public\n        onlySolo(msg.sender)\n    {\n        Require.that(\n            data.length == NUM_CALLFUNCTIONDATA_BYTES,\n            FILE,\n            \"Cannot parse CallFunctionData\"\n        );\n\n        CallFunctionData memory cfd = abi.decode(data, (CallFunctionData));\n\n        if (cfd.callType == CallFunctionType.Approve) {\n            approveOrderInternal(accountInfo.owner, cfd.order);\n        } else {\n            assert(cfd.callType == CallFunctionType.Cancel);\n            cancelOrderInternal(accountInfo.owner, cfd.order);\n        }\n    }","after":"function callFunction(\n        address /* sender */,\n        Account.Info calldata accountInfo,\n        bytes calldata data\n    )\n        public\n        onlySolo(msg.sender)\n    {\n        Require.that(\n            data.length == NUM_CALLFUNCTIONDATA_BYTES,\n            FILE,\n            \"Cannot parse CallFunctionData\"\n        );\n\n        CallFunctionData memory cfd = abi.decode(data, (CallFunctionData));\n\n        if (cfd.callType == CallFunctionType.Approve) {\n            approveOrderInternal(accountInfo.owner, cfd.order);\n        } else {\n            assert(cfd.callType == CallFunctionType.Cancel);\n            cancelOrderInternal(accountInfo.owner, cfd.order);\n        }\n    }","contract":"StopLimitOrders","time":0},{"type":"constant-restrict-modification  ","before":"uint256 PRICE_BASE = 10 ** 18;","after":"uint256 constant PRICE_BASE = 10 ** 18;","contract":"StopLimitOrders","time":0}]}