{"time":375,"results":[{"type":"external-function ","before":"sent or received.\n    function trade(int[] memory outcomeTokenAmounts, int collateralLimit)\n        public\n        atStage(Stage.Running)\n        onlyWhitelisted\n        returns (int netCost)\n    {\n        require(outcomeTokenAmounts.length == atomicOutcomeSlotCount);\n\n        // Calculate net cost for executing trade\n        int outcomeTokenNetCost = calcNetCost(outcomeTokenAmounts);\n        int fees;\n        if(outcomeTokenNetCost < 0)\n            fees = int(calcMarketFee(uint(-outcomeTokenNetCost)));\n        else\n            fees = int(calcMarketFee(uint(outcomeTokenNetCost)));\n\n        require(fees >= 0);\n        netCost = outcomeTokenNetCost.add(fees);\n\n        require(\n            (collateralLimit != 0 && netCost <= collateralLimit) ||\n            collateralLimit == 0\n        );\n\n        if(outcomeTokenNetCost > 0) {\n            require(\n                collateralToken.transferFrom(msg.sender, address(this), uint(netCost)) &&\n                collateralToken.approve(address(pmSystem), uint(outcomeTokenNetCost))\n            );\n\n            splitPositionThroughAllConditions(uint(outcomeTokenNetCost));\n        }\n\n        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {\n            if(outcomeTokenAmounts[i] != 0) {\n                uint positionId = generateAtomicPositionId(i);\n                if(outcomeTokenAmounts[i] < 0) {\n                    pmSystem.safeTransferFrom(msg.sender, address(this), positionId, uint(-outcomeTokenAmounts[i]), \"\");\n                } else {\n                    pmSystem.safeTransferFrom(address(this), msg.sender, positionId, uint(outcomeTokenAmounts[i]), \"\");\n                }\n\n            }\n        }\n\n        if(outcomeTokenNetCost < 0) {\n            // This is safe since\n            // 0x8000000000000000000000000000000000000000000000000000000000000000 ==\n            // uint(-int(-0x8000000000000000000000000000000000000000000000000000000000000000))\n            mergePositionsThroughAllConditions(uint(-outcomeTokenNetCost));\n            if(netCost < 0) {\n                require(collateralToken.transfer(msg.sender, uint(-netCost)));\n            }\n        }\n\n        emit AMMOutcomeTokenTrade(msg.sender, outcomeTokenAmounts, outcomeTokenNetCo","after":"sent or received.\n    function trade(int[] calldata outcomeTokenAmounts, int collateralLimit)\n        public\n        atStage(Stage.Running)\n        onlyWhitelisted\n        returns (int netCost)\n    {\n        require(outcomeTokenAmounts.length == atomicOutcomeSlotCount);\n\n        // Calculate net cost for executing trade\n        int outcomeTokenNetCost = calcNetCost(outcomeTokenAmounts);\n        int fees;\n        if(outcomeTokenNetCost < 0)\n            fees = int(calcMarketFee(uint(-outcomeTokenNetCost)));\n        else\n            fees = int(calcMarketFee(uint(outcomeTokenNetCost)));\n\n        require(fees >= 0);\n        netCost = outcomeTokenNetCost.add(fees);\n\n        require(\n            (collateralLimit != 0 && netCost <= collateralLimit) ||\n            collateralLimit == 0\n        );\n\n        if(outcomeTokenNetCost > 0) {\n            require(\n                collateralToken.transferFrom(msg.sender, address(this), uint(netCost)) &&\n                collateralToken.approve(address(pmSystem), uint(outcomeTokenNetCost))\n            );\n\n            splitPositionThroughAllConditions(uint(outcomeTokenNetCost));\n        }\n\n        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {\n            if(outcomeTokenAmounts[i] != 0) {\n                uint positionId = generateAtomicPositionId(i);\n                if(outcomeTokenAmounts[i] < 0) {\n                    pmSystem.safeTransferFrom(msg.sender, address(this), positionId, uint(-outcomeTokenAmounts[i]), \"\");\n                } else {\n                    pmSystem.safeTransferFrom(address(this), msg.sender, positionId, uint(outcomeTokenAmounts[i]), \"\");\n                }\n\n            }\n        }\n\n        if(outcomeTokenNetCost < 0) {\n            // This is safe since\n            // 0x8000000000000000000000000000000000000000000000000000000000000000 ==\n            // uint(-int(-0x8000000000000000000000000000000000000000000000000000000000000000))\n            mergePositionsThroughAllConditions(uint(-outcomeTokenNetCost));\n            if(netCost < 0) {\n                require(collateralToken.transfer(msg.sender, uint(-netCost)));\n            }\n        }\n\n        emit AMMOutcomeTokenTrade(msg.sender, outcomeTokenAmounts, outcomeTokenNetCo","contract":"LMSRMarketMaker","time":0}]}