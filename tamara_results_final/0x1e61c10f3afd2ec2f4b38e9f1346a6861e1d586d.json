{"time":92,"results":[{"type":"external-function ","before":"function defineProxyCode(bytes memory _code)\n    public onlyCoreOperator returns (bool)\n  {\n    return defineProxyCodeInternal(address(core), _code);\n  }","after":"function defineProxyCode(bytes calldata _code)\n    public onlyCoreOperator returns (bool)\n  {\n    return defineProxyCodeInternal(address(core), _code);\n  }","contract":"TokenFactory","time":0},{"type":"external-function ","before":"function deployToken(\n    uint256 _delegateId,\n    string memory _name,\n    string memory _symbol,\n    uint256 _decimals,\n    uint256 _lockEnd,\n    address[] memory _vaults,\n    uint256[] memory _supplies,\n    address[] memory _proxyOperators\n  ) public returns (address) {\n    require(hasCoreAccess(), \"TF01\");\n    require(_vaults.length == _supplies.length, \"TF02\");\n    require(proxyCode_.length != 0, \"TF03\");\n\n    // 1- Creating a proxy\n    address token = deployProxyInternal();\n    require(token != address(0), \"TF04\");\n\n    // 2- Defining the token in the core\n    ITokenCore tokenCore = ITokenCore(address(core));\n    require(tokenCore.defineToken(\n      token, _delegateId, _name, _symbol, _decimals), \"TF05\");\n\n    // 3- Assign roles\n    address[] memory factoryAddress = new address[](1);\n    factoryAddress[0] = address(this);\n    require(tokenCore.assignProxyOperators(token, FACTORY_PROXY_ROLE, factoryAddress), \"TF06\");\n    require(tokenCore.assignProxyOperators(token, ISSUER_PROXY_ROLE, _proxyOperators), \"TF07\");\n\n    // 4- Define rules\n    // Token is locked for review by core operators\n    // Removing the token factory from the rules will unlocked the token\n    IRule[] memory factoryRules = new IRule[](1);\n    factoryRules[0] = IRule(address(this));\n    require(tokenCore.defineRules(token, factoryRules), \"TF08\");\n\n    // 5- Locking the token\n    if (_lockEnd > now) {\n      require(tokenCore.defineLock(token, 0, _lockEnd, new address[](0)), \"TF09\");\n    }\n\n    // 6- Minting the token\n    require(tokenCore.mintAtOnce(token, _vaults, _supplies), \"TF10\");\n\n    emit TokenDeployed(token);\n    return token;\n  }","after":"function deployToken(\n    uint256 _delegateId,\n    string calldata _name,\n    string calldata _symbol,\n    uint256 _decimals,\n    uint256 _lockEnd,\n    address[] calldata _vaults,\n    uint256[] calldata _supplies,\n    address[] calldata _proxyOperators\n  ) public returns (address) {\n    require(hasCoreAccess(), \"TF01\");\n    require(_vaults.length == _supplies.length, \"TF02\");\n    require(proxyCode_.length != 0, \"TF03\");\n\n    // 1- Creating a proxy\n    address token = deployProxyInternal();\n    require(token != address(0), \"TF04\");\n\n    // 2- Defining the token in the core\n    ITokenCore tokenCore = ITokenCore(address(core));\n    require(tokenCore.defineToken(\n      token, _delegateId, _name, _symbol, _decimals), \"TF05\");\n\n    // 3- Assign roles\n    address[] memory factoryAddress = new address[](1);\n    factoryAddress[0] = address(this);\n    require(tokenCore.assignProxyOperators(token, FACTORY_PROXY_ROLE, factoryAddress), \"TF06\");\n    require(tokenCore.assignProxyOperators(token, ISSUER_PROXY_ROLE, _proxyOperators), \"TF07\");\n\n    // 4- Define rules\n    // Token is locked for review by core operators\n    // Removing the token factory from the rules will unlocked the token\n    IRule[] memory factoryRules = new IRule[](1);\n    factoryRules[0] = IRule(address(this));\n    require(tokenCore.defineRules(token, factoryRules), \"TF08\");\n\n    // 5- Locking the token\n    if (_lockEnd > now) {\n      require(tokenCore.defineLock(token, 0, _lockEnd, new address[](0)), \"TF09\");\n    }\n\n    // 6- Minting the token\n    require(tokenCore.mintAtOnce(token, _vaults, _supplies), \"TF10\");\n\n    emit TokenDeployed(token);\n    return token;\n  }","contract":"TokenFactory","time":0},{"type":"external-function ","before":"function reviewToken(address _token, address[] memory _auditSelectors)\n    public onlyCoreOperator returns (bool)\n  {\n    require(hasCoreAccess(), \"TF01\");\n\n    bool[] memory values = new bool[](_auditSelectors.length);\n    for(uint256 i=0; i < values.length; i++) {\n      values[i] = true;\n    }\n\n    ITokenCore tokenCore = ITokenCore(address(core));\n    require(tokenCore.defineAuditSelector(address(core), 0, _auditSelectors, values), \"TF11\");\n    require(tokenCore.defineRules(_token, new IRule[](0)), \"TF12\");\n    emit TokenReviewed(_token);\n    return true;\n  }","after":"function reviewToken(address _token, address[] calldata _auditSelectors)\n    public onlyCoreOperator returns (bool)\n  {\n    require(hasCoreAccess(), \"TF01\");\n\n    bool[] memory values = new bool[](_auditSelectors.length);\n    for(uint256 i=0; i < values.length; i++) {\n      values[i] = true;\n    }\n\n    ITokenCore tokenCore = ITokenCore(address(core));\n    require(tokenCore.defineAuditSelector(address(core), 0, _auditSelectors, values), \"TF11\");\n    require(tokenCore.defineRules(_token, new IRule[](0)), \"TF12\");\n    emit TokenReviewed(_token);\n    return true;\n  }","contract":"TokenFactory","time":0},{"type":"external-function ","before":"function configureTokensales(address _token,\n    address[] memory _tokensales, uint256[] memory _allowances)\n    public onlyProxyOperator(_token) returns (bool)\n  {\n    require(hasCoreAccess(), \"TF01\");\n    require(_tokensales.length == _allowances.length, \"TF13\");\n\n    ITokenCore tokenCore = ITokenCore(address(core));\n    (,,,,uint256[2] memory schedule,,,) = tokenCore.token(_token);\n    require(tokenCore.defineLock(_token, schedule[0], schedule[1], _tokensales), \"TF14\");\n\n    updateAllowances(_token, _tokensales, _allowances);\n    emit TokensalesConfigured(_token, _tokensales);\n  }","after":"function configureTokensales(address _token,\n    address[] calldata _tokensales, uint256[] calldata _allowances)\n    public onlyProxyOperator(_token) returns (bool)\n  {\n    require(hasCoreAccess(), \"TF01\");\n    require(_tokensales.length == _allowances.length, \"TF13\");\n\n    ITokenCore tokenCore = ITokenCore(address(core));\n    (,,,,uint256[2] memory schedule,,,) = tokenCore.token(_token);\n    require(tokenCore.defineLock(_token, schedule[0], schedule[1], _tokensales), \"TF14\");\n\n    updateAllowances(_token, _tokensales, _allowances);\n    emit TokensalesConfigured(_token, _tokensales);\n  }","contract":"TokenFactory","time":0}]}