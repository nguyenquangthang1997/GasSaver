{"time":211,"results":[{"type":"external-function ","before":"function investIn(string memory inviteCode, string memory referrer,uint256 value)\n        public\n        isHuman()\n    {\n        value = value*ethWei;\n        require(gameStart(), \"game not start\");\n        require(value >= 1*ethWei && value <= 2000*ethWei, \"between 1 and 2000\");\n        require(value == value.div(ethWei).mul(ethWei), \"invalid msg value\");\n\n        tokenTransfer(tokencontract).transferFrom(msg.sender,address(address(this)),value.div(1e10));\n\n        UserGlobal storage userGlobal = userMapping[msg.sender];\n        if (userGlobal.id == 0) {\n            require(!compareStr(inviteCode, \"\"), \"empty invite code\");\n            address referrerAddr = getUserAddressByCode(referrer);\n            require(uint(referrerAddr) != 0, \"referer not exist\");\n            require(referrerAddr != msg.sender, \"referrer can't be self\");\n            require(!isUsed(inviteCode), \"invite code is used\");\n\n            registerUser(msg.sender, inviteCode, referrer);\n        }\n\n        User storage user = userRoundMapping[rid][msg.sender];\n        if (uint(user.userAddress) != 0) {\n            require(user.freezeAmount.add(value) <= 2000*ethWei, \"can not beyond 2000 eth\");\n            user.allInvest = user.allInvest.add(value);\n            user.freezeAmount = user.freezeAmount.add(value);\n            user.staticLevel = getLevel(user.freezeAmount);\n            user.dynamicLevel = getLineLevel(user.freezeAmount.add(user.unlockAmount));\n        } else {\n            user.id = userGlobal.id;\n            user.userAddress = msg.sender;\n            user.freezeAmount = value;\n            user.staticLevel = getLevel(value);\n            user.allInvest = value;\n            user.dynamicLevel = getLineLevel(value);\n            user.inviteCode = userGlobal.inviteCode;\n            user.referrer = userGlobal.referrer;\n\n            if (!compareStr(userGlobal.referrer, \"\")) {\n                address referrerAddr = getUserAddressByCode(userGlobal.referrer);\n                userRoundMapping[rid][referrerAddr].inviteAmount++;\n            }\n        }\n\n        Invest memory invest = Invest(msg.sender, value, now, 0);\n        user.invests.push(invest);\n\n        if (rInvestMoney[rid] != 0 && (rInvestMoney[rid].div(10000).div(ethWei) != rInvestMoney[rid].add(value).div(10000).div(ethWei))) {\n            bool isEnough;\n            uint sendMoney;\n            (isEnough, sendMoney) = isEnoughBalance(rInfo[rid].luckPort);\n            if (sendMoney > 0) {\n                sendMoneyToUser(msg.sender, sendMoney);\n            }\n            rInfo[rid].luckPort = 0;\n\n        }\n\n        investCount = investCount.add(1);\n        investMoney = investMoney.add(value);\n        rInvestCount[rid] = rInvestCount[rid].add(1);\n        rInvestMoney[rid] = rInvestMoney[rid].add(value);\n        rInfo[rid].luckPort = rInfo[rid].luckPort.add(value.mul(2).div(1000));\n\n        emit LogInvestIn(msg.sender, userGlobal.id, value, now, userGlobal.inviteCode, userGlobal.referrer, 0);\n    }","after":"function investIn(string calldata inviteCode, string calldata referrer,uint256 value)\n        public\n        isHuman()\n    {\n        value = value*ethWei;\n        require(gameStart(), \"game not start\");\n        require(value >= 1*ethWei && value <= 2000*ethWei, \"between 1 and 2000\");\n        require(value == value.div(ethWei).mul(ethWei), \"invalid msg value\");\n\n        tokenTransfer(tokencontract).transferFrom(msg.sender,address(address(this)),value.div(1e10));\n\n        UserGlobal storage userGlobal = userMapping[msg.sender];\n        if (userGlobal.id == 0) {\n            require(!compareStr(inviteCode, \"\"), \"empty invite code\");\n            address referrerAddr = getUserAddressByCode(referrer);\n            require(uint(referrerAddr) != 0, \"referer not exist\");\n            require(referrerAddr != msg.sender, \"referrer can't be self\");\n            require(!isUsed(inviteCode), \"invite code is used\");\n\n            registerUser(msg.sender, inviteCode, referrer);\n        }\n\n        User storage user = userRoundMapping[rid][msg.sender];\n        if (uint(user.userAddress) != 0) {\n            require(user.freezeAmount.add(value) <= 2000*ethWei, \"can not beyond 2000 eth\");\n            user.allInvest = user.allInvest.add(value);\n            user.freezeAmount = user.freezeAmount.add(value);\n            user.staticLevel = getLevel(user.freezeAmount);\n            user.dynamicLevel = getLineLevel(user.freezeAmount.add(user.unlockAmount));\n        } else {\n            user.id = userGlobal.id;\n            user.userAddress = msg.sender;\n            user.freezeAmount = value;\n            user.staticLevel = getLevel(value);\n            user.allInvest = value;\n            user.dynamicLevel = getLineLevel(value);\n            user.inviteCode = userGlobal.inviteCode;\n            user.referrer = userGlobal.referrer;\n\n            if (!compareStr(userGlobal.referrer, \"\")) {\n                address referrerAddr = getUserAddressByCode(userGlobal.referrer);\n                userRoundMapping[rid][referrerAddr].inviteAmount++;\n            }\n        }\n\n        Invest memory invest = Invest(msg.sender, value, now, 0);\n        user.invests.push(invest);\n\n        if (rInvestMoney[rid] != 0 && (rInvestMoney[rid].div(10000).div(ethWei) != rInvestMoney[rid].add(value).div(10000).div(ethWei))) {\n            bool isEnough;\n            uint sendMoney;\n            (isEnough, sendMoney) = isEnoughBalance(rInfo[rid].luckPort);\n            if (sendMoney > 0) {\n                sendMoneyToUser(msg.sender, sendMoney);\n            }\n            rInfo[rid].luckPort = 0;\n\n        }\n\n        investCount = investCount.add(1);\n        investMoney = investMoney.add(value);\n        rInvestCount[rid] = rInvestCount[rid].add(1);\n        rInvestMoney[rid] = rInvestMoney[rid].add(value);\n        rInfo[rid].luckPort = rInfo[rid].luckPort.add(value.mul(2).div(1000));\n\n        emit LogInvestIn(msg.sender, userGlobal.id, value, now, userGlobal.inviteCode, userGlobal.referrer, 0);\n    }","contract":"CMMEMonopoly","time":0},{"type":"constant-restrict-modification  ","before":"uint ethWei = 1 ether;","after":"uint constant ethWei = 1 ether;","contract":"CMMEMonopoly","time":1},{"type":"constant-restrict-modification  ","before":"address tokencontract = address(0x244BD00B4B1623fC59ab542FF34F5b6fcbe7b128);","after":"address constant tokencontract = address(0x244BD00B4B1623fC59ab542FF34F5b6fcbe7b128);","contract":"CMMEMonopoly","time":1},{"type":"constant-restrict-modification  ","before":"uint period = 3 hours;","after":"uint constant period = 3 hours;","contract":"CMMEMonopoly","time":1},{"type":"constant-restrict-modification  ","before":"uint ethWei = 1 ether;","after":"uint constant ethWei = 1 ether;","contract":"CMMEMonopoly","time":1}]}