{"time":266,"results":[{"type":"external-function ","before":"function executeActionWithAtomicBatchCalls(\n    Call[] memory calls,\n    uint256 minimumActionGas,\n    bytes memory userSignature,\n    bytes memory dharmaSignature\n  ) public returns (bool[] memory ok, bytes[] memory returnData) {\n    // Ensure that each `to` address is a contract and is not this contract.\n    for (uint256 i = 0; i < calls.length; i++) {\n      _ensureValidGenericCallTarget(calls[i].to);\n    }\n\n    // Ensure caller and/or supplied signatures are valid and increment nonce.\n    (bytes32 actionID, uint256 nonce) = _validateActionAndIncrementNonce(\n      ActionType.GenericAtomicBatch,\n      abi.encode(calls),\n      minimumActionGas,\n      userSignature,\n      dharmaSignature\n    );\n\n    // Note: from this point on, there are no reverts (apart from out-of-gas or\n    // call-depth-exceeded) originating from this contract. However, one of the\n    // calls may revert, in which case the function will return `false`, along\n    // with the revert reason encoded as bytes, and fire an CallFailure event.\n    \n    // Specify length of returned values in order to work with them in memory.\n    ok = new bool[](calls.length);\n    returnData = new bytes[](calls.length);\n\n    // Set self-call context to call _executeActionWithAtomicBatchCallsAtomic.\n    _selfCallContext = this.executeActionWithAtomicBatchCalls.selector;\n\n    // Make the atomic self-call - if any call fails, calls that preceded it\n    // will be rolled back and calls that follow it will not be made.\n    (bool externalOk, bytes memory rawCallResults) = address(this).call(\n      abi.encodeWithSelector(\n        this._executeActionWithAtomicBatchCallsAtomic.selector, calls\n      )\n    );\n\n    // Parse data returned from self-call into each call result and store / log.\n    CallReturn[] memory callResults = abi.decode(rawCallResults, (CallReturn[]));\n    for (uint256 i = 0; i < callResults.length; i++) {\n      Call memory currentCall = calls[i];\n\n      // Set the status and the return data / revert reason from the call.\n      ok[i] = callResults[i].ok;\n      returnData[i] = callResults[i].returnData;\n      \n      // Emit CallSuccess or CallFailure event based on the outcome of the call.\n      if (callResults[i].ok) {\n        // Note: while the call succeeded, the action may still have \"failed\"\n        // (i.e. a successful calls to Compound can still return an error).\n        emit CallSuccess(\n          actionID,\n          !externalOk, // if another call failed this will have been rolled back\n          nonce,\n          currentCall.to,\n          currentCall.data,\n          callResults[i].returnData\n        );\n      } else {\n        // Note: while the call failed, the nonce will still be incremented,\n        // which will invalidate all supplied signatures.\n        emit CallFailure(\n          actionID,\n          nonce,\n          currentCall.to,\n          currentCall.data,\n          string(callResults[i].returnData)\n        );\n\n        // exit early - any calls after the first failed call will not execute.\n        break;\n      }\n    }\n  }","after":"function executeActionWithAtomicBatchCalls(\n    Call[] calldata calls,\n    uint256 minimumActionGas,\n    bytes calldata userSignature,\n    bytes calldata dharmaSignature\n  ) public returns (bool[] memory ok, bytes[] memory returnData) {\n    // Ensure that each `to` address is a contract and is not this contract.\n    for (uint256 i = 0; i < calls.length; i++) {\n      _ensureValidGenericCallTarget(calls[i].to);\n    }\n\n    // Ensure caller and/or supplied signatures are valid and increment nonce.\n    (bytes32 actionID, uint256 nonce) = _validateActionAndIncrementNonce(\n      ActionType.GenericAtomicBatch,\n      abi.encode(calls),\n      minimumActionGas,\n      userSignature,\n      dharmaSignature\n    );\n\n    // Note: from this point on, there are no reverts (apart from out-of-gas or\n    // call-depth-exceeded) originating from this contract. However, one of the\n    // calls may revert, in which case the function will return `false`, along\n    // with the revert reason encoded as bytes, and fire an CallFailure event.\n    \n    // Specify length of returned values in order to work with them in memory.\n    ok = new bool[](calls.length);\n    returnData = new bytes[](calls.length);\n\n    // Set self-call context to call _executeActionWithAtomicBatchCallsAtomic.\n    _selfCallContext = this.executeActionWithAtomicBatchCalls.selector;\n\n    // Make the atomic self-call - if any call fails, calls that preceded it\n    // will be rolled back and calls that follow it will not be made.\n    (bool externalOk, bytes memory rawCallResults) = address(this).call(\n      abi.encodeWithSelector(\n        this._executeActionWithAtomicBatchCallsAtomic.selector, calls\n      )\n    );\n\n    // Parse data returned from self-call into each call result and store / log.\n    CallReturn[] memory callResults = abi.decode(rawCallResults, (CallReturn[]));\n    for (uint256 i = 0; i < callResults.length; i++) {\n      Call memory currentCall = calls[i];\n\n      // Set the status and the return data / revert reason from the call.\n      ok[i] = callResults[i].ok;\n      returnData[i] = callResults[i].returnData;\n      \n      // Emit CallSuccess or CallFailure event based on the outcome of the call.\n      if (callResults[i].ok) {\n        // Note: while the call succeeded, the action may still have \"failed\"\n        // (i.e. a successful calls to Compound can still return an error).\n        emit CallSuccess(\n          actionID,\n          !externalOk, // if another call failed this will have been rolled back\n          nonce,\n          currentCall.to,\n          currentCall.data,\n          callResults[i].returnData\n        );\n      } else {\n        // Note: while the call failed, the nonce will still be incremented,\n        // which will invalidate all supplied signatures.\n        emit CallFailure(\n          actionID,\n          nonce,\n          currentCall.to,\n          currentCall.data,\n          string(callResults[i].returnData)\n        );\n\n        // exit early - any calls after the first failed call will not execute.\n        break;\n      }\n    }\n  }","contract":"DharmaSmartWalletImplementationV1","time":0},{"type":"external-function ","before":"function _executeActionWithAtomicBatchCallsAtomic(\n    Call[] memory calls\n  ) public returns (CallReturn[] memory callResults) {\n    // Ensure caller is this contract and self-call context is correctly set.\n    _enforceSelfCallFrom(this.executeActionWithAtomicBatchCalls.selector);\n\n    bool rollBack = false;\n    callResults = new CallReturn[](calls.length);\n\n    for (uint256 i = 0; i < calls.length; i++) {\n      // Perform low-level call and set return values using result.\n      (bool ok, bytes memory returnData) = calls[i].to.call(calls[i].data);\n      callResults[i] = CallReturn({ok: ok, returnData: returnData});\n      if (!ok) {\n        // exit early - any calls after the first failed call will not execute.\n        rollBack = true;\n        break;\n      }\n    }\n\n    if (rollBack) {\n      // wrap in length encoding and revert (provide data instead of a string)\n      bytes memory callResultsBytes = abi.encode(callResults);\n      assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\n    }\n  }","after":"function _executeActionWithAtomicBatchCallsAtomic(\n    Call[] calldata calls\n  ) public returns (CallReturn[] memory callResults) {\n    // Ensure caller is this contract and self-call context is correctly set.\n    _enforceSelfCallFrom(this.executeActionWithAtomicBatchCalls.selector);\n\n    bool rollBack = false;\n    callResults = new CallReturn[](calls.length);\n\n    for (uint256 i = 0; i < calls.length; i++) {\n      // Perform low-level call and set return values using result.\n      (bool ok, bytes memory returnData) = calls[i].to.call(calls[i].data);\n      callResults[i] = CallReturn({ok: ok, returnData: returnData});\n      if (!ok) {\n        // exit early - any calls after the first failed call will not execute.\n        rollBack = true;\n        break;\n      }\n    }\n\n    if (rollBack) {\n      // wrap in length encoding and revert (provide data instead of a string)\n      bytes memory callResultsBytes = abi.encode(callResults);\n      assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\n    }\n  }","contract":"DharmaSmartWalletImplementationV1","time":0}]}