{"time":128,"results":[{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping (uint256 => address) private _tokenOwner;\nmapping (uint256 => address) private _tokenApprovals;\nmapping (address => Counters.Counter) private _ownedTokensCount;\nmapping (address => mapping (address => bool)) private _operatorApprovals;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;","after":"mapping (uint256 => address) private _tokenOwner;\nmapping (uint256 => address) private _tokenApprovals;\nmapping (address => Counters.Counter) private _ownedTokensCount;\nmapping (address => mapping (address => bool)) private _operatorApprovals;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n","contract":"ERC721","time":0},{"type":"external-function ","before":"function initialize(string memory name, string memory symbol, string memory tokenURI) public onlyOwner {\n        _name = name;\n        _symbol = symbol;\n        _tokenURI = tokenURI;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }","after":"function initialize(string calldata name, string calldata symbol, string calldata tokenURI) public onlyOwner {\n        _name = name;\n        _symbol = symbol;\n        _tokenURI = tokenURI;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }","contract":"ERC721WithMessage","time":0},{"type":"external-function ","before":"function mintWithMessage(address to, uint256 tokenId, string memory message, bool encrypted) public onlyOwner returns (bool) {\n        _mint(to, tokenId);\n        _tokenMessages[tokenId] = Message(message, encrypted);\n        return true;\n    }","after":"function mintWithMessage(address to, uint256 tokenId, string calldata message, bool encrypted) public onlyOwner returns (bool) {\n        _mint(to, tokenId);\n        _tokenMessages[tokenId] = Message(message, encrypted);\n        return true;\n    }","contract":"ERC721WithMessage","time":0},{"type":"struct-data-arrangement ","before":"\naddress senderAddress\naddress keyAddress\nuint256 cardIndex\nuint256 tokenId\nuint256 giftAmount\nuint256 timestamp\nbool claimed","after":"uint256 cardIndex\nuint256 tokenId\nuint256 giftAmount\nuint256 timestamp\naddress senderAddress\naddress keyAddress\nbool claimed\n","contract":"Cardma","time":0},{"type":"struct-data-arrangement ","before":"\naddress keyAddress\nstring imageURI\nstring message\nbool encrypted\nuint256 giftAmount\nuint256 timestamp\nbool claimed","after":"string imageURI\nstring message\nuint256 giftAmount\nuint256 timestamp\naddress keyAddress\nbool encrypted\nbool claimed\n","contract":"Cardma","time":0},{"type":"external-function ","before":"function addCard(\n        string memory name,\n        string memory author,\n        string memory description,\n        string memory imageURI,\n        string memory tokenURI,\n        uint256 price,\n        uint256 limit\n    )\n        public\n        onlyOwner\n    {\n        require(_cardFactoryAddress != address(0), \"Cardma: card factory not set\");\n        \n        uint256 cardIndex = _cards.length;\n        address cardAddress = createCardContract();\n        ERC721WithMessage cardContract = ERC721WithMessage(cardAddress);\n        cardContract.setupOwnership();\n        cardContract.initialize(\n            name,\n            string((abi.encodePacked(\"CM-\", uint2str(cardIndex)))),\n            tokenURI\n        );\n        _cards.push(Card(\n            cardAddress,\n            name,\n            author,\n            description,\n            imageURI,\n            price,\n            0,\n            limit\n        ));\n    }","after":"function addCard(\n        string calldata name,\n        string calldata author,\n        string calldata description,\n        string calldata imageURI,\n        string calldata tokenURI,\n        uint256 price,\n        uint256 limit\n    )\n        public\n        onlyOwner\n    {\n        require(_cardFactoryAddress != address(0), \"Cardma: card factory not set\");\n        \n        uint256 cardIndex = _cards.length;\n        address cardAddress = createCardContract();\n        ERC721WithMessage cardContract = ERC721WithMessage(cardAddress);\n        cardContract.setupOwnership();\n        cardContract.initialize(\n            name,\n            string((abi.encodePacked(\"CM-\", uint2str(cardIndex)))),\n            tokenURI\n        );\n        _cards.push(Card(\n            cardAddress,\n            name,\n            author,\n            description,\n            imageURI,\n            price,\n            0,\n            limit\n        ));\n    }","contract":"Cardma","time":0},{"type":"external-function ","before":"function sendCard(\n        address keyAddress,\n        uint256 cardIndex,\n        string memory message,\n        bool encrypted\n    )\n        public\n        payable\n        checkIndex(cardIndex)\n    {\n        Card storage card = _cards[cardIndex];\n\n        // Check card keyAddress\n        require(_sentCards[keyAddress].keyAddress == address(0), \"Cardma: same keyAddress exists\");\n\n        // Check card availability\n        require(card.limit == 0 || card.count < card.limit, \"Cardma: desired card has been sold out\");\n\n        // Check and charge card price\n        require(msg.value >= card.price, \"Cardma: cannot afford the card\");\n        _revenue += card.price;\n\n        uint256 tokenId = card.count;\n        // Mint ERC721 token\n        ERC721WithMessage(card.cardAddress).mintWithMessage(\n            address(this), // hold token until claimed\n            tokenId,\n            message,\n            encrypted\n        );\n\n        // Keep token and ETH\n        address senderAddress = _msgSender();\n        SentCard memory sentCard = SentCard(\n            senderAddress,\n            keyAddress,\n            cardIndex,\n            tokenId,\n            msg.value - card.price,\n            block.timestamp,\n            false\n        );\n\n        // Update contract storage\n        _sentCards[keyAddress] = sentCard;\n        _sentCardsFromUser[senderAddress].push(keyAddress);\n        card.count += 1;\n    }","after":"function sendCard(\n        address keyAddress,\n        uint256 cardIndex,\n        string calldata message,\n        bool encrypted\n    )\n        public\n        payable\n        checkIndex(cardIndex)\n    {\n        Card storage card = _cards[cardIndex];\n\n        // Check card keyAddress\n        require(_sentCards[keyAddress].keyAddress == address(0), \"Cardma: same keyAddress exists\");\n\n        // Check card availability\n        require(card.limit == 0 || card.count < card.limit, \"Cardma: desired card has been sold out\");\n\n        // Check and charge card price\n        require(msg.value >= card.price, \"Cardma: cannot afford the card\");\n        _revenue += card.price;\n\n        uint256 tokenId = card.count;\n        // Mint ERC721 token\n        ERC721WithMessage(card.cardAddress).mintWithMessage(\n            address(this), // hold token until claimed\n            tokenId,\n            message,\n            encrypted\n        );\n\n        // Keep token and ETH\n        address senderAddress = _msgSender();\n        SentCard memory sentCard = SentCard(\n            senderAddress,\n            keyAddress,\n            cardIndex,\n            tokenId,\n            msg.value - card.price,\n            block.timestamp,\n            false\n        );\n\n        // Update contract storage\n        _sentCards[keyAddress] = sentCard;\n        _sentCardsFromUser[senderAddress].push(keyAddress);\n        card.count += 1;\n    }","contract":"Cardma","time":0}]}