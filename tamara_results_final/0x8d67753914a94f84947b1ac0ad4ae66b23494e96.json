{"time":389,"results":[{"type":"struct-data-arrangement ","before":"\note{\n    bytes32 prop\nosal\n    boo\nove;\n    bool \ntor;\n    ui\nunt;\n    addr\noter\n    uint \nvote\n    bool i","after":"ote{\n    bytes32 prop\ntor;\n    ui\noter\n    uint \nunt;\n    addr\nosal\n    boo\nove;\n    bool \nvote\n    bool i\n","contract":"EticaRelease","time":0},{"type":"external-function ","before":"----- //\nfunction createdisease(string memory _name) public {\n\n\n  // --- REQUIRE PAYMENT FOR ADDING A DISEASE TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\n\n  // make sure the user has enough ETI to create a disease\n  require(balances[msg.sender] >= DISEASE_CREATION_AMOUNT);\n  // transfer DISEASE_CREATION_AMOUNT ETI from user wallet to contract wallet:\n  transfer(address(this), DISEASE_CREATION_AMOUNT);\n\n  UNRECOVERABLE_ETI = UNRECOVERABLE_ETI.add(DISEASE_CREATION_AMOUNT);\n\n  // --- REQUIRE PAYMENT FOR ADDING A DISEASE TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\n\n\n  bytes32 _diseasehash = keccak256(abi.encode(_name));\n\n  diseasesCounter = diseasesCounter.add(1); // notice that first disease will have the index of 1 thus not 0 !\n\n  //check: if the disease is new we continue, otherwise we exit\n   if(diseasesbyIds[_diseasehash] != 0x0) revert();  //prevent the same disease from being created twice. The software manages diseases uniqueness based on their unique english name. Note that even the first disease will not have index of 0 thus should pass this check\n   require(diseasesbyNames[_name] == 0); // make sure it is not overwriting another disease thanks to unexpected string tricks from user\n\n   // store the Disease\n   diseases[diseasesCounter] = Disease(\n     _diseasehash,\n     _name\n   );\n\n   // Updates diseasesbyIds and diseasesbyNames mappings:\n   diseasesbyIds[_diseasehash] = diseasesCounter;\n   diseasesbyNames[_name] = _diseasehash;\n\n   emit NewDisease(diseasesCounter, _","after":"----- //\nfunction createdisease(string memory _name) public {\n\n\n  // --- REQUIRE PAYMENT FOR ADDING A DISEASE TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\n\n  // make sure the user has enough ETI to create a disease\n  require(balances[msg.sender] >= DISEASE_CREATION_AMOUNT);\n  // transfer DISEASE_CREATION_AMOUNT ETI from user wallet to contract wallet:\n  transfer(address(this), DISEASE_CREATION_AMOUNT);\n\n  UNRECOVERABLE_ETI = UNRECOVERABLE_ETI.add(DISEASE_CREATION_AMOUNT);\n\n  // --- REQUIRE PAYMENT FOR ADDING A DISEASE TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\n\n\n  bytes32 _diseasehash = keccak256(abi.encode(_name));\n\n  diseasesCounter = diseasesCounter.add(1); // notice that first disease will have the index of 1 thus not 0 !\n\n  //check: if the disease is new we continue, otherwise we exit\n   if(diseasesbyIds[_diseasehash] != 0x0) revert();  //prevent the same disease from being created twice. The software manages diseases uniqueness based on their unique english name. Note that even the first disease will not have index of 0 thus should pass this check\n   require(diseasesbyNames[_name] == 0); // make sure it is not overwriting another disease thanks to unexpected string tricks from user\n\n   // store the Disease\n   diseases[diseasesCounter] = Disease(\n     _diseasehash,\n     _name\n   );\n\n   // Updates diseasesbyIds and diseasesbyNames mappings:\n   diseasesbyIds[_diseasehash] = diseasesCounter;\n   diseasesbyNames[_name] = _diseasehash;\n\n   emit NewDisease(diseasesCounter, _","contract":"EticaRelease","time":0},{"type":"external-function ","before":");\n\n}\n\n\n\nfunction propose(bytes32 _diseasehash, string memory _title, string memory _description, string memory raw_release_hash, string memory _freefield, uint _chunkid) public {\n\n    //check if the disease exits\n     require(diseasesbyIds[_diseasehash] > 0 && diseasesbyIds[_diseasehash] <= diseasesCounter);\n     if(diseases[diseasesbyIds[_diseasehash]].disease_hash != _diseasehash) revert(); // second check not necessary but I decided to add it as the gas cost value for security is worth it\n\n    require(_chunkid <= chunksCounter);\n\n     bytes32 _proposed_release_hash = keccak256(abi.encode(raw_release_hash, _diseasehash));\n     diseaseProposalsCounter[_diseasehash] = diseaseProposalsCounter[_diseasehash].add(1);\n     diseaseproposals[_diseasehash][diseaseProposalsCounter[_diseasehash]] = _proposed_release_hash;\n\n     proposalsCounter = proposalsCounter.add(1); // notice that first proposal will have the index of 1 thus not 0 !\n     proposalsbyIndex[proposalsCounter] = _proposed_release_hash;\n\n     // Check that proposal does not already exist\n     // only allow one proposal for each {raw_release_hash,  _diseasehash} combinasion\n      bytes32 existing_proposal = proposals[_proposed_release_hash].proposed_release_hash;\n      if(existing_proposal != 0x0 || proposals[_proposed_release_hash].id != 0) revert();  //prevent the same raw_release_hash from being submited twice on same proposal. Double check for better security and slightly higher gas cost even though one would be enough !\n\n     uint _current_interval = uint((block.timestamp).div(REWARD_INTERVAL));\n\n      // Create new Period if this current interval did not have its Period created yet\n      if(IntervalsPeriods[_current_interval] == 0x0){\n        newPeriod();\n      }\n\n     Proposal storage proposal = proposals[_proposed_release_hash];\n\n       proposal.id = proposalsCounter;\n       proposal.disease_id = _diseasehash; // _diseasehash has already been checked to equal diseases[diseasesbyIds[_diseasehash]].disease_hash\n       proposal.period_id = IntervalsPeriods[_current_interval];\n       proposal.proposed_release_hash = _proposed_release_hash; // Hash of \"raw_release_hash + name of Disease\",\n       proposal.proposer = msg.sender;\n       proposal.title = _title;\n       proposal.description = _description;\n       proposal.raw_release_hash = raw_release_hash;\n       proposal.freefield = _freefield;\n\n\n       //  Proposal Data:\n       ProposalData storage proposaldata = propsdatas[_proposed_release_hash];\n       proposaldata.status = ProposalStatus.Pending;\n       proposaldata.istie = true;\n       proposaldata.prestatus = ProposalStatus.Pending;\n       proposaldata.nbvoters = 0;\n       proposaldata.slashingratio = 0;\n       proposaldata.forvotes = 0;\n       proposaldata.againstvotes = 0;\n       proposaldata.lastcuration_weight = 0;\n       proposaldata.lasteditor_weight = 0;\n       proposaldata.starttime = block.timestamp;\n       proposaldata.endtime = block.timestamp.add(DEFAULT_VOTING_TIME);\n\n\n// --- REQUIRE DEFAULT VOTE TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\n\n    require(bosoms[msg.sender] >= PROPOSAL_DEFAULT_VOTE); // this check is not mandatory as handled by safemath sub function: (bosoms[msg.sender].sub(PROPOSAL_DEFAULT_VOTE))\n\n    // Consume bosom:\n    bosoms[msg.sender] = bosoms[msg.sender].sub(PROPOSAL_DEFAULT_VOTE);\n\n\n    // Block Eticas in eticablkdtbl to prevent user from unstaking before eventual slash\n    blockedeticas[msg.sender] = blockedeticas[msg.sender].add(PROPOSAL_DEFAULT_VOTE);\n\n\n    // store vote:\n    Vote storage vote = votes[proposal.proposed_release_hash][msg.sender];\n    vote.proposal_hash = proposal.proposed_release_hash;\n    vote.approve = true;\n    vote.is_editor = true;\n    vote.amount = PROPOSAL_DEFAULT_VOTE;\n    vote.voter = msg.sender;\n    vote.timestamp = block.timestamp;\n\n\n\n      // UPDATE PROPOSAL:\n      proposaldata.prestatus = ProposalStatus.Singlevoter;\n\n      // if chunk exists and belongs to disease updates proposal.chunk_id:\n      uint existing_chunk = chunks[_chunkid].id;\n      if(existing_chunk != 0x0 && chunks[_chunkid].diseaseid == _diseasehash) {\n        proposal.chunk_id = _chunkid;\n        // updates chunk proposals infos:\n        chunkProposalsCounter[_chunkid] = chunkProposalsCounter[_chunkid].add(1);\n        chunkproposals[_chunkid][chunkProposalsCounter[_chunkid]] = proposal.proposed_release_hash;\n      }\n\n  // --- REQUIRE DEFAULT VOTE TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\n\n  RANDOMHASH = keccak256(abi.encode(RANDOMHASH, _proposed_release_hash)); // updates RANDOMHASH\n\n    emit NewProposal(_proposed_release_hash, msg.sender, proposal.disease_id, _chu","after":");\n\n}\n\n\n\nfunction propose(bytes32 _diseasehash, string calldata _title, string calldata _description, string calldata raw_release_hash, string calldata _freefield, uint _chunkid) public {\n\n    //check if the disease exits\n     require(diseasesbyIds[_diseasehash] > 0 && diseasesbyIds[_diseasehash] <= diseasesCounter);\n     if(diseases[diseasesbyIds[_diseasehash]].disease_hash != _diseasehash) revert(); // second check not necessary but I decided to add it as the gas cost value for security is worth it\n\n    require(_chunkid <= chunksCounter);\n\n     bytes32 _proposed_release_hash = keccak256(abi.encode(raw_release_hash, _diseasehash));\n     diseaseProposalsCounter[_diseasehash] = diseaseProposalsCounter[_diseasehash].add(1);\n     diseaseproposals[_diseasehash][diseaseProposalsCounter[_diseasehash]] = _proposed_release_hash;\n\n     proposalsCounter = proposalsCounter.add(1); // notice that first proposal will have the index of 1 thus not 0 !\n     proposalsbyIndex[proposalsCounter] = _proposed_release_hash;\n\n     // Check that proposal does not already exist\n     // only allow one proposal for each {raw_release_hash,  _diseasehash} combinasion\n      bytes32 existing_proposal = proposals[_proposed_release_hash].proposed_release_hash;\n      if(existing_proposal != 0x0 || proposals[_proposed_release_hash].id != 0) revert();  //prevent the same raw_release_hash from being submited twice on same proposal. Double check for better security and slightly higher gas cost even though one would be enough !\n\n     uint _current_interval = uint((block.timestamp).div(REWARD_INTERVAL));\n\n      // Create new Period if this current interval did not have its Period created yet\n      if(IntervalsPeriods[_current_interval] == 0x0){\n        newPeriod();\n      }\n\n     Proposal storage proposal = proposals[_proposed_release_hash];\n\n       proposal.id = proposalsCounter;\n       proposal.disease_id = _diseasehash; // _diseasehash has already been checked to equal diseases[diseasesbyIds[_diseasehash]].disease_hash\n       proposal.period_id = IntervalsPeriods[_current_interval];\n       proposal.proposed_release_hash = _proposed_release_hash; // Hash of \"raw_release_hash + name of Disease\",\n       proposal.proposer = msg.sender;\n       proposal.title = _title;\n       proposal.description = _description;\n       proposal.raw_release_hash = raw_release_hash;\n       proposal.freefield = _freefield;\n\n\n       //  Proposal Data:\n       ProposalData storage proposaldata = propsdatas[_proposed_release_hash];\n       proposaldata.status = ProposalStatus.Pending;\n       proposaldata.istie = true;\n       proposaldata.prestatus = ProposalStatus.Pending;\n       proposaldata.nbvoters = 0;\n       proposaldata.slashingratio = 0;\n       proposaldata.forvotes = 0;\n       proposaldata.againstvotes = 0;\n       proposaldata.lastcuration_weight = 0;\n       proposaldata.lasteditor_weight = 0;\n       proposaldata.starttime = block.timestamp;\n       proposaldata.endtime = block.timestamp.add(DEFAULT_VOTING_TIME);\n\n\n// --- REQUIRE DEFAULT VOTE TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\n\n    require(bosoms[msg.sender] >= PROPOSAL_DEFAULT_VOTE); // this check is not mandatory as handled by safemath sub function: (bosoms[msg.sender].sub(PROPOSAL_DEFAULT_VOTE))\n\n    // Consume bosom:\n    bosoms[msg.sender] = bosoms[msg.sender].sub(PROPOSAL_DEFAULT_VOTE);\n\n\n    // Block Eticas in eticablkdtbl to prevent user from unstaking before eventual slash\n    blockedeticas[msg.sender] = blockedeticas[msg.sender].add(PROPOSAL_DEFAULT_VOTE);\n\n\n    // store vote:\n    Vote storage vote = votes[proposal.proposed_release_hash][msg.sender];\n    vote.proposal_hash = proposal.proposed_release_hash;\n    vote.approve = true;\n    vote.is_editor = true;\n    vote.amount = PROPOSAL_DEFAULT_VOTE;\n    vote.voter = msg.sender;\n    vote.timestamp = block.timestamp;\n\n\n\n      // UPDATE PROPOSAL:\n      proposaldata.prestatus = ProposalStatus.Singlevoter;\n\n      // if chunk exists and belongs to disease updates proposal.chunk_id:\n      uint existing_chunk = chunks[_chunkid].id;\n      if(existing_chunk != 0x0 && chunks[_chunkid].diseaseid == _diseasehash) {\n        proposal.chunk_id = _chunkid;\n        // updates chunk proposals infos:\n        chunkProposalsCounter[_chunkid] = chunkProposalsCounter[_chunkid].add(1);\n        chunkproposals[_chunkid][chunkProposalsCounter[_chunkid]] = proposal.proposed_release_hash;\n      }\n\n  // --- REQUIRE DEFAULT VOTE TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\n\n  RANDOMHASH = keccak256(abi.encode(RANDOMHASH, _proposed_release_hash)); // updates RANDOMHASH\n\n    emit NewProposal(_proposed_release_hash, msg.sender, proposal.disease_id, _chu","contract":"EticaRelease","time":0},{"type":"external-function ","before":";\n\n }\n\n\n function revealvote(bytes32 _proposed_release_hash, bool _approved, string memory _vary) public {\n \n\n// --- check commit --- //\nbytes32 _votehash;\n_votehash = keccak256(abi.encode(_proposed_release_hash, _approved, msg.sender, _vary));\n\nrequire(commits[msg.sender][_votehash].amount > 0);\n// --- check commit done --- //\n\n//check if the proposal exists and that we get the right proposal:\nProposal storage proposal = proposals[_proposed_release_hash];\nrequire(proposal.id > 0 && proposal.proposed_release_hash == _proposed_release_hash);\n\n\nProposalData storage proposaldata = propsdatas[_proposed_release_hash];\n\n // Verify commit was done within voting time:\n require( commits[msg.sender][_votehash].timestamp <= proposaldata.endtime);\n\n // Verify we are within revealing time:\n require( block.timestamp > proposaldata.endtime && block.timestamp <= proposaldata.endtime.add(DEFAULT_REVEALING_TIME));\n\n require(proposaldata.prestatus != ProposalStatus.Pending); // can vote for proposal only if default vote has changed prestatus of Proposal. Thus can vote only if default vote occured as supposed to\n\nuint _old_proposal_curationweight = proposaldata.lastcuration_weight;\nuint _old_proposal_editorweight = proposaldata.lasteditor_weight;\n\n\n// get Period of Proposal:\nPeriod storage period = periods[proposal.period_id];\n\n\n// Check that vote does not already exist\n// only allow one vote for each {raw_release_hash, voter} combinasion\nbytes32 existing_vote = votes[proposal.proposed_release_hash][msg.sender].proposal_hash;\nif(existing_vote != 0x0 || votes[proposal.proposed_release_hash][msg.sender].amount != 0) revert();  //prevent the same user from voting twice for same raw_release_hash. Double condition check for better security and slightly higher gas cost even though one would be enough !\n\n\n // store vote:\n Vote storage vote = votes[proposal.proposed_release_hash][msg.sender];\n vote.proposal_hash = proposal.proposed_release_hash;\n vote.approve = _approved;\n vote.is_editor = false;\n vote.amount = commits[msg.sender][_votehash].amount;\n vote.voter = msg.sender;\n vote.timestamp = block.timestamp;\n\n proposaldata.nbvoters = proposaldata.nbvoters.add(1);\n\n     // PROPOSAL VAR UPDATE\n     if(_approved){\n      proposaldata.forvotes = proposaldata.forvotes.add(commits[msg.sender][_votehash].amount);\n     }\n     else {\n       proposaldata.againstvotes = proposaldata.againstvotes.add(commits[msg.sender][_votehash].amount);\n     }\n\n\n     // Determine slashing conditions\n     bool _isapproved = false;\n     bool _istie = false;\n     uint totalVotes = proposaldata.forvotes.add(proposaldata.againstvotes);\n     uint _forvotes_numerator = proposaldata.forvotes.mul(10000); // (newproposal_forvotes / totalVotes) will give a number between 0 and 1. Multiply by 10000 to store it as uint\n     uint _ratio_slashing = 0;\n\n     if ((_forvotes_numerator.div(totalVotes)) > APPROVAL_THRESHOLD){\n    _isapproved = true;\n    }\n    if ((_forvotes_numerator.div(totalVotes)) == APPROVAL_THRESHOLD){\n        _istie = true;\n    }\n\n    proposaldata.istie = _istie;\n\n    if (_isapproved){\n    _ratio_slashing = uint(((10000 - APPROVAL_THRESHOLD).mul(totalVotes)).div(10000));\n    _ratio_slashing = uint((proposaldata.againstvotes.mul(10000)).div(_ratio_slashing));  \n    proposaldata.slashingratio = uint(10000 - _ratio_slashing);\n    }\n    else{\n    _ratio_slashing = uint((totalVotes.mul(APPROVAL_THRESHOLD)).div(10000));\n    _ratio_slashing = uint((proposaldata.forvotes.mul(10000)).div(_ratio_slashing));\n    proposaldata.slashingratio = uint(10000 - _ratio_slashing);\n    }\n\n    // Make sure the slashing reward ratio is within expected range:\n     require(proposaldata.slashingratio >=0 && proposaldata.slashingratio <= 10000);\n\n        // updates period forvotes and againstvotes system\n        ProposalStatus _newstatus = ProposalStatus.Rejected;\n        if(_isapproved){\n         _newstatus = ProposalStatus.Accepted;\n        }\n\n        if(proposaldata.prestatus == ProposalStatus.Singlevoter){\n\n          if(_isapproved){\n            period.forprops = period.forprops.add(1);\n          }\n          else {\n            period.againstprops = period.againstprops.add(1);\n          }\n        }\n        // in this case the proposal becomes rejected after being accepted or becomes accepted after being rejected:\n        else if(_newstatus != proposaldata.prestatus){\n\n         if(_newstatus == ProposalStatus.Accepted){\n          period.againstprops = period.againstprops.sub(1);\n          period.forprops = period.forprops.add(1);\n         }\n         // in this case proposal is necessarily Rejected:\n         else {\n          period.forprops = period.forprops.sub(1);\n          period.againstprops = period.againstprops.add(1);\n         }\n\n        }\n        // updates period forvotes and againstvotes system done\n\n         // Proposal and Period new weight\n         if (_istie) {\n         proposaldata.prestatus =  ProposalStatus.Rejected;\n         proposaldata.lastcuration_weight = 0;\n         proposaldata.lasteditor_weight = 0;\n         // Proposal tied, remove proposal curation and editor sum\n         period.curation_sum = period.curation_sum.sub(_old_proposal_curationweight);\n         period.editor_sum = period.editor_sum.sub(_old_proposal_editorweight);\n         }\n         else {\n             // Proposal approved, strengthen curation sum\n         if (_isapproved){\n             proposaldata.prestatus =  ProposalStatus.Accepted;\n             proposaldata.lastcuration_weight = proposaldata.forvotes;\n             proposaldata.lasteditor_weight = proposaldata.forvotes;\n             // Proposal approved, replace proposal curation and editor sum with forvotes\n             period.curation_sum = period.curation_sum.sub(_old_proposal_curationweight).add(proposaldata.lastcuration_weight);\n             period.editor_sum = period.editor_sum.sub(_old_proposal_editorweight).add(proposaldata.lasteditor_weight);\n         }\n         else{\n             proposaldata.prestatus =  ProposalStatus.Rejected;\n             proposaldata.lastcuration_weight = proposaldata.againstvotes;\n             proposaldata.lasteditor_weight = 0;\n             // Proposal rejected, replace proposal curation sum with againstvotes and remove proposal editor sum\n             period.curation_sum = period.curation_sum.sub(_old_proposal_curationweight).add(proposaldata.lastcuration_weight);\n             period.editor_sum = period.editor_sum.sub(_old_proposal_editorweight);\n         }\n         }\n         \n        // resets commit to save space: \n        _removecommit(_votehash);\n        emit NewReveal(msg.sender, proposal.proposed_release_ha","after":";\n\n }\n\n\n function revealvote(bytes32 _proposed_release_hash, bool _approved, string memory _vary) public {\n \n\n// --- check commit --- //\nbytes32 _votehash;\n_votehash = keccak256(abi.encode(_proposed_release_hash, _approved, msg.sender, _vary));\n\nrequire(commits[msg.sender][_votehash].amount > 0);\n// --- check commit done --- //\n\n//check if the proposal exists and that we get the right proposal:\nProposal storage proposal = proposals[_proposed_release_hash];\nrequire(proposal.id > 0 && proposal.proposed_release_hash == _proposed_release_hash);\n\n\nProposalData storage proposaldata = propsdatas[_proposed_release_hash];\n\n // Verify commit was done within voting time:\n require( commits[msg.sender][_votehash].timestamp <= proposaldata.endtime);\n\n // Verify we are within revealing time:\n require( block.timestamp > proposaldata.endtime && block.timestamp <= proposaldata.endtime.add(DEFAULT_REVEALING_TIME));\n\n require(proposaldata.prestatus != ProposalStatus.Pending); // can vote for proposal only if default vote has changed prestatus of Proposal. Thus can vote only if default vote occured as supposed to\n\nuint _old_proposal_curationweight = proposaldata.lastcuration_weight;\nuint _old_proposal_editorweight = proposaldata.lasteditor_weight;\n\n\n// get Period of Proposal:\nPeriod storage period = periods[proposal.period_id];\n\n\n// Check that vote does not already exist\n// only allow one vote for each {raw_release_hash, voter} combinasion\nbytes32 existing_vote = votes[proposal.proposed_release_hash][msg.sender].proposal_hash;\nif(existing_vote != 0x0 || votes[proposal.proposed_release_hash][msg.sender].amount != 0) revert();  //prevent the same user from voting twice for same raw_release_hash. Double condition check for better security and slightly higher gas cost even though one would be enough !\n\n\n // store vote:\n Vote storage vote = votes[proposal.proposed_release_hash][msg.sender];\n vote.proposal_hash = proposal.proposed_release_hash;\n vote.approve = _approved;\n vote.is_editor = false;\n vote.amount = commits[msg.sender][_votehash].amount;\n vote.voter = msg.sender;\n vote.timestamp = block.timestamp;\n\n proposaldata.nbvoters = proposaldata.nbvoters.add(1);\n\n     // PROPOSAL VAR UPDATE\n     if(_approved){\n      proposaldata.forvotes = proposaldata.forvotes.add(commits[msg.sender][_votehash].amount);\n     }\n     else {\n       proposaldata.againstvotes = proposaldata.againstvotes.add(commits[msg.sender][_votehash].amount);\n     }\n\n\n     // Determine slashing conditions\n     bool _isapproved = false;\n     bool _istie = false;\n     uint totalVotes = proposaldata.forvotes.add(proposaldata.againstvotes);\n     uint _forvotes_numerator = proposaldata.forvotes.mul(10000); // (newproposal_forvotes / totalVotes) will give a number between 0 and 1. Multiply by 10000 to store it as uint\n     uint _ratio_slashing = 0;\n\n     if ((_forvotes_numerator.div(totalVotes)) > APPROVAL_THRESHOLD){\n    _isapproved = true;\n    }\n    if ((_forvotes_numerator.div(totalVotes)) == APPROVAL_THRESHOLD){\n        _istie = true;\n    }\n\n    proposaldata.istie = _istie;\n\n    if (_isapproved){\n    _ratio_slashing = uint(((10000 - APPROVAL_THRESHOLD).mul(totalVotes)).div(10000));\n    _ratio_slashing = uint((proposaldata.againstvotes.mul(10000)).div(_ratio_slashing));  \n    proposaldata.slashingratio = uint(10000 - _ratio_slashing);\n    }\n    else{\n    _ratio_slashing = uint((totalVotes.mul(APPROVAL_THRESHOLD)).div(10000));\n    _ratio_slashing = uint((proposaldata.forvotes.mul(10000)).div(_ratio_slashing));\n    proposaldata.slashingratio = uint(10000 - _ratio_slashing);\n    }\n\n    // Make sure the slashing reward ratio is within expected range:\n     require(proposaldata.slashingratio >=0 && proposaldata.slashingratio <= 10000);\n\n        // updates period forvotes and againstvotes system\n        ProposalStatus _newstatus = ProposalStatus.Rejected;\n        if(_isapproved){\n         _newstatus = ProposalStatus.Accepted;\n        }\n\n        if(proposaldata.prestatus == ProposalStatus.Singlevoter){\n\n          if(_isapproved){\n            period.forprops = period.forprops.add(1);\n          }\n          else {\n            period.againstprops = period.againstprops.add(1);\n          }\n        }\n        // in this case the proposal becomes rejected after being accepted or becomes accepted after being rejected:\n        else if(_newstatus != proposaldata.prestatus){\n\n         if(_newstatus == ProposalStatus.Accepted){\n          period.againstprops = period.againstprops.sub(1);\n          period.forprops = period.forprops.add(1);\n         }\n         // in this case proposal is necessarily Rejected:\n         else {\n          period.forprops = period.forprops.sub(1);\n          period.againstprops = period.againstprops.add(1);\n         }\n\n        }\n        // updates period forvotes and againstvotes system done\n\n         // Proposal and Period new weight\n         if (_istie) {\n         proposaldata.prestatus =  ProposalStatus.Rejected;\n         proposaldata.lastcuration_weight = 0;\n         proposaldata.lasteditor_weight = 0;\n         // Proposal tied, remove proposal curation and editor sum\n         period.curation_sum = period.curation_sum.sub(_old_proposal_curationweight);\n         period.editor_sum = period.editor_sum.sub(_old_proposal_editorweight);\n         }\n         else {\n             // Proposal approved, strengthen curation sum\n         if (_isapproved){\n             proposaldata.prestatus =  ProposalStatus.Accepted;\n             proposaldata.lastcuration_weight = proposaldata.forvotes;\n             proposaldata.lasteditor_weight = proposaldata.forvotes;\n             // Proposal approved, replace proposal curation and editor sum with forvotes\n             period.curation_sum = period.curation_sum.sub(_old_proposal_curationweight).add(proposaldata.lastcuration_weight);\n             period.editor_sum = period.editor_sum.sub(_old_proposal_editorweight).add(proposaldata.lasteditor_weight);\n         }\n         else{\n             proposaldata.prestatus =  ProposalStatus.Rejected;\n             proposaldata.lastcuration_weight = proposaldata.againstvotes;\n             proposaldata.lasteditor_weight = 0;\n             // Proposal rejected, replace proposal curation sum with againstvotes and remove proposal editor sum\n             period.curation_sum = period.curation_sum.sub(_old_proposal_curationweight).add(proposaldata.lastcuration_weight);\n             period.editor_sum = period.editor_sum.sub(_old_proposal_editorweight);\n         }\n         }\n         \n        // resets commit to save space: \n        _removecommit(_votehash);\n        emit NewReveal(msg.sender, proposal.proposed_release_ha","contract":"EticaRelease","time":0},{"type":"external-function ","before":" }\n\n\n    function createchunk(bytes32 _diseasehash, string memory _title, string memory _description) public {\n\n  //check if the disease exits\n  require(diseasesbyIds[_diseasehash] > 0 && diseasesbyIds[_diseasehash] <= diseasesCounter);\n  if(diseases[diseasesbyIds[_diseasehash]].disease_hash != _diseasehash) revert(); // second check not necessary but I decided to add it as the gas cost value for security is worth it\n\n  // --- REQUIRE PAYMENT FOR ADDING A CHUNK TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\n  uint _cost = DISEASE_CREATION_AMOUNT.div(20);\n  // make sure the user has enough ETI to create a chunk\n  require(balances[msg.sender] >= _cost);\n  // transfer DISEASE_CREATION_AMOUNT / 20  ETI from user wallet to contract wallet:\n  transfer(address(this), _cost);\n\n  // --- REQUIRE PAYMENT FOR ADDING A CHUNK TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\n\n  chunksCounter = chunksCounter.add(1); // get general id of Chunk\n\n  // updates disease's chunks infos:\n  diseaseChunksCounter[_diseasehash] = diseaseChunksCounter[_diseasehash].add(1); // Increase chunks index of Disease\n  diseasechunks[_diseasehash][diseaseChunksCounter[_diseasehash]] = chunksCounter;\n  \n\n  // store the Chunk\n   chunks[chunksCounter] = Chunk(\n     chunksCounter, // general id of the chunk\n     _diseasehash, // disease of the chunk\n     diseaseChunksCounter[_diseasehash], // Index of chunk within disease\n     _title,\n     _description\n   );\n\n  UNRECOVERABLE_ETI = UNRECOVERABLE_ETI.add(_cost);\n  emit NewChunk(chunksCounter, _diseaseha","after":" }\n\n\n    function createchunk(bytes32 _diseasehash, string calldata _title, string calldata _description) public {\n\n  //check if the disease exits\n  require(diseasesbyIds[_diseasehash] > 0 && diseasesbyIds[_diseasehash] <= diseasesCounter);\n  if(diseases[diseasesbyIds[_diseasehash]].disease_hash != _diseasehash) revert(); // second check not necessary but I decided to add it as the gas cost value for security is worth it\n\n  // --- REQUIRE PAYMENT FOR ADDING A CHUNK TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\n  uint _cost = DISEASE_CREATION_AMOUNT.div(20);\n  // make sure the user has enough ETI to create a chunk\n  require(balances[msg.sender] >= _cost);\n  // transfer DISEASE_CREATION_AMOUNT / 20  ETI from user wallet to contract wallet:\n  transfer(address(this), _cost);\n\n  // --- REQUIRE PAYMENT FOR ADDING A CHUNK TO CREATE A BARRIER TO ENTRY AND AVOID SPAM --- //\n\n  chunksCounter = chunksCounter.add(1); // get general id of Chunk\n\n  // updates disease's chunks infos:\n  diseaseChunksCounter[_diseasehash] = diseaseChunksCounter[_diseasehash].add(1); // Increase chunks index of Disease\n  diseasechunks[_diseasehash][diseaseChunksCounter[_diseasehash]] = chunksCounter;\n  \n\n  // store the Chunk\n   chunks[chunksCounter] = Chunk(\n     chunksCounter, // general id of the chunk\n     _diseasehash, // disease of the chunk\n     diseaseChunksCounter[_diseasehash], // Index of chunk within disease\n     _title,\n     _description\n   );\n\n  UNRECOVERABLE_ETI = UNRECOVERABLE_ETI.add(_cost);\n  emit NewChunk(chunksCounter, _diseaseha","contract":"EticaRelease","time":0},{"type":"constant-restrict-modification  ","before":"----  */\nuint public REWARD_INTERVAL ","after":"----  */\nuint public constant REWARD_INTERVAL ","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":" 7 jours\nuint public STAKING_DURATION =","after":" 7 jours\nuint public constant STAKING_DURATION =","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":"28 jours\nuint public DEFAULT_VOTING_TIME =","after":"28 jours\nuint public constant DEFAULT_VOTING_TIME =","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":" 21 days\nuint public DEFAULT_REVEALING_TIME ","after":" 21 days\nuint public constant DEFAULT_REVEALING_TIME ","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":"n 60.00%\nuint public PERIODS_PER_THRES","after":"n 60.00%\nuint public PERIODS_PER_THRES","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":"HRESHOLD\nuint public SEVERITY_L","after":"HRESHOLD\nuint public SEVERITY_L","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":"g voters\nuint public PROPOSERS_INCRE","after":"g voters\nuint public PROPOSERS_INCRE","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":"roposers\nuint public PROTOCOL_RATIO_TARGE","after":"roposers\nuint public PROTOCOL_RATIO_TARGE","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":"nt;\n\n    string public name =","after":"nt;\n\n    string public constant name =","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":"ca\";\n    string public symbol","after":"ca\";\n    string public constant symbol","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":"TI\";\n    uint public decim","after":"TI\";\n    uint public decim","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":"TI)\n\n    uint public PERIOD_CURATION_REWARD_RATIO = 381","after":"TI)\n\n    uint public constant PERIOD_CURATION_REWARD_RATIO = 381","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":"ward\n    uint public PERIOD_EDITOR_REWARD_RATIO = 618","after":"ward\n    uint public constant PERIOD_EDITOR_REWARD_RATIO = 618","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":"ed\n\n\n    uint public _BLOCKS_PER_READJUSTMEN","after":"ed\n\n\n    uint public _BLOCKS_PER_READJUSTMEN","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":"mber\n    uint public  _MINIMUM_TARGE","after":"mber\n    uint public  _MINIMUM_TARGE","contract":"EticaRelease","time":1},{"type":"constant-restrict-modification  ","before":"rder\n    uint public  _MAXIMUM_TARGET ","after":"rder\n    uint public  constant _MAXIMUM_TARGET ","contract":"EticaRelease","time":1}]}