{"time":201,"results":[{"type":"external-function ","before":"function freezeAccounts(address[] memory targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","after":"function freezeAccounts(address[] calldata targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function lockupAccounts(address[] memory targets, uint[] memory unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","after":"function lockupAccounts(address[] calldata targets, uint[] calldata unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function freezeAccounts(address[] memory targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","after":"function freezeAccounts(address[] calldata targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function lockupAccounts(address[] memory targets, uint[] memory unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","after":"function lockupAccounts(address[] calldata targets, uint[] calldata unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function freezeAccounts(address[] memory targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","after":"function freezeAccounts(address[] calldata targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function lockupAccounts(address[] memory targets, uint[] memory unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","after":"function lockupAccounts(address[] calldata targets, uint[] calldata unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"constant-restrict-modification  ","before":"string public name = \"CryptoHarborExchangeGameToken\";","after":"string public constant name = \"CryptoHarborExchangeGameToken\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public symbol = \"CHEG\";","after":"string public constant symbol = \"CHEG\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint public decimals = 8;","after":"uint public constant decimals = 8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public initialSupply = 1e8 * 1e8;","after":"uint256 public constant initialSupply = 1e8 * 1e8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public name = \"CryptoHarborExchangeGameToken\";","after":"string public constant name = \"CryptoHarborExchangeGameToken\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public symbol = \"CHEG\";","after":"string public constant symbol = \"CHEG\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint public decimals = 8;","after":"uint public constant decimals = 8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public initialSupply = 1e8 * 1e8;","after":"uint256 public constant initialSupply = 1e8 * 1e8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public name = \"CryptoHarborExchangeGameToken\";","after":"string public constant name = \"CryptoHarborExchangeGameToken\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public symbol = \"CHEG\";","after":"string public constant symbol = \"CHEG\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint public decimals = 8;","after":"uint public constant decimals = 8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public initialSupply = 1e8 * 1e8;","after":"uint256 public constant initialSupply = 1e8 * 1e8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"external-function ","before":"function freezeAccounts(address[] memory targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","after":"function freezeAccounts(address[] calldata targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function lockupAccounts(address[] memory targets, uint[] memory unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","after":"function lockupAccounts(address[] calldata targets, uint[] calldata unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function freezeAccounts(address[] memory targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","after":"function freezeAccounts(address[] calldata targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function lockupAccounts(address[] memory targets, uint[] memory unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","after":"function lockupAccounts(address[] calldata targets, uint[] calldata unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function freezeAccounts(address[] memory targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","after":"function freezeAccounts(address[] calldata targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function lockupAccounts(address[] memory targets, uint[] memory unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","after":"function lockupAccounts(address[] calldata targets, uint[] calldata unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"constant-restrict-modification  ","before":"string public name = \"CryptoHarborExchangeGameToken\";","after":"string public constant name = \"CryptoHarborExchangeGameToken\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public symbol = \"CHEG\";","after":"string public constant symbol = \"CHEG\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint public decimals = 8;","after":"uint public constant decimals = 8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public initialSupply = 1e8 * 1e8;","after":"uint256 public constant initialSupply = 1e8 * 1e8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public name = \"CryptoHarborExchangeGameToken\";","after":"string public constant name = \"CryptoHarborExchangeGameToken\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public symbol = \"CHEG\";","after":"string public constant symbol = \"CHEG\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint public decimals = 8;","after":"uint public constant decimals = 8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public initialSupply = 1e8 * 1e8;","after":"uint256 public constant initialSupply = 1e8 * 1e8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public name = \"CryptoHarborExchangeGameToken\";","after":"string public constant name = \"CryptoHarborExchangeGameToken\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public symbol = \"CHEG\";","after":"string public constant symbol = \"CHEG\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint public decimals = 8;","after":"uint public constant decimals = 8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public initialSupply = 1e8 * 1e8;","after":"uint256 public constant initialSupply = 1e8 * 1e8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"external-function ","before":"function freezeAccounts(address[] memory targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","after":"function freezeAccounts(address[] calldata targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function lockupAccounts(address[] memory targets, uint[] memory unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","after":"function lockupAccounts(address[] calldata targets, uint[] calldata unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public returns (bool success){\r\n        // Standard function transfer similar to ERC20 transfer with no _data .\r\n        // Added due to backwards compatibility reasons .\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(Address.isContract(_to)) {\r\n            IERC223Recipient receiver = IERC223Recipient(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        emit Transfer(msg.sender, _to, _value, _data);\r\n        return true;\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function freezeAccounts(address[] memory targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","after":"function freezeAccounts(address[] calldata targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function lockupAccounts(address[] memory targets, uint[] memory unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","after":"function lockupAccounts(address[] calldata targets, uint[] calldata unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function freezeAccounts(address[] memory targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","after":"function freezeAccounts(address[] calldata targets, bool isFrozen) onlyOwner public {\r\n        require(targets.length > 0);\r\n\r\n        for (uint j = 0; j < targets.length; j++) {\r\n            require(targets[j] != owner);\r\n            frozenAccount[targets[j]] = isFrozen;\r\n            emit FrozenFunds(targets[j], isFrozen);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function lockupAccounts(address[] memory targets, uint[] memory unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","after":"function lockupAccounts(address[] calldata targets, uint[] calldata unixTimes) onlyOwner public {\r\n        require(targets.length > 0\r\n                && targets.length == unixTimes.length);\r\n                \r\n        for(uint j = 0; j < targets.length; j++){\r\n            require(unlockUnixTime[targets[j]] < unixTimes[j]);\r\n            unlockUnixTime[targets[j]] = unixTimes[j];\r\n            emit LockedFunds(targets[j], unixTimes[j]);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"external-function ","before":"function transfer(address _to, uint _value, bytes memory _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","after":"function transfer(address _to, uint _value, bytes calldata _data) public  returns (bool success) {\r\n        require(_value > 0\r\n                && frozenAccount[msg.sender] == false \r\n                && frozenAccount[_to] == false\r\n                && now > unlockUnixTime[msg.sender] \r\n                && now > unlockUnixTime[_to]);\r\n\r\n        if (!isContract(_to)) {\r\n            return transferToAddress(_to, _value, _data);\r\n        }\r\n    }","contract":"CryptoHarborExchangeGameToken","time":0},{"type":"constant-restrict-modification  ","before":"string public name = \"CryptoHarborExchangeGameToken\";","after":"string public constant name = \"CryptoHarborExchangeGameToken\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public symbol = \"CHEG\";","after":"string public constant symbol = \"CHEG\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint public decimals = 8;","after":"uint public constant decimals = 8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public initialSupply = 1e8 * 1e8;","after":"uint256 public constant initialSupply = 1e8 * 1e8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public name = \"CryptoHarborExchangeGameToken\";","after":"string public constant name = \"CryptoHarborExchangeGameToken\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public symbol = \"CHEG\";","after":"string public constant symbol = \"CHEG\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint public decimals = 8;","after":"uint public constant decimals = 8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public initialSupply = 1e8 * 1e8;","after":"uint256 public constant initialSupply = 1e8 * 1e8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public name = \"CryptoHarborExchangeGameToken\";","after":"string public constant name = \"CryptoHarborExchangeGameToken\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"string public symbol = \"CHEG\";","after":"string public constant symbol = \"CHEG\";","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint public decimals = 8;","after":"uint public constant decimals = 8;","contract":"CryptoHarborExchangeGameToken","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public initialSupply = 1e8 * 1e8;","after":"uint256 public constant initialSupply = 1e8 * 1e8;","contract":"CryptoHarborExchangeGameToken","time":1}]}