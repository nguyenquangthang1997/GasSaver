{"time":254,"results":[{"type":"struct-data-arrangement ","before":"\naddress token\naddress recipient\nuint amount\nbool unwrap","after":"uint amount\naddress token\naddress recipient\nbool unwrap\n","contract":"Types","time":0},{"type":"external-function ","before":"function transfer(Types.Request memory request) public {\n    validateRequest(request);\n    \n    Types.TransferRequest memory transferRequest = request.decodeTransferRequest();\n    address payable depositAddress = registry.depositAddressOf(request.owner);\n\n    _transfer(\n      transferRequest.token, \n      depositAddress, \n      transferRequest.recipient, \n      transferRequest.amount, \n      transferRequest.unwrap\n    );\n\n    completeRequest(request);\n  }","after":"function transfer(Types.Request calldata request) public {\n    validateRequest(request);\n    \n    Types.TransferRequest memory transferRequest = request.decodeTransferRequest();\n    address payable depositAddress = registry.depositAddressOf(request.owner);\n\n    _transfer(\n      transferRequest.token, \n      depositAddress, \n      transferRequest.recipient, \n      transferRequest.amount, \n      transferRequest.unwrap\n    );\n\n    completeRequest(request);\n  }","contract":"DolomiteDirectV1","time":0},{"type":"external-function ","before":"function brokerRequestAllowance(BrokerData.BrokerApprovalRequest memory request) public returns (bool) {\n    require(msg.sender == loopringDelegate);\n\n    BrokerData.BrokerOrder[] memory mergedOrders = new BrokerData.BrokerOrder[](request.orders.length);\n    uint numMergedOrders = 1;\n\n    mergedOrders[0] = request.orders[0];\n    \n    if (request.orders.length > 1) {\n      for (uint i = 1; i < request.orders.length; i++) {\n        bool isDuplicate = false;\n\n        for (uint b = 0; b < numMergedOrders; b++) {\n          if (request.orders[i].owner == mergedOrders[b].owner) {\n            mergedOrders[b].requestedAmountS += request.orders[i].requestedAmountS;\n            mergedOrders[b].requestedFeeAmount += request.orders[i].requestedFeeAmount;\n            isDuplicate = true;\n            break;\n          }\n        }\n\n        if (!isDuplicate) {\n          mergedOrders[numMergedOrders] = request.orders[i];\n          numMergedOrders += 1;\n        }\n      }\n    }\n\n    for (uint j = 0; j < numMergedOrders; j++) {\n      BrokerData.BrokerOrder memory order = mergedOrders[j];\n      address payable depositAddress = registry.depositAddressOf(order.owner);\n      \n      _transfer(request.tokenS, depositAddress, address(this), order.requestedAmountS, false);\n      if (order.requestedFeeAmount > 0) _transfer(request.feeToken, depositAddress, address(this), order.requestedFeeAmount, false);\n    }\n\n    return false; // Does not use onOrderFillReport\n  }","after":"function brokerRequestAllowance(BrokerData.BrokerApprovalRequest calldata request) public returns (bool) {\n    require(msg.sender == loopringDelegate);\n\n    BrokerData.BrokerOrder[] memory mergedOrders = new BrokerData.BrokerOrder[](request.orders.length);\n    uint numMergedOrders = 1;\n\n    mergedOrders[0] = request.orders[0];\n    \n    if (request.orders.length > 1) {\n      for (uint i = 1; i < request.orders.length; i++) {\n        bool isDuplicate = false;\n\n        for (uint b = 0; b < numMergedOrders; b++) {\n          if (request.orders[i].owner == mergedOrders[b].owner) {\n            mergedOrders[b].requestedAmountS += request.orders[i].requestedAmountS;\n            mergedOrders[b].requestedFeeAmount += request.orders[i].requestedFeeAmount;\n            isDuplicate = true;\n            break;\n          }\n        }\n\n        if (!isDuplicate) {\n          mergedOrders[numMergedOrders] = request.orders[i];\n          numMergedOrders += 1;\n        }\n      }\n    }\n\n    for (uint j = 0; j < numMergedOrders; j++) {\n      BrokerData.BrokerOrder memory order = mergedOrders[j];\n      address payable depositAddress = registry.depositAddressOf(order.owner);\n      \n      _transfer(request.tokenS, depositAddress, address(this), order.requestedAmountS, false);\n      if (order.requestedFeeAmount > 0) _transfer(request.feeToken, depositAddress, address(this), order.requestedFeeAmount, false);\n    }\n\n    return false; // Does not use onOrderFillReport\n  }","contract":"DolomiteDirectV1","time":0},{"type":"external-function ","before":"function brokerRequestAllowance(BrokerData.BrokerApprovalRequest memory request) public returns (bool) {\n    require(msg.sender == loopringProtocol, \"Uniswap MakerBroker: Unauthorized caller\");\n    require(tokenToIsSetup[request.tokenS], \"Uniswap MakerBroker: tokenS is not setup yet\");\n\n    for (uint i = 0; i < request.orders.length; i++) {\n      require(request.orders[i].tokenRecipient == address(this), \"Uniswap MakerBroker: Order tokenRecipient must be this broker\");\n      require(request.orders[i].owner == owner, \"Uniswap MakerBroker: Order owner must be the owner of this contract\");\n    }\n\n    if (request.tokenB == wethTokenAddress) {\n      // We need to convert WETH to ETH to 1) avoid double fee payment on Uniswap and 2) get the best price on Uniswap\n      WETH(wethTokenAddress).withdraw(request.totalFillAmountB);\n    }\n\n    // perform exchange\n    bool isTokenBExchangeWrapper = abi.decode(request.orders[0].extraData, (bool));\n    IUniswapExchange exchange;\n    if (isTokenBExchangeWrapper) {\n      exchange = IUniswapExchange(address(uint160(tokenToExchange[request.tokenB])));\n    } else {\n      exchange = IUniswapExchange(address(uint160(tokenToExchange[request.tokenS])));\n    }\n\n    uint deadline = block.timestamp + 1;\n    uint exchangeAmount;\n    if (request.tokenS == wethTokenAddress) {\n      exchangeAmount = exchange.tokenToEthSwapInput(request.totalFillAmountB, request.totalRequestedAmountS, deadline);\n    } else if (request.tokenB == wethTokenAddress) {\n      exchangeAmount = exchange.ethToTokenSwapInput.value(request.totalFillAmountB)(request.totalRequestedAmountS, deadline);\n    } else {\n      // Pure token to token\n      address tokenToBuy;\n      if (isTokenBExchangeWrapper) {\n        request.tokenS;\n      } else {\n        request.tokenB;\n      }\n      exchangeAmount = exchange.tokenToTokenSwapInput(\n        request.totalFillAmountB,\n        request.totalRequestedAmountS,\n      /* minEthBoughtInWei */ 1, // We don't care about the token <-> ETH exchange rate as long as we get enough tokenB\n        deadline,\n        tokenToBuy);\n    }\n\n    if (request.tokenS == wethTokenAddress) {\n      // Orders on Dolomite require we use WETH instead of ETH, so we must convert it back\n      WETH(wethTokenAddress).deposit.value(exchangeAmount)();\n    }\n\n    return false;\n  }","after":"function brokerRequestAllowance(BrokerData.BrokerApprovalRequest calldata request) public returns (bool) {\n    require(msg.sender == loopringProtocol, \"Uniswap MakerBroker: Unauthorized caller\");\n    require(tokenToIsSetup[request.tokenS], \"Uniswap MakerBroker: tokenS is not setup yet\");\n\n    for (uint i = 0; i < request.orders.length; i++) {\n      require(request.orders[i].tokenRecipient == address(this), \"Uniswap MakerBroker: Order tokenRecipient must be this broker\");\n      require(request.orders[i].owner == owner, \"Uniswap MakerBroker: Order owner must be the owner of this contract\");\n    }\n\n    if (request.tokenB == wethTokenAddress) {\n      // We need to convert WETH to ETH to 1) avoid double fee payment on Uniswap and 2) get the best price on Uniswap\n      WETH(wethTokenAddress).withdraw(request.totalFillAmountB);\n    }\n\n    // perform exchange\n    bool isTokenBExchangeWrapper = abi.decode(request.orders[0].extraData, (bool));\n    IUniswapExchange exchange;\n    if (isTokenBExchangeWrapper) {\n      exchange = IUniswapExchange(address(uint160(tokenToExchange[request.tokenB])));\n    } else {\n      exchange = IUniswapExchange(address(uint160(tokenToExchange[request.tokenS])));\n    }\n\n    uint deadline = block.timestamp + 1;\n    uint exchangeAmount;\n    if (request.tokenS == wethTokenAddress) {\n      exchangeAmount = exchange.tokenToEthSwapInput(request.totalFillAmountB, request.totalRequestedAmountS, deadline);\n    } else if (request.tokenB == wethTokenAddress) {\n      exchangeAmount = exchange.ethToTokenSwapInput.value(request.totalFillAmountB)(request.totalRequestedAmountS, deadline);\n    } else {\n      // Pure token to token\n      address tokenToBuy;\n      if (isTokenBExchangeWrapper) {\n        request.tokenS;\n      } else {\n        request.tokenB;\n      }\n      exchangeAmount = exchange.tokenToTokenSwapInput(\n        request.totalFillAmountB,\n        request.totalRequestedAmountS,\n      /* minEthBoughtInWei */ 1, // We don't care about the token <-> ETH exchange rate as long as we get enough tokenB\n        deadline,\n        tokenToBuy);\n    }\n\n    if (request.tokenS == wethTokenAddress) {\n      // Orders on Dolomite require we use WETH instead of ETH, so we must convert it back\n      WETH(wethTokenAddress).deposit.value(exchangeAmount)();\n    }\n\n    return false;\n  }","contract":"UniswapMakerBroker","time":0}]}