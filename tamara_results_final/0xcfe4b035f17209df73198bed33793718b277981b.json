{"time":135,"results":[{"type":"external-function ","before":"function registerPullPayment(\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bytes32[4] memory _paymentDetails, // 0 paymentID, 1 businessID, 2 uniqueReferenceID, 3 paymentType\n        address[3] memory _addresses, // 0 customer, 1 pull payment executor, 2 treasury\n        uint256[3] memory _paymentAmounts, // 0 _initialConversionRate, 1 _fiatAmountInCents, 2 _initialPaymentAmountInCents\n        uint256[4] memory _paymentTimestamps, // 0 _frequency, 1 _numberOfPayments, 2 _startTimestamp, 3 _trialPeriod\n        string memory _currency\n    )\n    public\n    isExecutor()\n    {\n        require(pullPayments[_addresses[0]][_addresses[1]].paymentIds[0] == \"\", \"Pull Payment already exists.\");\n        require(_paymentDetails[0] != EMPTY_BYTES32, \"Payment ID is empty.\");\n        require(_paymentDetails[1] != EMPTY_BYTES32, \"Business ID is empty.\");\n        require(_paymentDetails[2] != EMPTY_BYTES32, \"Unique Reference ID is empty.\");\n        require(_paymentDetails[3] != EMPTY_BYTES32, \"Payment Type is empty.\");\n        require(_addresses[0] != address(0), \"Customer Address is ZERO_ADDRESS.\");\n        require(_addresses[1] != address(0), \"Pull Payment Executor Address is ZERO_ADDRESS.\");\n        require(_addresses[2] != address(0), \"Treasury Address is ZERO_ADDRESS.\");\n        require(_paymentAmounts[0] > 0, \"Initial conversion rate is zero.\");\n        require(_paymentAmounts[1] > 0, \"Payment amount in fiat is zero.\");\n        require(_paymentAmounts[2] >= 0, \"Initial payment amount in fiat is less than zero.\");\n        require(_paymentTimestamps[0] > 0, \"Payment frequency is zero.\");\n        require(_paymentTimestamps[1] > 0, \"Payment number of payments is zero.\");\n        require(_paymentTimestamps[2] > 0, \"Payment start time is zero.\");\n        require(_paymentTimestamps[3] >= 0, \"Payment trial period is less than zero.\");\n        require(_paymentAmounts[0] <= OVERFLOW_LIMITER_NUMBER, \"Initial conversion rate is higher thant the overflow limit.\");\n        require(_paymentAmounts[1] <= OVERFLOW_LIMITER_NUMBER, \"Payment amount in fiat is higher thant the overflow limit.\");\n        require(_paymentAmounts[2] <= OVERFLOW_LIMITER_NUMBER, \"Payment initial amount in fiat is higher thant the overflow limit.\");\n        require(_paymentTimestamps[0] <= OVERFLOW_LIMITER_NUMBER, \"Payment frequency is higher thant the overflow limit.\");\n        require(_paymentTimestamps[1] <= OVERFLOW_LIMITER_NUMBER, \"Payment number of payments is higher thant the overflow limit.\");\n        require(_paymentTimestamps[2] <= OVERFLOW_LIMITER_NUMBER, \"Payment start time is higher thant the overflow limit.\");\n        require(_paymentTimestamps[3] <= OVERFLOW_LIMITER_NUMBER, \"Payment trial period is higher thant the overflow limit.\");\n        require(bytes(_currency).length > 0, \"Currency is empty\");\n        pullPayments[_addresses[0]][_addresses[1]].paymentIds[0] = _paymentDetails[0];\n        pullPayments[_addresses[0]][_addresses[1]].paymentType = _paymentDetails[3];\n        pullPayments[_addresses[0]][_addresses[1]].treasuryAddress = _addresses[2];\n        pullPayments[_addresses[0]][_addresses[1]].initialConversionRate = _paymentAmounts[0];\n        pullPayments[_addresses[0]][_addresses[1]].fiatAmountInCents = _paymentAmounts[1];\n        pullPayments[_addresses[0]][_addresses[1]].initialPaymentAmountInCents = _paymentAmounts[2];\n        pullPayments[_addresses[0]][_addresses[1]].frequency = _paymentTimestamps[0];\n        pullPayments[_addresses[0]][_addresses[1]].numberOfPayments = _paymentTimestamps[1];\n        pullPayments[_addresses[0]][_addresses[1]].startTimestamp = _paymentTimestamps[2];\n        pullPayments[_addresses[0]][_addresses[1]].trialPeriod = _paymentTimestamps[3];\n        pullPayments[_addresses[0]][_addresses[1]].currency = _currency;\n        require(isValidRegistration(\n                v,\n                r,\n                s,\n                _addresses[0],\n                _addresses[1],\n                pullPayments[_addresses[0]][_addresses[1]]),\n            \"Invalid pull payment registration - ECRECOVER_FAILED\"\n        );\n        pullPayments[_addresses[0]][_addresses[1]].paymentIds[1] = _paymentDetails[1];\n        pullPayments[_addresses[0]][_addresses[1]].paymentIds[2] = _paymentDetails[2];\n        pullPayments[_addresses[0]][_addresses[1]].cancelTimestamp = 0;\n        /// @dev In case of a free trial period the start timestamp of the payment\n        /// is the start timestamp that was signed by the customer + the trial period.\n        /// A payment is not needed during registration.\n        if (_paymentDetails[3] == TYPE_PULL_PAYMENT_WITH_FREE_TRIAL) {\n            pullPayments[_addresses[0]][_addresses[1]].nextPaymentTimestamp = _paymentTimestamps[2] + _paymentTimestamps[3];\n            pullPayments[_addresses[0]][_addresses[1]].lastPaymentTimestamp = 0;\n            /// @dev In case of a recurring payment with initial amount\n            /// the first payment of the 'initialPaymentAmountInCents' and 'initialConversionRate'\n            /// will happen on registration.\n            /// Once it happens, we set the next payment timestamp as\n            /// the start timestamp signed by the customer + trial period\n        } else if (_paymentDetails[3] == TYPE_RECURRING_PULL_PAYMENT_WITH_INITIAL) {\n            executePullPaymentOnRegistration(\n                [_paymentDetails[0], _paymentDetails[1], _paymentDetails[2]], // 0 paymentID, 1 businessID, 2 uniqueReferenceID\n                [_addresses[0], _addresses[2]], // 0 Customer Address, 1 Treasury Address\n                [_paymentAmounts[2], _paymentAmounts[0]] // 0 initialPaymentAmountInCents, 1 initialConversionRate\n            );\n            pullPayments[_addresses[0]][_addresses[1]].lastPaymentTimestamp = now;\n            pullPayments[_addresses[0]][_addresses[1]].nextPaymentTimestamp = _paymentTimestamps[2] + _paymentTimestamps[0];\n            /// @dev In the case od a paid trial, the first payment happens\n            /// on registration using the 'initialPaymentAmountInCents' and 'initialConversionRate'.\n            /// When the first payment takes place we set the next payment timestamp\n            /// as the start timestamp that was signed by the customer + the trial period\n        } else if (_paymentDetails[3] == TYPE_PULL_PAYMENT_WITH_PAID_TRIAL) {\n            executePullPaymentOnRegistration(\n                [_paymentDetails[0], _paymentDetails[1], _paymentDetails[2]], /// paymentID , businessID , uniqueReferenceID\n                [_addresses[0], _addresses[2]], /// 0 Customer Address, 1 Treasury Address\n                [_paymentAmounts[2], _paymentAmounts[0]] /// 0 initialPaymentAmountInCents, 1 initialConversionRate\n            );\n            pullPayments[_addresses[0]][_addresses[1]].lastPaymentTimestamp = now;\n            pullPayments[_addresses[0]][_addresses[1]].nextPaymentTimestamp = _paymentTimestamps[2] + _paymentTimestamps[3];\n            /// @dev For the rest of the cases the first payment happens on registration\n            /// using the 'fiatAmountInCents' and 'initialConversionRate'.\n            /// When the first payment takes place, the number of payment is decreased by 1,\n            /// and the next payment timestamp is set to the start timestamp signed by the\n            /// customer + the frequency of the payment.\n        } else {\n            executePullPaymentOnRegistration(\n                [_paymentDetails[0], _paymentDetails[1], _paymentDetails[2]], /// paymentID , businessID , uniqueReferenceID\n                [_addresses[0], _addresses[2]], /// Customer Address, Treasury Address\n                [_paymentAmounts[1], _paymentAmounts[0]] /// fiatAmountInCents, initialConversionRate\n            );\n            pullPayments[_addresses[0]][_addresses[1]].lastPaymentTimestamp = now;\n            pullPayments[_addresses[0]][_addresses[1]].nextPaymentTimestamp = _paymentTimestamps[2] + _paymentTimestamps[0];\n            pullPayments[_addresses[0]][_addresses[1]].numberOfPayments = _paymentTimestamps[1] - 1;\n        }\n        if (isFundingNeeded(msg.sender)) {\n            msg.sender.transfer(FUNDING_AMOUNT);\n            emit LogSmartContractActorFunded(\"executor\", msg.sender, now);\n        }\n        emit LogPaymentRegistered(_addresses[0], _paymentDetails[0], _paymentDetails[1], _paymentDetails[2]);\n    }","after":"function registerPullPayment(\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bytes32[4] calldata _paymentDetails, // 0 paymentID, 1 businessID, 2 uniqueReferenceID, 3 paymentType\n        address[3] calldata _addresses, // 0 customer, 1 pull payment executor, 2 treasury\n        uint256[3] calldata _paymentAmounts, // 0 _initialConversionRate, 1 _fiatAmountInCents, 2 _initialPaymentAmountInCents\n        uint256[4] calldata _paymentTimestamps, // 0 _frequency, 1 _numberOfPayments, 2 _startTimestamp, 3 _trialPeriod\n        string calldata _currency\n    )\n    public\n    isExecutor()\n    {\n        require(pullPayments[_addresses[0]][_addresses[1]].paymentIds[0] == \"\", \"Pull Payment already exists.\");\n        require(_paymentDetails[0] != EMPTY_BYTES32, \"Payment ID is empty.\");\n        require(_paymentDetails[1] != EMPTY_BYTES32, \"Business ID is empty.\");\n        require(_paymentDetails[2] != EMPTY_BYTES32, \"Unique Reference ID is empty.\");\n        require(_paymentDetails[3] != EMPTY_BYTES32, \"Payment Type is empty.\");\n        require(_addresses[0] != address(0), \"Customer Address is ZERO_ADDRESS.\");\n        require(_addresses[1] != address(0), \"Pull Payment Executor Address is ZERO_ADDRESS.\");\n        require(_addresses[2] != address(0), \"Treasury Address is ZERO_ADDRESS.\");\n        require(_paymentAmounts[0] > 0, \"Initial conversion rate is zero.\");\n        require(_paymentAmounts[1] > 0, \"Payment amount in fiat is zero.\");\n        require(_paymentAmounts[2] >= 0, \"Initial payment amount in fiat is less than zero.\");\n        require(_paymentTimestamps[0] > 0, \"Payment frequency is zero.\");\n        require(_paymentTimestamps[1] > 0, \"Payment number of payments is zero.\");\n        require(_paymentTimestamps[2] > 0, \"Payment start time is zero.\");\n        require(_paymentTimestamps[3] >= 0, \"Payment trial period is less than zero.\");\n        require(_paymentAmounts[0] <= OVERFLOW_LIMITER_NUMBER, \"Initial conversion rate is higher thant the overflow limit.\");\n        require(_paymentAmounts[1] <= OVERFLOW_LIMITER_NUMBER, \"Payment amount in fiat is higher thant the overflow limit.\");\n        require(_paymentAmounts[2] <= OVERFLOW_LIMITER_NUMBER, \"Payment initial amount in fiat is higher thant the overflow limit.\");\n        require(_paymentTimestamps[0] <= OVERFLOW_LIMITER_NUMBER, \"Payment frequency is higher thant the overflow limit.\");\n        require(_paymentTimestamps[1] <= OVERFLOW_LIMITER_NUMBER, \"Payment number of payments is higher thant the overflow limit.\");\n        require(_paymentTimestamps[2] <= OVERFLOW_LIMITER_NUMBER, \"Payment start time is higher thant the overflow limit.\");\n        require(_paymentTimestamps[3] <= OVERFLOW_LIMITER_NUMBER, \"Payment trial period is higher thant the overflow limit.\");\n        require(bytes(_currency).length > 0, \"Currency is empty\");\n        pullPayments[_addresses[0]][_addresses[1]].paymentIds[0] = _paymentDetails[0];\n        pullPayments[_addresses[0]][_addresses[1]].paymentType = _paymentDetails[3];\n        pullPayments[_addresses[0]][_addresses[1]].treasuryAddress = _addresses[2];\n        pullPayments[_addresses[0]][_addresses[1]].initialConversionRate = _paymentAmounts[0];\n        pullPayments[_addresses[0]][_addresses[1]].fiatAmountInCents = _paymentAmounts[1];\n        pullPayments[_addresses[0]][_addresses[1]].initialPaymentAmountInCents = _paymentAmounts[2];\n        pullPayments[_addresses[0]][_addresses[1]].frequency = _paymentTimestamps[0];\n        pullPayments[_addresses[0]][_addresses[1]].numberOfPayments = _paymentTimestamps[1];\n        pullPayments[_addresses[0]][_addresses[1]].startTimestamp = _paymentTimestamps[2];\n        pullPayments[_addresses[0]][_addresses[1]].trialPeriod = _paymentTimestamps[3];\n        pullPayments[_addresses[0]][_addresses[1]].currency = _currency;\n        require(isValidRegistration(\n                v,\n                r,\n                s,\n                _addresses[0],\n                _addresses[1],\n                pullPayments[_addresses[0]][_addresses[1]]),\n            \"Invalid pull payment registration - ECRECOVER_FAILED\"\n        );\n        pullPayments[_addresses[0]][_addresses[1]].paymentIds[1] = _paymentDetails[1];\n        pullPayments[_addresses[0]][_addresses[1]].paymentIds[2] = _paymentDetails[2];\n        pullPayments[_addresses[0]][_addresses[1]].cancelTimestamp = 0;\n        /// @dev In case of a free trial period the start timestamp of the payment\n        /// is the start timestamp that was signed by the customer + the trial period.\n        /// A payment is not needed during registration.\n        if (_paymentDetails[3] == TYPE_PULL_PAYMENT_WITH_FREE_TRIAL) {\n            pullPayments[_addresses[0]][_addresses[1]].nextPaymentTimestamp = _paymentTimestamps[2] + _paymentTimestamps[3];\n            pullPayments[_addresses[0]][_addresses[1]].lastPaymentTimestamp = 0;\n            /// @dev In case of a recurring payment with initial amount\n            /// the first payment of the 'initialPaymentAmountInCents' and 'initialConversionRate'\n            /// will happen on registration.\n            /// Once it happens, we set the next payment timestamp as\n            /// the start timestamp signed by the customer + trial period\n        } else if (_paymentDetails[3] == TYPE_RECURRING_PULL_PAYMENT_WITH_INITIAL) {\n            executePullPaymentOnRegistration(\n                [_paymentDetails[0], _paymentDetails[1], _paymentDetails[2]], // 0 paymentID, 1 businessID, 2 uniqueReferenceID\n                [_addresses[0], _addresses[2]], // 0 Customer Address, 1 Treasury Address\n                [_paymentAmounts[2], _paymentAmounts[0]] // 0 initialPaymentAmountInCents, 1 initialConversionRate\n            );\n            pullPayments[_addresses[0]][_addresses[1]].lastPaymentTimestamp = now;\n            pullPayments[_addresses[0]][_addresses[1]].nextPaymentTimestamp = _paymentTimestamps[2] + _paymentTimestamps[0];\n            /// @dev In the case od a paid trial, the first payment happens\n            /// on registration using the 'initialPaymentAmountInCents' and 'initialConversionRate'.\n            /// When the first payment takes place we set the next payment timestamp\n            /// as the start timestamp that was signed by the customer + the trial period\n        } else if (_paymentDetails[3] == TYPE_PULL_PAYMENT_WITH_PAID_TRIAL) {\n            executePullPaymentOnRegistration(\n                [_paymentDetails[0], _paymentDetails[1], _paymentDetails[2]], /// paymentID , businessID , uniqueReferenceID\n                [_addresses[0], _addresses[2]], /// 0 Customer Address, 1 Treasury Address\n                [_paymentAmounts[2], _paymentAmounts[0]] /// 0 initialPaymentAmountInCents, 1 initialConversionRate\n            );\n            pullPayments[_addresses[0]][_addresses[1]].lastPaymentTimestamp = now;\n            pullPayments[_addresses[0]][_addresses[1]].nextPaymentTimestamp = _paymentTimestamps[2] + _paymentTimestamps[3];\n            /// @dev For the rest of the cases the first payment happens on registration\n            /// using the 'fiatAmountInCents' and 'initialConversionRate'.\n            /// When the first payment takes place, the number of payment is decreased by 1,\n            /// and the next payment timestamp is set to the start timestamp signed by the\n            /// customer + the frequency of the payment.\n        } else {\n            executePullPaymentOnRegistration(\n                [_paymentDetails[0], _paymentDetails[1], _paymentDetails[2]], /// paymentID , businessID , uniqueReferenceID\n                [_addresses[0], _addresses[2]], /// Customer Address, Treasury Address\n                [_paymentAmounts[1], _paymentAmounts[0]] /// fiatAmountInCents, initialConversionRate\n            );\n            pullPayments[_addresses[0]][_addresses[1]].lastPaymentTimestamp = now;\n            pullPayments[_addresses[0]][_addresses[1]].nextPaymentTimestamp = _paymentTimestamps[2] + _paymentTimestamps[0];\n            pullPayments[_addresses[0]][_addresses[1]].numberOfPayments = _paymentTimestamps[1] - 1;\n        }\n        if (isFundingNeeded(msg.sender)) {\n            msg.sender.transfer(FUNDING_AMOUNT);\n            emit LogSmartContractActorFunded(\"executor\", msg.sender, now);\n        }\n        emit LogPaymentRegistered(_addresses[0], _paymentDetails[0], _paymentDetails[1], _paymentDetails[2]);\n    }","contract":"PumaPayPullPaymentV2","time":0},{"type":"external-function ","before":"function executePullPayment(address _customerAddress, bytes32 _paymentID, uint256[2] memory _paymentDetails)\n    public\n    paymentExists(_customerAddress, msg.sender)\n    isValidPullPaymentExecutionRequest(_customerAddress, msg.sender, _paymentID, _paymentDetails[1])\n    validAmount(_paymentDetails[0])\n    returns (bool)\n    {\n        uint256 conversionRate = _paymentDetails[0];\n        address customerAddress = _customerAddress;\n        bytes32[3] memory paymentIds = pullPayments[customerAddress][msg.sender].paymentIds;\n        address treasury = pullPayments[customerAddress][msg.sender].treasuryAddress;\n        uint256 amountInPMA = calculatePMAFromFiat(pullPayments[customerAddress][msg.sender].fiatAmountInCents, conversionRate);\n\n        pullPayments[customerAddress][msg.sender].nextPaymentTimestamp =\n        pullPayments[customerAddress][msg.sender].nextPaymentTimestamp + pullPayments[customerAddress][msg.sender].frequency;\n        pullPayments[customerAddress][msg.sender].numberOfPayments = pullPayments[customerAddress][msg.sender].numberOfPayments - 1;\n        pullPayments[customerAddress][msg.sender].lastPaymentTimestamp = now;\n        token.transferFrom(\n            customerAddress,\n            treasury,\n            amountInPMA\n        );\n        emit LogPullPaymentExecuted(\n            customerAddress,\n            paymentIds[0],\n            paymentIds[1],\n            paymentIds[2],\n            amountInPMA,\n            conversionRate\n        );\n        return true;\n    }","after":"function executePullPayment(address _customerAddress, bytes32 _paymentID, uint256[2] calldata _paymentDetails)\n    public\n    paymentExists(_customerAddress, msg.sender)\n    isValidPullPaymentExecutionRequest(_customerAddress, msg.sender, _paymentID, _paymentDetails[1])\n    validAmount(_paymentDetails[0])\n    returns (bool)\n    {\n        uint256 conversionRate = _paymentDetails[0];\n        address customerAddress = _customerAddress;\n        bytes32[3] memory paymentIds = pullPayments[customerAddress][msg.sender].paymentIds;\n        address treasury = pullPayments[customerAddress][msg.sender].treasuryAddress;\n        uint256 amountInPMA = calculatePMAFromFiat(pullPayments[customerAddress][msg.sender].fiatAmountInCents, conversionRate);\n\n        pullPayments[customerAddress][msg.sender].nextPaymentTimestamp =\n        pullPayments[customerAddress][msg.sender].nextPaymentTimestamp + pullPayments[customerAddress][msg.sender].frequency;\n        pullPayments[customerAddress][msg.sender].numberOfPayments = pullPayments[customerAddress][msg.sender].numberOfPayments - 1;\n        pullPayments[customerAddress][msg.sender].lastPaymentTimestamp = now;\n        token.transferFrom(\n            customerAddress,\n            treasury,\n            amountInPMA\n        );\n        emit LogPullPaymentExecuted(\n            customerAddress,\n            paymentIds[0],\n            paymentIds[1],\n            paymentIds[2],\n            amountInPMA,\n            conversionRate\n        );\n        return true;\n    }","contract":"PumaPayPullPaymentV2","time":0}]}