{"time":141,"results":[{"type":"struct-data-arrangement ","before":"\n address signator\n string templateTerm\n string signatureDetail\n uint256 lexI\n uint256 dcNumbe\n uint256 timeStam\n bool revoke","after":" string templateTerm\n string signatureDetail\n uint256 lexI\n uint256 dcNumbe\n uint256 timeStam\n address signator\n bool revoke\n","contract":"TLDR","time":0},{"type":"external-function ","before":"\n    function writeLexScript(string memory templateTerms, uint256 lexRate, address lexAddress) public {\n        require(isReputable(msg.sender)); // program governance check / lexScribe must be reputable \n\t\n\t    uint256 lexID = LSW.add(1); // reflects new lexScript value for tracking lexScript wrappers\n\t    uint256 lexVersion = 0; // initalized lexVersion, \"0\"\n\t    LSW = LSW.add(1); // counts new entry to LSW \n\t    \n\t        lexScript[lexID] = lexScriptWrapper( // populate lexScript data for rddr / rdc usage\n                msg.sender,\n                lexAddress,\n                templateTerms,\n                lexID,\n                lexVersion,\n                lexRate);\n                \n        _mint(msg.sender, 1000000000000000000); // mints lexScribe \"1\" LEX for contribution to TLDR\n\t\n        emit Enscribed(lexID, lexVersion, msg.sender); \n","after":"\n    function writeLexScript(string calldata templateTerms, uint256 lexRate, address lexAddress) public {\n        require(isReputable(msg.sender)); // program governance check / lexScribe must be reputable \n\t\n\t    uint256 lexID = LSW.add(1); // reflects new lexScript value for tracking lexScript wrappers\n\t    uint256 lexVersion = 0; // initalized lexVersion, \"0\"\n\t    LSW = LSW.add(1); // counts new entry to LSW \n\t    \n\t        lexScript[lexID] = lexScriptWrapper( // populate lexScript data for rddr / rdc usage\n                msg.sender,\n                lexAddress,\n                templateTerms,\n                lexID,\n                lexVersion,\n                lexRate);\n                \n        _mint(msg.sender, 1000000000000000000); // mints lexScribe \"1\" LEX for contribution to TLDR\n\t\n        emit Enscribed(lexID, lexVersion, msg.sender); \n","contract":"TLDR","time":0},{"type":"external-function ","before":"\n    function editLexScript(uint256 lexID, string memory templateTerms, address lexAddress) public {\n\t    lexScriptWrapper storage lS = lexScript[lexID]; // retrieve LSW data\n\t\n\t    require(msg.sender == lS.lexScribe); // program safety check / authorization \n\t\n\t    uint256 lexVersion = lS.lexVersion.add(1); // updates lexVersion \n\t    \n\t        lexScript[lexID] = lexScriptWrapper( // populates updated lexScript data for rddr / rdc usage\n                msg.sender,\n                lexAddress,\n                templateTerms,\n                lexID,\n                lexVersion,\n                lS.lexRate);\n                \t\n        emit Enscribed(lexID, lexVersion, msg.sender);\n","after":"\n    function editLexScript(uint256 lexID, string calldata templateTerms, address lexAddress) public {\n\t    lexScriptWrapper storage lS = lexScript[lexID]; // retrieve LSW data\n\t\n\t    require(msg.sender == lS.lexScribe); // program safety check / authorization \n\t\n\t    uint256 lexVersion = lS.lexVersion.add(1); // updates lexVersion \n\t    \n\t        lexScript[lexID] = lexScriptWrapper( // populates updated lexScript data for rddr / rdc usage\n                msg.sender,\n                lexAddress,\n                templateTerms,\n                lexID,\n                lexVersion,\n                lS.lexRate);\n                \t\n        emit Enscribed(lexID, lexVersion, msg.sender);\n","contract":"TLDR","time":0},{"type":"external-function ","before":"\n    function signDC(uint256 lexID, string memory signatureDetails) public { // sign Digital Covenant with (0x) address\n\t    require(lexID > (0)); // program safety check\n\t    require(lexID <= LSW); // program safety check\n\t    lexScriptWrapper storage lS = lexScript[lexID]; // retrieve LSW data\n\t\n\t    uint256 dcNumber = RDC.add(1); // reflects new rdc value for public inspection and signature revocation\n\t    RDC = RDC.add(1); // counts new entry to RDC\n\t        \n\t        rdc[dcNumber] = DC( // populates rdc data\n                msg.sender,\n                lS.templateTerms,\n                signatureDetails,\n                lexID,\n                dcNumber,\n                now, \n                false);\n                \t\n        emit Signed(lexID, dcNumber, msg.sender);\n","after":"\n    function signDC(uint256 lexID, string calldata signatureDetails) public { // sign Digital Covenant with (0x) address\n\t    require(lexID > (0)); // program safety check\n\t    require(lexID <= LSW); // program safety check\n\t    lexScriptWrapper storage lS = lexScript[lexID]; // retrieve LSW data\n\t\n\t    uint256 dcNumber = RDC.add(1); // reflects new rdc value for public inspection and signature revocation\n\t    RDC = RDC.add(1); // counts new entry to RDC\n\t        \n\t        rdc[dcNumber] = DC( // populates rdc data\n                msg.sender,\n                lS.templateTerms,\n                signatureDetails,\n                lexID,\n                dcNumber,\n                now, \n                false);\n                \t\n        emit Signed(lexID, dcNumber, msg.sender);\n","contract":"TLDR","time":0},{"type":"external-function ","before":"\n    function registerDDR( // rddr \n    \taddress client,\n    \taddress provider,\n    \tERC20 ddrToken,\n    \tstring memory deliverable,\n        uint256 retainerDuration,\n    \tuint256 deliverableRate,\n    \tuint256 payCap,\n    \tuint256 lexID) public {\n    \trequire(lexID > (0)); // program safety check \n    \trequire(lexID <= LSW); // program safety check \n        require(deliverableRate <= payCap); // program safety check / economics\n\t    require(msg.sender == client); // program safety check / authorization / client signs TLDR transaction registering ddr offer / designates provider for confirmation\n        \n\t    uint256 ddrNumber = RDDR.add(1); // reflects new rddr value for inspection and escrow management\n        uint256 retainerTermination = now.add(retainerDuration); // rddr termination date in UnixTime, \"now\" block.timestamp + retainerDuration\n\n\t    RDDR = RDDR.add(1); // counts new entry to RDDR\n    \n            rddr[ddrNumber] = DDR( // populate rddr data \n                client,\n                provider,\n                ddrToken,\n                deliverable,\n                lexID,\n                ddrNumber,\n                now, // block.timestamp, \"now\"\n                retainerTermination,\n                deliverableRate,\n                0,\n                payCap,\n                false,\n                false);\n        \t \n        emit Registered(ddrNumber, lexID, msg.sender); \n","after":"\n    function registerDDR( // rddr \n    \taddress client,\n    \taddress provider,\n    \tERC20 ddrToken,\n    \tstring calldata deliverable,\n        uint256 retainerDuration,\n    \tuint256 deliverableRate,\n    \tuint256 payCap,\n    \tuint256 lexID) public {\n    \trequire(lexID > (0)); // program safety check \n    \trequire(lexID <= LSW); // program safety check \n        require(deliverableRate <= payCap); // program safety check / economics\n\t    require(msg.sender == client); // program safety check / authorization / client signs TLDR transaction registering ddr offer / designates provider for confirmation\n        \n\t    uint256 ddrNumber = RDDR.add(1); // reflects new rddr value for inspection and escrow management\n        uint256 retainerTermination = now.add(retainerDuration); // rddr termination date in UnixTime, \"now\" block.timestamp + retainerDuration\n\n\t    RDDR = RDDR.add(1); // counts new entry to RDDR\n    \n            rddr[ddrNumber] = DDR( // populate rddr data \n                client,\n                provider,\n                ddrToken,\n                deliverable,\n                lexID,\n                ddrNumber,\n                now, // block.timestamp, \"now\"\n                retainerTermination,\n                deliverableRate,\n                0,\n                payCap,\n                false,\n                false);\n        \t \n        emit Registered(ddrNumber, lexID, msg.sender); \n","contract":"TLDR","time":0},{"type":"constant-restrict-modification  ","before":" address public tldrAddress = address(this)","after":" address public constant tldrAddress = address(this)","contract":"TLDR","time":0},{"type":"constant-restrict-modification  ","before":" string public name = \"TLDR\"","after":" string public constant name = \"TLDR\"","contract":"TLDR","time":0},{"type":"constant-restrict-modification  ","before":" string public symbol = \"LEX\"","after":" string public constant symbol = \"LEX\"","contract":"TLDR","time":0},{"type":"constant-restrict-modification  ","before":" uint8 public decimals = 18","after":" uint8 public constant decimals = 18","contract":"TLDR","time":0}]}