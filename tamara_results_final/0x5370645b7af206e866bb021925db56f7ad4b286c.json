{"time":372,"results":[{"type":"struct-data-arrangement ","before":"\naddress userAddress\nuint investAmount\nuint investTime\nuint realityInvestTime\nuint times\nuint modeFlag\nbool isSuspendedInvest","after":"uint investAmount\nuint investTime\nuint realityInvestTime\nuint times\nuint modeFlag\naddress userAddress\nbool isSuspendedInvest\n","contract":"MutualAlliance","time":0},{"type":"external-function ","before":"function investIn(string memory inviteCode, string memory referrer, uint flag)\n    public\n    isHuman()\n    payable\n    {\n        require(flag == 0 || flag == 1, \"invalid flag\");\n        require(gameStart(), \"game not start\");\n        require(msg.value >= 1 * ethWei && msg.value <= 20 * ethWei, \"between 1 and 20\");\n        require(msg.value == msg.value.div(ethWei).mul(ethWei), \"invalid msg value\");\n        uint investTime = getInvestTime(msg.value);\n        uint investDay = getCurrentInvestDay(investTime);\n        everyDayInvestMapping[investDay] = msg.value.add(everyDayInvestMapping[investDay]);\n        calUserQueueingStatic(msg.sender);\n\n        UserGlobal storage userGlobal = userMapping[msg.sender];\n        if (userGlobal.id == 0) {\n            require(!isEmpty(inviteCode), \"empty invite code\");\n            address referrerAddr = getUserAddressByCode(referrer);\n            require(uint(referrerAddr) != 0, \"referer not exist\");\n            require(referrerAddr != msg.sender, \"referrer can't be self\");\n            require(!isUsed(inviteCode), \"invite code is used\");\n\n            registerUser(msg.sender, inviteCode, referrer);\n        }\n\n        User storage user = userRoundMapping[rid][msg.sender];\n        if (uint(user.userAddress) != 0) {\n            require(user.freezeAmount == 0 && user.unlockAmount == 0, \"your invest not unlocked\");\n            user.allInvest = user.allInvest.add(msg.value);\n            user.freezeAmount = msg.value;\n            user.staticLevel = getLevel(msg.value);\n            user.dynamicLevel = getLineLevel(msg.value);\n        } else {\n            user.id = userGlobal.id;\n            user.userAddress = msg.sender;\n            user.freezeAmount = msg.value;\n            user.staticLevel = getLevel(msg.value);\n            user.dynamicLevel = getLineLevel(msg.value);\n            user.allInvest = msg.value;\n            if (!isEmpty(userGlobal.referrer)) {\n                address referrerAddr = getUserAddressByCode(userGlobal.referrer);\n                if (referrerAddr != address(0)) {\n                    userRoundMapping[rid][referrerAddr].inviteAmount++;\n                }\n            }\n        }\n        Invest memory invest = Invest(msg.sender, msg.value, investTime, now, 0, flag, !notSuspended(investTime));\n        user.invests.push(invest);\n        lastInvestTime = investTime;\n\n        investCount = investCount.add(1);\n        investMoney = investMoney.add(msg.value);\n        rInvestCount[rid] = rInvestCount[rid].add(1);\n        rInvestMoney[rid] = rInvestMoney[rid].add(msg.value);\n        \n        if (user.staticLevel >= 3) {\n            storeSolitaire(msg.sender);\n        }\n        investAmountList[rid].push(msg.value);\n\n        storeDynamicPreProfits(msg.sender, getDayForProfits(investTime), flag);\n\n        sendFeetoAdmin(msg.value);\n        trySendTransform(msg.value);\n\n        emit LogInvestIn(msg.sender, userGlobal.id, msg.value, now, investTime, userGlobal.inviteCode, userGlobal.referrer, 0);\n    }","after":"function investIn(string calldata inviteCode, string calldata referrer, uint flag)\n    public\n    isHuman()\n    payable\n    {\n        require(flag == 0 || flag == 1, \"invalid flag\");\n        require(gameStart(), \"game not start\");\n        require(msg.value >= 1 * ethWei && msg.value <= 20 * ethWei, \"between 1 and 20\");\n        require(msg.value == msg.value.div(ethWei).mul(ethWei), \"invalid msg value\");\n        uint investTime = getInvestTime(msg.value);\n        uint investDay = getCurrentInvestDay(investTime);\n        everyDayInvestMapping[investDay] = msg.value.add(everyDayInvestMapping[investDay]);\n        calUserQueueingStatic(msg.sender);\n\n        UserGlobal storage userGlobal = userMapping[msg.sender];\n        if (userGlobal.id == 0) {\n            require(!isEmpty(inviteCode), \"empty invite code\");\n            address referrerAddr = getUserAddressByCode(referrer);\n            require(uint(referrerAddr) != 0, \"referer not exist\");\n            require(referrerAddr != msg.sender, \"referrer can't be self\");\n            require(!isUsed(inviteCode), \"invite code is used\");\n\n            registerUser(msg.sender, inviteCode, referrer);\n        }\n\n        User storage user = userRoundMapping[rid][msg.sender];\n        if (uint(user.userAddress) != 0) {\n            require(user.freezeAmount == 0 && user.unlockAmount == 0, \"your invest not unlocked\");\n            user.allInvest = user.allInvest.add(msg.value);\n            user.freezeAmount = msg.value;\n            user.staticLevel = getLevel(msg.value);\n            user.dynamicLevel = getLineLevel(msg.value);\n        } else {\n            user.id = userGlobal.id;\n            user.userAddress = msg.sender;\n            user.freezeAmount = msg.value;\n            user.staticLevel = getLevel(msg.value);\n            user.dynamicLevel = getLineLevel(msg.value);\n            user.allInvest = msg.value;\n            if (!isEmpty(userGlobal.referrer)) {\n                address referrerAddr = getUserAddressByCode(userGlobal.referrer);\n                if (referrerAddr != address(0)) {\n                    userRoundMapping[rid][referrerAddr].inviteAmount++;\n                }\n            }\n        }\n        Invest memory invest = Invest(msg.sender, msg.value, investTime, now, 0, flag, !notSuspended(investTime));\n        user.invests.push(invest);\n        lastInvestTime = investTime;\n\n        investCount = investCount.add(1);\n        investMoney = investMoney.add(msg.value);\n        rInvestCount[rid] = rInvestCount[rid].add(1);\n        rInvestMoney[rid] = rInvestMoney[rid].add(msg.value);\n        \n        if (user.staticLevel >= 3) {\n            storeSolitaire(msg.sender);\n        }\n        investAmountList[rid].push(msg.value);\n\n        storeDynamicPreProfits(msg.sender, getDayForProfits(investTime), flag);\n\n        sendFeetoAdmin(msg.value);\n        trySendTransform(msg.value);\n\n        emit LogInvestIn(msg.sender, userGlobal.id, msg.value, now, investTime, userGlobal.inviteCode, userGlobal.referrer, 0);\n    }","contract":"MutualAlliance","time":0},{"type":"constant-restrict-modification  ","before":"uint ethWei = 1 ether;","after":"uint constant ethWei = 1 ether;","contract":"MutualAlliance","time":1},{"type":"constant-restrict-modification  ","before":"address payable private devAddr = address(0x3fd4967d8C5079c2D37cbaac8014c1e9584Fe5Dd);","after":"address payable private constant devAddr = address(0x3fd4967d8C5079c2D37cbaac8014c1e9584Fe5Dd);","contract":"MutualAlliance","time":1},{"type":"constant-restrict-modification  ","before":"address payable private loyal = address(0x0EF71a4b3b37dbAb581bEc482bcd0eE7429917A3);","after":"address payable private constant loyal = address(0x0EF71a4b3b37dbAb581bEc482bcd0eE7429917A3);","contract":"MutualAlliance","time":1},{"type":"constant-restrict-modification  ","before":"address payable private other = address(0x0040E7d9808e9D344158D7379E0b91b61B93CC9F);","after":"address payable private constant other = address(0x0040E7d9808e9D344158D7379E0b91b61B93CC9F);","contract":"MutualAlliance","time":1},{"type":"constant-restrict-modification  ","before":"uint period = 3 days;","after":"uint constant period = 3 days;","contract":"MutualAlliance","time":1},{"type":"constant-restrict-modification  ","before":"uint ethWei = 1 ether;","after":"uint constant ethWei = 1 ether;","contract":"MutualAlliance","time":1}]}