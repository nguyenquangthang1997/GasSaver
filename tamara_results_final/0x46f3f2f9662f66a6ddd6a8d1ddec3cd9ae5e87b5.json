{"time":458,"results":[{"type":"de-morgan-condition ","before":"{\n        if (!balances[msg.sender].safeToSub(value) || !balances[to].sa","after":"!({\n        if (balances[msg.sender].safeToSub(value) || balances[to].sa)","loc":{"start":{"line":1071,"column":12},"end":{"line":1071,"column":83}},"contract":"GnosisStandardToken","time":0},{"type":"de-morgan-condition ","before":"{\n        if (!balances[from].safeToSub(value) || !allowances[from][msg.sender].safeToSub(\n            v","after":"!({\n        if (balances[from].safeToSub(value) || allowances[from][msg.sender].safeToSub(\n            v)","loc":{"start":{"line":1087,"column":12},"end":{"line":1089,"column":8}},"contract":"GnosisStandardToken","time":0},{"type":"loop-duplication","before":"\nstart line 2519 column 12, end line 2525 column 12\n) {\n            for (uint256 i = 0; i < latestSolution.trades.length; i++) {\n                address owner = latestSolution.trades[i].owner;\n                uint256 orderId = latestSolution.trades[i].orderId;\n                Order memory order = orders[owner][orderId];\n                (, uint128 sellAmount) = getTradedAmounts(latestSolution.trades[i].volume, order);\n                addBalance(owner, tokenIdToAddressMap(order.sellToken), sellAmount\nstart line 2526 column 12, end line 2534 column 12\n  }\n            for (uint256 i = 0; i < latestSolution.trades.length; i++) {\n                address owner = latestSolution.trades[i].owner;\n                uint256 orderId = latestSolution.trades[i].orderId;\n                Order memory order = orders[owner][orderId];\n                (uint128 buyAmount, uint128 sellAmount) = getTradedAmounts(latestSolution.trades[i].volume, order);\n                revertRemainingOrder(owner, orderId, sellAmount);\n                subtractBalance(owner, tokenIdToAddressMap(order.buyToken), buyAmount);\n                emit TradeReversion(owner, orderId, sellAmount, buyAmount","after":"// merge loop\n\nstart line 2519 column 12, end line 2525 column 12\n) {\n            for (uint256 i = 0; i < latestSolution.trades.length; i++) {\n                address owner = latestSolution.trades[i].owner;\n                uint256 orderId = latestSolution.trades[i].orderId;\n                Order memory order = orders[owner][orderId];\n                (, uint128 sellAmount) = getTradedAmounts(latestSolution.trades[i].volume, order);\n                addBalance(owner, tokenIdToAddressMap(order.sellToken), sellAmount\nstart line 2526 column 12, end line 2534 column 12\n  }\n            for (uint256 i = 0; i < latestSolution.trades.length; i++) {\n                address owner = latestSolution.trades[i].owner;\n                uint256 orderId = latestSolution.trades[i].orderId;\n                Order memory order = orders[owner][orderId];\n                (uint128 buyAmount, uint128 sellAmount) = getTradedAmounts(latestSolution.trades[i].volume, order);\n                revertRemainingOrder(owner, orderId, sellAmount);\n                subtractBalance(owner, tokenIdToAddressMap(order.buyToken), buyAmount);\n                emit TradeReversion(owner, orderId, sellAmount, buyAmount","contract":"BatchExchange","time":0},{"type":"struct-data-arrangement ","before":"\nnData {\n      \natchId;\n        Tr\ntrades;\n        uint16[] \nrPrice;\n        address s\nmitter;\n        u\nReward;\n        uint25","after":"atchId;\n        Tr\ntrades;\n        uint16[] \nmitter;\n        u\nReward;\n        uint25\nrPrice;\n        address s\nnData {\n      \n","contract":"BatchExchange","time":0},{"type":"external-function ","before":"s.\n      */\n    function replaceOrders(\n        uint256[] memory cancellations,\n        uint16[] memory buyTokens,\n        uint16[] memory sellTokens,\n        uint32[] memory validFroms,\n        uint32[] memory validUntils,\n        uint128[] memory buyAmounts,\n        uint128[] memory sellAmounts\n    ) public returns (uint256[] memory orderIds) {\n        cancelOrders(cancellations);\n        return placeValidFromOrders(buyTokens, sellTokens, validFroms, validUntils, buyAmounts, sel","after":"s.\n      */\n    function replaceOrders(\n        uint256[] calldata cancellations,\n        uint16[] calldata buyTokens,\n        uint16[] calldata sellTokens,\n        uint32[] calldata validFroms,\n        uint32[] calldata validUntils,\n        uint128[] calldata buyAmounts,\n        uint128[] memory sellAmounts\n    ) public returns (uint256[] memory orderIds) {\n        cancelOrders(cancellations);\n        return placeValidFromOrders(buyTokens, sellTokens, validFroms, validUntils, buyAmounts, sel","contract":"BatchExchange","time":0},{"type":"external-function ","before":"ht\n      */\n    function submitSolution(\n        uint32 batchIndex,\n        uint256 claimedObjectiveValue,\n        address[] memory owners,\n        uint16[] memory orderIds,\n        uint128[] memory buyVolumes,\n        uint128[] memory prices,\n        uint16[] memory tokenIdsForPrice\n    ) public returns (uint256) {\n        require(acceptingSolutions(batchIndex), \"Solutions are no longer accepted for this batch\");\n        require(\n            isObjectiveValueSufficientlyImproved(claimedObjectiveValue),\n            \"Claimed objective doesn't sufficiently improve current solution\"\n        );\n        require(verifyAmountThreshold(prices), \"At least one price lower than AMOUNT_MINIMUM\");\n        require(tokenIdsForPrice[0] != 0, \"Fee token has fixed price!\");\n        require(tokenIdsForPrice.checkPriceOrdering(), \"prices are not ordered by tokenId\");\n        require(owners.length <= MAX_TOUCHED_ORDERS, \"Solution exceeds MAX_TOUCHED_ORDERS\");\n        burnPreviousAuctionFees();\n        undoCurrentSolution();\n        updateCurrentPrices(prices, tokenIdsForPrice);\n        delete latestSolution.trades;\n        int256[] memory tokenConservation = TokenConservation.init(tokenIdsForPrice);\n        uint256 utility = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            require(checkOrderValidity(order, batchIndex), \"Order is invalid\");\n            (uint128 executedBuyAmount, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            require(executedBuyAmount >= AMOUNT_MINIMUM, \"buy amount less than AMOUNT_MINIMUM\");\n            require(executedSellAmount >= AMOUNT_MINIMUM, \"sell amount less than AMOUNT_MINIMUM\");\n            tokenConservation.updateTokenConservation(\n                order.buyToken,\n                order.sellToken,\n                tokenIdsForPrice,\n                executedBuyAmount,\n                executedSellAmount\n            );\n            require(getRemainingAmount(order) >= executedSellAmount, \"executedSellAmount bigger than specified in order\");\n            // Ensure executed price is not lower than the order price:\n            //       executedSellAmount / executedBuyAmount <= order.priceDenominator / order.priceNumerator\n            require(\n                executedSellAmount.mul(order.priceNumerator) <= executedBuyAmount.mul(order.priceDenominator),\n                \"limit price not satisfied\"\n            );\n            // accumulate utility before updateRemainingOrder, but after limitPrice verified!\n            utility = utility.add(evaluateUtility(executedBuyAmount, order));\n            updateRemainingOrder(owners[i], orderIds[i], executedSellAmount);\n            addBalanceAndBlockWithdrawForThisBatch(owners[i], tokenIdToAddressMap(order.buyToken), executedBuyAmount);\n            emit Trade(owners[i], orderIds[i], executedSellAmount, executedBuyAmount);\n        }\n        // Perform all subtractions after additions to avoid negative values\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            (, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            subtractBalance(owners[i], tokenIdToAddressMap(order.sellToken), executedSellAmount);\n        }\n        uint256 disregardedUtility = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            disregardedUtility = disregardedUtility.add(evaluateDisregardedUtility(orders[owners[i]][orderIds[i]], owners[i]));\n        }\n        uint256 burntFees = uint256(tokenConservation.feeTokenImbalance()) / 2;\n        // burntFees ensures direct trades (when available) yield better solutions than longer rings\n        uint256 objectiveValue = utility.add(burntFees).sub(disregardedUtility);\n        checkAndOverrideObjectiveValue(objectiveValue);\n        grantRewardToSolutionSubmitter(burntFees);\n        tokenConservation.checkTokenConservation();\n        documentTrades(batchIndex, owners, orderIds, buyVolumes, tokenIdsForPrice);\n        return (object","after":"ht\n      */\n    function submitSolution(\n        uint32 batchIndex,\n        uint256 claimedObjectiveValue,\n        address[] calldata owners,\n        uint16[] calldata orderIds,\n        uint128[] calldata buyVolumes,\n        uint128[] calldata prices,\n        uint16[] calldata tokenIdsForPrice\n    ) public returns (uint256) {\n        require(acceptingSolutions(batchIndex), \"Solutions are no longer accepted for this batch\");\n        require(\n            isObjectiveValueSufficientlyImproved(claimedObjectiveValue),\n            \"Claimed objective doesn't sufficiently improve current solution\"\n        );\n        require(verifyAmountThreshold(prices), \"At least one price lower than AMOUNT_MINIMUM\");\n        require(tokenIdsForPrice[0] != 0, \"Fee token has fixed price!\");\n        require(tokenIdsForPrice.checkPriceOrdering(), \"prices are not ordered by tokenId\");\n        require(owners.length <= MAX_TOUCHED_ORDERS, \"Solution exceeds MAX_TOUCHED_ORDERS\");\n        burnPreviousAuctionFees();\n        undoCurrentSolution();\n        updateCurrentPrices(prices, tokenIdsForPrice);\n        delete latestSolution.trades;\n        int256[] memory tokenConservation = TokenConservation.init(tokenIdsForPrice);\n        uint256 utility = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            require(checkOrderValidity(order, batchIndex), \"Order is invalid\");\n            (uint128 executedBuyAmount, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            require(executedBuyAmount >= AMOUNT_MINIMUM, \"buy amount less than AMOUNT_MINIMUM\");\n            require(executedSellAmount >= AMOUNT_MINIMUM, \"sell amount less than AMOUNT_MINIMUM\");\n            tokenConservation.updateTokenConservation(\n                order.buyToken,\n                order.sellToken,\n                tokenIdsForPrice,\n                executedBuyAmount,\n                executedSellAmount\n            );\n            require(getRemainingAmount(order) >= executedSellAmount, \"executedSellAmount bigger than specified in order\");\n            // Ensure executed price is not lower than the order price:\n            //       executedSellAmount / executedBuyAmount <= order.priceDenominator / order.priceNumerator\n            require(\n                executedSellAmount.mul(order.priceNumerator) <= executedBuyAmount.mul(order.priceDenominator),\n                \"limit price not satisfied\"\n            );\n            // accumulate utility before updateRemainingOrder, but after limitPrice verified!\n            utility = utility.add(evaluateUtility(executedBuyAmount, order));\n            updateRemainingOrder(owners[i], orderIds[i], executedSellAmount);\n            addBalanceAndBlockWithdrawForThisBatch(owners[i], tokenIdToAddressMap(order.buyToken), executedBuyAmount);\n            emit Trade(owners[i], orderIds[i], executedSellAmount, executedBuyAmount);\n        }\n        // Perform all subtractions after additions to avoid negative values\n        for (uint256 i = 0; i < owners.length; i++) {\n            Order memory order = orders[owners[i]][orderIds[i]];\n            (, uint128 executedSellAmount) = getTradedAmounts(buyVolumes[i], order);\n            subtractBalance(owners[i], tokenIdToAddressMap(order.sellToken), executedSellAmount);\n        }\n        uint256 disregardedUtility = 0;\n        for (uint256 i = 0; i < owners.length; i++) {\n            disregardedUtility = disregardedUtility.add(evaluateDisregardedUtility(orders[owners[i]][orderIds[i]], owners[i]));\n        }\n        uint256 burntFees = uint256(tokenConservation.feeTokenImbalance()) / 2;\n        // burntFees ensures direct trades (when available) yield better solutions than longer rings\n        uint256 objectiveValue = utility.add(burntFees).sub(disregardedUtility);\n        checkAndOverrideObjectiveValue(objectiveValue);\n        grantRewardToSolutionSubmitter(burntFees);\n        tokenConservation.checkTokenConservation();\n        documentTrades(batchIndex, owners, orderIds, buyVolumes, tokenIdsForPrice);\n        return (object","contract":"BatchExchange","time":0}]}