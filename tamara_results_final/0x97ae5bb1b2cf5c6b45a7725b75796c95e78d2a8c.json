{"time":87,"results":[{"type":"external-function ","before":"function exchange(\n        ExchangeWrapperLibrary.ExchangeData memory _exchangeData,\n        bytes memory _ordersData\n    )\n        public\n        returns (ExchangeWrapperLibrary.ExchangeResults memory)\n    {\n        require(\n            ICore(core).validModules(msg.sender),\n            \"ZeroExExchangeWrapper.exchange: Sender must be approved module\"\n        );\n\n        uint256 tradesCount = _exchangeData.orderCount;\n        address[] memory sendTokens = new address[](tradesCount);\n        address[] memory receiveTokens = new address[](tradesCount);\n        uint256[] memory receiveTokenAmounts = new uint256[](tradesCount);\n\n        uint256 scannedBytes = 0;\n        for (uint256 i = 0; i < _exchangeData.orderCount; i++) {\n            ZeroExOrderLibrary.ZeroExOrderInformation memory orderInformation;\n            uint256 orderBodyStart;\n\n            // Parse order i's information\n            (orderInformation, orderBodyStart) = parseOrderInformation(\n                _ordersData,\n                scannedBytes\n            );\n\n            // Track the send tokens to ensure any leftovers are returned to the user\n            sendTokens[i] = orderInformation.takerToken;\n\n            // Fill the order via the 0x exchange\n            (receiveTokens[i], receiveTokenAmounts[i]) = fillZeroExOrder(\n                _exchangeData.caller,\n                orderInformation\n            );\n\n            // Ensure the received token can be transfered via the Set transfer proxy\n            ERC20Wrapper.ensureAllowance(\n                receiveTokens[i],\n                address(this),\n                setTransferProxy,\n                receiveTokenAmounts[i]\n            );\n\n            // Update current bytes\n            scannedBytes = orderBodyStart.add(384);\n        }\n\n        // Return leftover send tokens to the original caller\n        ExchangeWrapperLibrary.returnLeftoverSendTokens(\n            sendTokens,\n            _exchangeData.caller\n        );\n\n        return ExchangeWrapperLibrary.ExchangeResults({\n            receiveTokens: receiveTokens,\n            receiveTokenAmounts: receiveTokenAmounts\n        });\n    }","after":"function exchange(\n        ExchangeWrapperLibrary.ExchangeData calldata _exchangeData,\n        bytes calldata _ordersData\n    )\n        public\n        returns (ExchangeWrapperLibrary.ExchangeResults memory)\n    {\n        require(\n            ICore(core).validModules(msg.sender),\n            \"ZeroExExchangeWrapper.exchange: Sender must be approved module\"\n        );\n\n        uint256 tradesCount = _exchangeData.orderCount;\n        address[] memory sendTokens = new address[](tradesCount);\n        address[] memory receiveTokens = new address[](tradesCount);\n        uint256[] memory receiveTokenAmounts = new uint256[](tradesCount);\n\n        uint256 scannedBytes = 0;\n        for (uint256 i = 0; i < _exchangeData.orderCount; i++) {\n            ZeroExOrderLibrary.ZeroExOrderInformation memory orderInformation;\n            uint256 orderBodyStart;\n\n            // Parse order i's information\n            (orderInformation, orderBodyStart) = parseOrderInformation(\n                _ordersData,\n                scannedBytes\n            );\n\n            // Track the send tokens to ensure any leftovers are returned to the user\n            sendTokens[i] = orderInformation.takerToken;\n\n            // Fill the order via the 0x exchange\n            (receiveTokens[i], receiveTokenAmounts[i]) = fillZeroExOrder(\n                _exchangeData.caller,\n                orderInformation\n            );\n\n            // Ensure the received token can be transfered via the Set transfer proxy\n            ERC20Wrapper.ensureAllowance(\n                receiveTokens[i],\n                address(this),\n                setTransferProxy,\n                receiveTokenAmounts[i]\n            );\n\n            // Update current bytes\n            scannedBytes = orderBodyStart.add(384);\n        }\n\n        // Return leftover send tokens to the original caller\n        ExchangeWrapperLibrary.returnLeftoverSendTokens(\n            sendTokens,\n            _exchangeData.caller\n        );\n\n        return ExchangeWrapperLibrary.ExchangeResults({\n            receiveTokens: receiveTokens,\n            receiveTokenAmounts: receiveTokenAmounts\n        });\n    }","contract":"ZeroExExchangeWrapper","time":0}]}