{"time":60,"results":[{"type":"struct-data-arrangement ","before":"\naddress recipient\nuint amount\nstring description\nbool signedByChairman\nuint minExecutionDate\nbool executed\nbool proposalPassed\nuint numberOfVotes\nbytes32 proposalHash\nVote[] votes\nmapping (address => bool) voted","after":"uint amount\nstring description\nuint minExecutionDate\nuint numberOfVotes\nbytes32 proposalHash\nVote[] votes\nmapping (address => bool) voted\naddress recipient\nbool signedByChairman\nbool executed\nbool proposalPassed\n","contract":"MindsyncPlatform","time":0},{"type":"external-function ","before":"function newProposal(\n        address destination,\n        uint weiAmount,\n        string memory transactionDescription,\n        bytes memory transactionBytecode\n    )\n        onlyTokenholders public\n        returns (uint proposalID)\n    {\n        proposalID = proposals.length++;\n        Proposal storage p = proposals[proposalID];\n        p.recipient = destination;\n        p.signedByChairman = false;\n        p.amount = weiAmount;\n        p.description = transactionDescription;\n        p.proposalHash = keccak256(abi.encodePacked(destination, weiAmount, transactionBytecode));\n        p.minExecutionDate = now + debatingPeriodInMinutes * 1 minutes;\n        p.executed = false;\n        p.proposalPassed = false;\n        p.numberOfVotes = 0;\n        emit ProposalAdded(proposalID, destination, weiAmount, transactionDescription);\n        numProposals = proposalID+1;\n\n        return proposalID;\n    }","after":"function newProposal(\n        address destination,\n        uint weiAmount,\n        string calldata transactionDescription,\n        bytes calldata transactionBytecode\n    )\n        onlyTokenholders public\n        returns (uint proposalID)\n    {\n        proposalID = proposals.length++;\n        Proposal storage p = proposals[proposalID];\n        p.recipient = destination;\n        p.signedByChairman = false;\n        p.amount = weiAmount;\n        p.description = transactionDescription;\n        p.proposalHash = keccak256(abi.encodePacked(destination, weiAmount, transactionBytecode));\n        p.minExecutionDate = now + debatingPeriodInMinutes * 1 minutes;\n        p.executed = false;\n        p.proposalPassed = false;\n        p.numberOfVotes = 0;\n        emit ProposalAdded(proposalID, destination, weiAmount, transactionDescription);\n        numProposals = proposalID+1;\n\n        return proposalID;\n    }","contract":"MindsyncPlatform","time":0},{"type":"external-function ","before":"function executeProposal(uint proposalNumber, bytes memory transactionBytecode) public {\n        Proposal storage p = proposals[proposalNumber];\n\n        require(initialized);\n        require(now > p.minExecutionDate                                             // If it is past the voting deadline\n            && !p.executed                                                          // and it has not already been executed\n            && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode))); // and the supplied code matches the proposal...\n\n\n        // ...then tally the results\n        uint quorum = 0;\n        uint yea = 0;\n        uint nay = 0;\n\n        for (uint i = 0; i <  p.votes.length; ++i) {\n            Vote storage v = p.votes[i];\n            uint voteWeight = tokenAddress.actualBalanceOf(v.voter);\n            quorum += voteWeight;\n            if (v.inSupport) {\n                yea += voteWeight;\n            } else {\n                nay += voteWeight;\n            }\n        }\n\n        Token t = Token(tokenAddress);\n        require(quorum >= t.totalSupply().mul(minimumQuorum).div(100)); // Check if a minimum quorum has been reached\n\n        if (yea > nay ) {\n            // Proposal passed; execute the transaction\n\n            p.executed = true;\n            \n            (bool success, ) = p.recipient.call.value(p.amount)(transactionBytecode);\n            require(success);\n\n            p.proposalPassed = true;\n        } else {\n            // Proposal failed\n            p.proposalPassed = false;\n        }\n\n        // Fire Events\n        emit ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed);\n    }","after":"function executeProposal(uint proposalNumber, bytes calldata transactionBytecode) public {\n        Proposal storage p = proposals[proposalNumber];\n\n        require(initialized);\n        require(now > p.minExecutionDate                                             // If it is past the voting deadline\n            && !p.executed                                                          // and it has not already been executed\n            && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode))); // and the supplied code matches the proposal...\n\n\n        // ...then tally the results\n        uint quorum = 0;\n        uint yea = 0;\n        uint nay = 0;\n\n        for (uint i = 0; i <  p.votes.length; ++i) {\n            Vote storage v = p.votes[i];\n            uint voteWeight = tokenAddress.actualBalanceOf(v.voter);\n            quorum += voteWeight;\n            if (v.inSupport) {\n                yea += voteWeight;\n            } else {\n                nay += voteWeight;\n            }\n        }\n\n        Token t = Token(tokenAddress);\n        require(quorum >= t.totalSupply().mul(minimumQuorum).div(100)); // Check if a minimum quorum has been reached\n\n        if (yea > nay ) {\n            // Proposal passed; execute the transaction\n\n            p.executed = true;\n            \n            (bool success, ) = p.recipient.call.value(p.amount)(transactionBytecode);\n            require(success);\n\n            p.proposalPassed = true;\n        } else {\n            // Proposal failed\n            p.proposalPassed = false;\n        }\n\n        // Fire Events\n        emit ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed);\n    }","contract":"MindsyncPlatform","time":0},{"type":"external-function ","before":"function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public {\n        Token t = Token(_token);\n        require(t.transferFrom(_from, address(this), _value));\n        emit receivedTokens(_from, _value, _token, _extraData);\n    }","after":"function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) public {\n        Token t = Token(_token);\n        require(t.transferFrom(_from, address(this), _value));\n        emit receivedTokens(_from, _value, _token, _extraData);\n    }","contract":"MindsyncPlatform","time":0}]}