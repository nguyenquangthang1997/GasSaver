{"time":136,"results":[{"type":"external-function ","before":"function reveal(uint256 _bid, bytes memory randString) public duringReveal {\n        bytes32 myHash = calculateHash(_bid,randString);\n        data storage myData = information[msg.sender];\n        require(myHash == myData.hashValue, \"hashes do not match\");\n        require(_bid <= myData.value,\"Bid not valid\");\n        require(_bid >= minimumBid,\"Bid was less than minimum bid\");\n        require(!myData.revealed,\"Bid already revealed\");\n\n        myData.bid = _bid;\n        myData.revealed = true;\n\n        uint256 newLen = reveals[_bid].push(msg.sender);\n        if (newLen == 1) {\n            revealedValues.push(_bid);\n        }\n\n        emit BidRevealed(msg.sender,_bid);\n    }","after":"function reveal(uint256 _bid, bytes calldata randString) public duringReveal {\n        bytes32 myHash = calculateHash(_bid,randString);\n        data storage myData = information[msg.sender];\n        require(myHash == myData.hashValue, \"hashes do not match\");\n        require(_bid <= myData.value,\"Bid not valid\");\n        require(_bid >= minimumBid,\"Bid was less than minimum bid\");\n        require(!myData.revealed,\"Bid already revealed\");\n\n        myData.bid = _bid;\n        myData.revealed = true;\n\n        uint256 newLen = reveals[_bid].push(msg.sender);\n        if (newLen == 1) {\n            revealedValues.push(_bid);\n        }\n\n        emit BidRevealed(msg.sender,_bid);\n    }","contract":"auction","time":0},{"type":"external-function ","before":"function setWinningAddresses(address[] memory theAddresses,bool flagged) public onlyOwner  afterReveal{\n        uint256 pos;\n        for (pos = 0; pos < theAddresses.length; pos++) {\n            information[theAddresses[pos]].flagged = flagged;\n            emit WinnerWithTie(theAddresses[pos]);\n        }\n    }","after":"function setWinningAddresses(address[] calldata theAddresses,bool flagged) public onlyOwner  afterReveal{\n        uint256 pos;\n        for (pos = 0; pos < theAddresses.length; pos++) {\n            information[theAddresses[pos]].flagged = flagged;\n            emit WinnerWithTie(theAddresses[pos]);\n        }\n    }","contract":"auction","time":0},{"type":"external-function ","before":"function earlyWithdrawal(address[] memory winners) public onlyOwner duringWithdraw {\n        uint256 amount;\n        uint256 pos;\n        uint256 len = winners.length;\n        for (pos = 0; pos < len; pos++) {\n            address addr = winners[pos];\n            if (!done[addr]){\n                bool winner;\n                bool inperiod;\n                (winner, inperiod) = isWinner(addr);\n                require(winner && inperiod,\"Not a winner\");\n                amount += information[addr].bid;\n            }\n            done[addr] = true;\n        }\n        emit BalanceWithdrawn(wallet,amount);\n        wallet.transfer(amount);\n    }","after":"function earlyWithdrawal(address[] calldata winners) public onlyOwner duringWithdraw {\n        uint256 amount;\n        uint256 pos;\n        uint256 len = winners.length;\n        for (pos = 0; pos < len; pos++) {\n            address addr = winners[pos];\n            if (!done[addr]){\n                bool winner;\n                bool inperiod;\n                (winner, inperiod) = isWinner(addr);\n                require(winner && inperiod,\"Not a winner\");\n                amount += information[addr].bid;\n            }\n            done[addr] = true;\n        }\n        emit BalanceWithdrawn(wallet,amount);\n        wallet.transfer(amount);\n    }","contract":"auction","time":0}]}