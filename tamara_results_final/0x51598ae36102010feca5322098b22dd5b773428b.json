{"time":227,"results":[{"type":"struct-data-arrangement ","before":"\naddress payable[] issuers\naddress[] approvers\nuint deadline\naddress token\nuint tokenVersion\nuint balance\nbool hasPaidOut\nFulfillment[] fulfillments\nContribution[] contributions","after":"address payable[] issuers\naddress[] approvers\nuint deadline\nuint tokenVersion\nuint balance\nFulfillment[] fulfillments\nContribution[] contributions\naddress token\nbool hasPaidOut\n","contract":"StandardBounties","time":0},{"type":"struct-data-arrangement ","before":"\naddress payable contributor\nuint amount\nbool refunded","after":"uint amount\naddress payable contributor\nbool refunded\n","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function issueAndContribute(\n    address payable _sender,\n    address payable[] memory _issuers,\n    address[] memory _approvers,\n    string memory _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _depositAmount)\n    public\n    payable\n    returns(uint)\n  {\n    uint bountyId = issueBounty(_sender, _issuers, _approvers, _data, _deadline, _token, _tokenVersion);\n\n    contribute(_sender, bountyId, _depositAmount);\n\n    return (bountyId);\n  }","after":"function issueAndContribute(\n    address payable _sender,\n    address payable[] calldata _issuers,\n    address[] calldata _approvers,\n    string calldata _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _depositAmount)\n    public\n    payable\n    returns(uint)\n  {\n    uint bountyId = issueBounty(_sender, _issuers, _approvers, _data, _deadline, _token, _tokenVersion);\n\n    contribute(_sender, bountyId, _depositAmount);\n\n    return (bountyId);\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function refundMyContributions(\n    address _sender,\n    uint _bountyId,\n    uint[] memory _contributionIds)\n    public\n    senderIsValid(_sender)\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n        refundContribution(_sender, _bountyId, _contributionIds[i]);\n    }\n  }","after":"function refundMyContributions(\n    address _sender,\n    uint _bountyId,\n    uint[] calldata _contributionIds)\n    public\n    senderIsValid(_sender)\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n        refundContribution(_sender, _bountyId, _contributionIds[i]);\n    }\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function refundContributions(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] memory _contributionIds)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n      require(_contributionIds[i] < bounties[_bountyId].contributions.length);\n\n      Contribution storage contribution = bounties[_bountyId].contributions[_contributionIds[i]];\n\n      require(!contribution.refunded);\n\n      contribution.refunded = true;\n\n      transferTokens(_bountyId, contribution.contributor, contribution.amount); // Performs the disbursal of tokens to the contributor\n    }\n\n    emit ContributionsRefunded(_bountyId, _sender, _contributionIds);\n  }","after":"function refundContributions(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] calldata _contributionIds)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n      require(_contributionIds[i] < bounties[_bountyId].contributions.length);\n\n      Contribution storage contribution = bounties[_bountyId].contributions[_contributionIds[i]];\n\n      require(!contribution.refunded);\n\n      contribution.refunded = true;\n\n      transferTokens(_bountyId, contribution.contributor, contribution.amount); // Performs the disbursal of tokens to the contributor\n    }\n\n    emit ContributionsRefunded(_bountyId, _sender, _contributionIds);\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function drainBounty(\n    address payable _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] memory _amounts)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    if (bounties[_bountyId].tokenVersion == 0 || bounties[_bountyId].tokenVersion == 20){\n      require(_amounts.length == 1); // ensures there's only 1 amount of tokens to be returned\n      require(_amounts[0] <= bounties[_bountyId].balance); // ensures an issuer doesn't try to drain the bounty of more tokens than their balance permits\n      transferTokens(_bountyId, _sender, _amounts[0]); // Performs the draining of tokens to the issuer\n    } else {\n      for (uint i = 0; i < _amounts.length; i++){\n        require(tokenBalances[_bountyId][_amounts[i]]);// ensures an issuer doesn't try to drain the bounty of a token it doesn't have in its balance\n        transferTokens(_bountyId, _sender, _amounts[i]);\n      }\n    }\n\n    emit BountyDrained(_bountyId, _sender, _amounts);\n  }","after":"function drainBounty(\n    address payable _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] calldata _amounts)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    if (bounties[_bountyId].tokenVersion == 0 || bounties[_bountyId].tokenVersion == 20){\n      require(_amounts.length == 1); // ensures there's only 1 amount of tokens to be returned\n      require(_amounts[0] <= bounties[_bountyId].balance); // ensures an issuer doesn't try to drain the bounty of more tokens than their balance permits\n      transferTokens(_bountyId, _sender, _amounts[0]); // Performs the draining of tokens to the issuer\n    } else {\n      for (uint i = 0; i < _amounts.length; i++){\n        require(tokenBalances[_bountyId][_amounts[i]]);// ensures an issuer doesn't try to drain the bounty of a token it doesn't have in its balance\n        transferTokens(_bountyId, _sender, _amounts[i]);\n      }\n    }\n\n    emit BountyDrained(_bountyId, _sender, _amounts);\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function performAction(\n    address _sender,\n    uint _bountyId,\n    string memory _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n  {\n    emit ActionPerformed(_bountyId, _sender, _data); // The _data string is emitted in an event for easy off-chain consumption\n  }","after":"function performAction(\n    address _sender,\n    uint _bountyId,\n    string calldata _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n  {\n    emit ActionPerformed(_bountyId, _sender, _data); // The _data string is emitted in an event for easy off-chain consumption\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function updateFulfillment(\n  address _sender,\n  uint _bountyId,\n  uint _fulfillmentId,\n  address payable[] memory _fulfillers,\n  string memory _data)\n  public\n  senderIsValid(_sender)\n  validateBountyArrayIndex(_bountyId)\n  validateFulfillmentArrayIndex(_bountyId, _fulfillmentId)\n  onlySubmitter(_sender, _bountyId, _fulfillmentId) // Only the original submitter of a fulfillment may update their submission\n  {\n    bounties[_bountyId].fulfillments[_fulfillmentId].fulfillers = _fulfillers;\n    emit FulfillmentUpdated(_bountyId,\n                            _fulfillmentId,\n                            _fulfillers,\n                            _data); // The _data string is emitted in an event for easy off-chain consumption\n  }","after":"function updateFulfillment(\n  address _sender,\n  uint _bountyId,\n  uint _fulfillmentId,\n  address payable[] calldata _fulfillers,\n  string calldata _data)\n  public\n  senderIsValid(_sender)\n  validateBountyArrayIndex(_bountyId)\n  validateFulfillmentArrayIndex(_bountyId, _fulfillmentId)\n  onlySubmitter(_sender, _bountyId, _fulfillmentId) // Only the original submitter of a fulfillment may update their submission\n  {\n    bounties[_bountyId].fulfillments[_fulfillmentId].fulfillers = _fulfillers;\n    emit FulfillmentUpdated(_bountyId,\n                            _fulfillmentId,\n                            _fulfillers,\n                            _data); // The _data string is emitted in an event for easy off-chain consumption\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function fulfillAndAccept(\n    address _sender,\n    uint _bountyId,\n    address payable[] memory _fulfillers,\n    string memory _data,\n    uint _approverId,\n    uint[] memory _tokenAmounts)\n    public\n    senderIsValid(_sender)\n  {\n    // first fulfills the bounty on behalf of the fulfillers\n    fulfillBounty(_sender, _bountyId, _fulfillers, _data);\n\n    // then accepts the fulfillment\n    acceptFulfillment(_sender,\n                      _bountyId,\n                      bounties[_bountyId].fulfillments.length - 1,\n                      _approverId,\n                      _tokenAmounts);\n  }","after":"function fulfillAndAccept(\n    address _sender,\n    uint _bountyId,\n    address payable[] calldata _fulfillers,\n    string calldata _data,\n    uint _approverId,\n    uint[] calldata _tokenAmounts)\n    public\n    senderIsValid(_sender)\n  {\n    // first fulfills the bounty on behalf of the fulfillers\n    fulfillBounty(_sender, _bountyId, _fulfillers, _data);\n\n    // then accepts the fulfillment\n    acceptFulfillment(_sender,\n                      _bountyId,\n                      bounties[_bountyId].fulfillments.length - 1,\n                      _approverId,\n                      _tokenAmounts);\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function changeBounty(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers,\n    address payable[] memory _approvers,\n    string memory _data,\n    uint _deadline)\n    public\n    senderIsValid(_sender)\n  {\n    require(_bountyId < numBounties); // makes the validateBountyArrayIndex modifier in-line to avoid stack too deep errors\n    require(_issuerId < bounties[_bountyId].issuers.length); // makes the validateIssuerArrayIndex modifier in-line to avoid stack too deep errors\n    require(_sender == bounties[_bountyId].issuers[_issuerId]); // makes the onlyIssuer modifier in-line to avoid stack too deep errors\n\n    require(_issuers.length > 0 || _approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n\n    bounties[_bountyId].issuers = _issuers;\n    bounties[_bountyId].approvers = _approvers;\n    bounties[_bountyId].deadline = _deadline;\n    emit BountyChanged(_bountyId,\n                       _sender,\n                       _issuers,\n                       _approvers,\n                       _data,\n                       _deadline);\n  }","after":"function changeBounty(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers,\n    address payable[] calldata _approvers,\n    string calldata _data,\n    uint _deadline)\n    public\n    senderIsValid(_sender)\n  {\n    require(_bountyId < numBounties); // makes the validateBountyArrayIndex modifier in-line to avoid stack too deep errors\n    require(_issuerId < bounties[_bountyId].issuers.length); // makes the validateIssuerArrayIndex modifier in-line to avoid stack too deep errors\n    require(_sender == bounties[_bountyId].issuers[_issuerId]); // makes the onlyIssuer modifier in-line to avoid stack too deep errors\n\n    require(_issuers.length > 0 || _approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n\n    bounties[_bountyId].issuers = _issuers;\n    bounties[_bountyId].approvers = _approvers;\n    bounties[_bountyId].deadline = _deadline;\n    emit BountyChanged(_bountyId,\n                       _sender,\n                       _issuers,\n                       _approvers,\n                       _data,\n                       _deadline);\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function changeData(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    string memory _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    emit BountyDataChanged(_bountyId, _sender, _data); // The new _data is emitted within an event rather than being stored on-chain for minimized gas costs\n  }","after":"function changeData(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    string calldata _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    emit BountyDataChanged(_bountyId, _sender, _data); // The new _data is emitted within an event rather than being stored on-chain for minimized gas costs\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function addIssuers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _issuers.length; i++){\n      bounties[_bountyId].issuers.push(_issuers[i]);\n    }\n\n    emit BountyIssuersUpdated(_bountyId, _sender, bounties[_bountyId].issuers);\n  }","after":"function addIssuers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _issuers.length; i++){\n      bounties[_bountyId].issuers.push(_issuers[i]);\n    }\n\n    emit BountyIssuersUpdated(_bountyId, _sender, bounties[_bountyId].issuers);\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function addApprovers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address[] memory _approvers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _approvers.length; i++){\n      bounties[_bountyId].approvers.push(_approvers[i]);\n    }\n\n    emit BountyApproversUpdated(_bountyId, _sender, bounties[_bountyId].approvers);\n  }","after":"function addApprovers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address[] calldata _approvers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _approvers.length; i++){\n      bounties[_bountyId].approvers.push(_approvers[i]);\n    }\n\n    emit BountyApproversUpdated(_bountyId, _sender, bounties[_bountyId].approvers);\n  }","contract":"StandardBounties","time":0}]}