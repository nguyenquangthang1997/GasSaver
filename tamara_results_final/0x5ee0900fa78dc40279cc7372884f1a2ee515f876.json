{"time":407,"results":[{"type":"loop-duplication","before":"\nstart line 450 column 8, end line 453 column 8\nfor (uint256 i = 0; i < nbOfStrings; i++)\n        {\n            offsetArr[i] = sliceUint(b, globalOffset + 32 + 32 * i);\n        }\nstart line 455 column 8, end line 462 column 8\nfor (uint256 i = 0; i < nbOfStrings; i++)\n        {\n            stringLengths[i] = sliceUint(b, globalOffset + 32 + offsetArr[i]);\n            require(stringLengths[i] <= 32);\n            // No string more than a bytes32\n\n            stringArr[i] = bytes32ToString(bytesToBytes32(b, globalOffset + 64 + offsetArr[i]), stringLengths[i]);\n        }","after":"// merge loop\n\nstart line 450 column 8, end line 453 column 8\nfor (uint256 i = 0; i < nbOfStrings; i++)\n        {\n            offsetArr[i] = sliceUint(b, globalOffset + 32 + 32 * i);\n        }\nstart line 455 column 8, end line 462 column 8\nfor (uint256 i = 0; i < nbOfStrings; i++)\n        {\n            stringLengths[i] = sliceUint(b, globalOffset + 32 + offsetArr[i]);\n            require(stringLengths[i] <= 32);\n            // No string more than a bytes32\n\n            stringArr[i] = bytes32ToString(bytesToBytes32(b, globalOffset + 64 + offsetArr[i]), stringLengths[i]);\n        }","contract":"Helpers","time":0},{"type":"external-function ","before":"function setNWhitelistedStatus(address[] memory _addresses, bool whitelisted_status) public onlyMultiSigOwners() {\n        for (uint256 i = 0; i < _addresses.length; i++)\n        {\n            whitelisted[_addresses[i]] = whitelisted_status;\n        }\n    }","after":"function setNWhitelistedStatus(address[] calldata _addresses, bool whitelisted_status) public onlyMultiSigOwners() {\n        for (uint256 i = 0; i < _addresses.length; i++)\n        {\n            whitelisted[_addresses[i]] = whitelisted_status;\n        }\n    }","contract":"ProxyForKYCWhitelistOnlySpecifiedPeopleAreWhitelisted","time":0},{"type":"external-function ","before":"function initialCall(bytes memory functionCall) public returns (bytes32) {\n        require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n\n        Current_functionCallHash = keccak256(functionCall);\n        Current_functionCall = functionCall;\n\n        delete Current_Approvals;\n\n        Current_Approvals.push(msg.sender);\n\n        bytes4 funcSelector;\n\n        assembly {\n            funcSelector := mload(add(functionCall, 32))\n        }\n\n        Current_functionSig = funcSelector;\n\n\n        if (nbApprovalsNeeded == 1)\n        {\n            address(this).call(functionCall);\n\n            if (!isRegistered(funcSelector))\n            {\n                revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n            }\n\n            emit MultiSigOwnerTransactionCleared(funcSelector);\n        }\n\n        return Current_functionCallHash;\n    }","after":"function initialCall(bytes calldata functionCall) public returns (bytes32) {\n        require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n\n        Current_functionCallHash = keccak256(functionCall);\n        Current_functionCall = functionCall;\n\n        delete Current_Approvals;\n\n        Current_Approvals.push(msg.sender);\n\n        bytes4 funcSelector;\n\n        assembly {\n            funcSelector := mload(add(functionCall, 32))\n        }\n\n        Current_functionSig = funcSelector;\n\n\n        if (nbApprovalsNeeded == 1)\n        {\n            address(this).call(functionCall);\n\n            if (!isRegistered(funcSelector))\n            {\n                revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n            }\n\n            emit MultiSigOwnerTransactionCleared(funcSelector);\n        }\n\n        return Current_functionCallHash;\n    }","contract":"ProxyForKYCWhitelistOnlySpecifiedPeopleAreWhitelisted","time":0},{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping(uint256 => address) private _tokenOwner;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => Counters.Counter) private _ownedTokensCount;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;","after":"mapping(uint256 => address) private _tokenOwner;\nmapping(uint256 => address) private _tokenApprovals;\nmapping(address => Counters.Counter) private _ownedTokensCount;\nmapping(address => mapping(address => bool)) private _operatorApprovals;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n","contract":"ERC721","time":0},{"type":"external-function ","before":"function setbaseURI(string memory _new_baseURI) public onlyMultiSigOwners() {\n        baseURI = _new_baseURI;\n    }","after":"function setbaseURI(string calldata _new_baseURI) public onlyMultiSigOwners() {\n        baseURI = _new_baseURI;\n    }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public {\n        require(_token == nexiumAddress);\n        require(_extraData.length >= 4);\n        // We need at least the functionSelector;\n\n        bytes4 funcSelector = 0x0;\n\n        if (_extraData.length == 0) {\n            funcSelector = 0x0;\n        }\n\n        assembly {\n            funcSelector := mload(add(_extraData, 32))\n        }\n\n        if (funcSelector == bytes4(keccak256(\"createNewOptionID(uint256,address)\")))\n        {\n            revert(\"Please put empty keys and values args\");\n            /*uint256 nbOfAsset = Helpers.sliceUint(_extraData, 4);\n            address _minter = address(Helpers.sliceUint(_extraData, 36));\n\n            createNewOptionID(nbOfAsset, _minter);\n\n            NxcInterface nexiumContract = NxcInterface(address(nexiumAddress));\n\n            require(_value >= CallProxyForNxCBurn(nbOfAsset), \"Not enough NXC!\");*/\n        }\n        else if (funcSelector == bytes4(keccak256(\"createNewOptionID(uint256,address,string[],string[])\")))\n        {\n\n            // Check extraData length\n\n            uint256 nbOfAsset = Helpers.sliceUint(_extraData, 4);\n            address _minter = address(Helpers.sliceUint(_extraData, 36));\n\n            uint256 keysOffset = Helpers.sliceUint(_extraData, 68) + 4;\n            // we have to account for the bytes4 selector\n            uint256 valuesOffset = Helpers.sliceUint(_extraData, 100) + 4;\n\n            uint256 nbOfKeys = Helpers.sliceUint(_extraData, keysOffset);\n            uint256 nbOfValues = Helpers.sliceUint(_extraData, valuesOffset);\n\n            require(nbOfValues == nbOfKeys);\n\n            string[] memory keys = Helpers.parseBytesToStringArr(_extraData, keysOffset);\n            string[] memory values = Helpers.parseBytesToStringArr(_extraData, valuesOffset);\n\n            createNewOptionID(nbOfAsset, _minter, keys, values);\n\n            require(_value >= CallProxyForNxCBurn(nbOfAsset, keys, values), \"Not enough NXC!\");\n        }\n        else\n        {\n            revert(\"Unknown function called through receiveApproval\");\n        }\n\n        NxcInterface nexiumContract = NxcInterface(address(nexiumAddress));\n        if (!nexiumContract.transferFrom(_from, address(this), _value))\n        {\n            revert(\"notEnoughNxCSent\");\n        }\n\n        return;\n    }","after":"function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) public {\n        require(_token == nexiumAddress);\n        require(_extraData.length >= 4);\n        // We need at least the functionSelector;\n\n        bytes4 funcSelector = 0x0;\n\n        if (_extraData.length == 0) {\n            funcSelector = 0x0;\n        }\n\n        assembly {\n            funcSelector := mload(add(_extraData, 32))\n        }\n\n        if (funcSelector == bytes4(keccak256(\"createNewOptionID(uint256,address)\")))\n        {\n            revert(\"Please put empty keys and values args\");\n            /*uint256 nbOfAsset = Helpers.sliceUint(_extraData, 4);\n            address _minter = address(Helpers.sliceUint(_extraData, 36));\n\n            createNewOptionID(nbOfAsset, _minter);\n\n            NxcInterface nexiumContract = NxcInterface(address(nexiumAddress));\n\n            require(_value >= CallProxyForNxCBurn(nbOfAsset), \"Not enough NXC!\");*/\n        }\n        else if (funcSelector == bytes4(keccak256(\"createNewOptionID(uint256,address,string[],string[])\")))\n        {\n\n            // Check extraData length\n\n            uint256 nbOfAsset = Helpers.sliceUint(_extraData, 4);\n            address _minter = address(Helpers.sliceUint(_extraData, 36));\n\n            uint256 keysOffset = Helpers.sliceUint(_extraData, 68) + 4;\n            // we have to account for the bytes4 selector\n            uint256 valuesOffset = Helpers.sliceUint(_extraData, 100) + 4;\n\n            uint256 nbOfKeys = Helpers.sliceUint(_extraData, keysOffset);\n            uint256 nbOfValues = Helpers.sliceUint(_extraData, valuesOffset);\n\n            require(nbOfValues == nbOfKeys);\n\n            string[] memory keys = Helpers.parseBytesToStringArr(_extraData, keysOffset);\n            string[] memory values = Helpers.parseBytesToStringArr(_extraData, valuesOffset);\n\n            createNewOptionID(nbOfAsset, _minter, keys, values);\n\n            require(_value >= CallProxyForNxCBurn(nbOfAsset, keys, values), \"Not enough NXC!\");\n        }\n        else\n        {\n            revert(\"Unknown function called through receiveApproval\");\n        }\n\n        NxcInterface nexiumContract = NxcInterface(address(nexiumAddress));\n        if (!nexiumContract.transferFrom(_from, address(this), _value))\n        {\n            revert(\"notEnoughNxCSent\");\n        }\n\n        return;\n    }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function setOptionIdPropriety(uint256 _optionID, string memory _key, string memory _value) public\n    {\n        require(msg.sender == minterForOptionID[_optionID]);\n        require(bytes(_key).length > 0);\n\n        KeyValue memory keyValueForThisKey = KeyValueMappingOptionID[_optionID][_key];\n\n        uint256 index;\n        KeyValue memory newKeyValue;\n\n        // Check if the key already set or not\n        if (bytes(keyValueForThisKey._key).length == 0)\n        {\n            index = KeyValueArrayOptionID[_optionID].length;\n            newKeyValue = KeyValue(index, _key, _value);\n            KeyValueArrayOptionID[_optionID].push(newKeyValue);\n        }\n        else\n        {\n            index = keyValueForThisKey._index;\n            newKeyValue = KeyValue(index, _key, _value);\n            KeyValueArrayOptionID[_optionID][index] = newKeyValue;\n        }\n\n        KeyValueMappingOptionID[_optionID][_key] = newKeyValue;\n    }","after":"function setOptionIdPropriety(uint256 _optionID, string calldata _key, string calldata _value) public\n    {\n        require(msg.sender == minterForOptionID[_optionID]);\n        require(bytes(_key).length > 0);\n\n        KeyValue memory keyValueForThisKey = KeyValueMappingOptionID[_optionID][_key];\n\n        uint256 index;\n        KeyValue memory newKeyValue;\n\n        // Check if the key already set or not\n        if (bytes(keyValueForThisKey._key).length == 0)\n        {\n            index = KeyValueArrayOptionID[_optionID].length;\n            newKeyValue = KeyValue(index, _key, _value);\n            KeyValueArrayOptionID[_optionID].push(newKeyValue);\n        }\n        else\n        {\n            index = keyValueForThisKey._index;\n            newKeyValue = KeyValue(index, _key, _value);\n            KeyValueArrayOptionID[_optionID][index] = newKeyValue;\n        }\n\n        KeyValueMappingOptionID[_optionID][_key] = newKeyValue;\n    }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function deleteOptionIdPropriety(uint256 _optionID, string memory _key) public\n    {\n        require(msg.sender == minterForOptionID[_optionID]);\n\n        KeyValue memory keyValueForThisKey = KeyValueMappingOptionID[_optionID][_key];\n\n        uint256 index = keyValueForThisKey._index;\n        uint256 length = KeyValueArrayOptionID[_optionID].length;\n\n        KeyValueArrayOptionID[_optionID][index] = KeyValueArrayOptionID[_optionID][length - 1];\n        delete KeyValueArrayOptionID[_optionID][length - 1];\n        delete KeyValueMappingOptionID[_optionID][_key];\n    }","after":"function deleteOptionIdPropriety(uint256 _optionID, string calldata _key) public\n    {\n        require(msg.sender == minterForOptionID[_optionID]);\n\n        KeyValue memory keyValueForThisKey = KeyValueMappingOptionID[_optionID][_key];\n\n        uint256 index = keyValueForThisKey._index;\n        uint256 length = KeyValueArrayOptionID[_optionID].length;\n\n        KeyValueArrayOptionID[_optionID][index] = KeyValueArrayOptionID[_optionID][length - 1];\n        delete KeyValueArrayOptionID[_optionID][length - 1];\n        delete KeyValueMappingOptionID[_optionID][_key];\n    }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function setTokenIdPropriety(uint256 _TokenID, string memory _key, string memory _value) public\n    {\n        NFT_Token itemContract = NFT_Token(nftAddress);\n\n        uint256 _optionId = itemContract.itemTypes(_TokenID);\n        require(msg.sender == minterForOptionID[_optionId]);\n\n        require(bytes(_key).length > 0);\n\n        KeyValue memory keyValueForThisKey = KeyValueMappingTokenID[_TokenID][_key];\n\n        uint256 index;\n        KeyValue memory newKeyValue;\n\n        // Check if the key already set or not\n\n        if (bytes(keyValueForThisKey._key).length == 0)\n        {\n            index = KeyValueArrayTokenID[_TokenID].length;\n            newKeyValue = KeyValue(index, _key, _value);\n            KeyValueArrayTokenID[_TokenID].push(newKeyValue);\n        }\n        else\n        {\n            index = keyValueForThisKey._index;\n            newKeyValue = KeyValue(index, _key, _value);\n            KeyValueArrayTokenID[_TokenID][index] = newKeyValue;\n        }\n\n        KeyValueMappingTokenID[_TokenID][_key] = newKeyValue;\n    }","after":"function setTokenIdPropriety(uint256 _TokenID, string calldata _key, string calldata _value) public\n    {\n        NFT_Token itemContract = NFT_Token(nftAddress);\n\n        uint256 _optionId = itemContract.itemTypes(_TokenID);\n        require(msg.sender == minterForOptionID[_optionId]);\n\n        require(bytes(_key).length > 0);\n\n        KeyValue memory keyValueForThisKey = KeyValueMappingTokenID[_TokenID][_key];\n\n        uint256 index;\n        KeyValue memory newKeyValue;\n\n        // Check if the key already set or not\n\n        if (bytes(keyValueForThisKey._key).length == 0)\n        {\n            index = KeyValueArrayTokenID[_TokenID].length;\n            newKeyValue = KeyValue(index, _key, _value);\n            KeyValueArrayTokenID[_TokenID].push(newKeyValue);\n        }\n        else\n        {\n            index = keyValueForThisKey._index;\n            newKeyValue = KeyValue(index, _key, _value);\n            KeyValueArrayTokenID[_TokenID][index] = newKeyValue;\n        }\n\n        KeyValueMappingTokenID[_TokenID][_key] = newKeyValue;\n    }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function deleteTokenIdPropriety(uint256 _TokenID, string memory _key) public\n    {\n        NFT_Token itemContract = NFT_Token(nftAddress);\n\n        uint256 _optionId = itemContract.itemTypes(_TokenID);\n        require(msg.sender == minterForOptionID[_optionId]);\n\n        KeyValue memory keyValueForThisKey = KeyValueMappingTokenID[_TokenID][_key];\n\n        uint256 index = keyValueForThisKey._index;\n        uint256 length = KeyValueArrayTokenID[_TokenID].length;\n\n        KeyValueArrayTokenID[_TokenID][index] = KeyValueArrayTokenID[_TokenID][length - 1];\n        delete KeyValueArrayTokenID[_TokenID][length - 1];\n        delete KeyValueMappingTokenID[_TokenID][_key];\n    }","after":"function deleteTokenIdPropriety(uint256 _TokenID, string calldata _key) public\n    {\n        NFT_Token itemContract = NFT_Token(nftAddress);\n\n        uint256 _optionId = itemContract.itemTypes(_TokenID);\n        require(msg.sender == minterForOptionID[_optionId]);\n\n        KeyValue memory keyValueForThisKey = KeyValueMappingTokenID[_TokenID][_key];\n\n        uint256 index = keyValueForThisKey._index;\n        uint256 length = KeyValueArrayTokenID[_TokenID].length;\n\n        KeyValueArrayTokenID[_TokenID][index] = KeyValueArrayTokenID[_TokenID][length - 1];\n        delete KeyValueArrayTokenID[_TokenID][length - 1];\n        delete KeyValueMappingTokenID[_TokenID][_key];\n    }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function setTokenURI(uint256 tokenID, string memory _tokenURI) public\n    {\n        NFT_Token itemContract = NFT_Token(nftAddress);\n\n        uint256 optionID = itemContract.itemTypes(tokenID);\n\n        require(msg.sender == minterForOptionID[optionID]);\n\n        itemContract.setTokenURI(tokenID, _tokenURI);\n    }","after":"function setTokenURI(uint256 tokenID, string calldata _tokenURI) public\n    {\n        NFT_Token itemContract = NFT_Token(nftAddress);\n\n        uint256 optionID = itemContract.itemTypes(tokenID);\n\n        require(msg.sender == minterForOptionID[optionID]);\n\n        itemContract.setTokenURI(tokenID, _tokenURI);\n    }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function DefineBundle(uint256 optionID, uint256[] memory optionIDList) public\n    {\n        require(minterForOptionID[optionID] == msg.sender);\n        for (uint256 i = 0; i < optionIDList.length; i++)\n        {\n            require(minterForOptionID[optionIDList[i]] == msg.sender);\n        }\n        bundlesDefinition[optionID] = optionIDList;\n        isBundle[optionID] = true;\n    }","after":"function DefineBundle(uint256 optionID, uint256[] calldata optionIDList) public\n    {\n        require(minterForOptionID[optionID] == msg.sender);\n        for (uint256 i = 0; i < optionIDList.length; i++)\n        {\n            require(minterForOptionID[optionIDList[i]] == msg.sender);\n        }\n        bundlesDefinition[optionID] = optionIDList;\n        isBundle[optionID] = true;\n    }","contract":"NFT_Factory","time":0},{"type":"external-function ","before":"function initialCall(bytes memory functionCall) public returns (bytes32) {\n        require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n\n        Current_functionCallHash = keccak256(functionCall);\n        Current_functionCall = functionCall;\n\n        delete Current_Approvals;\n\n        Current_Approvals.push(msg.sender);\n\n        bytes4 funcSelector;\n\n        assembly {\n            funcSelector := mload(add(functionCall, 32))\n        }\n\n        Current_functionSig = funcSelector;\n\n\n        if (nbApprovalsNeeded == 1)\n        {\n            address(this).call(functionCall);\n\n            if (!isRegistered(funcSelector))\n            {\n                revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n            }\n\n            emit MultiSigOwnerTransactionCleared(funcSelector);\n        }\n\n        return Current_functionCallHash;\n    }","after":"function initialCall(bytes calldata functionCall) public returns (bytes32) {\n        require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n\n        Current_functionCallHash = keccak256(functionCall);\n        Current_functionCall = functionCall;\n\n        delete Current_Approvals;\n\n        Current_Approvals.push(msg.sender);\n\n        bytes4 funcSelector;\n\n        assembly {\n            funcSelector := mload(add(functionCall, 32))\n        }\n\n        Current_functionSig = funcSelector;\n\n\n        if (nbApprovalsNeeded == 1)\n        {\n            address(this).call(functionCall);\n\n            if (!isRegistered(funcSelector))\n            {\n                revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n            }\n\n            emit MultiSigOwnerTransactionCleared(funcSelector);\n        }\n\n        return Current_functionCallHash;\n    }","contract":"NFT_Factory","time":0},{"type":"state-data-arrangement ","before":"\naddress private NexiumAddress;\naddress private FactoryAddress;\nmapping(address => uint256) groupOwners;\nmapping(uint256 => uint256) public NexiumPerTokenId;\nmapping(uint256 => uint256) public EtherPerTokenId;\nstring private _name;\nstring private _symbol;\nuint256 private _total_supply;\nstring private _uri_prefix;\nstring private _route;\nuint256 private _last_id;\nmapping(uint256 => string) tokenURIs;\nmapping(uint256 => bool) private _locked;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\nmapping(uint256 => uint256[]) groupMapping;\naddress payable ProxyContractForMetaTxsAddress;","after":"mapping(address => uint256) groupOwners;\nmapping(uint256 => uint256) public NexiumPerTokenId;\nmapping(uint256 => uint256) public EtherPerTokenId;\nstring private _name;\nstring private _symbol;\nuint256 private _total_supply;\nstring private _uri_prefix;\nstring private _route;\nuint256 private _last_id;\nmapping(uint256 => string) tokenURIs;\nmapping(uint256 => bool) private _locked;\nmapping(uint256 => uint256[]) groupMapping;\naddress private NexiumAddress;\naddress private FactoryAddress;\naddress payable ProxyContractForMetaTxsAddress;\nbytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public {\n\n        require(_token == NexiumAddress);\n        require(_extraData.length == 32);\n\n        uint256 tokenId = Helpers.bytesToUint(_extraData);\n\n        NxcInterface nexiumContract = NxcInterface(NexiumAddress);\n\n        if (nexiumContract.transferFrom(_from, address(this), _value) == false)\n        {\n            revert();\n        }\n\n        NexiumPerTokenId[tokenId] = NexiumPerTokenId[tokenId].add(_value);\n\n        return;\n    }","after":"function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) public {\n\n        require(_token == NexiumAddress);\n        require(_extraData.length == 32);\n\n        uint256 tokenId = Helpers.bytesToUint(_extraData);\n\n        NxcInterface nexiumContract = NxcInterface(NexiumAddress);\n\n        if (nexiumContract.transferFrom(_from, address(this), _value) == false)\n        {\n            revert();\n        }\n\n        NexiumPerTokenId[tokenId] = NexiumPerTokenId[tokenId].add(_value);\n\n        return;\n    }","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function groupAssets(uint256[] memory tokenIds) public returns (uint256) {\n\n        uint256 tokenId = totalSupply().add(1);\n        _mint(msg.sender, tokenId);\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            transferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        groupMapping[tokenId] = tokenIds;\n\n        emit Grouping(msg.sender, tokenId);\n\n        return tokenId;\n    }","after":"function groupAssets(uint256[] calldata tokenIds) public returns (uint256) {\n\n        uint256 tokenId = totalSupply().add(1);\n        _mint(msg.sender, tokenId);\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            transferFrom(msg.sender, address(this), tokenIds[i]);\n        }\n\n        groupMapping[tokenId] = tokenIds;\n\n        emit Grouping(msg.sender, tokenId);\n\n        return tokenId;\n    }","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function setURI_Prefix(string memory _new_uri_prefix) public onlyMultiSigOwners() returns (bool) {\n        _uri_prefix = _new_uri_prefix;\n        return true;\n    }","after":"function setURI_Prefix(string calldata _new_uri_prefix) public onlyMultiSigOwners() returns (bool) {\n        _uri_prefix = _new_uri_prefix;\n        return true;\n    }","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function setRoute(string memory _new_route) public onlyMultiSigOwners() returns (bool) {\n        _route = _new_route;\n        return true;\n    }","after":"function setRoute(string calldata _new_route) public onlyMultiSigOwners() returns (bool) {\n        _route = _new_route;\n        return true;\n    }","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function setTokenURI(uint256 tokenID, string memory _tokenURI) public returns (bool) {\n        require(msg.sender == FactoryAddress);\n\n        tokenURIs[tokenID] = _tokenURI;\n        return true;\n    }","after":"function setTokenURI(uint256 tokenID, string calldata _tokenURI) public returns (bool) {\n        require(msg.sender == FactoryAddress);\n\n        tokenURIs[tokenID] = _tokenURI;\n        return true;\n    }","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function forward(bytes memory sig, address signer, address destination, uint value, bytes memory data, address rewardToken, uint rewardAmount) public\n    {\n        ProxyContractForMetaTxs _proxy_contract_MetaTx = ProxyContractForMetaTxs(ProxyContractForMetaTxsAddress);\n        return _proxy_contract_MetaTx.forward(sig, signer, destination, value, data, rewardToken, rewardAmount);\n    }","after":"function forward(bytes calldata sig, address signer, address destination, uint value, bytes calldata data, address rewardToken, uint rewardAmount) public\n    {\n        ProxyContractForMetaTxs _proxy_contract_MetaTx = ProxyContractForMetaTxs(ProxyContractForMetaTxsAddress);\n        return _proxy_contract_MetaTx.forward(sig, signer, destination, value, data, rewardToken, rewardAmount);\n    }","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function initialCall(bytes memory functionCall) public returns (bytes32) {\n        require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n\n        Current_functionCallHash = keccak256(functionCall);\n        Current_functionCall = functionCall;\n\n        delete Current_Approvals;\n\n        Current_Approvals.push(msg.sender);\n\n        bytes4 funcSelector;\n\n        assembly {\n            funcSelector := mload(add(functionCall, 32))\n        }\n\n        Current_functionSig = funcSelector;\n\n\n        if (nbApprovalsNeeded == 1)\n        {\n            address(this).call(functionCall);\n\n            if (!isRegistered(funcSelector))\n            {\n                revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n            }\n\n            emit MultiSigOwnerTransactionCleared(funcSelector);\n        }\n\n        return Current_functionCallHash;\n    }","after":"function initialCall(bytes calldata functionCall) public returns (bytes32) {\n        require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n\n        Current_functionCallHash = keccak256(functionCall);\n        Current_functionCall = functionCall;\n\n        delete Current_Approvals;\n\n        Current_Approvals.push(msg.sender);\n\n        bytes4 funcSelector;\n\n        assembly {\n            funcSelector := mload(add(functionCall, 32))\n        }\n\n        Current_functionSig = funcSelector;\n\n\n        if (nbApprovalsNeeded == 1)\n        {\n            address(this).call(functionCall);\n\n            if (!isRegistered(funcSelector))\n            {\n                revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n            }\n\n            emit MultiSigOwnerTransactionCleared(funcSelector);\n        }\n\n        return Current_functionCallHash;\n    }","contract":"NFT_Token","time":0},{"type":"external-function ","before":"function newAsset(uint256 optionID, string memory name, address minter) public {\n        _tokenTypes[optionID] = TokenType(optionID, name, minter);\n        emit RegisterNewAsset(optionID, name);\n    }","after":"function newAsset(uint256 optionID, string calldata name, address minter) public {\n        _tokenTypes[optionID] = TokenType(optionID, name, minter);\n        emit RegisterNewAsset(optionID, name);\n    }","contract":"NFT_B2E_Listing","time":0},{"type":"external-function ","before":"function replaceAsset(uint256 optionID, string memory name, address minter) public {\n        delete _tokenTypes[optionID];\n        _tokenTypes[optionID] = TokenType(optionID, name, minter);\n        emit UpdateAsset(optionID, name);\n    }","after":"function replaceAsset(uint256 optionID, string calldata name, address minter) public {\n        delete _tokenTypes[optionID];\n        _tokenTypes[optionID] = TokenType(optionID, name, minter);\n        emit UpdateAsset(optionID, name);\n    }","contract":"NFT_B2E_Listing","time":0},{"type":"external-function ","before":"function initialCall(bytes memory functionCall) public returns (bytes32) {\n        require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n\n        Current_functionCallHash = keccak256(functionCall);\n        Current_functionCall = functionCall;\n\n        delete Current_Approvals;\n\n        Current_Approvals.push(msg.sender);\n\n        bytes4 funcSelector;\n\n        assembly {\n            funcSelector := mload(add(functionCall, 32))\n        }\n\n        Current_functionSig = funcSelector;\n\n\n        if (nbApprovalsNeeded == 1)\n        {\n            address(this).call(functionCall);\n\n            if (!isRegistered(funcSelector))\n            {\n                revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n            }\n\n            emit MultiSigOwnerTransactionCleared(funcSelector);\n        }\n\n        return Current_functionCallHash;\n    }","after":"function initialCall(bytes calldata functionCall) public returns (bytes32) {\n        require(isInOwnerList(msg.sender), \"Initial call - Not in owner list\");\n\n        Current_functionCallHash = keccak256(functionCall);\n        Current_functionCall = functionCall;\n\n        delete Current_Approvals;\n\n        Current_Approvals.push(msg.sender);\n\n        bytes4 funcSelector;\n\n        assembly {\n            funcSelector := mload(add(functionCall, 32))\n        }\n\n        Current_functionSig = funcSelector;\n\n\n        if (nbApprovalsNeeded == 1)\n        {\n            address(this).call(functionCall);\n\n            if (!isRegistered(funcSelector))\n            {\n                revert(\"initialCall - Called a function without the onlyMultiSigOwners modifier\");\n            }\n\n            emit MultiSigOwnerTransactionCleared(funcSelector);\n        }\n\n        return Current_functionCallHash;\n    }","contract":"NFT_B2E_Listing","time":0},{"type":"constant-restrict-modification  ","before":"uint256 minimum = 100;","after":"uint256 constant minimum = 100;","contract":"ProxyContractForBurn","time":0},{"type":"constant-restrict-modification  ","before":"uint256 divisor = 4;","after":"uint256 constant divisor = 4;","contract":"ProxyContractForBurn","time":0}]}