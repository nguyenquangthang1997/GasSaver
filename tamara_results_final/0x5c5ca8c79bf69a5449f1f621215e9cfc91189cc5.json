{"time":58,"results":[{"type":"external-function ","before":"function approveAndCallWithSignature( string memory methodName, address relayAuthority,address from,address to,   address token, uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes memory signature ) public returns (bool success)   {\n\n       require(!bytesEqual('transfer',bytes(methodName)));\n\n\n       require(_validatePacketSignature(methodName,relayAuthority,from,to, token,tokens,relayerRewardTokens,expires,nonce, signature));\n\n       bytes memory method = bytes(methodName);\n\n       _sendApproveAndCall(from,to,token,tokens,method);\n\n        return true;\n    }","after":"function approveAndCallWithSignature( string calldata methodName, address relayAuthority,address from,address to,   address token, uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes calldata signature ) public returns (bool success)   {\n\n       require(!bytesEqual('transfer',bytes(methodName)));\n\n\n       require(_validatePacketSignature(methodName,relayAuthority,from,to, token,tokens,relayerRewardTokens,expires,nonce, signature));\n\n       bytes memory method = bytes(methodName);\n\n       _sendApproveAndCall(from,to,token,tokens,method);\n\n        return true;\n    }","contract":"LavaWallet","time":0},{"type":"external-function ","before":"function transferTokensWithSignature(string memory methodName, address relayAuthority, address from, address to, address token, uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes memory signature) public returns (bool success)\n {\n\n     require(bytesEqual('transfer',bytes(methodName)));\n\n\n     require(_validatePacketSignature(methodName,relayAuthority,from,to, token,tokens,relayerRewardTokens,expires,nonce, signature));\n\n     require( ERC20Interface(token).transferFrom(from,  to, tokens )  );\n\n\n     return true;\n\n }","after":"function transferTokensWithSignature(string calldata methodName, address relayAuthority, address from, address to, address token, uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce, bytes calldata signature) public returns (bool success)\n {\n\n     require(bytesEqual('transfer',bytes(methodName)));\n\n\n     require(_validatePacketSignature(methodName,relayAuthority,from,to, token,tokens,relayerRewardTokens,expires,nonce, signature));\n\n     require( ERC20Interface(token).transferFrom(from,  to, tokens )  );\n\n\n     return true;\n\n }","contract":"LavaWallet","time":0},{"type":"external-function ","before":"function burnSignature(string memory methodName, address relayAuthority, address from, address to, address wallet,address token,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce,  bytes memory signature) public returns (bool success)\n      {\n\n\n         bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,token, tokens,relayerRewardTokens,expires,nonce);\n\n          address recoveredSignatureSigner = recover(sigHash,signature);\n\n          //make sure the invalidator is the signer\n          require(recoveredSignatureSigner == from);\n\n          //only the original packet owner can burn signature, not a relay\n          require(from == msg.sender);\n\n          //make sure this signature has never been used\n          uint burnedSignature = burnedSignatures[sigHash];\n          burnedSignatures[sigHash] = 0x2; //invalidated\n          require(burnedSignature == 0x0);\n\n          return true;\n      }","after":"function burnSignature(string calldata methodName, address relayAuthority, address from, address to, address wallet,address token,uint256 tokens,uint256 relayerRewardTokens,uint256 expires,uint256 nonce,  bytes calldata signature) public returns (bool success)\n      {\n\n\n         bytes32 sigHash = getLavaTypedDataHash(methodName,relayAuthority,from,to,wallet,token, tokens,relayerRewardTokens,expires,nonce);\n\n          address recoveredSignatureSigner = recover(sigHash,signature);\n\n          //make sure the invalidator is the signer\n          require(recoveredSignatureSigner == from);\n\n          //only the original packet owner can burn signature, not a relay\n          require(from == msg.sender);\n\n          //make sure this signature has never been used\n          uint burnedSignature = burnedSignatures[sigHash];\n          burnedSignatures[sigHash] = 0x2; //invalidated\n          require(burnedSignature == 0x0);\n\n          return true;\n      }","contract":"LavaWallet","time":0}]}