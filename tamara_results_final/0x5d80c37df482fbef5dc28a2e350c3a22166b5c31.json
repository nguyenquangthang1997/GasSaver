{"time":131,"results":[{"type":"external-function ","before":"function setRate(string memory _currency, uint256 _rate)\n    public\n    onlyOwner\n    validAmount(_rate)\n    returns (bool) {\n        require(bytes(_currency).length != 0, \"Invalid conversion rate - Currency is empty.\");\n        conversionRates[_currency] = _rate;\n        emit LogSetConversionRate(_currency, _rate);\n\n        if (isFundingNeeded(owner())) {\n            owner().transfer(FUNDING_AMOUNT);\n\n            emit LogSmartContractActorFunded(\"owner\", owner(), now);\n        }\n\n        return true;\n    }","after":"function setRate(string calldata _currency, uint256 _rate)\n    public\n    onlyOwner\n    validAmount(_rate)\n    returns (bool) {\n        require(bytes(_currency).length != 0, \"Invalid conversion rate - Currency is empty.\");\n        conversionRates[_currency] = _rate;\n        emit LogSetConversionRate(_currency, _rate);\n\n        if (isFundingNeeded(owner())) {\n            owner().transfer(FUNDING_AMOUNT);\n\n            emit LogSmartContractActorFunded(\"owner\", owner(), now);\n        }\n\n        return true;\n    }","contract":"PumaPayPullPayment","time":0},{"type":"external-function ","before":"function registerPullPayment(\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bytes32[2] memory _ids, // [0] paymentID, [1] businessID\n        address[3] memory _addresses, // [0] customerAddress, [1] pull payment executor, [2] treasury wallet\n        string memory _currency,\n        string memory _uniqueReferenceID,\n        uint256 _initialPaymentAmountInCents,\n        uint256 _fiatAmountInCents,\n        uint256 _frequency,\n        uint256 _numberOfPayments,\n        uint256 _startTimestamp\n    )\n    public\n    isExecutor()\n    {\n        require(!doesPaymentExist(_addresses[0], _addresses[1]), \"Pull Payment already exists.\");\n\n        require(_ids[0] != EMPTY_BYTES32, \"Payment ID is empty.\");\n        require(_ids[1] != EMPTY_BYTES32, \"Business ID is empty.\");\n        require(bytes(_currency).length > 0, \"Currency is empty.\");\n        require(bytes(_uniqueReferenceID).length > 0, \"Unique Reference ID is empty.\");\n\n        require(_addresses[0] != address(0), \"Customer Address is ZERO_ADDRESS.\");\n        require(_addresses[1] != address(0), \"Beneficiary Address is ZERO_ADDRESS.\");\n        require(_addresses[2] != address(0), \"Treasury Address is ZERO_ADDRESS.\");\n\n        require(_fiatAmountInCents > 0, \"Payment amount in fiat is zero.\");\n        require(_frequency > 0, \"Payment frequency is zero.\");\n        require(_numberOfPayments > 0, \"Payment number of payments is zero.\");\n        require(_startTimestamp > 0, \"Payment start time is zero.\");\n\n        require(_fiatAmountInCents <= OVERFLOW_LIMITER_NUMBER, \"Payment amount is higher than the overflow limit.\");\n        require(_frequency <= OVERFLOW_LIMITER_NUMBER, \"Payment frequency is higher than the overflow limit.\");\n        require(_numberOfPayments <= OVERFLOW_LIMITER_NUMBER, \"Payment number of payments is higher than the overflow limit.\");\n        require(_startTimestamp <= OVERFLOW_LIMITER_NUMBER, \"Payment start time is higher than the overflow limit.\");\n\n        pullPayments[_addresses[0]][_addresses[1]].currency = _currency;\n        pullPayments[_addresses[0]][_addresses[1]].initialPaymentAmountInCents = _initialPaymentAmountInCents;\n        pullPayments[_addresses[0]][_addresses[1]].fiatAmountInCents = _fiatAmountInCents;\n        pullPayments[_addresses[0]][_addresses[1]].frequency = _frequency;\n        pullPayments[_addresses[0]][_addresses[1]].startTimestamp = _startTimestamp;\n        pullPayments[_addresses[0]][_addresses[1]].numberOfPayments = _numberOfPayments;\n        pullPayments[_addresses[0]][_addresses[1]].paymentID = _ids[0];\n        pullPayments[_addresses[0]][_addresses[1]].businessID = _ids[1];\n        pullPayments[_addresses[0]][_addresses[1]].uniqueReferenceID = _uniqueReferenceID;\n        pullPayments[_addresses[0]][_addresses[1]].treasuryAddress = _addresses[2];\n\n        require(isValidRegistration(\n                v,\n                r,\n                s,\n                _addresses[0],\n                _addresses[1],\n                pullPayments[_addresses[0]][_addresses[1]]),\n            \"Invalid pull payment registration - ECRECOVER_FAILED\"\n        );\n\n        pullPayments[_addresses[0]][_addresses[1]].nextPaymentTimestamp = _startTimestamp;\n        pullPayments[_addresses[0]][_addresses[1]].lastPaymentTimestamp = 0;\n        pullPayments[_addresses[0]][_addresses[1]].cancelTimestamp = 0;\n\n        if (isFundingNeeded(msg.sender)) {\n            msg.sender.transfer(FUNDING_AMOUNT);\n\n            emit LogSmartContractActorFunded(\"executor\", msg.sender, now);\n        }\n\n        emit LogPaymentRegistered(_addresses[0], _ids[0], _ids[1], _uniqueReferenceID);\n    }","after":"function registerPullPayment(\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        bytes32[2] calldata _ids, // [0] paymentID, [1] businessID\n        address[3] calldata _addresses, // [0] customerAddress, [1] pull payment executor, [2] treasury wallet\n        string calldata _currency,\n        string calldata _uniqueReferenceID,\n        uint256 _initialPaymentAmountInCents,\n        uint256 _fiatAmountInCents,\n        uint256 _frequency,\n        uint256 _numberOfPayments,\n        uint256 _startTimestamp\n    )\n    public\n    isExecutor()\n    {\n        require(!doesPaymentExist(_addresses[0], _addresses[1]), \"Pull Payment already exists.\");\n\n        require(_ids[0] != EMPTY_BYTES32, \"Payment ID is empty.\");\n        require(_ids[1] != EMPTY_BYTES32, \"Business ID is empty.\");\n        require(bytes(_currency).length > 0, \"Currency is empty.\");\n        require(bytes(_uniqueReferenceID).length > 0, \"Unique Reference ID is empty.\");\n\n        require(_addresses[0] != address(0), \"Customer Address is ZERO_ADDRESS.\");\n        require(_addresses[1] != address(0), \"Beneficiary Address is ZERO_ADDRESS.\");\n        require(_addresses[2] != address(0), \"Treasury Address is ZERO_ADDRESS.\");\n\n        require(_fiatAmountInCents > 0, \"Payment amount in fiat is zero.\");\n        require(_frequency > 0, \"Payment frequency is zero.\");\n        require(_numberOfPayments > 0, \"Payment number of payments is zero.\");\n        require(_startTimestamp > 0, \"Payment start time is zero.\");\n\n        require(_fiatAmountInCents <= OVERFLOW_LIMITER_NUMBER, \"Payment amount is higher than the overflow limit.\");\n        require(_frequency <= OVERFLOW_LIMITER_NUMBER, \"Payment frequency is higher than the overflow limit.\");\n        require(_numberOfPayments <= OVERFLOW_LIMITER_NUMBER, \"Payment number of payments is higher than the overflow limit.\");\n        require(_startTimestamp <= OVERFLOW_LIMITER_NUMBER, \"Payment start time is higher than the overflow limit.\");\n\n        pullPayments[_addresses[0]][_addresses[1]].currency = _currency;\n        pullPayments[_addresses[0]][_addresses[1]].initialPaymentAmountInCents = _initialPaymentAmountInCents;\n        pullPayments[_addresses[0]][_addresses[1]].fiatAmountInCents = _fiatAmountInCents;\n        pullPayments[_addresses[0]][_addresses[1]].frequency = _frequency;\n        pullPayments[_addresses[0]][_addresses[1]].startTimestamp = _startTimestamp;\n        pullPayments[_addresses[0]][_addresses[1]].numberOfPayments = _numberOfPayments;\n        pullPayments[_addresses[0]][_addresses[1]].paymentID = _ids[0];\n        pullPayments[_addresses[0]][_addresses[1]].businessID = _ids[1];\n        pullPayments[_addresses[0]][_addresses[1]].uniqueReferenceID = _uniqueReferenceID;\n        pullPayments[_addresses[0]][_addresses[1]].treasuryAddress = _addresses[2];\n\n        require(isValidRegistration(\n                v,\n                r,\n                s,\n                _addresses[0],\n                _addresses[1],\n                pullPayments[_addresses[0]][_addresses[1]]),\n            \"Invalid pull payment registration - ECRECOVER_FAILED\"\n        );\n\n        pullPayments[_addresses[0]][_addresses[1]].nextPaymentTimestamp = _startTimestamp;\n        pullPayments[_addresses[0]][_addresses[1]].lastPaymentTimestamp = 0;\n        pullPayments[_addresses[0]][_addresses[1]].cancelTimestamp = 0;\n\n        if (isFundingNeeded(msg.sender)) {\n            msg.sender.transfer(FUNDING_AMOUNT);\n\n            emit LogSmartContractActorFunded(\"executor\", msg.sender, now);\n        }\n\n        emit LogPaymentRegistered(_addresses[0], _ids[0], _ids[1], _uniqueReferenceID);\n    }","contract":"PumaPayPullPayment","time":0}]}