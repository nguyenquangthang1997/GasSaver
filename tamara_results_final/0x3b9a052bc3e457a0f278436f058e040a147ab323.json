{"time":358,"results":[{"type":"external-function ","before":"function registerChain(string memory description, string memory initEndpoint, ChainValidator chainValidator, uint256 minRequiredDeposit, uint256 minRequiredVesting, uint256 rewardBonusRequiredVesting, uint256 rewardBonusPercentage, \n                           uint256 notaryPeriod, uint256 maxNumOfValidators, uint256 maxNumOfTransactors, bool involvedVestingNotaryCond, bool participationNotaryCond) public returns (uint256 chainId) {\n        require(bytes(description).length > 0 && bytes(description).length <= MAX_DESCRIPTION_LENGTH,   \"Chain description length must be: > 0 && <= MAX_DESCRIPTION_LENGTH(200)\");\n        require(bytes(initEndpoint).length > 0 && bytes(initEndpoint).length <= MAX_URL_LENGTH,         \"Chain endpoint length must be: > 0 && <= MAX_URL_LENGTH(100)\");\n        require(notaryPeriod >= MIN_NOTARY_PERIOD && notaryPeriod <= MAX_NOTARY_PERIOD,                 \"Notary period must be in range <MIN_NOTARY_PERIOD(1440), MAX_NOTARY_PERIOD(34560)>\");\n        require(involvedVestingNotaryCond == true || participationNotaryCond == true,                   \"At least one notary condition must be specified\");\n        \n        if (minRequiredDeposit > 0) {\n            require(minRequiredDeposit >= LITION_MIN_REQUIRED_DEPOSIT,                                  \"Min. required deposit for all chains must be >= LITION_MIN_REQUIRED_DEPOSIT (1000 LIT)\");\n        }\n        \n        if (minRequiredVesting > 0) {\n            require(minRequiredVesting >= LITION_MIN_REQUIRED_VESTING,                                  \"Min. required vesting for all chains must be >= LITION_MIN_REQUIRED_VESTING (1000 LIT)\");\n        }\n        \n        if (rewardBonusRequiredVesting > 0) {\n            require(rewardBonusPercentage > 0,                                                          \"Reward bonus percentage must be > 0%\");    \n        }\n    \n        chainId                         = nextId;\n        ChainInfo storage chain         = chains[chainId];\n        \n        chain.id                        = chainId;\n        chain.description               = description;\n        chain.endpoint                  = initEndpoint;\n        chain.minRequiredDeposit        = minRequiredDeposit;\n        chain.minRequiredVesting        = minRequiredVesting;\n        chain.notaryPeriod              = notaryPeriod;\n        chain.registered                = true;\n        chain.creator                   = msg.sender;\n        \n        if (chainValidator != ChainValidator(0)) {\n            chain.chainValidator = chainValidator;\n        }\n        \n        // Sets min required deposit\n        if (minRequiredDeposit == 0) {\n            chain.minRequiredDeposit = LITION_MIN_REQUIRED_DEPOSIT;\n        } \n        else {\n            chain.minRequiredDeposit = minRequiredDeposit;\n        }\n        \n        // Sets min required vesting\n        if (minRequiredVesting == 0) {\n            chain.minRequiredVesting = LITION_MIN_REQUIRED_VESTING;\n        } \n        else {\n            chain.minRequiredVesting = minRequiredVesting;\n        }\n\n        \n        if (involvedVestingNotaryCond == true) {\n            chain.involvedVestingNotaryCond  = true;    \n        }\n        \n        if (participationNotaryCond == true) {\n            chain.participationNotaryCond    = true;\n        }\n        \n        if (maxNumOfValidators > 0) {\n            chain.maxNumOfValidators         = maxNumOfValidators;\n        }\n        \n        if (maxNumOfTransactors > 0) {\n            chain.maxNumOfTransactors        = maxNumOfTransactors;\n        }\n        \n        if (rewardBonusRequiredVesting > 0) {\n            chain.rewardBonusRequiredVesting = rewardBonusRequiredVesting;\n            chain.rewardBonusPercentage      = rewardBonusPercentage;\n        }\n        \n        emit NewChain(chainId, description, initEndpoint);\n        \n        nextId++;\n    }","after":"function registerChain(string calldata description, string calldata initEndpoint, ChainValidator chainValidator, uint256 minRequiredDeposit, uint256 minRequiredVesting, uint256 rewardBonusRequiredVesting, uint256 rewardBonusPercentage, \n                           uint256 notaryPeriod, uint256 maxNumOfValidators, uint256 maxNumOfTransactors, bool involvedVestingNotaryCond, bool participationNotaryCond) public returns (uint256 chainId) {\n        require(bytes(description).length > 0 && bytes(description).length <= MAX_DESCRIPTION_LENGTH,   \"Chain description length must be: > 0 && <= MAX_DESCRIPTION_LENGTH(200)\");\n        require(bytes(initEndpoint).length > 0 && bytes(initEndpoint).length <= MAX_URL_LENGTH,         \"Chain endpoint length must be: > 0 && <= MAX_URL_LENGTH(100)\");\n        require(notaryPeriod >= MIN_NOTARY_PERIOD && notaryPeriod <= MAX_NOTARY_PERIOD,                 \"Notary period must be in range <MIN_NOTARY_PERIOD(1440), MAX_NOTARY_PERIOD(34560)>\");\n        require(involvedVestingNotaryCond == true || participationNotaryCond == true,                   \"At least one notary condition must be specified\");\n        \n        if (minRequiredDeposit > 0) {\n            require(minRequiredDeposit >= LITION_MIN_REQUIRED_DEPOSIT,                                  \"Min. required deposit for all chains must be >= LITION_MIN_REQUIRED_DEPOSIT (1000 LIT)\");\n        }\n        \n        if (minRequiredVesting > 0) {\n            require(minRequiredVesting >= LITION_MIN_REQUIRED_VESTING,                                  \"Min. required vesting for all chains must be >= LITION_MIN_REQUIRED_VESTING (1000 LIT)\");\n        }\n        \n        if (rewardBonusRequiredVesting > 0) {\n            require(rewardBonusPercentage > 0,                                                          \"Reward bonus percentage must be > 0%\");    \n        }\n    \n        chainId                         = nextId;\n        ChainInfo storage chain         = chains[chainId];\n        \n        chain.id                        = chainId;\n        chain.description               = description;\n        chain.endpoint                  = initEndpoint;\n        chain.minRequiredDeposit        = minRequiredDeposit;\n        chain.minRequiredVesting        = minRequiredVesting;\n        chain.notaryPeriod              = notaryPeriod;\n        chain.registered                = true;\n        chain.creator                   = msg.sender;\n        \n        if (chainValidator != ChainValidator(0)) {\n            chain.chainValidator = chainValidator;\n        }\n        \n        // Sets min required deposit\n        if (minRequiredDeposit == 0) {\n            chain.minRequiredDeposit = LITION_MIN_REQUIRED_DEPOSIT;\n        } \n        else {\n            chain.minRequiredDeposit = minRequiredDeposit;\n        }\n        \n        // Sets min required vesting\n        if (minRequiredVesting == 0) {\n            chain.minRequiredVesting = LITION_MIN_REQUIRED_VESTING;\n        } \n        else {\n            chain.minRequiredVesting = minRequiredVesting;\n        }\n\n        \n        if (involvedVestingNotaryCond == true) {\n            chain.involvedVestingNotaryCond  = true;    \n        }\n        \n        if (participationNotaryCond == true) {\n            chain.participationNotaryCond    = true;\n        }\n        \n        if (maxNumOfValidators > 0) {\n            chain.maxNumOfValidators         = maxNumOfValidators;\n        }\n        \n        if (maxNumOfTransactors > 0) {\n            chain.maxNumOfTransactors        = maxNumOfTransactors;\n        }\n        \n        if (rewardBonusRequiredVesting > 0) {\n            chain.rewardBonusRequiredVesting = rewardBonusRequiredVesting;\n            chain.rewardBonusPercentage      = rewardBonusPercentage;\n        }\n        \n        emit NewChain(chainId, description, initEndpoint);\n        \n        nextId++;\n    }","contract":"LitionRegistry","time":0},{"type":"external-function ","before":"function notary(uint256 chainId, uint256 notaryStartBlock, uint256 notaryEndBlock, address[] memory validators, uint32[] memory blocksMined,\n                    address[] memory users, uint64[] memory userGas, uint64 largestTx,\n                    uint8[] memory v, bytes32[] memory r, bytes32[] memory s) public {\n                  \n        ChainInfo storage chain = chains[chainId];\n        require(chain.registered    == true,                            \"Invalid chain data: Non-registered chain\");\n        require(validatorExist(chain, msg.sender) == true,              \"Sender must have vesting balance > 0\");\n        require(chain.totalVesting  > 0,                                \"Current chain total_vesting == 0, there are no active validators\");\n        \n        require(validators.length       > 0,                            \"Invalid statistics data: validators.length == 0\");\n        require(validators.length       == blocksMined.length,          \"Invalid statistics data: validators.length != num of block mined\");\n        if (chain.maxNumOfValidators != 0) {\n            require(validators.length   <= chain.maxNumOfValidators,    \"Invalid statistics data: validators.length > maxNumOfValidators\");\n            require(v.length            <= chain.maxNumOfValidators,    \"Invalid statistics data: signatures.length > maxNumOfValidators\");\n        }\n        \n        if (chain.maxNumOfTransactors != 0) {\n            require(users.length    <= chain.maxNumOfTransactors,   \"Invalid statistics data: users.length > maxNumOfTransactors\");\n        }\n        require(users.length        > 0,                            \"Invalid statistics data: users.length == 0\");\n        require(users.length        == userGas.length,              \"Invalid statistics data: users.length != usersGas.length\");\n        \n        require(v.length            == r.length,                    \"Invalid statistics data: v.length != r.length\");\n        require(v.length            == s.length,                    \"Invalid statistics data: v.length != s.length\");\n        require(notaryStartBlock    >  chain.lastNotary.block,      \"Invalid statistics data: notaryBlock_start <= last known notary block\");\n        require(notaryEndBlock      >  notaryStartBlock,            \"Invalid statistics data: notaryEndBlock <= notaryStartBlock\");\n        require(largestTx           >  0,                           \"Invalid statistics data: Largest tx <= 0\");\n        \n        bytes32 signatureHash = keccak256(abi.encodePacked(notaryEndBlock, validators, blocksMined, users, userGas, largestTx));\n        \n        // Validates notary conditions(involvedVesting && participation) to statistics to be accepted\n        validateNotaryConditions(chain, signatureHash, v, r, s);\n        \n        // Calculates total cost based on user's usage durint current notary window\n        uint256 totalCost = processUsersConsumptions(chain, users, userGas, largestTx);\n        \n        // In case totalCost == 0, something is wrong and there is no need for notary to continue as there is no tokens to be distributed to the validators.\n        // There is probably ongoing coordinated attack based on invalid statistics sent to the notary\n        require(totalCost > 0, \"Invalid statistics data: users totalUsageCost == 0\");\n        \n        // How many block could validator mined since the last notary in case he did sign every possible block \n        uint256 maxBlocksMined = (notaryEndBlock - notaryStartBlock) + 1;\n        \n        // Calculates total involved vesting from provided list of validators and removes all validators that did not mine during last 2 notyary windows\n        uint256 totalInvolvedVesting = processNotaryValidators(chain, validators, blocksMined, maxBlocksMined);\n        \n        // In case totalInvolvedVesting == 0, something is wrong and there is no need for notary to continue as rewards cannot be calculated. It might happen\n        // as edge case when the last validator stopped mining durint current notary window or there is ongoing coordinated attack based on invalid statistics sent to the notary\n        require(totalInvolvedVesting > 0, \"totalInvolvedVesting == 0. Invalid statistics or 0 active validators left in the chain\");\n        \n        // Calculates and process validator's rewards based on their participation rate and vesting balance\n        processValidatorsRewards(chain, totalInvolvedVesting, validators, blocksMined, maxBlocksMined, totalCost);\n        \n        // Updates info when the last notary was processed \n        chain.lastNotary.block = notaryEndBlock;\n        chain.lastNotary.timestamp = now;\n        \n        if (chain.active == false) {\n            chain.active = true;\n        }\n        \n        emit Notary(chainId, notaryEndBlock, maxBlocksMined);\n    }","after":"function notary(uint256 chainId, uint256 notaryStartBlock, uint256 notaryEndBlock, address[] calldata validators, uint32[] calldata blocksMined,\n                    address[] calldata users, uint64[] calldata userGas, uint64 largestTx,\n                    uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) public {\n                  \n        ChainInfo storage chain = chains[chainId];\n        require(chain.registered    == true,                            \"Invalid chain data: Non-registered chain\");\n        require(validatorExist(chain, msg.sender) == true,              \"Sender must have vesting balance > 0\");\n        require(chain.totalVesting  > 0,                                \"Current chain total_vesting == 0, there are no active validators\");\n        \n        require(validators.length       > 0,                            \"Invalid statistics data: validators.length == 0\");\n        require(validators.length       == blocksMined.length,          \"Invalid statistics data: validators.length != num of block mined\");\n        if (chain.maxNumOfValidators != 0) {\n            require(validators.length   <= chain.maxNumOfValidators,    \"Invalid statistics data: validators.length > maxNumOfValidators\");\n            require(v.length            <= chain.maxNumOfValidators,    \"Invalid statistics data: signatures.length > maxNumOfValidators\");\n        }\n        \n        if (chain.maxNumOfTransactors != 0) {\n            require(users.length    <= chain.maxNumOfTransactors,   \"Invalid statistics data: users.length > maxNumOfTransactors\");\n        }\n        require(users.length        > 0,                            \"Invalid statistics data: users.length == 0\");\n        require(users.length        == userGas.length,              \"Invalid statistics data: users.length != usersGas.length\");\n        \n        require(v.length            == r.length,                    \"Invalid statistics data: v.length != r.length\");\n        require(v.length            == s.length,                    \"Invalid statistics data: v.length != s.length\");\n        require(notaryStartBlock    >  chain.lastNotary.block,      \"Invalid statistics data: notaryBlock_start <= last known notary block\");\n        require(notaryEndBlock      >  notaryStartBlock,            \"Invalid statistics data: notaryEndBlock <= notaryStartBlock\");\n        require(largestTx           >  0,                           \"Invalid statistics data: Largest tx <= 0\");\n        \n        bytes32 signatureHash = keccak256(abi.encodePacked(notaryEndBlock, validators, blocksMined, users, userGas, largestTx));\n        \n        // Validates notary conditions(involvedVesting && participation) to statistics to be accepted\n        validateNotaryConditions(chain, signatureHash, v, r, s);\n        \n        // Calculates total cost based on user's usage durint current notary window\n        uint256 totalCost = processUsersConsumptions(chain, users, userGas, largestTx);\n        \n        // In case totalCost == 0, something is wrong and there is no need for notary to continue as there is no tokens to be distributed to the validators.\n        // There is probably ongoing coordinated attack based on invalid statistics sent to the notary\n        require(totalCost > 0, \"Invalid statistics data: users totalUsageCost == 0\");\n        \n        // How many block could validator mined since the last notary in case he did sign every possible block \n        uint256 maxBlocksMined = (notaryEndBlock - notaryStartBlock) + 1;\n        \n        // Calculates total involved vesting from provided list of validators and removes all validators that did not mine during last 2 notyary windows\n        uint256 totalInvolvedVesting = processNotaryValidators(chain, validators, blocksMined, maxBlocksMined);\n        \n        // In case totalInvolvedVesting == 0, something is wrong and there is no need for notary to continue as rewards cannot be calculated. It might happen\n        // as edge case when the last validator stopped mining durint current notary window or there is ongoing coordinated attack based on invalid statistics sent to the notary\n        require(totalInvolvedVesting > 0, \"totalInvolvedVesting == 0. Invalid statistics or 0 active validators left in the chain\");\n        \n        // Calculates and process validator's rewards based on their participation rate and vesting balance\n        processValidatorsRewards(chain, totalInvolvedVesting, validators, blocksMined, maxBlocksMined, totalCost);\n        \n        // Updates info when the last notary was processed \n        chain.lastNotary.block = notaryEndBlock;\n        chain.lastNotary.timestamp = now;\n        \n        if (chain.active == false) {\n            chain.active = true;\n        }\n        \n        emit Notary(chainId, notaryEndBlock, maxBlocksMined);\n    }","contract":"LitionRegistry","time":1}]}