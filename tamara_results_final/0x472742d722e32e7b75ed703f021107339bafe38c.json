{"time":101,"results":[{"type":"external-function ","before":"TH.    \n    function checkoutWithETH(\n            address buyerAddress,\n            address payable sellerAddress,\n            address tokenAddress,\n            uint256 tokenUnitPrice,\n            uint256 tokenAmount,\n            address paymentTokenAddress,\n            uint256 paymentTokenRate,\n            uint256 paymentTokenAmount,\n            uint256 expirationTimeSeconds,\n            uint256 salt,\n            bytes32 hash,\n            bytes memory signature\n        )\n        public\n        payable\n        whenNotPaused\n    {\n\n        Invoice memory invoice = Invoice({\n                                buyerAddress: buyerAddress,\n                                sellerAddress: sellerAddress,\n                                tokenAddress: tokenAddress,\n                                tokenUnitPrice: tokenUnitPrice,\n                                tokenAmount: tokenAmount,\n                                paymentTokenAddress: paymentTokenAddress,\n                                paymentTokenRate: paymentTokenRate,\n                                paymentTokenAmount: paymentTokenAmount,\n                                expirationTimeSeconds: expirationTimeSeconds,\n                                salt: salt\n                            });\n\n        // check the hash\n        bytes32 invoiceHash = _getStructHash(invoice);\n        require(invoiceHash == hash, \"invoice hash does not match\");\n\n        // check signature\n        require(_isValidSignature(hash, signature) == true, \"invoice signature is invalid\");\n        \n        // check invoice\n        require(_isValidInvoice(invoice) == true, \"invoice is invalid\");\n\n        // prepare token && allowance check\n        IERC20 token = IERC20(_tokenAddress);\n        require(token.allowance(_sellerAddress, address(this)) >= invoice.tokenAmount, \"insufficient token allowance\");\n\n        // payment amount check\n        require(ETH_TOKEN_ADDRESS == invoice.paymentTokenAddress, \"_ETH_ payment token address is invalid\");\n        require(msg.value == invoice.paymentTokenAmount, \"insufficient ETH payment\");\n\n        // ETH/Token swap execute \n        token.safeTransferFrom(_sellerAddress, invoice.buyerAddress, invoice.tokenAmount);\n        _sellerAddress.transfer(invoice.paymentTokenAmount);\n\n        emit TokenPurchased(invoice.buyerAddress, invoice.tokenAddress, invoice.tokenAmount, invoice","after":"TH.    \n    function checkoutWithETH(\n            address buyerAddress,\n            address payable sellerAddress,\n            address tokenAddress,\n            uint256 tokenUnitPrice,\n            uint256 tokenAmount,\n            address paymentTokenAddress,\n            uint256 paymentTokenRate,\n            uint256 paymentTokenAmount,\n            uint256 expirationTimeSeconds,\n            uint256 salt,\n            bytes32 hash,\n            bytes memory signature\n        )\n        public\n        payable\n        whenNotPaused\n    {\n\n        Invoice memory invoice = Invoice({\n                                buyerAddress: buyerAddress,\n                                sellerAddress: sellerAddress,\n                                tokenAddress: tokenAddress,\n                                tokenUnitPrice: tokenUnitPrice,\n                                tokenAmount: tokenAmount,\n                                paymentTokenAddress: paymentTokenAddress,\n                                paymentTokenRate: paymentTokenRate,\n                                paymentTokenAmount: paymentTokenAmount,\n                                expirationTimeSeconds: expirationTimeSeconds,\n                                salt: salt\n                            });\n\n        // check the hash\n        bytes32 invoiceHash = _getStructHash(invoice);\n        require(invoiceHash == hash, \"invoice hash does not match\");\n\n        // check signature\n        require(_isValidSignature(hash, signature) == true, \"invoice signature is invalid\");\n        \n        // check invoice\n        require(_isValidInvoice(invoice) == true, \"invoice is invalid\");\n\n        // prepare token && allowance check\n        IERC20 token = IERC20(_tokenAddress);\n        require(token.allowance(_sellerAddress, address(this)) >= invoice.tokenAmount, \"insufficient token allowance\");\n\n        // payment amount check\n        require(ETH_TOKEN_ADDRESS == invoice.paymentTokenAddress, \"_ETH_ payment token address is invalid\");\n        require(msg.value == invoice.paymentTokenAmount, \"insufficient ETH payment\");\n\n        // ETH/Token swap execute \n        token.safeTransferFrom(_sellerAddress, invoice.buyerAddress, invoice.tokenAmount);\n        _sellerAddress.transfer(invoice.paymentTokenAmount);\n\n        emit TokenPurchased(invoice.buyerAddress, invoice.tokenAddress, invoice.tokenAmount, invoice","contract":"Payment","time":0},{"type":"external-function ","before":"ETH.   \n    function checkoutWithToken(\n            address buyerAddress,\n            address sellerAddress,\n            address tokenAddress,\n            uint256 tokenUnitPrice,\n            uint256 tokenAmount,\n            address paymentTokenAddress,\n            uint256 paymentTokenRate,\n            uint256 paymentTokenAmount,\n            uint256 expirationTimeSeconds,\n            uint256 salt,\n            bytes32 hash,\n            bytes memory signature\n        ) \n        public\n        whenNotPaused\n    {\n\n        Invoice memory invoice = Invoice({\n                                buyerAddress: buyerAddress,\n                                sellerAddress: sellerAddress,\n                                tokenAddress: tokenAddress,\n                                tokenUnitPrice: tokenUnitPrice,\n                                tokenAmount: tokenAmount,\n                                paymentTokenAddress: paymentTokenAddress,\n                                paymentTokenRate: paymentTokenRate,\n                                paymentTokenAmount: paymentTokenAmount,\n                                expirationTimeSeconds: expirationTimeSeconds,\n                                salt: salt\n                            });\n\n        // check the hash\n        bytes32 invoiceHash = _getStructHash(invoice);\n        require(invoiceHash == hash, \"invoice hash does not match\");\n\n        // check signature\n        require(_isValidSignature(hash, signature) == true, \"invoice signature is invalid\");\n        \n        // check invoice\n        require(_isValidInvoice(invoice) == true, \"invoice is invalid\");\n\n        // prepare token && allowance check\n        IERC20 token = IERC20(_tokenAddress);\n        require(token.allowance(_sellerAddress, address(this)) >= invoice.tokenAmount, \"insufficient token allowance\");\n\n        // prepare payment token && allowance check\n        IERC20 paymentToken = IERC20(invoice.paymentTokenAddress);\n        require(paymentToken.allowance(invoice.buyerAddress, address(this)) >= invoice.paymentTokenAmount, \"insufficient payment token allowance. please approval for the contract before checkout\");\n\n        // ETH/Token swap execute \n        token.safeTransferFrom(_sellerAddress, invoice.buyerAddress, invoice.tokenAmount);\n        paymentToken.safeTransferFrom(invoice.buyerAddress, _sellerAddress, invoice.paymentTokenAmount);\n\n        emit TokenPurchased(invoice.buyerAddress, invoice.tokenAddress, invoice.tokenAmount, invoice","after":"ETH.   \n    function checkoutWithToken(\n            address buyerAddress,\n            address sellerAddress,\n            address tokenAddress,\n            uint256 tokenUnitPrice,\n            uint256 tokenAmount,\n            address paymentTokenAddress,\n            uint256 paymentTokenRate,\n            uint256 paymentTokenAmount,\n            uint256 expirationTimeSeconds,\n            uint256 salt,\n            bytes32 hash,\n            bytes memory signature\n        ) \n        public\n        whenNotPaused\n    {\n\n        Invoice memory invoice = Invoice({\n                                buyerAddress: buyerAddress,\n                                sellerAddress: sellerAddress,\n                                tokenAddress: tokenAddress,\n                                tokenUnitPrice: tokenUnitPrice,\n                                tokenAmount: tokenAmount,\n                                paymentTokenAddress: paymentTokenAddress,\n                                paymentTokenRate: paymentTokenRate,\n                                paymentTokenAmount: paymentTokenAmount,\n                                expirationTimeSeconds: expirationTimeSeconds,\n                                salt: salt\n                            });\n\n        // check the hash\n        bytes32 invoiceHash = _getStructHash(invoice);\n        require(invoiceHash == hash, \"invoice hash does not match\");\n\n        // check signature\n        require(_isValidSignature(hash, signature) == true, \"invoice signature is invalid\");\n        \n        // check invoice\n        require(_isValidInvoice(invoice) == true, \"invoice is invalid\");\n\n        // prepare token && allowance check\n        IERC20 token = IERC20(_tokenAddress);\n        require(token.allowance(_sellerAddress, address(this)) >= invoice.tokenAmount, \"insufficient token allowance\");\n\n        // prepare payment token && allowance check\n        IERC20 paymentToken = IERC20(invoice.paymentTokenAddress);\n        require(paymentToken.allowance(invoice.buyerAddress, address(this)) >= invoice.paymentTokenAmount, \"insufficient payment token allowance. please approval for the contract before checkout\");\n\n        // ETH/Token swap execute \n        token.safeTransferFrom(_sellerAddress, invoice.buyerAddress, invoice.tokenAmount);\n        paymentToken.safeTransferFrom(invoice.buyerAddress, _sellerAddress, invoice.paymentTokenAmount);\n\n        emit TokenPurchased(invoice.buyerAddress, invoice.tokenAddress, invoice.tokenAmount, invoice","contract":"Payment","time":0}]}