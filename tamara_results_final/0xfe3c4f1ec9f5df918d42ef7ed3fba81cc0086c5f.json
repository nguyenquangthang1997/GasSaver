{"time":307,"results":[{"type":"external-function ","before":"function setInflationRate(FixedPoint.Unsigned memory _inflationRate) public onlyOwner {\n        inflationRate = _inflationRate;\n    }","after":"function setInflationRate(FixedPoint.Unsigned calldata _inflationRate) public onlyOwner {\n        inflationRate = _inflationRate;\n    }","contract":"Voting","time":0},{"type":"external-function ","before":"function retrieveRewards(address voterAddress, uint roundId, PendingRequest[] memory toRetrieve)\n        public\n        returns (FixedPoint.Unsigned memory totalRewardToIssue)\n    {\n        if (migratedAddress != address(0)) {\n            require(msg.sender == migratedAddress);\n        }\n        uint blockTime = getCurrentTime();\n        _updateRound(blockTime);\n        require(roundId < voteTiming.computeCurrentRoundId(blockTime));\n\n        Round storage round = rounds[roundId];\n        FixedPoint.Unsigned memory snapshotBalance = FixedPoint.Unsigned(\n            votingToken.balanceOfAt(voterAddress, round.snapshotId));\n\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\n        FixedPoint.Unsigned memory snapshotTotalSupply = FixedPoint.Unsigned(\n            votingToken.totalSupplyAt(round.snapshotId));\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\n\n        // Keep track of the voter's accumulated token reward.\n        totalRewardToIssue = FixedPoint.Unsigned(0);\n\n        for (uint i = 0; i < toRetrieve.length; i++) {\n            PriceRequest storage priceRequest = _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time);\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n\n            require(priceRequest.lastVotingRound == roundId, \"Only retrieve rewards for votes resolved in same round\");\n\n            _resolvePriceRequest(priceRequest, voteInstance);\n\n            if (voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)) {\n                // The price was successfully resolved during the voter's last voting round, the voter revealed and was\n                // correct, so they are elgible for a reward.\n                FixedPoint.Unsigned memory correctTokens = voteInstance.resultComputation.\n                    getTotalCorrectlyVotedTokens();\n\n                // Compute the reward and add to the cumulative reward.\n                FixedPoint.Unsigned memory reward = snapshotBalance.mul(totalRewardPerVote).div(correctTokens);\n                totalRewardToIssue = totalRewardToIssue.add(reward);\n\n                // Emit reward retrieval for this vote.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time,\n                    reward.rawValue);\n            } else {\n                // Emit a 0 token retrieval on incorrect votes.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n            }\n\n            // Delete the submission to capture any refund and clean up storage.\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\n        }\n\n        // Issue any accumulated rewards.\n        if (totalRewardToIssue.isGreaterThan(0)) {\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue));\n        }\n    }","after":"function retrieveRewards(address voterAddress, uint roundId, PendingRequest[] calldata toRetrieve)\n        public\n        returns (FixedPoint.Unsigned memory totalRewardToIssue)\n    {\n        if (migratedAddress != address(0)) {\n            require(msg.sender == migratedAddress);\n        }\n        uint blockTime = getCurrentTime();\n        _updateRound(blockTime);\n        require(roundId < voteTiming.computeCurrentRoundId(blockTime));\n\n        Round storage round = rounds[roundId];\n        FixedPoint.Unsigned memory snapshotBalance = FixedPoint.Unsigned(\n            votingToken.balanceOfAt(voterAddress, round.snapshotId));\n\n        // Compute the total amount of reward that will be issued for each of the votes in the round.\n        FixedPoint.Unsigned memory snapshotTotalSupply = FixedPoint.Unsigned(\n            votingToken.totalSupplyAt(round.snapshotId));\n        FixedPoint.Unsigned memory totalRewardPerVote = round.inflationRate.mul(snapshotTotalSupply);\n\n        // Keep track of the voter's accumulated token reward.\n        totalRewardToIssue = FixedPoint.Unsigned(0);\n\n        for (uint i = 0; i < toRetrieve.length; i++) {\n            PriceRequest storage priceRequest = _getPriceRequest(toRetrieve[i].identifier, toRetrieve[i].time);\n            VoteInstance storage voteInstance = priceRequest.voteInstances[priceRequest.lastVotingRound];\n\n            require(priceRequest.lastVotingRound == roundId, \"Only retrieve rewards for votes resolved in same round\");\n\n            _resolvePriceRequest(priceRequest, voteInstance);\n\n            if (voteInstance.resultComputation.wasVoteCorrect(voteInstance.voteSubmissions[voterAddress].revealHash)) {\n                // The price was successfully resolved during the voter's last voting round, the voter revealed and was\n                // correct, so they are elgible for a reward.\n                FixedPoint.Unsigned memory correctTokens = voteInstance.resultComputation.\n                    getTotalCorrectlyVotedTokens();\n\n                // Compute the reward and add to the cumulative reward.\n                FixedPoint.Unsigned memory reward = snapshotBalance.mul(totalRewardPerVote).div(correctTokens);\n                totalRewardToIssue = totalRewardToIssue.add(reward);\n\n                // Emit reward retrieval for this vote.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time,\n                    reward.rawValue);\n            } else {\n                // Emit a 0 token retrieval on incorrect votes.\n                emit RewardsRetrieved(voterAddress, roundId, toRetrieve[i].identifier, toRetrieve[i].time, 0);\n            }\n\n            // Delete the submission to capture any refund and clean up storage.\n            delete voteInstance.voteSubmissions[voterAddress].revealHash;\n        }\n\n        // Issue any accumulated rewards.\n        if (totalRewardToIssue.isGreaterThan(0)) {\n            require(votingToken.mint(voterAddress, totalRewardToIssue.rawValue));\n        }\n    }","contract":"Voting","time":0},{"type":"external-function ","before":"function setPublicKey(bytes memory publicKey, bytes32 topicHash) public {\n        require(publicKey.length == 64, \"Public key is the wrong length\");\n        recipients[msg.sender].topics[topicHash].publicKey = publicKey;\n    }","after":"function setPublicKey(bytes calldata publicKey, bytes32 topicHash) public {\n        require(publicKey.length == 64, \"Public key is the wrong length\");\n        recipients[msg.sender].topics[topicHash].publicKey = publicKey;\n    }","contract":"Voting","time":0}]}