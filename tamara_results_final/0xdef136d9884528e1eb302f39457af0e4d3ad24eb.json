{"time":200,"results":[{"type":"state-data-arrangement ","before":"\nbytes32 constant private FILE = \"LimitOrders\";\nbytes2 constant private EIP191_HEADER = 0x1901;\nstring constant private EIP712_DOMAIN_NAME = \"LimitOrders\";\nstring constant private EIP712_DOMAIN_VERSION = \"1.1\";\nbytes32 constant private EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"EIP712Domain(\",\n        \"string name,\",\n        \"string version,\",\n        \"uint256 chainId,\",\n        \"address verifyingContract\",\n        \")\"\n    ));\nbytes32 constant private EIP712_LIMIT_ORDER_STRUCT_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"LimitOrder(\",\n        \"uint256 makerMarket,\",\n        \"uint256 takerMarket,\",\n        \"uint256 makerAmount,\",\n        \"uint256 takerAmount,\",\n        \"address makerAccountOwner,\",\n        \"uint256 makerAccountNumber,\",\n        \"address takerAccountOwner,\",\n        \"uint256 takerAccountNumber,\",\n        \"uint256 expiration,\",\n        \"uint256 salt\",\n        \")\"\n    ));\nuint256 constant private NUM_ORDER_BYTES = 320;\nuint256 constant private NUM_SIGNATURE_BYTES = 66;\nuint256 constant private NUM_CALLFUNCTIONDATA_BYTES = 32 + NUM_ORDER_BYTES;\nbytes32 public EIP712_DOMAIN_HASH;\nbool public g_isOperational;\nmapping (bytes32 => uint256) public g_makerFilledAmount;\nmapping (bytes32 => OrderStatus) public g_status;","after":"bytes32 constant private FILE = \"LimitOrders\";\nstring constant private EIP712_DOMAIN_NAME = \"LimitOrders\";\nstring constant private EIP712_DOMAIN_VERSION = \"1.1\";\nbytes32 constant private EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"EIP712Domain(\",\n        \"string name,\",\n        \"string version,\",\n        \"uint256 chainId,\",\n        \"address verifyingContract\",\n        \")\"\n    ));\nbytes32 constant private EIP712_LIMIT_ORDER_STRUCT_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"LimitOrder(\",\n        \"uint256 makerMarket,\",\n        \"uint256 takerMarket,\",\n        \"uint256 makerAmount,\",\n        \"uint256 takerAmount,\",\n        \"address makerAccountOwner,\",\n        \"uint256 makerAccountNumber,\",\n        \"address takerAccountOwner,\",\n        \"uint256 takerAccountNumber,\",\n        \"uint256 expiration,\",\n        \"uint256 salt\",\n        \")\"\n    ));\nuint256 constant private NUM_ORDER_BYTES = 320;\nuint256 constant private NUM_SIGNATURE_BYTES = 66;\nuint256 constant private NUM_CALLFUNCTIONDATA_BYTES = 32 + NUM_ORDER_BYTES;\nbytes32 public EIP712_DOMAIN_HASH;\nmapping (bytes32 => uint256) public g_makerFilledAmount;\nmapping (bytes32 => OrderStatus) public g_status;\nbytes2 constant private EIP191_HEADER = 0x1901;\nbool public g_isOperational;\n","contract":"LimitOrders","time":0},{"type":"external-function ","before":"function cancelOrder(\n        Order memory order\n    )\n        public\n    {\n        cancelOrderInternal(msg.sender, order);\n    }","after":"function cancelOrder(\n        Order calldata order\n    )\n        public\n    {\n        cancelOrderInternal(msg.sender, order);\n    }","contract":"LimitOrders","time":0},{"type":"external-function ","before":"function approveOrder(\n        Order memory order\n    )\n        public\n    {\n        approveOrderInternal(msg.sender, order);\n    }","after":"function approveOrder(\n        Order calldata order\n    )\n        public\n    {\n        approveOrderInternal(msg.sender, order);\n    }","contract":"LimitOrders","time":0},{"type":"external-function ","before":"function getTradeCost(\n        uint256 inputMarketId,\n        uint256 outputMarketId,\n        Account.Info memory makerAccount,\n        Account.Info memory takerAccount,\n        Types.Par memory /* oldInputPar */,\n        Types.Par memory /* newInputPar */,\n        Types.Wei memory inputWei,\n        bytes memory data\n    )\n        public\n        onlySolo(msg.sender)\n        returns (Types.AssetAmount memory)\n    {\n        Require.that(\n            g_isOperational,\n            FILE,\n            \"Contract is not operational\"\n        );\n\n        OrderInfo memory orderInfo = getOrderAndValidateSignature(data);\n\n        verifyOrderAndAccountsAndMarkets(\n            orderInfo,\n            makerAccount,\n            takerAccount,\n            inputMarketId,\n            outputMarketId,\n            inputWei\n        );\n\n        return getOutputAssetAmount(\n            inputMarketId,\n            outputMarketId,\n            inputWei,\n            orderInfo\n        );\n    }","after":"function getTradeCost(\n        uint256 inputMarketId,\n        uint256 outputMarketId,\n        Account.Info calldata makerAccount,\n        Account.Info calldata takerAccount,\n        Types.Par calldata /* oldInputPar */,\n        Types.Par calldata /* newInputPar */,\n        Types.Wei calldata inputWei,\n        bytes calldata data\n    )\n        public\n        onlySolo(msg.sender)\n        returns (Types.AssetAmount memory)\n    {\n        Require.that(\n            g_isOperational,\n            FILE,\n            \"Contract is not operational\"\n        );\n\n        OrderInfo memory orderInfo = getOrderAndValidateSignature(data);\n\n        verifyOrderAndAccountsAndMarkets(\n            orderInfo,\n            makerAccount,\n            takerAccount,\n            inputMarketId,\n            outputMarketId,\n            inputWei\n        );\n\n        return getOutputAssetAmount(\n            inputMarketId,\n            outputMarketId,\n            inputWei,\n            orderInfo\n        );\n    }","contract":"LimitOrders","time":0},{"type":"external-function ","before":"function callFunction(\n        address /* sender */,\n        Account.Info memory accountInfo,\n        bytes memory data\n    )\n        public\n        onlySolo(msg.sender)\n    {\n        Require.that(\n            data.length == NUM_CALLFUNCTIONDATA_BYTES,\n            FILE,\n            \"Cannot parse CallFunctionData\"\n        );\n\n        CallFunctionData memory cfd = abi.decode(data, (CallFunctionData));\n\n        if (cfd.callType == CallFunctionType.Approve) {\n            approveOrderInternal(accountInfo.owner, cfd.order);\n        } else {\n            assert(cfd.callType == CallFunctionType.Cancel);\n            cancelOrderInternal(accountInfo.owner, cfd.order);\n        }\n    }","after":"function callFunction(\n        address /* sender */,\n        Account.Info calldata accountInfo,\n        bytes calldata data\n    )\n        public\n        onlySolo(msg.sender)\n    {\n        Require.that(\n            data.length == NUM_CALLFUNCTIONDATA_BYTES,\n            FILE,\n            \"Cannot parse CallFunctionData\"\n        );\n\n        CallFunctionData memory cfd = abi.decode(data, (CallFunctionData));\n\n        if (cfd.callType == CallFunctionType.Approve) {\n            approveOrderInternal(accountInfo.owner, cfd.order);\n        } else {\n            assert(cfd.callType == CallFunctionType.Cancel);\n            cancelOrderInternal(accountInfo.owner, cfd.order);\n        }\n    }","contract":"LimitOrders","time":0}]}