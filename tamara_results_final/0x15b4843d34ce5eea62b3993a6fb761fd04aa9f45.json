{"time":157,"results":[{"type":"state-data-arrangement ","before":"\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nmapping (uint256 => address) private _tokenOwner;\nmapping (uint256 => address) private _tokenApprovals;\nmapping (address => Counters.Counter) private _ownedTokensCount;\nmapping (address => mapping (address => bool)) private _operatorApprovals;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;","after":"mapping (uint256 => address) private _tokenOwner;\nmapping (uint256 => address) private _tokenApprovals;\nmapping (address => Counters.Counter) private _ownedTokensCount;\nmapping (address => mapping (address => bool)) private _operatorApprovals;\nbytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\nbytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n","contract":"ERC721","time":0},{"type":"state-data-arrangement ","before":"\naddress proxyRegistryAddress;\nuint256 public currentTokenId;\nuint256 public activeTokenId;\nuint8 public currentTermsVersion;\nmapping (uint256 => PromotionPeriod) promotionPeriods;\nmapping (uint256 => PoolProposal) proposedPools;\nmapping (uint256 => uint8) termsVersions;\nmapping (uint8 => string) terms;","after":"uint256 public currentTokenId;\nuint256 public activeTokenId;\nmapping (uint256 => PromotionPeriod) promotionPeriods;\nmapping (uint256 => PoolProposal) proposedPools;\nmapping (uint256 => uint8) termsVersions;\nmapping (uint8 => string) terms;\naddress proxyRegistryAddress;\nuint8 public currentTermsVersion;\n","contract":"PromotedPool","time":0},{"type":"external-function ","before":"function mintTo(address _to, uint256 _startTime, uint256 _endTime, string memory _termsHash, uint8 _termsVersion) public onlyOwner {\n    require(_startTime > now, \"Token must have start time in the future.\");\n    require(_startTime > promotionPeriods[currentTokenId].endTime, \"Token must have start time > most recent token's end time\");\n    if(promotionPeriods[currentTokenId].endTime != 0) {\n      require(_startTime - promotionPeriods[currentTokenId].endTime < 7890000 , \"Token must have start time < 1 year after the most recent token's end time\");\n    }\n    uint256 newTokenId = _getNextTokenId();\n    _mint(_to, newTokenId);\n    _incrementTokenId();\n    promotionPeriods[newTokenId] = PromotionPeriod(_startTime, _endTime);\n    proposedPools[newTokenId] = PoolProposal(address(0), address(0));\n    if(_termsVersion > currentTermsVersion) {\n      terms[_termsVersion] = _termsHash;\n      currentTermsVersion = _termsVersion;\n    }\n    termsVersions[newTokenId] = _termsVersion;\n    emit MintedToken(newTokenId, _to, _startTime, _endTime);\n  }","after":"function mintTo(address _to, uint256 _startTime, uint256 _endTime, string calldata _termsHash, uint8 _termsVersion) public onlyOwner {\n    require(_startTime > now, \"Token must have start time in the future.\");\n    require(_startTime > promotionPeriods[currentTokenId].endTime, \"Token must have start time > most recent token's end time\");\n    if(promotionPeriods[currentTokenId].endTime != 0) {\n      require(_startTime - promotionPeriods[currentTokenId].endTime < 7890000 , \"Token must have start time < 1 year after the most recent token's end time\");\n    }\n    uint256 newTokenId = _getNextTokenId();\n    _mint(_to, newTokenId);\n    _incrementTokenId();\n    promotionPeriods[newTokenId] = PromotionPeriod(_startTime, _endTime);\n    proposedPools[newTokenId] = PoolProposal(address(0), address(0));\n    if(_termsVersion > currentTermsVersion) {\n      terms[_termsVersion] = _termsHash;\n      currentTermsVersion = _termsVersion;\n    }\n    termsVersions[newTokenId] = _termsVersion;\n    emit MintedToken(newTokenId, _to, _startTime, _endTime);\n  }","contract":"PromotedPool","time":0}]}