{"time":89,"results":[{"type":"external-function ","before":"function save(\n        uint ethToFree,\n        address[] memory ctokenAddr,\n        uint[] memory ctokenFactor,\n        uint splitAmt,\n        uint slippageAmt\n    ) public\n    {\n        enterMarket(getCETHAddress());\n        enterMarket(getCDAIAddress());\n        (,,,,uint maxWithdraw,) = getCompStats(address(this), ctokenAddr, ctokenFactor);\n        uint ethToSwap = ethToFree < maxWithdraw ? ethToFree : maxWithdraw;\n        redeemEth(ethToSwap);\n        uint destAmt = SplitSwapInterface(getAddressSplitSwap()).ethToDaiSwap.value(ethToSwap)(splitAmt, slippageAmt);\n        repayDai(destAmt);\n        emit LogSaveDaiCompound(ethToSwap, destAmt);\n    }","after":"function save(\n        uint ethToFree,\n        address[] calldata ctokenAddr,\n        uint[] calldata ctokenFactor,\n        uint splitAmt,\n        uint slippageAmt\n    ) public\n    {\n        enterMarket(getCETHAddress());\n        enterMarket(getCDAIAddress());\n        (,,,,uint maxWithdraw,) = getCompStats(address(this), ctokenAddr, ctokenFactor);\n        uint ethToSwap = ethToFree < maxWithdraw ? ethToFree : maxWithdraw;\n        redeemEth(ethToSwap);\n        uint destAmt = SplitSwapInterface(getAddressSplitSwap()).ethToDaiSwap.value(ethToSwap)(splitAmt, slippageAmt);\n        repayDai(destAmt);\n        emit LogSaveDaiCompound(ethToSwap, destAmt);\n    }","contract":"InstaCompDaiSave","time":1},{"type":"external-function ","before":"function leverage(\n        uint daiToBorrow,\n        address[] memory cTokenAddr,\n        uint[] memory ctokenFactor,\n        uint splitAmt,\n        uint slippageAmt\n    ) public\n    {\n        enterMarket(getCETHAddress());\n        enterMarket(getCDAIAddress());\n        (,,,uint borrowRemain,,) = getCompStats(address(this), cTokenAddr, ctokenFactor);\n        uint daiToSwap = getDaiRemainBorrow(borrowRemain);\n        daiToSwap = daiToSwap < daiToBorrow ? daiToSwap : daiToBorrow;\n        borrow(daiToSwap);\n        ERC20Interface(getAddressDAI()).approve(getAddressSplitSwap(), daiToSwap);\n        uint destAmt = SplitSwapInterface(getAddressSplitSwap()).daiToEthSwap(daiToSwap, splitAmt, slippageAmt);\n        mintCEth(destAmt);\n        emit LogLeverageDaiCompound(daiToSwap, destAmt);\n    }","after":"function leverage(\n        uint daiToBorrow,\n        address[] calldata cTokenAddr,\n        uint[] calldata ctokenFactor,\n        uint splitAmt,\n        uint slippageAmt\n    ) public\n    {\n        enterMarket(getCETHAddress());\n        enterMarket(getCDAIAddress());\n        (,,,uint borrowRemain,,) = getCompStats(address(this), cTokenAddr, ctokenFactor);\n        uint daiToSwap = getDaiRemainBorrow(borrowRemain);\n        daiToSwap = daiToSwap < daiToBorrow ? daiToSwap : daiToBorrow;\n        borrow(daiToSwap);\n        ERC20Interface(getAddressDAI()).approve(getAddressSplitSwap(), daiToSwap);\n        uint destAmt = SplitSwapInterface(getAddressSplitSwap()).daiToEthSwap(daiToSwap, splitAmt, slippageAmt);\n        mintCEth(destAmt);\n        emit LogLeverageDaiCompound(daiToSwap, destAmt);\n    }","contract":"InstaCompDaiSave","time":0},{"type":"external-function ","before":"function getSave(\n        address user,\n        uint ethToFree,\n        address[] memory cTokenAddr,\n        uint[] memory ctokenFactor\n    ) public returns (uint finalColInEth, uint finalDebtInEth, uint daiDebt, bool isOk)\n    {\n        (uint totalSupply, uint totalBorrow,,,uint maxWithdraw,) = getCompStats(user, cTokenAddr, ctokenFactor);\n        uint ethToSwap = ethToFree < maxWithdraw ? ethToFree : maxWithdraw;\n        (, uint expectedDAI) = SplitSwapInterface(getAddressSplitSwap()).getBest(getAddressETH(), getAddressDAI(), ethToSwap);\n        uint daiBorrowed = daiBorrowed(user);\n        uint daiInEth = CompOracleInterface(getCompOracleAddress()).getUnderlyingPrice(getCDAIAddress());\n        if (daiBorrowed < expectedDAI) {\n            finalColInEth = sub(totalSupply, ethToSwap);\n            finalDebtInEth = sub(totalBorrow, wmul(daiBorrowed, daiInEth));\n            daiDebt = 0;\n            isOk = false;\n        } else {\n            finalColInEth = sub(totalSupply, ethToSwap);\n            finalDebtInEth = sub(totalBorrow, wmul(expectedDAI, daiInEth));\n            daiDebt = sub(daiBorrowed, expectedDAI);\n            isOk = true;\n        }\n    }","after":"function getSave(\n        address user,\n        uint ethToFree,\n        address[] calldata cTokenAddr,\n        uint[] calldata ctokenFactor\n    ) public returns (uint finalColInEth, uint finalDebtInEth, uint daiDebt, bool isOk)\n    {\n        (uint totalSupply, uint totalBorrow,,,uint maxWithdraw,) = getCompStats(user, cTokenAddr, ctokenFactor);\n        uint ethToSwap = ethToFree < maxWithdraw ? ethToFree : maxWithdraw;\n        (, uint expectedDAI) = SplitSwapInterface(getAddressSplitSwap()).getBest(getAddressETH(), getAddressDAI(), ethToSwap);\n        uint daiBorrowed = daiBorrowed(user);\n        uint daiInEth = CompOracleInterface(getCompOracleAddress()).getUnderlyingPrice(getCDAIAddress());\n        if (daiBorrowed < expectedDAI) {\n            finalColInEth = sub(totalSupply, ethToSwap);\n            finalDebtInEth = sub(totalBorrow, wmul(daiBorrowed, daiInEth));\n            daiDebt = 0;\n            isOk = false;\n        } else {\n            finalColInEth = sub(totalSupply, ethToSwap);\n            finalDebtInEth = sub(totalBorrow, wmul(expectedDAI, daiInEth));\n            daiDebt = sub(daiBorrowed, expectedDAI);\n            isOk = true;\n        }\n    }","contract":"InstaCompDaiSave","time":0},{"type":"external-function ","before":"function getLeverage(\n        address user,\n        uint daiToBorrow,\n        address[] memory cTokenAddr,\n        uint[] memory ctokenFactor\n    ) public returns (uint finalColInEth, uint finalDebtInEth, uint ethCol)\n    {\n        (uint totalSupply, uint totalBorrow,, uint borrowRemain,,) = getCompStats(user, cTokenAddr, ctokenFactor);\n        uint daiToSwap = getDaiRemainBorrow(borrowRemain);\n        daiToSwap = daiToSwap < daiToBorrow ? daiToSwap : daiToBorrow;\n        (, uint expectedETH) = SplitSwapInterface(getAddressSplitSwap()).getBest(getAddressDAI(), getAddressETH(), daiToSwap);\n        uint daiInEth = CompOracleInterface(getCompOracleAddress()).getUnderlyingPrice(getCDAIAddress());\n        finalColInEth = add(totalSupply, expectedETH);\n        finalDebtInEth = add(totalBorrow, wmul(daiToSwap, daiInEth));\n        ethCol = add(getEthSupply(user), expectedETH);\n    }","after":"function getLeverage(\n        address user,\n        uint daiToBorrow,\n        address[] calldata cTokenAddr,\n        uint[] calldata ctokenFactor\n    ) public returns (uint finalColInEth, uint finalDebtInEth, uint ethCol)\n    {\n        (uint totalSupply, uint totalBorrow,, uint borrowRemain,,) = getCompStats(user, cTokenAddr, ctokenFactor);\n        uint daiToSwap = getDaiRemainBorrow(borrowRemain);\n        daiToSwap = daiToSwap < daiToBorrow ? daiToSwap : daiToBorrow;\n        (, uint expectedETH) = SplitSwapInterface(getAddressSplitSwap()).getBest(getAddressDAI(), getAddressETH(), daiToSwap);\n        uint daiInEth = CompOracleInterface(getCompOracleAddress()).getUnderlyingPrice(getCDAIAddress());\n        finalColInEth = add(totalSupply, expectedETH);\n        finalDebtInEth = add(totalBorrow, wmul(daiToSwap, daiInEth));\n        ethCol = add(getEthSupply(user), expectedETH);\n    }","contract":"InstaCompDaiSave","time":0}]}