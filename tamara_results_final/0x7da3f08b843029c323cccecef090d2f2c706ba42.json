{"time":329,"results":[{"type":"struct-data-arrangement ","before":"\n  address payable[] issue\n  address[] approve\n  uint deadli\n  address tok\n  uint tokenVersi\n  uint balan\n  bool hasPaidO\n  Fulfillment[] fulfillmen\n  Contribution[] contributio","after":"  address payable[] issue\n  address[] approve\n  uint deadli\n  uint tokenVersi\n  uint balan\n  Fulfillment[] fulfillmen\n  Contribution[] contributio\n  address tok\n  bool hasPaidO\n","contract":"StandardBounties","time":0},{"type":"struct-data-arrangement ","before":"\n  address payable contribut\n  uint amou\n  bool refund","after":"  uint amou\n  address payable contribut\n  bool refund\n","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function issueAndContribute(\n    address payable _sender,\n    address payable[] memory _issuers,\n    address[] memory _approvers,\n    string memory _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _depositAmount)\n    public\n    payable\n    returns(uint)\n  {\n    uint bountyId = issueBounty(_sender, _issuers, _approvers, _data, _deadline, _token, _tokenVersion);\n\n    contribute(_sender, bountyId, _depositAmount);\n\n    return (bountyId);\n ","after":"  function issueAndContribute(\n    address payable _sender,\n    address payable[] calldata _issuers,\n    address[] calldata _approvers,\n    string calldata _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _depositAmount)\n    public\n    payable\n    returns(uint)\n  {\n    uint bountyId = issueBounty(_sender, _issuers, _approvers, _data, _deadline, _token, _tokenVersion);\n\n    contribute(_sender, bountyId, _depositAmount);\n\n    return (bountyId);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function refundMyContributions(\n    address _sender,\n    uint _bountyId,\n    uint[] memory _contributionIds)\n    public\n    senderIsValid(_sender)\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n        refundContribution(_sender, _bountyId, _contributionIds[i]);\n    }\n ","after":"  function refundMyContributions(\n    address _sender,\n    uint _bountyId,\n    uint[] calldata _contributionIds)\n    public\n    senderIsValid(_sender)\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n        refundContribution(_sender, _bountyId, _contributionIds[i]);\n    }\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function refundContributions(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] memory _contributionIds)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n      require(_contributionIds[i] < bounties[_bountyId].contributions.length);\n\n      Contribution storage contribution = bounties[_bountyId].contributions[_contributionIds[i]];\n\n      require(!contribution.refunded);\n\n      contribution.refunded = true;\n\n      transferTokens(_bountyId, contribution.contributor, contribution.amount); // Performs the disbursal of tokens to the contributor\n    }\n\n    emit ContributionsRefunded(_bountyId, _sender, _contributionIds);\n ","after":"  function refundContributions(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] calldata _contributionIds)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n      require(_contributionIds[i] < bounties[_bountyId].contributions.length);\n\n      Contribution storage contribution = bounties[_bountyId].contributions[_contributionIds[i]];\n\n      require(!contribution.refunded);\n\n      contribution.refunded = true;\n\n      transferTokens(_bountyId, contribution.contributor, contribution.amount); // Performs the disbursal of tokens to the contributor\n    }\n\n    emit ContributionsRefunded(_bountyId, _sender, _contributionIds);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function drainBounty(\n    address payable _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] memory _amounts)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    if (bounties[_bountyId].tokenVersion == 0 || bounties[_bountyId].tokenVersion == 20){\n      require(_amounts.length == 1); // ensures there's only 1 amount of tokens to be returned\n      require(_amounts[0] <= bounties[_bountyId].balance); // ensures an issuer doesn't try to drain the bounty of more tokens than their balance permits\n      transferTokens(_bountyId, _sender, _amounts[0]); // Performs the draining of tokens to the issuer\n    } else {\n      for (uint i = 0; i < _amounts.length; i++){\n        require(tokenBalances[_bountyId][_amounts[i]]);// ensures an issuer doesn't try to drain the bounty of a token it doesn't have in its balance\n        transferTokens(_bountyId, _sender, _amounts[i]);\n      }\n    }\n\n    emit BountyDrained(_bountyId, _sender, _amounts);\n ","after":"  function drainBounty(\n    address payable _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] calldata _amounts)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    if (bounties[_bountyId].tokenVersion == 0 || bounties[_bountyId].tokenVersion == 20){\n      require(_amounts.length == 1); // ensures there's only 1 amount of tokens to be returned\n      require(_amounts[0] <= bounties[_bountyId].balance); // ensures an issuer doesn't try to drain the bounty of more tokens than their balance permits\n      transferTokens(_bountyId, _sender, _amounts[0]); // Performs the draining of tokens to the issuer\n    } else {\n      for (uint i = 0; i < _amounts.length; i++){\n        require(tokenBalances[_bountyId][_amounts[i]]);// ensures an issuer doesn't try to drain the bounty of a token it doesn't have in its balance\n        transferTokens(_bountyId, _sender, _amounts[i]);\n      }\n    }\n\n    emit BountyDrained(_bountyId, _sender, _amounts);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function performAction(\n    address _sender,\n    uint _bountyId,\n    string memory _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n  {\n    emit ActionPerformed(_bountyId, _sender, _data); // The _data string is emitted in an event for easy off-chain consumption\n ","after":"  function performAction(\n    address _sender,\n    uint _bountyId,\n    string calldata _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n  {\n    emit ActionPerformed(_bountyId, _sender, _data); // The _data string is emitted in an event for easy off-chain consumption\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function updateFulfillment(\n  address _sender,\n  uint _bountyId,\n  uint _fulfillmentId,\n  address payable[] memory _fulfillers,\n  string memory _data)\n  public\n  senderIsValid(_sender)\n  validateBountyArrayIndex(_bountyId)\n  validateFulfillmentArrayIndex(_bountyId, _fulfillmentId)\n  onlySubmitter(_sender, _bountyId, _fulfillmentId) // Only the original submitter of a fulfillment may update their submission\n  {\n    bounties[_bountyId].fulfillments[_fulfillmentId].fulfillers = _fulfillers;\n    emit FulfillmentUpdated(_bountyId,\n                            _fulfillmentId,\n                            _fulfillers,\n                            _data); // The _data string is emitted in an event for easy off-chain consumption\n ","after":"  function updateFulfillment(\n  address _sender,\n  uint _bountyId,\n  uint _fulfillmentId,\n  address payable[] calldata _fulfillers,\n  string calldata _data)\n  public\n  senderIsValid(_sender)\n  validateBountyArrayIndex(_bountyId)\n  validateFulfillmentArrayIndex(_bountyId, _fulfillmentId)\n  onlySubmitter(_sender, _bountyId, _fulfillmentId) // Only the original submitter of a fulfillment may update their submission\n  {\n    bounties[_bountyId].fulfillments[_fulfillmentId].fulfillers = _fulfillers;\n    emit FulfillmentUpdated(_bountyId,\n                            _fulfillmentId,\n                            _fulfillers,\n                            _data); // The _data string is emitted in an event for easy off-chain consumption\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function fulfillAndAccept(\n    address _sender,\n    uint _bountyId,\n    address payable[] memory _fulfillers,\n    string memory _data,\n    uint _approverId,\n    uint[] memory _tokenAmounts)\n    public\n    senderIsValid(_sender)\n  {\n    // first fulfills the bounty on behalf of the fulfillers\n    fulfillBounty(_sender, _bountyId, _fulfillers, _data);\n\n    // then accepts the fulfillment\n    acceptFulfillment(_sender,\n                      _bountyId,\n                      bounties[_bountyId].fulfillments.length - 1,\n                      _approverId,\n                      _tokenAmounts);\n ","after":"  function fulfillAndAccept(\n    address _sender,\n    uint _bountyId,\n    address payable[] calldata _fulfillers,\n    string calldata _data,\n    uint _approverId,\n    uint[] calldata _tokenAmounts)\n    public\n    senderIsValid(_sender)\n  {\n    // first fulfills the bounty on behalf of the fulfillers\n    fulfillBounty(_sender, _bountyId, _fulfillers, _data);\n\n    // then accepts the fulfillment\n    acceptFulfillment(_sender,\n                      _bountyId,\n                      bounties[_bountyId].fulfillments.length - 1,\n                      _approverId,\n                      _tokenAmounts);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function changeBounty(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers,\n    address payable[] memory _approvers,\n    string memory _data,\n    uint _deadline)\n    public\n    senderIsValid(_sender)\n  {\n    require(_bountyId < numBounties); // makes the validateBountyArrayIndex modifier in-line to avoid stack too deep errors\n    require(_issuerId < bounties[_bountyId].issuers.length); // makes the validateIssuerArrayIndex modifier in-line to avoid stack too deep errors\n    require(_sender == bounties[_bountyId].issuers[_issuerId]); // makes the onlyIssuer modifier in-line to avoid stack too deep errors\n\n    require(_issuers.length > 0 || _approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n\n    bounties[_bountyId].issuers = _issuers;\n    bounties[_bountyId].approvers = _approvers;\n    bounties[_bountyId].deadline = _deadline;\n    emit BountyChanged(_bountyId,\n                       _sender,\n                       _issuers,\n                       _approvers,\n                       _data,\n                       _deadline);\n ","after":"  function changeBounty(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers,\n    address payable[] calldata _approvers,\n    string calldata _data,\n    uint _deadline)\n    public\n    senderIsValid(_sender)\n  {\n    require(_bountyId < numBounties); // makes the validateBountyArrayIndex modifier in-line to avoid stack too deep errors\n    require(_issuerId < bounties[_bountyId].issuers.length); // makes the validateIssuerArrayIndex modifier in-line to avoid stack too deep errors\n    require(_sender == bounties[_bountyId].issuers[_issuerId]); // makes the onlyIssuer modifier in-line to avoid stack too deep errors\n\n    require(_issuers.length > 0 || _approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n\n    bounties[_bountyId].issuers = _issuers;\n    bounties[_bountyId].approvers = _approvers;\n    bounties[_bountyId].deadline = _deadline;\n    emit BountyChanged(_bountyId,\n                       _sender,\n                       _issuers,\n                       _approvers,\n                       _data,\n                       _deadline);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function changeData(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    string memory _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    emit BountyDataChanged(_bountyId, _sender, _data); // The new _data is emitted within an event rather than being stored on-chain for minimized gas costs\n ","after":"  function changeData(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    string calldata _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    emit BountyDataChanged(_bountyId, _sender, _data); // The new _data is emitted within an event rather than being stored on-chain for minimized gas costs\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function addIssuers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _issuers.length; i++){\n      bounties[_bountyId].issuers.push(_issuers[i]);\n    }\n\n    emit BountyIssuersUpdated(_bountyId, _sender, bounties[_bountyId].issuers);\n ","after":"  function addIssuers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _issuers.length; i++){\n      bounties[_bountyId].issuers.push(_issuers[i]);\n    }\n\n    emit BountyIssuersUpdated(_bountyId, _sender, bounties[_bountyId].issuers);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function replaceIssuers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    require(_issuers.length > 0 || bounties[_bountyId].approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n\n    bounties[_bountyId].issuers = _issuers;\n\n    emit BountyIssuersUpdated(_bountyId, _sender, bounties[_bountyId].issuers);\n ","after":"  function replaceIssuers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    require(_issuers.length > 0 || bounties[_bountyId].approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n\n    bounties[_bountyId].issuers = _issuers;\n\n    emit BountyIssuersUpdated(_bountyId, _sender, bounties[_bountyId].issuers);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function addApprovers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address[] memory _approvers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _approvers.length; i++){\n      bounties[_bountyId].approvers.push(_approvers[i]);\n    }\n\n    emit BountyApproversUpdated(_bountyId, _sender, bounties[_bountyId].approvers);\n ","after":"  function addApprovers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address[] calldata _approvers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _approvers.length; i++){\n      bounties[_bountyId].approvers.push(_approvers[i]);\n    }\n\n    emit BountyApproversUpdated(_bountyId, _sender, bounties[_bountyId].approvers);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function replaceApprovers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address[] memory _approvers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    require(bounties[_bountyId].issuers.length > 0 || _approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n    bounties[_bountyId].approvers = _approvers;\n\n    emit BountyApproversUpdated(_bountyId, _sender, bounties[_bountyId].approvers);\n ","after":"  function replaceApprovers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address[] calldata _approvers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    require(bounties[_bountyId].issuers.length > 0 || _approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n    bounties[_bountyId].approvers = _approvers;\n\n    emit BountyApproversUpdated(_bountyId, _sender, bounties[_bountyId].approvers);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function metaIssueBounty(\n    bytes memory signature,\n    address payable[] memory _issuers,\n    address[] memory _approvers,\n    string memory _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _nonce)\n    public\n    returns (uint)\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaIssueBounty\",\n                                                  _issuers,\n                                                  _approvers,\n                                                  _data,\n                                                  _deadline,\n                                                  _token,\n                                                  _tokenVersion,\n                                                  _nonce));\n    address signer = getSigner(metaHash, signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n    return bountiesContract.issueBounty(address(uint160(signer)),\n                                         _issuers,\n                                         _approvers,\n                                         _data,\n                                         _deadline,\n                                         _token,\n                                         _tokenVersion);\n ","after":"  function metaIssueBounty(\n    bytes calldata signature,\n    address payable[] calldata _issuers,\n    address[] calldata _approvers,\n    string calldata _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _nonce)\n    public\n    returns (uint)\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaIssueBounty\",\n                                                  _issuers,\n                                                  _approvers,\n                                                  _data,\n                                                  _deadline,\n                                                  _token,\n                                                  _tokenVersion,\n                                                  _nonce));\n    address signer = getSigner(metaHash, signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n    return bountiesContract.issueBounty(address(uint160(signer)),\n                                         _issuers,\n                                         _approvers,\n                                         _data,\n                                         _deadline,\n                                         _token,\n                                         _tokenVersion);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaIssueAndContribute(\n    bytes memory signature,\n    address payable[] memory _issuers,\n    address[] memory _approvers,\n    string memory _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _depositAmount,\n    uint _nonce)\n    public\n    payable\n    returns (uint)\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaIssueAndContribute\",\n                                                  _issuers,\n                                                  _approvers,\n                                                  _data,\n                                                  _deadline,\n                                                  _token,\n                                                  _tokenVersion,\n                                                  _depositAmount,\n                                                  _nonce));\n    address signer = getSigner(metaHash, signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    if (msg.value > 0){\n      return bountiesContract.issueAndContribute.value(msg.value)(address(uint160(signer)),\n                                                 _issuers,\n                                                 _approvers,\n                                                 _data,\n                                                 _deadline,\n                                                 _token,\n                                                 _tokenVersion,\n                                                 _depositAmount);\n    } else {\n      return bountiesContract.issueAndContribute(address(uint160(signer)),\n                                                 _issuers,\n                                                 _approvers,\n                                                 _data,\n                                                 _deadline,\n                                                 _token,\n                                                 _tokenVersion,\n                                                 _depositAmount);\n    }\n\n ","after":"  function metaIssueAndContribute(\n    bytes calldata signature,\n    address payable[] calldata _issuers,\n    address[] calldata _approvers,\n    string calldata _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _depositAmount,\n    uint _nonce)\n    public\n    payable\n    returns (uint)\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaIssueAndContribute\",\n                                                  _issuers,\n                                                  _approvers,\n                                                  _data,\n                                                  _deadline,\n                                                  _token,\n                                                  _tokenVersion,\n                                                  _depositAmount,\n                                                  _nonce));\n    address signer = getSigner(metaHash, signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    if (msg.value > 0){\n      return bountiesContract.issueAndContribute.value(msg.value)(address(uint160(signer)),\n                                                 _issuers,\n                                                 _approvers,\n                                                 _data,\n                                                 _deadline,\n                                                 _token,\n                                                 _tokenVersion,\n                                                 _depositAmount);\n    } else {\n      return bountiesContract.issueAndContribute(address(uint160(signer)),\n                                                 _issuers,\n                                                 _approvers,\n                                                 _data,\n                                                 _deadline,\n                                                 _token,\n                                                 _tokenVersion,\n                                                 _depositAmount);\n    }\n\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaContribute(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _amount,\n    uint _nonce)\n    public\n    payable\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaContribute\",\n                                                  _bountyId,\n                                                  _amount,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    if (msg.value > 0){\n      bountiesContract.contribute.value(msg.value)(address(uint160(signer)), _bountyId, _amount);\n    } else {\n      bountiesContract.contribute(address(uint160(signer)), _bountyId, _amount);\n    }\n ","after":"  function metaContribute(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _amount,\n    uint _nonce)\n    public\n    payable\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaContribute\",\n                                                  _bountyId,\n                                                  _amount,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    if (msg.value > 0){\n      bountiesContract.contribute.value(msg.value)(address(uint160(signer)), _bountyId, _amount);\n    } else {\n      bountiesContract.contribute(address(uint160(signer)), _bountyId, _amount);\n    }\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaRefundContribution(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _contributionId,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaRefundContribution\",\n                                                  _bountyId,\n                                                  _contributionId,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.refundContribution(signer, _bountyId, _contributionId);\n ","after":"  function metaRefundContribution(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _contributionId,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaRefundContribution\",\n                                                  _bountyId,\n                                                  _contributionId,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.refundContribution(signer, _bountyId, _contributionId);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaRefundMyContributions(\n    bytes memory _signature,\n    uint _bountyId,\n    uint[] memory _contributionIds,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaRefundMyContributions\",\n                                                  _bountyId,\n                                                  _contributionIds,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.refundMyContributions(signer, _bountyId, _contributionIds);\n ","after":"  function metaRefundMyContributions(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint[] calldata _contributionIds,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaRefundMyContributions\",\n                                                  _bountyId,\n                                                  _contributionIds,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.refundMyContributions(signer, _bountyId, _contributionIds);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaRefundContributions(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] memory _contributionIds,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaRefundContributions\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _contributionIds,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.refundContributions(signer, _bountyId, _issuerId, _contributionIds);\n ","after":"  function metaRefundContributions(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] calldata _contributionIds,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaRefundContributions\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _contributionIds,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.refundContributions(signer, _bountyId, _issuerId, _contributionIds);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaDrainBounty(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] memory _amounts,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaDrainBounty\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _amounts,\n                                                  _nonce));\n    address payable signer = address(uint160(getSigner(metaHash, _signature)));\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.drainBounty(signer, _bountyId, _issuerId, _amounts);\n ","after":"  function metaDrainBounty(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] calldata _amounts,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaDrainBounty\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _amounts,\n                                                  _nonce));\n    address payable signer = address(uint160(getSigner(metaHash, _signature)));\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.drainBounty(signer, _bountyId, _issuerId, _amounts);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaPerformAction(\n    bytes memory _signature,\n    uint _bountyId,\n    string memory _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaPerformAction\",\n                                                  _bountyId,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.performAction(signer, _bountyId, _data);\n ","after":"  function metaPerformAction(\n    bytes calldata _signature,\n    uint _bountyId,\n    string calldata _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaPerformAction\",\n                                                  _bountyId,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.performAction(signer, _bountyId, _data);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaFulfillBounty(\n    bytes memory _signature,\n    uint _bountyId,\n    address payable[] memory  _fulfillers,\n    string memory _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaFulfillBounty\",\n                                                  _bountyId,\n                                                  _fulfillers,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.fulfillBounty(signer, _bountyId, _fulfillers, _data);\n ","after":"  function metaFulfillBounty(\n    bytes calldata _signature,\n    uint _bountyId,\n    address payable[] calldata  _fulfillers,\n    string calldata _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaFulfillBounty\",\n                                                  _bountyId,\n                                                  _fulfillers,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.fulfillBounty(signer, _bountyId, _fulfillers, _data);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaUpdateFulfillment(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _fulfillmentId,\n    address payable[] memory  _fulfillers,\n    string memory _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaUpdateFulfillment\",\n                                                  _bountyId,\n                                                  _fulfillmentId,\n                                                  _fulfillers,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.updateFulfillment(signer, _bountyId, _fulfillmentId, _fulfillers, _data);\n ","after":"  function metaUpdateFulfillment(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _fulfillmentId,\n    address payable[] calldata  _fulfillers,\n    string calldata _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaUpdateFulfillment\",\n                                                  _bountyId,\n                                                  _fulfillmentId,\n                                                  _fulfillers,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.updateFulfillment(signer, _bountyId, _fulfillmentId, _fulfillers, _data);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaAcceptFulfillment(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _fulfillmentId,\n    uint _approverId,\n    uint[] memory _tokenAmounts,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaAcceptFulfillment\",\n                                                  _bountyId,\n                                                  _fulfillmentId,\n                                                  _approverId,\n                                                  _tokenAmounts,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.acceptFulfillment(signer,\n                       _bountyId,\n                       _fulfillmentId,\n                       _approverId,\n                       _tokenAmounts);\n ","after":"  function metaAcceptFulfillment(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _fulfillmentId,\n    uint _approverId,\n    uint[] calldata _tokenAmounts,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaAcceptFulfillment\",\n                                                  _bountyId,\n                                                  _fulfillmentId,\n                                                  _approverId,\n                                                  _tokenAmounts,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.acceptFulfillment(signer,\n                       _bountyId,\n                       _fulfillmentId,\n                       _approverId,\n                       _tokenAmounts);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaFulfillAndAccept(\n    bytes memory _signature,\n    uint _bountyId,\n    address payable[] memory _fulfillers,\n    string memory _data,\n    uint _approverId,\n    uint[] memory _tokenAmounts,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaFulfillAndAccept\",\n                                                  _bountyId,\n                                                  _fulfillers,\n                                                  _data,\n                                                  _approverId,\n                                                  _tokenAmounts,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.fulfillAndAccept(signer,\n                      _bountyId,\n                      _fulfillers,\n                      _data,\n                      _approverId,\n                      _tokenAmounts);\n ","after":"  function metaFulfillAndAccept(\n    bytes calldata _signature,\n    uint _bountyId,\n    address payable[] calldata _fulfillers,\n    string calldata _data,\n    uint _approverId,\n    uint[] calldata _tokenAmounts,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaFulfillAndAccept\",\n                                                  _bountyId,\n                                                  _fulfillers,\n                                                  _data,\n                                                  _approverId,\n                                                  _tokenAmounts,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.fulfillAndAccept(signer,\n                      _bountyId,\n                      _fulfillers,\n                      _data,\n                      _approverId,\n                      _tokenAmounts);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaChangeBounty(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers,\n    address payable[] memory _approvers,\n    string memory _data,\n    uint _deadline,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeBounty\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _issuers,\n                                                  _approvers,\n                                                  _data,\n                                                  _deadline,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeBounty(signer,\n                  _bountyId,\n                  _issuerId,\n                  _issuers,\n                  _approvers,\n                  _data,\n                  _deadline);\n ","after":"  function metaChangeBounty(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers,\n    address payable[] calldata _approvers,\n    string calldata _data,\n    uint _deadline,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeBounty\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _issuers,\n                                                  _approvers,\n                                                  _data,\n                                                  _deadline,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeBounty(signer,\n                  _bountyId,\n                  _issuerId,\n                  _issuers,\n                  _approvers,\n                  _data,\n                  _deadline);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaChangeIssuer(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint _issuerIdToChange,\n    address payable _newIssuer,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeIssuer\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _issuerIdToChange,\n                                                  _newIssuer,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeIssuer(signer,\n                  _bountyId,\n                  _issuerId,\n                  _issuerIdToChange,\n                  _newIssuer);\n ","after":"  function metaChangeIssuer(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint _issuerIdToChange,\n    address payable _newIssuer,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeIssuer\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _issuerIdToChange,\n                                                  _newIssuer,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeIssuer(signer,\n                  _bountyId,\n                  _issuerId,\n                  _issuerIdToChange,\n                  _newIssuer);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaChangeApprover(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint _approverId,\n    address payable _approver,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeApprover\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _approverId,\n                                                  _approver,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeApprover(signer,\n                  _bountyId,\n                  _issuerId,\n                  _approverId,\n                  _approver);\n ","after":"  function metaChangeApprover(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint _approverId,\n    address payable _approver,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeApprover\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _approverId,\n                                                  _approver,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeApprover(signer,\n                  _bountyId,\n                  _issuerId,\n                  _approverId,\n                  _approver);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaChangeData(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    string memory _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeData\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeData(signer,\n                _bountyId,\n                _issuerId,\n                _data);\n ","after":"  function metaChangeData(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    string calldata _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeData\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeData(signer,\n                _bountyId,\n                _issuerId,\n                _data);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaChangeDeadline(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint  _deadline,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeDeadline\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _deadline,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeDeadline(signer,\n                    _bountyId,\n                    _issuerId,\n                    _deadline);\n ","after":"  function metaChangeDeadline(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint  _deadline,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeDeadline\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _deadline,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeDeadline(signer,\n                    _bountyId,\n                    _issuerId,\n                    _deadline);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaAddIssuers(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaAddIssuers\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _issuers,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.addIssuers(signer,\n                _bountyId,\n                _issuerId,\n                _issuers);\n ","after":"  function metaAddIssuers(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaAddIssuers\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _issuers,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.addIssuers(signer,\n                _bountyId,\n                _issuerId,\n                _issuers);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaReplaceIssuers(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaReplaceIssuers\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _issuers,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.replaceIssuers(signer,\n                    _bountyId,\n                    _issuerId,\n                    _issuers);\n ","after":"  function metaReplaceIssuers(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaReplaceIssuers\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _issuers,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.replaceIssuers(signer,\n                    _bountyId,\n                    _issuerId,\n                    _issuers);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaAddApprovers(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address[] memory _approvers,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaAddApprovers\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _approvers,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.addApprovers(signer,\n                _bountyId,\n                _issuerId,\n                _approvers);\n ","after":"  function metaAddApprovers(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address[] calldata _approvers,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaAddApprovers\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _approvers,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.addApprovers(signer,\n                _bountyId,\n                _issuerId,\n                _approvers);\n ","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"  function metaReplaceApprovers(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address[] memory _approvers,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaReplaceApprovers\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _approvers,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.replaceApprovers(signer,\n                    _bountyId,\n                    _issuerId,\n                    _approvers);\n ","after":"  function metaReplaceApprovers(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address[] calldata _approvers,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaReplaceApprovers\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _approvers,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.replaceApprovers(signer,\n                    _bountyId,\n                    _issuerId,\n                    _approvers);\n ","contract":"BountiesMetaTxRelayer","time":0}]}