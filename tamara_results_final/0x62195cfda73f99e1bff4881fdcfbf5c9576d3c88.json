{"time":137,"results":[{"type":"struct-data-arrangement ","before":"\n address signator\n string templateTerm\n string signatureDetail\n uint256 lexI\n uint256 dcNumbe\n uint256 timeStam\n bool revoke","after":" string templateTerm\n string signatureDetail\n uint256 lexI\n uint256 dcNumbe\n uint256 timeStam\n address signator\n bool revoke\n","contract":"lexDAOregistry","time":0},{"type":"external-function ","before":"\n    function writeLexScript(string memory templateTerms, uint256 lexRate, address lexAddress) public {\n        require(isReputable(msg.sender)); // program governance check / lexScribe must be reputable \n\t\n\t    uint256 lexID = LSW.add(1); // reflects new lexScript value for tracking lexScript wrappers\n\t    uint256 lexVersion = 0; // initalized lexVersion, \"0\"\n\t    LSW = LSW.add(1); // counts new entry to LSW \n\t    \n\t        lexScript[lexID] = lexScriptWrapper( // populate lexScript data for rddr / rdc usage\n                msg.sender,\n                lexAddress,\n                templateTerms,\n                lexID,\n                lexVersion,\n                lexRate);\n                \n        _mint(msg.sender, 1000000000000000000); // mint lexScribe \"1\" LEX for contribution to TLDR\n\t\n        emit Enscribed(lexID, lexVersion, msg.sender); \n","after":"\n    function writeLexScript(string calldata templateTerms, uint256 lexRate, address lexAddress) public {\n        require(isReputable(msg.sender)); // program governance check / lexScribe must be reputable \n\t\n\t    uint256 lexID = LSW.add(1); // reflects new lexScript value for tracking lexScript wrappers\n\t    uint256 lexVersion = 0; // initalized lexVersion, \"0\"\n\t    LSW = LSW.add(1); // counts new entry to LSW \n\t    \n\t        lexScript[lexID] = lexScriptWrapper( // populate lexScript data for rddr / rdc usage\n                msg.sender,\n                lexAddress,\n                templateTerms,\n                lexID,\n                lexVersion,\n                lexRate);\n                \n        _mint(msg.sender, 1000000000000000000); // mint lexScribe \"1\" LEX for contribution to TLDR\n\t\n        emit Enscribed(lexID, lexVersion, msg.sender); \n","contract":"lexDAOregistry","time":1},{"type":"external-function ","before":"\n    function editLexScript(uint256 lexID, string memory templateTerms, address lexAddress) public {\n\t    lexScriptWrapper storage lS = lexScript[lexID]; // retrieve LSW data\n\t\n\t    require(address(msg.sender) == lS.lexScribe); // program safety check / authorization \n\t\n\t    uint256 lexVersion = lS.lexVersion.add(1); // updates lexVersion \n\t    \n\t        lexScript[lexID] = lexScriptWrapper( // populate updated lexScript data for rddr / rdc usage\n                msg.sender,\n                lexAddress,\n                templateTerms,\n                lexID,\n                lexVersion,\n                lS.lexRate);\n                \t\n        emit Enscribed(lexID, lexVersion, msg.sender);\n","after":"\n    function editLexScript(uint256 lexID, string calldata templateTerms, address lexAddress) public {\n\t    lexScriptWrapper storage lS = lexScript[lexID]; // retrieve LSW data\n\t\n\t    require(address(msg.sender) == lS.lexScribe); // program safety check / authorization \n\t\n\t    uint256 lexVersion = lS.lexVersion.add(1); // updates lexVersion \n\t    \n\t        lexScript[lexID] = lexScriptWrapper( // populate updated lexScript data for rddr / rdc usage\n                msg.sender,\n                lexAddress,\n                templateTerms,\n                lexID,\n                lexVersion,\n                lS.lexRate);\n                \t\n        emit Enscribed(lexID, lexVersion, msg.sender);\n","contract":"lexDAOregistry","time":0},{"type":"external-function ","before":"\n    function signDC(uint256 lexID, string memory signatureDetails) public { // sign Digital Covenant with (0x) address\n\t    lexScriptWrapper storage lS = lexScript[lexID]; // retrieve LSW data\n\t\n\t    uint256 dcNumber = RDC.add(1); // reflects new rdc value for public inspection and signature revocation\n\t    bool revoked = false; // initialized value of rdc revocation status, \"false\"\n\t    RDC = RDC.add(1); // counts new entry to RDC\n\t        \n\t        rdc[dcNumber] = DC( // populate rdc data\n                msg.sender,\n                lS.templateTerms,\n                signatureDetails,\n                lexID,\n                dcNumber,\n                now,\n                revoked);\n                \t\n        emit Signed(lexID, dcNumber, msg.sender);\n","after":"\n    function signDC(uint256 lexID, string calldata signatureDetails) public { // sign Digital Covenant with (0x) address\n\t    lexScriptWrapper storage lS = lexScript[lexID]; // retrieve LSW data\n\t\n\t    uint256 dcNumber = RDC.add(1); // reflects new rdc value for public inspection and signature revocation\n\t    bool revoked = false; // initialized value of rdc revocation status, \"false\"\n\t    RDC = RDC.add(1); // counts new entry to RDC\n\t        \n\t        rdc[dcNumber] = DC( // populate rdc data\n                msg.sender,\n                lS.templateTerms,\n                signatureDetails,\n                lexID,\n                dcNumber,\n                now,\n                revoked);\n                \t\n        emit Signed(lexID, dcNumber, msg.sender);\n","contract":"lexDAOregistry","time":0},{"type":"external-function ","before":"\n    function registerDDR( // rddr \n    \taddress client,\n    \taddress provider,\n    \tERC20 ddrToken,\n    \tstring memory deliverable,\n    \tstring memory governingLawForum,\n        uint256 retainerDuration,\n    \tuint256 deliverableRate,\n    \tuint256 payCap,\n    \tuint256 lexID) public {\n    \trequire(lexID != (0)); // program safety check \n        require(deliverableRate <= payCap); // program safety check / economics\n\t    require(msg.sender == provider); // program safety check / authorization / provider countersigns client payCap TLDR approval for effective rddr\n        \n\t    uint256 ddrNumber = RDDR.add(1); // reflects new rddr value for inspection and client digital payments\n        uint256 retainerTermination = now.add(retainerDuration); // rddr termination date in UnixTime, \"now\" block.timestamp + retainerDuration\n        \n\t    ddrToken.transferFrom(client, address(this), payCap); // escrows payCap amount in approved ddrToken into TLDR for rddr payments and/or lexScribe resolution\n        \n\t    RDDR = RDDR.add(1); // counts new entry to RDDR\n    \n            rddr[ddrNumber] = DDR( // populate rddr data \n                client,\n                provider,\n                ddrToken,\n                deliverable,\n                governingLawForum,\n                lexID,\n                ddrNumber,\n                now, // block.timestamp, \"now\"\n                retainerTermination,\n                deliverableRate,\n                0,\n                payCap,\n                false);\n        \t \n        emit Registered(lexID, ddrNumber); \n","after":"\n    function registerDDR( // rddr \n    \taddress client,\n    \taddress provider,\n    \tERC20 ddrToken,\n    \tstring calldata deliverable,\n    \tstring calldata governingLawForum,\n        uint256 retainerDuration,\n    \tuint256 deliverableRate,\n    \tuint256 payCap,\n    \tuint256 lexID) public {\n    \trequire(lexID != (0)); // program safety check \n        require(deliverableRate <= payCap); // program safety check / economics\n\t    require(msg.sender == provider); // program safety check / authorization / provider countersigns client payCap TLDR approval for effective rddr\n        \n\t    uint256 ddrNumber = RDDR.add(1); // reflects new rddr value for inspection and client digital payments\n        uint256 retainerTermination = now.add(retainerDuration); // rddr termination date in UnixTime, \"now\" block.timestamp + retainerDuration\n        \n\t    ddrToken.transferFrom(client, address(this), payCap); // escrows payCap amount in approved ddrToken into TLDR for rddr payments and/or lexScribe resolution\n        \n\t    RDDR = RDDR.add(1); // counts new entry to RDDR\n    \n            rddr[ddrNumber] = DDR( // populate rddr data \n                client,\n                provider,\n                ddrToken,\n                deliverable,\n                governingLawForum,\n                lexID,\n                ddrNumber,\n                now, // block.timestamp, \"now\"\n                retainerTermination,\n                deliverableRate,\n                0,\n                payCap,\n                false);\n        \t \n        emit Registered(lexID, ddrNumber); \n","contract":"lexDAOregistry","time":0},{"type":"constant-restrict-modification  ","before":" address public lexContractAddress = address(this)","after":" address public constant lexContractAddress = address(this)","contract":"lexDAOregistry","time":0},{"type":"constant-restrict-modification  ","before":" string public name = \"lexDAO\"","after":" string public constant name = \"lexDAO\"","contract":"lexDAOregistry","time":0},{"type":"constant-restrict-modification  ","before":" string public symbol = \"LEX\"","after":" string public constant symbol = \"LEX\"","contract":"lexDAOregistry","time":0},{"type":"constant-restrict-modification  ","before":" uint8 public decimals = 18","after":" uint8 public constant decimals = 18","contract":"lexDAOregistry","time":0}]}