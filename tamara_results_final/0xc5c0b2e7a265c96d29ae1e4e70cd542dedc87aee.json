{"time":115,"results":[{"type":"external-function ","before":"function confidentialApprove(\n        bytes32 _noteHash,\n        address _spender,\n        bool _spenderApproval,\n        bytes memory _signature\n    ) public {\n        ( uint8 status, , , ) = ace.getNote(address(this), _noteHash);\n        require(status == 1, \"only unspent notes can be approved\");\n\n        bytes32 signatureHash = keccak256(abi.encodePacked(_signature));\n        require(signatureLog[signatureHash] != true, \"signature has already been used\");\n        signatureLog[signatureHash] = true;\n\n        bytes32 _hashStruct = keccak256(abi.encode(\n                NOTE_SIGNATURE_TYPEHASH,\n                _noteHash,\n                _spender,\n                _spenderApproval\n        ));\n\n        validateSignature(_hashStruct, _noteHash, _signature);\n        confidentialApproved[_noteHash][_spender] = _spenderApproval;\n    }","after":"function confidentialApprove(\n        bytes32 _noteHash,\n        address _spender,\n        bool _spenderApproval,\n        bytes calldata _signature\n    ) public {\n        ( uint8 status, , , ) = ace.getNote(address(this), _noteHash);\n        require(status == 1, \"only unspent notes can be approved\");\n\n        bytes32 signatureHash = keccak256(abi.encodePacked(_signature));\n        require(signatureLog[signatureHash] != true, \"signature has already been used\");\n        signatureLog[signatureHash] = true;\n\n        bytes32 _hashStruct = keccak256(abi.encode(\n                NOTE_SIGNATURE_TYPEHASH,\n                _noteHash,\n                _spender,\n                _spenderApproval\n        ));\n\n        validateSignature(_hashStruct, _noteHash, _signature);\n        confidentialApproved[_noteHash][_spender] = _spenderApproval;\n    }","contract":"ZkAssetDetailed","time":0},{"type":"external-function ","before":"function confidentialTransferFrom(uint24 _proof, bytes memory _proofOutput) public {\n        (bytes memory inputNotes,\n        bytes memory outputNotes,\n        address publicOwner,\n        int256 publicValue) = _proofOutput.extractProofOutput();\n\n        bytes32 proofHash = keccak256(_proofOutput);\n\n        if (confidentialApproved[proofHash][msg.sender] != true) {\n            uint256 length = inputNotes.getLength();\n            for (uint i = 0; i < length; i += 1) {\n                (, bytes32 noteHash, ) = inputNotes.get(i).extractNote();\n                require(\n                    confidentialApproved[noteHash][msg.sender] == true,\n                    \"sender does not have approval to spend input note\"\n                );\n            }\n        }\n\n        ace.updateNoteRegistry(_proof, _proofOutput, msg.sender);\n\n        logInputNotes(inputNotes);\n        logOutputNotes(outputNotes);\n\n        if (publicValue < 0) {\n            emit ConvertTokens(publicOwner, uint256(-publicValue));\n        }\n        if (publicValue > 0) {\n            emit RedeemTokens(publicOwner, uint256(publicValue));\n        }\n    }","after":"function confidentialTransferFrom(uint24 _proof, bytes calldata _proofOutput) public {\n        (bytes memory inputNotes,\n        bytes memory outputNotes,\n        address publicOwner,\n        int256 publicValue) = _proofOutput.extractProofOutput();\n\n        bytes32 proofHash = keccak256(_proofOutput);\n\n        if (confidentialApproved[proofHash][msg.sender] != true) {\n            uint256 length = inputNotes.getLength();\n            for (uint i = 0; i < length; i += 1) {\n                (, bytes32 noteHash, ) = inputNotes.get(i).extractNote();\n                require(\n                    confidentialApproved[noteHash][msg.sender] == true,\n                    \"sender does not have approval to spend input note\"\n                );\n            }\n        }\n\n        ace.updateNoteRegistry(_proof, _proofOutput, msg.sender);\n\n        logInputNotes(inputNotes);\n        logOutputNotes(outputNotes);\n\n        if (publicValue < 0) {\n            emit ConvertTokens(publicOwner, uint256(-publicValue));\n        }\n        if (publicValue > 0) {\n            emit RedeemTokens(publicOwner, uint256(publicValue));\n        }\n    }","contract":"ZkAssetDetailed","time":0},{"type":"external-function ","before":"function updateNoteMetaData(bytes32 noteHash, bytes memory metaData) public {\n        // Get the note from this assets registry\n        ( uint8 status, , , address noteOwner ) = ace.getNote(address(this), noteHash);\n\n        bytes32 addressID = keccak256(abi.encodePacked(msg.sender, noteHash));\n        require(\n            (noteAccess[addressID] >= metaDataTimeLog[noteHash] || noteOwner == msg.sender) && status == 1,\n            'caller does not have permission to update metaData'\n        );\n\n        // Approve the addresses in the note metaData\n        approveAddresses(metaData, noteHash);\n\n        // Set the metaDataTimeLog to the latest block time\n        setMetaDataTimeLog(noteHash);\n\n        emit UpdateNoteMetaData(noteOwner, noteHash, metaData);\n    }","after":"function updateNoteMetaData(bytes32 noteHash, bytes calldata metaData) public {\n        // Get the note from this assets registry\n        ( uint8 status, , , address noteOwner ) = ace.getNote(address(this), noteHash);\n\n        bytes32 addressID = keccak256(abi.encodePacked(msg.sender, noteHash));\n        require(\n            (noteAccess[addressID] >= metaDataTimeLog[noteHash] || noteOwner == msg.sender) && status == 1,\n            'caller does not have permission to update metaData'\n        );\n\n        // Approve the addresses in the note metaData\n        approveAddresses(metaData, noteHash);\n\n        // Set the metaDataTimeLog to the latest block time\n        setMetaDataTimeLog(noteHash);\n\n        emit UpdateNoteMetaData(noteOwner, noteHash, metaData);\n    }","contract":"ZkAssetDetailed","time":0}]}