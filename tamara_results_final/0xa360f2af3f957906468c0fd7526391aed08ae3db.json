{"time":274,"results":[{"type":"external-function ","before":"function endFailedAuction(\n        uint256 _startingCurrentSetAmount,\n        uint256 _calculatedUnitShares,\n        address _currentSet,\n        address _coreAddress,\n        RebalancingLibrary.AuctionPriceParameters memory _auctionPriceParameters,\n        RebalancingLibrary.BiddingParameters memory _biddingParameters,\n        uint8 _rebalanceState\n    )\n        public\n        returns (uint8)\n    {\n        // Token must be in Rebalance State\n        require(\n            _rebalanceState ==  uint8(RebalancingLibrary.State.Rebalance),\n            \"RebalanceAuctionModule.endFailedAuction: Rebalancing Set Token must be in Rebalance State\"\n        );\n\n        // Calculate timestamp when pivot is reached\n        uint256 revertAuctionTime = _auctionPriceParameters.auctionStartTime.add(\n            _auctionPriceParameters.auctionTimeToPivot\n        );\n\n        // Make sure auction has gone past pivot point\n        require(\n            block.timestamp >= revertAuctionTime,\n            \"RebalanceAuctionModule.endFailedAuction: Can only be called after auction reaches pivot\"\n        );\n\n        uint8 newRebalanceState;\n        /**\n         * If not enough sets have been bid on then allow auction to fail where no bids being registered\n         * returns the rebalancing set token to pre-auction state and some bids being registered puts the\n         * rebalancing set token in Drawdown mode.\n         *\n         * However, if enough sets have been bid on. Then allow auction to fail and enter Drawdown state if\n         * and only if the calculated post-auction unitShares is equal to 0.\n         */\n        if (_biddingParameters.remainingCurrentSets >= _biddingParameters.minimumBid) {\n            // Check if any bids have been placed\n            if (_startingCurrentSetAmount == _biddingParameters.remainingCurrentSets) {\n                // If bid not placed, reissue current Set\n                ICore(_coreAddress).issueInVault(\n                    _currentSet,\n                    _startingCurrentSetAmount\n                );\n\n                // Set Rebalance Set Token state to Default\n                newRebalanceState = uint8(RebalancingLibrary.State.Default);\n            } else {\n                // Set Rebalancing Set Token to Drawdown state\n                newRebalanceState = uint8(RebalancingLibrary.State.Drawdown);\n            }\n        } else {\n            // If settleRebalance can be called then endFailedAuction can't be unless calculatedUnitShares\n            // equals 0\n            require(\n                _calculatedUnitShares == 0,\n                \"RebalancingSetToken.endFailedAuction: Cannot be called if rebalance is viably completed\"\n            );\n\n            // If calculated unitShares equals 0 set to Drawdown state\n            newRebalanceState = uint8(RebalancingLibrary.State.Drawdown);\n        }\n\n        return newRebalanceState;\n    }","after":"function endFailedAuction(\n        uint256 _startingCurrentSetAmount,\n        uint256 _calculatedUnitShares,\n        address _currentSet,\n        address _coreAddress,\n        RebalancingLibrary.AuctionPriceParameters calldata _auctionPriceParameters,\n        RebalancingLibrary.BiddingParameters calldata _biddingParameters,\n        uint8 _rebalanceState\n    )\n        public\n        returns (uint8)\n    {\n        // Token must be in Rebalance State\n        require(\n            _rebalanceState ==  uint8(RebalancingLibrary.State.Rebalance),\n            \"RebalanceAuctionModule.endFailedAuction: Rebalancing Set Token must be in Rebalance State\"\n        );\n\n        // Calculate timestamp when pivot is reached\n        uint256 revertAuctionTime = _auctionPriceParameters.auctionStartTime.add(\n            _auctionPriceParameters.auctionTimeToPivot\n        );\n\n        // Make sure auction has gone past pivot point\n        require(\n            block.timestamp >= revertAuctionTime,\n            \"RebalanceAuctionModule.endFailedAuction: Can only be called after auction reaches pivot\"\n        );\n\n        uint8 newRebalanceState;\n        /**\n         * If not enough sets have been bid on then allow auction to fail where no bids being registered\n         * returns the rebalancing set token to pre-auction state and some bids being registered puts the\n         * rebalancing set token in Drawdown mode.\n         *\n         * However, if enough sets have been bid on. Then allow auction to fail and enter Drawdown state if\n         * and only if the calculated post-auction unitShares is equal to 0.\n         */\n        if (_biddingParameters.remainingCurrentSets >= _biddingParameters.minimumBid) {\n            // Check if any bids have been placed\n            if (_startingCurrentSetAmount == _biddingParameters.remainingCurrentSets) {\n                // If bid not placed, reissue current Set\n                ICore(_coreAddress).issueInVault(\n                    _currentSet,\n                    _startingCurrentSetAmount\n                );\n\n                // Set Rebalance Set Token state to Default\n                newRebalanceState = uint8(RebalancingLibrary.State.Default);\n            } else {\n                // Set Rebalancing Set Token to Drawdown state\n                newRebalanceState = uint8(RebalancingLibrary.State.Drawdown);\n            }\n        } else {\n            // If settleRebalance can be called then endFailedAuction can't be unless calculatedUnitShares\n            // equals 0\n            require(\n                _calculatedUnitShares == 0,\n                \"RebalancingSetToken.endFailedAuction: Cannot be called if rebalance is viably completed\"\n            );\n\n            // If calculated unitShares equals 0 set to Drawdown state\n            newRebalanceState = uint8(RebalancingLibrary.State.Drawdown);\n        }\n\n        return newRebalanceState;\n    }","contract":"FailAuctionLibrary","time":0},{"type":"struct-data-arrangement ","before":"\naddress manager\naddress currentSet\naddress coreAddress\naddress componentWhitelist\naddress factoryAddress\nuint256 lastRebalanceTimestamp\nuint256 rebalanceInterval\nuint8 rebalanceState","after":"uint256 lastRebalanceTimestamp\nuint256 rebalanceInterval\naddress manager\naddress currentSet\naddress coreAddress\naddress componentWhitelist\naddress factoryAddress\nuint8 rebalanceState\n","contract":"ProposeLibrary","time":1},{"type":"external-function ","before":"function validateProposal(\n        address _nextSet,\n        address _auctionLibrary,\n        ProposalContext memory _proposalContext,\n        RebalancingLibrary.AuctionPriceParameters memory _auctionPriceParameters\n    )\n        public\n    {\n        ICore coreInstance = ICore(_proposalContext.coreAddress);\n        IRebalancingSetFactory factoryInstance = IRebalancingSetFactory(_proposalContext.factoryAddress);\n\n        // Make sure it is manager that is proposing the rebalance\n        require(\n            msg.sender == _proposalContext.manager,\n            \"ProposeLibrary.validateProposal: Sender must be manager\"\n        );\n\n        // New Proposal can only be made in Default and Proposal state\n        require(\n            _proposalContext.rebalanceState == uint8(RebalancingLibrary.State.Default) ||\n            _proposalContext.rebalanceState == uint8(RebalancingLibrary.State.Proposal),\n            \"ProposeLibrary.validateProposal: State must be in Propose or Default\"\n        );\n\n        // Make sure enough time has passed from last rebalance to start a new proposal\n        require(\n            block.timestamp >= _proposalContext.lastRebalanceTimestamp.add(\n                _proposalContext.rebalanceInterval\n            ),\n            \"ProposeLibrary.validateProposal: Rebalance interval not elapsed\"\n        );\n\n        // Check that new proposed Set is valid Set created by Core\n        require(\n            coreInstance.validSets(_nextSet),\n            \"ProposeLibrary.validateProposal: Invalid or disabled proposed SetToken address\"\n        );\n\n        // Check proposed components on whitelist. This is to ensure managers are unable to add contract addresses\n        // to a propose that prohibit the set from carrying out an auction i.e. a token that only the manager possesses\n        require(\n            IWhiteList(\n                _proposalContext.componentWhitelist\n            ).areValidAddresses(ISetToken(_nextSet).getComponents()),\n            \"ProposeLibrary.validateProposal: Proposed set contains invalid component token\"\n        );\n\n        // Check that the auction library is a valid priceLibrary tracked by Core\n        require(\n            coreInstance.validPriceLibraries(_auctionLibrary),\n            \"ProposeLibrary.validateProposal: Invalid or disabled PriceLibrary address\"\n        );\n\n        // Check that auctionTimeToPivot is greater than or equal to 6 hours\n        require(\n            _auctionPriceParameters.auctionTimeToPivot >= factoryInstance.minimumTimeToPivot(),\n            \"ProposeLibrary.validateProposal: Time to pivot must be greater than minimum\"\n        );\n\n        // Check that auctionTimeToPivot is less than or equal to 3 days\n        require(\n            _auctionPriceParameters.auctionTimeToPivot <= factoryInstance.maximumTimeToPivot(),\n            \"ProposeLibrary.validateProposal: Time to pivot must be greater than maximum\"\n        );\n\n        // Check that the proposed set natural unit is a multiple of current set natural unit, or vice versa.\n        // Done to make sure that when calculating token units there will are no rounding errors.\n        uint256 currentNaturalUnit = ISetToken(_proposalContext.currentSet).naturalUnit();\n        uint256 nextSetNaturalUnit = ISetToken(_nextSet).naturalUnit();\n        require(\n            Math.max(currentNaturalUnit, nextSetNaturalUnit).mod(\n                Math.min(currentNaturalUnit, nextSetNaturalUnit)\n            ) == 0,\n            \"ProposeLibrary.validateProposal: Invalid proposed Set natural unit\"\n        );\n\n        // Check that pivot price is compliant with library restrictions\n        IAuctionPriceCurve(_auctionLibrary).validateAuctionPriceParameters(\n            _auctionPriceParameters\n        );\n    }","after":"function validateProposal(\n        address _nextSet,\n        address _auctionLibrary,\n        ProposalContext calldata _proposalContext,\n        RebalancingLibrary.AuctionPriceParameters calldata _auctionPriceParameters\n    )\n        public\n    {\n        ICore coreInstance = ICore(_proposalContext.coreAddress);\n        IRebalancingSetFactory factoryInstance = IRebalancingSetFactory(_proposalContext.factoryAddress);\n\n        // Make sure it is manager that is proposing the rebalance\n        require(\n            msg.sender == _proposalContext.manager,\n            \"ProposeLibrary.validateProposal: Sender must be manager\"\n        );\n\n        // New Proposal can only be made in Default and Proposal state\n        require(\n            _proposalContext.rebalanceState == uint8(RebalancingLibrary.State.Default) ||\n            _proposalContext.rebalanceState == uint8(RebalancingLibrary.State.Proposal),\n            \"ProposeLibrary.validateProposal: State must be in Propose or Default\"\n        );\n\n        // Make sure enough time has passed from last rebalance to start a new proposal\n        require(\n            block.timestamp >= _proposalContext.lastRebalanceTimestamp.add(\n                _proposalContext.rebalanceInterval\n            ),\n            \"ProposeLibrary.validateProposal: Rebalance interval not elapsed\"\n        );\n\n        // Check that new proposed Set is valid Set created by Core\n        require(\n            coreInstance.validSets(_nextSet),\n            \"ProposeLibrary.validateProposal: Invalid or disabled proposed SetToken address\"\n        );\n\n        // Check proposed components on whitelist. This is to ensure managers are unable to add contract addresses\n        // to a propose that prohibit the set from carrying out an auction i.e. a token that only the manager possesses\n        require(\n            IWhiteList(\n                _proposalContext.componentWhitelist\n            ).areValidAddresses(ISetToken(_nextSet).getComponents()),\n            \"ProposeLibrary.validateProposal: Proposed set contains invalid component token\"\n        );\n\n        // Check that the auction library is a valid priceLibrary tracked by Core\n        require(\n            coreInstance.validPriceLibraries(_auctionLibrary),\n            \"ProposeLibrary.validateProposal: Invalid or disabled PriceLibrary address\"\n        );\n\n        // Check that auctionTimeToPivot is greater than or equal to 6 hours\n        require(\n            _auctionPriceParameters.auctionTimeToPivot >= factoryInstance.minimumTimeToPivot(),\n            \"ProposeLibrary.validateProposal: Time to pivot must be greater than minimum\"\n        );\n\n        // Check that auctionTimeToPivot is less than or equal to 3 days\n        require(\n            _auctionPriceParameters.auctionTimeToPivot <= factoryInstance.maximumTimeToPivot(),\n            \"ProposeLibrary.validateProposal: Time to pivot must be greater than maximum\"\n        );\n\n        // Check that the proposed set natural unit is a multiple of current set natural unit, or vice versa.\n        // Done to make sure that when calculating token units there will are no rounding errors.\n        uint256 currentNaturalUnit = ISetToken(_proposalContext.currentSet).naturalUnit();\n        uint256 nextSetNaturalUnit = ISetToken(_nextSet).naturalUnit();\n        require(\n            Math.max(currentNaturalUnit, nextSetNaturalUnit).mod(\n                Math.min(currentNaturalUnit, nextSetNaturalUnit)\n            ) == 0,\n            \"ProposeLibrary.validateProposal: Invalid proposed Set natural unit\"\n        );\n\n        // Check that pivot price is compliant with library restrictions\n        IAuctionPriceCurve(_auctionLibrary).validateAuctionPriceParameters(\n            _auctionPriceParameters\n        );\n    }","contract":"ProposeLibrary","time":0}]}