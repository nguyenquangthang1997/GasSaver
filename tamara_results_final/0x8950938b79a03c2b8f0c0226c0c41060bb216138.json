{"time":249,"results":[{"type":"external-function ","before":" function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes memory _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status);\n  ","after":" function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes calldata _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status);\n  ","contract":"CertiDApp","time":0},{"type":"external-function ","before":" function registerCertificate(\n    bytes memory _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash;\n  ","after":" function registerCertificate(\n    bytes calldata _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash;\n  ","contract":"CertiDApp","time":0},{"type":"external-function ","before":"\n  function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes memory _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status);\n","after":"\n  function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes calldata _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status);\n","contract":"CertiDApp","time":0},{"type":"external-function ","before":"\n  function registerCertificate(\n    bytes memory _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash;\n","after":"\n  function registerCertificate(\n    bytes calldata _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash;\n","contract":"CertiDApp","time":0},{"type":"external-function ","before":"ty\n  function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes memory _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status)","after":"ty\n  function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes calldata _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status)","contract":"CertiDApp","time":0},{"type":"external-function ","before":"d.\n  function registerCertificate(\n    bytes memory _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash","after":"d.\n  function registerCertificate(\n    bytes calldata _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash","contract":"CertiDApp","time":0},{"type":"external-function ","before":" function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes memory _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status);\n  ","after":" function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes calldata _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status);\n  ","contract":"CertiDApp","time":0},{"type":"external-function ","before":" function registerCertificate(\n    bytes memory _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash;\n  ","after":" function registerCertificate(\n    bytes calldata _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash;\n  ","contract":"CertiDApp","time":0},{"type":"external-function ","before":"\n  function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes memory _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status);\n","after":"\n  function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes calldata _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status);\n","contract":"CertiDApp","time":0},{"type":"external-function ","before":"\n  function registerCertificate(\n    bytes memory _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash;\n","after":"\n  function registerCertificate(\n    bytes calldata _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash;\n","contract":"CertiDApp","time":0},{"type":"external-function ","before":"ty\n  function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes memory _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status)","after":"ty\n  function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes calldata _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status)","contract":"CertiDApp","time":0},{"type":"external-function ","before":"d.\n  function registerCertificate(\n    bytes memory _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash","after":"d.\n  function registerCertificate(\n    bytes calldata _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash","contract":"CertiDApp","time":0},{"type":"external-function ","before":" function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes memory _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status);\n  ","after":" function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes calldata _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status);\n  ","contract":"CertiDApp","time":0},{"type":"external-function ","before":" function registerCertificate(\n    bytes memory _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash;\n  ","after":" function registerCertificate(\n    bytes calldata _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash;\n  ","contract":"CertiDApp","time":0},{"type":"external-function ","before":"\n  function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes memory _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status);\n","after":"\n  function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes calldata _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status);\n","contract":"CertiDApp","time":0},{"type":"external-function ","before":"\n  function registerCertificate(\n    bytes memory _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash;\n","after":"\n  function registerCertificate(\n    bytes calldata _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash;\n","contract":"CertiDApp","time":0},{"type":"external-function ","before":"ty\n  function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes memory _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status)","after":"ty\n  function updateCertifyingAuthority(\n    address _authorityAddress,\n    bytes calldata _data,\n    AuthorityStatus _status\n  ) public onlyManager {\n    if(_data.length > 0) {\n      certifyingAuthorities[_authorityAddress].data = _data;\n    }\n\n    certifyingAuthorities[_authorityAddress].status = _status;\n\n    emit AuthorityStatusUpdated(_authorityAddress, _status)","contract":"CertiDApp","time":0},{"type":"external-function ","before":"d.\n  function registerCertificate(\n    bytes memory _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash","after":"d.\n  function registerCertificate(\n    bytes calldata _signedCertificate\n  ) public returns (\n    bytes32\n  ) {\n    (Certificate memory _certificateObj, bytes32 _certificateHash) = parseSignedCertificate(_signedCertificate, true);\n\n    /// @notice Signers in this transaction\n    bytes memory _newSigners = _certificateObj.signers;\n\n    /// @notice If certificate already registered then signers can be updated.\n    ///   Initializing _updatedSigners with existing signers on blockchain if any.\n    ///   More signers would be appended to this in next 'for' loop.\n    bytes memory _updatedSigners = certificates[_certificateHash].signers;\n\n    /// @notice Check with every the new signer if it is not already included in storage.\n    ///   This is helpful when a same certificate is submitted again with more signatures,\n    ///   the contract will consider only new signers in that case.\n    for(uint256 i = 0; i < _newSigners.length; i += 20) {\n      address _signer;\n      assembly {\n        _signer := mload(add(_newSigners, add(0x14, i)))\n      }\n      if(_checkUniqueSigner(_signer, certificates[_certificateHash].signers)) {\n        _updatedSigners = abi.encodePacked(_updatedSigners, _signer);\n        emit Certified(\n          _certificateHash,\n          _signer\n        );\n      }\n    }\n\n    /// @notice check whether the certificate is freshly being registered.\n    ///   For new certificates, directly proceed with adding it.\n    ///   For existing certificates only update the signers if there are any new.\n    if(certificates[_certificateHash].signers.length > 0) {\n      require(_updatedSigners.length > certificates[_certificateHash].signers.length, 'need new signers');\n      certificates[_certificateHash].signers = _updatedSigners;\n    } else {\n      certificates[_certificateHash] = _certificateObj;\n    }\n\n    return _certificateHash","contract":"CertiDApp","time":0}]}