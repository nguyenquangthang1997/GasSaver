{"time":145,"results":[{"type":"struct-data-arrangement ","before":"\n address signator\n string templateTerm\n string signatureDetail\n uint256 lexI\n uint256 dcNumbe\n uint256 timeStam\n bool revoke","after":" string templateTerm\n string signatureDetail\n uint256 lexI\n uint256 dcNumbe\n uint256 timeStam\n address signator\n bool revoke\n","contract":"TLDR","time":0},{"type":"struct-data-arrangement ","before":"\n address clien\n address provide\n address drToke\n string deliverabl\n uint256 lexI\n uint256 drNumbe\n uint256 timeStam\n uint256 retainerTerminatio\n uint256 deliverableRat\n uint256 pai\n uint256 payCa\n bool confirme\n bool dispute","after":" string deliverabl\n uint256 lexI\n uint256 drNumbe\n uint256 timeStam\n uint256 retainerTerminatio\n uint256 deliverableRat\n uint256 pai\n uint256 payCa\n address clien\n address provide\n address drToke\n bool confirme\n bool dispute\n","contract":"TLDR","time":0},{"type":"external-function ","before":"\n    function writeLexScript(string memory templateTerms, uint256 lexRate, address lexAddress) public {\n        require(isReputable(msg.sender)); // program governance check / lexScribe must be reputable \n\t\n\t    uint256 lexID = LSW.add(1); // reflects new lexScript value for tracking lexScript wrappers\n\t    LSW = LSW.add(1); // counts new entry to LSW \n\t    \n\t    lexScript[lexID] = lexScriptWrapper( // populate lexScript data for rdr / rdc usage\n                msg.sender,\n                lexAddress,\n                templateTerms,\n                lexID,\n                0,\n                lexRate);\n                \n        _mint(msg.sender, 1000000000000000000); // mints lexScribe \"1\" LEX for contribution to TLDR\n\t\n        emit Enscribed(lexID, 0, msg.sender); \n","after":"\n    function writeLexScript(string calldata templateTerms, uint256 lexRate, address lexAddress) public {\n        require(isReputable(msg.sender)); // program governance check / lexScribe must be reputable \n\t\n\t    uint256 lexID = LSW.add(1); // reflects new lexScript value for tracking lexScript wrappers\n\t    LSW = LSW.add(1); // counts new entry to LSW \n\t    \n\t    lexScript[lexID] = lexScriptWrapper( // populate lexScript data for rdr / rdc usage\n                msg.sender,\n                lexAddress,\n                templateTerms,\n                lexID,\n                0,\n                lexRate);\n                \n        _mint(msg.sender, 1000000000000000000); // mints lexScribe \"1\" LEX for contribution to TLDR\n\t\n        emit Enscribed(lexID, 0, msg.sender); \n","contract":"TLDR","time":0},{"type":"external-function ","before":"\n    function editLexScript(uint256 lexID, string memory templateTerms, address lexAddress) public {\n\t    lexScriptWrapper storage lS = lexScript[lexID]; // retrieve LSW data\n\t\n\t    require(msg.sender == lS.lexScribe); // program safety check / authorization \n\t\n\t    uint256 lexVersion = lS.lexVersion.add(1); // updates lexVersion \n\t    \n\t    lexScript[lexID] = lexScriptWrapper( // populates updated lexScript data for rdr / rdc usage\n                msg.sender,\n                lexAddress,\n                templateTerms,\n                lexID,\n                lexVersion,\n                lS.lexRate);\n                \t\n        emit Enscribed(lexID, lexVersion, msg.sender);\n","after":"\n    function editLexScript(uint256 lexID, string calldata templateTerms, address lexAddress) public {\n\t    lexScriptWrapper storage lS = lexScript[lexID]; // retrieve LSW data\n\t\n\t    require(msg.sender == lS.lexScribe); // program safety check / authorization \n\t\n\t    uint256 lexVersion = lS.lexVersion.add(1); // updates lexVersion \n\t    \n\t    lexScript[lexID] = lexScriptWrapper( // populates updated lexScript data for rdr / rdc usage\n                msg.sender,\n                lexAddress,\n                templateTerms,\n                lexID,\n                lexVersion,\n                lS.lexRate);\n                \t\n        emit Enscribed(lexID, lexVersion, msg.sender);\n","contract":"TLDR","time":0},{"type":"external-function ","before":"\n    function signDC(uint256 lexID, string memory signatureDetails) public { // sign Digital Covenant with (0x) address\n\t    require(lexID > (0)); // program safety check\n\t    require(lexID <= LSW); // program safety check\n\t    lexScriptWrapper storage lS = lexScript[lexID]; // retrieve LSW data\n\t\n\t    uint256 dcNumber = RDC.add(1); // reflects new rdc value for public inspection and signature revocation\n\t    RDC = RDC.add(1); // counts new entry to RDC\n\t        \n\t    rdc[dcNumber] = DC( // populates rdc data\n                msg.sender,\n                lS.templateTerms,\n                signatureDetails,\n                lexID,\n                dcNumber,\n                now, \n                false);\n                \t\n        emit Signed(lexID, dcNumber, msg.sender);\n","after":"\n    function signDC(uint256 lexID, string calldata signatureDetails) public { // sign Digital Covenant with (0x) address\n\t    require(lexID > (0)); // program safety check\n\t    require(lexID <= LSW); // program safety check\n\t    lexScriptWrapper storage lS = lexScript[lexID]; // retrieve LSW data\n\t\n\t    uint256 dcNumber = RDC.add(1); // reflects new rdc value for public inspection and signature revocation\n\t    RDC = RDC.add(1); // counts new entry to RDC\n\t        \n\t    rdc[dcNumber] = DC( // populates rdc data\n                msg.sender,\n                lS.templateTerms,\n                signatureDetails,\n                lexID,\n                dcNumber,\n                now, \n                false);\n                \t\n        emit Signed(lexID, dcNumber, msg.sender);\n","contract":"TLDR","time":0},{"type":"external-function ","before":"\n    function registerDR( // rdr \n    \taddress client,\n    \taddress drToken,\n    \tstring memory deliverable,\n        uint256 retainerDuration,\n    \tuint256 deliverableRate,\n    \tuint256 payCap,\n    \tuint256 lexID) public {\n    \trequire(lexID > (0)); // program safety check \n    \trequire(lexID <= LSW); // program safety check \n        require(deliverableRate <= payCap); // program safety check / economics\n        \n\t    uint256 drNumber = RDR.add(1); // reflects new rdr value for inspection and escrow management\n        uint256 retainerTermination = now.add(retainerDuration); // rdr termination date in UnixTime, \"now\" block.timestamp + retainerDuration\n\n\t    RDR = RDR.add(1); // counts new entry to RDR\n                \n            rdr[drNumber] = DR( // populate rdr data \n                client,\n                msg.sender,\n                drToken,\n                deliverable,\n                lexID,\n                drNumber,\n                now, // block.timestamp, \"now\"\n                retainerTermination,\n                deliverableRate,\n                0,\n                payCap,\n                false,\n                false);\n        \t \n        emit Registered(drNumber, lexID, msg.sender); \n","after":"\n    function registerDR( // rdr \n    \taddress client,\n    \taddress drToken,\n    \tstring calldata deliverable,\n        uint256 retainerDuration,\n    \tuint256 deliverableRate,\n    \tuint256 payCap,\n    \tuint256 lexID) public {\n    \trequire(lexID > (0)); // program safety check \n    \trequire(lexID <= LSW); // program safety check \n        require(deliverableRate <= payCap); // program safety check / economics\n        \n\t    uint256 drNumber = RDR.add(1); // reflects new rdr value for inspection and escrow management\n        uint256 retainerTermination = now.add(retainerDuration); // rdr termination date in UnixTime, \"now\" block.timestamp + retainerDuration\n\n\t    RDR = RDR.add(1); // counts new entry to RDR\n                \n            rdr[drNumber] = DR( // populate rdr data \n                client,\n                msg.sender,\n                drToken,\n                deliverable,\n                lexID,\n                drNumber,\n                now, // block.timestamp, \"now\"\n                retainerTermination,\n                deliverableRate,\n                0,\n                payCap,\n                false,\n                false);\n        \t \n        emit Registered(drNumber, lexID, msg.sender); \n","contract":"TLDR","time":0},{"type":"constant-restrict-modification  ","before":" address public tldrAddress = address(this)","after":" address public constant tldrAddress = address(this)","contract":"TLDR","time":1},{"type":"constant-restrict-modification  ","before":" string public name = \"TLDR\"","after":" string public constant name = \"TLDR\"","contract":"TLDR","time":1},{"type":"constant-restrict-modification  ","before":" string public symbol = \"LEX\"","after":" string public constant symbol = \"LEX\"","contract":"TLDR","time":1},{"type":"constant-restrict-modification  ","before":" uint8 public decimals = 18","after":" uint8 public constant decimals = 18","contract":"TLDR","time":1}]}