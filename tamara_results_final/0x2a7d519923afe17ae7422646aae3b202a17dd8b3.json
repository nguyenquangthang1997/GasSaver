{"time":165,"results":[{"type":"state-data-arrangement ","before":"\nbytes32 constant private FILE = \"SignedOperationProxy\";\nbytes2 constant private EIP191_HEADER = 0x1901;\nstring constant private EIP712_DOMAIN_NAME = \"SignedOperationProxy\";\nstring constant private EIP712_DOMAIN_VERSION = \"1.1\";\nbytes constant private EIP712_DOMAIN_STRING = abi.encodePacked(\n        \"EIP712Domain(\",\n        \"string name,\",\n        \"string version,\",\n        \"uint256 chainId,\",\n        \"address verifyingContract\",\n        \")\"\n    );\nbytes constant private EIP712_OPERATION_STRING = abi.encodePacked(\n        \"Operation(\",\n        \"Action[] actions,\",\n        \"uint256 expiration,\",\n        \"uint256 salt,\",\n        \"address sender,\",\n        \"address signer\",\n        \")\"\n    );\nbytes constant private EIP712_ACTION_STRING = abi.encodePacked(\n        \"Action(\",\n        \"uint8 actionType,\",\n        \"address accountOwner,\",\n        \"uint256 accountNumber,\",\n        \"AssetAmount assetAmount,\",\n        \"uint256 primaryMarketId,\",\n        \"uint256 secondaryMarketId,\",\n        \"address otherAddress,\",\n        \"address otherAccountOwner,\",\n        \"uint256 otherAccountNumber,\",\n        \"bytes data\",\n        \")\"\n    );\nbytes constant private EIP712_ASSET_AMOUNT_STRING = abi.encodePacked(\n        \"AssetAmount(\",\n        \"bool sign,\",\n        \"uint8 denomination,\",\n        \"uint8 ref,\",\n        \"uint256 value\",\n        \")\"\n    );\nbytes32 constant private EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n        EIP712_DOMAIN_STRING\n    ));\nbytes32 constant private EIP712_OPERATION_HASH = keccak256(abi.encodePacked(\n        EIP712_OPERATION_STRING,\n        EIP712_ACTION_STRING,\n        EIP712_ASSET_AMOUNT_STRING\n    ));\nbytes32 constant private EIP712_ACTION_HASH = keccak256(abi.encodePacked(\n        EIP712_ACTION_STRING,\n        EIP712_ASSET_AMOUNT_STRING\n    ));\nbytes32 constant private EIP712_ASSET_AMOUNT_HASH = keccak256(abi.encodePacked(\n        EIP712_ASSET_AMOUNT_STRING\n    ));\nbytes32 public EIP712_DOMAIN_HASH;\nbool public g_isOperational;\nmapping (bytes32 => bool) public g_invalidated;","after":"bytes32 constant private FILE = \"SignedOperationProxy\";\nstring constant private EIP712_DOMAIN_NAME = \"SignedOperationProxy\";\nstring constant private EIP712_DOMAIN_VERSION = \"1.1\";\nbytes constant private EIP712_DOMAIN_STRING = abi.encodePacked(\n        \"EIP712Domain(\",\n        \"string name,\",\n        \"string version,\",\n        \"uint256 chainId,\",\n        \"address verifyingContract\",\n        \")\"\n    );\nbytes constant private EIP712_OPERATION_STRING = abi.encodePacked(\n        \"Operation(\",\n        \"Action[] actions,\",\n        \"uint256 expiration,\",\n        \"uint256 salt,\",\n        \"address sender,\",\n        \"address signer\",\n        \")\"\n    );\nbytes constant private EIP712_ACTION_STRING = abi.encodePacked(\n        \"Action(\",\n        \"uint8 actionType,\",\n        \"address accountOwner,\",\n        \"uint256 accountNumber,\",\n        \"AssetAmount assetAmount,\",\n        \"uint256 primaryMarketId,\",\n        \"uint256 secondaryMarketId,\",\n        \"address otherAddress,\",\n        \"address otherAccountOwner,\",\n        \"uint256 otherAccountNumber,\",\n        \"bytes data\",\n        \")\"\n    );\nbytes constant private EIP712_ASSET_AMOUNT_STRING = abi.encodePacked(\n        \"AssetAmount(\",\n        \"bool sign,\",\n        \"uint8 denomination,\",\n        \"uint8 ref,\",\n        \"uint256 value\",\n        \")\"\n    );\nbytes32 constant private EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n        EIP712_DOMAIN_STRING\n    ));\nbytes32 constant private EIP712_OPERATION_HASH = keccak256(abi.encodePacked(\n        EIP712_OPERATION_STRING,\n        EIP712_ACTION_STRING,\n        EIP712_ASSET_AMOUNT_STRING\n    ));\nbytes32 constant private EIP712_ACTION_HASH = keccak256(abi.encodePacked(\n        EIP712_ACTION_STRING,\n        EIP712_ASSET_AMOUNT_STRING\n    ));\nbytes32 constant private EIP712_ASSET_AMOUNT_HASH = keccak256(abi.encodePacked(\n        EIP712_ASSET_AMOUNT_STRING\n    ));\nbytes32 public EIP712_DOMAIN_HASH;\nmapping (bytes32 => bool) public g_invalidated;\nbytes2 constant private EIP191_HEADER = 0x1901;\nbool public g_isOperational;\n","contract":"SignedOperationProxy","time":0},{"type":"external-function ","before":"function cancel(\n        Account.Info[] memory accounts,\n        Actions.ActionArgs[] memory actions,\n        Authorization memory auth\n    )\n        public\n    {\n        bytes32 operationHash = getOperationHash(\n            accounts,\n            actions,\n            auth,\n            0\n        );\n        Require.that(\n            auth.header.signer == msg.sender,\n            FILE,\n            \"Canceler must be signer\"\n        );\n        g_invalidated[operationHash] = true;\n        emit LogOperationCanceled(operationHash, msg.sender);\n    }","after":"function cancel(\n        Account.Info[] calldata accounts,\n        Actions.ActionArgs[] calldata actions,\n        Authorization calldata auth\n    )\n        public\n    {\n        bytes32 operationHash = getOperationHash(\n            accounts,\n            actions,\n            auth,\n            0\n        );\n        Require.that(\n            auth.header.signer == msg.sender,\n            FILE,\n            \"Canceler must be signer\"\n        );\n        g_invalidated[operationHash] = true;\n        emit LogOperationCanceled(operationHash, msg.sender);\n    }","contract":"SignedOperationProxy","time":0},{"type":"external-function ","before":"function operate(\n        Account.Info[] memory accounts,\n        Actions.ActionArgs[] memory actions,\n        Authorization[] memory auths\n    )\n        public\n    {\n        Require.that(\n            g_isOperational,\n            FILE,\n            \"Contract is not operational\"\n        );\n\n        // cache the index of the first action for this auth\n        uint256 actionStartIdx = 0;\n\n        // loop over all auths\n        for (uint256 authIdx = 0; authIdx < auths.length; authIdx++) {\n            Authorization memory auth = auths[authIdx];\n\n            // require that the message is not expired\n            Require.that(\n                auth.header.expiration == 0 || auth.header.expiration >= block.timestamp,\n                FILE,\n                \"Signed operation is expired\",\n                authIdx\n            );\n\n            // require that the sender matches the authorization\n            Require.that(\n                auth.header.sender == address(0) || auth.header.sender == msg.sender,\n                FILE,\n                \"Operation sender mismatch\",\n                authIdx\n            );\n\n            // consider the signer to be null unless there is a signature\n            address signer = address(0);\n\n            // if there is a signature, then validate it\n            if (auth.signature.length != 0) {\n                // get the hash of the operation\n                bytes32 operationHash = getOperationHash(\n                    accounts,\n                    actions,\n                    auth,\n                    actionStartIdx\n                );\n\n                // require that this message is still valid\n                Require.that(\n                    !g_invalidated[operationHash],\n                    FILE,\n                    \"Hash already used or canceled\",\n                    operationHash\n                );\n\n                // get the signer\n                signer = TypedSignature.recover(operationHash, auth.signature);\n\n                // require that this signer matches the authorization\n                Require.that(\n                    auth.header.signer == signer,\n                    FILE,\n                    \"Invalid signature\"\n                );\n\n                // consider this operationHash to be used (and therefore no longer valid)\n                g_invalidated[operationHash] = true;\n                emit LogOperationExecuted(operationHash, signer, msg.sender);\n            }\n\n            // cache the index of the first action after this auth\n            uint256 actionEndIdx = actionStartIdx.add(auth.numActions);\n\n            // loop over all actions for which this auth applies\n            for (uint256 actionIdx = actionStartIdx; actionIdx < actionEndIdx; actionIdx++) {\n                // validate primary account\n                Actions.ActionArgs memory action = actions[actionIdx];\n                validateAccountOwner(accounts[action.accountId].owner, signer);\n\n                // validate second account in the case of a transfer\n                if (action.actionType == Actions.ActionType.Transfer) {\n                    validateAccountOwner(accounts[action.otherAccountId].owner, signer);\n                }\n            }\n\n            // update actionStartIdx\n            actionStartIdx = actionEndIdx;\n        }\n\n        // require that all actions are signed or from msg.sender\n        Require.that(\n            actionStartIdx == actions.length,\n            FILE,\n            \"Not all actions are signed\"\n        );\n\n        // send the operation\n        SOLO_MARGIN.operate(accounts, actions);\n    }","after":"function operate(\n        Account.Info[] calldata accounts,\n        Actions.ActionArgs[] calldata actions,\n        Authorization[] calldata auths\n    )\n        public\n    {\n        Require.that(\n            g_isOperational,\n            FILE,\n            \"Contract is not operational\"\n        );\n\n        // cache the index of the first action for this auth\n        uint256 actionStartIdx = 0;\n\n        // loop over all auths\n        for (uint256 authIdx = 0; authIdx < auths.length; authIdx++) {\n            Authorization memory auth = auths[authIdx];\n\n            // require that the message is not expired\n            Require.that(\n                auth.header.expiration == 0 || auth.header.expiration >= block.timestamp,\n                FILE,\n                \"Signed operation is expired\",\n                authIdx\n            );\n\n            // require that the sender matches the authorization\n            Require.that(\n                auth.header.sender == address(0) || auth.header.sender == msg.sender,\n                FILE,\n                \"Operation sender mismatch\",\n                authIdx\n            );\n\n            // consider the signer to be null unless there is a signature\n            address signer = address(0);\n\n            // if there is a signature, then validate it\n            if (auth.signature.length != 0) {\n                // get the hash of the operation\n                bytes32 operationHash = getOperationHash(\n                    accounts,\n                    actions,\n                    auth,\n                    actionStartIdx\n                );\n\n                // require that this message is still valid\n                Require.that(\n                    !g_invalidated[operationHash],\n                    FILE,\n                    \"Hash already used or canceled\",\n                    operationHash\n                );\n\n                // get the signer\n                signer = TypedSignature.recover(operationHash, auth.signature);\n\n                // require that this signer matches the authorization\n                Require.that(\n                    auth.header.signer == signer,\n                    FILE,\n                    \"Invalid signature\"\n                );\n\n                // consider this operationHash to be used (and therefore no longer valid)\n                g_invalidated[operationHash] = true;\n                emit LogOperationExecuted(operationHash, signer, msg.sender);\n            }\n\n            // cache the index of the first action after this auth\n            uint256 actionEndIdx = actionStartIdx.add(auth.numActions);\n\n            // loop over all actions for which this auth applies\n            for (uint256 actionIdx = actionStartIdx; actionIdx < actionEndIdx; actionIdx++) {\n                // validate primary account\n                Actions.ActionArgs memory action = actions[actionIdx];\n                validateAccountOwner(accounts[action.accountId].owner, signer);\n\n                // validate second account in the case of a transfer\n                if (action.actionType == Actions.ActionType.Transfer) {\n                    validateAccountOwner(accounts[action.otherAccountId].owner, signer);\n                }\n            }\n\n            // update actionStartIdx\n            actionStartIdx = actionEndIdx;\n        }\n\n        // require that all actions are signed or from msg.sender\n        Require.that(\n            actionStartIdx == actions.length,\n            FILE,\n            \"Not all actions are signed\"\n        );\n\n        // send the operation\n        SOLO_MARGIN.operate(accounts, actions);\n    }","contract":"SignedOperationProxy","time":0}]}