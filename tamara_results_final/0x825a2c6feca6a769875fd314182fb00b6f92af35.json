{"time":163,"results":[{"type":"external-function ","before":"function executeReward(string memory identifier) public onlyWhitelistAdmin {\n        require(paused(), \"require paused when rewarding\");\n        super.executeReward(identifier);\n    }","after":"function executeReward(string calldata identifier) public onlyWhitelistAdmin {\n        require(paused(), \"require paused when rewarding\");\n        super.executeReward(identifier);\n    }","contract":"JZTCToken","time":0},{"type":"external-function ","before":"function executeRewardBatch(string memory identifier, uint256 batchOffset) public onlyWhitelistAdmin {\n        require(paused(), \"require paused when rewarding\");\n        super.executeRewardBatch(identifier, batchOffset);\n    }","after":"function executeRewardBatch(string calldata identifier, uint256 batchOffset) public onlyWhitelistAdmin {\n        require(paused(), \"require paused when rewarding\");\n        super.executeRewardBatch(identifier, batchOffset);\n    }","contract":"JZTCToken","time":0},{"type":"external-function ","before":"function initialize(string memory name, string memory symbol, uint8 decimals) public initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }","after":"function initialize(string calldata name, string calldata symbol, uint8 decimals) public initializer {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }","contract":"JZTCToken","time":0},{"type":"external-function ","before":"function executeReward(string memory identifier) public onlyWhitelistAdmin {\n        Reward storage reward = identifierRewardMap[identifier];\n        require(reward.status == RewardStatus.Created);\n\n        address[] memory holders = getHolders();\n        for (uint index = 0; index < holders.length; index++) {\n            require(reward.grantedMap[holders[index]] == false);\n            uint256 amount = reward.amount.mul(balanceOf(holders[index])).div(totalSupply());\n            reward.token.safeTransfer(holders[index], amount);\n            reward.grantedMap[holders[index]] = true;\n        }\n\n        _tokenRewardBalance[address(reward.token)] = _tokenRewardBalance[address(reward.token)].sub(reward.amount);\n        reward.status = RewardStatus.Executed;\n    }","after":"function executeReward(string calldata identifier) public onlyWhitelistAdmin {\n        Reward storage reward = identifierRewardMap[identifier];\n        require(reward.status == RewardStatus.Created);\n\n        address[] memory holders = getHolders();\n        for (uint index = 0; index < holders.length; index++) {\n            require(reward.grantedMap[holders[index]] == false);\n            uint256 amount = reward.amount.mul(balanceOf(holders[index])).div(totalSupply());\n            reward.token.safeTransfer(holders[index], amount);\n            reward.grantedMap[holders[index]] = true;\n        }\n\n        _tokenRewardBalance[address(reward.token)] = _tokenRewardBalance[address(reward.token)].sub(reward.amount);\n        reward.status = RewardStatus.Executed;\n    }","contract":"JZTCToken","time":0},{"type":"external-function ","before":"function executeRewardBatch(string memory identifier, uint256 batchOffset) public onlyWhitelistAdmin {\n        Reward storage reward = identifierRewardMap[identifier];\n        require(reward.status == RewardStatus.Created || reward.status == RewardStatus.Executed);\n\n        uint256 tokenBatchCount = _tokenBatchCount[address(reward.token)];\n        require(tokenBatchCount != 0);\n        uint256 offset = batchOffset * _tokenBatchCount[address(reward.token)];\n        address[] memory holders = getHolders();\n        uint256 maxIndex = Math.min(offset + tokenBatchCount, holders.length);\n\n        for (uint256 index = offset; index < maxIndex; index++) {\n            require(reward.grantedMap[holders[index]] == false);\n            uint256 amount = reward.amount.mul(balanceOf(holders[index])).div(totalSupply());\n            reward.token.safeTransfer(holders[index], amount);\n            reward.grantedMap[holders[index]] = true;\n            _tokenRewardBalance[address(reward.token)] = _tokenRewardBalance[address(reward.token)].sub(amount);\n        }\n        reward.status = RewardStatus.Executed;\n    }","after":"function executeRewardBatch(string calldata identifier, uint256 batchOffset) public onlyWhitelistAdmin {\n        Reward storage reward = identifierRewardMap[identifier];\n        require(reward.status == RewardStatus.Created || reward.status == RewardStatus.Executed);\n\n        uint256 tokenBatchCount = _tokenBatchCount[address(reward.token)];\n        require(tokenBatchCount != 0);\n        uint256 offset = batchOffset * _tokenBatchCount[address(reward.token)];\n        address[] memory holders = getHolders();\n        uint256 maxIndex = Math.min(offset + tokenBatchCount, holders.length);\n\n        for (uint256 index = offset; index < maxIndex; index++) {\n            require(reward.grantedMap[holders[index]] == false);\n            uint256 amount = reward.amount.mul(balanceOf(holders[index])).div(totalSupply());\n            reward.token.safeTransfer(holders[index], amount);\n            reward.grantedMap[holders[index]] = true;\n            _tokenRewardBalance[address(reward.token)] = _tokenRewardBalance[address(reward.token)].sub(amount);\n        }\n        reward.status = RewardStatus.Executed;\n    }","contract":"JZTCToken","time":0}]}