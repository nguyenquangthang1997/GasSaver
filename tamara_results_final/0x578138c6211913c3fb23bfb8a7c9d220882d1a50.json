{"time":431,"results":[{"type":"external-function ","before":"sent or received.\n    function trade(int[] memory outcomeTokenAmounts, int collateralLimit)\n        public\n        atStage(Stage.Running)\n        onlyWhitelisted\n        returns (int netCost)\n    {\n        require(outcomeTokenAmounts.length == atomicOutcomeSlotCount);\n\n        // Calculate net cost for executing trade\n        int outcomeTokenNetCost = calcNetCost(outcomeTokenAmounts);\n        int fees;\n        if(outcomeTokenNetCost < 0)\n            fees = int(calcMarketFee(uint(-outcomeTokenNetCost)));\n        else\n            fees = int(calcMarketFee(uint(outcomeTokenNetCost)));\n\n        require(fees >= 0);\n        netCost = outcomeTokenNetCost.add(fees);\n\n        require(\n            (collateralLimit != 0 && netCost <= collateralLimit) ||\n            collateralLimit == 0\n        );\n\n        if(outcomeTokenNetCost > 0) {\n            require(\n                collateralToken.transferFrom(msg.sender, address(this), uint(netCost)) &&\n                collateralToken.approve(address(pmSystem), uint(outcomeTokenNetCost))\n            );\n\n            splitPositionThroughAllConditions(uint(outcomeTokenNetCost));\n        }\n\n        bool touched = false;\n        uint[] memory transferAmounts = new uint[](atomicOutcomeSlotCount);\n        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {\n            if(outcomeTokenAmounts[i] < 0) {\n                touched = true;\n                // This is safe since\n                // 0x8000000000000000000000000000000000000000000000000000000000000000 ==\n                // uint(-int(-0x8000000000000000000000000000000000000000000000000000000000000000))\n                transferAmounts[i] = uint(-outcomeTokenAmounts[i]);\n            }\n        }\n        if(touched) pmSystem.safeBatchTransferFrom(msg.sender, address(this), positionIds, transferAmounts, \"\");\n\n        if(outcomeTokenNetCost < 0) {\n            mergePositionsThroughAllConditions(uint(-outcomeTokenNetCost));\n        }\n\n        emit AMMOutcomeTokenTrade(msg.sender, outcomeTokenAmounts, outcomeTokenNetCost, uint(fees));\n\n        touched = false;\n        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {\n            if(outcomeTokenAmounts[i] > 0) {\n                touched = true;\n                transferAmounts[i] = uint(outcomeTokenAmounts[i]);\n            } else {\n                transferAmounts[i] = 0;\n            }\n        }\n        if(touched) pmSystem.safeBatchTransferFrom(address(this), msg.sender, positionIds, transferAmounts, \"\");\n\n        if(netCost < 0) {\n            require(collateralToken.transfer(msg.sender, uint(-netCo","after":"sent or received.\n    function trade(int[] calldata outcomeTokenAmounts, int collateralLimit)\n        public\n        atStage(Stage.Running)\n        onlyWhitelisted\n        returns (int netCost)\n    {\n        require(outcomeTokenAmounts.length == atomicOutcomeSlotCount);\n\n        // Calculate net cost for executing trade\n        int outcomeTokenNetCost = calcNetCost(outcomeTokenAmounts);\n        int fees;\n        if(outcomeTokenNetCost < 0)\n            fees = int(calcMarketFee(uint(-outcomeTokenNetCost)));\n        else\n            fees = int(calcMarketFee(uint(outcomeTokenNetCost)));\n\n        require(fees >= 0);\n        netCost = outcomeTokenNetCost.add(fees);\n\n        require(\n            (collateralLimit != 0 && netCost <= collateralLimit) ||\n            collateralLimit == 0\n        );\n\n        if(outcomeTokenNetCost > 0) {\n            require(\n                collateralToken.transferFrom(msg.sender, address(this), uint(netCost)) &&\n                collateralToken.approve(address(pmSystem), uint(outcomeTokenNetCost))\n            );\n\n            splitPositionThroughAllConditions(uint(outcomeTokenNetCost));\n        }\n\n        bool touched = false;\n        uint[] memory transferAmounts = new uint[](atomicOutcomeSlotCount);\n        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {\n            if(outcomeTokenAmounts[i] < 0) {\n                touched = true;\n                // This is safe since\n                // 0x8000000000000000000000000000000000000000000000000000000000000000 ==\n                // uint(-int(-0x8000000000000000000000000000000000000000000000000000000000000000))\n                transferAmounts[i] = uint(-outcomeTokenAmounts[i]);\n            }\n        }\n        if(touched) pmSystem.safeBatchTransferFrom(msg.sender, address(this), positionIds, transferAmounts, \"\");\n\n        if(outcomeTokenNetCost < 0) {\n            mergePositionsThroughAllConditions(uint(-outcomeTokenNetCost));\n        }\n\n        emit AMMOutcomeTokenTrade(msg.sender, outcomeTokenAmounts, outcomeTokenNetCost, uint(fees));\n\n        touched = false;\n        for (uint i = 0; i < atomicOutcomeSlotCount; i++) {\n            if(outcomeTokenAmounts[i] > 0) {\n                touched = true;\n                transferAmounts[i] = uint(outcomeTokenAmounts[i]);\n            } else {\n                transferAmounts[i] = 0;\n            }\n        }\n        if(touched) pmSystem.safeBatchTransferFrom(address(this), msg.sender, positionIds, transferAmounts, \"\");\n\n        if(netCost < 0) {\n            require(collateralToken.transfer(msg.sender, uint(-netCo","contract":"LMSRMarketMaker","time":0}]}