{"time":89,"results":[{"type":"external-function ","before":"function performSwap(\n        address sourceToken,\n        address destinationToken,\n        uint256 sourceAmount,\n        uint256 minDestinationAmount,\n        address[] memory callees,\n        bytes memory exchangeData,\n        uint256[] memory startIndexes,\n        uint256[] memory values,\n        uint256 mintPrice\n    )\n        public\n        payable\n        whenNotPaused\n        nonReentrant\n    {\n        //Basic sanity check\n        require(callees.length > 0, \"No callee provided!!\");\n        require(\n            callees.length + 1 == startIndexes.length,\n            \"Start indexes must be 1 greater then number of callees!!\"\n        );\n        require(sourceToken != address(0), \"Invalid source token!!\");\n        require(destinationToken != address(0), \"Inavlid destination address\");\n\n        uint initialGas = gasleft();\n\n        //If source token is not ETH than transfer required amount of tokens\n        //from sender to this contract\n        if (sourceToken != ETH_ADDRESS){\n            IERC20(sourceToken).safeTransferFrom(msg.sender, address(this), sourceAmount);\n        }\n\n        for (uint256 i = 0; i < callees.length; i++) {\n\n            require(isWhitelisted(callees[i]), \"Callee is not whitelisted!!\");\n\n            bool result = externalCall(\n                callees[i],//destination\n                values[i],//value to send\n                startIndexes[i],// start index of call data\n                startIndexes[i+1].sub(startIndexes[i]),// length of calldata\n                exchangeData// total calldata\n            );\n            require(result, \"External call failed!!\");\n        }\n        uint256 receivedAmount = tokenBalance(destinationToken, address(this));\n\n        require(\n            receivedAmount >= minDestinationAmount,\n            \"Received amount of tokens are less then expected!!\"\n        );\n\n        uint256 fee = calculateFee(\n            sourceToken,\n            receivedAmount,\n            callees.length\n        );\n\n        if (fee > 0) {\n            receivedAmount = receivedAmount.sub(fee);\n            transferTokens(destinationToken, _feeWallet, fee);\n        }\n\n        transferTokens(destinationToken, msg.sender, receivedAmount);\n\n        emit Swapped(\n            msg.sender,\n            sourceToken,\n            destinationToken,\n            sourceAmount,\n            receivedAmount\n        );\n\n        if (mintPrice > 0){\n            refundGas(initialGas, mintPrice);\n        }\n    }","after":"function performSwap(\n        address sourceToken,\n        address destinationToken,\n        uint256 sourceAmount,\n        uint256 minDestinationAmount,\n        address[] calldata callees,\n        bytes calldata exchangeData,\n        uint256[] calldata startIndexes,\n        uint256[] calldata values,\n        uint256 mintPrice\n    )\n        public\n        payable\n        whenNotPaused\n        nonReentrant\n    {\n        //Basic sanity check\n        require(callees.length > 0, \"No callee provided!!\");\n        require(\n            callees.length + 1 == startIndexes.length,\n            \"Start indexes must be 1 greater then number of callees!!\"\n        );\n        require(sourceToken != address(0), \"Invalid source token!!\");\n        require(destinationToken != address(0), \"Inavlid destination address\");\n\n        uint initialGas = gasleft();\n\n        //If source token is not ETH than transfer required amount of tokens\n        //from sender to this contract\n        if (sourceToken != ETH_ADDRESS){\n            IERC20(sourceToken).safeTransferFrom(msg.sender, address(this), sourceAmount);\n        }\n\n        for (uint256 i = 0; i < callees.length; i++) {\n\n            require(isWhitelisted(callees[i]), \"Callee is not whitelisted!!\");\n\n            bool result = externalCall(\n                callees[i],//destination\n                values[i],//value to send\n                startIndexes[i],// start index of call data\n                startIndexes[i+1].sub(startIndexes[i]),// length of calldata\n                exchangeData// total calldata\n            );\n            require(result, \"External call failed!!\");\n        }\n        uint256 receivedAmount = tokenBalance(destinationToken, address(this));\n\n        require(\n            receivedAmount >= minDestinationAmount,\n            \"Received amount of tokens are less then expected!!\"\n        );\n\n        uint256 fee = calculateFee(\n            sourceToken,\n            receivedAmount,\n            callees.length\n        );\n\n        if (fee > 0) {\n            receivedAmount = receivedAmount.sub(fee);\n            transferTokens(destinationToken, _feeWallet, fee);\n        }\n\n        transferTokens(destinationToken, msg.sender, receivedAmount);\n\n        emit Swapped(\n            msg.sender,\n            sourceToken,\n            destinationToken,\n            sourceAmount,\n            receivedAmount\n        );\n\n        if (mintPrice > 0){\n            refundGas(initialGas, mintPrice);\n        }\n    }","contract":"AugustusSwapper","time":0}]}