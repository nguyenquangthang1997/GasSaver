{"time":185,"results":[{"type":"state-data-arrangement ","before":"\naddress payable internal operator;\nuint256 constant internal MINIMUM_TIME_TO_REVEAL = 1 days;\nuint256 constant internal TIME_TO_ALLOW_REVOKE = 7 days;\nbool internal isRevokeStarted = false;\nuint256 internal revokeTime = 0;\nbool internal active = true;\nmapping (address => mapping (bytes32 => uint256)) private reveal_timestamps;","after":"uint256 constant internal MINIMUM_TIME_TO_REVEAL = 1 days;\nuint256 constant internal TIME_TO_ALLOW_REVOKE = 7 days;\nuint256 internal revokeTime = 0;\nmapping (address => mapping (bytes32 => uint256)) private reveal_timestamps;\naddress payable internal operator;\nbool internal isRevokeStarted = false;\nbool internal active = true;\n","contract":"Base","time":0},{"type":"external-function ","before":"function claimReward(\n        uint256[] memory firstInput,\n        uint256[] memory secondInput,\n        string memory solutionDescription,\n        string memory name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","after":"function claimReward(\n        uint256[] calldata firstInput,\n        uint256[] calldata secondInput,\n        string calldata solutionDescription,\n        string calldata name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","contract":"STARK_Friendly_Hash_Challenge_GMiMC_erf_S45b","time":0},{"type":"external-function ","before":"function claimReward(\n        uint256[] memory firstInput,\n        uint256[] memory secondInput,\n        string memory solutionDescription,\n        string memory name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","after":"function claimReward(\n        uint256[] calldata firstInput,\n        uint256[] calldata secondInput,\n        string calldata solutionDescription,\n        string calldata name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","contract":"STARK_Friendly_Hash_Challenge_GMiMC_erf_S45b","time":0},{"type":"external-function ","before":"function claimReward(\n        uint256[] memory firstInput,\n        uint256[] memory secondInput,\n        string memory solutionDescription,\n        string memory name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","after":"function claimReward(\n        uint256[] calldata firstInput,\n        uint256[] calldata secondInput,\n        string calldata solutionDescription,\n        string calldata name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","contract":"STARK_Friendly_Hash_Challenge_GMiMC_erf_S45b","time":0},{"type":"state-data-arrangement ","before":"\naddress payable internal operator;\nuint256 constant internal MINIMUM_TIME_TO_REVEAL = 1 days;\nuint256 constant internal TIME_TO_ALLOW_REVOKE = 7 days;\nbool internal isRevokeStarted = false;\nuint256 internal revokeTime = 0;\nbool internal active = true;\nmapping (address => mapping (bytes32 => uint256)) private reveal_timestamps;","after":"uint256 constant internal MINIMUM_TIME_TO_REVEAL = 1 days;\nuint256 constant internal TIME_TO_ALLOW_REVOKE = 7 days;\nuint256 internal revokeTime = 0;\nmapping (address => mapping (bytes32 => uint256)) private reveal_timestamps;\naddress payable internal operator;\nbool internal isRevokeStarted = false;\nbool internal active = true;\n","contract":"Base","time":1},{"type":"external-function ","before":"function claimReward(\n        uint256[] memory firstInput,\n        uint256[] memory secondInput,\n        string memory solutionDescription,\n        string memory name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","after":"function claimReward(\n        uint256[] calldata firstInput,\n        uint256[] calldata secondInput,\n        string calldata solutionDescription,\n        string calldata name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","contract":"STARK_Friendly_Hash_Challenge_GMiMC_erf_S45b","time":0},{"type":"external-function ","before":"function claimReward(\n        uint256[] memory firstInput,\n        uint256[] memory secondInput,\n        string memory solutionDescription,\n        string memory name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","after":"function claimReward(\n        uint256[] calldata firstInput,\n        uint256[] calldata secondInput,\n        string calldata solutionDescription,\n        string calldata name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","contract":"STARK_Friendly_Hash_Challenge_GMiMC_erf_S45b","time":0},{"type":"external-function ","before":"function claimReward(\n        uint256[] memory firstInput,\n        uint256[] memory secondInput,\n        string memory solutionDescription,\n        string memory name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","after":"function claimReward(\n        uint256[] calldata firstInput,\n        uint256[] calldata secondInput,\n        string calldata solutionDescription,\n        string calldata name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","contract":"STARK_Friendly_Hash_Challenge_GMiMC_erf_S45b","time":0},{"type":"state-data-arrangement ","before":"\naddress payable internal operator;\nuint256 constant internal MINIMUM_TIME_TO_REVEAL = 1 days;\nuint256 constant internal TIME_TO_ALLOW_REVOKE = 7 days;\nbool internal isRevokeStarted = false;\nuint256 internal revokeTime = 0;\nbool internal active = true;\nmapping (address => mapping (bytes32 => uint256)) private reveal_timestamps;","after":"uint256 constant internal MINIMUM_TIME_TO_REVEAL = 1 days;\nuint256 constant internal TIME_TO_ALLOW_REVOKE = 7 days;\nuint256 internal revokeTime = 0;\nmapping (address => mapping (bytes32 => uint256)) private reveal_timestamps;\naddress payable internal operator;\nbool internal isRevokeStarted = false;\nbool internal active = true;\n","contract":"Base","time":0},{"type":"external-function ","before":"function claimReward(\n        uint256[] memory firstInput,\n        uint256[] memory secondInput,\n        string memory solutionDescription,\n        string memory name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","after":"function claimReward(\n        uint256[] calldata firstInput,\n        uint256[] calldata secondInput,\n        string calldata solutionDescription,\n        string calldata name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","contract":"STARK_Friendly_Hash_Challenge_GMiMC_erf_S45b","time":0},{"type":"external-function ","before":"function claimReward(\n        uint256[] memory firstInput,\n        uint256[] memory secondInput,\n        string memory solutionDescription,\n        string memory name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","after":"function claimReward(\n        uint256[] calldata firstInput,\n        uint256[] calldata secondInput,\n        string calldata solutionDescription,\n        string calldata name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","contract":"STARK_Friendly_Hash_Challenge_GMiMC_erf_S45b","time":0},{"type":"external-function ","before":"function claimReward(\n        uint256[] memory firstInput,\n        uint256[] memory secondInput,\n        string memory solutionDescription,\n        string memory name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","after":"function claimReward(\n        uint256[] calldata firstInput,\n        uint256[] calldata secondInput,\n        string calldata solutionDescription,\n        string calldata name)\n        public\n    {\n        require(active == true, \"This challenge is no longer active. Thank you for participating.\");\n        require(firstInput.length > 0, \"First input cannot be empty.\");\n        require(secondInput.length > 0, \"Second input cannot be empty.\");\n        require(firstInput.length == secondInput.length, \"Input lengths are not equal.\");\n        uint256 inputLength = firstInput.length;\n        bool sameInput = true;\n        for (uint256 i = 0; i < inputLength; i++) {\n            if (firstInput[i] != secondInput[i]) {\n                sameInput = false;\n            }\n        }\n        require(sameInput == false, \"Inputs are equal.\");\n        bool sameHash = true;\n        uint256[] memory firstHash = applyHash(firstInput);\n        uint256[] memory secondHash = applyHash(secondInput);\n        require(firstHash.length == secondHash.length, \"Output lengths are not equal.\");\n        uint256 outputLength = firstHash.length;\n        for (uint256 i = 0; i < outputLength; i++) {\n            if (firstHash[i] != secondHash[i]) {\n                sameHash = false;\n            }\n        }\n        require(sameHash == true, \"Not a collision.\");\n        verifyTimelyRegistration(calcCommitment(firstInput, secondInput));\n\n        active = false;\n        emit LogString(solutionDescription);\n        emit LogString(name);\n        msg.sender.transfer(address(this).balance);\n    }","contract":"STARK_Friendly_Hash_Challenge_GMiMC_erf_S45b","time":0}]}