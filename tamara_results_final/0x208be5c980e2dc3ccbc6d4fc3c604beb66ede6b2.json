{"time":349,"results":[{"type":"struct-data-arrangement ","before":"\n    uint32 times\n    bytes32 tx\n    uint64 t\n    bytes32 ut","after":"    bytes32 tx\n    bytes32 ut\n    uint64 t\n    uint32 times\n","contract":"FastExitHandler","time":1},{"type":"external-function ","before":"\n\n  function startBoughtExit(\n    bytes32[] memory _youngestInputProof, bytes32[] memory _proof,\n    uint8 _outputIndex, uint8 _inputIndex, bytes32[] memory signedData\n  ) public payable {\n    require(msg.value >= exitStake, \"Not enough ether sent to pay for exit stake\");\n    Data memory data;\n\n    (,data.timestamp,,) = bridge.periods(_proof[0]);\n    require(data.timestamp > 0, \"The referenced period was not submitted to bridge\");\n\n    (, data.timestamp,,) = bridge.periods(_youngestInputProof[0]);\n    require(data.timestamp > 0, \"The referenced period was not submitted to bridge\");\n\n    // check exiting tx inclusion in the root chain block\n    bytes memory txData;\n    (data.txPos, data.txHash, txData) = TxLib.validateProof(32 * (_youngestInputProof.length + 2) + 96, _proof);\n\n    // parse exiting tx and check if it is exitable\n    TxLib.Tx memory exitingTx = TxLib.parseTx(txData);\n    TxLib.Output memory out = exitingTx.outs[_outputIndex];\n    data.utxoId = bytes32(uint256(_outputIndex) << 120 | uint120(uint256(data.txHash)));\n\n    (uint256 buyPrice, bytes32 utxoIdSigned, address signer) = unpackSignedData(signedData);\n\n    require(!isNft(out.color), \"Can not fast exit NFTs\");\n    require(out.owner == address(this), \"Funds were not sent to this contract\");\n    require(\n      ecrecover(\n        TxLib.getSigHash(txData),\n        exitingTx.ins[0].v, exitingTx.ins[0].r, exitingTx.ins[0].s\n      ) == signer,\n      \"Signer was not the previous owner of UTXO\"\n    );\n    require(\n      data.utxoId == utxoIdSigned,\n      \"The signed utxoid does not match the one in the proof\"\n    );\n\n    require(out.value > 0, \"UTXO has no value\");\n    require(exits[data.utxoId].amount == 0, \"The exit for UTXO has already been started\");\n    require(!exits[data.utxoId].finalized, \"The exit for UTXO has already been finalized\");\n    require(exitingTx.txType == TxLib.TxType.Transfer, \"Can only fast exit transfer tx\");\n\n    uint256 priority;\n    // check youngest input tx inclusion in the root chain block\n    bytes32 inputTxHash;\n    (data.txPos, inputTxHash,) = TxLib.validateProof(128, _youngestInputProof);\n    require(\n      inputTxHash == exitingTx.ins[_inputIndex].outpoint.hash,\n      \"Input from the proof is not referenced in exiting tx\"\n    );\n\n    if (isNft(out.color)) {\n      priority = (nftExitCounter << 128) | uint128(uint256(data.utxoId));\n      nftExitCounter++;\n    } else {\n      priority = getERC20ExitPriority(data.timestamp, data.utxoId, data.txPos);\n    }\n\n    tokens[out.color].addr.transferFrom(msg.sender, signer, buyPrice);\n\n    tokens[out.color].insert(priority);\n\n    exits[data.utxoId] = Exit({\n      owner: msg.sender,\n      color: out.color,\n      amount: out.value,\n      finalized: false,\n      stake: exitStake,\n      priorityTimestamp: data.timestamp,\n      tokenData: out.stateRoot\n    });\n    emit ExitStarted(\n      data.txHash,\n      _outputIndex,\n      out.color,\n      out.owner,\n      out.value\n    );","after":"\n\n  function startBoughtExit(\n    bytes32[] calldata _youngestInputProof, bytes32[] calldata _proof,\n    uint8 _outputIndex, uint8 _inputIndex, bytes32[] calldata signedData\n  ) public payable {\n    require(msg.value >= exitStake, \"Not enough ether sent to pay for exit stake\");\n    Data memory data;\n\n    (,data.timestamp,,) = bridge.periods(_proof[0]);\n    require(data.timestamp > 0, \"The referenced period was not submitted to bridge\");\n\n    (, data.timestamp,,) = bridge.periods(_youngestInputProof[0]);\n    require(data.timestamp > 0, \"The referenced period was not submitted to bridge\");\n\n    // check exiting tx inclusion in the root chain block\n    bytes memory txData;\n    (data.txPos, data.txHash, txData) = TxLib.validateProof(32 * (_youngestInputProof.length + 2) + 96, _proof);\n\n    // parse exiting tx and check if it is exitable\n    TxLib.Tx memory exitingTx = TxLib.parseTx(txData);\n    TxLib.Output memory out = exitingTx.outs[_outputIndex];\n    data.utxoId = bytes32(uint256(_outputIndex) << 120 | uint120(uint256(data.txHash)));\n\n    (uint256 buyPrice, bytes32 utxoIdSigned, address signer) = unpackSignedData(signedData);\n\n    require(!isNft(out.color), \"Can not fast exit NFTs\");\n    require(out.owner == address(this), \"Funds were not sent to this contract\");\n    require(\n      ecrecover(\n        TxLib.getSigHash(txData),\n        exitingTx.ins[0].v, exitingTx.ins[0].r, exitingTx.ins[0].s\n      ) == signer,\n      \"Signer was not the previous owner of UTXO\"\n    );\n    require(\n      data.utxoId == utxoIdSigned,\n      \"The signed utxoid does not match the one in the proof\"\n    );\n\n    require(out.value > 0, \"UTXO has no value\");\n    require(exits[data.utxoId].amount == 0, \"The exit for UTXO has already been started\");\n    require(!exits[data.utxoId].finalized, \"The exit for UTXO has already been finalized\");\n    require(exitingTx.txType == TxLib.TxType.Transfer, \"Can only fast exit transfer tx\");\n\n    uint256 priority;\n    // check youngest input tx inclusion in the root chain block\n    bytes32 inputTxHash;\n    (data.txPos, inputTxHash,) = TxLib.validateProof(128, _youngestInputProof);\n    require(\n      inputTxHash == exitingTx.ins[_inputIndex].outpoint.hash,\n      \"Input from the proof is not referenced in exiting tx\"\n    );\n\n    if (isNft(out.color)) {\n      priority = (nftExitCounter << 128) | uint128(uint256(data.utxoId));\n      nftExitCounter++;\n    } else {\n      priority = getERC20ExitPriority(data.timestamp, data.utxoId, data.txPos);\n    }\n\n    tokens[out.color].addr.transferFrom(msg.sender, signer, buyPrice);\n\n    tokens[out.color].insert(priority);\n\n    exits[data.utxoId] = Exit({\n      owner: msg.sender,\n      color: out.color,\n      amount: out.value,\n      finalized: false,\n      stake: exitStake,\n      priorityTimestamp: data.timestamp,\n      tokenData: out.stateRoot\n    });\n    emit ExitStarted(\n      data.txHash,\n      _outputIndex,\n      out.color,\n      out.owner,\n      out.value\n    );","contract":"FastExitHandler","time":0},{"type":"external-function ","before":"\n\n  function startExit(\n    bytes32[] memory _youngestInputProof, bytes32[] memory _proof,\n    uint8 _outputIndex, uint8 _inputIndex\n  ) public payable {\n    require(msg.value >= exitStake, \"Not enough ether sent to pay for exit stake\");\n    uint32 timestamp;\n    (, timestamp,,) = bridge.periods(_proof[0]);\n    require(timestamp > 0, \"The referenced period was not submitted to bridge\");\n\n    if (_youngestInputProof.length > 0) {\n      (, timestamp,,) = bridge.periods(_youngestInputProof[0]);\n      require(timestamp > 0, \"The referenced period was not submitted to bridge\");\n    }\n\n    // check exiting tx inclusion in the root chain block\n    bytes32 txHash;\n    bytes memory txData;\n    uint64 txPos;\n    (txPos, txHash, txData) = TxLib.validateProof(32 * (_youngestInputProof.length + 2) + 64, _proof);\n\n    // parse exiting tx and check if it is exitable\n    TxLib.Tx memory exitingTx = TxLib.parseTx(txData);\n    TxLib.Output memory out = exitingTx.outs[_outputIndex];\n\n    bytes32 utxoId = bytes32(uint256(_outputIndex) << 120 | uint120(uint256(txHash)));\n    uint256 priority;\n    if (msg.sender != out.owner) {\n      // or caller code hashes to owner\n      address a = msg.sender;\n      assembly {\n        priority := extcodehash(a) // abusing priority for hashBytes here, to save stack\n      }\n      require(priority != 0, \"caller not contract\");\n      require(bytes20(out.owner) == ripemd160(abi.encode(priority)), \"Only UTXO owner or contract can start exit\");\n      out.owner = msg.sender;\n    }\n    require(out.value > 0, \"UTXO has no value\");\n    require(exits[utxoId].amount == 0, \"The exit for UTXO has already been started\");\n    require(!exits[utxoId].finalized, \"The exit for UTXO has already been finalized\");\n\n    \n    if (_youngestInputProof.length > 0) {\n      // check youngest input tx inclusion in the root chain block\n      bytes32 inputTxHash;\n      (txPos, inputTxHash,) = TxLib.validateProof(96, _youngestInputProof);\n      require(\n        inputTxHash == exitingTx.ins[_inputIndex].outpoint.hash,\n        \"Input from the proof is not referenced in exiting tx\"\n      );\n      \n      if (isNft(out.color)) {\n        priority = (nftExitCounter << 128) | uint128(uint256(utxoId));\n        nftExitCounter++;\n      } else if (isNST(out.color)) {\n        priority = (nstExitCounter << 128) | uint128(uint256(utxoId));\n        nstExitCounter++;\n      } else {      \n        priority = getERC20ExitPriority(timestamp, utxoId, txPos);\n      }\n    } else {\n      require(exitingTx.txType == TxLib.TxType.Deposit, \"Expected deposit tx\");\n      if (isNft(out.color)) {\n        priority = (nftExitCounter << 128) | uint128(uint256(utxoId));\n        nftExitCounter++;\n      } else if (isNST(out.color)) {\n        priority = (nstExitCounter << 128) | uint128(uint256(utxoId));\n        nstExitCounter++;\n      } else {\n        priority = getERC20ExitPriority(timestamp, utxoId, txPos);\n      }\n    }\n\n    tokens[out.color].insert(priority);\n\n    exits[utxoId] = Exit({\n      owner: out.owner,\n      color: out.color,\n      amount: out.value,\n      finalized: false,\n      stake: exitStake,\n      priorityTimestamp: timestamp,\n      tokenData: out.stateRoot\n    });\n\n    emit ExitStarted(\n      txHash,\n      _outputIndex,\n      out.color,\n      out.owner,\n      out.value\n    );","after":"\n\n  function startExit(\n    bytes32[] calldata _youngestInputProof, bytes32[] calldata _proof,\n    uint8 _outputIndex, uint8 _inputIndex\n  ) public payable {\n    require(msg.value >= exitStake, \"Not enough ether sent to pay for exit stake\");\n    uint32 timestamp;\n    (, timestamp,,) = bridge.periods(_proof[0]);\n    require(timestamp > 0, \"The referenced period was not submitted to bridge\");\n\n    if (_youngestInputProof.length > 0) {\n      (, timestamp,,) = bridge.periods(_youngestInputProof[0]);\n      require(timestamp > 0, \"The referenced period was not submitted to bridge\");\n    }\n\n    // check exiting tx inclusion in the root chain block\n    bytes32 txHash;\n    bytes memory txData;\n    uint64 txPos;\n    (txPos, txHash, txData) = TxLib.validateProof(32 * (_youngestInputProof.length + 2) + 64, _proof);\n\n    // parse exiting tx and check if it is exitable\n    TxLib.Tx memory exitingTx = TxLib.parseTx(txData);\n    TxLib.Output memory out = exitingTx.outs[_outputIndex];\n\n    bytes32 utxoId = bytes32(uint256(_outputIndex) << 120 | uint120(uint256(txHash)));\n    uint256 priority;\n    if (msg.sender != out.owner) {\n      // or caller code hashes to owner\n      address a = msg.sender;\n      assembly {\n        priority := extcodehash(a) // abusing priority for hashBytes here, to save stack\n      }\n      require(priority != 0, \"caller not contract\");\n      require(bytes20(out.owner) == ripemd160(abi.encode(priority)), \"Only UTXO owner or contract can start exit\");\n      out.owner = msg.sender;\n    }\n    require(out.value > 0, \"UTXO has no value\");\n    require(exits[utxoId].amount == 0, \"The exit for UTXO has already been started\");\n    require(!exits[utxoId].finalized, \"The exit for UTXO has already been finalized\");\n\n    \n    if (_youngestInputProof.length > 0) {\n      // check youngest input tx inclusion in the root chain block\n      bytes32 inputTxHash;\n      (txPos, inputTxHash,) = TxLib.validateProof(96, _youngestInputProof);\n      require(\n        inputTxHash == exitingTx.ins[_inputIndex].outpoint.hash,\n        \"Input from the proof is not referenced in exiting tx\"\n      );\n      \n      if (isNft(out.color)) {\n        priority = (nftExitCounter << 128) | uint128(uint256(utxoId));\n        nftExitCounter++;\n      } else if (isNST(out.color)) {\n        priority = (nstExitCounter << 128) | uint128(uint256(utxoId));\n        nstExitCounter++;\n      } else {      \n        priority = getERC20ExitPriority(timestamp, utxoId, txPos);\n      }\n    } else {\n      require(exitingTx.txType == TxLib.TxType.Deposit, \"Expected deposit tx\");\n      if (isNft(out.color)) {\n        priority = (nftExitCounter << 128) | uint128(uint256(utxoId));\n        nftExitCounter++;\n      } else if (isNST(out.color)) {\n        priority = (nstExitCounter << 128) | uint128(uint256(utxoId));\n        nstExitCounter++;\n      } else {\n        priority = getERC20ExitPriority(timestamp, utxoId, txPos);\n      }\n    }\n\n    tokens[out.color].insert(priority);\n\n    exits[utxoId] = Exit({\n      owner: out.owner,\n      color: out.color,\n      amount: out.value,\n      finalized: false,\n      stake: exitStake,\n      priorityTimestamp: timestamp,\n      tokenData: out.stateRoot\n    });\n\n    emit ExitStarted(\n      txHash,\n      _outputIndex,\n      out.color,\n      out.owner,\n      out.value\n    );","contract":"FastExitHandler","time":0},{"type":"external-function ","before":"\n\n  function challengeExit(\n    bytes32[] memory _proof,\n    bytes32[] memory _prevProof,\n    uint8 _outputIndex,\n    uint8 _inputIndex,\n    address challenger\n  ) public {\n    require(msg.sender == challenger, \"Wrong challenger\");\n    // validate exiting tx\n    uint256 offset = 32 * (_proof.length + 2);\n    bytes32 txHash1;\n    bytes memory txData;\n    (, txHash1, txData) = TxLib.validateProof(offset + 96, _prevProof);\n    bytes32 utxoId = bytes32(uint256(_outputIndex) << 120 | uint120(uint256(txHash1)));\n\n    TxLib.Tx memory txn;\n    if (_proof.length > 0) {\n      // validate spending tx\n      bytes32 txHash;\n      (, txHash, txData) = TxLib.validateProof(128, _proof);\n      txn = TxLib.parseTx(txData);\n\n      // make sure one is spending the other one\n      require(txHash1 == txn.ins[_inputIndex].outpoint.hash);\n      require(_outputIndex == txn.ins[_inputIndex].outpoint.pos);\n\n      // if transfer, make sure signature correct\n      if (txn.txType == TxLib.TxType.Transfer) {\n        bytes32 sigHash = TxLib.getSigHash(txData);\n        address signer = ecrecover(\n          sigHash,\n          txn.ins[_inputIndex].v,\n          txn.ins[_inputIndex].r,\n          txn.ins[_inputIndex].s\n        );\n        require(exits[utxoId].owner == signer);\n      } else if (txn.txType == TxLib.TxType.SpendCond) {\n        // just have the pass through\n        // later we will check solEVM Enforcer here.\n      } else {\n        revert(\"unknown tx type\");\n      }\n    } else {\n      // challenging deposit exit\n      txn = TxLib.parseTx(txData);\n      utxoId = txn.ins[_inputIndex].outpoint.hash;\n      if (txn.txType == TxLib.TxType.Deposit) {\n        // check that deposit was included correctly\n        // only then it should be usable for challenge\n        Deposit memory deposit = deposits[uint32(uint256(utxoId))];\n        require(deposit.amount == txn.outs[0].value, \"value mismatch\");\n        require(deposit.owner == txn.outs[0].owner, \"owner mismatch\");\n        require(deposit.color == txn.outs[0].color, \"color mismatch\");\n        if (isNST(deposit.color)) {\n          require(tokenData[uint32(uint256(utxoId))] == txn.outs[0].stateRoot, \"data mismatch\");\n        }\n        // todo: check timely inclusion of deposit tx\n        // this will prevent grieving attacks by the operator\n      } else {\n        revert(\"unexpected tx type\");\n      }\n    }\n\n    require(exits[utxoId].amount > 0, \"exit not found\");\n    require(!exits[utxoId].finalized, \"The exit has already been finalized\");\n\n    // award stake to challanger\n    msg.sender.transfer(exits[utxoId].stake);\n    // delete invalid exit\n    delete exits[utxoId];","after":"\n\n  function challengeExit(\n    bytes32[] calldata _proof,\n    bytes32[] calldata _prevProof,\n    uint8 _outputIndex,\n    uint8 _inputIndex,\n    address challenger\n  ) public {\n    require(msg.sender == challenger, \"Wrong challenger\");\n    // validate exiting tx\n    uint256 offset = 32 * (_proof.length + 2);\n    bytes32 txHash1;\n    bytes memory txData;\n    (, txHash1, txData) = TxLib.validateProof(offset + 96, _prevProof);\n    bytes32 utxoId = bytes32(uint256(_outputIndex) << 120 | uint120(uint256(txHash1)));\n\n    TxLib.Tx memory txn;\n    if (_proof.length > 0) {\n      // validate spending tx\n      bytes32 txHash;\n      (, txHash, txData) = TxLib.validateProof(128, _proof);\n      txn = TxLib.parseTx(txData);\n\n      // make sure one is spending the other one\n      require(txHash1 == txn.ins[_inputIndex].outpoint.hash);\n      require(_outputIndex == txn.ins[_inputIndex].outpoint.pos);\n\n      // if transfer, make sure signature correct\n      if (txn.txType == TxLib.TxType.Transfer) {\n        bytes32 sigHash = TxLib.getSigHash(txData);\n        address signer = ecrecover(\n          sigHash,\n          txn.ins[_inputIndex].v,\n          txn.ins[_inputIndex].r,\n          txn.ins[_inputIndex].s\n        );\n        require(exits[utxoId].owner == signer);\n      } else if (txn.txType == TxLib.TxType.SpendCond) {\n        // just have the pass through\n        // later we will check solEVM Enforcer here.\n      } else {\n        revert(\"unknown tx type\");\n      }\n    } else {\n      // challenging deposit exit\n      txn = TxLib.parseTx(txData);\n      utxoId = txn.ins[_inputIndex].outpoint.hash;\n      if (txn.txType == TxLib.TxType.Deposit) {\n        // check that deposit was included correctly\n        // only then it should be usable for challenge\n        Deposit memory deposit = deposits[uint32(uint256(utxoId))];\n        require(deposit.amount == txn.outs[0].value, \"value mismatch\");\n        require(deposit.owner == txn.outs[0].owner, \"owner mismatch\");\n        require(deposit.color == txn.outs[0].color, \"color mismatch\");\n        if (isNST(deposit.color)) {\n          require(tokenData[uint32(uint256(utxoId))] == txn.outs[0].stateRoot, \"data mismatch\");\n        }\n        // todo: check timely inclusion of deposit tx\n        // this will prevent grieving attacks by the operator\n      } else {\n        revert(\"unexpected tx type\");\n      }\n    }\n\n    require(exits[utxoId].amount > 0, \"exit not found\");\n    require(!exits[utxoId].finalized, \"The exit has already been finalized\");\n\n    // award stake to challanger\n    msg.sender.transfer(exits[utxoId].stake);\n    // delete invalid exit\n    delete exits[utxoId];","contract":"FastExitHandler","time":0},{"type":"external-function ","before":"\n\n  function challengeYoungestInput(\n    bytes32[] memory _youngerInputProof,\n    bytes32[] memory _exitingTxProof,\n    uint8 _outputIndex,\n    uint8 _inputIndex,\n    address challenger\n  ) public {\n    require(msg.sender == challenger, \"Wrong challenger\");\n    // validate exiting input tx\n    bytes32 txHash;\n    bytes memory txData;\n    (, txHash, txData) = TxLib.validateProof(32 * (_youngerInputProof.length + 2) + 96, _exitingTxProof);\n    bytes32 utxoId = bytes32(uint256(_outputIndex) << 120 | uint120(uint256(txHash)));\n\n    // check the exit exists\n    require(exits[utxoId].amount > 0, \"There is no exit for this UTXO\");\n\n    TxLib.Tx memory exitingTx = TxLib.parseTx(txData);\n\n    // validate younger input tx\n    (,txHash,) = TxLib.validateProof(128, _youngerInputProof);\n\n    // check younger input is actually an input of exiting tx\n    require(txHash == exitingTx.ins[_inputIndex].outpoint.hash, \"Given output is not referenced in exiting tx\");\n\n    uint32 youngerInputTimestamp;\n    (,youngerInputTimestamp,,) = bridge.periods(_youngerInputProof[0]);\n    require(youngerInputTimestamp > 0, \"The referenced period was not submitted to bridge\");\n\n    require(exits[utxoId].priorityTimestamp < youngerInputTimestamp, \"Challenged input should be older\");\n\n    // award stake to challanger\n    msg.sender.transfer(exits[utxoId].stake);\n    // delete invalid exit\n    delete exits[utxoId];","after":"\n\n  function challengeYoungestInput(\n    bytes32[] calldata _youngerInputProof,\n    bytes32[] calldata _exitingTxProof,\n    uint8 _outputIndex,\n    uint8 _inputIndex,\n    address challenger\n  ) public {\n    require(msg.sender == challenger, \"Wrong challenger\");\n    // validate exiting input tx\n    bytes32 txHash;\n    bytes memory txData;\n    (, txHash, txData) = TxLib.validateProof(32 * (_youngerInputProof.length + 2) + 96, _exitingTxProof);\n    bytes32 utxoId = bytes32(uint256(_outputIndex) << 120 | uint120(uint256(txHash)));\n\n    // check the exit exists\n    require(exits[utxoId].amount > 0, \"There is no exit for this UTXO\");\n\n    TxLib.Tx memory exitingTx = TxLib.parseTx(txData);\n\n    // validate younger input tx\n    (,txHash,) = TxLib.validateProof(128, _youngerInputProof);\n\n    // check younger input is actually an input of exiting tx\n    require(txHash == exitingTx.ins[_inputIndex].outpoint.hash, \"Given output is not referenced in exiting tx\");\n\n    uint32 youngerInputTimestamp;\n    (,youngerInputTimestamp,,) = bridge.periods(_youngerInputProof[0]);\n    require(youngerInputTimestamp > 0, \"The referenced period was not submitted to bridge\");\n\n    require(exits[utxoId].priorityTimestamp < youngerInputTimestamp, \"Challenged input should be older\");\n\n    // award stake to challanger\n    msg.sender.transfer(exits[utxoId].stake);\n    // delete invalid exit\n    delete exits[utxoId];","contract":"FastExitHandler","time":0}]}