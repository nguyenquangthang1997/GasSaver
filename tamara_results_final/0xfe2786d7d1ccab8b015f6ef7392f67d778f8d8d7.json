{"time":159,"results":[{"type":"state-data-arrangement ","before":"\n   uint256 internal constant MAX_UINT256 = ~uint256(\n   uint256 internal constant TOTAL_TOKENS = 500000000e\n   string public constant name = \"Parsiq Toke\n   string public constant symbol = \"PR\n   uint8 public constant decimals = uint8(1\n   mapping(address => bool) public noti\n   mapping(address => Timelock[]) public timeloc\n   mapping(address => Timelock[]) public relativeTimeloc\n   mapping(bytes32 => bool) public hashedT\n   mapping(address => bool) public whitelist\n   uint256 public transfersUnlockTime = MAX_UINT2\n   address public burnerAddre\n   bool public burningEnabl\n   bool public etherlessTransferEnabled = tr","after":"   uint256 internal constant MAX_UINT256 = ~uint256(\n   uint256 internal constant TOTAL_TOKENS = 500000000e\n   string public constant name = \"Parsiq Toke\n   string public constant symbol = \"PR\n   mapping(address => bool) public noti\n   mapping(address => Timelock[]) public timeloc\n   mapping(address => Timelock[]) public relativeTimeloc\n   mapping(bytes32 => bool) public hashedT\n   mapping(address => bool) public whitelist\n   uint256 public transfersUnlockTime = MAX_UINT2\n   address public burnerAddre\n   uint8 public constant decimals = uint8(1\n   bool public burningEnabl\n   bool public etherlessTransferEnabled = tr\n","contract":"ParsiqToken","time":0},{"type":"external-function ","before":"   function transferBatch(address[] memory to, uint256[] memory value) public returns (bool) {\n        require(to.length == value.length, \"Array sizes must be equal\");\n        uint256 n = to.length;\n        for (uint256 i = 0; i < n; i++) {\n            transfer(to[i], value[i]);\n        }\n        return true;\n  ","after":"   function transferBatch(address[] calldata to, uint256[] calldata value) public returns (bool) {\n        require(to.length == value.length, \"Array sizes must be equal\");\n        uint256 n = to.length;\n        for (uint256 i = 0; i < n; i++) {\n            transfer(to[i], value[i]);\n        }\n        return true;\n  ","contract":"ParsiqToken","time":0},{"type":"external-function ","before":"   function transferPreSigned(\n        bytes memory _signature,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        onlyWhenEtherlessTransferEnabled\n        notTokenAddress(_to)\n        notBurnerUntilBurnIsEnabled(_to)\n        returns (bool)\n    {\n        require(_to != address(0), \"Transfer to the zero address\");\n\n        bytes32 hashedParams = hashForSign(msg.sig, address(this), _to, _value, _fee, _nonce);\n        address from = hashedParams.toEthSignedMessageHash().recover(_signature);\n        require(from != address(0), \"Invalid signature\");\n\n        require(\n            transfersUnlockTime <= now ||\n            whitelisted[from] == true ||\n            whitelisted[_to] == true, \"Transfers are locked\");\n\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\n        require(hashedTxs[hashedTx] == false, \"Nonce already used\");\n        hashedTxs[hashedTx] = true;\n\n        if (msg.sender == _to) {\n            _transfer(from, _to, _value.add(_fee));\n            _postTransfer(from, _to, _value.add(_fee));\n        } else {\n            _transfer(from, _to, _value);\n            _postTransfer(from, _to, _value);\n            _transfer(from, msg.sender, _fee);\n            _postTransfer(from, msg.sender, _fee);\n        }\n\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\n        return true;\n  ","after":"   function transferPreSigned(\n        bytes calldata _signature,\n        address _to,\n        uint256 _value,\n        uint256 _fee,\n        uint256 _nonce\n    )\n        public\n        onlyWhenEtherlessTransferEnabled\n        notTokenAddress(_to)\n        notBurnerUntilBurnIsEnabled(_to)\n        returns (bool)\n    {\n        require(_to != address(0), \"Transfer to the zero address\");\n\n        bytes32 hashedParams = hashForSign(msg.sig, address(this), _to, _value, _fee, _nonce);\n        address from = hashedParams.toEthSignedMessageHash().recover(_signature);\n        require(from != address(0), \"Invalid signature\");\n\n        require(\n            transfersUnlockTime <= now ||\n            whitelisted[from] == true ||\n            whitelisted[_to] == true, \"Transfers are locked\");\n\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\n        require(hashedTxs[hashedTx] == false, \"Nonce already used\");\n        hashedTxs[hashedTx] = true;\n\n        if (msg.sender == _to) {\n            _transfer(from, _to, _value.add(_fee));\n            _postTransfer(from, _to, _value.add(_fee));\n        } else {\n            _transfer(from, _to, _value);\n            _postTransfer(from, _to, _value);\n            _transfer(from, msg.sender, _fee);\n            _postTransfer(from, msg.sender, _fee);\n        }\n\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\n        return true;\n  ","contract":"ParsiqToken","time":0},{"type":"external-function ","before":"   function releasePreSigned(bytes memory _signature, uint256 _fee, uint256 _nonce)\n        public\n        onlyWhenEtherlessTransferEnabled\n        returns (bool)\n    {\n        bytes32 hashedParams = hashForReleaseSign(msg.sig, address(this), _fee, _nonce);\n        address from = hashedParams.toEthSignedMessageHash().recover(_signature);\n        require(from != address(0), \"Invalid signature\");\n\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\n        require(hashedTxs[hashedTx] == false, \"Nonce already used\");\n        hashedTxs[hashedTx] = true;\n\n        uint256 released = _release(from);\n        require(released > _fee, \"Too small release\");\n        if (from != msg.sender) { // \"from\" already have all the tokens, no need to charge\n            _transfer(from, msg.sender, _fee);\n            _postTransfer(from, msg.sender, _fee);\n        }\n        return true;\n  ","after":"   function releasePreSigned(bytes calldata _signature, uint256 _fee, uint256 _nonce)\n        public\n        onlyWhenEtherlessTransferEnabled\n        returns (bool)\n    {\n        bytes32 hashedParams = hashForReleaseSign(msg.sig, address(this), _fee, _nonce);\n        address from = hashedParams.toEthSignedMessageHash().recover(_signature);\n        require(from != address(0), \"Invalid signature\");\n\n        bytes32 hashedTx = keccak256(abi.encodePacked(from, hashedParams));\n        require(hashedTxs[hashedTx] == false, \"Nonce already used\");\n        hashedTxs[hashedTx] = true;\n\n        uint256 released = _release(from);\n        require(released > _fee, \"Too small release\");\n        if (from != msg.sender) { // \"from\" already have all the tokens, no need to charge\n            _transfer(from, msg.sender, _fee);\n            _postTransfer(from, msg.sender, _fee);\n        }\n        return true;\n  ","contract":"ParsiqToken","time":0}]}