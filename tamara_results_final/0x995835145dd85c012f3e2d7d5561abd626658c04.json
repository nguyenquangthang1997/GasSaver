{"time":78,"results":[{"type":"external-function ","before":"  function liquidateNFTs(uint256[] memory _nftIds, address[] memory _nftContractAddresses, bool _isMixedBatchOfNFTs, uint256 _uniswapSlippageAllowedInBasisPoints) public {\n        require(_nftIds.length == _nftContractAddresses.length, 'you did not provide an nftContractAddress for each of the groups of NFTs that you wish to liquidate');\n        require(_nftIds.length > 0, 'you must submit an array with at least one element');\n\n        for(uint i = 0; i < _nftIds.length; i++){\n            // Transfer NFTs from User to Proxy, since only the owner of the token can call depositNftsAndMintTokens.\n            NFTCore(_nftContractAddresses[i]).transferFrom(msg.sender, address(this), _nftIds[i]);\n\n            // If we are melting an array of NFTs that come from different NFTCore contracts, then we\n            //  call wrapAndLiquidate one by one, since each NFT has a different corresponding wrapper\n            //  contract and uniswap contract\n            if(_isMixedBatchOfNFTs){\n                uint256[] memory nftIdArray = new uint256[](1);\n                nftIdArray[0] = _nftIds[i];\n                _wrapAndLiquidateArrayOfNfts(nftIdArray, _nftContractAddresses[i], msg.sender, _uniswapSlippageAllowedInBasisPoints);\n            }\n        }\n        // If we are melting an array of NFTs that come from the same NFTCore contract, then we call\n        //  wrapAndLiquidate together in a bundle to save gas, since they share the same wrapper contract\n        //  and the same uniswap contract.\n        if(!_isMixedBatchOfNFTs){\n            _wrapAndLiquidateArrayOfNfts(_nftIds, _nftContractAddresses[0], msg.sender, _uniswapSlippageAllowedInBasisPoints);\n        }\n   ","after":"  function liquidateNFTs(uint256[] calldata _nftIds, address[] calldata _nftContractAddresses, bool _isMixedBatchOfNFTs, uint256 _uniswapSlippageAllowedInBasisPoints) public {\n        require(_nftIds.length == _nftContractAddresses.length, 'you did not provide an nftContractAddress for each of the groups of NFTs that you wish to liquidate');\n        require(_nftIds.length > 0, 'you must submit an array with at least one element');\n\n        for(uint i = 0; i < _nftIds.length; i++){\n            // Transfer NFTs from User to Proxy, since only the owner of the token can call depositNftsAndMintTokens.\n            NFTCore(_nftContractAddresses[i]).transferFrom(msg.sender, address(this), _nftIds[i]);\n\n            // If we are melting an array of NFTs that come from different NFTCore contracts, then we\n            //  call wrapAndLiquidate one by one, since each NFT has a different corresponding wrapper\n            //  contract and uniswap contract\n            if(_isMixedBatchOfNFTs){\n                uint256[] memory nftIdArray = new uint256[](1);\n                nftIdArray[0] = _nftIds[i];\n                _wrapAndLiquidateArrayOfNfts(nftIdArray, _nftContractAddresses[i], msg.sender, _uniswapSlippageAllowedInBasisPoints);\n            }\n        }\n        // If we are melting an array of NFTs that come from the same NFTCore contract, then we call\n        //  wrapAndLiquidate together in a bundle to save gas, since they share the same wrapper contract\n        //  and the same uniswap contract.\n        if(!_isMixedBatchOfNFTs){\n            _wrapAndLiquidateArrayOfNfts(_nftIds, _nftContractAddresses[0], msg.sender, _uniswapSlippageAllowedInBasisPoints);\n        }\n   ","contract":"WrappedNFTLiquidationProxy","time":0},{"type":"constant-restrict-modification  ","before":"  address private wrappedKittiesAddress = 0x09fE5f0236F0Ea5D930197DCE254d77B0412807","after":"  address private constant wrappedKittiesAddress = 0x09fE5f0236F0Ea5D930197DCE254d77B0412807","contract":"WrappedNFTLiquidationProxy","time":0}]}