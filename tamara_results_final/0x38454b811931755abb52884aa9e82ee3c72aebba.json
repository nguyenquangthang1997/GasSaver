{"time":290,"results":[{"type":"external-function ","before":"function purchaseCallbackOnAccept(\n\t\tuint256 groupNumber, address[] memory addresses, uint256[] memory weiAmounts)\n\tpublic onlyManyOwnersOrOracle(keccak256(msg.data)) returns(bool success) {\n\t\treturn accept(groupNumber, addresses, weiAmounts);\n\t}","after":"function purchaseCallbackOnAccept(\n\t\tuint256 groupNumber, address[] calldata addresses, uint256[] calldata weiAmounts)\n\tpublic onlyManyOwnersOrOracle(keccak256(msg.data)) returns(bool success) {\n\t\treturn accept(groupNumber, addresses, weiAmounts);\n\t}","contract":"SparksterTokenSwap","time":0},{"type":"external-function ","before":"function insertAndApprove(uint256 groupNumber, address[] memory addresses, uint256[] memory weiAmounts)\n\tpublic onlyManyOwnersOrOracle(keccak256(msg.data)) returns(bool) {\n\t\tuint256 n = addresses.length;\n\t\trequire(n == weiAmounts.length, \"Length\");\n\t\tGroup storage theGroup = groups[groupNumber];\n\t\tfor (uint256 i = 0; i < n; i++) {\n\t\t\taddress theAddress = addresses[i];\n\t\t\tif (!theGroup.exists[theAddress]) {\n\t\t\t\ttheGroup.addresses.push(theAddress);\n\t\t\t\ttheGroup.exists[theAddress] = true;\n\t\t\t\tmembers[theAddress].groups.push(groupNumber);\n\t\t\t}\n\t\t}\n\t\treturn accept(groupNumber, addresses, weiAmounts);\n\t}","after":"function insertAndApprove(uint256 groupNumber, address[] calldata addresses, uint256[] calldata weiAmounts)\n\tpublic onlyManyOwnersOrOracle(keccak256(msg.data)) returns(bool) {\n\t\tuint256 n = addresses.length;\n\t\trequire(n == weiAmounts.length, \"Length\");\n\t\tGroup storage theGroup = groups[groupNumber];\n\t\tfor (uint256 i = 0; i < n; i++) {\n\t\t\taddress theAddress = addresses[i];\n\t\t\tif (!theGroup.exists[theAddress]) {\n\t\t\t\ttheGroup.addresses.push(theAddress);\n\t\t\t\ttheGroup.exists[theAddress] = true;\n\t\t\t\tmembers[theAddress].groups.push(groupNumber);\n\t\t\t}\n\t\t}\n\t\treturn accept(groupNumber, addresses, weiAmounts);\n\t}","contract":"SparksterTokenSwap","time":0},{"type":"external-function ","before":"function callbackInsertApproveAndDistribute(\n\t\tuint256 groupNumber, address[] memory addresses, uint256[] memory weiAmounts)\n\tpublic onlyManyOwnersOrOracle(keccak256(msg.data)) returns(bool) {\n\t\tuint256 n = addresses.length;\n\t\trequire(n == weiAmounts.length, \"Length\");\n\t\trequire(getGroupState(groupNumber) != GroupStates.unlocked, \"Unlocked\");\n\t\tGroup storage theGroup = groups[groupNumber];\n\t\tuint256 newOwnerSupply = balances[owner];\n\t\tfor (uint256 i = 0; i < n; i++) {\n\t\t\taddress theAddress = addresses[i];\n\t\t\tMember storage memberRecord = members[theAddress];\n\t\t\tuint256 weiAmount = weiAmounts[i];\n\t\t\tmemberRecord.weiBalance[groupNumber] = memberRecord.weiBalance[groupNumber].add(weiAmount);\n\t\t\t// Record the total amount purchased by the current member\n\t\t\tif (!theGroup.exists[theAddress]) {\n\t\t\t\ttheGroup.addresses.push(theAddress);\n\t\t\t\ttheGroup.exists[theAddress] = true;\n\t\t\t\tmemberRecord.groups.push(groupNumber);\n\t\t\t}\n\t\t\tuint256 additionalBalance = weiAmount.mul(theGroup.ratio); // Don't give cumulative tokens; one address can be distributed multiple times.\n\t\t\tif (additionalBalance > 0) {\n\t\t\t\tbalances[theAddress] = balances[theAddress].add(additionalBalance);\n\t\t\t\tnewOwnerSupply = newOwnerSupply.sub(additionalBalance); // Update the available number of tokens.\n\t\t\t\temit Transfer(owner, theAddress, additionalBalance); // Notify exchanges of the distribution.\n\t\t\t}\n\t\t}\n\t\tbalances[owner] = newOwnerSupply;\n\t\temit PurchasedCallbackOnAccept(groupNumber, addresses);\n\t\tif (getGroupState(groupNumber) != GroupStates.distributed)\n\t\t\ttheGroup.state = GroupStates.distributed;\n\t\treturn true;\n\t}","after":"function callbackInsertApproveAndDistribute(\n\t\tuint256 groupNumber, address[] calldata addresses, uint256[] calldata weiAmounts)\n\tpublic onlyManyOwnersOrOracle(keccak256(msg.data)) returns(bool) {\n\t\tuint256 n = addresses.length;\n\t\trequire(n == weiAmounts.length, \"Length\");\n\t\trequire(getGroupState(groupNumber) != GroupStates.unlocked, \"Unlocked\");\n\t\tGroup storage theGroup = groups[groupNumber];\n\t\tuint256 newOwnerSupply = balances[owner];\n\t\tfor (uint256 i = 0; i < n; i++) {\n\t\t\taddress theAddress = addresses[i];\n\t\t\tMember storage memberRecord = members[theAddress];\n\t\t\tuint256 weiAmount = weiAmounts[i];\n\t\t\tmemberRecord.weiBalance[groupNumber] = memberRecord.weiBalance[groupNumber].add(weiAmount);\n\t\t\t// Record the total amount purchased by the current member\n\t\t\tif (!theGroup.exists[theAddress]) {\n\t\t\t\ttheGroup.addresses.push(theAddress);\n\t\t\t\ttheGroup.exists[theAddress] = true;\n\t\t\t\tmemberRecord.groups.push(groupNumber);\n\t\t\t}\n\t\t\tuint256 additionalBalance = weiAmount.mul(theGroup.ratio); // Don't give cumulative tokens; one address can be distributed multiple times.\n\t\t\tif (additionalBalance > 0) {\n\t\t\t\tbalances[theAddress] = balances[theAddress].add(additionalBalance);\n\t\t\t\tnewOwnerSupply = newOwnerSupply.sub(additionalBalance); // Update the available number of tokens.\n\t\t\t\temit Transfer(owner, theAddress, additionalBalance); // Notify exchanges of the distribution.\n\t\t\t}\n\t\t}\n\t\tbalances[owner] = newOwnerSupply;\n\t\temit PurchasedCallbackOnAccept(groupNumber, addresses);\n\t\tif (getGroupState(groupNumber) != GroupStates.distributed)\n\t\t\ttheGroup.state = GroupStates.distributed;\n\t\treturn true;\n\t}","contract":"SparksterTokenSwap","time":0},{"type":"external-function ","before":"function refund(address[] memory addresses, uint256[] memory weiAmounts) public onlyManyOwners(keccak256(msg.data)) returns(bool success) {\n\t\tuint256 n = addresses.length;\n\t\trequire (n == weiAmounts.length, \"Length\");\n\t\tuint256 thePenalty = penalty;\n\t\tuint256 totalRefund = 0;\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\tuint256 weiAmount = weiAmounts[i];\n\t\t\taddress payable theAddress = address(uint160(address(addresses[i])));\n\t\t\tif (thePenalty < weiAmount) {\n\t\t\t\tweiAmount = weiAmount.sub(thePenalty);\n\t\t\t\ttotalRefund = totalRefund.add(weiAmount);\n\t\t\t\twithdrawableBalances[theAddress] = withdrawableBalances[theAddress].add(weiAmount);\n\t\t\t}\n\t\t}\n\t\trequire(address(this).balance >= minimumRequiredBalance + totalRefund, \"NSF\"); // The contract must have enough to refund these addresses.\n\t\tminimumRequiredBalance = minimumRequiredBalance.add(totalRefund);\n\t\temit RefundedBatch(addresses);\n\t\treturn true;\n\t}","after":"function refund(address[] calldata addresses, uint256[] calldata weiAmounts) public onlyManyOwners(keccak256(msg.data)) returns(bool success) {\n\t\tuint256 n = addresses.length;\n\t\trequire (n == weiAmounts.length, \"Length\");\n\t\tuint256 thePenalty = penalty;\n\t\tuint256 totalRefund = 0;\n\t\tfor(uint256 i = 0; i < n; i++) {\n\t\t\tuint256 weiAmount = weiAmounts[i];\n\t\t\taddress payable theAddress = address(uint160(address(addresses[i])));\n\t\t\tif (thePenalty < weiAmount) {\n\t\t\t\tweiAmount = weiAmount.sub(thePenalty);\n\t\t\t\ttotalRefund = totalRefund.add(weiAmount);\n\t\t\t\twithdrawableBalances[theAddress] = withdrawableBalances[theAddress].add(weiAmount);\n\t\t\t}\n\t\t}\n\t\trequire(address(this).balance >= minimumRequiredBalance + totalRefund, \"NSF\"); // The contract must have enough to refund these addresses.\n\t\tminimumRequiredBalance = minimumRequiredBalance.add(totalRefund);\n\t\temit RefundedBatch(addresses);\n\t\treturn true;\n\t}","contract":"SparksterTokenSwap","time":0},{"type":"external-function ","before":"function createGroup(\n\t\tstring memory groupName, uint256 startEpoch, uint256 phase1endEpoch, uint256 phase2endEpoch, uint256 deadlineEpoch,\n\t\tuint256 unlockAfterEpoch, uint256 phase2weiCap, uint256 phase3weiCap, uint256 hardWeiCap, uint256 ratio) public\n\tonlyManyOwners(keccak256(msg.data)) returns (bool success, uint256 createdGroupNumber) {\n\t\trequire(nextGroupNumber < maxGroups, \"Too many groups\");\n\t\tcreatedGroupNumber = nextGroupNumber;\n\t\tGroup storage theGroup = groups[createdGroupNumber];\n\t\ttheGroup.name = groupName;\n\t\ttheGroup.startTime = startEpoch;\n\t\ttheGroup.phase1endTime = phase1endEpoch;\n\t\ttheGroup.phase2endTime = phase2endEpoch;\n\t\ttheGroup.deadline = deadlineEpoch;\n\t\ttheGroup.unlockTime = unlockAfterEpoch;\n\t\ttheGroup.max2 = phase2weiCap;\n\t\ttheGroup.max3 = phase3weiCap;\n\t\ttheGroup.cap = hardWeiCap;\n\t\ttheGroup.ratio = ratio;\n\t\tnextGroupNumber++;\n\t\tsuccess = true;\n\t}","after":"function createGroup(\n\t\tstring calldata groupName, uint256 startEpoch, uint256 phase1endEpoch, uint256 phase2endEpoch, uint256 deadlineEpoch,\n\t\tuint256 unlockAfterEpoch, uint256 phase2weiCap, uint256 phase3weiCap, uint256 hardWeiCap, uint256 ratio) public\n\tonlyManyOwners(keccak256(msg.data)) returns (bool success, uint256 createdGroupNumber) {\n\t\trequire(nextGroupNumber < maxGroups, \"Too many groups\");\n\t\tcreatedGroupNumber = nextGroupNumber;\n\t\tGroup storage theGroup = groups[createdGroupNumber];\n\t\ttheGroup.name = groupName;\n\t\ttheGroup.startTime = startEpoch;\n\t\ttheGroup.phase1endTime = phase1endEpoch;\n\t\ttheGroup.phase2endTime = phase2endEpoch;\n\t\ttheGroup.deadline = deadlineEpoch;\n\t\ttheGroup.unlockTime = unlockAfterEpoch;\n\t\ttheGroup.max2 = phase2weiCap;\n\t\ttheGroup.max3 = phase3weiCap;\n\t\ttheGroup.cap = hardWeiCap;\n\t\ttheGroup.ratio = ratio;\n\t\tnextGroupNumber++;\n\t\tsuccess = true;\n\t}","contract":"SparksterTokenSwap","time":0},{"type":"external-function ","before":"function airdrop( address[] memory addresses, uint256[] memory tokenDecimalAmounts) public onlyManyOwnersOrOracle(keccak256(msg.data))\n\treturns (bool) {\n\t\tuint256 n = addresses.length;\n\t\trequire(n == tokenDecimalAmounts.length, \"Length\");\n\t\tuint256 newOwnerBalance = balances[owner];\n\t\tfor (uint256 i = 0; i < n; i++) {\n\t\t\taddress theAddress = addresses[i];\n\t\t\tuint256 airdropAmount = tokenDecimalAmounts[i];\n\t\t\tif (airdropAmount > 0) {\n\t\t\t\tuint256 currentBalance = balances[theAddress];\n\t\t\t\tbalances[theAddress] = currentBalance.add(airdropAmount);\n\t\t\t\tnewOwnerBalance = newOwnerBalance.sub(airdropAmount);\n\t\t\t\temit Transfer(owner, theAddress, airdropAmount);\n\t\t\t}\n\t\t}\n\t\tbalances[owner] = newOwnerBalance;\n\t\temit AirdroppedBatch(addresses);\n\t\treturn true;\n\t}","after":"function airdrop( address[] calldata addresses, uint256[] calldata tokenDecimalAmounts) public onlyManyOwnersOrOracle(keccak256(msg.data))\n\treturns (bool) {\n\t\tuint256 n = addresses.length;\n\t\trequire(n == tokenDecimalAmounts.length, \"Length\");\n\t\tuint256 newOwnerBalance = balances[owner];\n\t\tfor (uint256 i = 0; i < n; i++) {\n\t\t\taddress theAddress = addresses[i];\n\t\t\tuint256 airdropAmount = tokenDecimalAmounts[i];\n\t\t\tif (airdropAmount > 0) {\n\t\t\t\tuint256 currentBalance = balances[theAddress];\n\t\t\t\tbalances[theAddress] = currentBalance.add(airdropAmount);\n\t\t\t\tnewOwnerBalance = newOwnerBalance.sub(airdropAmount);\n\t\t\t\temit Transfer(owner, theAddress, airdropAmount);\n\t\t\t}\n\t\t}\n\t\tbalances[owner] = newOwnerBalance;\n\t\temit AirdroppedBatch(addresses);\n\t\treturn true;\n\t}","contract":"SparksterTokenSwap","time":0}]}