{"time":1112,"results":[{"type":"external-function ","before":"function giveLaunchReward(address[] memory _addresses, uint256[] memory _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","after":"function giveLaunchReward(address[] calldata _addresses, uint256[] calldata _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] memory _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","after":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] calldata _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawExpiredStakings(uint256[] memory _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","after":"function withdrawExpiredStakings(uint256[] calldata _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] memory _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","after":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] calldata _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function burnDefaultedLoans(address[] memory _addressArray, uint256[] memory _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","after":"function burnDefaultedLoans(address[] calldata _addressArray, uint256[] calldata _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function giveLaunchReward(address[] memory _addresses, uint256[] memory _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","after":"function giveLaunchReward(address[] calldata _addresses, uint256[] calldata _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] memory _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","after":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] calldata _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawExpiredStakings(uint256[] memory _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","after":"function withdrawExpiredStakings(uint256[] calldata _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] memory _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","after":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] calldata _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function burnDefaultedLoans(address[] memory _addressArray, uint256[] memory _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","after":"function burnDefaultedLoans(address[] calldata _addressArray, uint256[] calldata _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function giveLaunchReward(address[] memory _addresses, uint256[] memory _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","after":"function giveLaunchReward(address[] calldata _addresses, uint256[] calldata _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] memory _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","after":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] calldata _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawExpiredStakings(uint256[] memory _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","after":"function withdrawExpiredStakings(uint256[] calldata _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] memory _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","after":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] calldata _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function burnDefaultedLoans(address[] memory _addressArray, uint256[] memory _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","after":"function burnDefaultedLoans(address[] calldata _addressArray, uint256[] calldata _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","contract":"TimeAlly","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public earthSecondsInMonth = 2629744;","after":"uint256 public constant earthSecondsInMonth = 2629744;","contract":"TimeAlly","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public earthSecondsInMonth = 2629744;","after":"uint256 public constant earthSecondsInMonth = 2629744;","contract":"TimeAlly","time":1},{"type":"constant-restrict-modification  ","before":"uint256 public earthSecondsInMonth = 2629744;","after":"uint256 public constant earthSecondsInMonth = 2629744;","contract":"TimeAlly","time":1},{"type":"external-function ","before":"function giveLaunchReward(address[] memory _addresses, uint256[] memory _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","after":"function giveLaunchReward(address[] calldata _addresses, uint256[] calldata _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] memory _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","after":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] calldata _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawExpiredStakings(uint256[] memory _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","after":"function withdrawExpiredStakings(uint256[] calldata _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] memory _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","after":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] calldata _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function burnDefaultedLoans(address[] memory _addressArray, uint256[] memory _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","after":"function burnDefaultedLoans(address[] calldata _addressArray, uint256[] calldata _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function giveLaunchReward(address[] memory _addresses, uint256[] memory _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","after":"function giveLaunchReward(address[] calldata _addresses, uint256[] calldata _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] memory _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","after":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] calldata _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","contract":"TimeAlly","time":1},{"type":"external-function ","before":"function withdrawExpiredStakings(uint256[] memory _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","after":"function withdrawExpiredStakings(uint256[] calldata _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] memory _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","after":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] calldata _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function burnDefaultedLoans(address[] memory _addressArray, uint256[] memory _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","after":"function burnDefaultedLoans(address[] calldata _addressArray, uint256[] calldata _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function giveLaunchReward(address[] memory _addresses, uint256[] memory _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","after":"function giveLaunchReward(address[] calldata _addresses, uint256[] calldata _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] memory _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","after":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] calldata _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawExpiredStakings(uint256[] memory _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","after":"function withdrawExpiredStakings(uint256[] calldata _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] memory _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","after":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] calldata _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function burnDefaultedLoans(address[] memory _addressArray, uint256[] memory _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","after":"function burnDefaultedLoans(address[] calldata _addressArray, uint256[] calldata _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","contract":"TimeAlly","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public earthSecondsInMonth = 2629744;","after":"uint256 public constant earthSecondsInMonth = 2629744;","contract":"TimeAlly","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public earthSecondsInMonth = 2629744;","after":"uint256 public constant earthSecondsInMonth = 2629744;","contract":"TimeAlly","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public earthSecondsInMonth = 2629744;","after":"uint256 public constant earthSecondsInMonth = 2629744;","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function giveLaunchReward(address[] memory _addresses, uint256[] memory _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","after":"function giveLaunchReward(address[] calldata _addresses, uint256[] calldata _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] memory _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","after":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] calldata _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawExpiredStakings(uint256[] memory _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","after":"function withdrawExpiredStakings(uint256[] calldata _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] memory _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","after":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] calldata _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function burnDefaultedLoans(address[] memory _addressArray, uint256[] memory _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","after":"function burnDefaultedLoans(address[] calldata _addressArray, uint256[] calldata _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function giveLaunchReward(address[] memory _addresses, uint256[] memory _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","after":"function giveLaunchReward(address[] calldata _addresses, uint256[] calldata _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] memory _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","after":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] calldata _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawExpiredStakings(uint256[] memory _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","after":"function withdrawExpiredStakings(uint256[] calldata _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] memory _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","after":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] calldata _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function burnDefaultedLoans(address[] memory _addressArray, uint256[] memory _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","after":"function burnDefaultedLoans(address[] calldata _addressArray, uint256[] calldata _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function giveLaunchReward(address[] memory _addresses, uint256[] memory _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","after":"function giveLaunchReward(address[] calldata _addresses, uint256[] calldata _exaEsAmountArray) public onlyOwner {\n        for(uint256 i = 0; i < _addresses.length; i++) {\n            launchReward[msg.sender] = launchReward[msg.sender].sub(_exaEsAmountArray[i]);\n            launchReward[_addresses[i]] = launchReward[_addresses[i]].add(_exaEsAmountArray[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] memory _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","after":"function withdrawBenefitOfAStakingByMonths(\n        uint256 _stakingId,\n        uint256[] calldata _months\n    ) public {\n        uint256 _benefitOfAllMonths;\n        for(uint256 i = 0; i < _months.length; i++) {\n            // require(\n            //   isStakingActive(msg.sender, _stakingId, _months[i])\n            //   && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]\n            //   // , 'staking must be active'\n            // );\n            if(isStakingActive(msg.sender, _stakingId, _months[i])\n            && !stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]]) {\n                uint256 _benefit = stakings[msg.sender][_stakingId].exaEsAmount\n                                  .mul(timeAllyMonthlyNRT[ _months[i] ])\n                                  .div(totalActiveStakings[ _months[i] ]);\n\n                _benefitOfAllMonths = _benefitOfAllMonths.add(_benefit);\n                stakings[msg.sender][_stakingId].isMonthClaimed[_months[i]] = true;\n            }\n        }\n\n        uint256 _luckPool = _benefitOfAllMonths\n                        .mul( uint256(15).sub(stakingPlans[stakings[msg.sender][_stakingId].stakingPlanId].fractionFrom15) )\n                        .div( 15 );\n\n        require( token.transfer(address(nrtManager), _luckPool) );\n        require( nrtManager.UpdateLuckpool(_luckPool) );\n\n        _benefitOfAllMonths = _benefitOfAllMonths.sub(_luckPool);\n\n        uint256 _halfBenefit = _benefitOfAllMonths.div(2);\n        require( token.transfer(msg.sender, _halfBenefit) );\n\n        launchReward[msg.sender] = launchReward[msg.sender].add(_halfBenefit);\n\n        // emit event\n        emit BenefitWithdrawl(msg.sender, _stakingId, _months, _halfBenefit);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function withdrawExpiredStakings(uint256[] memory _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","after":"function withdrawExpiredStakings(uint256[] calldata _stakingIds) public {\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n            require(now >= stakings[msg.sender][_stakingIds[i]].timestamp\n                    .add(stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth))\n              // , 'cannot withdraw before staking ends'\n            );\n            stakings[msg.sender][_stakingIds[i]].status = 3;\n\n            token.transfer(msg.sender, stakings[msg.sender][_stakingIds[i]].exaEsAmount);\n\n            emit PrincipalWithdrawl(msg.sender, _stakingIds[i]);\n        }\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] memory _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","after":"function takeLoanOnSelfStaking(uint256 _loanPlanId, uint256 _exaEsAmount, uint256[] calldata _stakingIds) public {\n        // @dev when loan is to be taken, first calculate active stakings from given stakings array. this way we can get how much loan user can take and simultaneously mark stakings as claimed for next months number loan period\n        uint256 _currentMonth = getCurrentMonth();\n        uint256 _userStakingsExaEsAmount;\n\n        for(uint256 i = 0; i < _stakingIds.length; i++) {\n\n            if( isStakingActive(msg.sender, _stakingIds[i], _currentMonth)\n                && (\n                  // @dev if urgent loan is not allowed then loan can be taken only after staking period is completed 75%\n                  stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].isUrgentLoanAllowed\n                  || now > stakings[msg.sender][_stakingIds[i]].timestamp + stakingPlans[ stakings[msg.sender][_stakingIds[i]].stakingPlanId ].months.mul(earthSecondsInMonth).mul(75).div(100)\n                )\n            ) {\n\n                // @dev store sum in a number\n                _userStakingsExaEsAmount = _userStakingsExaEsAmount\n                    .add(\n                        stakings[msg.sender][ _stakingIds[i] ].exaEsAmount\n                          .mul(loanPlans[_loanPlanId].maxLoanAmountPercent)\n                          .div(100)\n                );\n\n                // @dev subtract total active stakings\n                uint256 stakingStartMonth = stakings[msg.sender][_stakingIds[i]].stakingMonth;\n\n                uint256 stakeEndMonth = stakingStartMonth + stakingPlans[stakings[msg.sender][_stakingIds[i]].stakingPlanId].months;\n\n                for(uint256 j = _currentMonth + 1; j <= stakeEndMonth; j++) {\n                    totalActiveStakings[j] = totalActiveStakings[j].sub(_userStakingsExaEsAmount);\n                }\n\n                // @dev make stakings inactive\n                for(uint256 j = 1; j <= loanPlans[_loanPlanId].loanMonths; j++) {\n                    stakings[msg.sender][ _stakingIds[i] ].isMonthClaimed[ _currentMonth + j ] = true;\n                    stakings[msg.sender][ _stakingIds[i] ].status = 2; // means in loan\n                }\n            }\n        }\n\n        uint256 _maxLoaningAmount = _userStakingsExaEsAmount;\n\n        if(_exaEsAmount > _maxLoaningAmount) {\n            require(false\n              // , 'cannot loan more than maxLoaningAmount'\n            );\n        }\n\n\n        uint256 _loanInterest = _exaEsAmount.mul(loanPlans[_loanPlanId].loanRate).div(100);\n        uint256 _loanAmountToTransfer = _exaEsAmount.sub(_loanInterest);\n\n        require( token.transfer(address(nrtManager), _loanInterest) );\n        require( nrtManager.UpdateLuckpool(_loanInterest) );\n\n        loans[msg.sender].push(Loan({\n            exaEsAmount: _exaEsAmount,\n            timestamp: now,\n            loanPlanId: _loanPlanId,\n            status: 1,\n            stakingIds: _stakingIds\n        }));\n\n        // @dev send user amount\n        require( token.transfer(msg.sender, _loanAmountToTransfer) );\n\n        emit NewLoan(msg.sender, _loanPlanId, _exaEsAmount, _loanInterest, loans[msg.sender].length - 1);\n    }","contract":"TimeAlly","time":0},{"type":"external-function ","before":"function burnDefaultedLoans(address[] memory _addressArray, uint256[] memory _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","after":"function burnDefaultedLoans(address[] calldata _addressArray, uint256[] calldata _loanIdArray) public {\n        uint256 _amountToBurn;\n        for(uint256 i = 0; i < _addressArray.length; i++) {\n            require(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].status == 1\n                // , 'loan should not be repayed'\n            );\n            require(\n                now >\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].timestamp\n                + loanPlans[ loans[ _addressArray[i] ][ _loanIdArray[i] ].loanPlanId ].loanMonths.mul(earthSecondsInMonth)\n                // , 'loan should have crossed its loan period'\n            );\n            uint256[] storage _stakingIdsOfLoan = loans[ _addressArray[i] ][ _loanIdArray[i] ].stakingIds;\n\n            /// @dev add staking amounts of all stakings on which loan is taken\n            for(uint256 j = 0; j < _stakingIdsOfLoan.length; j++) {\n                _amountToBurn = _amountToBurn.add(\n                    stakings[ _addressArray[i] ][ _stakingIdsOfLoan[j] ].exaEsAmount\n                );\n            }\n            /// @dev sub loan amount\n            _amountToBurn = _amountToBurn.sub(\n                loans[ _addressArray[i] ][ _loanIdArray[i] ].exaEsAmount\n            );\n        }\n        require(token.transfer(address(nrtManager), _amountToBurn));\n        require(nrtManager.UpdateBurnBal(_amountToBurn));\n\n        // emit event\n    }","contract":"TimeAlly","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public earthSecondsInMonth = 2629744;","after":"uint256 public constant earthSecondsInMonth = 2629744;","contract":"TimeAlly","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public earthSecondsInMonth = 2629744;","after":"uint256 public constant earthSecondsInMonth = 2629744;","contract":"TimeAlly","time":0},{"type":"constant-restrict-modification  ","before":"uint256 public earthSecondsInMonth = 2629744;","after":"uint256 public constant earthSecondsInMonth = 2629744;","contract":"TimeAlly","time":0}]}