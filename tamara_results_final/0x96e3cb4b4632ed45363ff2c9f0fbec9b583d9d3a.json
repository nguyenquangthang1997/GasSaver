{"time":115,"results":[{"type":"external-function ","before":"function channelOpen(ChannelLibrary.Channel memory channel)\n\t\tpublic\n\t{\n\t\tbytes32 channelId = channel.hash();\n\t\trequire(states[channelId] == ChannelLibrary.State.Unknown, \"INVALID_STATE\");\n\t\trequire(msg.sender == channel.creator, \"INVALID_CREATOR\");\n\t\trequire(channel.isValid(now), \"INVALID_CHANNEL\");\n\t\t\n\t\tstates[channelId] = ChannelLibrary.State.Active;\n\n\t\tSafeERC20.transferFrom(channel.tokenAddr, msg.sender, address(this), channel.tokenAmount);\n\n\t\temit LogChannelOpen(channelId);\n\t}","after":"function channelOpen(ChannelLibrary.Channel calldata channel)\n\t\tpublic\n\t{\n\t\tbytes32 channelId = channel.hash();\n\t\trequire(states[channelId] == ChannelLibrary.State.Unknown, \"INVALID_STATE\");\n\t\trequire(msg.sender == channel.creator, \"INVALID_CREATOR\");\n\t\trequire(channel.isValid(now), \"INVALID_CHANNEL\");\n\t\t\n\t\tstates[channelId] = ChannelLibrary.State.Active;\n\n\t\tSafeERC20.transferFrom(channel.tokenAddr, msg.sender, address(this), channel.tokenAmount);\n\n\t\temit LogChannelOpen(channelId);\n\t}","contract":"AdExCore","time":0},{"type":"external-function ","before":"function channelWithdrawExpired(ChannelLibrary.Channel memory channel)\n\t\tpublic\n\t{\n\t\tbytes32 channelId = channel.hash();\n\t\trequire(states[channelId] == ChannelLibrary.State.Active, \"INVALID_STATE\");\n\t\trequire(now > channel.validUntil, \"NOT_EXPIRED\");\n\t\trequire(msg.sender == channel.creator, \"INVALID_CREATOR\");\n\t\t\n\t\tuint toWithdraw = channel.tokenAmount.sub(withdrawn[channelId]);\n\n\t\t// NOTE: we will not update withdrawn, since a WithdrawExpired does not count towards normal withdrawals\n\t\tstates[channelId] = ChannelLibrary.State.Expired;\n\t\t\n\t\tSafeERC20.transfer(channel.tokenAddr, msg.sender, toWithdraw);\n\n\t\temit LogChannelWithdrawExpired(channelId, toWithdraw);\n\t}","after":"function channelWithdrawExpired(ChannelLibrary.Channel calldata channel)\n\t\tpublic\n\t{\n\t\tbytes32 channelId = channel.hash();\n\t\trequire(states[channelId] == ChannelLibrary.State.Active, \"INVALID_STATE\");\n\t\trequire(now > channel.validUntil, \"NOT_EXPIRED\");\n\t\trequire(msg.sender == channel.creator, \"INVALID_CREATOR\");\n\t\t\n\t\tuint toWithdraw = channel.tokenAmount.sub(withdrawn[channelId]);\n\n\t\t// NOTE: we will not update withdrawn, since a WithdrawExpired does not count towards normal withdrawals\n\t\tstates[channelId] = ChannelLibrary.State.Expired;\n\t\t\n\t\tSafeERC20.transfer(channel.tokenAddr, msg.sender, toWithdraw);\n\n\t\temit LogChannelWithdrawExpired(channelId, toWithdraw);\n\t}","contract":"AdExCore","time":0},{"type":"external-function ","before":"function channelWithdraw(ChannelLibrary.Channel memory channel, bytes32 stateRoot, bytes32[3][] memory signatures, bytes32[] memory proof, uint amountInTree)\n\t\tpublic\n\t{\n\t\tbytes32 channelId = channel.hash();\n\t\trequire(states[channelId] == ChannelLibrary.State.Active, \"INVALID_STATE\");\n\t\trequire(now <= channel.validUntil, \"EXPIRED\");\n\n\t\tbytes32 hashToSign = keccak256(abi.encode(channelId, stateRoot));\n\t\trequire(channel.isSignedBySupermajority(hashToSign, signatures), \"NOT_SIGNED_BY_VALIDATORS\");\n\n\t\tbytes32 balanceLeaf = keccak256(abi.encode(msg.sender, amountInTree));\n\t\trequire(MerkleProof.isContained(balanceLeaf, proof, stateRoot), \"BALANCELEAF_NOT_FOUND\");\n\n\t\t// The user can withdraw their constantly increasing balance at any time (essentially prevent users from double spending)\n\t\tuint toWithdraw = amountInTree.sub(withdrawnPerUser[channelId][msg.sender]);\n\t\twithdrawnPerUser[channelId][msg.sender] = amountInTree;\n\n\t\t// Ensure that it's not possible to withdraw more than the channel deposit (e.g. malicious validators sign such a state)\n\t\twithdrawn[channelId] = withdrawn[channelId].add(toWithdraw);\n\t\trequire(withdrawn[channelId] <= channel.tokenAmount, \"WITHDRAWING_MORE_THAN_CHANNEL\");\n\n\t\tSafeERC20.transfer(channel.tokenAddr, msg.sender, toWithdraw);\n\n\t\temit LogChannelWithdraw(channelId, toWithdraw);\n\t}","after":"function channelWithdraw(ChannelLibrary.Channel calldata channel, bytes32 stateRoot, bytes32[3][] calldata signatures, bytes32[] calldata proof, uint amountInTree)\n\t\tpublic\n\t{\n\t\tbytes32 channelId = channel.hash();\n\t\trequire(states[channelId] == ChannelLibrary.State.Active, \"INVALID_STATE\");\n\t\trequire(now <= channel.validUntil, \"EXPIRED\");\n\n\t\tbytes32 hashToSign = keccak256(abi.encode(channelId, stateRoot));\n\t\trequire(channel.isSignedBySupermajority(hashToSign, signatures), \"NOT_SIGNED_BY_VALIDATORS\");\n\n\t\tbytes32 balanceLeaf = keccak256(abi.encode(msg.sender, amountInTree));\n\t\trequire(MerkleProof.isContained(balanceLeaf, proof, stateRoot), \"BALANCELEAF_NOT_FOUND\");\n\n\t\t// The user can withdraw their constantly increasing balance at any time (essentially prevent users from double spending)\n\t\tuint toWithdraw = amountInTree.sub(withdrawnPerUser[channelId][msg.sender]);\n\t\twithdrawnPerUser[channelId][msg.sender] = amountInTree;\n\n\t\t// Ensure that it's not possible to withdraw more than the channel deposit (e.g. malicious validators sign such a state)\n\t\twithdrawn[channelId] = withdrawn[channelId].add(toWithdraw);\n\t\trequire(withdrawn[channelId] <= channel.tokenAmount, \"WITHDRAWING_MORE_THAN_CHANNEL\");\n\n\t\tSafeERC20.transfer(channel.tokenAddr, msg.sender, toWithdraw);\n\n\t\temit LogChannelWithdraw(channelId, toWithdraw);\n\t}","contract":"AdExCore","time":0},{"type":"external-function ","before":"function channelOpen(address coreAddr, ChannelLibrary.Channel memory channel)\n\t\tpublic\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\tif (GeneralERC20(channel.tokenAddr).allowance(address(this), coreAddr) > 0) {\n\t\t\tSafeERC20.approve(channel.tokenAddr, coreAddr, 0);\n\t\t}\n\t\tSafeERC20.approve(channel.tokenAddr, coreAddr, channel.tokenAmount);\n\t\tAdExCore(coreAddr).channelOpen(channel);\n\t}","after":"function channelOpen(address coreAddr, ChannelLibrary.Channel calldata channel)\n\t\tpublic\n\t{\n\t\trequire(msg.sender == address(this), 'ONLY_IDENTITY_CAN_CALL');\n\t\tif (GeneralERC20(channel.tokenAddr).allowance(address(this), coreAddr) > 0) {\n\t\t\tSafeERC20.approve(channel.tokenAddr, coreAddr, 0);\n\t\t}\n\t\tSafeERC20.approve(channel.tokenAddr, coreAddr, channel.tokenAmount);\n\t\tAdExCore(coreAddr).channelOpen(channel);\n\t}","contract":"Identity","time":0},{"type":"external-function ","before":"function execute(Transaction[] memory txns, bytes32[3][] memory signatures)\n\t\tpublic\n\t{\n\t\trequire(txns.length > 0, 'MUST_PASS_TX');\n\t\taddress feeTokenAddr = txns[0].feeTokenAddr;\n\t\tuint feeAmount = 0;\n\t\tuint len = txns.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tTransaction memory txn = txns[i];\n\t\t\trequire(txn.identityContract == address(this), 'TRANSACTION_NOT_FOR_CONTRACT');\n\t\t\trequire(txn.feeTokenAddr == feeTokenAddr, 'EXECUTE_NEEDS_SINGLE_TOKEN');\n\t\t\trequire(txn.nonce == nonce, 'WRONG_NONCE');\n\n\t\t\t// If we use the naive abi.encode(txn) and have a field of type `bytes`,\n\t\t\t// there is a discrepancy between ethereumjs-abi and solidity\n\t\t\t// if we enter every field individually, in order, there is no discrepancy\n\t\t\t//bytes32 hash = keccak256(abi.encode(txn));\n\t\t\tbytes32 hash = keccak256(abi.encode(txn.identityContract, txn.nonce, txn.feeTokenAddr, txn.feeAmount, txn.to, txn.value, txn.data));\n\t\t\taddress signer = SignatureValidator.recoverAddr(hash, signatures[i]);\n\n\t\t\trequire(privileges[signer] >= uint8(PrivilegeLevel.Transactions), 'INSUFFICIENT_PRIVILEGE_TRANSACTION');\n\n\t\t\tnonce = nonce.add(1);\n\t\t\tfeeAmount = feeAmount.add(txn.feeAmount);\n\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\n\t\t\t// The actual anti-bricking mechanism - do not allow a signer to drop his own priviledges\n\t\t\trequire(privileges[signer] >= uint8(PrivilegeLevel.Transactions), 'PRIVILEGE_NOT_DOWNGRADED');\n\t\t}\n\t\tif (feeAmount > 0) {\n\t\t\tSafeERC20.transfer(feeTokenAddr, msg.sender, feeAmount);\n\t\t}\n\t}","after":"function execute(Transaction[] calldata txns, bytes32[3][] calldata signatures)\n\t\tpublic\n\t{\n\t\trequire(txns.length > 0, 'MUST_PASS_TX');\n\t\taddress feeTokenAddr = txns[0].feeTokenAddr;\n\t\tuint feeAmount = 0;\n\t\tuint len = txns.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tTransaction memory txn = txns[i];\n\t\t\trequire(txn.identityContract == address(this), 'TRANSACTION_NOT_FOR_CONTRACT');\n\t\t\trequire(txn.feeTokenAddr == feeTokenAddr, 'EXECUTE_NEEDS_SINGLE_TOKEN');\n\t\t\trequire(txn.nonce == nonce, 'WRONG_NONCE');\n\n\t\t\t// If we use the naive abi.encode(txn) and have a field of type `bytes`,\n\t\t\t// there is a discrepancy between ethereumjs-abi and solidity\n\t\t\t// if we enter every field individually, in order, there is no discrepancy\n\t\t\t//bytes32 hash = keccak256(abi.encode(txn));\n\t\t\tbytes32 hash = keccak256(abi.encode(txn.identityContract, txn.nonce, txn.feeTokenAddr, txn.feeAmount, txn.to, txn.value, txn.data));\n\t\t\taddress signer = SignatureValidator.recoverAddr(hash, signatures[i]);\n\n\t\t\trequire(privileges[signer] >= uint8(PrivilegeLevel.Transactions), 'INSUFFICIENT_PRIVILEGE_TRANSACTION');\n\n\t\t\tnonce = nonce.add(1);\n\t\t\tfeeAmount = feeAmount.add(txn.feeAmount);\n\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\n\t\t\t// The actual anti-bricking mechanism - do not allow a signer to drop his own priviledges\n\t\t\trequire(privileges[signer] >= uint8(PrivilegeLevel.Transactions), 'PRIVILEGE_NOT_DOWNGRADED');\n\t\t}\n\t\tif (feeAmount > 0) {\n\t\t\tSafeERC20.transfer(feeTokenAddr, msg.sender, feeAmount);\n\t\t}\n\t}","contract":"Identity","time":0},{"type":"external-function ","before":"function executeBySender(Transaction[] memory txns)\n\t\tpublic\n\t{\n\t\trequire(privileges[msg.sender] >= uint8(PrivilegeLevel.Transactions), 'INSUFFICIENT_PRIVILEGE_SENDER');\n\t\tuint len = txns.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tTransaction memory txn = txns[i];\n\t\t\trequire(txn.nonce == nonce, 'WRONG_NONCE');\n\n\t\t\tnonce = nonce.add(1);\n\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\n\t\t}\n\t\t// The actual anti-bricking mechanism - do not allow the sender to drop his own priviledges\n\t\trequire(privileges[msg.sender] >= uint8(PrivilegeLevel.Transactions), 'PRIVILEGE_NOT_DOWNGRADED');\n\t}","after":"function executeBySender(Transaction[] calldata txns)\n\t\tpublic\n\t{\n\t\trequire(privileges[msg.sender] >= uint8(PrivilegeLevel.Transactions), 'INSUFFICIENT_PRIVILEGE_SENDER');\n\t\tuint len = txns.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tTransaction memory txn = txns[i];\n\t\t\trequire(txn.nonce == nonce, 'WRONG_NONCE');\n\n\t\t\tnonce = nonce.add(1);\n\n\t\t\texecuteCall(txn.to, txn.value, txn.data);\n\t\t}\n\t\t// The actual anti-bricking mechanism - do not allow the sender to drop his own priviledges\n\t\trequire(privileges[msg.sender] >= uint8(PrivilegeLevel.Transactions), 'PRIVILEGE_NOT_DOWNGRADED');\n\t}","contract":"Identity","time":0},{"type":"external-function ","before":"function executeRoutines(RoutineAuthorization memory auth, RoutineOperation[] memory operations)\n\t\tpublic\n\t{\n\t\trequire(auth.validUntil >= now, 'AUTHORIZATION_EXPIRED');\n\t\tbytes32 hash = keccak256(abi.encode(auth));\n\t\trequire(routineAuthorizations[hash], 'NO_AUTHORIZATION');\n\t\tuint len = operations.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tRoutineOperation memory op = operations[i];\n\t\t\tif (op.mode == RoutineOp.ChannelWithdraw) {\n\t\t\t\t// Channel: Withdraw\n\t\t\t\texecuteCall(auth.outpace, 0, abi.encodePacked(CHANNEL_WITHDRAW_SELECTOR, op.data));\n\t\t\t} else if (op.mode == RoutineOp.ChannelWithdrawExpired) {\n\t\t\t\t// Channel: Withdraw Expired\n\t\t\t\texecuteCall(auth.outpace, 0, abi.encodePacked(CHANNEL_WITHDRAW_EXPIRED_SELECTOR, op.data));\n\t\t\t} else {\n\t\t\t\trevert('INVALID_MODE');\n\t\t\t}\n\t\t}\n\t\tif (auth.weeklyFeeAmount > 0 && (now - routinePaidFees[hash]) >= 7 days) {\n\t\t\troutinePaidFees[hash] = now;\n\t\t\tSafeERC20.transfer(auth.feeTokenAddr, auth.relayer, auth.weeklyFeeAmount);\n\t\t}\n\t}","after":"function executeRoutines(RoutineAuthorization calldata auth, RoutineOperation[] calldata operations)\n\t\tpublic\n\t{\n\t\trequire(auth.validUntil >= now, 'AUTHORIZATION_EXPIRED');\n\t\tbytes32 hash = keccak256(abi.encode(auth));\n\t\trequire(routineAuthorizations[hash], 'NO_AUTHORIZATION');\n\t\tuint len = operations.length;\n\t\tfor (uint i=0; i<len; i++) {\n\t\t\tRoutineOperation memory op = operations[i];\n\t\t\tif (op.mode == RoutineOp.ChannelWithdraw) {\n\t\t\t\t// Channel: Withdraw\n\t\t\t\texecuteCall(auth.outpace, 0, abi.encodePacked(CHANNEL_WITHDRAW_SELECTOR, op.data));\n\t\t\t} else if (op.mode == RoutineOp.ChannelWithdrawExpired) {\n\t\t\t\t// Channel: Withdraw Expired\n\t\t\t\texecuteCall(auth.outpace, 0, abi.encodePacked(CHANNEL_WITHDRAW_EXPIRED_SELECTOR, op.data));\n\t\t\t} else {\n\t\t\t\trevert('INVALID_MODE');\n\t\t\t}\n\t\t}\n\t\tif (auth.weeklyFeeAmount > 0 && (now - routinePaidFees[hash]) >= 7 days) {\n\t\t\troutinePaidFees[hash] = now;\n\t\t\tSafeERC20.transfer(auth.feeTokenAddr, auth.relayer, auth.weeklyFeeAmount);\n\t\t}\n\t}","contract":"Identity","time":0}]}