{"time":132,"results":[{"type":"state-data-arrangement ","before":"\nbytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\nbytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\nmapping (address => mapping(uint256 => uint256)) internal balances;\nmapping (address => mapping(address => bool)) internal operators;\nbytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\nbytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;","after":"mapping (address => mapping(uint256 => uint256)) internal balances;\nmapping (address => mapping(address => bool)) internal operators;\nbytes4 constant internal ERC1155_RECEIVED_VALUE = 0xf23a6e61;\nbytes4 constant internal ERC1155_BATCH_RECEIVED_VALUE = 0xbc197c81;\nbytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7;\nbytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26;\n","contract":"ERC1155","time":0},{"type":"external-function ","before":"function metaSafeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _id,\n    uint256 _amount,\n    bool _isGasFee,\n    bytes memory _data)\n    public\n  {\n    require(_to != address(0), \"ERC1155Meta#metaSafeTransferFrom: INVALID_RECIPIENT\");\n\n    // Starting gas amount\n    uint256 startGas = gasleft();\n    bytes memory transferData;\n    GasReceipt memory gasReceipt;\n\n    // Verify signature and extract the signed data\n    bytes memory signedData = _signatureValidation(\n      _from,\n      _data,\n      abi.encodePacked(META_TX_TYPEHASH, _from, _to, _id, _amount)\n    );\n\n    // If Gas is being reimbursed\n    if (_isGasFee) {\n      (gasReceipt, transferData) = abi.decode(signedData, (GasReceipt, bytes));\n      _safeTransferFrom(_from, _to, _id, _amount);\n\n      // Check if recipient is contract\n      if (_to.isContract()) {\n        // We need to somewhat protect operators against gas griefing attacks in recipient contract.\n        // Hence we only pass the gasLimit to the recipient such that the validator knows the griefing\n        // limit. Nothing can prevent the receiver to revert the transaction as close to the gasLimit as\n        // possible, but the operator can now only accept meta-transaction gasLimit within a certain range.\n        bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received.gas(gasReceipt.gasLimit)(msg.sender, _from, _id, _amount, transferData);\n        require(retval == ERC1155_RECEIVED_VALUE, \"ERC1155Meta#metaSafeTransferFrom: INVALID_ON_RECEIVE_MESSAGE\");\n      }\n\n      // Transfer gas cost\n      _transferGasFee(_from, startGas, gasReceipt);\n\n    } else {\n      _safeTransferFrom(_from, _to, _id, _amount);\n      _callonERC1155Received(_from, _to, _id, _amount, signedData);\n    }\n  }","after":"function metaSafeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _id,\n    uint256 _amount,\n    bool _isGasFee,\n    bytes calldata _data)\n    public\n  {\n    require(_to != address(0), \"ERC1155Meta#metaSafeTransferFrom: INVALID_RECIPIENT\");\n\n    // Starting gas amount\n    uint256 startGas = gasleft();\n    bytes memory transferData;\n    GasReceipt memory gasReceipt;\n\n    // Verify signature and extract the signed data\n    bytes memory signedData = _signatureValidation(\n      _from,\n      _data,\n      abi.encodePacked(META_TX_TYPEHASH, _from, _to, _id, _amount)\n    );\n\n    // If Gas is being reimbursed\n    if (_isGasFee) {\n      (gasReceipt, transferData) = abi.decode(signedData, (GasReceipt, bytes));\n      _safeTransferFrom(_from, _to, _id, _amount);\n\n      // Check if recipient is contract\n      if (_to.isContract()) {\n        // We need to somewhat protect operators against gas griefing attacks in recipient contract.\n        // Hence we only pass the gasLimit to the recipient such that the validator knows the griefing\n        // limit. Nothing can prevent the receiver to revert the transaction as close to the gasLimit as\n        // possible, but the operator can now only accept meta-transaction gasLimit within a certain range.\n        bytes4 retval = IERC1155TokenReceiver(_to).onERC1155Received.gas(gasReceipt.gasLimit)(msg.sender, _from, _id, _amount, transferData);\n        require(retval == ERC1155_RECEIVED_VALUE, \"ERC1155Meta#metaSafeTransferFrom: INVALID_ON_RECEIVE_MESSAGE\");\n      }\n\n      // Transfer gas cost\n      _transferGasFee(_from, startGas, gasReceipt);\n\n    } else {\n      _safeTransferFrom(_from, _to, _id, _amount);\n      _callonERC1155Received(_from, _to, _id, _amount, signedData);\n    }\n  }","contract":"ERC1155Meta","time":0},{"type":"external-function ","before":"function metaSafeBatchTransferFrom(\n    address _from,\n    address _to,\n    uint256[] memory _ids,\n    uint256[] memory _amounts,\n    bool _isGasFee,\n    bytes memory _data)\n    public\n  {\n    require(_to != address(0), \"ERC1155Meta#metaSafeBatchTransferFrom: INVALID_RECIPIENT\");\n\n    // Starting gas amount\n    uint256 startGas = gasleft();\n    bytes memory transferData;\n    GasReceipt memory gasReceipt;\n\n    // Verify signature and extract the signed data\n    bytes memory signedData = _signatureValidation(\n      _from,\n      _data,\n      abi.encodePacked(\n        META_BATCH_TX_TYPEHASH,\n        _from,\n        _to,\n        keccak256(abi.encodePacked(_ids)),\n        keccak256(abi.encodePacked(_amounts))\n      )\n    );\n\n    // If gas fee being reimbursed\n    if (_isGasFee) {\n      (gasReceipt, transferData) = abi.decode(signedData, (GasReceipt, bytes));\n\n      // Update balances\n      _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n\n            // Check if recipient is contract\n      if (_to.isContract()) {\n        // We need to somewhat protect operators against gas griefing attacks in recipient contract.\n        // Hence we only pass the gasLimit to the recipient such that the validator knows the griefing\n        // limit. Nothing can prevent the receiver to revert the transaction as close to the gasLimit as\n        // possible, but the operator can now only accept meta-transaction gasLimit within a certain range.\n        bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived.gas(gasReceipt.gasLimit)(msg.sender, _from, _ids, _amounts, transferData);\n        require(retval == ERC1155_BATCH_RECEIVED_VALUE, \"ERC1155Meta#metaSafeBatchTransferFrom: INVALID_ON_RECEIVE_MESSAGE\");\n      }\n\n      // Handle gas reimbursement\n      _transferGasFee(_from, startGas, gasReceipt);\n\n    } else {\n      _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n      _callonERC1155BatchReceived(_from, _to, _ids, _amounts, signedData);\n    }\n  }","after":"function metaSafeBatchTransferFrom(\n    address _from,\n    address _to,\n    uint256[] calldata _ids,\n    uint256[] calldata _amounts,\n    bool _isGasFee,\n    bytes calldata _data)\n    public\n  {\n    require(_to != address(0), \"ERC1155Meta#metaSafeBatchTransferFrom: INVALID_RECIPIENT\");\n\n    // Starting gas amount\n    uint256 startGas = gasleft();\n    bytes memory transferData;\n    GasReceipt memory gasReceipt;\n\n    // Verify signature and extract the signed data\n    bytes memory signedData = _signatureValidation(\n      _from,\n      _data,\n      abi.encodePacked(\n        META_BATCH_TX_TYPEHASH,\n        _from,\n        _to,\n        keccak256(abi.encodePacked(_ids)),\n        keccak256(abi.encodePacked(_amounts))\n      )\n    );\n\n    // If gas fee being reimbursed\n    if (_isGasFee) {\n      (gasReceipt, transferData) = abi.decode(signedData, (GasReceipt, bytes));\n\n      // Update balances\n      _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n\n            // Check if recipient is contract\n      if (_to.isContract()) {\n        // We need to somewhat protect operators against gas griefing attacks in recipient contract.\n        // Hence we only pass the gasLimit to the recipient such that the validator knows the griefing\n        // limit. Nothing can prevent the receiver to revert the transaction as close to the gasLimit as\n        // possible, but the operator can now only accept meta-transaction gasLimit within a certain range.\n        bytes4 retval = IERC1155TokenReceiver(_to).onERC1155BatchReceived.gas(gasReceipt.gasLimit)(msg.sender, _from, _ids, _amounts, transferData);\n        require(retval == ERC1155_BATCH_RECEIVED_VALUE, \"ERC1155Meta#metaSafeBatchTransferFrom: INVALID_ON_RECEIVE_MESSAGE\");\n      }\n\n      // Handle gas reimbursement\n      _transferGasFee(_from, startGas, gasReceipt);\n\n    } else {\n      _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n      _callonERC1155BatchReceived(_from, _to, _ids, _amounts, signedData);\n    }\n  }","contract":"ERC1155Meta","time":0},{"type":"external-function ","before":"function metaSetApprovalForAll(\n    address _owner,\n    address _operator,\n    bool _approved,\n    bool _isGasFee,\n    bytes memory _data)\n    public\n  {\n    // Starting gas amount\n    uint256 startGas = gasleft();\n\n    // Verify signature and extract the signed data\n    bytes memory signedData = _signatureValidation(\n      _owner,\n      _data,\n      abi.encodePacked(META_APPROVAL_TYPEHASH, _owner, _operator, _approved)\n    );\n\n    // Update operator status\n    operators[_owner][_operator] = _approved;\n\n    // Emit event\n    emit ApprovalForAll(_owner, _operator, _approved);\n\n    // Handle gas reimbursement\n    if (_isGasFee) {\n      GasReceipt memory gasReceipt = abi.decode(signedData, (GasReceipt));\n      _transferGasFee(_owner, startGas, gasReceipt);\n    }\n  }","after":"function metaSetApprovalForAll(\n    address _owner,\n    address _operator,\n    bool _approved,\n    bool _isGasFee,\n    bytes calldata _data)\n    public\n  {\n    // Starting gas amount\n    uint256 startGas = gasleft();\n\n    // Verify signature and extract the signed data\n    bytes memory signedData = _signatureValidation(\n      _owner,\n      _data,\n      abi.encodePacked(META_APPROVAL_TYPEHASH, _owner, _operator, _approved)\n    );\n\n    // Update operator status\n    operators[_owner][_operator] = _approved;\n\n    // Emit event\n    emit ApprovalForAll(_owner, _operator, _approved);\n\n    // Handle gas reimbursement\n    if (_isGasFee) {\n      GasReceipt memory gasReceipt = abi.decode(signedData, (GasReceipt));\n      _transferGasFee(_owner, startGas, gasReceipt);\n    }\n  }","contract":"ERC1155Meta","time":0},{"type":"external-function ","before":"function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes memory _data)\n    public\n  {\n    require((msg.sender == _from) || operators[_from][msg.sender], \"ERC1155#safeTransferFrom: INVALID_OPERATOR\");\n    require(_to != address(0),\"ERC1155#safeTransferFrom: INVALID_RECIPIENT\");\n    // require(_amount >= balances[_from][_id]) is not necessary since checked with safemath operations\n\n    _safeTransferFrom(_from, _to, _id, _amount);\n    _callonERC1155Received(_from, _to, _id, _amount, _data);\n  }","after":"function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _amount, bytes calldata _data)\n    public\n  {\n    require((msg.sender == _from) || operators[_from][msg.sender], \"ERC1155#safeTransferFrom: INVALID_OPERATOR\");\n    require(_to != address(0),\"ERC1155#safeTransferFrom: INVALID_RECIPIENT\");\n    // require(_amount >= balances[_from][_id]) is not necessary since checked with safemath operations\n\n    _safeTransferFrom(_from, _to, _id, _amount);\n    _callonERC1155Received(_from, _to, _id, _amount, _data);\n  }","contract":"ERC1155Meta","time":0},{"type":"external-function ","before":"function safeBatchTransferFrom(address _from, address _to, uint256[] memory _ids, uint256[] memory _amounts, bytes memory _data)\n    public\n  {\n    // Requirements\n    require((msg.sender == _from) || operators[_from][msg.sender], \"ERC1155#safeBatchTransferFrom: INVALID_OPERATOR\");\n    require(_to != address(0), \"ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT\");\n\n    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n    _callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\n  }","after":"function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _amounts, bytes calldata _data)\n    public\n  {\n    // Requirements\n    require((msg.sender == _from) || operators[_from][msg.sender], \"ERC1155#safeBatchTransferFrom: INVALID_OPERATOR\");\n    require(_to != address(0), \"ERC1155#safeBatchTransferFrom: INVALID_RECIPIENT\");\n\n    _safeBatchTransferFrom(_from, _to, _ids, _amounts);\n    _callonERC1155BatchReceived(_from, _to, _ids, _amounts, _data);\n  }","contract":"ERC1155Meta","time":0}]}