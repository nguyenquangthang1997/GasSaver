{"time":34,"results":[{"type":"external-function ","before":"function receiveApproval(address _sender, uint256 _value, address _tokenContract, bytes memory _extraData) public {\n        require(_value > 0, \"Error: Value must be > 0\");\n\n        // Once approved, transferFrom users wallet to ours. Calculate prior balance, and new balance to account for deflationary tokens.\n        uint _oldBalance = ERC20Interface(_tokenContract).balanceOf(address(this));\n        require(ERC20Interface(_tokenContract).transferFrom(_sender, address(this), _value), \"Could not transfer tokens to Time Lock contract address.\");\n        uint _newBalance = ERC20Interface(_tokenContract).balanceOf(address(this));\n        uint _balanceDiff = _newBalance.sub(_oldBalance); \n        uint _tokenAmount = _balanceDiff; //_balanceDiff; \n        \n        uint _freezeDuration = defaultFreezeDuration;\n        uint _freezeIndex = deposits[_sender].length;\n\n        if(deposits[_sender].length < 1) deposits[_sender];\n        \n        Deposit memory deposit;\n        deposit.tokenAddress = _tokenContract;\n        deposit.depositTime = now;\n        deposit.tokenAmount = _tokenAmount;\n        deposit.freezeDuration = _freezeDuration;\n        deposits[_sender].push(deposit);\n        \n        tokensFrozen[_tokenContract] += _tokenAmount; // Update global stats for token.\n\n        emit TokensFrozen(_sender, _tokenContract, _freezeIndex, now, _tokenAmount, _freezeDuration);\n    }","after":"function receiveApproval(address _sender, uint256 _value, address _tokenContract, bytes calldata _extraData) public {\n        require(_value > 0, \"Error: Value must be > 0\");\n\n        // Once approved, transferFrom users wallet to ours. Calculate prior balance, and new balance to account for deflationary tokens.\n        uint _oldBalance = ERC20Interface(_tokenContract).balanceOf(address(this));\n        require(ERC20Interface(_tokenContract).transferFrom(_sender, address(this), _value), \"Could not transfer tokens to Time Lock contract address.\");\n        uint _newBalance = ERC20Interface(_tokenContract).balanceOf(address(this));\n        uint _balanceDiff = _newBalance.sub(_oldBalance); \n        uint _tokenAmount = _balanceDiff; //_balanceDiff; \n        \n        uint _freezeDuration = defaultFreezeDuration;\n        uint _freezeIndex = deposits[_sender].length;\n\n        if(deposits[_sender].length < 1) deposits[_sender];\n        \n        Deposit memory deposit;\n        deposit.tokenAddress = _tokenContract;\n        deposit.depositTime = now;\n        deposit.tokenAmount = _tokenAmount;\n        deposit.freezeDuration = _freezeDuration;\n        deposits[_sender].push(deposit);\n        \n        tokensFrozen[_tokenContract] += _tokenAmount; // Update global stats for token.\n\n        emit TokensFrozen(_sender, _tokenContract, _freezeIndex, now, _tokenAmount, _freezeDuration);\n    }","contract":"TimeLock","time":0},{"type":"constant-restrict-modification  ","before":"uint defaultFreezeDuration = 5 minutes;","after":"uint constant defaultFreezeDuration = 5 minutes;","contract":"TimeLock","time":0}]}