{"time":328,"results":[{"type":"external-function ","before":"function validateTrades(\n        uint256[] memory _values,\n        bytes32[] memory _hashes,\n        address[] memory _addresses,\n        address _operator\n    )\n        public\n        returns (bytes32[] memory)\n    {\n        _validateTradeInputLengths(_values, _hashes);\n        _validateUniqueOffers(_values);\n        _validateMatches(_values, _addresses);\n        _validateFillAmounts(_values);\n        _validateTradeData(_values, _addresses, _operator);\n\n        // validate signatures of all offers\n        _validateTradeSignatures(\n            _values,\n            _hashes,\n            _addresses,\n            OFFER_TYPEHASH,\n            0,\n            _values[0] & mask8 // numOffers\n        );\n\n        // validate signatures of all fills\n        _validateTradeSignatures(\n            _values,\n            _hashes,\n            _addresses,\n            FILL_TYPEHASH,\n            _values[0] & mask8, // numOffers\n            (_values[0] & mask8) + ((_values[0] & mask16) >> 8) // numOffers + numFills\n        );\n\n        _emitTradeEvents(_values, _addresses, new address[](0), false);\n\n        return _hashes;\n    }","after":"function validateTrades(\n        uint256[] calldata _values,\n        bytes32[] calldata _hashes,\n        address[] calldata _addresses,\n        address _operator\n    )\n        public\n        returns (bytes32[] memory)\n    {\n        _validateTradeInputLengths(_values, _hashes);\n        _validateUniqueOffers(_values);\n        _validateMatches(_values, _addresses);\n        _validateFillAmounts(_values);\n        _validateTradeData(_values, _addresses, _operator);\n\n        // validate signatures of all offers\n        _validateTradeSignatures(\n            _values,\n            _hashes,\n            _addresses,\n            OFFER_TYPEHASH,\n            0,\n            _values[0] & mask8 // numOffers\n        );\n\n        // validate signatures of all fills\n        _validateTradeSignatures(\n            _values,\n            _hashes,\n            _addresses,\n            FILL_TYPEHASH,\n            _values[0] & mask8, // numOffers\n            (_values[0] & mask8) + ((_values[0] & mask16) >> 8) // numOffers + numFills\n        );\n\n        _emitTradeEvents(_values, _addresses, new address[](0), false);\n\n        return _hashes;\n    }","contract":"Utils","time":0},{"type":"external-function ","before":"function performNetworkTrades(\n        uint256[] memory _values,\n        address[] memory _addresses,\n        address[] memory _marketDapps\n    )\n        public\n        returns (uint256[] memory)\n    {\n        uint256[] memory increments = new uint256[](_addresses.length / 2);\n        // i = 1 + numOffers * 2\n        uint256 i = 1 + (_values[0] & mask8) * 2;\n        uint256 end = _values.length;\n\n        // loop matches\n        for(i; i < end; i++) {\n            uint256[] memory data = new uint256[](9);\n            data[0] = _values[i]; // match data\n            data[1] = data[0] & mask8; // offerIndex\n            data[2] = (data[0] & mask24) >> 16; // operator.surplusAssetIndex\n            data[3] = _values[data[1] * 2 + 1]; // offer.dataA\n            data[4] = _values[data[1] * 2 + 2]; // offer.dataB\n            data[5] = ((data[3] & mask16) >> 8); // maker.offerAssetIndex\n            data[6] = ((data[3] & mask24) >> 16); // maker.wantAssetIndex\n            // amount of offerAssetId to take from the offer is equal to the match.takeAmount\n            data[7] = data[0] >> 128;\n            // expected amount to receive is: matchData.takeAmount * offer.wantAmount / offer.offerAmount\n            data[8] = data[7].mul(data[4] >> 128).div(data[4] & mask128);\n\n            address[] memory assetIds = new address[](3);\n            assetIds[0] = _addresses[data[5] * 2 + 1]; // offer.offerAssetId\n            assetIds[1] = _addresses[data[6] * 2 + 1]; // offer.wantAssetId\n            assetIds[2] = _addresses[data[2] * 2 + 1]; // surplusAssetId\n\n            uint256[] memory dataValues = new uint256[](3);\n            dataValues[0] = data[7]; // the proportion of offerAmount to offer\n            dataValues[1] = data[8]; // the proportion of wantAmount to receive for the offer\n            dataValues[2] = data[0]; // match data\n\n            increments[data[2]] = _performNetworkTrade(\n                assetIds,\n                dataValues,\n                _marketDapps,\n                _addresses\n            );\n        }\n\n        _emitTradeEvents(_values, _addresses, _marketDapps, true);\n\n        return increments;\n    }","after":"function performNetworkTrades(\n        uint256[] calldata _values,\n        address[] calldata _addresses,\n        address[] calldata _marketDapps\n    )\n        public\n        returns (uint256[] memory)\n    {\n        uint256[] memory increments = new uint256[](_addresses.length / 2);\n        // i = 1 + numOffers * 2\n        uint256 i = 1 + (_values[0] & mask8) * 2;\n        uint256 end = _values.length;\n\n        // loop matches\n        for(i; i < end; i++) {\n            uint256[] memory data = new uint256[](9);\n            data[0] = _values[i]; // match data\n            data[1] = data[0] & mask8; // offerIndex\n            data[2] = (data[0] & mask24) >> 16; // operator.surplusAssetIndex\n            data[3] = _values[data[1] * 2 + 1]; // offer.dataA\n            data[4] = _values[data[1] * 2 + 2]; // offer.dataB\n            data[5] = ((data[3] & mask16) >> 8); // maker.offerAssetIndex\n            data[6] = ((data[3] & mask24) >> 16); // maker.wantAssetIndex\n            // amount of offerAssetId to take from the offer is equal to the match.takeAmount\n            data[7] = data[0] >> 128;\n            // expected amount to receive is: matchData.takeAmount * offer.wantAmount / offer.offerAmount\n            data[8] = data[7].mul(data[4] >> 128).div(data[4] & mask128);\n\n            address[] memory assetIds = new address[](3);\n            assetIds[0] = _addresses[data[5] * 2 + 1]; // offer.offerAssetId\n            assetIds[1] = _addresses[data[6] * 2 + 1]; // offer.wantAssetId\n            assetIds[2] = _addresses[data[2] * 2 + 1]; // surplusAssetId\n\n            uint256[] memory dataValues = new uint256[](3);\n            dataValues[0] = data[7]; // the proportion of offerAmount to offer\n            dataValues[1] = data[8]; // the proportion of wantAmount to receive for the offer\n            dataValues[2] = data[0]; // match data\n\n            increments[data[2]] = _performNetworkTrade(\n                assetIds,\n                dataValues,\n                _marketDapps,\n                _addresses\n            );\n        }\n\n        _emitTradeEvents(_values, _addresses, _marketDapps, true);\n\n        return increments;\n    }","contract":"Utils","time":0},{"type":"external-function ","before":"function trade(\n        address[] memory _assetIds,\n        uint256[] memory _dataValues,\n        address[] memory /* _addresses */,\n        address payable _recipient\n    )\n        public\n        payable\n        nonReentrant\n    {\n        // _dataValues[2] bits(24..56): delay\n        uint256 deadline = now.add((_dataValues[2] & ~(~uint256(0) << 56)) >> 24);\n\n        if (_assetIds[0] == ETHER_ADDR) {\n            UniswapExchange exchange = UniswapExchange(factory.getExchange(_assetIds[1]));\n            exchange.ethToTokenTransferInput.value(_dataValues[0])(\n                _dataValues[1],\n                deadline,\n                _recipient\n            );\n            return;\n        }\n\n        UniswapExchange exchange = UniswapExchange(factory.getExchange(_assetIds[0]));\n\n        Utils.transferTokensIn(msg.sender, _assetIds[0], _dataValues[0], _dataValues[0]);\n        Utils.approveTokenTransfer(\n            _assetIds[0],\n            address(exchange),\n            _dataValues[0]\n        );\n\n        if (_assetIds[1] == ETHER_ADDR) {\n            exchange.tokenToEthTransferInput(\n                _dataValues[0],\n                _dataValues[1],\n                deadline,\n                _recipient\n            );\n            return;\n        }\n\n        // Use the minimum of 1 for minEth as the amount of intermediate eth\n        // used for the trade is not important. It is only important that the\n        // final received tokens is more than or equal to the wantAmount.\n        exchange.tokenToTokenTransferInput(\n            _dataValues[0],\n            _dataValues[1],\n            1,\n            deadline,\n            _recipient,\n            _assetIds[1]\n        );\n    }","after":"function trade(\n        address[] calldata _assetIds,\n        uint256[] calldata _dataValues,\n        address[] calldata /* _addresses */,\n        address payable _recipient\n    )\n        public\n        payable\n        nonReentrant\n    {\n        // _dataValues[2] bits(24..56): delay\n        uint256 deadline = now.add((_dataValues[2] & ~(~uint256(0) << 56)) >> 24);\n\n        if (_assetIds[0] == ETHER_ADDR) {\n            UniswapExchange exchange = UniswapExchange(factory.getExchange(_assetIds[1]));\n            exchange.ethToTokenTransferInput.value(_dataValues[0])(\n                _dataValues[1],\n                deadline,\n                _recipient\n            );\n            return;\n        }\n\n        UniswapExchange exchange = UniswapExchange(factory.getExchange(_assetIds[0]));\n\n        Utils.transferTokensIn(msg.sender, _assetIds[0], _dataValues[0], _dataValues[0]);\n        Utils.approveTokenTransfer(\n            _assetIds[0],\n            address(exchange),\n            _dataValues[0]\n        );\n\n        if (_assetIds[1] == ETHER_ADDR) {\n            exchange.tokenToEthTransferInput(\n                _dataValues[0],\n                _dataValues[1],\n                deadline,\n                _recipient\n            );\n            return;\n        }\n\n        // Use the minimum of 1 for minEth as the amount of intermediate eth\n        // used for the trade is not important. It is only important that the\n        // final received tokens is more than or equal to the wantAmount.\n        exchange.tokenToTokenTransferInput(\n            _dataValues[0],\n            _dataValues[1],\n            1,\n            deadline,\n            _recipient,\n            _assetIds[1]\n        );\n    }","contract":"UniswapDapp","time":0}]}