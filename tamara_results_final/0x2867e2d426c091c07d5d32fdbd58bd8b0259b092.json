{"time":319,"results":[{"type":"struct-data-arrangement ","before":"\naddress payable[] issuers\naddress[] approvers\nuint deadline\naddress token\nuint tokenVersion\nuint balance\nbool hasPaidOut\nFulfillment[] fulfillments\nContribution[] contributions","after":"address payable[] issuers\naddress[] approvers\nuint deadline\nuint tokenVersion\nuint balance\nFulfillment[] fulfillments\nContribution[] contributions\naddress token\nbool hasPaidOut\n","contract":"StandardBounties","time":0},{"type":"struct-data-arrangement ","before":"\naddress payable contributor\nuint amount\nbool refunded","after":"uint amount\naddress payable contributor\nbool refunded\n","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function issueAndContribute(\n    address payable _sender,\n    address payable[] memory _issuers,\n    address[] memory _approvers,\n    string memory _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _depositAmount)\n    public\n    payable\n    returns(uint)\n  {\n    uint bountyId = issueBounty(_sender, _issuers, _approvers, _data, _deadline, _token, _tokenVersion);\n\n    contribute(_sender, bountyId, _depositAmount);\n\n    return (bountyId);\n  }","after":"function issueAndContribute(\n    address payable _sender,\n    address payable[] calldata _issuers,\n    address[] calldata _approvers,\n    string calldata _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _depositAmount)\n    public\n    payable\n    returns(uint)\n  {\n    uint bountyId = issueBounty(_sender, _issuers, _approvers, _data, _deadline, _token, _tokenVersion);\n\n    contribute(_sender, bountyId, _depositAmount);\n\n    return (bountyId);\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function refundMyContributions(\n    address _sender,\n    uint _bountyId,\n    uint[] memory _contributionIds)\n    public\n    senderIsValid(_sender)\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n        refundContribution(_sender, _bountyId, _contributionIds[i]);\n    }\n  }","after":"function refundMyContributions(\n    address _sender,\n    uint _bountyId,\n    uint[] calldata _contributionIds)\n    public\n    senderIsValid(_sender)\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n        refundContribution(_sender, _bountyId, _contributionIds[i]);\n    }\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function refundContributions(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] memory _contributionIds)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n      require(_contributionIds[i] < bounties[_bountyId].contributions.length);\n\n      Contribution storage contribution = bounties[_bountyId].contributions[_contributionIds[i]];\n\n      require(!contribution.refunded);\n\n      contribution.refunded = true;\n\n      transferTokens(_bountyId, contribution.contributor, contribution.amount); // Performs the disbursal of tokens to the contributor\n    }\n\n    emit ContributionsRefunded(_bountyId, _sender, _contributionIds);\n  }","after":"function refundContributions(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] calldata _contributionIds)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n      require(_contributionIds[i] < bounties[_bountyId].contributions.length);\n\n      Contribution storage contribution = bounties[_bountyId].contributions[_contributionIds[i]];\n\n      require(!contribution.refunded);\n\n      contribution.refunded = true;\n\n      transferTokens(_bountyId, contribution.contributor, contribution.amount); // Performs the disbursal of tokens to the contributor\n    }\n\n    emit ContributionsRefunded(_bountyId, _sender, _contributionIds);\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function drainBounty(\n    address payable _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] memory _amounts)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    if (bounties[_bountyId].tokenVersion == 0 || bounties[_bountyId].tokenVersion == 20){\n      require(_amounts.length == 1); // ensures there's only 1 amount of tokens to be returned\n      require(_amounts[0] <= bounties[_bountyId].balance); // ensures an issuer doesn't try to drain the bounty of more tokens than their balance permits\n      transferTokens(_bountyId, _sender, _amounts[0]); // Performs the draining of tokens to the issuer\n    } else {\n      for (uint i = 0; i < _amounts.length; i++){\n        require(tokenBalances[_bountyId][_amounts[i]]);// ensures an issuer doesn't try to drain the bounty of a token it doesn't have in its balance\n        transferTokens(_bountyId, _sender, _amounts[i]);\n      }\n    }\n\n    emit BountyDrained(_bountyId, _sender, _amounts);\n  }","after":"function drainBounty(\n    address payable _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] calldata _amounts)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    if (bounties[_bountyId].tokenVersion == 0 || bounties[_bountyId].tokenVersion == 20){\n      require(_amounts.length == 1); // ensures there's only 1 amount of tokens to be returned\n      require(_amounts[0] <= bounties[_bountyId].balance); // ensures an issuer doesn't try to drain the bounty of more tokens than their balance permits\n      transferTokens(_bountyId, _sender, _amounts[0]); // Performs the draining of tokens to the issuer\n    } else {\n      for (uint i = 0; i < _amounts.length; i++){\n        require(tokenBalances[_bountyId][_amounts[i]]);// ensures an issuer doesn't try to drain the bounty of a token it doesn't have in its balance\n        transferTokens(_bountyId, _sender, _amounts[i]);\n      }\n    }\n\n    emit BountyDrained(_bountyId, _sender, _amounts);\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function performAction(\n    address _sender,\n    uint _bountyId,\n    string memory _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n  {\n    emit ActionPerformed(_bountyId, _sender, _data); // The _data string is emitted in an event for easy off-chain consumption\n  }","after":"function performAction(\n    address _sender,\n    uint _bountyId,\n    string calldata _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n  {\n    emit ActionPerformed(_bountyId, _sender, _data); // The _data string is emitted in an event for easy off-chain consumption\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function updateFulfillment(\n  address _sender,\n  uint _bountyId,\n  uint _fulfillmentId,\n  address payable[] memory _fulfillers,\n  string memory _data)\n  public\n  senderIsValid(_sender)\n  validateBountyArrayIndex(_bountyId)\n  validateFulfillmentArrayIndex(_bountyId, _fulfillmentId)\n  onlySubmitter(_sender, _bountyId, _fulfillmentId) // Only the original submitter of a fulfillment may update their submission\n  {\n    bounties[_bountyId].fulfillments[_fulfillmentId].fulfillers = _fulfillers;\n    emit FulfillmentUpdated(_bountyId,\n                            _fulfillmentId,\n                            _fulfillers,\n                            _data); // The _data string is emitted in an event for easy off-chain consumption\n  }","after":"function updateFulfillment(\n  address _sender,\n  uint _bountyId,\n  uint _fulfillmentId,\n  address payable[] calldata _fulfillers,\n  string calldata _data)\n  public\n  senderIsValid(_sender)\n  validateBountyArrayIndex(_bountyId)\n  validateFulfillmentArrayIndex(_bountyId, _fulfillmentId)\n  onlySubmitter(_sender, _bountyId, _fulfillmentId) // Only the original submitter of a fulfillment may update their submission\n  {\n    bounties[_bountyId].fulfillments[_fulfillmentId].fulfillers = _fulfillers;\n    emit FulfillmentUpdated(_bountyId,\n                            _fulfillmentId,\n                            _fulfillers,\n                            _data); // The _data string is emitted in an event for easy off-chain consumption\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function fulfillAndAccept(\n    address _sender,\n    uint _bountyId,\n    address payable[] memory _fulfillers,\n    string memory _data,\n    uint _approverId,\n    uint[] memory _tokenAmounts)\n    public\n    senderIsValid(_sender)\n  {\n    // first fulfills the bounty on behalf of the fulfillers\n    fulfillBounty(_sender, _bountyId, _fulfillers, _data);\n\n    // then accepts the fulfillment\n    acceptFulfillment(_sender,\n                      _bountyId,\n                      bounties[_bountyId].fulfillments.length - 1,\n                      _approverId,\n                      _tokenAmounts);\n  }","after":"function fulfillAndAccept(\n    address _sender,\n    uint _bountyId,\n    address payable[] calldata _fulfillers,\n    string calldata _data,\n    uint _approverId,\n    uint[] calldata _tokenAmounts)\n    public\n    senderIsValid(_sender)\n  {\n    // first fulfills the bounty on behalf of the fulfillers\n    fulfillBounty(_sender, _bountyId, _fulfillers, _data);\n\n    // then accepts the fulfillment\n    acceptFulfillment(_sender,\n                      _bountyId,\n                      bounties[_bountyId].fulfillments.length - 1,\n                      _approverId,\n                      _tokenAmounts);\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function changeBounty(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers,\n    address payable[] memory _approvers,\n    string memory _data,\n    uint _deadline)\n    public\n    senderIsValid(_sender)\n  {\n    require(_bountyId < numBounties); // makes the validateBountyArrayIndex modifier in-line to avoid stack too deep errors\n    require(_issuerId < bounties[_bountyId].issuers.length); // makes the validateIssuerArrayIndex modifier in-line to avoid stack too deep errors\n    require(_sender == bounties[_bountyId].issuers[_issuerId]); // makes the onlyIssuer modifier in-line to avoid stack too deep errors\n\n    require(_issuers.length > 0 || _approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n\n    bounties[_bountyId].issuers = _issuers;\n    bounties[_bountyId].approvers = _approvers;\n    bounties[_bountyId].deadline = _deadline;\n    emit BountyChanged(_bountyId,\n                       _sender,\n                       _issuers,\n                       _approvers,\n                       _data,\n                       _deadline);\n  }","after":"function changeBounty(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers,\n    address payable[] calldata _approvers,\n    string calldata _data,\n    uint _deadline)\n    public\n    senderIsValid(_sender)\n  {\n    require(_bountyId < numBounties); // makes the validateBountyArrayIndex modifier in-line to avoid stack too deep errors\n    require(_issuerId < bounties[_bountyId].issuers.length); // makes the validateIssuerArrayIndex modifier in-line to avoid stack too deep errors\n    require(_sender == bounties[_bountyId].issuers[_issuerId]); // makes the onlyIssuer modifier in-line to avoid stack too deep errors\n\n    require(_issuers.length > 0 || _approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n\n    bounties[_bountyId].issuers = _issuers;\n    bounties[_bountyId].approvers = _approvers;\n    bounties[_bountyId].deadline = _deadline;\n    emit BountyChanged(_bountyId,\n                       _sender,\n                       _issuers,\n                       _approvers,\n                       _data,\n                       _deadline);\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function changeData(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    string memory _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    emit BountyDataChanged(_bountyId, _sender, _data); // The new _data is emitted within an event rather than being stored on-chain for minimized gas costs\n  }","after":"function changeData(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    string calldata _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    emit BountyDataChanged(_bountyId, _sender, _data); // The new _data is emitted within an event rather than being stored on-chain for minimized gas costs\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function addIssuers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _issuers.length; i++){\n      bounties[_bountyId].issuers.push(_issuers[i]);\n    }\n\n    emit BountyIssuersUpdated(_bountyId, _sender, bounties[_bountyId].issuers);\n  }","after":"function addIssuers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _issuers.length; i++){\n      bounties[_bountyId].issuers.push(_issuers[i]);\n    }\n\n    emit BountyIssuersUpdated(_bountyId, _sender, bounties[_bountyId].issuers);\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function addApprovers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address[] memory _approvers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _approvers.length; i++){\n      bounties[_bountyId].approvers.push(_approvers[i]);\n    }\n\n    emit BountyApproversUpdated(_bountyId, _sender, bounties[_bountyId].approvers);\n  }","after":"function addApprovers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address[] calldata _approvers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _approvers.length; i++){\n      bounties[_bountyId].approvers.push(_approvers[i]);\n    }\n\n    emit BountyApproversUpdated(_bountyId, _sender, bounties[_bountyId].approvers);\n  }","contract":"StandardBounties","time":0},{"type":"external-function ","before":"function metaIssueBounty(\n    bytes memory signature,\n    address payable[] memory _issuers,\n    address[] memory _approvers,\n    string memory _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _nonce)\n    public\n    returns (uint)\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaIssueBounty\",\n                                                  _issuers,\n                                                  _approvers,\n                                                  _data,\n                                                  _deadline,\n                                                  _token,\n                                                  _tokenVersion,\n                                                  _nonce));\n    address signer = getSigner(metaHash, signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n    return bountiesContract.issueBounty(address(uint160(signer)),\n                                         _issuers,\n                                         _approvers,\n                                         _data,\n                                         _deadline,\n                                         _token,\n                                         _tokenVersion);\n  }","after":"function metaIssueBounty(\n    bytes calldata signature,\n    address payable[] calldata _issuers,\n    address[] calldata _approvers,\n    string calldata _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _nonce)\n    public\n    returns (uint)\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaIssueBounty\",\n                                                  _issuers,\n                                                  _approvers,\n                                                  _data,\n                                                  _deadline,\n                                                  _token,\n                                                  _tokenVersion,\n                                                  _nonce));\n    address signer = getSigner(metaHash, signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n    return bountiesContract.issueBounty(address(uint160(signer)),\n                                         _issuers,\n                                         _approvers,\n                                         _data,\n                                         _deadline,\n                                         _token,\n                                         _tokenVersion);\n  }","contract":"BountiesMetaTxRelayer","time":1},{"type":"external-function ","before":"function metaIssueAndContribute(\n    bytes memory signature,\n    address payable[] memory _issuers,\n    address[] memory _approvers,\n    string memory _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _depositAmount,\n    uint _nonce)\n    public\n    payable\n    returns (uint)\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaIssueAndContribute\",\n                                                  _issuers,\n                                                  _approvers,\n                                                  _data,\n                                                  _deadline,\n                                                  _token,\n                                                  _tokenVersion,\n                                                  _depositAmount,\n                                                  _nonce));\n    address signer = getSigner(metaHash, signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    if (msg.value > 0){\n      return bountiesContract.issueAndContribute.value(msg.value)(address(uint160(signer)),\n                                                 _issuers,\n                                                 _approvers,\n                                                 _data,\n                                                 _deadline,\n                                                 _token,\n                                                 _tokenVersion,\n                                                 _depositAmount);\n    } else {\n      return bountiesContract.issueAndContribute(address(uint160(signer)),\n                                                 _issuers,\n                                                 _approvers,\n                                                 _data,\n                                                 _deadline,\n                                                 _token,\n                                                 _tokenVersion,\n                                                 _depositAmount);\n    }\n\n  }","after":"function metaIssueAndContribute(\n    bytes calldata signature,\n    address payable[] calldata _issuers,\n    address[] calldata _approvers,\n    string calldata _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _depositAmount,\n    uint _nonce)\n    public\n    payable\n    returns (uint)\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaIssueAndContribute\",\n                                                  _issuers,\n                                                  _approvers,\n                                                  _data,\n                                                  _deadline,\n                                                  _token,\n                                                  _tokenVersion,\n                                                  _depositAmount,\n                                                  _nonce));\n    address signer = getSigner(metaHash, signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    if (msg.value > 0){\n      return bountiesContract.issueAndContribute.value(msg.value)(address(uint160(signer)),\n                                                 _issuers,\n                                                 _approvers,\n                                                 _data,\n                                                 _deadline,\n                                                 _token,\n                                                 _tokenVersion,\n                                                 _depositAmount);\n    } else {\n      return bountiesContract.issueAndContribute(address(uint160(signer)),\n                                                 _issuers,\n                                                 _approvers,\n                                                 _data,\n                                                 _deadline,\n                                                 _token,\n                                                 _tokenVersion,\n                                                 _depositAmount);\n    }\n\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaContribute(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _amount,\n    uint _nonce)\n    public\n    payable\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaContribute\",\n                                                  _bountyId,\n                                                  _amount,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    if (msg.value > 0){\n      bountiesContract.contribute.value(msg.value)(address(uint160(signer)), _bountyId, _amount);\n    } else {\n      bountiesContract.contribute(address(uint160(signer)), _bountyId, _amount);\n    }\n  }","after":"function metaContribute(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _amount,\n    uint _nonce)\n    public\n    payable\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaContribute\",\n                                                  _bountyId,\n                                                  _amount,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    if (msg.value > 0){\n      bountiesContract.contribute.value(msg.value)(address(uint160(signer)), _bountyId, _amount);\n    } else {\n      bountiesContract.contribute(address(uint160(signer)), _bountyId, _amount);\n    }\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaRefundContribution(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _contributionId,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaRefundContribution\",\n                                                  _bountyId,\n                                                  _contributionId,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.refundContribution(signer, _bountyId, _contributionId);\n  }","after":"function metaRefundContribution(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _contributionId,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaRefundContribution\",\n                                                  _bountyId,\n                                                  _contributionId,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.refundContribution(signer, _bountyId, _contributionId);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaRefundMyContributions(\n    bytes memory _signature,\n    uint _bountyId,\n    uint[] memory _contributionIds,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaRefundMyContributions\",\n                                                  _bountyId,\n                                                  _contributionIds,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.refundMyContributions(signer, _bountyId, _contributionIds);\n  }","after":"function metaRefundMyContributions(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint[] calldata _contributionIds,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaRefundMyContributions\",\n                                                  _bountyId,\n                                                  _contributionIds,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.refundMyContributions(signer, _bountyId, _contributionIds);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaRefundContributions(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] memory _contributionIds,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaRefundContributions\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _contributionIds,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.refundContributions(signer, _bountyId, _issuerId, _contributionIds);\n  }","after":"function metaRefundContributions(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] calldata _contributionIds,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaRefundContributions\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _contributionIds,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.refundContributions(signer, _bountyId, _issuerId, _contributionIds);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaDrainBounty(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] memory _amounts,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaDrainBounty\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _amounts,\n                                                  _nonce));\n    address payable signer = address(uint160(getSigner(metaHash, _signature)));\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.drainBounty(signer, _bountyId, _issuerId, _amounts);\n  }","after":"function metaDrainBounty(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] calldata _amounts,\n    uint _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaDrainBounty\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _amounts,\n                                                  _nonce));\n    address payable signer = address(uint160(getSigner(metaHash, _signature)));\n\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.drainBounty(signer, _bountyId, _issuerId, _amounts);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaPerformAction(\n    bytes memory _signature,\n    uint _bountyId,\n    string memory _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaPerformAction\",\n                                                  _bountyId,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.performAction(signer, _bountyId, _data);\n  }","after":"function metaPerformAction(\n    bytes calldata _signature,\n    uint _bountyId,\n    string calldata _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaPerformAction\",\n                                                  _bountyId,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.performAction(signer, _bountyId, _data);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaFulfillBounty(\n    bytes memory _signature,\n    uint _bountyId,\n    address payable[] memory  _fulfillers,\n    string memory _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaFulfillBounty\",\n                                                  _bountyId,\n                                                  _fulfillers,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.fulfillBounty(signer, _bountyId, _fulfillers, _data);\n  }","after":"function metaFulfillBounty(\n    bytes calldata _signature,\n    uint _bountyId,\n    address payable[] calldata  _fulfillers,\n    string calldata _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaFulfillBounty\",\n                                                  _bountyId,\n                                                  _fulfillers,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.fulfillBounty(signer, _bountyId, _fulfillers, _data);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaUpdateFulfillment(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _fulfillmentId,\n    address payable[] memory  _fulfillers,\n    string memory _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaUpdateFulfillment\",\n                                                  _bountyId,\n                                                  _fulfillmentId,\n                                                  _fulfillers,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.updateFulfillment(signer, _bountyId, _fulfillmentId, _fulfillers, _data);\n  }","after":"function metaUpdateFulfillment(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _fulfillmentId,\n    address payable[] calldata  _fulfillers,\n    string calldata _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaUpdateFulfillment\",\n                                                  _bountyId,\n                                                  _fulfillmentId,\n                                                  _fulfillers,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.updateFulfillment(signer, _bountyId, _fulfillmentId, _fulfillers, _data);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaAcceptFulfillment(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _fulfillmentId,\n    uint _approverId,\n    uint[] memory _tokenAmounts,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaAcceptFulfillment\",\n                                                  _bountyId,\n                                                  _fulfillmentId,\n                                                  _approverId,\n                                                  _tokenAmounts,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.acceptFulfillment(signer,\n                       _bountyId,\n                       _fulfillmentId,\n                       _approverId,\n                       _tokenAmounts);\n  }","after":"function metaAcceptFulfillment(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _fulfillmentId,\n    uint _approverId,\n    uint[] calldata _tokenAmounts,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaAcceptFulfillment\",\n                                                  _bountyId,\n                                                  _fulfillmentId,\n                                                  _approverId,\n                                                  _tokenAmounts,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.acceptFulfillment(signer,\n                       _bountyId,\n                       _fulfillmentId,\n                       _approverId,\n                       _tokenAmounts);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaFulfillAndAccept(\n    bytes memory _signature,\n    uint _bountyId,\n    address payable[] memory _fulfillers,\n    string memory _data,\n    uint _approverId,\n    uint[] memory _tokenAmounts,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaFulfillAndAccept\",\n                                                  _bountyId,\n                                                  _fulfillers,\n                                                  _data,\n                                                  _approverId,\n                                                  _tokenAmounts,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.fulfillAndAccept(signer,\n                      _bountyId,\n                      _fulfillers,\n                      _data,\n                      _approverId,\n                      _tokenAmounts);\n  }","after":"function metaFulfillAndAccept(\n    bytes calldata _signature,\n    uint _bountyId,\n    address payable[] calldata _fulfillers,\n    string calldata _data,\n    uint _approverId,\n    uint[] calldata _tokenAmounts,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaFulfillAndAccept\",\n                                                  _bountyId,\n                                                  _fulfillers,\n                                                  _data,\n                                                  _approverId,\n                                                  _tokenAmounts,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.fulfillAndAccept(signer,\n                      _bountyId,\n                      _fulfillers,\n                      _data,\n                      _approverId,\n                      _tokenAmounts);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaChangeBounty(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers,\n    address payable[] memory _approvers,\n    string memory _data,\n    uint _deadline,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeBounty\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _issuers,\n                                                  _approvers,\n                                                  _data,\n                                                  _deadline,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeBounty(signer,\n                  _bountyId,\n                  _issuerId,\n                  _issuers,\n                  _approvers,\n                  _data,\n                  _deadline);\n  }","after":"function metaChangeBounty(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers,\n    address payable[] calldata _approvers,\n    string calldata _data,\n    uint _deadline,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeBounty\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _issuers,\n                                                  _approvers,\n                                                  _data,\n                                                  _deadline,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeBounty(signer,\n                  _bountyId,\n                  _issuerId,\n                  _issuers,\n                  _approvers,\n                  _data,\n                  _deadline);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaChangeIssuer(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint _issuerIdToChange,\n    address payable _newIssuer,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeIssuer\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _issuerIdToChange,\n                                                  _newIssuer,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeIssuer(signer,\n                  _bountyId,\n                  _issuerId,\n                  _issuerIdToChange,\n                  _newIssuer);\n  }","after":"function metaChangeIssuer(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint _issuerIdToChange,\n    address payable _newIssuer,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeIssuer\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _issuerIdToChange,\n                                                  _newIssuer,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeIssuer(signer,\n                  _bountyId,\n                  _issuerId,\n                  _issuerIdToChange,\n                  _newIssuer);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaChangeApprover(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint _approverId,\n    address payable _approver,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeApprover\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _approverId,\n                                                  _approver,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeApprover(signer,\n                  _bountyId,\n                  _issuerId,\n                  _approverId,\n                  _approver);\n  }","after":"function metaChangeApprover(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint _approverId,\n    address payable _approver,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeApprover\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _approverId,\n                                                  _approver,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeApprover(signer,\n                  _bountyId,\n                  _issuerId,\n                  _approverId,\n                  _approver);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaChangeData(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    string memory _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeData\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeData(signer,\n                _bountyId,\n                _issuerId,\n                _data);\n  }","after":"function metaChangeData(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    string calldata _data,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeData\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _data,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeData(signer,\n                _bountyId,\n                _issuerId,\n                _data);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaChangeDeadline(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint  _deadline,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeDeadline\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _deadline,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeDeadline(signer,\n                    _bountyId,\n                    _issuerId,\n                    _deadline);\n  }","after":"function metaChangeDeadline(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    uint  _deadline,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaChangeDeadline\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _deadline,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.changeDeadline(signer,\n                    _bountyId,\n                    _issuerId,\n                    _deadline);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaAddIssuers(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaAddIssuers\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _issuers,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.addIssuers(signer,\n                _bountyId,\n                _issuerId,\n                _issuers);\n  }","after":"function metaAddIssuers(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaAddIssuers\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _issuers,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.addIssuers(signer,\n                _bountyId,\n                _issuerId,\n                _issuers);\n  }","contract":"BountiesMetaTxRelayer","time":0},{"type":"external-function ","before":"function metaAddApprovers(\n    bytes memory _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address[] memory _approvers,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaAddApprovers\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _approvers,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.addApprovers(signer,\n                _bountyId,\n                _issuerId,\n                _approvers);\n  }","after":"function metaAddApprovers(\n    bytes calldata _signature,\n    uint _bountyId,\n    uint _issuerId,\n    address[] calldata _approvers,\n    uint256 _nonce)\n    public\n    {\n    bytes32 metaHash = keccak256(abi.encode(address(this),\n                                                  \"metaAddApprovers\",\n                                                  _bountyId,\n                                                  _issuerId,\n                                                  _approvers,\n                                                  _nonce));\n    address signer = getSigner(metaHash, _signature);\n    //make sure signer doesn't come back as 0x0\n    require(signer != address(0));\n    require(_nonce == replayNonce[signer]);\n\n    //increase the nonce to prevent replay attacks\n    replayNonce[signer]++;\n\n    bountiesContract.addApprovers(signer,\n                _bountyId,\n                _issuerId,\n                _approvers);\n  }","contract":"BountiesMetaTxRelayer","time":0}]}