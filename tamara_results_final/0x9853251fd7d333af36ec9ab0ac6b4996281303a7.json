{"time":475,"results":[{"type":"state-data-arrangement ","before":"\naddress payable constant public ZERO_ADDR = address(0x00);\nuint public _dailyInvest = 0;\nuint public _staticPool = 0;\nuint public _outInvest = 0;\nuint public _safePool = 0;\nuint public _gloryPool = 0;\nmapping(address => Player) allPlayers;\naddress[] public allAddress = new address[](0);\nuint[] public lockedRound = new uint[](0);\nuint investCount = 0;\nmapping(uint => Investment) investments;\naddress[] public dailyPlayers = new address[](0);\nuint _rand = 88;\nuint _safeIndex = 0;\nuint _endTime = 0;\nuint _startTime = 0;\nbool public _active = true;","after":"uint public _dailyInvest = 0;\nuint public _staticPool = 0;\nuint public _outInvest = 0;\nuint public _safePool = 0;\nuint public _gloryPool = 0;\nmapping(address => Player) allPlayers;\naddress[] public allAddress = new address[](0);\nuint[] public lockedRound = new uint[](0);\nuint investCount = 0;\nmapping(uint => Investment) investments;\naddress[] public dailyPlayers = new address[](0);\nuint _rand = 88;\nuint _safeIndex = 0;\nuint _endTime = 0;\nuint _startTime = 0;\naddress payable constant public ZERO_ADDR = address(0x00);\nbool public _active = true;\n","contract":"Future","time":0},{"type":"external-function ","before":"function sendGloryAward(address[] memory plays, uint[] memory selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","after":"function sendGloryAward(address[] calldata plays, uint[] calldata selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] memory locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","after":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] calldata locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function future(\n        address[] memory plays, address[] memory parents,\n        uint[] memory bonus, uint[] memory totalBonus,\n        uint[] memory totalInvests, uint[] memory sons, uint[] memory round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","after":"function future(\n        address[] calldata plays, address[] calldata parents,\n        uint[] calldata bonus, uint[] calldata totalBonus,\n        uint[] calldata totalInvests, uint[] calldata sons, uint[] calldata round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function sendGloryAward(address[] memory plays, uint[] memory selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","after":"function sendGloryAward(address[] calldata plays, uint[] calldata selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] memory locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","after":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] calldata locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function future(\n        address[] memory plays, address[] memory parents,\n        uint[] memory bonus, uint[] memory totalBonus,\n        uint[] memory totalInvests, uint[] memory sons, uint[] memory round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","after":"function future(\n        address[] calldata plays, address[] calldata parents,\n        uint[] calldata bonus, uint[] calldata totalBonus,\n        uint[] calldata totalInvests, uint[] calldata sons, uint[] calldata round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function sendGloryAward(address[] memory plays, uint[] memory selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","after":"function sendGloryAward(address[] calldata plays, uint[] calldata selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] memory locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","after":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] calldata locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function future(\n        address[] memory plays, address[] memory parents,\n        uint[] memory bonus, uint[] memory totalBonus,\n        uint[] memory totalInvests, uint[] memory sons, uint[] memory round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","after":"function future(\n        address[] calldata plays, address[] calldata parents,\n        uint[] calldata bonus, uint[] calldata totalBonus,\n        uint[] calldata totalInvests, uint[] calldata sons, uint[] calldata round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","contract":"Future","time":0},{"type":"struct-data-arrangement ","before":"\naddress self\nuint amount\nuint time\nuint round\nbool firstFlag","after":"uint amount\nuint time\nuint round\naddress self\nbool firstFlag\n","contract":"FutureBase","time":0},{"type":"state-data-arrangement ","before":"\naddress payable constant public ZERO_ADDR = address(0x00);\nuint public _dailyInvest = 0;\nuint public _staticPool = 0;\nuint public _outInvest = 0;\nuint public _safePool = 0;\nuint public _gloryPool = 0;\nmapping(address => Player) allPlayers;\naddress[] public allAddress = new address[](0);\nuint[] public lockedRound = new uint[](0);\nuint investCount = 0;\nmapping(uint => Investment) investments;\naddress[] public dailyPlayers = new address[](0);\nuint _rand = 88;\nuint _safeIndex = 0;\nuint _endTime = 0;\nuint _startTime = 0;\nbool public _active = true;","after":"uint public _dailyInvest = 0;\nuint public _staticPool = 0;\nuint public _outInvest = 0;\nuint public _safePool = 0;\nuint public _gloryPool = 0;\nmapping(address => Player) allPlayers;\naddress[] public allAddress = new address[](0);\nuint[] public lockedRound = new uint[](0);\nuint investCount = 0;\nmapping(uint => Investment) investments;\naddress[] public dailyPlayers = new address[](0);\nuint _rand = 88;\nuint _safeIndex = 0;\nuint _endTime = 0;\nuint _startTime = 0;\naddress payable constant public ZERO_ADDR = address(0x00);\nbool public _active = true;\n","contract":"Future","time":0},{"type":"external-function ","before":"function sendGloryAward(address[] memory plays, uint[] memory selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","after":"function sendGloryAward(address[] calldata plays, uint[] calldata selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] memory locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","after":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] calldata locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function future(\n        address[] memory plays, address[] memory parents,\n        uint[] memory bonus, uint[] memory totalBonus,\n        uint[] memory totalInvests, uint[] memory sons, uint[] memory round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","after":"function future(\n        address[] calldata plays, address[] calldata parents,\n        uint[] calldata bonus, uint[] calldata totalBonus,\n        uint[] calldata totalInvests, uint[] calldata sons, uint[] calldata round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function sendGloryAward(address[] memory plays, uint[] memory selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","after":"function sendGloryAward(address[] calldata plays, uint[] calldata selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] memory locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","after":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] calldata locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function future(\n        address[] memory plays, address[] memory parents,\n        uint[] memory bonus, uint[] memory totalBonus,\n        uint[] memory totalInvests, uint[] memory sons, uint[] memory round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","after":"function future(\n        address[] calldata plays, address[] calldata parents,\n        uint[] calldata bonus, uint[] calldata totalBonus,\n        uint[] calldata totalInvests, uint[] calldata sons, uint[] calldata round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function sendGloryAward(address[] memory plays, uint[] memory selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","after":"function sendGloryAward(address[] calldata plays, uint[] calldata selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] memory locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","after":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] calldata locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function future(\n        address[] memory plays, address[] memory parents,\n        uint[] memory bonus, uint[] memory totalBonus,\n        uint[] memory totalInvests, uint[] memory sons, uint[] memory round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","after":"function future(\n        address[] calldata plays, address[] calldata parents,\n        uint[] calldata bonus, uint[] calldata totalBonus,\n        uint[] calldata totalInvests, uint[] calldata sons, uint[] calldata round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","contract":"Future","time":1},{"type":"struct-data-arrangement ","before":"\naddress self\nuint amount\nuint time\nuint round\nbool firstFlag","after":"uint amount\nuint time\nuint round\naddress self\nbool firstFlag\n","contract":"FutureBase","time":0},{"type":"state-data-arrangement ","before":"\naddress payable constant public ZERO_ADDR = address(0x00);\nuint public _dailyInvest = 0;\nuint public _staticPool = 0;\nuint public _outInvest = 0;\nuint public _safePool = 0;\nuint public _gloryPool = 0;\nmapping(address => Player) allPlayers;\naddress[] public allAddress = new address[](0);\nuint[] public lockedRound = new uint[](0);\nuint investCount = 0;\nmapping(uint => Investment) investments;\naddress[] public dailyPlayers = new address[](0);\nuint _rand = 88;\nuint _safeIndex = 0;\nuint _endTime = 0;\nuint _startTime = 0;\nbool public _active = true;","after":"uint public _dailyInvest = 0;\nuint public _staticPool = 0;\nuint public _outInvest = 0;\nuint public _safePool = 0;\nuint public _gloryPool = 0;\nmapping(address => Player) allPlayers;\naddress[] public allAddress = new address[](0);\nuint[] public lockedRound = new uint[](0);\nuint investCount = 0;\nmapping(uint => Investment) investments;\naddress[] public dailyPlayers = new address[](0);\nuint _rand = 88;\nuint _safeIndex = 0;\nuint _endTime = 0;\nuint _startTime = 0;\naddress payable constant public ZERO_ADDR = address(0x00);\nbool public _active = true;\n","contract":"Future","time":0},{"type":"external-function ","before":"function sendGloryAward(address[] memory plays, uint[] memory selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","after":"function sendGloryAward(address[] calldata plays, uint[] calldata selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] memory locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","after":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] calldata locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function future(\n        address[] memory plays, address[] memory parents,\n        uint[] memory bonus, uint[] memory totalBonus,\n        uint[] memory totalInvests, uint[] memory sons, uint[] memory round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","after":"function future(\n        address[] calldata plays, address[] calldata parents,\n        uint[] calldata bonus, uint[] calldata totalBonus,\n        uint[] calldata totalInvests, uint[] calldata sons, uint[] calldata round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function sendGloryAward(address[] memory plays, uint[] memory selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","after":"function sendGloryAward(address[] calldata plays, uint[] calldata selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] memory locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","after":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] calldata locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function future(\n        address[] memory plays, address[] memory parents,\n        uint[] memory bonus, uint[] memory totalBonus,\n        uint[] memory totalInvests, uint[] memory sons, uint[] memory round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","after":"function future(\n        address[] calldata plays, address[] calldata parents,\n        uint[] calldata bonus, uint[] calldata totalBonus,\n        uint[] calldata totalInvests, uint[] calldata sons, uint[] calldata round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function sendGloryAward(address[] memory plays, uint[] memory selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","after":"function sendGloryAward(address[] calldata plays, uint[] calldata selfAmount, uint totalAmount)\n    public onlyAdmin() {\n        _gloryPool = _gloryPool.sub(totalAmount);\n        for(uint i = 0; i < plays.length; i++){\n            investBonus(plays[i], selfAmount[i], true, 0);\n            emit logGlory(plays[i], selfAmount[i], now);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] memory locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","after":"function startArgs(uint dailyInvest, uint safePool, uint gloryPool, uint staticPool, uint[] calldata locks) public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        _dailyInvest = dailyInvest;\n        _safePool = safePool;\n        _gloryPool = gloryPool;\n        _staticPool = staticPool;\n        for(uint i=0; i<locks.length; i++) {\n            lockedRound.push(locks[i]);\n        }\n    }","contract":"Future","time":0},{"type":"external-function ","before":"function future(\n        address[] memory plays, address[] memory parents,\n        uint[] memory bonus, uint[] memory totalBonus,\n        uint[] memory totalInvests, uint[] memory sons, uint[] memory round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","after":"function future(\n        address[] calldata plays, address[] calldata parents,\n        uint[] calldata bonus, uint[] calldata totalBonus,\n        uint[] calldata totalInvests, uint[] calldata sons, uint[] calldata round)\n    public onlyAdmin() {\n        require(!isStart(), \"Game Not Start Limit\");\n        for(uint i=0; i<plays.length; i++) {\n            Player storage user = allPlayers[plays[i]];\n            user.self = plays[i];\n            user.parent = parents[i];\n            user.bonus = bonus[i];\n            user.totalBonus = totalBonus[i];\n            user.invest = totalInvests[i];\n            user.sons = sons[i];\n            user.round = round[i];\n            user.index = allAddress.length;\n            allAddress.push(plays[i]);\n        }\n    }","contract":"Future","time":0},{"type":"struct-data-arrangement ","before":"\naddress self\nuint amount\nuint time\nuint round\nbool firstFlag","after":"uint amount\nuint time\nuint round\naddress self\nbool firstFlag\n","contract":"FutureBase","time":0}]}