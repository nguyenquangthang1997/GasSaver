{"time":94,"results":[{"type":"state-data-arrangement ","before":"\nstring public symbol;\nstring public name;\nuint8 public decimals;\nuint256 public _totalSupply;\nuint256 public _burned;\nuint256 public _mintingEpoch;\nuint public latestDifficultyPeriodStarted;\nuint public epochCount;\nuint public _BLOCKS_PER_READJUSTMENT = 64;\nuint public _MINIMUM_TARGET = 2 ** 16;\nuint public _MAXIMUM_TARGET = 2 ** 234;\nuint public miningTarget;\nbytes32 public challengeNumber;\nuint public rewardEra;\nuint public maxSupplyForEra;\naddress public lastRewardTo;\nuint public lastRewardAmount;\nuint public lastRewardEthBlockNumber;\nmapping(bytes32 => bytes32) solutionForChallenge;\nuint public tokensMinted;\nmapping(address => uint) balances;\nmapping(address => mapping(address => uint)) allowed;\nuint private basePercent;\nbool private locked = false;\naddress private previousSender = address(0);","after":"string public symbol;\nstring public name;\nuint256 public _totalSupply;\nuint256 public _burned;\nuint256 public _mintingEpoch;\nuint public latestDifficultyPeriodStarted;\nuint public epochCount;\nuint public _BLOCKS_PER_READJUSTMENT = 64;\nuint public _MINIMUM_TARGET = 2 ** 16;\nuint public _MAXIMUM_TARGET = 2 ** 234;\nuint public miningTarget;\nbytes32 public challengeNumber;\nuint public rewardEra;\nuint public maxSupplyForEra;\nuint public lastRewardAmount;\nuint public lastRewardEthBlockNumber;\nmapping(bytes32 => bytes32) solutionForChallenge;\nuint public tokensMinted;\nmapping(address => uint) balances;\nmapping(address => mapping(address => uint)) allowed;\nuint private basePercent;\naddress public lastRewardTo;\naddress private previousSender = address(0);\nuint8 public decimals;\nbool private locked = false;\n","contract":"BUTTv1","time":0},{"type":"external-function ","before":"function approveAndCall(address spender, uint tokens, bytes memory data) public returns(bool success) {\n    allowed[msg.sender][spender] = tokens;\n    emit Approval(msg.sender, spender, tokens);\n    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n    return true;\n\n  }","after":"function approveAndCall(address spender, uint tokens, bytes calldata data) public returns(bool success) {\n    allowed[msg.sender][spender] = tokens;\n    emit Approval(msg.sender, spender, tokens);\n    ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\n    return true;\n\n  }","contract":"BUTTv1","time":0},{"type":"constant-restrict-modification  ","before":"uint public _BLOCKS_PER_READJUSTMENT = 64;","after":"uint public constant _BLOCKS_PER_READJUSTMENT = 64;","contract":"BUTTv1","time":0},{"type":"constant-restrict-modification  ","before":"uint public _MINIMUM_TARGET = 2 ** 16;","after":"uint public constant _MINIMUM_TARGET = 2 ** 16;","contract":"BUTTv1","time":0},{"type":"constant-restrict-modification  ","before":"uint public _MAXIMUM_TARGET = 2 ** 234;","after":"uint public constant _MAXIMUM_TARGET = 2 ** 234;","contract":"BUTTv1","time":0}]}