{"time":192,"results":[{"type":"struct-data-arrangement ","before":"\n  address payable[] issue\n  address[] approve\n  uint deadli\n  address tok\n  uint tokenVersi\n  uint balan\n  bool hasPaidO\n  Fulfillment[] fulfillmen\n  Contribution[] contributio","after":"  address payable[] issue\n  address[] approve\n  uint deadli\n  uint tokenVersi\n  uint balan\n  Fulfillment[] fulfillmen\n  Contribution[] contributio\n  address tok\n  bool hasPaidO\n","contract":"StandardBounties","time":0},{"type":"struct-data-arrangement ","before":"\n  address payable contribut\n  uint amou\n  bool refund","after":"  uint amou\n  address payable contribut\n  bool refund\n","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function issueAndContribute(\n    address payable _sender,\n    address payable[] memory _issuers,\n    address[] memory _approvers,\n    string memory _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _depositAmount)\n    public\n    payable\n    returns(uint)\n  {\n    uint bountyId = issueBounty(_sender, _issuers, _approvers, _data, _deadline, _token, _tokenVersion);\n\n    contribute(_sender, bountyId, _depositAmount);\n\n    return (bountyId);\n ","after":"  function issueAndContribute(\n    address payable _sender,\n    address payable[] calldata _issuers,\n    address[] calldata _approvers,\n    string calldata _data,\n    uint _deadline,\n    address _token,\n    uint _tokenVersion,\n    uint _depositAmount)\n    public\n    payable\n    returns(uint)\n  {\n    uint bountyId = issueBounty(_sender, _issuers, _approvers, _data, _deadline, _token, _tokenVersion);\n\n    contribute(_sender, bountyId, _depositAmount);\n\n    return (bountyId);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function refundMyContributions(\n    address _sender,\n    uint _bountyId,\n    uint[] memory _contributionIds)\n    public\n    senderIsValid(_sender)\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n        refundContribution(_sender, _bountyId, _contributionIds[i]);\n    }\n ","after":"  function refundMyContributions(\n    address _sender,\n    uint _bountyId,\n    uint[] calldata _contributionIds)\n    public\n    senderIsValid(_sender)\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n        refundContribution(_sender, _bountyId, _contributionIds[i]);\n    }\n ","contract":"StandardBounties","time":1},{"type":"external-function ","before":"  function refundContributions(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] memory _contributionIds)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n      require(_contributionIds[i] < bounties[_bountyId].contributions.length);\n\n      Contribution storage contribution = bounties[_bountyId].contributions[_contributionIds[i]];\n\n      require(!contribution.refunded);\n\n      contribution.refunded = true;\n\n      transferTokens(_bountyId, contribution.contributor, contribution.amount); // Performs the disbursal of tokens to the contributor\n    }\n\n    emit ContributionsRefunded(_bountyId, _sender, _contributionIds);\n ","after":"  function refundContributions(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] calldata _contributionIds)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    for (uint i = 0; i < _contributionIds.length; i++){\n      require(_contributionIds[i] < bounties[_bountyId].contributions.length);\n\n      Contribution storage contribution = bounties[_bountyId].contributions[_contributionIds[i]];\n\n      require(!contribution.refunded);\n\n      contribution.refunded = true;\n\n      transferTokens(_bountyId, contribution.contributor, contribution.amount); // Performs the disbursal of tokens to the contributor\n    }\n\n    emit ContributionsRefunded(_bountyId, _sender, _contributionIds);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function drainBounty(\n    address payable _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] memory _amounts)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    if (bounties[_bountyId].tokenVersion == 0 || bounties[_bountyId].tokenVersion == 20){\n      require(_amounts.length == 1); // ensures there's only 1 amount of tokens to be returned\n      require(_amounts[0] <= bounties[_bountyId].balance); // ensures an issuer doesn't try to drain the bounty of more tokens than their balance permits\n      transferTokens(_bountyId, _sender, _amounts[0]); // Performs the draining of tokens to the issuer\n    } else {\n      for (uint i = 0; i < _amounts.length; i++){\n        require(tokenBalances[_bountyId][_amounts[i]]);// ensures an issuer doesn't try to drain the bounty of a token it doesn't have in its balance\n        transferTokens(_bountyId, _sender, _amounts[i]);\n      }\n    }\n\n    emit BountyDrained(_bountyId, _sender, _amounts);\n ","after":"  function drainBounty(\n    address payable _sender,\n    uint _bountyId,\n    uint _issuerId,\n    uint[] calldata _amounts)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n    callNotStarted\n  {\n    if (bounties[_bountyId].tokenVersion == 0 || bounties[_bountyId].tokenVersion == 20){\n      require(_amounts.length == 1); // ensures there's only 1 amount of tokens to be returned\n      require(_amounts[0] <= bounties[_bountyId].balance); // ensures an issuer doesn't try to drain the bounty of more tokens than their balance permits\n      transferTokens(_bountyId, _sender, _amounts[0]); // Performs the draining of tokens to the issuer\n    } else {\n      for (uint i = 0; i < _amounts.length; i++){\n        require(tokenBalances[_bountyId][_amounts[i]]);// ensures an issuer doesn't try to drain the bounty of a token it doesn't have in its balance\n        transferTokens(_bountyId, _sender, _amounts[i]);\n      }\n    }\n\n    emit BountyDrained(_bountyId, _sender, _amounts);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function performAction(\n    address _sender,\n    uint _bountyId,\n    string memory _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n  {\n    emit ActionPerformed(_bountyId, _sender, _data); // The _data string is emitted in an event for easy off-chain consumption\n ","after":"  function performAction(\n    address _sender,\n    uint _bountyId,\n    string calldata _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n  {\n    emit ActionPerformed(_bountyId, _sender, _data); // The _data string is emitted in an event for easy off-chain consumption\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function updateFulfillment(\n  address _sender,\n  uint _bountyId,\n  uint _fulfillmentId,\n  address payable[] memory _fulfillers,\n  string memory _data)\n  public\n  senderIsValid(_sender)\n  validateBountyArrayIndex(_bountyId)\n  validateFulfillmentArrayIndex(_bountyId, _fulfillmentId)\n  onlySubmitter(_sender, _bountyId, _fulfillmentId) // Only the original submitter of a fulfillment may update their submission\n  {\n    bounties[_bountyId].fulfillments[_fulfillmentId].fulfillers = _fulfillers;\n    emit FulfillmentUpdated(_bountyId,\n                            _fulfillmentId,\n                            _fulfillers,\n                            _data); // The _data string is emitted in an event for easy off-chain consumption\n ","after":"  function updateFulfillment(\n  address _sender,\n  uint _bountyId,\n  uint _fulfillmentId,\n  address payable[] calldata _fulfillers,\n  string calldata _data)\n  public\n  senderIsValid(_sender)\n  validateBountyArrayIndex(_bountyId)\n  validateFulfillmentArrayIndex(_bountyId, _fulfillmentId)\n  onlySubmitter(_sender, _bountyId, _fulfillmentId) // Only the original submitter of a fulfillment may update their submission\n  {\n    bounties[_bountyId].fulfillments[_fulfillmentId].fulfillers = _fulfillers;\n    emit FulfillmentUpdated(_bountyId,\n                            _fulfillmentId,\n                            _fulfillers,\n                            _data); // The _data string is emitted in an event for easy off-chain consumption\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function fulfillAndAccept(\n    address _sender,\n    uint _bountyId,\n    address payable[] memory _fulfillers,\n    string memory _data,\n    uint _approverId,\n    uint[] memory _tokenAmounts)\n    public\n    senderIsValid(_sender)\n  {\n    // first fulfills the bounty on behalf of the fulfillers\n    fulfillBounty(_sender, _bountyId, _fulfillers, _data);\n\n    // then accepts the fulfillment\n    acceptFulfillment(_sender,\n                      _bountyId,\n                      bounties[_bountyId].fulfillments.length - 1,\n                      _approverId,\n                      _tokenAmounts);\n ","after":"  function fulfillAndAccept(\n    address _sender,\n    uint _bountyId,\n    address payable[] calldata _fulfillers,\n    string calldata _data,\n    uint _approverId,\n    uint[] calldata _tokenAmounts)\n    public\n    senderIsValid(_sender)\n  {\n    // first fulfills the bounty on behalf of the fulfillers\n    fulfillBounty(_sender, _bountyId, _fulfillers, _data);\n\n    // then accepts the fulfillment\n    acceptFulfillment(_sender,\n                      _bountyId,\n                      bounties[_bountyId].fulfillments.length - 1,\n                      _approverId,\n                      _tokenAmounts);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function changeBounty(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers,\n    address payable[] memory _approvers,\n    string memory _data,\n    uint _deadline)\n    public\n    senderIsValid(_sender)\n  {\n    require(_bountyId < numBounties); // makes the validateBountyArrayIndex modifier in-line to avoid stack too deep errors\n    require(_issuerId < bounties[_bountyId].issuers.length); // makes the validateIssuerArrayIndex modifier in-line to avoid stack too deep errors\n    require(_sender == bounties[_bountyId].issuers[_issuerId]); // makes the onlyIssuer modifier in-line to avoid stack too deep errors\n\n    require(_issuers.length > 0 || _approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n\n    bounties[_bountyId].issuers = _issuers;\n    bounties[_bountyId].approvers = _approvers;\n    bounties[_bountyId].deadline = _deadline;\n    emit BountyChanged(_bountyId,\n                       _sender,\n                       _issuers,\n                       _approvers,\n                       _data,\n                       _deadline);\n ","after":"  function changeBounty(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers,\n    address payable[] calldata _approvers,\n    string calldata _data,\n    uint _deadline)\n    public\n    senderIsValid(_sender)\n  {\n    require(_bountyId < numBounties); // makes the validateBountyArrayIndex modifier in-line to avoid stack too deep errors\n    require(_issuerId < bounties[_bountyId].issuers.length); // makes the validateIssuerArrayIndex modifier in-line to avoid stack too deep errors\n    require(_sender == bounties[_bountyId].issuers[_issuerId]); // makes the onlyIssuer modifier in-line to avoid stack too deep errors\n\n    require(_issuers.length > 0 || _approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n\n    bounties[_bountyId].issuers = _issuers;\n    bounties[_bountyId].approvers = _approvers;\n    bounties[_bountyId].deadline = _deadline;\n    emit BountyChanged(_bountyId,\n                       _sender,\n                       _issuers,\n                       _approvers,\n                       _data,\n                       _deadline);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function changeData(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    string memory _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    emit BountyDataChanged(_bountyId, _sender, _data); // The new _data is emitted within an event rather than being stored on-chain for minimized gas costs\n ","after":"  function changeData(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    string calldata _data)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    emit BountyDataChanged(_bountyId, _sender, _data); // The new _data is emitted within an event rather than being stored on-chain for minimized gas costs\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function addIssuers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _issuers.length; i++){\n      bounties[_bountyId].issuers.push(_issuers[i]);\n    }\n\n    emit BountyIssuersUpdated(_bountyId, _sender, bounties[_bountyId].issuers);\n ","after":"  function addIssuers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _issuers.length; i++){\n      bounties[_bountyId].issuers.push(_issuers[i]);\n    }\n\n    emit BountyIssuersUpdated(_bountyId, _sender, bounties[_bountyId].issuers);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function replaceIssuers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] memory _issuers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    require(_issuers.length > 0 || bounties[_bountyId].approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n\n    bounties[_bountyId].issuers = _issuers;\n\n    emit BountyIssuersUpdated(_bountyId, _sender, bounties[_bountyId].issuers);\n ","after":"  function replaceIssuers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address payable[] calldata _issuers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    require(_issuers.length > 0 || bounties[_bountyId].approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n\n    bounties[_bountyId].issuers = _issuers;\n\n    emit BountyIssuersUpdated(_bountyId, _sender, bounties[_bountyId].issuers);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function addApprovers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address[] memory _approvers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _approvers.length; i++){\n      bounties[_bountyId].approvers.push(_approvers[i]);\n    }\n\n    emit BountyApproversUpdated(_bountyId, _sender, bounties[_bountyId].approvers);\n ","after":"  function addApprovers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address[] calldata _approvers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    for (uint i = 0; i < _approvers.length; i++){\n      bounties[_bountyId].approvers.push(_approvers[i]);\n    }\n\n    emit BountyApproversUpdated(_bountyId, _sender, bounties[_bountyId].approvers);\n ","contract":"StandardBounties","time":0},{"type":"external-function ","before":"  function replaceApprovers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address[] memory _approvers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    require(bounties[_bountyId].issuers.length > 0 || _approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n    bounties[_bountyId].approvers = _approvers;\n\n    emit BountyApproversUpdated(_bountyId, _sender, bounties[_bountyId].approvers);\n ","after":"  function replaceApprovers(\n    address _sender,\n    uint _bountyId,\n    uint _issuerId,\n    address[] calldata _approvers)\n    public\n    senderIsValid(_sender)\n    validateBountyArrayIndex(_bountyId)\n    validateIssuerArrayIndex(_bountyId, _issuerId)\n    onlyIssuer(_sender, _bountyId, _issuerId)\n  {\n    require(bounties[_bountyId].issuers.length > 0 || _approvers.length > 0); // Ensures there's at least 1 issuer or approver, so funds don't get stuck\n    bounties[_bountyId].approvers = _approvers;\n\n    emit BountyApproversUpdated(_bountyId, _sender, bounties[_bountyId].approvers);\n ","contract":"StandardBounties","time":0}]}