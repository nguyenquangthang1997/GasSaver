{"time":45,"results":[{"type":"external-function ","before":"function addBond(BondLibrary.Bond memory bond) public {\n\t\tbytes32 id = bond.hash(msg.sender);\n\t\trequire(!bonds[id].active, 'BOND_ALREADY_ACTIVE');\n\t\trequire(slashPoints[bond.poolId] < MAX_SLASH, 'POOL_SLASHED');\n\t\tbonds[id] = BondState({\n\t\t\tactive: true,\n\t\t\tslashedAtStart: uint64(slashPoints[bond.poolId]),\n\t\t\twillUnlock: 0\n\t\t});\n\t\tSafeERC20.transferFrom(tokenAddr, msg.sender, address(this), bond.amount);\n\t}","after":"function addBond(BondLibrary.Bond calldata bond) public {\n\t\tbytes32 id = bond.hash(msg.sender);\n\t\trequire(!bonds[id].active, 'BOND_ALREADY_ACTIVE');\n\t\trequire(slashPoints[bond.poolId] < MAX_SLASH, 'POOL_SLASHED');\n\t\tbonds[id] = BondState({\n\t\t\tactive: true,\n\t\t\tslashedAtStart: uint64(slashPoints[bond.poolId]),\n\t\t\twillUnlock: 0\n\t\t});\n\t\tSafeERC20.transferFrom(tokenAddr, msg.sender, address(this), bond.amount);\n\t}","contract":"Staking","time":0},{"type":"external-function ","before":"function requestUnbond(BondLibrary.Bond memory bond) public {\n\t\tBondState storage bondState = bonds[bond.hash(msg.sender)];\n\t\trequire(bondState.active && bondState.willUnlock == 0, 'BOND_NOT_ACTIVE');\n\t\tbondState.willUnlock = uint64(now + TIME_TO_UNBOND);\n\t}","after":"function requestUnbond(BondLibrary.Bond calldata bond) public {\n\t\tBondState storage bondState = bonds[bond.hash(msg.sender)];\n\t\trequire(bondState.active && bondState.willUnlock == 0, 'BOND_NOT_ACTIVE');\n\t\tbondState.willUnlock = uint64(now + TIME_TO_UNBOND);\n\t}","contract":"Staking","time":0},{"type":"external-function ","before":"function unbond(BondLibrary.Bond memory bond) public {\n\t\tbytes32 id = bond.hash(msg.sender);\n\t\tBondState storage bondState = bonds[id];\n\t\trequire(bondState.willUnlock > 0 && now > bondState.willUnlock, 'BOND_NOT_UNLOCKED');\n\t\tuint amount = calcWithdrawAmount(bond, uint(bondState.slashedAtStart));\n\t\tuint toBurn = bond.amount - amount;\n\t\tdelete bonds[id];\n\t\tSafeERC20.transfer(tokenAddr, msg.sender, amount);\n\t\tSafeERC20.transfer(tokenAddr, BURN_ADDR, toBurn);\n\t}","after":"function unbond(BondLibrary.Bond calldata bond) public {\n\t\tbytes32 id = bond.hash(msg.sender);\n\t\tBondState storage bondState = bonds[id];\n\t\trequire(bondState.willUnlock > 0 && now > bondState.willUnlock, 'BOND_NOT_UNLOCKED');\n\t\tuint amount = calcWithdrawAmount(bond, uint(bondState.slashedAtStart));\n\t\tuint toBurn = bond.amount - amount;\n\t\tdelete bonds[id];\n\t\tSafeERC20.transfer(tokenAddr, msg.sender, amount);\n\t\tSafeERC20.transfer(tokenAddr, BURN_ADDR, toBurn);\n\t}","contract":"Staking","time":0}]}