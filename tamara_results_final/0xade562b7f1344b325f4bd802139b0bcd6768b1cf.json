{"time":223,"results":[{"type":"de-morgan-condition ","before":"!marginDetails.isOpen && !marginDetails.isLong","after":"!(marginDetails.isOpen && marginDetails.isLong)","loc":{"start":{"line":1252,"column":15},"end":{"line":1252,"column":55}},"contract":"MarginRingSubmitterWrapper","time":0},{"type":"external-function ","before":"function brokerRequestAllowance(LoopringTypes.BrokerApprovalRequest memory request) public returns (bool) {\n    require(msg.sender == address(LOOPRING_PROTOCOL), \"The msg.sender must be the Loopring protocol\");\n\n    DydxActions.ActionArgs[] memory actionsQueue = new DydxActions.ActionArgs[](request.orders.length * 3);\n    DydxPosition.Info[] memory positionsQueue = new DydxPosition.Info[](request.orders.length);\n\n    uint numActions;\n    uint numPositions;\n\n    for (uint i = 0; i < request.orders.length; i++) {\n      (\n        LoopringTypes.BrokerOrder memory order,\n        Types.MarginLimitOrderDetails memory limitOrder\n      ) = _marginLimitOrderAtIndex(request, i);\n\n      uint positionIndex;\n      uint totalDepositAmount = order.fillAmountB;\n      uint depositedCollateralAmount = 0;\n\n      (\n        numPositions,\n        positionIndex\n      ) = _generatePositionIndex(positionsQueue, numPositions, limitOrder.trader, limitOrder.positionId);\n\n      // Move funds for collateral into this contract for deposit into dydx if it hasn't already been done\n      if (!hasExecutedDeposit[order.orderHash]) {\n        hasExecutedDeposit[order.orderHash] = true;\n        totalDepositAmount += limitOrder.depositAmount;\n        depositedCollateralAmount = limitOrder.depositAmount;\n\n        if (limitOrder.broker == address(0x0)) {\n          TRADE_DELEGATE.transferTokenFrom(limitOrder.depositToken, order.owner, address(this), limitOrder.depositAmount);\n        } else {\n          IDolomiteMarginTradingBroker(limitOrder.broker)\n            .brokerMarginRequestApproval(order.owner, limitOrder.depositToken, limitOrder.depositAmount);\n          ERC20(limitOrder.depositToken).transferFrom(limitOrder.broker, address(this), limitOrder.depositAmount);\n        }\n      }\n\n      // Deposit the collateral and fillAmountB (received at this point from Loopring settlement)\n      actionsQueue[numActions] = _constructDydxTokenAction({\n        positionIndex: positionIndex,\n        isDeposit: true,\n        amount: totalDepositAmount,\n        marketId: limitOrder.marketIdB,\n        targetAddress: address(this)\n      });\n\n      // Withdraw the requestedAmountS needed by Loopring to complete ring settlement\n      actionsQueue[numActions + 1] = _constructDydxTokenAction({\n        positionIndex: positionIndex,\n        isDeposit: false,\n        amount: order.requestedAmountS,\n        marketId: limitOrder.marketIdS,\n        targetAddress: address(this)\n      });\n\n      numActions += 2;\n\n      // Set position expiration if needed and if it has not already been done\n      if (limitOrder.expiration > 0 && !isPositionRegistered(limitOrder.trader, limitOrder.positionId)) {\n        actionsQueue[numActions] = _constructDydxExpirationAction(\n          positionIndex, \n          limitOrder.marketIdS, \n          limitOrder.expiration\n        );\n\n        numActions++;\n      }\n\n      registerPosition(limitOrder.trader, limitOrder.positionId);\n      emit FilledPosition(limitOrder.trader, limitOrder.positionId, order.fillAmountB, order.requestedAmountS, depositedCollateralAmount);\n    }\n\n    // Consolidate action and position queues & execute them with DyDx\n    DydxActions.ActionArgs[] memory actions = new DydxActions.ActionArgs[](numActions);\n    DydxPosition.Info[] memory positions = new DydxPosition.Info[](numPositions);\n\n    for (uint b = 0; b < numActions; b++) {\n      actions[b] = actionsQueue[b];\n      if (b < numPositions) positions[b] = positionsQueue[b];\n    }\n\n    DYDX_PROTOCOL.operate(positions, actions);\n\n    // Does not use onOrderFillReport\n    return false; \n  }","after":"function brokerRequestAllowance(LoopringTypes.BrokerApprovalRequest calldata request) public returns (bool) {\n    require(msg.sender == address(LOOPRING_PROTOCOL), \"The msg.sender must be the Loopring protocol\");\n\n    DydxActions.ActionArgs[] memory actionsQueue = new DydxActions.ActionArgs[](request.orders.length * 3);\n    DydxPosition.Info[] memory positionsQueue = new DydxPosition.Info[](request.orders.length);\n\n    uint numActions;\n    uint numPositions;\n\n    for (uint i = 0; i < request.orders.length; i++) {\n      (\n        LoopringTypes.BrokerOrder memory order,\n        Types.MarginLimitOrderDetails memory limitOrder\n      ) = _marginLimitOrderAtIndex(request, i);\n\n      uint positionIndex;\n      uint totalDepositAmount = order.fillAmountB;\n      uint depositedCollateralAmount = 0;\n\n      (\n        numPositions,\n        positionIndex\n      ) = _generatePositionIndex(positionsQueue, numPositions, limitOrder.trader, limitOrder.positionId);\n\n      // Move funds for collateral into this contract for deposit into dydx if it hasn't already been done\n      if (!hasExecutedDeposit[order.orderHash]) {\n        hasExecutedDeposit[order.orderHash] = true;\n        totalDepositAmount += limitOrder.depositAmount;\n        depositedCollateralAmount = limitOrder.depositAmount;\n\n        if (limitOrder.broker == address(0x0)) {\n          TRADE_DELEGATE.transferTokenFrom(limitOrder.depositToken, order.owner, address(this), limitOrder.depositAmount);\n        } else {\n          IDolomiteMarginTradingBroker(limitOrder.broker)\n            .brokerMarginRequestApproval(order.owner, limitOrder.depositToken, limitOrder.depositAmount);\n          ERC20(limitOrder.depositToken).transferFrom(limitOrder.broker, address(this), limitOrder.depositAmount);\n        }\n      }\n\n      // Deposit the collateral and fillAmountB (received at this point from Loopring settlement)\n      actionsQueue[numActions] = _constructDydxTokenAction({\n        positionIndex: positionIndex,\n        isDeposit: true,\n        amount: totalDepositAmount,\n        marketId: limitOrder.marketIdB,\n        targetAddress: address(this)\n      });\n\n      // Withdraw the requestedAmountS needed by Loopring to complete ring settlement\n      actionsQueue[numActions + 1] = _constructDydxTokenAction({\n        positionIndex: positionIndex,\n        isDeposit: false,\n        amount: order.requestedAmountS,\n        marketId: limitOrder.marketIdS,\n        targetAddress: address(this)\n      });\n\n      numActions += 2;\n\n      // Set position expiration if needed and if it has not already been done\n      if (limitOrder.expiration > 0 && !isPositionRegistered(limitOrder.trader, limitOrder.positionId)) {\n        actionsQueue[numActions] = _constructDydxExpirationAction(\n          positionIndex, \n          limitOrder.marketIdS, \n          limitOrder.expiration\n        );\n\n        numActions++;\n      }\n\n      registerPosition(limitOrder.trader, limitOrder.positionId);\n      emit FilledPosition(limitOrder.trader, limitOrder.positionId, order.fillAmountB, order.requestedAmountS, depositedCollateralAmount);\n    }\n\n    // Consolidate action and position queues & execute them with DyDx\n    DydxActions.ActionArgs[] memory actions = new DydxActions.ActionArgs[](numActions);\n    DydxPosition.Info[] memory positions = new DydxPosition.Info[](numPositions);\n\n    for (uint b = 0; b < numActions; b++) {\n      actions[b] = actionsQueue[b];\n      if (b < numPositions) positions[b] = positionsQueue[b];\n    }\n\n    DYDX_PROTOCOL.operate(positions, actions);\n\n    // Does not use onOrderFillReport\n    return false; \n  }","contract":"DolomiteMarginTrading","time":0}]}