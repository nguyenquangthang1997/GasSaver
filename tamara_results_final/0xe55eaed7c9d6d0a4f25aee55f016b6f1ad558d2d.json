{"time":137,"results":[{"type":"external-function ","before":"function registerAccount(address payable _benefactorAddress, string memory _benefactorName,\n                             address payable _managerAddress, address[] memory _signatories, uint _unlockDate,\n                             uint _preUnlockMonthlyquota) public returns(bool) {\n\n        if (accounts[_benefactorAddress].benefactorAddress == address(0x00)){\n\n            Account storage account = accounts[_benefactorAddress];\n            account.benefactorAddress = _benefactorAddress;\n            account.benefactorName = _benefactorName;\n            account.managerAddress = _managerAddress;\n            account.signatories = _signatories;\n            account.creationDate = now;\n            account.unlockDate = _unlockDate;\n            account.preUnlockMonthlyquota = _preUnlockMonthlyquota;\n\n\n\n        }\n\n\n        }","after":"function registerAccount(address payable _benefactorAddress, string calldata _benefactorName,\n                             address payable _managerAddress, address[] calldata _signatories, uint _unlockDate,\n                             uint _preUnlockMonthlyquota) public returns(bool) {\n\n        if (accounts[_benefactorAddress].benefactorAddress == address(0x00)){\n\n            Account storage account = accounts[_benefactorAddress];\n            account.benefactorAddress = _benefactorAddress;\n            account.benefactorName = _benefactorName;\n            account.managerAddress = _managerAddress;\n            account.signatories = _signatories;\n            account.creationDate = now;\n            account.unlockDate = _unlockDate;\n            account.preUnlockMonthlyquota = _preUnlockMonthlyquota;\n\n\n\n        }\n\n\n        }","contract":"Mementofund","time":0},{"type":"external-function ","before":"function splitInvestEthToToken(address _account, address[] memory _tokens, uint[] memory _ratios) public payable {\n        require(isRegisteredBenefactor(_account),\"Specified account must be registered\");\n        require(msg.value > 0, \"Transaction must have ether value\");\n        require(_tokens.length == _ratios.length, \"unmatched array lengths\");\n\n        handleIndexes(_account, address(ETH_TOKEN_ADDRESS));\n\n        uint256 msgValue = msg.value;\n\n            require(_tokens.length > 0, \"Array must be greater than 0.\");\n            uint quotaTotal;\n            for (uint i = 0;i < _tokens.length; i++) {\n                quotaTotal = quotaTotal.add(quotaTotal);\n            }\n\n            require(quotaTotal < 100, \"Split Total Greater than 100.\");\n\n            for (uint i = 0; i < _tokens.length; i++) {\n                handleIndexes(_account, address(_tokens[i]));\n                uint256 quota = (msg.value * _ratios[i]) / 100;\n                require(quota < msg.value, \"Quota Split greater than Message Value\");\n                uint destqty = _kybertrade(ETH_TOKEN_ADDRESS, quota, ERC20(_tokens[i]));\n                userBalance[_account][address(_tokens[i])] = userBalance[_account][address(_tokens[i])].add(destqty);\n                userInvestments[_account].push(Investment({\n                                                timestamp: now,\n                                                depositedBy: msg.sender,\n                                                srcTokenAddress: address(ETH_TOKEN_ADDRESS),\n                                                srcAmount: quota,\n                                                destTokenAddress: address(_tokens[i]),\n                                                destAmount: destqty\n                                                }));\n                msgValue = msgValue.sub(quota);\n                emit kybertrade(address(ETH_TOKEN_ADDRESS),quota, address(_tokens[i]), destqty);\n            }\n        userBalance[_account][address(ETH_TOKEN_ADDRESS)] = userBalance[_account][address(ETH_TOKEN_ADDRESS)].add(msgValue);\n        userInvestments[_account].push(Investment({\n                                        timestamp: now,\n                                        depositedBy: msg.sender,\n                                        srcTokenAddress: address(ETH_TOKEN_ADDRESS),\n                                        srcAmount: msgValue,\n                                        destTokenAddress: address(ETH_TOKEN_ADDRESS),\n                                        destAmount: msgValue\n                                        }));\n    }","after":"function splitInvestEthToToken(address _account, address[] calldata _tokens, uint[] calldata _ratios) public payable {\n        require(isRegisteredBenefactor(_account),\"Specified account must be registered\");\n        require(msg.value > 0, \"Transaction must have ether value\");\n        require(_tokens.length == _ratios.length, \"unmatched array lengths\");\n\n        handleIndexes(_account, address(ETH_TOKEN_ADDRESS));\n\n        uint256 msgValue = msg.value;\n\n            require(_tokens.length > 0, \"Array must be greater than 0.\");\n            uint quotaTotal;\n            for (uint i = 0;i < _tokens.length; i++) {\n                quotaTotal = quotaTotal.add(quotaTotal);\n            }\n\n            require(quotaTotal < 100, \"Split Total Greater than 100.\");\n\n            for (uint i = 0; i < _tokens.length; i++) {\n                handleIndexes(_account, address(_tokens[i]));\n                uint256 quota = (msg.value * _ratios[i]) / 100;\n                require(quota < msg.value, \"Quota Split greater than Message Value\");\n                uint destqty = _kybertrade(ETH_TOKEN_ADDRESS, quota, ERC20(_tokens[i]));\n                userBalance[_account][address(_tokens[i])] = userBalance[_account][address(_tokens[i])].add(destqty);\n                userInvestments[_account].push(Investment({\n                                                timestamp: now,\n                                                depositedBy: msg.sender,\n                                                srcTokenAddress: address(ETH_TOKEN_ADDRESS),\n                                                srcAmount: quota,\n                                                destTokenAddress: address(_tokens[i]),\n                                                destAmount: destqty\n                                                }));\n                msgValue = msgValue.sub(quota);\n                emit kybertrade(address(ETH_TOKEN_ADDRESS),quota, address(_tokens[i]), destqty);\n            }\n        userBalance[_account][address(ETH_TOKEN_ADDRESS)] = userBalance[_account][address(ETH_TOKEN_ADDRESS)].add(msgValue);\n        userInvestments[_account].push(Investment({\n                                        timestamp: now,\n                                        depositedBy: msg.sender,\n                                        srcTokenAddress: address(ETH_TOKEN_ADDRESS),\n                                        srcAmount: msgValue,\n                                        destTokenAddress: address(ETH_TOKEN_ADDRESS),\n                                        destAmount: msgValue\n                                        }));\n    }","contract":"Mementofund","time":0}]}